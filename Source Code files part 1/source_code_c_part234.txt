ete this;
    }

    return ulRef;
}

//
// IFusionBindLog
//

STDMETHODIMP CDebugLog::GetResultCode()
{
    return _hrResult;
}

STDMETHODIMP CDebugLog::GetBindLog(DWORD dwDetailLevel, LPWSTR pwzDebugLog,
                                   DWORD *pcbDebugLog)
{
    HRESULT                                  hr = S_OK;
    LISTNODE                                 pos = NULL;
    DWORD                                    dwCharsReqd;
    CDebugLogElement                        *pLogElem = NULL;

    if (!pcbDebugLog) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    pos = _listDbgMsg.GetHeadPosition();
    if (!pos) {
        // No entries in debug log!
        hr = S_FALSE;
        goto Exit;
    }

    // Calculate total size (entries + new line chars + NULL)

    dwCharsReqd = 0;
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLevel) {
            dwCharsReqd += lstrlenW(pLogElem->_pszMsg) * sizeof(WCHAR);
            dwCharsReqd += sizeof(L"\r\n");
        }
    }

    dwCharsReqd += 1; // NULL char

    if (!pwzDebugLog || *pcbDebugLog < dwCharsReqd) {
        *pcbDebugLog = dwCharsReqd;

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pwzDebugLog = L'\0';

    pos = _listDbgMsg.GetHeadPosition();
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLevel) {
            StrCatW(pwzDebugLog, pLogElem->_pszMsg);
            StrCatW(pwzDebugLog, L"\r\n");
        }
    }

    ASSERT((DWORD)lstrlenW(pwzDebugLog) * sizeof(WCHAR) < dwCharsReqd);

Exit:
    return hr;
}                                    

//
// CDebugLog helpers
//

HRESULT CDebugLog::SetResultCode(HRESULT hr)
{
    _hrResult = hr;

    return S_OK;
}

HRESULT CDebugLog::DebugOut(DWORD dwDetailLvl, DWORD dwResId, ...)
{
    HRESULT                                  hr = S_OK;
    va_list                                  args;
    LPWSTR                                   wzFormatString = NULL;
    LPWSTR                                   wzDebugStr = NULL;

    wzFormatString = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzFormatString) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzDebugStr = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzDebugStr) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    wzFormatString[0] = L'\0';

    if (!WszLoadString(g_hInst, dwResId, wzFormatString, MAX_DBG_STR_LEN)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    va_start(args, dwResId);
    wvnsprintfW(wzDebugStr, MAX_DBG_STR_LEN, wzFormatString, args);
    va_end(args);

    hr = LogMessage(dwDetailLvl, wzDebugStr, FALSE, TRUE);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzDebugStr);
    SAFEDELETEARRAY(wzFormatString);

    return hr;
}

HRESULT CDebugLog::LogMessage(DWORD dwDetailLvl, LPCWSTR wzDebugStr, BOOL bPrepend, BOOL bEscapeEntities)
{
    HRESULT                                  hr = S_OK;
    CDebugLogElement                        *pLogElem = NULL;
    
    hr = CDebugLogElement::Create(dwDetailLvl, wzDebugStr, bEscapeEntities, &pLogElem);
    if (FAILED(hr)) {
        goto Exit;
    }

    _dwNumEntries += 1;

    if (bPrepend) {
        _listDbgMsg.AddHead(pLogElem);
    }
    else {
        _listDbgMsg.AddTail(pLogElem);
    }

Exit:
    return hr;    
}

HRESULT CDebugLog::DumpDebugLog(DWORD dwDetailLvl, HRESULT hrLog)
{
    HRESULT                                    hr = S_OK;
    HANDLE                                     hFile = INVALID_HANDLE_VALUE;
    LISTNODE                                   pos = NULL;
    LPWSTR                                     wzUrlName=NULL;
    CDebugLogElement                          *pLogElem = NULL;
    WCHAR                                     *wzExtension = L"HTM";
    WCHAR                                      wzFileName[MAX_PATH];
    WCHAR                                      wzSiteName[MAX_PATH];
    WCHAR                                      wzAppLogDir[MAX_PATH];
    LPWSTR                                     wzEXEName = NULL;
    LPWSTR                                     wzResourceName = NULL;
    FILETIME                                   ftTime;
    FILETIME                                   ftExpireTime;
    DWORD                                      dwBytes;
    DWORD                                      dwSize;
    BOOL                                       bRet;
    CCriticalSection                           cs(&g_csBindLog);

    if (!g_dwLogFailures && !g_dwForceLog) {
        return S_FALSE;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }

    pos = _listDbgMsg.GetHeadPosition();
    if (!pos) {
        hr = S_FALSE;
        goto Exit;
    }

    wzUrlName = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzUrlName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Build the log entry URL and Wininet cache file
    
    wnsprintfW(wzUrlName, MAX_URL_LENGTH, L"?FusionBindError!exe=%ws!name=%ws", _wzEXEName, _pwzAsmName);

    if (_bLogToWininet) {
        // Replace all characters > 0x80 with '?'
    
        dwSize = lstrlenW(wzUrlName);
        for (unsigned i = 0; i < dwSize; i++) {
            if (wzUrlName[i] > 0x80) {
                wzUrlName[i] = L'?';
            }
        }
        
        bRet = CreateUrlCacheEntryW(wzUrlName, 0, wzExtension, wzFileName, 0);
        if (!bRet) {
            goto Exit;
        }
    }
    else {
        BOOL                        bExists;

        wnsprintfW(wzAppLogDir, MAX_PATH, L"%ws\\%ws", _szLogPath, _wzEXEName);

        hr = CheckFileExistence(wzAppLogDir, &bExists);
        if (FAILED(hr)) {
            goto Exit;
        }
        else if (!bExists) {
            BOOL b;

            b = CreateDirectory(wzAppLogDir, NULL);
            if (!b) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }

        if (PathIsURLW(_pwzAsmName)) {
            // This was a where-ref bind. We can't spit out a filename w/
            // the URL of the bind because the URL has invalid filename chars.
            // The best we can do is show that it was a where-ref bind, and
            // give the filename, and maybe the site.

            dwSize = MAX_PATH;
            hr = UrlGetPartW(_pwzAsmName, wzSiteName, &dwSize, URL_PART_HOSTNAME, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            wzResourceName = PathFindFileName(_pwzAsmName);

            ASSERT(wzResourceName);

            if (!lstrlenW(wzSiteName)) {
                lstrcpyW(wzSiteName, L"LocalMachine");
            }

            wnsprintfW(wzFileName, MAX_PATH, L"%ws\\FusionBindError!exe=%ws!name=WhereRefBind!Host=(%ws)!FileName=(%ws).HTM",
                       wzAppLogDir, _wzEXEName, wzSiteName, wzResourceName);
        }
        else {
            wnsprintfW(wzFileName, MAX_PATH, L"%ws\\FusionBindError!exe=%ws!name=%ws.HTM", wzAppLogDir, _wzEXEName, _pwzAsmName);
        }
    }

    // Create the and write the log file

    hr = CreateLogFile(&hFile, wzFileName, _wzEXEName, hrLog);
    if (FAILED(hr)) {
        goto Exit;
    }

    pos = _listDbgMsg.GetHeadPosition();
    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        ASSERT(pLogElem);

        if (pLogElem->_dwDetailLvl <= dwDetailLvl) {
            pLogElem->Dump(hFile);
            WriteFile(hFile, DEBUG_LOG_NEW_LINE, sizeof(DEBUG_LOG_NEW_LINE) - 1,
                      &dwBytes, NULL);
        }
    }

    // Close the log file and commit the wininet cache entry

    hr = CloseLogFile(&hFile);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_bLogToWininet) {
        GetSystemTimeAsFileTime(&ftTime);
        ftExpireTime.dwLowDateTime = (DWORD)0;
        ftExpireTime.dwHighDateTime = (DWORD)0;
        
        bRet = CommitUrlCacheEntryW(wzUrlName, wzFileName, ftExpireTime, ftTime,
                                    NORMAL_CACHE_ENTRY, NULL, 0, NULL, 0);
        if (!bRet) {
            goto Exit;
        }
        
    }

Exit:
    cs.Unlock();
    SAFEDELETEARRAY(wzUrlName);

    return hr;
}

HRESULT CDebugLog::CloseLogFile(HANDLE *phFile)
{
    HRESULT                               hr = S_OK;
    CDebugLogElement                     *pLogElem = NULL;

    if (!phFile) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    hr = CDebugLogElement::Create(0, DEBUG_LOG_HTML_END, FALSE, &pLogElem);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pLogElem->Dump(*phFile);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    if (*phFile != INVALID_HANDLE_VALUE) {
        CloseHandle(*phFile);
        *phFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}

HRESULT CDebugLog::CreateLogFile(HANDLE *phFile, LPCWSTR wzFileName,
                                 LPCWSTR wzEXEName, HRESULT hrLog)
{
    HRESULT                              hr = S_OK;
    SYSTEMTIME                           systime;
    LPWSTR                               pwzFormatMessage = NULL;
    DWORD                                dwFMResult = 0;
    LPWSTR                               wzBuffer = NULL;
    LPWSTR                               wzBuf = NULL;
    LPWSTR                               wzResultText = NULL;
    WCHAR                                wzDateBuffer[MAX_DATE_LEN];
    WCHAR                                wzTimeBuffer[MAX_DATE_LEN];

    if (!phFile || !wzFileName || !wzEXEName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzBuffer = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzBuf = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzResultText = NEW(WCHAR[MAX_DBG_STR_LEN]);
    if (!wzResultText) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *phFile = CreateFile(wzFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (*phFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!_bWroteDetails) {
    
        // Details
    
        if (!WszLoadString(g_hInst, ID_FUSLOG_DETAILED_LOG, wzBuffer, MAX_DBG_STR_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        LogMessage(0, wzBuffer, TRUE, TRUE);
        
        // Executable path
    
        if (!WszLoadString(g_hInst, ID_FUSLOG_EXECUTABLE, wzBuf, MAX_DBG_STR_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, L"%ws %ws", wzBuf, g_wzEXEPath);
        LogMessage(0, wzBuffer, TRUE, TRUE);
        
        // Fusion.dll path
        
        if (!WszLoadString(g_hInst, ID_FUSLOG_FUSION_DLL_PATH, wzBuf, MAX_DBG_STR_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, L"%ws %ws", wzBuf, g_FusionDllPath);
        LogMessage(0, wzBuffer, TRUE, TRUE);
        
        // Bind result and FormatMessage text
        
        if (!WszLoadString(g_hInst, ID_FUSLOG_BIND_RESULT_TEXT, wzResultText, MAX_DBG_STR_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
            
        dwFMResult = WszFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_FROM_SYSTEM, 0, hrLog, 0,
                                    (LPWSTR)&pwzFormatMessage, 0, NULL);
        if (dwFMResult) {                               
            wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, wzResultText, hrLog, pwzFormatMessage);
        }
        else {
            WCHAR                             wzNoDescription[MAX_DBG_STR_LEN];
    
            if (!WszLoadString(g_hInst, ID_FUSLOG_NO_DESCRIPTION, wzNoDescription, MAX_DBG_STR_LEN)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            
            wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, wzResultText, hrLog, wzNoDescription);
        }
    
        LogMessage(0, wzBuffer, TRUE, TRUE);
    
        // Success/fail
        
        if (SUCCEEDED(hrLog)) {
            if (!WszLoadString(g_hInst, ID_FUSLOG_OPERATION_SUCCESSFUL, wzBuffer, MAX_DBG_STR_LEN)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;;
            }
    
            LogMessage(0, wzBuffer, TRUE, TRUE);
        }
        else {
            if (!WszLoadString(g_hInst, ID_FUSLOG_OPERATION_FAILED, wzBuffer, MAX_DBG_STR_LEN)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;;
            }
    
            LogMessage(0, wzBuffer, TRUE, TRUE);
        }
    
        // Header text
    
        GetLocalTime(&systime);
    
        if (!GetDateFormatWrapW(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, wzDateBuffer, MAX_DATE_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        
        if (!GetTimeFormatWrapW(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, wzTimeBuffer, MAX_DATE_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        if (!WszLoadString(g_hInst, ID_FUSLOG_HEADER_TEXT, wzBuf, MAX_DBG_STR_LEN)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
        wnsprintfW(wzBuffer, MAX_DBG_STR_LEN, L"%ws (%ws @ %ws) ***\r\n", wzBuf, wzDateBuffer, wzTimeBuffer);
        LogMessage(0, wzBuffer, TRUE, TRUE);
        
        // HTML start/end
    
        LogMessage(0, DEBUG_LOG_HTML_START, TRUE, FALSE);
        LogMessage(0, DEBUG_LOG_MARK_OF_THE_WEB, TRUE, FALSE);
        LogMessage(0, DEBUG_LOG_HTML_META_LANGUAGE, TRUE, FALSE);

        _bWroteDetails = TRUE;
    }
    
Exit:
    if (pwzFormatMessage) {
        LocalFree(pwzFormatMessage);
    }

    SAFEDELETEARRAY(wzBuffer);
    SAFEDELETEARRAY(wzBuf);
    SAFEDELETEARRAY(wzResultText);

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\xmldefs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    XmlDefs.h

Abstract:

    Defines for XML used in fusion policies

Author:

    Freddie L. Aaron (FredA) 01-Feb-2001

Revision History:

--*/

#define RTM_CORVERSION                      L"v1.0.3705"
#define XML_COMMENT                         L"//comment()"
#define XML_TEXT                            L"//text()"

#define XML_COMMENTNODE_NAME                L"#comment"
#define XML_COMMENTLOOK                     L"<!--"

#define XML_XMLNS                           L"xmlns"
#define XML_CONFIGURATION_KEY               L"configuration"
#define XML_STARTUP_KEY                     L"startup"
#define XML_REQUIREDRUNTIME_KEY             L"requiredRuntime"
#define XML_SUPPORTEDRUNTIME_KEY            L"supportedRuntime"
#define XML_RUNTIME_KEY                     L"runtime"
#define XML_ASSEMBLYBINDINGS_KEY            L"assemblyBinding"
#define XML_DEPENDENTASSEMBLY_KEY           L"dependentAssembly"
#define XML_ASSEMBLYIDENTITY_KEY            L"assemblyIdentity"
#define XML_BINDINGREDIRECT_KEY             L"bindingRedirect"
#define XML_PUBLISHERPOLICY_KEY             L"publisherPolicy"

#define ASM_NAMESPACE_URI                   L"urn:schemas-microsoft-com:asm.v1"
#define XML_NAR_NAMESPACE_NAME              L"asm_ns_v1"
#define XML_NAR_NAMESPACE_COLON             XML_NAR_NAMESPACE_NAME L":"
#define XML_NAMESPACEURI                    XML_XMLNS L":" XML_NAR_NAMESPACE_NAME L"='" ASM_NAMESPACE_URI L"'"
#define XML_XPATH_SEP                       L"/"
#define XML_CONFIGURATION                   XML_XPATH_SEP XML_CONFIGURATION_KEY
#define XML_STARTUP                         XML_CONFIGURATION XML_XPATH_SEP XML_STARTUP_KEY
#define XML_REQUIRED_RUNTIME                XML_STARTUP XML_XPATH_SEP XML_REQUIREDRUNTIME_KEY
#define XML_SUPPORTED_RUNTIME               XML_STARTUP XML_XPATH_SEP XML_SUPPORTEDRUNTIME_KEY
#define XML_RUNTIME                         XML_CONFIGURATION XML_XPATH_SEP XML_RUNTIME_KEY
#define XML_ASSEMBLYBINDINGS                XML_RUNTIME XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_ASSEMBLYBINDINGS_KEY
#define XML_SPECIFICASSEMBLYBINDINGS        XML_NAR_NAMESPACE_COLON XML_ASSEMBLYBINDINGS_KEY
#define XML_DEPENDENTASSEMBLY               XML_ASSEMBLYBINDINGS XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_DEPENDENTASSEMBLY_KEY
#define XML_SPECIFICDEPENDENTASSEMBLY       XML_NAR_NAMESPACE_COLON XML_DEPENDENTASSEMBLY_KEY
#define XML_ASSEMBLYIDENTITY                XML_DEPENDENTASSEMBLY XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_ASSEMBLYIDENTITY_KEY
#define XML_SPECIFICASSEMBLYIDENTITY        XML_NAR_NAMESPACE_COLON XML_ASSEMBLYIDENTITY_KEY
#define XML_BINDINGREDIRECT                 XML_DEPENDENTASSEMBLY XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_BINDINGREDIRECT_KEY
#define XML_SPECIFICBINDINGREDIRECT         XML_NAR_NAMESPACE_COLON XML_BINDINGREDIRECT_KEY
#define XML_PUBLISHERPOLICY                 XML_DEPENDENTASSEMBLY XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_PUBLISHERPOLICY_KEY
#define XML_SPECIFICPUBLISHERPOLICY         XML_NAR_NAMESPACE_COLON XML_PUBLISHERPOLICY_KEY
#define XML_SAFEMODE_PUBLISHERPOLICY        XML_ASSEMBLYBINDINGS XML_XPATH_SEP XML_NAR_NAMESPACE_COLON XML_PUBLISHERPOLICY_KEY
#define XML_AllNAMESPACECHILDREN            XML_NAR_NAMESPACE_COLON XML_XPATH_SEP L"*"

#define XML_ATTRIBUTE_NAME                  L"name"
#define XML_ATTRIBUTE_PUBLICKEYTOKEN        L"publicKeyToken"
#define XML_ATTRIBUTE_CULTURE               L"culture"
#define XML_ATTRIBUTE_OLDVERSION            L"oldVersion"
#define XML_ATTRIBUTE_NEWVERSION            L"newVersion"
#define XML_ATTRIBUTE_APPLIESTO             L"appliesTo"
#define XML_ATTRIBUTE_APPLY                 L"apply"
#define XML_ATTRIBUTE_APPLY_YES             L"yes"
#define XML_ATTRIBUTE_APPLY_NO              L"no"

#define XML_ATTRIBUTE_VERSION               L"version"
#define XML_ATTRIBUTE_SAFEMODE              L"safemode"
#define XML_ATTRIBUTE_TRUE                  L"true"
#define XML_ATTRIBUTE_FALSE                 L"false"

#define SZXML_MALFORMED_ERROR               L"The manifest '%ws' may be malformed, unable to find '%ws' tag!"
#define XML_SPACER                          L"\r\n"
#define XML_BEGIN_DEPENDENT_ASM             L"   <dependentAssembly>\r\n"
#define XML_ASSEMBLY_IDENT                  L"    <assemblyIdentity name=\"%ws\" publicKeyToken=\"%ws\" culture=\"%ws\"/>\r\n"
#define XML_BINDING_REDIRECT                L"    <bindingRedirect oldVersion=\"%ws\" newVersion=\"%ws\"/>\r\n"
#define XML_PUBPOLICY_YES                   L"    <publisherPolicy apply=\"yes\"/>\r\n"
#define XML_PUBPOLICY_NO                    L"    <publisherPolicy apply=\"no\"/>\r\n"
#define XML_END_DEPENDENT_ASM               L"   </dependentAssembly>\r\n"
#define XML_CONFIG_TEMPLATE_COMPLETE        L"<configuration><runtime><assemblyBinding xmlns=\"%ws\"></assemblyBinding></runtime></configuration>"
#define XML_CONFIG_TEMPLATE_BEGIN           L"<configuration>\r\n <runtime>\r\n  <assemblyBinding appliesTo=\"%ws\" xmlns=\"urn:schemas-microsoft-com:asm.v1\">\r\n"
#define XML_CONFIG_TEMPLATE_BEGIN_STARTUP   L"<configuration>\r\n <startup>\r\n  <supportedRuntime version=\"%ws\"/>\r\n </startup>\r\n <runtime>\r\n  <assemblyBinding appliesTo=\"%ws\" xmlns=\"urn:schemas-microsoft-com:asm.v1\">\r\n"
#define XML_CONFIG_TEMPLATE_END             L"  </assemblyBinding>\r\n </runtime>\r\n</configuration>\r\n"

// Error Codes
#define NAR_E_SUCCESS                   S_OK
#define NAR_E_NO_MANAGED_APPS_FOUND     EMAKEHR(0x1075)
#define NAR_E_NO_POLICY_CHANGE_FOUND    EMAKEHR(0x1076)
#define NAR_E_USER_CANCELED             EMAKEHR(0x1077)
#define NAR_E_RESTORE_APP               EMAKEHR(0x1078)
#define NAR_E_UNDO_APP                  EMAKEHR(0x1079)
#define NAR_E_FIX_APP                   EMAKEHR(0x1080)
#define NAR_E_RESTORE_FAILED            EMAKEHR(0x1081)
#define NAR_E_SAFEMODE_FAILED           EMAKEHR(0x1082)
#define NAR_E_INVALID_ARG               EMAKEHR(0x1083)
#define NAR_E_OUTOFMEMORY               EMAKEHR(0x1084)
#define NAR_E_GETHISTORYREADERS         EMAKEHR(0x1085)
#define NAR_E_ADVANCED_MODE             EMAKEHR(0x1086)
#define NAR_E_UNEXPECTED                EMAKEHR(0x1087)
#define NAR_E_ADMIN_POLICY_SET          EMAKEHR(0x1088)
#define NAR_E_MALFORMED_XML             EMAKEHR(0x1089)
#define NAR_E_RUNTIME_VERSION           EMAKEHR(0x1090)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\cpl\arm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
*
*
*    PROGRAM: ARM.cpp
*
*    PURPOSE: Application Policy Manager Applet
*
*
*    Created by Fred Aaron (Freda)
*
*    FUNCTIONS:
*
*        DllMain()
*        InitAPMApplet()
*        TermAPMApplet()
*        CPIApplet()
*
****************************************************************************/

#define GETCORSYSTEMDIRECTORY_FN_NAME   "GetCORSystemDirectory"
#define EXECUTENAR_FN_NAME              "PolicyManager"
#define SZ_SHFUSION_DLL_NAME            TEXT("\\Shfusion.dll")
#define SZ_MSCOREE_DLL_NAME             TEXT("Mscoree.dll")

#include <windows.h>
#include <shellapi.h>
#include <cpl.h>
#include "resource.h"

#define NUM_APPLETS 1
#define EXE_NAME_SIZE 14

typedef HRESULT (__stdcall *PFNGETCORSYSTEMDIRECTORY) (LPWSTR, DWORD, LPDWORD);
typedef HRESULT (__stdcall *PFNEXECUTENAR) (HWND hWndParent, LPWSTR pwzFullyQualifiedAppPath, LPWSTR pwzAppName, LPWSTR pwzCulture);

HINSTANCE hModule = NULL;

char szCtlPanel[30];

/****************************************************************************
*
*    FUNCTION: DllMain(PVOID, ULONG, PCONTEXT)
*
*    PURPOSE: Win32 Initialization DLL
*
****************************************************************************/
BOOL WINAPI DllMain(IN HINSTANCE hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{
    if (ulReason != DLL_PROCESS_ATTACH)
    {
        return TRUE;
    }
    else
    {
        hModule = hmod;
    }

    return TRUE;

    UNREFERENCED_PARAMETER(pctx);
}

/****************************************************************************
*
*    FUNCTION: InitAPMApplet (HWND)
*
*    PURPOSE: loads the caption string for the Control Panel
*
****************************************************************************/
BOOL InitAPMApplet (HWND hwndParent)
{
    UNREFERENCED_PARAMETER(hwndParent);

    LoadStringA(hModule, CPCAPTION, szCtlPanel, sizeof(szCtlPanel));
    return TRUE;
}

/****************************************************************************
*
*    FUNCTION: TermAPMApplet()
*
*    PURPOSE: termination procedure for the stereo applets
*
****************************************************************************/
void TermAPMApplet()
{
    return;
}

/****************************************************************************
*
*    FUNCTION: void ExecuteAPM(DWORD dwFlags)
*
*    PURPOSE: Launch the policy manager located in shfusion.dll
*
****************************************************************************/
void ExecuteARM(HWND hWndParent, LPWSTR pwzFullyQualifiedAppPath, LPWSTR pwzAppName)
{
    HMODULE hShfusion = NULL;

    // Implement delay loading of Shfusion.dll
    WCHAR       szFusionPath[MAX_PATH];
    DWORD       ccPath = MAX_PATH;
    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;

    // Find out where the current version of URT is installed
    HMODULE hEEShim = LoadLibrary(SZ_MSCOREE_DLL_NAME);
    if(hEEShim != NULL)
    {
        pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY)
            GetProcAddress(hEEShim, GETCORSYSTEMDIRECTORY_FN_NAME);

        // Get the loaded path
        if( (pfnGetCorSystemDirectory != NULL) && SUCCEEDED(pfnGetCorSystemDirectory(szFusionPath, MAX_PATH, &ccPath)) )
        {
            if (lstrlenW(szFusionPath) + lstrlen(SZ_SHFUSION_DLL_NAME) + 1 >= MAX_PATH) {
                FreeLibrary(hEEShim);
                return;
            }

            // Attempt to load Shfusion.dll now
            lstrcatW(szFusionPath, SZ_SHFUSION_DLL_NAME);
            hShfusion = LoadLibrary(szFusionPath);
        }

        FreeLibrary(hEEShim);
        hEEShim = NULL;
    }

    if(hShfusion != NULL) {
        // Load Shfusions wizard
        PFNEXECUTENAR   pfnExecuteNAR = (PFNEXECUTENAR) GetProcAddress(hShfusion, EXECUTENAR_FN_NAME);
        
        if(pfnExecuteNAR != NULL) {
            pfnExecuteNAR(hWndParent, pwzFullyQualifiedAppPath, pwzAppName, NULL);
        }

        FreeLibrary(hShfusion);
    }
}

/****************************************************************************
*
*    FUNCTION: CPIApplet(HWND, UINT, LONG, LONG)
*
*    PURPOSE: Processes messages for control panel applet
*
****************************************************************************/
LONG CALLBACK CPlApplet (HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPNEWCPLINFOA   lpNewCPlInfo;
    LPCPLINFO       lpCPlInfo;
    static int      iInitCount = 0;
            
    switch (uMsg) {
        case CPL_INIT:              // first message, sent once
            if (!iInitCount)
            {
                if (!InitAPMApplet(hwndCPL))
                    return FALSE;
            }
            iInitCount++;
            return TRUE;

        case CPL_GETCOUNT:          // second message, sent once
            return (LONG)NUM_APPLETS;
            break;

        case CPL_NEWINQUIRE:        // third message, sent once per app
            lpNewCPlInfo = reinterpret_cast<LPNEWCPLINFOA>(lParam2);
            lpNewCPlInfo->dwSize = (DWORD) sizeof(NEWCPLINFOA);
            lpNewCPlInfo->dwFlags = 0;
            lpNewCPlInfo->dwHelpContext = 0;
            lpNewCPlInfo->lData = 0;
            lpNewCPlInfo->hIcon = LoadIconA(hModule, (LPCSTR) MAKEINTRESOURCE(ARM_ICON));
            lpNewCPlInfo->szHelpFile[0] = '\0';

            LoadStringA(hModule, ARM_CPL_NAME, lpNewCPlInfo->szName, 32);
            LoadStringA(hModule, ARM_CPL_CAPTION, lpNewCPlInfo->szInfo, 64);
            break;

        case CPL_INQUIRE:        // for backward compat & speed
            lpCPlInfo = reinterpret_cast<LPCPLINFO>(lParam2);
            lpCPlInfo->lData = 0;
            lpCPlInfo->idIcon = ARM_ICON; // MAKEINTRESOURCE(ARM_ICON);
            lpCPlInfo->idName = ARM_CPL_NAME; // MAKEINTRESOURCE(ARM_CPL_NAME);
            lpCPlInfo->idInfo = ARM_CPL_CAPTION; // MAKEINTRESOURCE(ARM_CPL_CAPTION);
            break;


        case CPL_SELECT:            // application icon selected
            break;


        case CPL_DBLCLK:            // application icon double-clicked
            ExecuteARM(GetDesktopWindow(), NULL, NULL);
            break;

         case CPL_STOP:              // sent once per app. before CPL_EXIT
            break;

         case CPL_EXIT:              // sent once before FreeLibrary called
            iInitCount--;
            if (!iInitCount)
                TermAPMApplet();
            break;

         default:
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\xmlmanager.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    XmlManager.cpp

Abstract:

    Mangement code for handling XML manifest files

Author:

    Freddie L. Aaron (FredA) 01-Feb-2001

Revision History:
    Jan 2002 - Added capability to respect CLR runtime version

--*/

#include "stdinc.h"
#include <msxml2.h>

#include "XmlManager.h"
#include "XmlDefs.h"
#include "comutil.h"        // _bstr_t && _variant_t

// APP.CFG Policy strings
const WCHAR     wszARMName[]            = { L".NET Application Restore"};
const WCHAR     wszArmRollBackBlock[]   = { L".NET Application Restore RollBackBlock #%ld %ws"};
const WCHAR     wszArmEntryBegin[]      = { L".NET Application Restore BeginBlock #%ld %ld.%ld %ws"};
const WCHAR     wszArmEntryEnd[]        = { L".NET Application Restore EndBlock #%ld"};
const WCHAR     wszArmEntryBeginNoVal[] = { L".NET Application Restore BeginBlock #"};
const WCHAR     wszArmEntryEndNoVal[]   = { L".NET Application Restore EndBlock #"};
const WCHAR     wszNar00Extension[]     = { L"NAR00" };
const WCHAR     wszNar01Extension[]     = { L"NAR01" };

// Hash read buffer size
#define READ_FILE_BUFFER_SIZE           10 * 1024       // 10k at a time to read

static HMODULE hMsXml;

// Globals
CSmartRef<IClassFactory>    g_XmlDomClassFactory;
WCHAR                       g_wcNodeSpaceChar;
DWORD                       g_dwNodeSpaceSize;

class __declspec(uuid("2933BF81-7B36-11d2-B20E-00C04F983E60")) priv_MSXML_DOMDocument20;
class __declspec(uuid("f5078f1b-c551-11d3-89b9-0000f81fe221")) priv_MSXML_DOMDocument26;
class __declspec(uuid("f5078f32-c551-11d3-89b9-0000f81fe221")) priv_MSXML_DOMDocument30;

#undef SPEWNODENAME
#undef SPEWNODEXML

#ifdef DEBUG
    #define SPEWNODENAME(x) { if(x) { BSTR bstrNodeName; x->get_nodeName(&bstrNodeName); MyTraceW(bstrNodeName); SAFESYSFREESTRING(bstrNodeName); } }
    #define SPEWNODEXML(x) { if(x) { BSTR bstrNodeXml; x->get_xml(&bstrNodeXml); MyTraceW(bstrNodeXml); SAFESYSFREESTRING(bstrNodeXml); } }
#else
    #define SPEWNODENAME(x)
    #define SPEWNODEXML(x)
#endif

HRESULT PrettyFormatXmlDocument(CSmartRef<IXMLDOMDocument2> &Document);
HRESULT PrettyFormatXML(CSmartRef<IXMLDOMDocument2> &pXMLDoc, CSmartRef<IXMLDOMNode> &pRootNode, LONG dwLevel);
HRESULT SimplifySaveXmlDocument(CSmartRef<IXMLDOMDocument2> &Document, BOOL fPrettyFormat, LPWSTR pwszSourceName);
HRESULT OrderDocmentAssemblyBindings(CSmartRef<IXMLDOMDocument2> &Document, LPWSTR pwzSourceName, BOOL *pfDisposition);
HRESULT HasAssemblyBindingAppliesTo(CSmartRef<IXMLDOMDocument2> &Document, BOOL *pfHasAppliesTo);

// **************************************************************************
BOOL InitializeMSXML(void)
{
    IClassFactory *pFactory = NULL;
    HRESULT hr;
    typedef HRESULT (*tdpfnDllGetClassObject)(REFCLSID, REFIID, LPVOID*);
    tdpfnDllGetClassObject pfnGCO;
    
    hMsXml = NULL;

    // Attempt to load XML in highest version possible
    if ( hMsXml == NULL ) {
        hMsXml = WszLoadLibraryEx( L"msxml3.dll", NULL, 0 );
        if ( hMsXml == NULL ) {
            MyTrace("Unable to load msxml3, trying msxml2");
            hMsXml = WszLoadLibraryEx( L"msxml2.dll", NULL, 0 );
            if ( hMsXml == NULL ) {
                MyTrace("Very Bad Things - no msxml exists on this machine?");
                    return FALSE;
            }
        }
    }

    if( (pfnGCO = (tdpfnDllGetClassObject) GetProcAddress( hMsXml, "DllGetClassObject" )) == NULL ) {
        return FALSE;
    }
    
    hr = pfnGCO( __uuidof(priv_MSXML_DOMDocument30), IID_IClassFactory, (void**)&pFactory );
    if ( FAILED(hr) ) {
        MyTrace("Can't load version 3.0, trying 2.6");

        hr = pfnGCO( __uuidof(priv_MSXML_DOMDocument26), IID_IClassFactory, (void**)&pFactory );
        if ( FAILED( hr ) ) {
            MyTrace("Can't load version 2.6, trying 2.0");

            hr = pfnGCO( __uuidof(priv_MSXML_DOMDocument20), IID_IClassFactory, (void**)&pFactory );
            if ( FAILED( hr ) ) {
                MyTrace("Poked: no XML v2.0");
                return FALSE;
            }
        }
    }

    g_XmlDomClassFactory = pFactory;
    pFactory->Release();

    return TRUE;
}

// **************************************************************************/
HRESULT GetExeModulePath(IHistoryReader *pReader, LPWSTR pwszSourceName, DWORD dwSize)
{
    if(pwszSourceName && dwSize) {
        *pwszSourceName = L'\0';
        if( FAILED(pReader->GetEXEModulePath(pwszSourceName, &dwSize))) {
            MyTrace("GetExeModulePath Failed");
            return E_FAIL;
        }
        return S_OK;
    }

    ASSERT(0);
    return E_INVALIDARG;
}

// **************************************************************************/
#define MAX_BUFFER_SIZE 8192
BOOL SimpleHashRoutine(HCRYPTHASH hHash, HANDLE hFile)
{
    BYTE *pbBuffer = NULL;
    DWORD dwDataRead;
    BOOL b = FALSE;
    BOOL bKeepReading = TRUE;
    LPWSTR ws = NULL;

    ws = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!ws) {
        return FALSE;
    }

    if(( pbBuffer = NEW(BYTE[READ_FILE_BUFFER_SIZE]) ) != NULL ) {
        while(bKeepReading) {
            b = ReadFile( hFile, pbBuffer, READ_FILE_BUFFER_SIZE, &dwDataRead, NULL );
            if( b && (dwDataRead == 0) ) {
                bKeepReading = FALSE;
                b = TRUE;
                continue;
            }
            else if(!b) {
                *ws = '\0';
                WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), ws, MAX_BUFFER_SIZE, NULL);
                MyTraceW(ws);
                bKeepReading = FALSE;
                continue;
            }
            
            if(!CryptHashData(hHash, pbBuffer, dwDataRead, 0)) {
                *ws = '\0';
                WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), ws, MAX_BUFFER_SIZE, NULL);
                MyTraceW(ws);

                b = FALSE;
                break;
            }
        }

        SAFEDELETEARRAY(pbBuffer);
    }

    SAFEDELETEARRAY(ws);

    return b;
}

// **************************************************************************/
HRESULT GetFileHash(ALG_ID PreferredAlgorithm, LPWSTR pwzFileName, LPBYTE *pHashBytes, LPDWORD pdwSize)
{
    HRESULT         hr = E_FAIL;
    BOOL            fSuccessCode = FALSE;
    HCRYPTPROV      hProvider;
    HCRYPTHASH      hCurrentHash;
    HANDLE          hFile;

    // Initialization
    hProvider = (HCRYPTPROV)INVALID_HANDLE_VALUE;
    hCurrentHash = (HCRYPTHASH)INVALID_HANDLE_VALUE;
    hFile = INVALID_HANDLE_VALUE;

    if(!lstrlen(pwzFileName)) {
        return E_INVALIDARG;
    }

    //
    // First try and open the file.  
    //
    if( (hFile = WszCreateFile(pwzFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL)) == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }
    
    //
    // Create a cryptological provider that supports everything RSA needs.
    // 
    if(WszCryptAcquireContext(&hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        //
        // We'll be using SHA1 for the file hash
        //
        if(CryptCreateHash(hProvider, PreferredAlgorithm, 0, 0, &hCurrentHash)) {
            fSuccessCode = SimpleHashRoutine( hCurrentHash, hFile );

            // We know the buffer is the right size, so we just call down to the hash parameter
            // getter, which will be smart and bop out (setting the pdwDestinationSize parameter)
            // if the user passed a silly parameter.
            //
            if( fSuccessCode ) {
                DWORD dwSize, dwDump;
                BYTE *pb = NULL;
                fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHSIZE, (BYTE*)&dwSize, &(dwDump=sizeof(dwSize)), 0 );
                if(fSuccessCode && ( pb = NEW(BYTE[dwSize]) ) != NULL ) {
                    fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHVAL, pb, &dwSize, 0);
                    if(fSuccessCode) {
                        *pdwSize = dwSize;
                        *pHashBytes = pb;
                        hr = S_OK;
                    }
                    else {
                        SAFEDELETEARRAY(pb);
                        *pdwSize = 0;
                        *pHashBytes = NULL;
                        MyTrace("GetFileHash - CryptGetHashParam failed!");
                    }
                }
            }
            else {
                MyTrace("GetFileHash - SimpleHashRoutine failed!");
            }
        }
        else {
            MyTrace("GetFileHash - CryptCreateHash failed!");
        }
    }
    else {
        MyTrace("GetFileHash - CryptAcquireContext failed!");
    }

    
    DWORD dwLastError = GetLastError();
    CloseHandle(hFile);

    if(hCurrentHash != (HCRYPTHASH)INVALID_HANDLE_VALUE) {
        CryptDestroyHash( hCurrentHash );
    }

    if(hProvider != (HCRYPTPROV)INVALID_HANDLE_VALUE) {
        CryptReleaseContext( hProvider, 0 );
    }

    SetLastError( dwLastError );

    return hr;
}

// **************************************************************************/
HRESULT SetRegistryHashKey(LPWSTR pwszSourceName, LPBYTE pByte, DWORD dwSize)
{
    HKEY    hkNarSubKey = NULL;
    HRESULT hr = E_FAIL;

    if( ERROR_SUCCESS == WszRegCreateKeyEx(FUSION_PARENT_KEY, SZ_FUSION_NAR_KEY, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkNarSubKey, NULL)) {
        if(ERROR_SUCCESS == WszRegSetValueEx(hkNarSubKey, pwszSourceName, 0, REG_BINARY, (CONST BYTE *) pByte, dwSize)) {
            hr = S_OK;
        }

        RegCloseKey(hkNarSubKey);
    }

    return S_OK;
}

// **************************************************************************/
HRESULT GetRegistryHashKey(LPWSTR pwszSourceName, LPBYTE *pByte, LPDWORD pdwSize)
{
    HRESULT hr = E_FAIL;
    HKEY    hkNarSubKey = NULL;
    DWORD   dwSizeNeeded = 0;
    DWORD   dwType = REG_BINARY;

    *pdwSize = 0;
    *pByte = NULL;

    if(ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_FUSION_NAR_KEY, 0, KEY_QUERY_VALUE, &hkNarSubKey)) {
        if(ERROR_SUCCESS == WszRegQueryValueEx(hkNarSubKey, pwszSourceName, 0, &dwType, NULL, &dwSizeNeeded)) {
            if(( *pByte = NEW(BYTE[dwSizeNeeded]) ) != NULL ) {
                if(ERROR_SUCCESS == WszRegQueryValueEx(hkNarSubKey, pwszSourceName, 0, &dwType, *pByte, &dwSizeNeeded)) {
                    *pdwSize = dwSizeNeeded;
                    hr = S_OK;
                }
            }
            else {
                hr = E_OUTOFMEMORY;
            }
        }
        RegCloseKey(hkNarSubKey);
    }

    return hr;
}

// **************************************************************************/
void GetRegistryNodeSpaceInfo(LPDWORD pdwChar, LPDWORD pdwSize)
{
    HRESULT hr = E_FAIL;
    HKEY    hkNarSubKey = NULL;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    // Set initial values
    *pdwChar = ' ';
    *pdwSize = 1;

    if(ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_FUSION_NAR_KEY, 0, KEY_QUERY_VALUE, &hkNarSubKey)) {

        // Get the character
        WszRegQueryValueEx(hkNarSubKey, SZ_FUSION_NAR_NODESPACECHAR_KEY, 0, &dwType, (LPBYTE)pdwChar, &dwSize);

        // Get the spacer amount
        WszRegQueryValueEx(hkNarSubKey, SZ_FUSION_NAR_NODESPACESIZE_KEY, 0, &dwType, (LPBYTE)pdwSize, &dwSize);

        RegCloseKey(hkNarSubKey);
    }
}

// **************************************************************************/
HRESULT KillRegistryHashKey(LPWSTR pwszSourceName)
{
    HKEY    hkNarSubKey = NULL;
    HRESULT hr = E_FAIL;

    if(ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_FUSION_NAR_KEY, 0, KEY_ALL_ACCESS, &hkNarSubKey)) {
        if(ERROR_SUCCESS == WszRegDeleteValue(hkNarSubKey, pwszSourceName)) {
            hr = S_OK;
        }
    }

    return hr;
}

// **************************************************************************/
HRESULT HasFileBeenModified(LPWSTR pwszSourceName)
{
    HRESULT     hr = S_OK;
    LPBYTE      pHashBytes = NULL;
    DWORD       dwHashSize;

    // Check to see if we have a hash entry
    if(SUCCEEDED(GetRegistryHashKey(pwszSourceName, &pHashBytes, &dwHashSize))) {
        if(dwHashSize) {
            // We actually have hash data
            LPBYTE      pCurrentHashBytes = NULL;
            DWORD       dwCurrentHashSize;

            if(SUCCEEDED(hr = GetFileHash(CALG_SHA1, pwszSourceName, &pCurrentHashBytes, &dwCurrentHashSize))) {
                // We got a hash, see if they match
                if(!memcmp(pCurrentHashBytes, pHashBytes, dwCurrentHashSize)) {
                    // Hashes match
                    MyTrace("HasFileBeenModified::Hashes for app.config vs registry match!");
                }
                else {
                    hr = E_FAIL;
                    MyTrace("HasFileBeenModified::Hashes do not match for app.config vs registry");
                }
            }
            else {
                hr = E_FAIL;
            }

            SAFEDELETEARRAY(pCurrentHashBytes);
        }
        SAFEDELETEARRAY(pHashBytes);
    }


    return hr;
}

// **************************************************************************/
//
// Takes version range (e.g. "1.0.0.0-5.0.0.0" ) with reference
// (e.g. "2.0.0.0") and brackets base version in 2 disinct ranges
// (e.g. "1.0.0.0-1.65535.65535.65535" "2.0.0.1-5.0.0.0")
HRESULT MakeVersionRanges(_bstr_t bstrRangedVer, _bstr_t bstrRefRange, _bstr_t *pbstrRange1, _bstr_t *pbstrRange2)
{
    LPWSTR      pStr;
    LPWSTR      pDeliniator;
    HRESULT     hr;
    ULONGLONG   ulRangeLo;
    ULONGLONG   ulRangeHi;
    ULONGLONG   ulRangeRef;

    // We have data?
    if(!bstrRangedVer.length()) {
        return E_INVALIDARG;
    }

    if(!bstrRefRange.length()) {
        return E_INVALIDARG;
    }

    // Get Versions
    pStr = bstrRangedVer;
    pDeliniator = StrStrIW(pStr, L"-");
    if(!pDeliniator) {
        return E_INVALIDARG;
    }

    // Get Low version
    *pDeliniator = L'\0';
    if(FAILED(hr = StringToVersion(pStr, &ulRangeLo))) {
        return hr;
    }

    // Get Hi version
    *pDeliniator = L'-';
    pStr = ++pDeliniator;
    if(FAILED(hr = StringToVersion(pStr, &ulRangeHi))) {
        return hr;
    }

    if(FAILED(hr = StringToVersion(bstrRefRange, &ulRangeRef))) {
        return hr;
    }

    // Check to see if our bstrRefRange is within our bstrRangedVer
    if(ulRangeRef >= ulRangeLo && ulRangeRef <= ulRangeHi) {

        WCHAR       wzRngLo[25];
        WCHAR       wzRngHi[25];
        BOOL        fReverse = FALSE;

        *wzRngLo = '\0';
        *wzRngHi = '\0';

        // Do low version range
        if(FAILED(hr = VersionToString(ulRangeLo, wzRngLo, ARRAYSIZE(wzRngLo), L'.'))) {
            return hr;
        }

        if(ulRangeRef - 1 > ulRangeLo) {
            if(FAILED(hr = VersionToString(ulRangeRef - 1, wzRngHi, ARRAYSIZE(wzRngHi), L'.'))) {
                return hr;
            }
        }

        if(lstrlen(wzRngHi)) {
            *pbstrRange1 = _bstr_t(wzRngLo) + _bstr_t("-") + _bstr_t(wzRngHi);
        }

        *wzRngLo = L'\0';
        *wzRngHi = L'\0';

        // Do high range
        if(FAILED(hr = VersionToString(ulRangeHi, wzRngHi, ARRAYSIZE(wzRngHi), L'.'))) {
            return hr;
        }

        if(ulRangeRef + 1 < ulRangeHi) {
            if(FAILED(hr = VersionToString(ulRangeRef + 1, wzRngLo, ARRAYSIZE(wzRngLo), L'.'))) {
                return hr;
            }
        }

        if(!lstrlen(wzRngLo)) {
            *pbstrRange2 = _bstr_t(wzRngLo);
        }
        else {
            *pbstrRange2 = _bstr_t(wzRngLo) + _bstr_t("-") + _bstr_t(wzRngHi);
        }
    }
    else {
        // Don't expect to hit this since we already have a bindingRedirect node
        // that isn't ranged. 
        ASSERT(0);
    }

    return S_OK;
}

// **************************************************************************/
BOOL IsVersionInRange(LPWSTR wzVersion, _bstr_t *pbstrRangedVersion)
{
    LPWSTR      pStr = NULL;
    LPWSTR      pDeliniator = NULL;
    ULONGLONG   ulRangeLo = 0;
    ULONGLONG   ulRangeHi = 0;
    ULONGLONG   ulRangeRef = 0;

    // Get Versions
    if(FAILED(StringToVersion(wzVersion, &ulRangeRef))) {
        return FALSE;
    }

    if(!pbstrRangedVersion || !pbstrRangedVersion->length()) {
        return FALSE;
    }

    pStr = *pbstrRangedVersion;
    pDeliniator = StrStrI(pStr, L"-");
    if(!pDeliniator) {
        return FALSE;
    }

    // Get Low version
    *pDeliniator = L'\0';
    if(FAILED(StringToVersion(pStr, &ulRangeLo))) {
        return FALSE;
    }

    // Get Hi version
    *pDeliniator = L'-';
    pStr = ++pDeliniator;
    if(FAILED(StringToVersion(pStr, &ulRangeHi))) {
        return FALSE;
    }

    // Check to see if our bstrRefRange is within our bstrRangedVer
    if(ulRangeRef >= ulRangeLo && ulRangeRef <= ulRangeHi) {
        return TRUE;
    }

    return FALSE;
}

// **************************************************************************/
LPWSTR CreatePad(BOOL fPreAppendXmlSpacer, BOOL fPostAppendXmlSpacer, int iWhiteSpaceCount)
{
    LPWSTR  pwz = NULL;
    DWORD   dwSize = 0;

    if(fPreAppendXmlSpacer) {
        dwSize += lstrlen(XML_SPACER);
    }

    if(fPostAppendXmlSpacer) {
        dwSize += lstrlen(XML_SPACER);
    }

    dwSize += iWhiteSpaceCount + 1;
    pwz = NEW(WCHAR[dwSize]);
    if(pwz) {
        LPWSTR pTmp = pwz;

        if(fPreAppendXmlSpacer) {
            StrCpy(pwz, XML_SPACER);
            pTmp += lstrlen(pwz);
        }

        for (int i = 0; i < iWhiteSpaceCount; i++, pTmp++)
            *pTmp = g_wcNodeSpaceChar;
        *pTmp = L'\0';

        if(fPostAppendXmlSpacer) {
            StrCat(pwz, XML_SPACER);
        }
    }

    return pwz;
}

// Remove all nodes from document of a particular type
// **************************************************************************/
void SimplifyRemoveAllNodes(CSmartRef<IXMLDOMDocument2> &Document, _bstr_t bstrNodeType)
{
    CSmartRef<IXMLDOMNodeList> listOfNodes;

    if(!Document || !bstrNodeType.length()) {
        return;
    }

    if(SUCCEEDED(Document->selectNodes(bstrNodeType, &listOfNodes)) ) {
        
        CSmartRef<IXMLDOMNode> node;

        listOfNodes->reset();
        //
        // And for each, process it
        while( SUCCEEDED(listOfNodes->nextNode(&node)) ) {
            CSmartRef<IXMLDOMNode>       parentNode;

            if(!node) {
                break;  // All done
            }

            node->get_parentNode(&parentNode);
            if(parentNode != NULL) {
                parentNode->removeChild(node, NULL);
                parentNode = NULL;
            }
            
            node = NULL;
        }
    }
}

// Remove all nodes from document of a particular type
// **************************************************************************/
void SimplifyRemoveAllNodes(CSmartRef<IXMLDOMNode> &RootNode, _bstr_t bstrNodeType)
{
    CSmartRef<IXMLDOMNodeList> listOfNodes;

    if(!RootNode || !bstrNodeType.length()) {
        return;
    }

    if(SUCCEEDED(RootNode->selectNodes(bstrNodeType, &listOfNodes)) ) {
        
        CSmartRef<IXMLDOMNode> node;

        listOfNodes->reset();
        //
        // And for each, process it
        while( SUCCEEDED(listOfNodes->nextNode(&node)) ) {
            CSmartRef<IXMLDOMNode>       parentNode;

            if(!node) {
                break;  // All done
            }

            node->get_parentNode(&parentNode);
            if(parentNode != NULL) {
                parentNode->removeChild(node, NULL);
                parentNode = NULL;
            }
            
            node = NULL;
        }
    }
}

// **************************************************************************/
HRESULT SimplifyAppendTextNode(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &Node, LPWSTR pwzData)
{
    CSmartRef<IXMLDOMText> TextNode;
    HRESULT     hr = S_OK;

    ASSERT(Node);
    if(Node != NULL) {
        _bstr_t     bstrData;

        if(pwzData && lstrlen(pwzData)) {
            bstrData = _bstr_t(pwzData);
        }
        else {
            bstrData = "";
        }

        if(SUCCEEDED(hr = Document->createTextNode(bstrData, &TextNode))) {
            // Insert it into the document
            hr = Node->appendChild( TextNode, NULL);
        }
    }
    else {
        hr = E_INVALIDARG;
    }

    if(FAILED(hr)) {
        MyTrace("Failed to create or append new text node");
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyInsertNodeBefore(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &DestNode,
                                 CSmartRef<IXMLDOMNode> &BeforeNode, IXMLDOMNode* InsertNode)
{
    VARIANT     vt;
    HRESULT     hr;

    // Insert it into the document
    VariantClear(&vt);
    vt.vt = VT_UNKNOWN;
    vt.punkVal = BeforeNode;

    if(FAILED(hr = DestNode->insertBefore(InsertNode, vt, NULL))) {
        MyTrace("SimplifyInsertNodeBefore Failed");
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyInsertTextBefore(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &DestNode,
                                    CSmartRef<IXMLDOMNode> &BeforeNode, LPWSTR pwzData)
{
    CSmartRef<IXMLDOMText> TextNode;
    CSmartRef<IXMLDOMNode> TempNode;

    HRESULT     hr;

    ASSERT(Document && DestNode && BeforeNode);
    if(Document != NULL && DestNode != NULL && BeforeNode != NULL) {
        _bstr_t     bstrData;

        if(pwzData && lstrlen(pwzData)) {
            bstrData = _bstr_t(pwzData);
        }
        else {
            bstrData = "";
        }

        if( SUCCEEDED(hr = Document->createTextNode(bstrData, &TextNode))) {
            TempNode = TextNode;
            hr = SimplifyInsertNodeBefore(Document, DestNode, BeforeNode, TempNode);
        }
    }
    else {
        hr = E_INVALIDARG;
    }

    if(FAILED(hr)) {
        MyTrace("Failed to InsertTextNodeBefore node");
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyConstructNode(CSmartRef<IXMLDOMDocument2> &Document, int iNodeType, _bstr_t nodeName,
                              _bstr_t nameSpaceURI, IXMLDOMNode **NewNode)
{
    HRESULT     hr;
    VARIANT     vt;

    VariantClear(&vt);

    vt.vt = VT_INT;
    vt.intVal = iNodeType;

    if( FAILED(hr = Document->createNode(vt, nodeName, nameSpaceURI, NewNode))) {
        WCHAR   wzErrorStr[_MAX_PATH];

        wnsprintf(wzErrorStr, ARRAYSIZE(wzErrorStr), L"Can't create '%ws' node.", nodeName);
        MyTraceW(wzErrorStr);
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyRemoveAttribute(CSmartRef<IXMLDOMNode> &domNode, _bstr_t bstrAttribName)
{
    CSmartRef<IXMLDOMNamedNodeMap> Attributes;
    CSmartRef<IXMLDOMNode>       AttribNode;
    HRESULT                      hr;

    if( SUCCEEDED(hr = domNode->get_attributes( &Attributes ))) {
        if(Attributes != NULL) {
            hr = Attributes->removeNamedItem(bstrAttribName, &AttribNode);

            if( FAILED(hr)) {
                WCHAR   wzErrorStr[_MAX_PATH];

                wnsprintf(wzErrorStr, ARRAYSIZE(wzErrorStr), L"Failed to remove '%ws' attribute.", bstrAttribName);
                MyTraceW(wzErrorStr);
            }
        }
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyPutAttribute(CSmartRef<IXMLDOMDocument2> &Document,  CSmartRef<IXMLDOMNode> &domNode,
                             _bstr_t bstrAttribName, LPWSTR pszValue, LPWSTR pszNamespaceURI)
{
    CSmartRef<IXMLDOMNamedNodeMap> Attributes;
    CSmartRef<IXMLDOMNode>       AttribNode;
    CSmartRef<IXMLDOMNode>       TempNode;
    HRESULT                      hr;

    if(SUCCEEDED(hr = domNode->get_attributes( &Attributes ))) {

        // Get the attribute from our namespace
        if(SUCCEEDED(hr = Attributes->getQualifiedItem(bstrAttribName, _bstr_t(pszNamespaceURI), &AttribNode))) {
            //
            // If we had success, but the attribute node is null, then we have to
            // go create one, which is tricky.
            if( AttribNode == NULL ) {
                VARIANT vt;
                VariantClear(&vt);
                vt.vt = VT_INT;
                vt.intVal = NODE_ATTRIBUTE;

                //
                // Do the actual creation part
                hr = Document->createNode(vt, bstrAttribName, _bstr_t(pszNamespaceURI), &TempNode );
            
                if(FAILED(hr)) {
                    WCHAR   wzErrorStr[_MAX_PATH];

                    wnsprintf(wzErrorStr, ARRAYSIZE(wzErrorStr), L"Can't create the new attribute node '%ws'.", bstrAttribName);
                    MyTraceW(wzErrorStr);
                    goto lblGetOut;
                }

                //
                // Now we go and put that item into the map.
                if(FAILED( hr = Attributes->setNamedItem( TempNode, &AttribNode ))) {
                    WCHAR   wzErrorStr[_MAX_PATH];

                    wnsprintf(wzErrorStr, ARRAYSIZE(wzErrorStr), L"Can't setNamedItem for attribute '%ws'.", bstrAttribName);
                    MyTraceW(wzErrorStr);
                    goto lblGetOut;
                }
            }

            if(pszValue) {
                hr = AttribNode->put_text( _bstr_t(pszValue) );
            }
            else {
                hr = AttribNode->put_text( _bstr_t("") );
            }
        }
    }

lblGetOut:

    return hr;
}

// **************************************************************************/
HRESULT SimplifyGetAttribute(CSmartRef<IXMLDOMNamedNodeMap> &Attributes, LPWSTR pwzAttribName,
                             _bstr_t *pbstrDestination)
{
    CSmartRef<IXMLDOMNode>  NodeValue = NULL;
    HRESULT                 hr = S_OK;
    BSTR                    _bst_pretemp;

    if(FAILED(hr = Attributes->getNamedItem(_bstr_t(pwzAttribName), &NodeValue))) {
        goto lblBopOut;
    }
    else if( NodeValue == NULL )  {
        goto lblBopOut;
    }
    else {
        if(FAILED(hr = NodeValue->get_text(&_bst_pretemp))) {
            goto lblBopOut;
        }

        *pbstrDestination = _bstr_t(_bst_pretemp, FALSE);
    }

lblBopOut:
    return hr;
}

// **************************************************************************/
HRESULT SimplifyAppendARMBeginComment(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &destNode,
                                      FILETIME *pftSnapShot, DWORD dwRollCount)
{
    CSmartRef<IXMLDOMComment> Comment;
    WCHAR           wszBuff[_MAX_PATH];
    WCHAR           wzDateBuf[STRING_BUFFER];
    FILETIME        ftTemp;
    HRESULT         hr;
    _bstr_t         bStrBuf;

    MyTrace("SimplifyAppendARMBeginComment - Entry");

    ASSERT(Document);
    ASSERT(destNode);
    
    hr = Document->createComment(NULL, &Comment);
    if(FAILED(hr) || Comment == NULL) {
        goto Exit;
    }

    *wszBuff = L'\0';
    *wzDateBuf = L'\0';

    GetSystemTimeAsFileTime(&ftTemp);
    FormatDateString(&ftTemp, NULL, TRUE, wzDateBuf, ARRAYSIZE(wzDateBuf));
    wnsprintf(wszBuff, ARRAYSIZE(wszBuff), wszArmEntryBegin, dwRollCount, pftSnapShot->dwHighDateTime, pftSnapShot->dwLowDateTime, wzDateBuf);
    bStrBuf = wszBuff;

    hr = Comment->insertData(0, bStrBuf);
    if(FAILED(hr)) {
        goto Exit;
    }

    hr = destNode->appendChild(Comment, NULL);
    if(FAILED(hr)) {
        goto Exit;
    }

    MyTrace("SimplifyAppendARMBeginComment - Success");

Exit:
    MyTrace("SimplifyAppendARMBeginComment - Exit");
    return hr;
}

// **************************************************************************/
HRESULT SimplifyAppendARMExitComment(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &destNode,
                                     DWORD dwRollCount)
{
    CSmartRef<IXMLDOMComment> Comment;
    CSmartRef<IXMLDOMNode>    TempNode;
    WCHAR                     wszBuff[MAX_PATH];
    HRESULT                   hr =E_FAIL;
    _bstr_t                   bStrBuf;

    MyTrace("SimplifyAppendARMExitComment - Entry");

    *wszBuff = L'\0';

    hr = Document->createComment(NULL, &Comment);
    if(FAILED(hr) || (Comment == NULL)) {
        goto Exit;
    }

    wnsprintf(wszBuff, ARRAYSIZE(wszBuff), wszArmEntryEnd, dwRollCount);
    bStrBuf = wszBuff;

    hr = Comment->insertData(0, bStrBuf);
    if(FAILED(hr)) {
        goto Exit;
    }

    // Insert it into the document
    hr = destNode->appendChild(Comment, NULL);
    if(FAILED(hr)) {
        goto Exit;
    }

    MyTrace("SimplifyAppendARMExitComment - Success");

Exit:
    MyTrace("SimplifyAppendARMExitComment - Exit");
    return hr;
}

// **************************************************************************/
HRESULT SimplifyInsertBeforeARMEntryComment(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &DestNode,
                                            CSmartRef<IXMLDOMNode> &BeforeNode, FILETIME *pftSnapShot, DWORD dwRollCount)
{
    CSmartRef<IXMLDOMComment> Comment;
    HRESULT         hr;

    if(SUCCEEDED(hr = Document->createComment(NULL, &Comment))) {
        WCHAR           wszBuff[_MAX_PATH];
        WCHAR           wzDateBuf[STRING_BUFFER];
        FILETIME        ftTemp;

        *wszBuff = L'\0';
        *wzDateBuf = L'\0';

        GetSystemTimeAsFileTime(&ftTemp);
        FormatDateString(&ftTemp, NULL, TRUE, wzDateBuf, ARRAYSIZE(wzDateBuf));
        wnsprintf(wszBuff, ARRAYSIZE(wszBuff), wszArmEntryBegin, dwRollCount, pftSnapShot->dwHighDateTime, pftSnapShot->dwLowDateTime, wzDateBuf);
        _bstr_t     bStrBuf = wszBuff;

        if(SUCCEEDED(hr = Comment->insertData(0, bStrBuf))) {
            hr = SimplifyInsertNodeBefore(Document, DestNode, BeforeNode, Comment);
        }
        else {
            MyTrace("SimplifyInsertBeforeARMEntryComment - failed insertData into comment node");
        }
    }
    else {
        MyTrace("SimplifyInsertBeforeARMEntryComment - failed create comment node");
    }

    return hr;
}
// **************************************************************************/
HRESULT SimplifyInsertBeforeARMExitComment(CSmartRef<IXMLDOMDocument2> &Document, CSmartRef<IXMLDOMNode> &DestNode,
                                           CSmartRef<IXMLDOMNode> &BeforeNode, DWORD dwRollCount)
{
    CSmartRef<IXMLDOMComment> Comment;
    HRESULT         hr;

    if(SUCCEEDED( hr = Document->createComment(NULL, &Comment))) {
        CSmartRef<IXMLDOMNode>       TempNode;
        WCHAR           wszBuff[_MAX_PATH];

        wnsprintf(wszBuff, ARRAYSIZE(wszBuff), wszArmEntryEnd, dwRollCount);
        _bstr_t     bStrBuf = wszBuff;

        if(SUCCEEDED( hr = Comment->insertData(0, bStrBuf))) {
            hr = SimplifyInsertNodeBefore(Document, DestNode, BeforeNode, Comment);
        }
        else {
            MyTrace("SimplifyInsertBeforeARMExitComment - failed insertData into comment node");
        }
    }
    else {
        MyTrace("SimplifyInsertBeforeARMExitComment - failed to create comment node");
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyAppendNodeUknowns(CSmartRef<IXMLDOMNode> &srcNode,
                                  CSmartRef<IXMLDOMNode> &destNode,
                                  LPWSTR pwzRefVersion)
{
    CSmartRef<IXMLDOMNodeList>  srcChildNodesList;
    CSmartRef<IXMLDOMNode>      childNode;
    HRESULT                     hr = E_FAIL;

    MyTrace("SimplifyAppendNodeUknowns - Entry");

    if(!srcNode) {
        hr = S_OK;
        goto Exit;
    }

    hr = srcNode->get_childNodes(&srcChildNodesList);
    if(SUCCEEDED(hr) && srcChildNodesList != NULL) {
        srcChildNodesList->reset();

        while( SUCCEEDED(srcChildNodesList->nextNode(&childNode)) ) {
            if( childNode == NULL ) {
                break;            // All done
            }

            BOOL        fAddEntry;
            BSTR        bstrXml;

            fAddEntry = TRUE;

            // No CR or LF or Space entries allowed
            childNode->get_xml(&bstrXml);
            if(bstrXml[0] == L'\r' || bstrXml[0] == L'\n' || bstrXml[0] == L' ') {
                fAddEntry = FALSE;
            }
            SAFESYSFREESTRING(bstrXml);

            if(fAddEntry) {
                // Check node names to make sure we don't end up having
                // duplicates
                childNode->get_nodeName(&bstrXml);
                if(!FusionCompareString(XML_ASSEMBLYBINDINGS_KEY, (LPWSTR) bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_DEPENDENTASSEMBLY_KEY, (LPWSTR) bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ASSEMBLYIDENTITY_KEY, (LPWSTR) bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_BINDINGREDIRECT_KEY, (LPWSTR) bstrXml)) {
                    CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
                    _bstr_t     bstrOldVersion;

                    if(SUCCEEDED( hr = childNode->get_attributes( &Attributes )) ) {
                        SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_OLDVERSION, &bstrOldVersion);
                    }

                    // Only allow other bindingRedirect tags except our ref'd one
                    if(pwzRefVersion) {
                        if(!FusionCompareString(pwzRefVersion, (LPWSTR) bstrOldVersion)) {
                            fAddEntry = FALSE;
                        }
                        else if(StrStrI(bstrOldVersion, L"-") != NULL) {
                            if(IsVersionInRange(pwzRefVersion, &bstrOldVersion)) {
                                fAddEntry = FALSE;
                            }
                        }
                    }
                }
                else if(!FusionCompareString(XML_PUBLISHERPOLICY_KEY, (LPWSTR) bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_COMMENTNODE_NAME, (LPWSTR) bstrXml)) {
                    BSTR        bstrXmlData;

                    // Don't allow ARM entry or exit blocks to be appended
                    childNode->get_text(&bstrXmlData);
                    if(StrStrI(bstrXmlData, wszArmEntryBeginNoVal) || StrStrI(bstrXmlData, wszArmEntryEndNoVal)) {
                        fAddEntry = FALSE;
                    }
                    SAFESYSFREESTRING(bstrXmlData);
                }
                
                SAFESYSFREESTRING(bstrXml);

                if(fAddEntry) {
                    CSmartRef<IXMLDOMNode> copyChildNode;

                    childNode->cloneNode(VARIANT_TRUE, &copyChildNode);
                    if(copyChildNode) {
                        if(FAILED(hr = destNode->appendChild(copyChildNode, NULL))) {
                            MyTrace("Failed to appendChild node");
                        }
                    }
                    else {
                        MyTrace("Failed to clone node");
                    }
                }
            }
            childNode = NULL;
        }
    }

    if(FAILED(hr)) {
        MyTrace("SimplifyAppendNodeUknowns failed");
    }

Exit:
    MyTrace("SimplifyAppendNodeUknowns - Exit");
    return hr;
}

// **************************************************************************/
HRESULT SimplifyAppendNodeAttributesUknowns(CSmartRef<IXMLDOMDocument2> &Document,
                                            CSmartRef<IXMLDOMNode> &srcNode, CSmartRef<IXMLDOMNode> &destNode)
{
    CSmartRef<IXMLDOMNamedNodeMap> srcNodeAttributesList;
    CSmartRef<IXMLDOMNode> attributeNode;
    HRESULT         hr = E_FAIL;

    if(!srcNode) {
        return S_OK;
    }

    hr = srcNode->get_attributes(&srcNodeAttributesList);
    if(SUCCEEDED(hr) && srcNodeAttributesList != NULL) {
        srcNodeAttributesList->reset();

        while ( SUCCEEDED(srcNodeAttributesList->nextNode(&attributeNode)) ) {
            if ( attributeNode == NULL ) {
                break;            // All done
            }

            BOOL        fAddEntry;
            BSTR        bstrXml;

            fAddEntry = TRUE;

            if(fAddEntry) {
                // Check node names to make sure we don't end up having
                // duplicates
                attributeNode->get_nodeName(&bstrXml);
                if(!FusionCompareString(XML_ATTRIBUTE_NAME, bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ATTRIBUTE_PUBLICKEYTOKEN, bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ATTRIBUTE_CULTURE, bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ATTRIBUTE_OLDVERSION, bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ATTRIBUTE_NEWVERSION, bstrXml)) {
                    fAddEntry = FALSE;
                }
                else if(!FusionCompareString(XML_ATTRIBUTE_APPLY, bstrXml)) {
                    fAddEntry = FALSE;
                }

                if(fAddEntry) {
                    VARIANT varVal;
                    VariantClear(&varVal);

                    attributeNode->get_nodeValue(&varVal);
                    hr = SimplifyPutAttribute(Document, destNode, bstrXml, _bstr_t(varVal), ASM_NAMESPACE_URI);
                }
                SAFESYSFREESTRING(bstrXml);
            }
            attributeNode = NULL;
        }
    }

    if(FAILED(hr)) {
        MyTrace("SimplifyAppendNodeAttributesUknowns failed");
    }

    return hr;
}

// **************************************************************************/
HRESULT WriteBasicConfigFile(LPWSTR pwszSource, BOOL *pfTemplateCreated)
{
    HRESULT     hr = E_FAIL;
    HANDLE      hFile;
    DWORD       dwFileSize = 0;
    ULONG       cbData;
    ULONG       cbBytesWritten = 0;
    WCHAR       wszBasicConfigTemplate[4096];
    WCHAR       wszBackupFileName[_MAX_PATH];

    // Check to see if file exists
    if(WszGetFileAttributes(pwszSource) != -1) {
        // Now make sure we actually have a file size
        hFile = WszCreateFile(pwszSource, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
        if(hFile != INVALID_HANDLE_VALUE) {
            dwFileSize = GetFileSize(hFile, NULL);
            CloseHandle(hFile);
        }
    }

    if(pfTemplateCreated) {
        dwFileSize ? *pfTemplateCreated = FALSE : *pfTemplateCreated = TRUE;
    }

    // We got a file and size, just bail
    if(dwFileSize) {
        return S_OK;
    }

    // Make sure Nar00 and Nar01 don't exist, could make
    // the undo, restore process ugly.
    wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", pwszSource, wszNar00Extension);
    WszDeleteFile(wszBackupFileName);

    // Delete the change backup 'config.Nar01'
    wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", pwszSource, wszNar01Extension);
    WszDeleteFile(wszBackupFileName);

    wnsprintf(wszBasicConfigTemplate, ARRAYSIZE(wszBasicConfigTemplate), XML_CONFIG_TEMPLATE_COMPLETE, ASM_NAMESPACE_URI);

    LPSTR   pStrData = WideToAnsi(wszBasicConfigTemplate);
    cbData = lstrlenA(pStrData) * ELEMENTSIZE(pStrData);

    CFileStreamBase fsbase(FALSE);

    if(fsbase.OpenForWrite(pwszSource)) {
        if(SUCCEEDED(fsbase.Write(pStrData, cbData, &cbBytesWritten))) {
            if(cbBytesWritten == cbData) {
                fsbase.Close();
                hr = S_OK;
            }
            else {
                MyTrace("WriteBasicConfigFile failed to write correct number of bytes.");
            }
        }
        else {
            MyTrace("WriteBasicConfigFile failed to write data.");
        }
    }
    else {
        MyTrace("WriteBasicConfigFile failed to open for write");
        MyTraceW(pwszSource);
    }

    SAFEDELETEARRAY(pStrData);
    return hr;
}

// **************************************************************************/
HRESULT ConstructXMLDOMObject(CSmartRef<IXMLDOMDocument2> &Document, LPWSTR pwszSourceName)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vb;

    MyTrace("ConstructXMLDOMObject - Entry");

    if( FAILED(hr = g_XmlDomClassFactory->CreateInstance( NULL, Document.iid, (void**)&Document ))) {
        return hr;
    }
    
    // If they're willing to deal with bad XML, then so be it.
    if( FAILED( hr = Document->put_validateOnParse( VARIANT_FALSE ) ) ) {
        MyTrace("MSXMLDOM Refuses to be let the wool be pulled over its eyes!");
    }

    // Parsing language
    Document->setProperty(_bstr_t("SelectionLanguage"), _variant_t("XPath"));

    // Namespace URI
    Document->setProperty(_bstr_t("SelectionNamespaces"), _variant_t(XML_NAMESPACEURI));
    
    hr = Document->put_preserveWhiteSpace( VARIANT_TRUE );
    hr = Document->put_resolveExternals( VARIANT_FALSE );

    CFileStreamBase fsbase(FALSE);
    CSmartRef<IStream> istream = &fsbase;
    CSmartRef<IUnknown> unkstream;

    if( !fsbase.OpenForRead( pwszSourceName )) {
        MyTrace("Failed opening for read");
        MyTraceW(pwszSourceName);
        return E_FAIL;
    }

    hr = istream->QueryInterface( IID_IUnknown, (void**)&unkstream );
    hr = Document->load( _variant_t( istream ), &vb );

    if( vb != VARIANT_TRUE ) {
        CSmartRef<IXMLDOMParseError> perror;
        hr = Document->get_parseError( &perror );
        LONG ecode, filepos, linenumber, linepos;
        BSTR reason, src;
        
        perror->get_errorCode( &ecode );
        perror->get_filepos( &filepos );
        perror->get_line( &linenumber );
        perror->get_linepos( &linepos );
        perror->get_reason( &reason );
        perror->get_srcText( &src );

        WCHAR   wzStr[_MAX_PATH];

        wnsprintf(wzStr, ARRAYSIZE(wzStr), L"Error: %0x, Reason %ws at position %ld, Line #%ld, Column %ld. Text was: '%ws'.", ecode,
            _bstr_t(reason), filepos, linenumber, linepos, _bstr_t(src));
        MyTraceW(wzStr);
        hr = E_FAIL;
    }

    fsbase.Close();

    if(SUCCEEDED(hr)) {
        SimplifyRemoveAllNodes(Document, _bstr_t(XML_TEXT));
    }

    // Validate our XML format
    CSmartRef<IXMLDOMElement> rootElement;
    BSTR    bstrTagName = NULL;
    WCHAR   wzFmtError[] = {L"The manifest '%ws' may be malformed, no configuration element!"};

    // Make sure the root of the Document is configuration
    hr = E_FAIL;

    // Fix 449754 - NAR crashes when a malformed or a empty application config file is present
    // 2 fixes here, 1 is that S_FALSE can be return from these interfaces which indicate ther was
    // no data found. So we explicitly check for S_OK. This keeps us from AVing.

    // The other is that once we check this correctly, we end up showing the malformed XML dialog
    if(Document->get_documentElement( &rootElement ) == S_OK) {
        if(rootElement->get_tagName(&bstrTagName) == S_OK) {
            if(!FusionCompareString(XML_CONFIGURATION_KEY, bstrTagName)) {
                hr = S_OK;
            }
        }
    }
    
    SAFESYSFREESTRING(bstrTagName);

    if(FAILED(hr)) {
        WCHAR   wszMsgError[_MAX_PATH * 2];

        wnsprintf(wszMsgError, ARRAYSIZE(wszMsgError), wzFmtError, pwszSourceName);
        MyTraceW(wszMsgError);
        return NAR_E_MALFORMED_XML;
    }

    // Make sure we have all the proper elements
    // in the Document, if not then create them.
    CSmartRef<IXMLDOMNodeList>  runtimeNodeList;
    CSmartRef<IXMLDOMNode>      configNode = rootElement;
    CSmartRef<IXMLDOMNode>      runtimeNode;
    CSmartRef<IXMLDOMNode>      newRuntimeNode;
    LONG                        lCountOfNodes;
    
    // Select the 'runtime' node
    if( FAILED(Document->selectNodes(_bstr_t(XML_RUNTIME), &runtimeNodeList )) ) {
        WCHAR           wzStrError[_MAX_PATH * 2];
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, pwszSourceName, XML_RUNTIME_KEY);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // See if we really have a runtime node
    runtimeNodeList->get_length( &lCountOfNodes );
    if(!lCountOfNodes) {
        // Construct one
        if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_RUNTIME_KEY, _bstr_t(), &runtimeNode))) {
            SimplifyRemoveAttribute(runtimeNode, XML_XMLNS);
            hr = configNode->appendChild(runtimeNode, &newRuntimeNode);
        }
    }
    else {
        runtimeNodeList->reset();
        runtimeNodeList->nextNode(&newRuntimeNode);
    }

    if(newRuntimeNode) {
        CSmartRef<IXMLDOMNode> assemblyBindingNode;

        hr = newRuntimeNode->get_firstChild(&assemblyBindingNode);
        if(assemblyBindingNode == NULL) {
            // Construct a assemblyBinding node

            if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_ASSEMBLYBINDINGS_KEY, ASM_NAMESPACE_URI, &assemblyBindingNode))) {
                hr = newRuntimeNode->appendChild(assemblyBindingNode, NULL);
            }
        }
    }

    MyTrace("ConstructXMLDOMObject - Exit");

    return hr;
}

// **************************************************************************/
HRESULT GetRollBackCount(CSmartRef<IXMLDOMDocument2> &Document, DWORD *pdwRollCount)
{
    CSmartRef<IXMLDOMNodeList>  commentTags;
    CSmartRef<IXMLDOMNode>      commentNode;

    MyTrace("GetRollBackCount - Entry");

    ASSERT(pdwRollCount);
    if(!pdwRollCount) {
        return E_INVALIDARG;
    }

    *pdwRollCount = 0;

    //
    // Now, let's select all the Comment blocks:
    //
    if( FAILED(Document->selectNodes(_bstr_t(XML_COMMENT), &commentTags )) ) {
        MyTrace("Unable to select the comment nodes, can't proceed.");
        return E_FAIL;
    }

    //
    // And for each, process it
    commentTags->reset();

    while ( SUCCEEDED(commentTags->nextNode(&commentNode)) ) {
        if ( commentNode == NULL ) {
            break;            // All done
        }

        BSTR        bstrXml;
        LPWSTR      pwszChar;

        commentNode->get_xml(&bstrXml);

        pwszChar = StrStrI(bstrXml, wszArmEntryBeginNoVal);
        if(pwszChar) {
            // Found our comment block, move to # sign
            pwszChar = StrStrI(bstrXml, L"#");
            pwszChar++;
            DWORD   dwValue = StrToInt(pwszChar);
            if(dwValue > *pdwRollCount) {
                *pdwRollCount = dwValue;
            }
        }

        SAFESYSFREESTRING(bstrXml);
        commentNode = NULL;
    }

    MyTrace("GetRollBackCount - Exit");

    return S_OK;
}

// **************************************************************************/
HRESULT GetRollBackCount(IHistoryReader *pReader, DWORD *pdwRollCount )
{
    CSmartRef<IXMLDOMDocument2> Document;
    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wzStrError[_MAX_PATH];
    
    ASSERT(pReader && pdwRollCount);
    if(!pReader) {
        return E_INVALIDARG;
    }
    if(!pdwRollCount) {
        return E_INVALIDARG;
    }

    if(!InitializeMSXML()) {
        return E_FAIL;
    }

    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH) {
        return E_FAIL;
    }
    
    StrCat(wszSourceName, CONFIG_EXTENSION);

    // Construct XMLDOM and load our config file
    if( FAILED(ConstructXMLDOMObject(Document, wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Failed opening the config file '%ws' for input under the DOM.", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    return GetRollBackCount(Document, pdwRollCount);
}

// **************************************************************************/
HRESULT GetRollBackSnapShotId(CSmartRef<IXMLDOMDocument2> &Document, DWORD dwRollCount, FILETIME *ftAppCfgId)
{
    CSmartRef<IXMLDOMNodeList>  commentTags;
    CSmartRef<IXMLDOMNode>      commentNode;

    MyTrace("GetRollBackSnapShotId - Entry");

    //
    // Now, let's select all the Comment blocks:
    //
    if( FAILED(Document->selectNodes(_bstr_t(XML_COMMENT), &commentTags )) ) {
        MyTrace("Unable to select the comment nodes, can't proceed.");
        return E_FAIL;
    }

    //
    // And for each, process it
    commentTags->reset();

    while ( SUCCEEDED(commentTags->nextNode(&commentNode)) ) {
        if ( commentNode == NULL ) {
            break;            // All done
        }

        BSTR        bstrXml;
        LPWSTR      pwszChar;

        commentNode->get_xml(&bstrXml);

        pwszChar = StrStrI(bstrXml, wszArmEntryBeginNoVal);
        if(pwszChar) {
            // Found our comment block, move beyond block ID
            WCHAR       wzFileTime[_MAX_PATH];
            StrCpy(wzFileTime, pwszChar);
            SAFESYSFREESTRING(bstrXml);

            // Point to High time
            LPWSTR      pwszftHigh = StrStrI(wzFileTime, L"#");
            while(*pwszftHigh++ != L' ');
            
            // Point to Low time
            LPWSTR      pwszftLow = StrStrI(pwszftHigh, L".");
            *pwszftLow = L'\0';
            pwszftLow++;

            // Stop at end of Low time
            LPWSTR      pwszftEnd = StrStrI(pwszftLow, L" ");
            if(pwszftEnd) {
                *pwszftEnd = L'\0';
            }

            ftAppCfgId->dwHighDateTime = StrToIntW(pwszftHigh);
            ftAppCfgId->dwLowDateTime = StrToIntW(pwszftLow);

            return S_OK;
        }

        SAFESYSFREESTRING(bstrXml);
        commentNode = NULL;
    }
    return E_FAIL;
}

// **************************************************************************/
HRESULT BackupConfigFile(LPWSTR pwszSourceName)
{
    WCHAR       wszBackupFileName[_MAX_PATH];
    HRESULT     hr = E_FAIL;

    ASSERT(pwszSourceName);
    if(!pwszSourceName) {
        return E_INVALIDARG;
    }

    wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", pwszSourceName, wszNar00Extension);

    // Check to see if Original copy of app.cfg file exists
    if(WszGetFileAttributes(wszBackupFileName) == -1) {
        // File doesn't exist, so copy it
        if(WszCopyFile(pwszSourceName, wszBackupFileName, TRUE)) {
            hr = S_OK;
        }
    }

    // Overwrite or create backup file.
    wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", pwszSourceName, wszNar01Extension);
    if(WszCopyFile(pwszSourceName, wszBackupFileName, FALSE)) {
        hr = S_OK;
    }

    if(FAILED(hr)) {
        WCHAR       wszError[_MAX_PATH * 2];
        wnsprintf(wszError, ARRAYSIZE(wszError), L"Unable to backup '%ws' file.", pwszSourceName);
        MyTraceW(wszError);
    }

    return hr;
}

// **************************************************************************/
HRESULT DoesBackupConfigExist(IHistoryReader *pReader, BOOL fOriginal, BOOL *fResult)
{
    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wszConfigFileName[_MAX_PATH];

    ASSERT( pReader && fResult);
    if(!pReader) {
        return E_INVALIDARG;
    }
    if(!fResult) {
        return E_INVALIDARG;
    }

    *fResult = FALSE;

    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH)
        return E_FAIL;
    StrCat(wszSourceName, CONFIG_EXTENSION);

    if(fOriginal) {
        wnsprintf(wszConfigFileName, ARRAYSIZE(wszConfigFileName), L"%ws.%ws", wszSourceName, wszNar00Extension);
    }
    else {
        wnsprintf(wszConfigFileName, ARRAYSIZE(wszConfigFileName), L"%ws.%ws", wszSourceName, wszNar01Extension);
    }

    if(WszGetFileAttributes(wszConfigFileName) != -1) {
        *fResult = TRUE;
    }

    return S_OK;
}

// **************************************************************************/
HRESULT RestorePreviousConfigFile(IHistoryReader *pReader, BOOL fOriginal)
{
    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wszBackupFileName[_MAX_PATH];
    DWORD           dwError = 0;
    HRESULT     hr = E_FAIL;

    ASSERT(pReader);
    if(!pReader) {
        return E_INVALIDARG;
    }

    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH)
        return E_FAIL;
    StrCat(wszSourceName, CONFIG_EXTENSION);

    if(fOriginal) {
        wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", wszSourceName, wszNar00Extension);
        if(WszGetFileAttributes(wszBackupFileName) != -1) {
            if(WszCopyFile(wszBackupFileName, wszSourceName, FALSE)) {

                // Now delete the original 'config.nar00'
                WszDeleteFile(wszBackupFileName);

                // Delete the change backup 'config.nar01'
                wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", wszSourceName, wszNar01Extension);
                if(WszGetFileAttributes(wszBackupFileName) != -1) {
                    WszDeleteFile(wszBackupFileName);
                }

                hr = S_OK;
            }
            else {
                dwError = GetLastError();
            }
        }
    }
    else {
        wnsprintf(wszBackupFileName, ARRAYSIZE(wszBackupFileName), L"%ws.%ws", wszSourceName, wszNar01Extension);
        if(WszGetFileAttributes(wszBackupFileName) != -1) {
            if(WszCopyFile(wszBackupFileName, wszSourceName, FALSE)) {
                // Delete the change backup 'config.nar01'
                WszDeleteFile(wszBackupFileName);
                hr = S_OK;
            }
            else {
                dwError = GetLastError();
            }
        }
    }

    // If we succeeded in restore, write the new HASH to the registry
    if(SUCCEEDED(hr)) {
        LPBYTE      pByte;
        DWORD       dwSize;

        if(SUCCEEDED(hr = GetFileHash(CALG_SHA1, wszSourceName, &pByte, &dwSize))) {
            // We got a hash, write it to the registry
            SetRegistryHashKey(wszSourceName, pByte, dwSize);
            SAFEDELETEARRAY(pByte);
        }
        else {
            WCHAR       wzStrError[_MAX_PATH];
            wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Unable to generate hash for '%ws'.", wszSourceName);
            MyTraceW(wzStrError);
        }
    }

    if(FAILED(hr)) {
        WCHAR       wszError[_MAX_PATH * 2];
        wnsprintf(wszError, ARRAYSIZE(wszError), L"Failed to restore '%ws' to '%ws', GetLastError 0x%0x",
            wszBackupFileName, wszSourceName, dwError);
        MyTraceW(wszError);
    }

    return hr;
}

// **************************************************************************/
HRESULT SimplifyGetOriginalNodeData(CSmartRef<IXMLDOMNode> &SrcNode, _bstr_t *bstrDest)
{
    CSmartRef<IXMLDOMNodeList> srcChildNodesList;
    CSmartRef<IXMLDOMNode> childNode;
    CSmartRef<IXMLDOMNode> cloneNode;
    
    HRESULT     hr = E_FAIL;
    BSTR        bstrXmlData;

    if(!SrcNode || !bstrDest) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = SrcNode->cloneNode(VARIANT_TRUE, &cloneNode);

    if(!cloneNode) {
        goto Exit;
    }

    // Select all the comment nodes, and remove them.
    hr = cloneNode->selectNodes(_bstr_t(XML_COMMENT), &srcChildNodesList);
    if(SUCCEEDED(hr) && srcChildNodesList != NULL) {
        while( SUCCEEDED(srcChildNodesList->nextNode(&childNode)) ) {
            if( childNode == NULL ) {
                break;            // All done
            }

            CSmartRef<IXMLDOMNode> parentNode;

            childNode->get_parentNode(&parentNode);
            if(parentNode) {
                parentNode->removeChild(childNode, NULL);
            }

            childNode = NULL;
        }
    }

    cloneNode->get_xml(&bstrXmlData);

    if(SysStringLen(bstrXmlData)) {
        *bstrDest = bstrXmlData;
        hr = S_OK;
    }
    
    SAFESYSFREESTRING(bstrXmlData);

Exit:
    
    return hr;
}

// **************************************************************************/
HRESULT GetReferencedBindingRedirectNode(CSmartRef<IXMLDOMNode> &pdependentAssemblyNode,
                                         CSmartRef<IXMLDOMNode> &pbindingRedirectNode,
                                         LPWSTR pwzVerRef, BOOL *pfDoesHaveBindingRedirects)
{
    CSmartRef<IXMLDOMNodeList> bindingRedirectListNode;

    MyTrace("GetReferencedBindingRedirectNode - Entry");

    // Get all the children bindingRedirectNodes
    if(SUCCEEDED(pdependentAssemblyNode->selectNodes(_bstr_t(XML_SPECIFICBINDINGREDIRECT), &bindingRedirectListNode))) {
        CSmartRef<IXMLDOMNode> currentBindingRedirectNode;
        LONG            lCount;

        // If this AssemblyIdentity node does have bindingRedirect statements, pass TRUE back
        bindingRedirectListNode->reset();
        bindingRedirectListNode->get_length(&lCount);
        if(lCount) {
            *pfDoesHaveBindingRedirects = TRUE;
        }

        //
        // And for each, process it
        while( SUCCEEDED(bindingRedirectListNode->nextNode(&pbindingRedirectNode)) ) {
            if( pbindingRedirectNode == NULL ) {
                break;            // All done
            }

            // We have a RedirectNode, match the REF
            CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
            _bstr_t     bstrOldVersion;

            // Get attributes of our node of interest
            if(SUCCEEDED(pbindingRedirectNode->get_attributes( &Attributes )) ) {
                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_OLDVERSION, &bstrOldVersion);
            }

            // If the ref's match, then this is our node
            if(!FusionCompareString(pwzVerRef, bstrOldVersion)) {
                break;
            }
            else if(StrStrI(bstrOldVersion, L"-") != NULL) {
                if(IsVersionInRange(pwzVerRef, &bstrOldVersion)) {
                    break;
                }
            }
            else {
                pbindingRedirectNode = NULL;
            }
        }
    }

    MyTrace("GetReferencedBindingRedirectNode - Exit");

    return S_OK;
}

// **************************************************************************/
HRESULT PerformFinalPassOnDocument(IXMLDOMDocument2 *pXMLDoc, LPWSTR pwszSourceName)
{
    CSmartRef<IXMLDOMNodeList>  assemblyBindingList;
    CSmartRef<IXMLDOMNode>      assemblyBindingNode;
    HRESULT                     hr = S_OK;
    
    MyTrace("PerformFinalPassOnDocument - Entry");

    if(!pXMLDoc || !pwszSourceName) {
        MyTrace("Invalid arguments");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Remove any assemblyBinding nodes that don't have children
    // Select all /configuration/runtime/assemblyBinding
    hr = pXMLDoc->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList);
    if(FAILED(hr)) {
        WCHAR       wzStrError[MAX_PATH];
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, pwszSourceName, XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        goto Exit;
    }

    assemblyBindingList->reset();
    while(SUCCEEDED(assemblyBindingList->nextNode(&assemblyBindingNode))) {
        if(!assemblyBindingNode) {
            break;      // All done
        }

        VARIANT_BOOL    vb;
        assemblyBindingNode->hasChildNodes(&vb);
        if(vb == VARIANT_FALSE) {
            CSmartRef<IXMLDOMNode>  parentNode;

            assemblyBindingNode->get_parentNode(&parentNode);
            if(parentNode) {
                parentNode->removeChild(assemblyBindingNode, NULL);
            }
        }

        assemblyBindingNode = NULL;
    }
    
Exit:
    MyTrace("PerformFinalPassOnDocument - Exit");
    return hr;
    
}

// **************************************************************************/
HRESULT SimplifySaveXmlDocument(CSmartRef<IXMLDOMDocument2> &Document, BOOL fPrettyFormat, LPWSTR pwszSourceName)
{
    HRESULT     hr;
    LPBYTE      pByte;
    DWORD       dwSize;
    WCHAR       wzStrError[_MAX_PATH];
    BOOL        fChanged;

    MyTrace("SimplifySaveXmlDocument - Entry");
    
    // Perform final Clean up pass on the document before writting it out
    PerformFinalPassOnDocument(Document, pwszSourceName);

    // Format the document in the right ordering
    hr = OrderDocmentAssemblyBindings(Document, pwszSourceName, &fChanged);
    if(FAILED(hr)) {
        goto Exit;
    }

    // Make the document readable
    if(fPrettyFormat) {
        PrettyFormatXmlDocument(Document);
    }

    if( FAILED( hr = Document->save( _variant_t(pwszSourceName))) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Unable to save '%ws', Changes will be lost.", pwszSourceName);
        MyTraceW(wzStrError);
        goto Exit;
    }

    if(SUCCEEDED(hr = GetFileHash(CALG_SHA1, pwszSourceName, &pByte, &dwSize))) {
        // We got a hash, write it to the registry
        SetRegistryHashKey(pwszSourceName, pByte, dwSize);
        SAFEDELETEARRAY(pByte);
    }
    else {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Unable to generate hash for '%ws'.", pwszSourceName);
        MyTraceW(wzStrError);
    }

Exit:

    MyTrace("SimplifySaveXmlDocument - Exit");

    return hr;
}

// **************************************************************************/
HRESULT FixDependentAssemblyNode(
  CSmartRef<IXMLDOMDocument2> &Document, 
  CSmartRef<IXMLDOMNode> &dependentAssemblyNode,
  CSmartRef<IXMLDOMNode> &PrePendAssemblyBindingBuffNode,
  CSmartRef<IXMLDOMNode> &PostAppendAssemblyBindingBuffNode,
  FILETIME *pftSnapShot,
  AsmBindDiffs *pABD,
  BOOL fRunInRTMCorVer,
  BOOL fDocHasAppliesTo,
  BOOL *fChanged)
{
    CSmartRef<IXMLDOMNode>  newDependentAssemblyNode;
    CSmartRef<IXMLDOMNode>  AssemblyIdentNode;
    CSmartRef<IXMLDOMNode>  BindingRedirectNode;
    CSmartRef<IXMLDOMNode>  PublisherPolicyNode;
    CSmartRef<IXMLDOMNode>  parentNode;
    _bstr_t                 bstrNodeXmlData;
    HRESULT                 hr = S_OK;
    DWORD                   dwPolicyRollingCount = 1;
    BOOL                    fAddedNewPolicyData;
    BOOL                    fHasAppliesTo = FALSE;

    MyTrace("FixDependentAssemblyNode - Entry");

    if(SUCCEEDED(GetRollBackCount(Document, &dwPolicyRollingCount ))) {
        dwPolicyRollingCount++;
    }

    *fChanged = fAddedNewPolicyData = FALSE;

    if(dependentAssemblyNode) {
        SimplifyGetOriginalNodeData(dependentAssemblyNode, &bstrNodeXmlData);
    }

    // Construct New dependentAssembly node
    hr = SimplifyConstructNode( Document, NODE_ELEMENT, XML_DEPENDENTASSEMBLY_KEY, ASM_NAMESPACE_URI, &newDependentAssemblyNode);
    if(FAILED(hr)) {
        MyTrace("Unable to create new dependentAssembly node");
        goto Exit;
    }

    // Make ARM's comment entry block
    SimplifyAppendARMBeginComment(Document, newDependentAssemblyNode, pftSnapShot, dwPolicyRollingCount);

    //
    // ****** assemblyIdentity:: Try to find original assemblyIdentity tag
    //
    if(dependentAssemblyNode) {
        CSmartRef<IXMLDOMNode>  newTempAssemblyIdentNode;
        CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
        _bstr_t                 bstrAppliesTo;

        dependentAssemblyNode->selectSingleNode(_bstr_t(XML_SPECIFICASSEMBLYIDENTITY), &newTempAssemblyIdentNode);
        if(newTempAssemblyIdentNode) {
            newTempAssemblyIdentNode->cloneNode(VARIANT_TRUE, &AssemblyIdentNode);
        }

        // Check to find out if this assemblyIdentity parent node 'assemblyBindings>
        // has an appliesTo attribute
        dependentAssemblyNode->get_parentNode(&parentNode);
        if(SUCCEEDED(parentNode->get_attributes( &Attributes )) ) {
            SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLIESTO, &bstrAppliesTo);

            if(bstrAppliesTo.length()) {
                fHasAppliesTo = TRUE;
            }
        }
    }
    
    if(!AssemblyIdentNode) {
        // Try to create one since it wasn't there
        if(SUCCEEDED(SimplifyConstructNode(Document, NODE_ELEMENT, XML_ASSEMBLYIDENTITY_KEY, ASM_NAMESPACE_URI, &AssemblyIdentNode))) {
            SimplifyRemoveAttribute(AssemblyIdentNode, XML_XMLNS);

            // Set the attributes, insert the node and spacer
            SimplifyPutAttribute(Document, AssemblyIdentNode, XML_ATTRIBUTE_NAME, pABD->wzAssemblyName, NULL);
            SimplifyPutAttribute(Document, AssemblyIdentNode, XML_ATTRIBUTE_PUBLICKEYTOKEN, pABD->wzPublicKeyToken, NULL);
            SimplifyPutAttribute(Document, AssemblyIdentNode, XML_ATTRIBUTE_CULTURE, pABD->wzCulture, NULL);
        }
    }

    // Insert the assemblyIdentity node into the new dependentAssembly
    newDependentAssemblyNode->appendChild(AssemblyIdentNode, NULL);

    //
    // ****** bindingRedirect::
    //
    // See if we need to add a bindingRedirect statement
    // comparing the Version Referenced with the final version from Admin
    if(dependentAssemblyNode) {
        BOOL    fDoesHaveBindingRedirects = FALSE;
        GetReferencedBindingRedirectNode(dependentAssemblyNode, BindingRedirectNode, pABD->wzVerRef, &fDoesHaveBindingRedirects);
    }

    // Only contruct redirect statement if Version REF doesn't match version DEF'd
    if(!FusionCompareString(pABD->wzVerRef, pABD->wzVerAdminCfg)) {
        if(BindingRedirectNode) {
            // We are changing policy because we are
            // leaving out a previous bindingRedirect statement
            fAddedNewPolicyData = TRUE;
        }
    }
    else {
        if(BindingRedirectNode == NULL) {
            // Try to create one since it wasn't there
            if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_BINDINGREDIRECT_KEY, ASM_NAMESPACE_URI, &BindingRedirectNode))) {
                SimplifyRemoveAttribute( BindingRedirectNode, XML_XMLNS);
            }

            // Set the attributes, insert the node
            SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_OLDVERSION, pABD->wzVerRef, NULL);
            SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_NEWVERSION, pABD->wzVerAdminCfg, NULL);
            newDependentAssemblyNode->appendChild(BindingRedirectNode, NULL);

            // Fix 458974 - NAR fails to revert back in cases where removal of policy causes an app to break
            // We are adding bindingRedirect
            fAddedNewPolicyData = TRUE;
        }
        else {
            // Check node for ranged versions.
            CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
            _bstr_t     bstrOldVersion;
            _bstr_t     bstrNewVersion;

            // Get attributes of our node of interest
            if(SUCCEEDED( hr = BindingRedirectNode->get_attributes( &Attributes )) ) {
                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_OLDVERSION, &bstrOldVersion);
                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_NEWVERSION, &bstrNewVersion);
            }

            // If bindingRedirect ref or def don't match, then we need a statement
            BOOL    fVerRefMatch = FusionCompareString(pABD->wzVerRef, bstrOldVersion) ? FALSE : TRUE;
            BOOL    fVerDefMatch = FusionCompareString(pABD->wzVerAdminCfg, bstrNewVersion) ? FALSE : TRUE;
            if(!fVerRefMatch || !fVerDefMatch || pABD->fYesPublisherPolicy) {
                fAddedNewPolicyData = TRUE;
                BindingRedirectNode = NULL;

                if(!StrStrI(bstrOldVersion, L"-")) {
                    // No ranged version, so set the Def version and append to new node
                    if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_BINDINGREDIRECT_KEY, ASM_NAMESPACE_URI, &BindingRedirectNode))) {
                        SimplifyRemoveAttribute( BindingRedirectNode, XML_XMLNS);
                    }

                    // Set the attributes, insert the node
                    SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_OLDVERSION, pABD->wzVerRef, NULL);
                    SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_NEWVERSION, pABD->wzVerAdminCfg, NULL);
                    newDependentAssemblyNode->appendChild(BindingRedirectNode, NULL);
                }
                else {
                    // Break out version ranges into 3 distinct ranges
                    _bstr_t     bstrRange1, bstrRange2;
                    HRESULT     hrLocal;

                    if(FAILED(hrLocal = MakeVersionRanges(bstrOldVersion, _bstr_t(pABD->wzVerRef), &bstrRange1, &bstrRange2))) {
                        return hrLocal;
                    }

                    if(bstrRange1.length()) {
                        if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_BINDINGREDIRECT_KEY, ASM_NAMESPACE_URI, &BindingRedirectNode))) {
                            SimplifyRemoveAttribute( BindingRedirectNode, XML_XMLNS);
                        }
                        // Set the attributes, insert the node and spacer
                        SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_OLDVERSION, bstrRange1, NULL);
                        SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_NEWVERSION, bstrNewVersion, NULL);
                        newDependentAssemblyNode->appendChild(BindingRedirectNode, NULL);
                    }

                    BindingRedirectNode = NULL;
                    // Write 2 of 3 new bindingRedirect statements now
                    if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_BINDINGREDIRECT_KEY, ASM_NAMESPACE_URI, &BindingRedirectNode))) {
                        SimplifyRemoveAttribute( BindingRedirectNode, XML_XMLNS);
                    }

                    // Set the attributes, insert the node and spacer
                    SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_OLDVERSION, pABD->wzVerRef, NULL);
                    SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_NEWVERSION, pABD->wzVerAdminCfg, NULL);
                    newDependentAssemblyNode->appendChild(BindingRedirectNode, NULL);

                    BindingRedirectNode = NULL;
                    if(bstrRange2.length()) {
                        // Write 3 of 3 new bindingRedirect statements now
                        if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_BINDINGREDIRECT_KEY, ASM_NAMESPACE_URI, &BindingRedirectNode))) {
                            SimplifyRemoveAttribute( BindingRedirectNode, XML_XMLNS);
                        }

                        // Set the attributes, insert the node and spacer
                        SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_OLDVERSION, bstrRange2, NULL);
                        SimplifyPutAttribute(Document, BindingRedirectNode, XML_ATTRIBUTE_NEWVERSION, bstrNewVersion, NULL);
                        newDependentAssemblyNode->appendChild(BindingRedirectNode, NULL);
                    }
                }
            }
        }
    }

    //
    // ****** publisherPolicy:: If we need a policy change, try
    //                          to locate the original publisherpolicy
    //                          node, check it's attribute.
    //                          Construct a new policy and set results
    //                          based of result of policy being set or not.
    //
    if(pABD->fYesPublisherPolicy) {
        CSmartRef<IXMLDOMNode>  publisherPolicyNode;
        BOOL                    fSafeModeSet = FALSE;

        // See if original policy statement existed
        if(dependentAssemblyNode) {
            dependentAssemblyNode->selectSingleNode(_bstr_t(XML_SPECIFICPUBLISHERPOLICY), &publisherPolicyNode);

            if(publisherPolicyNode) {
                // Now check the attribute to make sure it's set
                CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
                _bstr_t     bstrApply;

                // Check our attribute value
                if(SUCCEEDED(publisherPolicyNode->get_attributes( &Attributes )) ) {
                    SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLY, &bstrApply);

                    if(!FusionCompareString(XML_ATTRIBUTE_APPLY_NO, bstrApply)) {
                        fSafeModeSet = TRUE;
                    }
                }
            }
        }

        // Contruct a new publisherpolicy node and append it to the
        // new temp node.
        if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_PUBLISHERPOLICY_KEY, ASM_NAMESPACE_URI, &PublisherPolicyNode))) {
            SimplifyRemoveAttribute( PublisherPolicyNode, XML_XMLNS);
            SimplifyPutAttribute(Document, PublisherPolicyNode, XML_ATTRIBUTE_APPLY, XML_ATTRIBUTE_APPLY_NO, NULL);
            newDependentAssemblyNode->appendChild(PublisherPolicyNode, NULL);
        }

        // Set appropriate result
        if(!fSafeModeSet) {
            fAddedNewPolicyData = TRUE;
        }
    }

    // Now append all other tags for this assembly that
    // we don't know about
    if(dependentAssemblyNode) {
        // Don't add the same bindingRedirect statement if we changed it
        SimplifyAppendNodeUknowns(dependentAssemblyNode, newDependentAssemblyNode, 
            fAddedNewPolicyData ? pABD->wzVerRef : NULL);
    }

    // Make ARM's comment exit block
    SimplifyAppendARMExitComment( Document, newDependentAssemblyNode, dwPolicyRollingCount);

    // Create a ARM comment node and insert the original
    // assemblyIdentity xml for preservation
    if(dependentAssemblyNode && bstrNodeXmlData.length() ) {
        WCHAR           wszTimeChange[4096];
        WCHAR           wzDateBuf[STRING_BUFFER];
        FILETIME        ftTemp;

        *wszTimeChange = '\0';
        *wzDateBuf = '\0';

        GetSystemTimeAsFileTime(&ftTemp);
        FormatDateString(&ftTemp, NULL, TRUE, wzDateBuf, ARRAYSIZE(wzDateBuf));
        wnsprintf(wszTimeChange, ARRAYSIZE(wszTimeChange), wszArmRollBackBlock, dwPolicyRollingCount, wzDateBuf);
        {
            CSmartRef<IXMLDOMComment> Comment;
            _bstr_t     bStrBuf = wszTimeChange;

            if(SUCCEEDED(Document->createComment(bStrBuf, &Comment))) {
                if(SUCCEEDED(Comment->appendData(bstrNodeXmlData))) {
                    if(FAILED(newDependentAssemblyNode->appendChild( Comment, NULL))) {
                        MyTrace("Failed to append new comment node");
                    }
                }
            }
        }
    }

    //
    // ****** Finalize:: Insert the new node data into the document
    //
    //

    // If there are changes or we are doing and RTM revert and the doc has an
    // appliesTo section, then make the changes

    // Try to get parent node, can be NULL if this node never existed
    parentNode = NULL;
    if(dependentAssemblyNode) {
        hr = dependentAssemblyNode->get_parentNode(&parentNode);
        if(FAILED(hr)) {
            MyTrace("Failed to get the parent node of dependentAssemblyNode");
            goto Exit;
        }
    }

    if(fDocHasAppliesTo) {
        CSmartRef<IXMLDOMNode> cloneNode;

        hr = newDependentAssemblyNode->cloneNode(VARIANT_TRUE, &cloneNode);
        if(FAILED(hr) || !cloneNode) {
            MyTrace("Failed to clone newDependentAssemblyNode");
            goto Exit;
        }

        if(fRunInRTMCorVer) {
            SimplifyRemoveAllNodes(cloneNode, XML_COMMENT);
            hr = PrePendAssemblyBindingBuffNode->appendChild(cloneNode, NULL);
            if(FAILED(hr)) {
                MyTrace("Failed to appendChild cloneNode to PrePendAssemblyBindingBuffNode");
                goto Exit;
            }

            if(parentNode && fAddedNewPolicyData) {
                // Replace broken node with newdependentAssemblynode
                hr = parentNode->replaceChild(newDependentAssemblyNode, dependentAssemblyNode, NULL);
                if(FAILED(hr)) {
                    MyTrace("Failed to replaceChild dependentAssemblyNode");
                    goto Exit;
                }
            }
        }
        else {
            if(parentNode) {
                if(fAddedNewPolicyData) {
                    // Replace broken node with newdependentAssemblynode
                    hr = parentNode->replaceChild(newDependentAssemblyNode, dependentAssemblyNode, NULL);
                    if(FAILED(hr)) {
                        MyTrace("Failed to replaceChild dependentAssemblyNode");
                        goto Exit;
                    }
                }
            }
            else {
                // No parent Node so just append it to our Runtime buffer
                hr = PostAppendAssemblyBindingBuffNode->appendChild(cloneNode, NULL);
                if(FAILED(hr)) {
                    MyTrace("Failed to appendChild newDependentAssemblyNodenode");
                    goto Exit;
                }
            }
        }
    }
    else {
        if(parentNode) {
            if(fAddedNewPolicyData) {
                // Replace broken node with newdependentAssemblynode
                hr = parentNode->replaceChild(newDependentAssemblyNode, dependentAssemblyNode, NULL);
                if(FAILED(hr)) {
                    MyTrace("Failed to replaceChild dependentAssemblyNode");
                    goto Exit;
                }
            }
        }
        else {
            // No parent Node so just append it to our Runtime buffer
            hr = PostAppendAssemblyBindingBuffNode->appendChild(newDependentAssemblyNode, NULL);
            if(FAILED(hr)) {
                MyTrace("Failed to appendChild newDependentAssemblyNodenode");
                goto Exit;
            }
        }
    }

    *fChanged = TRUE;

Exit:
    
    MyTrace("FixDependentAssemblyNode - Exit");
    return hr;
}

// **************************************************************************/
HRESULT SetStartupSafeMode(IHistoryReader *pReader, BOOL fSet, BOOL *fDisposition)
{
    CSmartRef<IXMLDOMDocument2> Document;
    CSmartRef<IXMLDOMElement>   rootElement;
    CSmartRef<IXMLDOMNode>      startupNode;
    CSmartRef<IXMLDOMNamedNodeMap> Attributes;
    WCHAR                       wszSourceName[MAX_PATH];
    WCHAR                       wzStrError[MAX_BUFFER_SIZE];
    HRESULT                     hr = S_OK;
    DWORD                       dwPolicyRollingCount;
    _bstr_t                     bstrAttribValue;
    BOOL                        fChangeDocument = FALSE;
    
    MyTrace("SetStartupSafeMode - Entry");

    if(!pReader) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    *fDisposition = FALSE;

    if(!InitializeMSXML()) {
        return E_FAIL;
    }
    
    // Get App.Config filename
    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if(lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > MAX_PATH) {
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }

    StrCat(wszSourceName, CONFIG_EXTENSION);

    // Construct basic .config file if needed
    if( FAILED(WriteBasicConfigFile(wszSourceName, NULL))) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"SetGlobalSafeMode - Policy file '%ws' couldn't be created", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Construct XMLDOM and load our config file
    if( FAILED(hr = ConstructXMLDOMObject(Document, wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Failed opening the config file '%ws' for input under the DOM.", wszSourceName);
        MyTraceW(wzStrError);
        return hr;
    }

    // Get the root of the document
    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"The manifest '%ws' may be malformed, unable to load the root element!", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Get rollback count to increment
    if(SUCCEEDED(GetRollBackCount(Document, &dwPolicyRollingCount))) {
        dwPolicyRollingCount++;
    }
    else {
        dwPolicyRollingCount = 1;
    }

    // Select the startup Node
    if(FAILED(Document->selectSingleNode(_bstr_t(XML_STARTUP), &startupNode)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        hr = E_FAIL;
        goto Exit;
    }

    // Get the attributes
    if(FAILED(startupNode->get_attributes(&Attributes))) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    // Get the value of interest
    SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_SAFEMODE, &bstrAttribValue);

    if(fSet) {
        if(FusionCompareString(XML_ATTRIBUTE_TRUE, bstrAttribValue)) {
            fChangeDocument = TRUE;
            SimplifyPutAttribute(Document, startupNode, XML_ATTRIBUTE_SAFEMODE, XML_ATTRIBUTE_TRUE, NULL);
        }
    }
    else {
        if(FusionCompareString(XML_ATTRIBUTE_TRUE, bstrAttribValue)) {
            fChangeDocument = TRUE;
            SimplifyPutAttribute(Document, startupNode, XML_ATTRIBUTE_SAFEMODE, _bstr_t(), NULL);
        }
    }

    // Something to change
    if(fChangeDocument) {
        // Now save the document
        hr = SimplifySaveXmlDocument(Document, TRUE, wszSourceName);
        if(SUCCEEDED(hr)) {
            *fDisposition = TRUE;
        }
    }

Exit:

    MyTrace("SetStartupSafeMode - Exit");
    return hr;
    
}

// **************************************************************************/
HRESULT SetGlobalSafeMode(IHistoryReader *pReader)
{
    CSmartRef<IXMLDOMDocument2> Document;
    CSmartRef<IXMLDOMElement>   rootElement;
    CSmartRef<IXMLDOMNodeList>  publisherPolicyList;
    CSmartRef<IXMLDOMNode>      publisherPolicyNode;
    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wzStrError[_MAX_PATH * 2];
    HRESULT         hr = S_OK;
    DWORD           dwPolicyRollingCount;

    MyTrace("SetGlobalSafeMode - Entry");

    if(!pReader) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    if(!InitializeMSXML()) {
        return E_FAIL;
    }
    
    // Get App.Config filename
    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH)
        return E_FAIL;
    StrCat(wszSourceName, CONFIG_EXTENSION);

    // Construct basic .config file if needed
    if( FAILED(WriteBasicConfigFile(wszSourceName, NULL))) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"SetGlobalSafeMode - Policy file '%ws' couldn't be created", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Backup config file
    if( FAILED(BackupConfigFile(wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"SetGlobalSafeMode::Failed to backup '%ws'config file", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Construct XMLDOM and load our config file
    if( FAILED(hr = ConstructXMLDOMObject(Document, wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Failed opening the config file '%ws' for input under the DOM.", wszSourceName);
        MyTraceW(wzStrError);
        return hr;
    }

    // Get the root of the document
    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"The manifest '%ws' may be malformed, unable to load the root element!", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Get rollback count to increment
    if(SUCCEEDED(GetRollBackCount(Document, &dwPolicyRollingCount))) {
        dwPolicyRollingCount++;
    }
    else {
        dwPolicyRollingCount = 1;
    }

    // Select all the 'publisherPolicy' blocks under 'configuration/runtime/assemblyBinding' blocks
    if( FAILED(Document->selectNodes(_bstr_t(XML_SAFEMODE_PUBLISHERPOLICY), &publisherPolicyList )) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_SAFEMODE_PUBLISHERPOLICY);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    BOOL    fChanged = FALSE;
    BOOL    fCreated;
    publisherPolicyList->reset();

    // Walk all publisherPolicyList nodes
    while(SUCCEEDED(publisherPolicyList->nextNode(&publisherPolicyNode))) {
        CSmartRef<IXMLDOMNode> assemblyBindingNode;
        CSmartRef<IXMLDOMNode> firstChildNode;
        _bstr_t         bstrPubPolicyXmlData;

        fCreated = FALSE;

        if(publisherPolicyNode == NULL) {
            CSmartRef<IXMLDOMNodeList> assemblyBindingList;
            
            // If we already create or modify an existing one, we be outta here?
            if(fChanged) {
                break;
            }

            fCreated = TRUE;

            // We didn't find publisherPolicy, so create one
            if(SUCCEEDED(SimplifyConstructNode( Document, NODE_ELEMENT, XML_PUBLISHERPOLICY_KEY, ASM_NAMESPACE_URI, &publisherPolicyNode))) {
                SimplifyRemoveAttribute( publisherPolicyNode, XML_XMLNS);
            }

            // Get the fist node below /configuration/runtime/assemblyBinding, this will be the new nodes parent
            if( FAILED(Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList)) ) {
                wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_ASSEMBLYBINDINGS);
                MyTraceW(wzStrError);
                return E_FAIL;
            }

            assemblyBindingList->reset();
            assemblyBindingList->nextNode(&assemblyBindingNode);

            // Fix 459976 - NAR crashes on revert if we provide an app config file with an wrong namespace
            // No assemblyBinding node, create one
            if(!assemblyBindingNode) {
                CSmartRef<IXMLDOMNode> runtimeNode;
                CSmartRef<IXMLDOMNode> tempNode;

                if(FAILED(Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode)) ) {
                    wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_ASSEMBLYBINDINGS);
                    MyTraceW(wzStrError);
                    return E_FAIL;
                }

                if(FAILED(SimplifyConstructNode(Document, NODE_ELEMENT, XML_ASSEMBLYBINDINGS_KEY, ASM_NAMESPACE_URI, &assemblyBindingNode))) {
                    MyTrace("Unable to create new assemblyBinding node");
                    return E_FAIL;
                }
                runtimeNode->appendChild(assemblyBindingNode, &tempNode);
                assemblyBindingNode = tempNode;
            }
        }
        else {
            // Make a copy of the original
            SimplifyGetOriginalNodeData(publisherPolicyNode, &bstrPubPolicyXmlData);

            // Check to see if we even need to set the attribute
            CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
            if(SUCCEEDED( hr = publisherPolicyNode->get_attributes( &Attributes )) ) {
                _bstr_t     bstrAttribValue;
                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLY, &bstrAttribValue);
                if(!FusionCompareString(XML_ATTRIBUTE_APPLY_NO, bstrAttribValue)) {
                    return S_OK;
                }
            }

            // Get the parent of this node
            publisherPolicyNode->get_parentNode(&assemblyBindingNode);
        }

        // We are changing something
        fChanged = TRUE;

        SimplifyPutAttribute(Document, publisherPolicyNode, XML_ATTRIBUTE_APPLY, XML_ATTRIBUTE_APPLY_NO, NULL);

        // Get the first child of assemblyBinding
        assemblyBindingNode->get_firstChild(&firstChildNode);

        // Insert ARM's comment exit block
        SimplifyInsertBeforeARMExitComment(Document, assemblyBindingNode, firstChildNode, dwPolicyRollingCount);

        // Again get the first child
        firstChildNode = NULL;
        assemblyBindingNode->get_firstChild(&firstChildNode);

        // Insert safe mode policy block if it's new
        if(fCreated) {
            SimplifyInsertNodeBefore(Document, assemblyBindingNode, firstChildNode, publisherPolicyNode);
        }

        // Again get the first child
        firstChildNode = NULL;
        assemblyBindingNode->get_firstChild(&firstChildNode);

        // Insert ARM's comment entry block
        SYSTEMTIME  st;
        FILETIME    ft;
        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ft);

        SimplifyInsertBeforeARMEntryComment(Document, assemblyBindingNode, firstChildNode, &ft, dwPolicyRollingCount);

        // Create a ARM comment node and insert the original
        // assemblyIdentity xml for preservation
        if(!fCreated) {
            CSmartRef<IXMLDOMComment> Comment;
            WCHAR           wszTimeChange[4096];
            WCHAR           wzDateBuf[STRING_BUFFER];

            *wszTimeChange = L'\0';
            *wzDateBuf = L'\0';

            FormatDateString(&ft, NULL, TRUE, wzDateBuf, ARRAYSIZE(wzDateBuf));
            wnsprintf(wszTimeChange, ARRAYSIZE(wszTimeChange), wszArmRollBackBlock, dwPolicyRollingCount, wzDateBuf);
            _bstr_t     bStrBuf = wszTimeChange;

            if(SUCCEEDED(Document->createComment(bStrBuf, &Comment))) {
                if(SUCCEEDED(Comment->appendData(bstrPubPolicyXmlData))) {
                    CSmartRef<IXMLDOMNode> NewNode;

                    assemblyBindingNode->appendChild(Comment, &NewNode);
                }
            }
        }

        publisherPolicyNode = NULL;
    }

    MyTrace("SetGlobalSafeMode - Exit");

    // Now save the document
    return SimplifySaveXmlDocument(Document, TRUE, wszSourceName);
}

// **************************************************************************/
HRESULT UnSetGlobalSafeMode(CSmartRef<IXMLDOMDocument2> &Document)
{
    CSmartRef<IXMLDOMNodeList> assemblyBindingTag;
    LONG            lDepAsmlength;

    MyTrace("UnSetGlobalSafeMode - Entry");

    // Now, let's select all the 'assemblyBinding' blocks
    if( FAILED(Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingTag )) ) {
        return E_FAIL;
    }

    // See if we really have one
    assemblyBindingTag->get_length( &lDepAsmlength );
    if(!lDepAsmlength) {
        return S_OK;
    }

    // Check all assemblyBindingTag nodes
    CSmartRef<IXMLDOMNode> assemblyChildNode;
    CSmartRef<IXMLDOMNode> publisherPolicyNode;
    BOOL    bFoundNodeOfInterest = FALSE;

    assemblyBindingTag->reset();

    while( SUCCEEDED(assemblyBindingTag->nextNode(&assemblyChildNode)) ) {
        if( assemblyChildNode == NULL ) {
            break;            // All done
        }

        CSmartRef<IXMLDOMNodeList> assemblyChildren;
        assemblyChildNode->get_childNodes(&assemblyChildren);
        assemblyChildren->get_length( &lDepAsmlength );
        if(lDepAsmlength) {

            // Check to see if this is the assemblynode were interested in
            assemblyChildren->reset();
            while(SUCCEEDED(assemblyChildren->nextNode(&publisherPolicyNode)) ) {
                if( publisherPolicyNode == NULL ) {
                    break;            // All done
                }

                BSTR    bstrNodeName;

                if(SUCCEEDED(publisherPolicyNode->get_nodeName(&bstrNodeName))) {
                    if(!FusionCompareString(XML_PUBLISHERPOLICY_KEY, bstrNodeName)) {

                        // See if this one is surround by NAR comment blocks
                        // and delete those as appropriate.
                        CSmartRef<IXMLDOMNode> commentNode;

                        publisherPolicyNode->get_previousSibling(&commentNode);
                        if(commentNode != NULL) {
                            BSTR        bstrXmlData = NULL;
                            commentNode->get_text(&bstrXmlData);
                            if(StrStrI(bstrXmlData, wszArmEntryBeginNoVal)) {
                                // Delete this comment node
                                CSmartRef<IXMLDOMNode> parentNode;
                                publisherPolicyNode->get_parentNode(&parentNode);
                                if(parentNode != NULL) {
                                    parentNode->removeChild(commentNode, NULL);
                                }
                            }
                            SAFESYSFREESTRING(bstrXmlData);
                        }

                        commentNode = NULL;
                        publisherPolicyNode->get_nextSibling(&commentNode);
                        if(commentNode != NULL) {
                            BSTR        bstrXmlData = NULL;
                            commentNode->get_text(&bstrXmlData);
                            if(StrStrI(bstrXmlData, wszArmEntryEndNoVal)) {
                                // Delete this comment node
                                CSmartRef<IXMLDOMNode> parentNode;
                                publisherPolicyNode->get_parentNode(&parentNode);
                                if(parentNode != NULL) {
                                    parentNode->removeChild(commentNode, NULL);
                                }
                            }
                            SAFESYSFREESTRING(bstrXmlData);
                        }
                        {
                            CSmartRef<IXMLDOMNode> parentNode;
                            publisherPolicyNode->get_parentNode(&parentNode);
                            parentNode->removeChild(publisherPolicyNode, NULL);
                            parentNode = NULL;
                        }
                    }
                    SAFESYSFREESTRING(bstrNodeName);
                }
                publisherPolicyNode = NULL;
            }
        }
        assemblyChildNode = NULL;
    }

    MyTrace("UnSetGlobalSafeMode - Exit");

    return S_OK;
}

// **************************************************************************/
HRESULT IsGlobalSafeModeSet(IHistoryReader *pReader, BOOL *fSafeModeSet)
{
    // Check to see if SafeMode is already set in pReaders app.cfg
    CSmartRef<IXMLDOMDocument2> Document;
    CSmartRef<IXMLDOMElement> rootElement;
    CSmartRef<IXMLDOMNodeList> publisherPoilcyTags;
    CSmartRef<IXMLDOMNode> publisherPolicyNode;

    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wzStrError[_MAX_PATH * 2];
    HRESULT         hr = S_OK;

    if(!pReader) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    *fSafeModeSet = FALSE;

    if(!InitializeMSXML()) {
        return E_FAIL;
    }
    
    // Get App.Config filename
    if(FAILED(GetExeModulePath(pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH)
        return E_FAIL;
    StrCat(wszSourceName, CONFIG_EXTENSION);

    // File doesn't exist, No safemode set
    if(WszGetFileAttributes(wszSourceName) == -1) {
        return S_OK;
    }

    // Construct XMLDOM and load our config file
    if( FAILED(hr = ConstructXMLDOMObject(Document, wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Failed opening the config file '%ws' for input under the DOM.", wszSourceName);
        MyTraceW(wzStrError);
        return hr;
    }

    // Get the root of the document
    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"The manifest '%ws' may be malformed, unable to load the root element!", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Now, let's select all the 'publisherPolicy' blocks
    if( FAILED(Document->selectNodes(_bstr_t(XML_SAFEMODE_PUBLISHERPOLICY), &publisherPoilcyTags )) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_PUBLISHERPOLICY_KEY);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    publisherPoilcyTags->reset();

    // Find the first publisherpolicy tag that's parent is assemblyBinding
    while( SUCCEEDED(publisherPoilcyTags->nextNode(&publisherPolicyNode)) ) {
        if( publisherPolicyNode == NULL ) {
            break;            // All done
        }

        CSmartRef<IXMLDOMNode>       parentNode;

        publisherPolicyNode->get_parentNode(&parentNode);
        if(parentNode != NULL) {
            BSTR        bstrNodeName;
            INT_PTR     iResult;

            parentNode->get_nodeName(&bstrNodeName);
            iResult = FusionCompareString(XML_ASSEMBLYBINDINGS_KEY, bstrNodeName);
            SAFESYSFREESTRING(bstrNodeName);

            if(!iResult) {

                // Now check the attribute to make sure it's set
                CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
                _bstr_t     bstrApply;

                // Get all the data needed to check if this is our node of interest
                if(SUCCEEDED(publisherPolicyNode->get_attributes( &Attributes )) ) {
                    SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLY, &bstrApply);

                    if(!FusionCompareString(XML_ATTRIBUTE_APPLY_NO, bstrApply)) {
                        *fSafeModeSet = TRUE;
                        break;
                    }
                }
            }
            parentNode = NULL;
        }
        publisherPolicyNode = NULL;
    }

    return S_OK;
}

// **************************************************************************/
HRESULT SetSupportedRuntime(CSmartRef<IXMLDOMDocument2> &Document, LPBINDENTRYINFO pBindInfo)
{
    CSmartRef<IXMLDOMNodeList> supportRuntimeNodeList;
    CSmartRef<IXMLDOMNode> startupNode;
    CSmartRef<IXMLDOMNode> newstartupNode;
    CSmartRef<IXMLDOMNode> supportedRuntimeNode;
    CSmartRef<IXMLDOMNode> newsupportedRuntimeNode;
    HRESULT                hr = S_OK;
    DWORD                  dwPolicyRollingCount = 0;
    _bstr_t                bstrNodeXmlData;
    DWORD                  dwPosCount;
    
    MyTrace("SetSupportedRuntime - Entry");

    // No COR version to check
    if(!pBindInfo) {
        ASSERT(0);
        hr = E_INVALIDARG;
        goto Exit;
    }

    // If wzRuntimeVer is blank, then the snapshots
    // runtime versions match.
    if(!lstrlen(pBindInfo->wzRuntimeRefVer)) {
        MyTrace("No supportedRuntime version specified");
        goto Exit;
    }

    // Get original startup XML data if exists
    Document->selectSingleNode(_bstr_t(XML_STARTUP), &startupNode);
    SimplifyGetOriginalNodeData(startupNode, &bstrNodeXmlData);

    if(FAILED(hr = Document->selectNodes(_bstr_t(XML_SUPPORTED_RUNTIME), &supportRuntimeNodeList)) ) {
        MyTrace("Unable to select the supportRuntime nodes, can't proceed.");
        goto Exit;
    }
    
    supportRuntimeNodeList->reset();
    dwPosCount = 0;

    // Examine all the supportedRuntime nodes to ensure we have at least one
    // that specifies the version of the runtime that this app needs
    while(SUCCEEDED(supportRuntimeNodeList->nextNode(&supportedRuntimeNode)) ) {
        CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
        _bstr_t     bstrVersion;

        if(supportedRuntimeNode == NULL ) {
            break;            // All done
        }

        if(SUCCEEDED(supportedRuntimeNode->get_attributes(&Attributes))) {
            SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_VERSION, &bstrVersion);
        }

        if(bstrVersion.length() && !FusionCompareString(pBindInfo->wzRuntimeRefVer, bstrVersion, TRUE)) {
            break;
        }

        supportedRuntimeNode = NULL;
        dwPosCount++;
    }

    if(supportedRuntimeNode) {
        MyTrace("A matching supportedRuntime version found");

        // If it's the 1st one in the list then it's ok to bail
        if(!dwPosCount) {
            goto Exit;
        }

        MyTrace("Moving matching supportedRuntime to 1st position");

        CSmartRef<IXMLDOMNode> tempNode;
        CSmartRef<IXMLDOMNode> firstChildNode;

        // Move the supportedRuntimeNode we found to the 1st position
        startupNode->removeChild(supportedRuntimeNode, &tempNode);
        startupNode->get_firstChild(&firstChildNode);
        hr = SimplifyInsertNodeBefore(Document, startupNode, firstChildNode, tempNode);
        if(FAILED(hr)) {
            MyTrace("Failed to move to the 1st position.");
            goto Exit;
        }

        pBindInfo->fPolicyChanged = TRUE;
        goto Exit;
    }

    MyTrace("No supportedRuntime version found.");

    // Get rollback count to increment
    if(SUCCEEDED(GetRollBackCount(Document, &dwPolicyRollingCount))) {
        dwPolicyRollingCount++;
    }
    else {
        dwPolicyRollingCount = 1;
    }

    if(FAILED(hr = SimplifyConstructNode(Document, NODE_ELEMENT, XML_STARTUP_KEY, "", &newstartupNode))) {
        MyTrace("Unable to create new startup node");
        goto Exit;
    }

    // Make ARM's entry block
    SimplifyAppendARMBeginComment(Document, newstartupNode, &pBindInfo->ftRevertToSnapShot, dwPolicyRollingCount);

    if(FAILED(hr = SimplifyConstructNode(Document, NODE_ELEMENT, XML_SUPPORTEDRUNTIME_KEY, "", &newsupportedRuntimeNode))) {
        MyTrace("Unable to create new supportedRuntime node");
        goto Exit;
    }

    SimplifyPutAttribute(Document, newsupportedRuntimeNode, XML_ATTRIBUTE_VERSION, pBindInfo->wzRuntimeRefVer, NULL);

    // Append the new runtime node to the new startup node
    newstartupNode->appendChild(newsupportedRuntimeNode, NULL);

    // <startup> Now append all other tags we don't know about
    SimplifyAppendNodeUknowns(startupNode, newstartupNode, NULL);

    // Create a ARM comment node and insert the original
    // startup xml for preservation
    if(bstrNodeXmlData.length()) {
        CSmartRef<IXMLDOMComment> Comment;
        WCHAR           wszTimeChange[4096];
        WCHAR           wzDateBuf[STRING_BUFFER];
        FILETIME        ftTemp;

        *wszTimeChange = L'\0';
        *wzDateBuf = L'\0';

        GetSystemTimeAsFileTime(&ftTemp);
        FormatDateString(&ftTemp, NULL, TRUE, wzDateBuf, ARRAYSIZE(wzDateBuf));
        wnsprintf(wszTimeChange, ARRAYSIZE(wszTimeChange), wszArmRollBackBlock,
            dwPolicyRollingCount, wzDateBuf);
        _bstr_t     bStrBuf = wszTimeChange;
        
        if(SUCCEEDED(Document->createComment(bStrBuf, &Comment))) {
            if(SUCCEEDED(Comment->appendData(bstrNodeXmlData))) {
                newstartupNode->appendChild(Comment, NULL);
            }
        }
    }

    // Make ARM's comment exit block
    SimplifyAppendARMExitComment(Document, newstartupNode, dwPolicyRollingCount);

    if(!startupNode) {
        // Need to insert new node into document
        CSmartRef<IXMLDOMNode>      runtimeNode;
        CSmartRef<IXMLDOMNode>      destNode;

        Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode);
        if(!runtimeNode) {
            MyTrace("Failed to selectSingleNode 'XML_RUNTIME");
            hr = E_UNEXPECTED;
            goto Exit;
        }
        
        Document->selectSingleNode(_bstr_t(XML_CONFIGURATION), &destNode);
        if(!destNode) {
            MyTrace("Failed to selectSingleNode 'XML_CONFIGURATION");
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if(FAILED(SimplifyInsertNodeBefore(Document, destNode, runtimeNode, newstartupNode))) {
            MyTrace("Failed to insertBefore new startupNode in document.");
            hr = E_UNEXPECTED;
            goto Exit;
        }
    }
    else {
        // Has a parent, so just replace old with new
        CSmartRef<IXMLDOMNode>      parentNode;

        startupNode->get_parentNode(&parentNode);
        if(parentNode == NULL) {
            MyTrace("Failed to get parent of startup node.");
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if(FAILED(parentNode->replaceChild(newstartupNode, startupNode, NULL))) {
            MyTrace("Failed to replaceChild node in document.");
            hr = E_UNEXPECTED;
            goto Exit;
        }
    }

    pBindInfo->fPolicyChanged = TRUE;

Exit:

    MyTrace("SetSupportedRuntime - Exit");        
    return hr;
}

// **************************************************************************/
HRESULT InsertNewPolicy(HWND hParentWnd, LPBINDENTRYINFO pBindInfo, HWND hWorkingWnd)
{
    CSmartRef<IXMLDOMDocument2> Document;
    CSmartRef<IXMLDOMElement>   rootElement;
    CSmartRef<IXMLDOMNodeList>  dependentAssemblyTags;
    CSmartRef<IXMLDOMNode>      PrePendAssemblyBindingBuffNode;
    CSmartRef<IXMLDOMNode>      PostAppendAssemblyBindingBuffNode;
    CSmartRef<IXMLDOMNodeList>  assemblyBindingList;
    CSmartRef<IXMLDOMNode>      assemblyBindingNode;
    LISTNODE        pListNode = NULL;
    WCHAR           wszSourceName[_MAX_PATH];
    WCHAR           wzStrError[_MAX_PATH * 2];
    HRESULT         hr = S_OK;
    BOOL            fTemplateFileCreated = FALSE;
    BOOL            fFoundDependentAssemblyOfInterest;
    BOOL            fRunInRTMCorVer = FALSE;
    BOOL            fDocHasAppliesTo = FALSE;
    
    MyTrace("InsertNewPolicy - Entry");

    if(!pBindInfo->pABDList) {
        MyTrace("InsertNewPolicy - No Assembly Binding Diff Data.");
        ASSERT(0);
        return E_FAIL;
    }

    if(!InitializeMSXML()) {
        return E_FAIL;
    }

    // Run this in RTM Version?
    fRunInRTMCorVer = FusionCompareString(pBindInfo->wzSnapshotRuntimeVer, RTM_CORVERSION, FALSE) ? FALSE : TRUE;
    
    // Get App.Config filename
    if(FAILED(GetExeModulePath(pBindInfo->pReader, wszSourceName, ARRAYSIZE(wszSourceName)))) {
        return E_FAIL;
    }

    // Build path and filename to .config file
    if (lstrlen(wszSourceName) + lstrlen(CONFIG_EXTENSION) + 1 > _MAX_PATH)
        return E_FAIL;
    StrCat(wszSourceName, CONFIG_EXTENSION);

    // No changes yet
    pBindInfo->fPolicyChanged = FALSE;

    // Construct a basic template file if needed
    if(FAILED(hr = WriteBasicConfigFile(wszSourceName, &fTemplateFileCreated))) {
        MyTrace("InsertNewPolicy::Failed to create a template config file");
        return hr;
    }

    // If we didn't create a template file, then check the file
    // hash's to make sure we don't lose any changes
    if(!fTemplateFileCreated && FAILED(HasFileBeenModified(wszSourceName))) {
        // Pop an error dialog asking if they want to lose changes.
        WCHAR   wszMsg[1024];
        WCHAR   wszFmt[1024];
        int     iResponse;

        WszLoadString(g_hFusResDllMod, IDS_FILE_CONTENTS_CHANGED, wszFmt, ARRAYSIZE(wszFmt));
        wnsprintf(wszMsg, ARRAYSIZE(wszMsg), wszFmt, wszSourceName);

        if(IsWindow(hWorkingWnd)) {
            ShowWindow(hWorkingWnd, FALSE);
        }

        iResponse = WszMessageBox(hParentWnd, wszMsg, wszARMName,
            (g_fBiDi ? MB_RTLREADING : 0) | MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);

        if(iResponse != IDYES) {
            // It's ok for the user to cancel
            return S_OK;
        }

        if(IsWindow(hWorkingWnd)) {
            ShowWindow(hWorkingWnd, TRUE);
        }
    }

    // Construct XMLDOM and load our config file
    if( FAILED(hr = ConstructXMLDOMObject(Document, wszSourceName)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"Failed opening the config file '%ws' for input under the DOM.", wszSourceName);
        MyTraceW(wzStrError);
        return hr;
    }

    // Get the root of the document
    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"The manifest '%ws' may be malformed, unable to load the root element!", wszSourceName);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    // Normalize the document
    rootElement->normalize();

    // Construct our PrePendAssemblyBindingBuffNode
    hr = SimplifyConstructNode(Document, NODE_ELEMENT, XML_ASSEMBLYBINDINGS_KEY, ASM_NAMESPACE_URI, &PrePendAssemblyBindingBuffNode);
    if(FAILED(hr) || !PrePendAssemblyBindingBuffNode) {
        MyTrace("Unable to create new PrePendAssemblyBindingBuffNode node");
        return E_FAIL;
    }

    // Construct our PostAppendAssemblyBindingBuffNode
    hr = SimplifyConstructNode(Document, NODE_ELEMENT, XML_ASSEMBLYBINDINGS_KEY, ASM_NAMESPACE_URI, &PostAppendAssemblyBindingBuffNode);
    if(FAILED(hr) || !PostAppendAssemblyBindingBuffNode) {
        MyTrace("Unable to create new PostAppendAssemblyBindingBuffNode node");
        return E_FAIL;
    }

    // Check the CLR runtime versions
    hr = SetSupportedRuntime(Document, pBindInfo);
    if(FAILED(hr)) {
        goto Exit;
    }

    // Check document for any appliesTo tags
    hr = HasAssemblyBindingAppliesTo(Document, &fDocHasAppliesTo);
    if(FAILED(hr)) {
        // Non critical failure - means we add RTM appliesTo if
        // always set to false
        MyTrace("HasAssemblyBindingAppliesTo has failed");
    }
    
    // Now, let's select all the 'dependentAssembly' blocks:
    if(FAILED(hr = Document->selectNodes(_bstr_t(XML_DEPENDENTASSEMBLY), &dependentAssemblyTags )) ) {
        MyTrace("Unable to select the dependentAssembly nodes, can't proceed.");
        return hr;
    }

    // Get the fist node below /configuration/runtime/assemblyBinding, this will be the new nodes parent    
    if( FAILED(Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        return E_FAIL;
    }

    assemblyBindingList->reset();
    assemblyBindingList->nextNode(&assemblyBindingNode);

    // No assemblyBinding node, create one
    if(!assemblyBindingNode) {
        CSmartRef<IXMLDOMNode> runtimeNode;
        CSmartRef<IXMLDOMNode> tempNode;

        if(FAILED(Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode)) ) {
            wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, wszSourceName, XML_ASSEMBLYBINDINGS);
            MyTraceW(wzStrError);
            return E_FAIL;
        }

        if(FAILED(SimplifyConstructNode(Document, NODE_ELEMENT, XML_ASSEMBLYBINDINGS_KEY, ASM_NAMESPACE_URI, &assemblyBindingNode))) {
            MyTrace("Unable to create new assemblyBinding node");
            return E_FAIL;
        }
        runtimeNode->appendChild(assemblyBindingNode, &tempNode);
        assemblyBindingNode = tempNode;
    }

    // Get the begining of our list of asm diff data
    pListNode = pBindInfo->pABDList->GetHeadPosition();

    // While we have diff data
    while(pListNode != NULL) {
        CSmartRef<IXMLDOMNode> dependentAssemblyNode;
        AsmBindDiffs    *pABD;
        BOOL            fChanged;

        dependentAssemblyTags = NULL;

        // Now, let's select all the 'dependentAssembly' blocks:
        if( FAILED(hr = Document->selectNodes(_bstr_t(XML_DEPENDENTASSEMBLY), &dependentAssemblyTags )) ) {
            MyTrace("Unable to select the dependentAssembly nodes, can't proceed.");
            return E_FAIL;
        }

        fFoundDependentAssemblyOfInterest = FALSE;

        // Get acutal asm diff data
        pABD = pBindInfo->pABDList->GetAt(pListNode);

        // Check all dependentAssembly nodes
        dependentAssemblyTags->reset();

        while( SUCCEEDED(dependentAssemblyTags->nextNode(&dependentAssemblyNode)) ) {
            if( dependentAssemblyNode == NULL ) {
                break;            // All done
            }

            CSmartRef<IXMLDOMNodeList>  dependentAssemblyChildren;
            CSmartRef<IXMLDOMNode>      dependentAssemblyNodeData;

            dependentAssemblyNode->get_childNodes(&dependentAssemblyChildren);
            if(dependentAssemblyChildren) {
                // Check to see if this is the assemblynode were interested in
                dependentAssemblyChildren->reset();
                while(SUCCEEDED(dependentAssemblyChildren->nextNode(&dependentAssemblyNodeData))) {
                    if( dependentAssemblyNodeData == NULL ) {
                        break;            // All done
                    }

                    CSmartRef<IXMLDOMNode> parentAssemblyBinding;
                    CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
                    _bstr_t                bstrAppliesTo;
                    BSTR                   bstrNodeName;
                    BOOL                   fMatchingAppliesTo;

                    parentAssemblyBinding = NULL;
                    Attributes = NULL;
                    fMatchingAppliesTo = FALSE;

                    // Get the parent node '<assemblyBinding>' node and get its
                    // appliesTo attribute
                    dependentAssemblyNode->get_parentNode(&parentAssemblyBinding);
                    hr = parentAssemblyBinding->get_attributes( &Attributes );

                    if(SUCCEEDED(hr)) {
                        SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLIESTO, &bstrAppliesTo);

                        BOOL fRunTimeMatch = FusionCompareStringI(pBindInfo->wzSnapshotRuntimeVer, bstrAppliesTo) ? FALSE : TRUE;

                        if(fDocHasAppliesTo && fRunTimeMatch) {
                            fMatchingAppliesTo = TRUE;
                        }
                        else if(!fDocHasAppliesTo && !bstrAppliesTo.length()) {
                            fMatchingAppliesTo = TRUE;
                        }
                    }

                    // We don't need to check this assembly
                    if(!fMatchingAppliesTo) {
                        dependentAssemblyNodeData = NULL;
                        continue;
                    }

                    if(SUCCEEDED(dependentAssemblyNodeData->get_nodeName(&bstrNodeName))) {
                        int     iCompareResult = FusionCompareString(XML_ASSEMBLYIDENTITY_KEY, bstrNodeName);
                        SAFESYSFREESTRING(bstrNodeName);

                        if(!iCompareResult) {
                            // We found an assemblyIdentity tag, see if it's the
                            // one were interested in.
                            CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
                            _bstr_t     bstrAssemblyName;
                            _bstr_t     bstrPublicKeyToken;
                            _bstr_t     bstrCulture;

                            // Get all the data needed to check if this is our node of interest
                            if(SUCCEEDED( hr = dependentAssemblyNodeData->get_attributes( &Attributes )) ) {
                                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_NAME, &bstrAssemblyName);
                                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_PUBLICKEYTOKEN, &bstrPublicKeyToken);
                                SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_CULTURE, &bstrCulture);
                            }

                            BOOL    fAsmCmp = FusionCompareStringI(bstrAssemblyName, pABD->wzAssemblyName) ? FALSE : TRUE;
                            BOOL    fPKTCmp = FusionCompareStringI(bstrPublicKeyToken, pABD->wzPublicKeyToken) ? FALSE : TRUE;
                            BOOL    fCultureCmp = FusionCompareStringI(bstrCulture, pABD->wzCulture) ? FALSE : TRUE;

                            if(!fCultureCmp) {
                                // Special cases for culture Compare, Empty and NULL
                                if( (!bstrCulture.length()) && (lstrlen(pABD->wzCulture) == 0)) {
                                    fCultureCmp = TRUE;
                                }
                            }

                            if(!fCultureCmp) {
                                // Special case 'neutral' culture
                                if(!FusionCompareStringI(bstrCulture, SZ_LANGUAGE_TYPE_NEUTRAL)) {
                                    if(!FusionCompareStringI(pABD->wzCulture, SZ_LANGUAGE_TYPE_NEUTRAL) || lstrlen(pABD->wzCulture) == 0 ) {
                                        fCultureCmp = TRUE;
                                    }
                                }
                            }

                            // Now check for Reference match
                            BOOL    fRefMatch = FALSE;
                            if(fAsmCmp && fPKTCmp && fCultureCmp) {
                                CSmartRef<IXMLDOMNode>  bindingRedirectNode;
                                BOOL    fDoesHaveBindingRedirects = FALSE;

                                GetReferencedBindingRedirectNode(dependentAssemblyNode, 
                                    bindingRedirectNode, pABD->wzVerRef, &fDoesHaveBindingRedirects);

                                // If a bindingRedirect is returned, then our
                                // ref's match, else no bindingRedirect exists at all
                                // in this assembly so this is our assembly to modify
                                if(bindingRedirectNode || !fDoesHaveBindingRedirects) {
                                    fRefMatch = TRUE;
                                }
                            }

                            // If all compare, then this is our puppy
                            fChanged = FALSE;
                            if(fAsmCmp && fPKTCmp && fCultureCmp && fRefMatch) {
                                if(FAILED(FixDependentAssemblyNode(Document, dependentAssemblyNode, PrePendAssemblyBindingBuffNode, 
                                    PostAppendAssemblyBindingBuffNode, &pBindInfo->ftRevertToSnapShot, pABD, fRunInRTMCorVer, fDocHasAppliesTo, &fChanged))) {
                                    MyTrace("Failed to create new assemblynode or insert in DOM document");
                                    return E_FAIL;
                                }

                                // Fix 449328 - ARM tool not reverting back publisher policy changes
                                fFoundDependentAssemblyOfInterest = TRUE;
                            }

                            if(fChanged) {
                                pBindInfo->fPolicyChanged = TRUE;
                            }
                            break;
                        }
                    }
                    dependentAssemblyNodeData = NULL;
                }
            }
            dependentAssemblyNode = NULL;
        }

        // We didn't find dependentAssembly
        fChanged = FALSE;
        if(!fFoundDependentAssemblyOfInterest) {
            if(FAILED(FixDependentAssemblyNode(Document, (CSmartRef<IXMLDOMNode>) NULL, PrePendAssemblyBindingBuffNode,
                PostAppendAssemblyBindingBuffNode, &pBindInfo->ftRevertToSnapShot, pABD, fRunInRTMCorVer, fDocHasAppliesTo, &fChanged))) {
                MyTrace("Failed to create new assemblynode or insert in DOM document");
                return E_FAIL;
            }
        }

        pBindInfo->pABDList->GetNext(pListNode);

        if(fChanged) {
            pBindInfo->fPolicyChanged = TRUE;
        }
    }

    //
    // ****** Finalize:: Check for changes
    //
    //
    if(pBindInfo->fPolicyChanged) {
        VARIANT_BOOL    vbHasChildren;
        BOOL            fSafeModeSet;

        // Fix # 396186, ensure global safemode is removed
        // Remove SafeMode if it's set
        hr = IsGlobalSafeModeSet(pBindInfo->pReader, &fSafeModeSet);
        if(SUCCEEDED(hr) && fSafeModeSet) {
            // Unset global safemode
            hr = UnSetGlobalSafeMode(Document);
            if(FAILED(hr)) {
                goto Exit;
            }
        }

        // Check working buffers for data
        //
        //

        // Check the PrePend buffer
        hr = PrePendAssemblyBindingBuffNode->hasChildNodes(&vbHasChildren);
        if(SUCCEEDED(hr) && vbHasChildren == VARIANT_TRUE) {

            // Place it into the top of the app.cfg file
            CSmartRef<IXMLDOMNode>      runtimeNode;
            CSmartRef<IXMLDOMNode>      destNode;

            Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode);
            if(!runtimeNode) {
                MyTrace("Failed to selectSingleNode 'XML_RUNTIME");
                hr = E_FAIL;
                goto Exit;
            }
            
            // Put the RTM appliesTo version in
            if(fDocHasAppliesTo) {
                SimplifyPutAttribute(Document, PrePendAssemblyBindingBuffNode, XML_ATTRIBUTE_APPLIESTO, RTM_CORVERSION, NULL);
            }

            Document->selectSingleNode(_bstr_t(XML_ASSEMBLYBINDINGS), &destNode);
            if(!destNode) {
                MyTrace("Failed to selectSingleNode 'XML_ASSEMBLYBINDINGS");
                hr = E_FAIL;
                goto Exit;
            }

            hr = SimplifyInsertNodeBefore(Document, runtimeNode, destNode, PrePendAssemblyBindingBuffNode);
            if(FAILED(hr)) {
                MyTrace("Failed to insertBefore new PrePendAssemblyBindingBuffNode in document.");
                hr = E_FAIL;
                goto Exit;
            }
        }

        // Check our PostPend buffer
        hr = PostAppendAssemblyBindingBuffNode->hasChildNodes(&vbHasChildren);
        if(SUCCEEDED(hr) && vbHasChildren == VARIANT_TRUE) {
            CSmartRef<IXMLDOMNode>      runtimeNode;
            CSmartRef<IXMLDOMNode>      tempNode;

            Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode);
            if(!runtimeNode) {
                MyTrace("Failed to selectSingleNode 'XML_RUNTIME");
                hr = E_FAIL;
                goto Exit;
            }

            // Now append the end of the xml doc
            hr = runtimeNode->appendChild(PostAppendAssemblyBindingBuffNode, &tempNode);
            if(FAILED(hr)) {
                MyTrace("Failed appendChild for PostAppendAssemblyBindingBuffNode on runtimeNode");
                goto Exit;
            }
        }

        // Backup original config file
        hr = BackupConfigFile(wszSourceName);
        if(FAILED(hr)) {
            wnsprintf(wzStrError, ARRAYSIZE(wzStrError), L"InsertNewPolicy::Failed to backup '%ws'config file", wszSourceName);
            MyTraceW(wzStrError);
            goto Exit;
        }

        hr = SimplifySaveXmlDocument(Document, TRUE, wszSourceName);
    }

Exit:

    MyTrace("InsertNewPolicy - Exit");

    return hr;
}

// HRESULT PrettyFormatXML(IXMLDOMDocument2 *pXMLDoc, IXMLDOMNode *pRootNode, LONG dwLevel)
//
/////////////////////////////////////////////////////////////////////////
HRESULT PrettyFormatXML(CSmartRef<IXMLDOMDocument2> &pXMLDoc, CSmartRef<IXMLDOMNode> &pRootNode, LONG dwLevel)
{
    CSmartRef<IXMLDOMNode> pNode;
    CSmartRef<IXMLDOMNode> pNewNode;
    LPWSTR                 pwzWhiteSpace1;
    LPWSTR                 pwzWhiteSpace2;
    BOOL                   bHasChildren = FALSE;    
    HRESULT                hr = S_OK;

    pwzWhiteSpace1 = CreatePad(TRUE, FALSE, (dwLevel - 1) * g_dwNodeSpaceSize);
    pwzWhiteSpace2 = CreatePad(TRUE, FALSE, dwLevel * g_dwNodeSpaceSize);

    hr = pRootNode->get_firstChild(&pNode);
    while(pNode != NULL) {    
        bHasChildren = TRUE;

        SimplifyInsertTextBefore(pXMLDoc, pRootNode, pNode, pwzWhiteSpace2);

        if (FAILED(PrettyFormatXML(pXMLDoc, pNode, dwLevel+1))) {
            goto Exit;
        }

        pNode->get_nextSibling(&pNewNode);
        pNode = pNewNode;
        pNewNode = NULL;
    }

    if (bHasChildren) {   
        SimplifyAppendTextNode(pXMLDoc, pRootNode, pwzWhiteSpace1);
    }

Exit:

    SAFEDELETEARRAY(pwzWhiteSpace1);
    SAFEDELETEARRAY(pwzWhiteSpace2);

    return hr;
}

//
// PrettyFormatXmlDocument - Nicely format the xml document so it can be
//                           easily read
//
/////////////////////////////////////////////////////////////////////////
HRESULT PrettyFormatXmlDocument(CSmartRef<IXMLDOMDocument2> &Document)
{
    CSmartRef<IXMLDOMElement>   rootElement;
    CSmartRef<IXMLDOMNode>      Node;
    HRESULT                     hr = S_OK;
    DWORD                       dwChar;

    if( FAILED(Document->get_documentElement( &rootElement ) ) ) {
        MyTrace("The manifest may be malformed, unable to load the root element!");
        return E_FAIL;
    }

    GetRegistryNodeSpaceInfo(&dwChar, &g_dwNodeSpaceSize);
    g_wcNodeSpaceChar = (WCHAR) dwChar;

    Node = rootElement;
    PrettyFormatXML(Document, Node, 1);
    return hr;
}

//
// Implied ordering method is:
//      assemblyBindings with appliesTo RTM version
//      assemblyBindings with appliesTo except RTM version
//      assemlbyBindings without appliesTo
//
// **************************************************************************/
HRESULT OrderDocmentAssemblyBindings(
  CSmartRef<IXMLDOMDocument2> &Document,
  LPWSTR pwzSourceName,
  BOOL *pfDisposition)
{
    CSmartRef<IXMLDOMNodeList> assemblyBindingList;
    CSmartRef<IXMLDOMNode>     assemblyBindingNode;
    CSmartRef<IXMLDOMNode>     runtimeNode;
    CSmartRef<IXMLDOMNode>     newRuntimeNode;
    WCHAR                      wzStrError[MAX_PATH * 2];
    HRESULT                    hr = S_OK;
    LONG                       lNodeCount;
    int                        iPass;
    BOOL                       fSequenceChange;
    
    MyTrace("OrderDocumentAssemblyBindings - Entry");
        
    if(!Document || !pfDisposition) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pfDisposition = fSequenceChange = FALSE;

    // Get the fist node below /configuration/runtime/assemblyBinding, this will be the new nodes parent
    if(FAILED(Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, pwzSourceName, XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // 1 Node or less, no work to do
    assemblyBindingList->get_length( &lNodeCount );
    if(lNodeCount <= 1) {
        goto Exit;
    }

    Document->selectSingleNode(_bstr_t(XML_RUNTIME), &runtimeNode);
    if(!runtimeNode) {
        MyTrace("Failed to selectSingleNode 'XML_RUNTIME");
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = SimplifyConstructNode(Document, NODE_ELEMENT, XML_RUNTIME_KEY, _bstr_t(), &newRuntimeNode);
    if(FAILED(hr) || !newRuntimeNode) {
        MyTrace("Unable to create new newRuntimeNode node");
        hr = E_UNEXPECTED;
        goto Exit;
    }

    assemblyBindingList->reset();
    iPass = 0;

    while(SUCCEEDED(assemblyBindingList->nextNode(&assemblyBindingNode))) {
        CSmartRef<IXMLDOMNode>          parent;
        CSmartRef<IXMLDOMNode>          original;
        CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
        _bstr_t                         bstrAppliesTo;
        int                             iRes;

        if(!assemblyBindingNode) {
            iPass++;
            if(iPass > 2) {
                break;      // All done
            }

            // Reselect the list since things might
            // have been moved out
            assemblyBindingList = NULL;

            if(FAILED(Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList)) ) {
                wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, pwzSourceName, XML_ASSEMBLYBINDINGS);
                MyTraceW(wzStrError);
                hr = E_UNEXPECTED;
                goto Exit;
            }
            assemblyBindingList->reset();

            continue;
        }

        assemblyBindingNode->get_parentNode(&parent);

        // Get all the data needed to check if this is our node of interest
        if(FAILED(assemblyBindingNode->get_attributes(&Attributes))) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLIESTO, &bstrAppliesTo);
        iRes = FusionCompareStringI(RTM_CORVERSION, bstrAppliesTo);

        // Get all RTM Versions
        if(iPass == 0 && iRes == 0) {
            parent->removeChild(assemblyBindingNode, &original);
            newRuntimeNode->appendChild(original, NULL);
        }
        // Grab all non blank appliesTo NOT RTM version
        else if(iPass == 1 && bstrAppliesTo.length() && iRes) {
            parent->removeChild(assemblyBindingNode, &original);
            newRuntimeNode->appendChild(original, NULL);
        }
        // Grab all blank appliesTo
        else if(iPass == 2) {
            parent->removeChild(assemblyBindingNode, &original);
            newRuntimeNode->appendChild(original, NULL);
        }
        else {
            fSequenceChange = TRUE;
        }

        parent = NULL;
        original = NULL;
        Attributes = NULL;
        assemblyBindingNode = NULL;
    }

    assemblyBindingNode = NULL;
    assemblyBindingList = NULL;

    // Put the sorted assemblyBindings back into the document
    if(FAILED(newRuntimeNode->selectNodes(_bstr_t(XML_NAR_NAMESPACE_COLON XML_ASSEMBLYBINDINGS_KEY), &assemblyBindingList)) ) {
        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, pwzSourceName, XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    assemblyBindingList->reset();
    
    while(SUCCEEDED(assemblyBindingList->nextNode(&assemblyBindingNode))) {
        if(!assemblyBindingNode) {
            break;      // All done
        }

        hr = runtimeNode->appendChild(assemblyBindingNode, NULL);
        if(FAILED(hr)) {
            MyTrace("Failed to append ordered assemblyBinding nodes");
            hr = E_UNEXPECTED;
            goto Exit;
        }

        assemblyBindingNode = NULL;
    }

    // If we actually change the ordering
    if(fSequenceChange) {
        MyTrace("Document ordering actually changed");
        *pfDisposition = TRUE;
    }

Exit:
    MyTrace("OrderDocumentAssemblyBindings - Exit");
    return hr;
}

// **************************************************************************/
HRESULT HasAssemblyBindingAppliesTo(
  CSmartRef<IXMLDOMDocument2> &Document,
  BOOL *pfHasAppliesTo)
{
    CSmartRef<IXMLDOMNodeList>  assemblyBindingList;
    CSmartRef<IXMLDOMNode>      assemblyBindingNode;
    HRESULT                     hr =  S_OK;

    MyTrace("HasAssemblyBindingAppliesTo - Entry");

    if(!Document || !pfHasAppliesTo) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pfHasAppliesTo = FALSE;
    
    hr = Document->selectNodes(_bstr_t(XML_ASSEMBLYBINDINGS), &assemblyBindingList);
    if(FAILED(hr) || !assemblyBindingList) {
        WCHAR   wzStrError[MAX_PATH];

        wnsprintf(wzStrError, ARRAYSIZE(wzStrError), SZXML_MALFORMED_ERROR, L"Document", XML_ASSEMBLYBINDINGS);
        MyTraceW(wzStrError);
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    assemblyBindingList->reset();
    
    while(SUCCEEDED(assemblyBindingList->nextNode(&assemblyBindingNode))) {
        CSmartRef<IXMLDOMNamedNodeMap>  Attributes;
        _bstr_t                         bstrAppliesTo;

        if(!assemblyBindingNode) {
            break;      // All done
        }

        hr = assemblyBindingNode->get_attributes(&Attributes);
        if(FAILED(hr) || !Attributes) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        SimplifyGetAttribute(Attributes, XML_ATTRIBUTE_APPLIESTO, &bstrAppliesTo);

        if(bstrAppliesTo.length()) {
            *pfHasAppliesTo = TRUE;
            break;
        }

        assemblyBindingNode = NULL;
        Attributes = NULL;
    }

Exit:
    MyTrace("HasAssemblyBindingAppliesTo - Exit");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\formatting.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <stdio.h>
#include <stdarg.h>
#include "debmacro.h"
#include "fusionbuffer.h"
#include "util.h"

#define UNUSED(_x) (_x)
#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

#if FUSION_WIN
#define wnsprintfW _snwprintf
#define wnsprintfA _snprintf
#endif

BOOL
FusionpFormatFlags(
    DWORD dwFlagsToFormat,
    SIZE_T cMapEntries,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    CStringBuffer *pbuff,
    SIZE_T *pcchWritten
    )
{
    BOOL fSuccess = FALSE;
    SIZE_T cchWritten = 0;
    CStringBuffer buffTemp;
    SIZE_T i;

    if (pcchWritten != NULL)
        *pcchWritten = 0;

    ASSERT(pbuff != NULL);
    if (pbuff == NULL)
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    for (i=0; i<cMapEntries; i++)
    {
        // What the heck does a flag mask of 0 mean?
        ASSERT(prgMapEntries[i].m_dwFlagMask != 0);

        if ((prgMapEntries[i].m_dwFlagMask != 0) &&
            ((dwFlagsToFormat & prgMapEntries[i].m_dwFlagMask) == prgMapEntries[i].m_dwFlagMask))
        {
            // we have a winner...
            if (cchWritten != 0)
            {
                if (!buffTemp.Win32Append(L" | ", 3))
                    goto Exit;

                cchWritten += 3;
            }

            if (!buffTemp.Win32Append(prgMapEntries[i].m_pszString, prgMapEntries[i].m_cchString))
                goto Exit;

            cchWritten += prgMapEntries[i].m_cchString;

            if (prgMapEntries[i].m_dwFlagsToTurnOff != 0)
            {
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagsToTurnOff);
            }
            else
            {
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagMask);
            }
        }
    }

    if (dwFlagsToFormat != 0)
    {
        WCHAR rgwchHexBuffer[16];
        SSIZE_T nCharsWritten = wnsprintfW(rgwchHexBuffer, NUMBER_OF(rgwchHexBuffer), L"0x%08lx", dwFlagsToFormat);

        if (cchWritten != 0)
        {
            if (!buffTemp.Win32Append(L" | ", 3))
                goto Exit;

            cchWritten += 3;
        }

        if (!buffTemp.Win32Append(rgwchHexBuffer, nCharsWritten))
            goto Exit;

        cchWritten += nCharsWritten;
    }

    pbuff->TakeValue(buffTemp, cchWritten);

    if (pcchWritten != NULL)
        *pcchWritten = cchWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\debug.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "debmacro.h"

#include <stdio.h>
#include <stdarg.h>
#include "fusionbuffer.h"
#include "shlwapi.h"

#define UNUSED(_x) (_x)
#define NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))
#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

#if FUSION_WIN
//
//  FUSION_WIN uses the ntdll assertion failure function:
//

EXTERN_C
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );
#endif // FUSION_WIN

typedef ULONG (*RTL_V_DBG_PRINT_EX_FUNCTION)(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

typedef ULONG (*RTL_V_DBG_PRINT_EX_WITH_PREFIX_FUNCTION)(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

RTL_V_DBG_PRINT_EX_FUNCTION g_pfnvDbgPrintEx;
RTL_V_DBG_PRINT_EX_WITH_PREFIX_FUNCTION g_pfnvDbgPrintExWithPrefix;

#if DBG

EXTERN_C void _DebugMsgA(LPCSTR pszMsg, ...)
{
    va_list ap;
    va_start(ap, pszMsg);
    _DebugMsgVaA(pszMsg, ap);
    va_end(ap);
}

EXTERN_C void _DebugMsgVaA(LPCSTR pszMsg, va_list ap)
{
    _DebugMsgExVaA(0, NULL, pszMsg, ap);
}

EXTERN_C void _DebugMsgExA(DWORD dwFlags, LPCSTR pszComponent, LPCSTR pszMsg, ...)
{
    va_list ap;
    va_start(ap, pszMsg);
    _DebugMsgExVaA(dwFlags, pszComponent, pszMsg, ap);
    va_end(ap);
}

EXTERN_C void _DebugMsgExVaA(DWORD dwFlags, LPCSTR pszComponent, LPCSTR pszMsg, va_list ap)
{
    CHAR ach[2*MAX_PATH+40];

    UNUSED(dwFlags);

#if FUSION_WIN
    _vsnprintf(ach, sizeof(ach) / sizeof(ach[0]), pszMsg, ap);
#elif FUSION_URT
    wvsprintfA(ach, pszMsg, ap);
#else
#error "Neither FUSION_WIN nor FUSION_URT are defined; figure out which _vsnprintf() wrapper to use..."
#endif

    if (pszComponent != NULL)
        OutputDebugStringA(pszComponent);

    OutputDebugStringA(ach);
    OutputDebugStringA("\r\n");
}

//UNUSED EXTERN_C void _DebugMsgW(
//UNUSED     LPCWSTR pszMsg,
//UNUSED     ...
//UNUSED     )
//UNUSED {
//UNUSED     va_list ap;
//UNUSED     va_start(ap, pszMsg);
//UNUSED     _DebugMsgVaW(pszMsg, ap);
//UNUSED     va_end(ap);
//UNUSED }

//UNUSED EXTERN_C void _DebugMsgVaW(
//UNUSED     LPCWSTR pszMsg,
//UNUSED     va_list ap
//UNUSED     )
//UNUSED {
//UNUSED     _DebugMsgExVaW(0, NULL, pszMsg, ap);
//UNUSED }

//UNUSED EXTERN_C void _DebugMsgExW(
//UNUSED     DWORD dwFlags,
//UNUSED     LPCWSTR pszComponent,
//UNUSED     LPCWSTR pszMsg,
//UNUSED     ...
//UNUSED     )
//UNUSED {
//UNUSED     va_list ap;
//UNUSED     va_start(ap, pszMsg);
//UNUSED     _DebugMsgExVaW(dwFlags, pszComponent, pszMsg, ap);
//UNUSED     va_end(ap);
//UNUSED }

//UNUSED EXTERN_C void _DebugMsgExVaW(
//UNUSED     DWORD dwFlags,
//UNUSED     LPCWSTR pszComponent,
//UNUSED     LPCWSTR pszMsg,
//UNUSED     va_list ap
//UNUSED     )
//UNUSED {
//UNUSED     WCHAR wch[2*MAX_PATH+40];  
//UNUSED 
//UNUSED     UNUSED(dwFlags);
//UNUSED 
//UNUSED #if FUSION_WIN
//UNUSED     _vsnwprintf(wch, sizeof(wch) / sizeof(wch[0]), pszMsg, ap);
//UNUSED #elif FUSION_URT
//UNUSED     wvsprintfW(wch, pszMsg, ap);
//UNUSED #else
//UNUSED #error "Neither FUSION_WIN nor FUSION_URT are defined; figure out which _vsnwprintf() wrapper to use..."
//UNUSED #endif

//UNUSED     if (pszComponent != NULL)
//UNUSED         OutputDebugStringW(pszComponent);

//UNUSED     OutputDebugStringW(wch);
//UNUSED     OutputDebugStringW(L"\r\n");
//UNUSED }

//UNUSED EXTERN_C void _DebugTrapA(
//UNUSED     DWORD dwFlags,
//UNUSED     LPCSTR pszComponent,
//UNUSED     LPCSTR pszMsg,
//UNUSED     ...
//UNUSED     )
//UNUSED {
//UNUSED     va_list ap;
//UNUSED     va_start(ap, pszMsg);
//UNUSED     _DebugTrapVaA(dwFlags, pszComponent, pszMsg, ap);
//UNUSED     va_end(ap);
//UNUSED }

//UNUSED EXTERN_C void _DebugTrapVaA(
//UNUSED     DWORD dwFlags,
//UNUSED     LPCSTR pszComponent,
//UNUSED     LPCSTR pszMsg,
//UNUSED     va_list ap
//UNUSED     )
//UNUSED {
//UNUSED     _DebugMsgExVaA(dwFlags, pszComponent, pszMsg, ap);
//UNUSED #if defined(_M_IX86)  
//UNUSED     _asm {int 3};
//UNUSED #else
//UNUSED     DebugBreak();
//UNUSED #endif
//UNUSED }

//UNUSED EXTERN_C VOID STDAPIVCALLTYPE
//UNUSED _DebugTrapW(
//UNUSED     DWORD dwFlags,
//UNUSED     LPCWSTR pszComponent,
//UNUSED     LPCWSTR pszMsg,
//UNUSED     ...
//UNUSED     )
//UNUSED {
//UNUSED     _DebugMsgExW(dwFlags, pszComponent, pszMsg);
//UNUSED #if defined(_M_IX86)  
//UNUSED     _asm {int 3};
//UNUSED #else
//UNUSED     DebugBreak();
//UNUSED #endif
//UNUSED }

BOOL
FusionpAssertFailedSz(
    DWORD dwFlags,
    PCSTR pszComponentName,
    PCSTR pszText,
    PCSTR pszFile,
    INT line,
    PCSTR pszFunctionName,
    PCSTR pszExpression
    )
{
#if FUSION_URT
    char ach[4096];
    // c:\foo.cpp(35): [Fusion] Assertion Failure.  Expression: "m_cch != 0".  Text: "Must have nonzero length"
    static const char szFormatWithText[] = "%s(%d): [%s] Assertion failure in %s. Expression: \"%s\". Text: \"%s\"\n";
    static const char szFormatNoText[] = "%s(%d): [%s] Assertion failure in %s. Expression: \"%s\".\n";
    PCSTR pszFormat = ((pszText == NULL) || (pszText == pszExpression)) ? szFormatNoText : szFormatWithText;

    wnsprintfA(ach, NUMBER_OF(ach), pszFormat, pszFile, line, pszComponentName, pszFunctionName, pszExpression, pszText);
    ::OutputDebugStringA(ach);

    return TRUE;
#elif FUSION_WIN
    if (::IsDebuggerPresent())
    {
        char ach[4096];
        // c:\foo.cpp(35): Assertion Failure.  Expression: "m_cch != 0".  Text: "Must have nonzero length"
        static const char szFormatWithText[] = "%s(%d): Assertion failure in %s. Expression: \"%s\". Text: \"%s\"\n";
        static const char szFormatNoText[] = "%s(%d): Assertion failure in %s. Expression: \"%s\".\n";
        PCSTR pszFormat = ((pszText == NULL) || (pszText == pszExpression)) ? szFormatNoText : szFormatWithText;

        _snprintf(ach, NUMBER_OF(ach), pszFormat, pszFile, line, pszFunctionName, pszExpression, pszText);
        ::OutputDebugStringA(ach);

        return TRUE;
    }

    RtlAssert((PVOID) pszExpression, (PVOID) pszFile, line, (PSTR) pszText);
    return FALSE;
#else
#error "Neither FUSION_URT nor FUSION_WIN are set; someone needs to define an assertion failure mechanism."
#endif
}

BOOL
FusionpAssertFailed(
    DWORD dwFlags,
    LPCSTR pszComponentName,
    LPCSTR pszFile,
    int line,
    PCSTR pszFunctionName,
    LPCSTR pszExpression
    )
{
#if FUSION_URT
    FusionpAssertFailedSz(0, pszComponentName, NULL, pszFile, line, pszFunctionName, pszExpression);
    return TRUE;
#elif FUSION_WIN
    if (::IsDebuggerPresent())
    {
        // If we're running under a user-mode debugger, break via that puppy instead of
        // through to the kernel mode debugger that you get when you call RtlAssert().
        FusionpAssertFailedSz(0, pszComponentName, NULL, pszFile, line, pszFunctionName, pszExpression);
        return TRUE; // we need our caller to execute a breakpoint...
    }

    RtlAssert((PVOID) pszExpression, (PVOID) pszFile, line, NULL);
    return FALSE;
#else
#error "Neither FUSION_URT nor FUSION_WIN are set; someone needs to define an assertion failure mechanism."
#endif
}

#endif // DBG

VOID
FusionpSoftAssertFailedSz(
    DWORD dwFlags,
    PCSTR pszComponentName,
    PCSTR pszText,
    PCSTR pszFile,
    INT line,
    PCSTR pszFunctionName,
    PCSTR pszExpression
    )
{
    char ach[4096];
    // c:\foo.cpp(35): [Fusion] Soft Assertion Failure.  Expression: "m_cch != 0".  Text: "Must have nonzero length"
    static const char szFormatWithText[] = "%s(%d): [%s] Soft Assertion Failure in %s! Log a bug!\n   Expression: %s\n   Message: %s\n";
    static const char szFormatNoText[] = "%s(%d): [%s] Soft Assertion Failure in %s! Log a bug!\n   Expression: %s\n";
    PCSTR pszFormat = ((pszText == NULL) || (pszText == pszExpression)) ? szFormatNoText : szFormatWithText;

    _snprintf(ach, NUMBER_OF(ach), pszFormat, pszFile, line, pszComponentName, pszFunctionName, pszExpression, pszText);
    ::OutputDebugStringA(ach);
}

VOID
FusionpSoftAssertFailed(
    DWORD dwFlags,
    PCSTR pszComponentName,
    PCSTR pszFile,
    int line,
    PCSTR pszFunctionName,
    PCSTR pszExpression
    )
{
    ::FusionpSoftAssertFailedSz(dwFlags, pszComponentName, NULL, pszFile, line, pszFunctionName, pszExpression);
}

ULONG
FusionpvDbgPrintExNoNTDLL(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR rgchBuffer[8192];
    ULONG n = ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer), Format, arglist);
    ::OutputDebugStringA(rgchBuffer);
    ::SetLastError(dwLastError);
    return n;
}

ULONG
FusionpvDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    va_list ap
    )
{
    if (g_pfnvDbgPrintEx == NULL)
    {
#if FUSION_WIN

        const DWORD dwLastError = ::GetLastError();

        HINSTANCE hInstNTDLL = ::GetModuleHandleW(L"NTDLL.DLL");
        if (hInstNTDLL != NULL)
            g_pfnvDbgPrintEx = (RTL_V_DBG_PRINT_EX_FUNCTION)(::GetProcAddress(hInstNTDLL, "vDbgPrintEx"));

        if (g_pfnvDbgPrintEx == NULL)
            g_pfnvDbgPrintEx = &FusionpvDbgPrintExNoNTDLL;

        ::SetLastError(dwLastError);
#elif FUSION_URT
        g_pfnvDbgPrintEx = &FusionpvDbgPrintExNoNTDLL;
#else
#error "Either FUSION_WIN or FUSION_URT needs to be defined"
#endif
    }

    return (*g_pfnvDbgPrintEx)(
        54, // DPFLTR_FUSION_ID
        Level,
        const_cast<PSTR>(Format),
        ap);
}

ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    )
{
    ULONG rv;
    va_list ap;
    va_start(ap, Format);
    rv = FusionpvDbgPrintEx(Level, Format, ap);
    va_end(ap);
    return rv;
}

VOID
FusionpDbgPrintBlob(
    ULONG Level,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    )
{
    ULONG Offset = 0;

    if (PerLinePrefix == NULL)
        PerLinePrefix = L"";

    // we'll output in 8-byte chunks as shown:
    //
    //  [prefix]Binary section %p (%d bytes)
    //  [prefix]   00000000: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000008: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000010: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //

    while (Length >= 8)
    {
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        FusionpDbgPrintEx(
            Level,
            "%S   %08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x (%c%c%c%c%c%c%c%c)\n",
            PerLinePrefix,
            Offset,
            pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7],
            PRINTABLE(pb[0]),
            PRINTABLE(pb[1]),
            PRINTABLE(pb[2]),
            PRINTABLE(pb[3]),
            PRINTABLE(pb[4]),
            PRINTABLE(pb[5]),
            PRINTABLE(pb[6]),
            PRINTABLE(pb[7]));

        Offset += 8;
        Length -= 8;
    }

    if (Length != 0)
    {
        CStringBuffer buffTemp;
        WCHAR rgTemp2[32]; // arbitrary big enough size
        bool First = true;
        ULONG i;
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        buffTemp.Win32Format(L"   %08lx: ", Offset);

        for (i=0; i<8; i++)
        {
            if (Length > 0)
            {
                if (!First)
                    buffTemp.Win32Append(L"-");
                else
                    First = false;

                swprintf(rgTemp2, L"%02x", pb[i]);
                buffTemp.Win32Append(rgTemp2);

                Length--;
            }
            else
            {
                buffTemp.Win32Append(L"   ");
            }
        }

        buffTemp.Win32Append(L" (");

        i = 0;

        while (Length != 0)
        {
            rgTemp2[0] = PRINTABLE(pb[i]);
            i++;
            buffTemp.Win32Append(rgTemp2, 1);
            Length--;
        }

        buffTemp.Win32Append(L")");

        FusionpDbgPrintEx(
            Level,
            "%S%S\n",
            PerLinePrefix,
            static_cast<PCWSTR>(buffTemp));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\disk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifdef UNICODE
#undef UNICODE
#endif

#include <windows.h>
#include <winerror.h>
#include "fusionp.h"
#include "disk.h"
#include "helpers.h"

#ifndef UNICODE
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExA"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionA"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionA"
#else
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExW"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionW"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionW"
#endif

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef BOOL (WINAPI *PFNWNETUSECONNECTION)(HWND, LPNETRESOURCE, PSTR, PSTR, DWORD, PSTR, PDWORD, PDWORD);
typedef BOOL (WINAPI *PFNWNETCANCELCONNECTION)(LPCTSTR, BOOL);

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn)
{
    if (*pfn==(PFN)-1)
    {
        *pfn = NULL;
        HMODULE ModuleHandle = GetModuleHandleA(pszModule);
        if (ModuleHandle)
        {
            *pfn = (PFN)GetProcAddress(ModuleHandle, pszFunction);
        }
    }        

    return (*pfn!=NULL);
}


// GetPartitionClusterSize

// GetDiskFreeSpace has the annoying habit of lying about the layout
// of the drive; thus we've been ending up with bogus sizes for the cluster size.
// You can't imagine how annoying it is to think you've a 200 MB cache, but it
// starts scavenging at 20MB.

// This function will, if given reason to doubt the veracity of GDFS, go straight 
// to the hardware and get the information for itself, otherwise return the passed-in
// value.

// The code that follows is heavily doctored from msdn sample code. Copyright violation? I think not.

static PFNGETDISKFREESPACEEX pfnGetDiskFreeSpaceEx = (PFNGETDISKFREESPACEEX)-1;
#define VWIN32_DIOC_DOS_DRIVEINFO   6

typedef struct _DIOC_REGISTERS 
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} 
DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 

typedef struct 
_DPB {
    BYTE    dpb_drive;          // Drive number (1-indexed)
    BYTE    dpb_unit;           // Unit number
    WORD    dpb_sector_size;    // Size of sector in bytes
    BYTE    dpb_cluster_mask;   // Number of sectors per cluster, minus 1
    BYTE    dpb_cluster_shift;  // The stuff after this, we don't really care about. 
    WORD    dpb_first_fat;
    BYTE    dpb_fat_count;
    WORD    dpb_root_entries;
    WORD    dpb_first_sector;
    WORD    dpb_max_cluster;
    WORD    dpb_fat_size;
    WORD    dpb_dir_sector;
    DWORD   dpb_reserved2;
    BYTE    dpb_media;
    BYTE    dpb_first_access;
    DWORD   dpb_reserved3;
    WORD    dpb_next_free;
    WORD    dpb_free_cnt;
    WORD    extdpb_free_cnt_hi;
    WORD    extdpb_flags;
    WORD    extdpb_FSInfoSec;
    WORD    extdpb_BkUpBootSec;
    DWORD   extdpb_first_sector;
    DWORD   extdpb_max_cluster;
    DWORD   extdpb_fat_size;
    DWORD   extdpb_root_clus;
    DWORD   extdpb_next_free;
} 
DPB, *PDPB;

#pragma pack()

DWORD GetPartitionClusterSize(PTSTR szDevice, DWORD dwClusterSize)
{
    switch (GlobalPlatformType)
    {
    case PLATFORM_TYPE_WIN95:
        // If GetDiskFreeSpaceEx is present _and_ we're running Win9x, this implies
        // that we must be doing OSR2 or later. We can trust earlier versions 
        // of the GDFS (we think; this assumption may be invalid.)

        // Since Win95 can't read NTFS drives, we'll freely assume we're reading a FAT drive.
        // Basically, we're performing an MSDOS INT21 call to get the drive partition record. Joy.
        
        if (pfnGetDiskFreeSpaceEx)
        {
            HANDLE hDevice;
            DIOC_REGISTERS reg;
            BYTE buffer[sizeof(WORD)+sizeof(DPB)];
            PDPB pdpb = (PDPB)(buffer + sizeof(WORD));
    
            BOOL fResult;
            DWORD cb;

            // We must always have a drive letter in this case
            int nDrive = *szDevice - TEXT('A') + 1;  // Drive number, 1-indexed

            hDevice = CreateFileA(TEXT("\\\\.\\vwin32"), 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if (hDevice!=INVALID_HANDLE_VALUE)
            {
                reg.reg_EDI = PtrToUlong(buffer);
                reg.reg_EAX = 0x7302;        
                reg.reg_ECX = sizeof(buffer);
                reg.reg_EDX = (DWORD) nDrive; // drive number (1-based) 
                reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

                fResult = DeviceIoControl(hDevice, 
                                          VWIN32_DIOC_DOS_DRIVEINFO,
                                          &reg, sizeof(reg), 
                                          &reg, sizeof(reg), 
                                          &cb, 0);

                if (fResult && !(reg.reg_Flags & 0x0001))
                {
                    // no error if carry flag is clear
                    dwClusterSize = DWORD((pdpb->dpb_cluster_mask+1)*pdpb->dpb_sector_size);
                }
                CloseHandle(hDevice);
            }
        }
        break;

    default:
        // Do nothing. Trust the value we've been passed.
        // UNIX guys will have to treat this separately.

        // For NT, however, this might be another issue. We can't use the DOS INT21.
        // Questions:
        // NT5 (but not NT4) supports FAT32; will we get honest answers? Apparently, yes.
        // NT4/5: NTFS drives and other FAT drives -- do we still get honest answers? Investigation
        // so far says, Yes. 
        break;
    }
    
    return dwClusterSize;
}


/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfoA(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal)
{
    static PFNWNETUSECONNECTION pfnWNetUseConnection = (PFNWNETUSECONNECTION)-1;
    static PFNWNETCANCELCONNECTION pfnWNetCancelConnection = (PFNWNETCANCELCONNECTION)-1;

    if (!pszPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // INET_ASSERT(pdwClusterSize || pdlAvail || pdlTotal);

    // If GetDiskFreeSpaceExA is available, we can be confident we're running W95OSR2+ || NT4
    EstablishFunction(TEXT("KERNEL32"), TEXT(SZ_GETDISKFREESPACEEX), (PFN*)&pfnGetDiskFreeSpaceEx);
  
    BOOL fRet = FALSE;
    TCHAR szDevice[MAX_PATH];
    PTSTR pszGDFSEX = NULL;
   
    if (*pszPath==DIR_SEPARATOR_CHAR)
    {
        // If we're dealing with a cache that's actually located on a network share, 
        // that's fine so long as we have GetDiskFreeSpaceEx at our disposal.
        // _However_, if we need the cluster size on Win9x, we'll need to use
        // INT21 stuff (see above), even if we have GDFSEX available, so we need to map
        // the share to a local drive.
        
        if (pfnGetDiskFreeSpaceEx 
            && !((GlobalPlatformType==PLATFORM_TYPE_WIN95) && pdwClusterSize))
        {
            DWORD cbPath = lstrlenA(pszPath);
            cbPath -= ((pszPath[cbPath-1]==DIR_SEPARATOR_CHAR) ? 1 : 0);
            if (cbPath>MAX_PATH-2)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            memcpy(szDevice, pszPath, cbPath);
            szDevice[cbPath] = DIR_SEPARATOR_CHAR;
            cbPath++;
            szDevice[cbPath] = '\0';
            pszGDFSEX = szDevice;
        }
        else
        {
            if (!(EstablishFunction(TEXT("MPR"), TEXT(SZ_WNETUSECONNECTION), (PFN*)&pfnWNetUseConnection)
                &&
               EstablishFunction(TEXT("MPR"), TEXT(SZ_WNETCANCELCONNECTION), (PFN*)&pfnWNetCancelConnection)))
            {
                return FALSE;
            }

           // If it's a UNC, map it to a local drive for backwards compatibility
            NETRESOURCE nr = { 0, RESOURCETYPE_DISK, 0, 0, szDevice, pszPath, NULL, NULL };
            DWORD cbLD = sizeof(szDevice);
            DWORD dwNull;
            if (pfnWNetUseConnection(NULL, 
                          &nr, 
                          NULL, 
                          NULL, 
                          CONNECT_INTERACTIVE | CONNECT_REDIRECT, 
                          szDevice,
                          &cbLD,
                          &dwNull)!=ERROR_SUCCESS)
            {
                SetLastError(ERROR_NO_MORE_DEVICES);        
                return FALSE;
            }
        }
    }
    else
    {
        memcpy(szDevice, pszPath, sizeof(TEXT("?:\\")));
        szDevice[3] = '\0';
        pszGDFSEX = pszPath;
    }
    if (*szDevice!=DIR_SEPARATOR_CHAR)
    {
        // *szDevice = (TCHAR)CharUpper((LPTSTR)*szDevice);
    }

#ifdef UNIX
    /* On Unix, GetDiskFreeSpace and GetDiskFreeSpaceEx will work successfully
     * only if the path exists. So, let us pass a path that exists
     */
    UnixGetValidParentPath(szDevice);
#endif /* UNIX */

    // I hate goto's, and this is a way to avoid them...
    for (;;)
    {
        DWORDLONG cbFree = 0, cbTotal = 0;
    
        if (pfnGetDiskFreeSpaceEx && (pdlTotal || pdlAvail))
        {
            ULARGE_INTEGER ulFree, ulTotal;

            // BUG BUG BUG Is the following problematic? Also, we'll need to add checks to make sure that 
            // the  cKBlimit fits a DWORD (in the obscene if unlikely case drive spaces grow that large)
            // For instance, if this is a per user system with a non-shared cache, we might want to change
            // the ratios.
            // INET_ASSERT(pszGDFSEX);
            fRet = pfnGetDiskFreeSpaceEx(pszGDFSEX, &ulFree, &ulTotal, NULL);

            // HACK Some versions of GetDiskFreeSpaceEx don't accept the whole directory; they
            // take only the drive letter. Pfft.
            if (!fRet)
            {
                fRet = pfnGetDiskFreeSpaceEx(szDevice, &ulFree, &ulTotal, NULL);
            }

            if (fRet)
            {
                cbFree = ulFree.QuadPart;
                cbTotal = ulTotal.QuadPart;
            }
        }

        if ((!fRet) || pdwClusterSize)
        {
            DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwClusters, dwClusterSize;
            if (!GetDiskFreeSpace(szDevice, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
            {
                fRet = FALSE;
                break;
            }
            
            dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;

            if (!fRet)
            {
                cbFree = (DWORDLONG)dwClusterSize * (DWORDLONG)dwFreeClusters;
                cbTotal = (DWORDLONG)dwClusterSize * (DWORDLONG)dwClusters;
            }
            
            if (pdwClusterSize)
            {
                *pdwClusterSize = GetPartitionClusterSize(szDevice, dwClusterSize);
            }
        }

        if (pdlTotal)
        {
             *pdlTotal = cbTotal;
        }
        if (pdlAvail)
        {
             *pdlAvail = cbFree;
        }
        fRet = TRUE;
        break;
    };
    
    // We've got the characteristics. Now delete local device connection, if any.
    if (*pszPath==DIR_SEPARATOR_CHAR && !pfnGetDiskFreeSpaceEx)
    {
        pfnWNetCancelConnection(szDevice, FALSE);
    }

    return fRet;
}

HRESULT GetFileSizeRoundedToCluster(HANDLE hFile, PDWORD pdwSizeLow, PDWORD pdwSizeHigh)
{
    static BOOL bFirstTime=TRUE;
    static DWORD    dwClusterSizeMinusOne, dwClusterSizeMask;

    HRESULT hr=S_OK;
    DWORD dwFileSizeLow, dwFileSizeHigh, dwError;

    // ASSERT(pdwSizeLow);
    // ASSERT(pdwSizeHigh);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        dwFileSizeLow  = *pdwSizeLow;
        dwFileSizeHigh = *pdwSizeHigh;

    }
    else
    {
        dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);

        if ( (dwFileSizeLow == 0xFFFFFFFF)     && 
                ((dwError = GetLastError()) != NO_ERROR) )
        { 
            hr = HRESULT_FROM_WIN32(dwError);
            return hr;
        }
    }

    if(bFirstTime)
    {
        TCHAR szPath[MAX_PATH+1];

        if(!GetWindowsDirectoryA(szPath, MAX_PATH) )
        {
            hr = FusionpHresultFromLastError();
            return hr;
        }

        GetDiskInfo( szPath, &dwClusterSizeMinusOne, NULL, NULL);
        dwClusterSizeMinusOne--;
        dwClusterSizeMask = ~dwClusterSizeMinusOne;
        bFirstTime = FALSE;
    }

    *pdwSizeLow = (dwFileSizeLow + dwClusterSizeMinusOne) & dwClusterSizeMask;

    if(*pdwSizeLow < dwFileSizeLow)
        dwFileSizeHigh++; // Add overflow from low.

    *pdwSizeHigh = dwFileSizeHigh;

    return S_OK;
}



HRESULT GetAvailableSpaceOnDisk(PDWORD pdwFree, PDWORD pdwTotal)
{

    TCHAR szPath[MAX_PATH+1];
    HRESULT hr=S_OK;
    DWORD    dwClusterSizeMinusOne;
    DWORDLONG   dlFree=0, dlTotal=0;

    if(!GetWindowsDirectoryA(szPath, MAX_PATH) )
    {
        hr = FusionpHresultFromLastError();
        return hr;
    }

    GetDiskInfo( szPath, &dwClusterSizeMinusOne, &dlFree, &dlTotal);


    PDWORD pdwTemp;
    if(pdwFree)
    {
        pdwTemp = (PDWORD) &dlFree;
        *pdwFree = (*pdwTemp) << 12;
        pdwTemp++;
        *pdwTemp = (*pdwTemp) >> 20 ;
        *pdwFree |= (*pdwTemp);
    }

    if(pdwTotal)
    {
         pdwTemp = (PDWORD) &dlTotal;
         *pdwTotal = (*pdwTemp) <<12;
         pdwTemp++;
         *pdwTemp = (*pdwTemp) >> 20;
         *pdwTotal |= *pdwTemp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\fusionmodule.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionmodule.h"
#include "FusionHandle.h"
#define UNUSED(x) (x)

extern CFusionModule _Module;

BOOL CFusionModule::ModuleDllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID pvReserved)
{
    UNUSED(pvReserved);

    BOOL fResult = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        if ((m_dwEnumLocaleTLS = ::TlsAlloc()) == -1)
        {
            fResult = FALSE;
            goto Exit;
        }

#if DBG
        if ((m_dwTraceContextTLS = ::TlsAlloc()) == -1)
        {
            const DWORD dwLastError = ::GetLastError();
            ::TlsFree(m_dwEnumLocaleTLS);
            m_dwEnumLocaleTLS = 0;
            ::SetLastError(dwLastError);
            fResult = FALSE;
            goto Exit;
        }
#endif

        m_hInstDLL = hInstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (m_dwEnumLocaleTLS != 0)
        {
            ::TlsFree(m_dwEnumLocaleTLS);
            m_dwEnumLocaleTLS = 0;
        }

#if DBG
        if (m_dwTraceContextTLS != 0)
        {
            ::TlsFree(m_dwTraceContextTLS);
            m_dwTraceContextTLS = 0;
        }
#endif
    }

    fResult = TRUE;
Exit:
    return fResult;
}

HRESULT CFusionModule::Initialize()
{
    HRESULT hr = NOERROR;
    ASSERT(!m_fFusionModuleInitialized);
    if (m_fFusionModuleInitialized)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    hr = m_OleAut.Init();
    if (FAILED(hr))
        goto Exit;
    m_fFusionModuleInitialized = true;
    hr = NOERROR;
Exit:
    return hr;
}

BOOL CFusionModule::EnumSystemLocalesExA(LOCALE_ENUMPROCEXA lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext)
{
    ENUMSYSTEMLOCALESEXCONTEXTA ctx;
    ASSERT(m_dwEnumLocaleTLS != 0);
    ctx.pvContext = pvContext;
    ctx.lpLocaleEnumProc = lpLocaleEnumProc;
    BOOL fSucceeded = ::TlsSetValue(m_dwEnumLocaleTLS, &ctx);
    if (fSucceeded)
        fSucceeded = ::EnumSystemLocalesA(&CFusionModule::EnumLocalesProcA, dwFlags);
    return fSucceeded;
}

BOOL CFusionModule::EnumSystemLocalesExW(LOCALE_ENUMPROCEXW lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext)
{
    ENUMSYSTEMLOCALESEXCONTEXTW ctx;
    ASSERT(m_dwEnumLocaleTLS != 0);
    ctx.pvContext = pvContext;
    ctx.lpLocaleEnumProc = lpLocaleEnumProc;
    BOOL fSucceeded = ::TlsSetValue(m_dwEnumLocaleTLS, &ctx);
    if (fSucceeded)
        fSucceeded = ::EnumSystemLocalesW(&CFusionModule::EnumLocalesProcW, dwFlags);
    return fSucceeded;
}

BOOL CFusionModule::EnumLocalesProcA(LPSTR pszLCID)
{
    ASSERT(_Module.m_dwEnumLocaleTLS != 0);
    LPENUMSYSTEMLOCALESEXCONTEXTA pCtx = reinterpret_cast<LPENUMSYSTEMLOCALESEXCONTEXTA>(::TlsGetValue(_Module.m_dwEnumLocaleTLS));
    ASSERT(pCtx != NULL);
    if (pCtx == NULL)
        return FALSE;
    return (*(pCtx->lpLocaleEnumProc))(pszLCID, pCtx->pvContext);
}

BOOL CFusionModule::EnumLocalesProcW(LPWSTR pszLCID)
{
    ASSERT(_Module.m_dwEnumLocaleTLS != 0);
    LPENUMSYSTEMLOCALESEXCONTEXTW pCtx = reinterpret_cast<LPENUMSYSTEMLOCALESEXCONTEXTW>(::TlsGetValue(_Module.m_dwEnumLocaleTLS));
    ASSERT(pCtx != NULL);
    if (pCtx == NULL)
        return FALSE;
    return (*(pCtx->lpLocaleEnumProc))(pszLCID, pCtx->pvContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\fstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "fstream.h"

CFileStream::CFileStream()
: _cRef(1)
, _hFile(INVALID_HANDLE_VALUE)
{
}

CFileStream::~CFileStream()
{
    Close();
}

HRESULT CFileStream::OpenForRead(LPCWSTR wzFilePath)
{
    HRESULT                                    hr = S_OK;

    ASSERT(_hFile == INVALID_HANDLE_VALUE && wzFilePath);
    if (_hFile != INVALID_HANDLE_VALUE || !wzFilePath) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    _hFile = ::CreateFileW(wzFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CFileStream::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream)) {
        *ppv = static_cast<IStream *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CFileStream::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CFileStream::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT CFileStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT                                   hr = S_OK;
    ULONG                                     cbRead = 0;

    if (pcbRead != NULL) {
        *pcbRead = 0;
    }

    ASSERT(_hFile != INVALID_HANDLE_VALUE);
    if (_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!::ReadFile(_hFile, pv, cb, &cbRead, NULL)) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbRead == 0) {
        hr = S_FALSE;
    }
    else {
        hr = NOERROR;
    }

    if (pcbRead != NULL) {
        *pcbRead = cbRead;
    }

Exit:
    return hr;
}

HRESULT CFileStream::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT                              hr = S_OK;
    ULONG                                cbWritten = 0;

    if (pcbWritten != NULL) {
        *pcbWritten = 0;
    }

    ASSERT(_hFile != INVALID_HANDLE_VALUE);
    if (_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!::WriteFile(_hFile, pv, cb, &cbWritten, NULL)) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbWritten == 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    if (pcbWritten != NULL) {
        *pcbWritten = cbWritten;
    }

Exit:
    return hr;
}

HRESULT CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
#if 1 // SetFilePointerEx not supported on Win9x
    return E_NOTIMPL;
#else    
    HRESULT                                         hr = S_OK;
    DWORD                                           dwFileOrigin;
    BOOL                                            bRet;

    ASSERT(_hFile != INVALID_HANDLE_VALUE);
    if (_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin) {
        case STREAM_SEEK_SET:
            dwFileOrigin = FILE_BEGIN;
            break;
            
        case STREAM_SEEK_CUR:
            dwFileOrigin = FILE_CURRENT;
            break;
            
        case STREAM_SEEK_END:
            dwFileOrigin = FILE_END;
            break;
            
        default:
            hr = E_UNEXPECTED;
            goto Exit;
    }
    
    bRet = SetFilePointerEx(_hFile, dlibMove, (LARGE_INTEGER *)plibNewPosition,
                            dwFileOrigin);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }


Exit:
    return hr;
#endif
}

HRESULT CFileStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

HRESULT CFileStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

HRESULT CFileStream::Commit(DWORD grfCommitFlags)
{
    HRESULT                                 hr = S_OK;

    if (grfCommitFlags != 0)  {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!Close()) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

Exit:
    return hr;
}

HRESULT CFileStream::Revert()
{
    return E_NOTIMPL;
}

HRESULT CFileStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

HRESULT CFileStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

HRESULT CFileStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

HRESULT CFileStream::Clone(IStream **ppIStream)
{
    return E_NOTIMPL;
}


BOOL CFileStream::Close()
{
    BOOL                            fSuccess = FALSE;
    
    if (_hFile != INVALID_HANDLE_VALUE) {
        if (!::CloseHandle(_hFile)) {
            _hFile = INVALID_HANDLE_VALUE;
            goto Exit;
        }

        _hFile = INVALID_HANDLE_VALUE;
    }

    fSuccess = TRUE; 

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\fusionhashstring.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "debmacro.h"
#include "util.h"
#include "fusiontrace.h"

BOOL
FusionpHashUnicodeString(
    PCWSTR String,
    SSIZE_T cch,
    PULONG HashValue,
    DWORD dwCmpFlags
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG TmpHashValue = 0;

    if (HashValue != NULL)
        *HashValue = 0;

    PARAMETER_CHECK_WIN32((dwCmpFlags == 0) || (dwCmpFlags == (NORM_IGNORECASE|SORT_STRINGSORT))); // ?safe
    PARAMETER_CHECK_WIN32(HashValue != NULL);

    if (cch < 0)
        cch = lstrlenW(String);

    //
    //  Note that if you change this implementation, you have to have the implementation inside
    //  ntdll change to match it.  Since that's hard and will affect everyone else in the world,
    //  DON'T CHANGE THIS ALGORITHM NO MATTER HOW GOOD OF AN IDEA IT SEEMS TO BE!  This isn't the
    //  most perfect hashing algorithm, but its stability is critical to being able to match
    //  previously persisted hash values.
    //

    if (dwCmpFlags & NORM_IGNORECASE)
    {
        while (cch-- != 0)
        {
            WCHAR Char = *String++;
            TmpHashValue = (TmpHashValue * 65599) + (WCHAR) ::CharUpperW((PWSTR) Char);
        }
    }
    else
    {
        while (cch-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *String++;
    }

    *HashValue = TmpHashValue;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\fusiontls.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"
/*-----------------------------------------------------------------------------
Fusion Thread Local Storage (aka Per Thread Data)
-----------------------------------------------------------------------------*/
#include "fusiontls.h"
#include "FusionEventLog.h"
#include "FusionHeap.h"

static DWORD s_dwFusionpThreadLocalIndex = TLS_OUT_OF_INDEXES;

BOOL
FusionpPerThreadDataMain(
    HINSTANCE hInst,
    DWORD dwReason
    )
{
    BOOL fResult = FALSE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        s_dwFusionpThreadLocalIndex = TlsAlloc();
        if (s_dwFusionpThreadLocalIndex == TLS_OUT_OF_INDEXES)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): TlsAlloc failed: last error %d\n", __FUNCTION__, GetLastError());
            goto Exit;
        }
        break;
    case DLL_THREAD_ATTACH:
        // the default value is NULL
        // and we don't heap allocate until someone tries to set the value on a thread
        break;
    case DLL_PROCESS_DETACH: // you must delete the thread local on process detach too, else you leak
    case DLL_THREAD_DETACH:
        // failures down here are generally ignorable
        // a) these functions mainly fail due to bugs, using a bad tls index,
        // not any other runtime situation, I think
        // b) if TlsGetValue fails, it returns NULL, delete does nothing,
        // and we might have leaked, can't do any better
        // c) TlsSetValue shouldn't even be necessary, assuming zero other
        // code of ours runs on this thread
        // d) what does failure from thread detach do anyway?
        if (s_dwFusionpThreadLocalIndex != TLS_OUT_OF_INDEXES)
        {
            delete reinterpret_cast<CFusionPerThreadData*>(TlsGetValue(s_dwFusionpThreadLocalIndex));
            TlsSetValue(s_dwFusionpThreadLocalIndex, NULL);
            if (dwReason == DLL_PROCESS_DETACH)
            {
                TlsFree(s_dwFusionpThreadLocalIndex);
                s_dwFusionpThreadLocalIndex = TLS_OUT_OF_INDEXES;
            }
        }
        break;
    }
    fResult = TRUE;

Exit:
    return fResult;
}

CFusionPerThreadData*
FusionpGetPerThreadData(
    EFusionpTls e
    )
{
    ::FusionpDbgPrintEx(
        DPFLTR_TRACE_LEVEL,
        "SXS.DLL: %s() entered\n", __FUNCTION__);
    
    DWORD dwLastError = ((e & eFusionpTlsCanScrambleLastError) == 0) ? GetLastError() : 0;

    // the use of "temp" here mimics what you would do with a destructor;
    // have a temp that is unconditionally freed, unless it is nulled by commiting it
    // into the return value "return pt.Detach();"
    CFusionPerThreadData* pTls = NULL;
    CFusionPerThreadData* pTlsTemp = reinterpret_cast<CFusionPerThreadData*>(::TlsGetValue(s_dwFusionpThreadLocalIndex));
    if (pTlsTemp == NULL && (e & eFusionpTlsCreate) != 0)
    {
        if (::GetLastError() != NO_ERROR)
        {
            goto Exit;
        }
#if FUSION_DEBUG_HEAP
        //
        // for beta1 just turn off leak tracking for this allocation
        // it only leaks in checked builds anyway
        //
        BOOL PreviousLeakTrackingState = FusionpEnableLeakTracking(FALSE);
        __try
        {
#endif // FUSION_DEBUG_HEAP
            pTlsTemp = NEW(CFusionPerThreadData);
#if FUSION_DEBUG_HEAP
        }
        __finally
        {
            FusionpEnableLeakTracking(PreviousLeakTrackingState);
        }
#endif // FUSION_DEBUG_HEAP
        if (pTlsTemp == NULL)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: new failed in %s()\n", __FUNCTION__);
            goto Exit;
        }
        if (!TlsSetValue(s_dwFusionpThreadLocalIndex, pTlsTemp))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: TlsSetValue failed in %s(), lastError:%d\n", __FUNCTION__, GetLastError());
            goto Exit;
        }
    }
    pTls = pTlsTemp;
    pTlsTemp = NULL;
Exit:
    delete pTlsTemp;
    if ((e & eFusionpTlsCanScrambleLastError) == 0)
    {
        SetLastError(dwLastError);
    }
    ::FusionpDbgPrintEx(
        DPFLTR_TRACE_LEVEL,
        "SXS.DLL: %s():%p exited\n", __FUNCTION__, pTls);
    return pTls;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\fusionreg.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "util.h"

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer *Buffer,
    SIZE_T *Cch
    )
{
    BOOL fSuccess = FALSE;
    LONG lResult;
    CStringBufferAccessor acc;
    DWORD cbBuffer;
    DWORD dwType = 0;

    FN_TRACE_WIN32(fSuccess);

    if (Cch != NULL)
        *Cch = 0;

    PARAMETER_CHECK_WIN32((dwFlags & ~(FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING)) == 0);

    acc.Attach(Buffer);

    if (acc.GetBufferCb() > MAXDWORD)
    {
        cbBuffer = MAXDWORD;
    }
    else
    {
        cbBuffer = static_cast<DWORD>(acc.GetBufferCb());
    }

    lResult = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (LPBYTE) acc.GetBufferPtr(), &cbBuffer);
    if ((lResult == ERROR_FILE_NOT_FOUND) && (dwFlags & FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING))
    {
        acc[0] = acc.NullCharacter();
    }
    else
    {
        if (lResult == ERROR_MORE_DATA)
        {
            acc.Detach();
            IFFALSE_EXIT(Buffer->ResizeBuffer((cbBuffer + 1) / sizeof(CStringBufferAccessor::TChar)));
            acc.Attach(Buffer);

            if (acc.GetBufferCb() > MAXDWORD)
            {
                cbBuffer = MAXDWORD;
            }
            else
            {
                cbBuffer = static_cast<DWORD>(acc.GetBufferCb());
            }

            lResult = ::RegQueryValueEx(hKey, lpValueName, NULL, &dwType, (LPBYTE) acc.GetBufferPtr(), &cbBuffer);
        }
        if (lResult != ERROR_SUCCESS)
        {
            ::SetLastError(lResult);
            TRACE_WIN32_FAILURE(RegQueryValueExW);
            goto Exit;
        }
        if (dwType != REG_SZ)
        {
            ::SetLastError(ERROR_INVALID_DATA);
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "Fusion: Registry value \"%ls\" has type other than REG_SZ\n", lpValueName);
            goto Exit;
        }
    }

    if (Cch != NULL)
        *Cch = Buffer->Cch();

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\helpers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "fusionp.h"
#include "helpers.h"
#include "list.h"
#include "policy.h"
#include "naming.h"
#include "appctx.h"
#include "cfgdl.h"
#include "actasm.h"
#include "util.h"
#include "shfolder.h"
#include "cacheUtils.h"
#include "util.h"
#include "clbutils.h"
#include "lock.h"
#include "history.h"
#include "parse.h"

#define MAX_DRIVE_ROOT_LEN                     4

extern CRITICAL_SECTION g_mxsFDI;
extern CRITICAL_SECTION g_csDownload;
extern CRITICAL_SECTION g_csInitClb;

extern HMODULE g_hMSCorEE;
extern LCID g_lcid;
extern HINSTANCE    g_hInst;

extern PFNSTRONGNAMETOKENFROMPUBLICKEY      g_pfnStrongNameTokenFromPublicKey;
extern PFNSTRONGNAMEERRORINFO               g_pfnStrongNameErrorInfo;
extern PFNSTRONGNAMEFREEBUFFER              g_pfnStrongNameFreeBuffer;
extern PFNSTRONGNAMESIGNATUREVERIFICATION   g_pfnStrongNameSignatureVerification;
extern pfnGetAssemblyMDImport               g_pfnGetAssemblyMDImport;
extern COINITIALIZECOR                      g_pfnCoInitializeCor;
extern pfnGetXMLObject                      g_pfnGetXMLObject;


typedef DWORD (*pfnGetSystemWindowsDirectoryW)(LPWSTR lpBuffer, UINT uSize);

typedef BOOL (*pfnGetVolumePathNameW)(LPCTSTR lpszFileName, 
                                    LPTSTR lpszVolumePathName, 
                                    DWORD cchBufferLength);

pfnGetCORVersion g_pfnGetCORVersion = NULL;
PFNGETCORSYSTEMDIRECTORY g_pfnGetCorSystemDirectory = NULL;
pfnGetVolumePathNameW  g_pfnGetVolumePathNameW = NULL;

//
// Helper functions borrowed from URLMON code download
//

/*******************************************************************

    NAME:        Unicode2Ansi
        
    SYNOPSIS:    Converts a unicode widechar string to ansi (MBCS)

    NOTES:        Caller must free out parameter using delete
                    
********************************************************************/
HRESULT Unicode2Ansi(const wchar_t *src, char ** dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it.
    int len = WideCharToMultiByte(CP_ACP, 0, src, -1, NULL, 0, NULL, NULL);
    *dest = NEW(char [len*sizeof(char)]);
    if (!*dest)
        return E_OUTOFMEMORY;

    // Now do the actual conversion
    if ((WideCharToMultiByte(CP_ACP, 0, src, -1, *dest, len*sizeof(char), 
                                                            NULL, NULL)) != 0)
        return S_OK; 
    else
        return HRESULT_FROM_WIN32(GetLastError());
}


/*******************************************************************

    NAME:        Ansi2Unicode
        
    SYNOPSIS:    Converts an ansi (MBCS) string to unicode.

    Notes:        Caller must free out parameter using delete
                        
********************************************************************/
HRESULT Ansi2Unicode(const char * src, wchar_t **dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it
    int len = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, NULL, 0);
    *dest = NEW(WCHAR [len*sizeof(WCHAR)]);
    if (!*dest)
        return E_OUTOFMEMORY;

    // Do the actual conversion.
    if ((MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, *dest, 
                                                    len*sizeof(wchar_t))) != 0)
        return S_OK; 
    else
        return HRESULT_FROM_WIN32(GetLastError());
}

// Poor man's check to see if we are a UNC or x:\ "fully qualified" filepath.
BOOL IsFullyQualified(LPCWSTR wzPath)
{
    BOOL                               bRet;

    if (!wzPath) {
        bRet = FALSE;
        goto Exit;
    }

    // If we don't have at least "\\[character]" or "[x]:\", we can't
    // possibly be fully qualified

    if (lstrlenW(wzPath) < 3) {
        bRet = FALSE;
        goto Exit;
    }

    if ((wzPath[0] == L'\\' && wzPath[1] == L'\\') ||
        (wzPath[1] == L':' && wzPath[2] == L'\\')) {
        bRet = TRUE;
    }
    else {
        bRet = FALSE;
    }

Exit:
    return bRet;
}

// The Win32 GetDriveType API is eneficent because you *have* to pass it a path to
// the ROOT of the drive (if you don't it fails). This wrapper allows you
// to pass in a path. Also, GetDriveTypeW will fail under Win95. This always
// calls the ANSI version.
UINT GetDriveTypeWrapper(LPCWSTR wzPath)
{
    HRESULT                    hr = S_OK;
    WCHAR                      wzDriveRoot[MAX_DRIVE_ROOT_LEN];
    UINT                       uiDriveType = DRIVE_UNKNOWN;
    CHAR                      *szDriveRoot = NULL;

    if (!wzPath) {
        goto Exit;
    }

    wnsprintfW(wzDriveRoot, MAX_DRIVE_ROOT_LEN, L"%wc:\\", wzPath[0]);

    hr = ::Unicode2Ansi(wzDriveRoot, &szDriveRoot);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    uiDriveType = GetDriveTypeA(szDriveRoot);

Exit:
    if (szDriveRoot) {
        delete [] szDriveRoot;
    }

    return uiDriveType;
}

HRESULT AppCtxGetWrapper(IApplicationContext *pAppCtx, LPWSTR wzTag,
                         WCHAR **ppwzValue)
{
    HRESULT                               hr = S_OK;
    WCHAR                                *wzBuf = NULL;
    DWORD                                 cbBuf;

    if (!pAppCtx || !wzTag || !ppwzValue) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(wzTag, wzBuf, &cbBuf, 0);

    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        hr = S_FALSE;
        *ppwzValue = NULL;
        goto Exit;
    }

    ASSERT(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    wzBuf = NEW(WCHAR[cbBuf]);
    if (!wzBuf) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pAppCtx->Get(wzTag, wzBuf, &cbBuf, 0);

    if (FAILED(hr)) {
        *ppwzValue = NULL;
        delete [] wzBuf;
    }
    else {
        *ppwzValue = wzBuf;
    }

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// NameObjGetWrapper
// ---------------------------------------------------------------------------
HRESULT NameObjGetWrapper(IAssemblyName *pName, DWORD nIdx, 
    LPBYTE *ppbBuf, LPDWORD pcbBuf)
{
    HRESULT hr = S_OK;
    
    LPBYTE pbAlloc;
    DWORD cbAlloc;

    // Get property size
    hr = pName->GetProperty(nIdx, NULL, &(cbAlloc = 0));
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        // Property is set; alloc buf
        pbAlloc = NEW(BYTE[cbAlloc]);
        if (!pbAlloc)
        {
            hr = E_OUTOFMEMORY;                
            goto exit;
        }

        // Get the property
        if (FAILED(hr = pName->GetProperty(nIdx, pbAlloc, &cbAlloc)))
            goto exit;
            
        *ppbBuf = pbAlloc;
        *pcbBuf = cbAlloc;
    }
    else
    {
        // If property unset, hr should be S_OK
        if (hr != S_OK)
            goto exit;

        // Success, returning 0 bytes, ensure buf is null.    
        *ppbBuf = NULL;
    }

    
exit:
    return hr;
}


HRESULT GetFileLastModified(LPCWSTR pwzFileName, FILETIME *pftLastModified)
{
    HRESULT                                hr = S_OK;
    HANDLE                                 hFile = INVALID_HANDLE_VALUE;

    if (!pwzFileName || !pftLastModified) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hFile = CreateFileW(pwzFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    if (!GetFileTime(hFile, NULL, NULL, pftLastModified)) {
        hr = FusionpHresultFromLastError();
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}

// GetWindowsDirectory has so many crazy gotchas....this really gets
// the windows directory, regardless of if it's NT5 w/ terminal server or
// not.

DWORD GetRealWindowsDirectory(LPWSTR wszRealWindowsDir, UINT uSize)
{
    HINSTANCE                                       hInst;
    DWORD                                           cszDir = 0;
    pfnGetSystemWindowsDirectoryW                   pfnGWSD = NULL;

    wszRealWindowsDir[0] = L'\0';

    hInst = GetModuleHandle(TEXT("KERNEL32.DLL"));
    if (hInst) {
        pfnGWSD = (pfnGetSystemWindowsDirectoryW)GetProcAddress(hInst, "GetSystemWindowsDirectoryW");
        if (pfnGWSD) {
            cszDir = (*pfnGWSD)(wszRealWindowsDir, uSize);
        }
    }

    if (!cszDir) {
        // Still don't know windows dir. Either we are not on NT5
        // or, the NT5 GetSystemWindowsDirectory call failed. Fall
        // back on GetWindowsDirectory

        cszDir = GetWindowsDirectoryW(wszRealWindowsDir, uSize);
    }

    return cszDir;
}

HRESULT FileTimeFromString(LPWSTR pwzFT, FILETIME *pft)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  pwzTmp = NULL;
    WCHAR                                   pwzBuf[512];

    if (!pwzFT || !pft) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    StrCpyW(pwzBuf, pwzFT);

    pwzTmp = pwzBuf;
    while (*pwzTmp) {
        if (*pwzTmp == '.') {
            break;
        }

        pwzTmp++;
    }

    if (!*pwzTmp) {
        // didn't find the "."
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *pwzTmp = L'\0';
    pwzTmp++;

    pft->dwHighDateTime = StrToIntW(pwzBuf);
    pft->dwLowDateTime = StrToIntW(pwzTmp);

Exit:
    return hr;
}

HRESULT SetAppCfgFilePath(IApplicationContext *pAppCtx, LPCWSTR wzFilePath)
{
    HRESULT                              hr = S_OK;
    CApplicationContext                 *pCAppCtx = dynamic_cast<CApplicationContext *>(pAppCtx);

    ASSERT(pCAppCtx);

    hr = pCAppCtx->Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!wzFilePath || !pAppCtx) {
        ASSERT(0);
        pCAppCtx->Unlock();
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = pAppCtx->Set(ACTAG_APP_CFG_LOCAL_FILEPATH, (void *)wzFilePath,
                      (sizeof(WCHAR) * (lstrlenW(wzFilePath) + 1)), 0);
                      
    pCAppCtx->Unlock();

Exit:
    return hr;
}

HRESULT MakeUniqueTempDirectory(LPCWSTR wzTempDir, LPWSTR wzUniqueTempDir,
                                DWORD dwLen)
{
    int                           n = 1;
    HRESULT                       hr = S_OK;
    CCriticalSection              cs(&g_csInitClb);

    ASSERT(wzTempDir && wzUniqueTempDir);

    //execute entire function under critical section
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    do {

        if (n > 100)    // avoid infinite loop!
            break;

        wnsprintfW(wzUniqueTempDir, dwLen, L"%ws%ws%d.tmp", wzTempDir, L"Fusion", n++);


    } while (GetFileAttributesW(wzUniqueTempDir) != -1);

    if (!CreateDirectoryW(wzUniqueTempDir, NULL)) {
        hr = FusionpHresultFromLastError();
        cs.Unlock();
        goto Exit;
    }

    hr = PathAddBackslashWrap(wzUniqueTempDir, dwLen);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    cs.Unlock();

Exit:
    return hr;
}

HRESULT RemoveDirectoryAndChildren(LPWSTR szDir)
{
    HRESULT hr = S_OK;
    HANDLE hf = INVALID_HANDLE_VALUE;
    TCHAR szBuf[MAX_PATH];
    WIN32_FIND_DATA fd;
    LPWSTR wzCanonicalized=NULL;
    WCHAR wzPath[MAX_PATH];
    DWORD dwSize;

    if (!szDir || !lstrlenW(szDir)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzPath[0] = L'\0';

    wzCanonicalized = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzCanonicalized)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_URL_LENGTH;
    hr = UrlCanonicalizeW(szDir, wzCanonicalized, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_PATH;
    hr = PathCreateFromUrlW(wzCanonicalized, wzPath, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Cannot delete root. Path must have greater length than "x:\"
    if (lstrlenW(wzPath) < 4) {
        ASSERT(0);
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    if (RemoveDirectory(wzPath)) {
        goto Exit;
    }

    // ha! we have a case where the directory is probbaly not empty

    StrCpy(szBuf, wzPath);
    StrCat(szBuf, TEXT("\\*"));

    if ((hf = FindFirstFile(szBuf, &fd)) == INVALID_HANDLE_VALUE) {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    do {

        if ( (FusionCompareStringI(fd.cFileName, TEXT(".")) == 0) ||
             (FusionCompareStringI(fd.cFileName, TEXT("..")) == 0))
            continue;

        wnsprintf(szBuf, MAX_PATH-1, TEXT("%s\\%s"), wzPath, fd.cFileName);
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            SetFileAttributes(szBuf, 
                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL);

            if (FAILED((hr=RemoveDirectoryAndChildren(szBuf)))) {
                goto Exit;
            }

        } else {

            SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFile(szBuf)) {
                hr = FusionpHresultFromLastError();
                goto Exit;
            }
        }


    } while (FindNextFile(hf, &fd));


    if (GetLastError() != ERROR_NO_MORE_FILES) {

        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    if (hf != INVALID_HANDLE_VALUE) {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    // here if all subdirs/children removed
    /// re-attempt to remove the main dir
    if (!RemoveDirectory(wzPath)) {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

Exit:
    if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);

    if (hf != INVALID_HANDLE_VALUE)
        FindClose(hf);

    SAFEDELETEARRAY(wzCanonicalized);
    return hr;
}

HRESULT GetPDBName(LPWSTR wzFileName, LPWSTR wzPDBName, DWORD *pdwSize)
{
    LPWSTR                           wzExt = NULL;
    
    ASSERT(wzFileName && wzPDBName && pdwSize);

    // BUGBUG: don't bother checking size, since this is a temp function

    lstrcpyW(wzPDBName, wzFileName);
    wzExt = PathFindExtension(wzPDBName);

    lstrcpyW(wzExt, L".PDB");

    return S_OK;
}

STDAPI CopyPDBs(IAssembly *pAsm)
{
    HRESULT                                       hr = S_OK;
    IAssemblyName                                *pName = NULL;
    IAssemblyModuleImport                        *pModImport = NULL;
    DWORD                                         dwSize;
    WCHAR                                         wzAsmCachePath[MAX_PATH];
    WCHAR                                         wzFileName[MAX_PATH];
    WCHAR                                         wzSourcePath[MAX_PATH];
    WCHAR                                         wzPDBName[MAX_PATH];
    WCHAR                                         wzPDBSourcePath[MAX_PATH];
    WCHAR                                         wzPDBTargetPath[MAX_PATH];
    WCHAR                                         wzModPath[MAX_PATH];
    LPWSTR                                        wzCodebase=NULL;
    LPWSTR                                        wzModName = NULL;
    DWORD                                         dwIdx = 0;
    LPWSTR                                        wzTmp = NULL;

    if (!pAsm) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (pAsm->GetAssemblyLocation(NULL) == E_NOTIMPL) {
        // This is a registered "known assembly" (ie. the process EXE).
        // We don't copy PDBs for the process EXE because it's never
        // shadow copied.

        hr = S_FALSE;
        goto Exit;
    }

    // Find the source location. Make sure this is a file:// URL (ie. we
    // don't support retrieving the PDB over http://).

    hr = pAsm->GetAssemblyNameDef(&pName);
    if (FAILED(hr)) {
        goto Exit;
    }

    wzCodebase = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzCodebase)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzCodebase[0] = L'\0';

    dwSize = MAX_URL_LENGTH * sizeof(WCHAR);
    hr = pName->GetProperty(ASM_NAME_CODEBASE_URL, (void *)wzCodebase, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!UrlIsW(wzCodebase, URLIS_FILEURL)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = MAX_PATH;
    hr = PathCreateFromUrlWrap(wzCodebase, wzSourcePath, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    wzTmp = PathFindFileName(wzSourcePath);
    ASSERT(wzTmp > (LPWSTR)wzSourcePath);
    *wzTmp = L'\0';
        
   // Find the target location in the cache.
   
    dwSize = MAX_PATH;
    hr = pAsm->GetManifestModulePath(wzAsmCachePath, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    wzTmp = PathFindFileName(wzAsmCachePath);
    ASSERT(wzTmp > (LPWSTR)wzAsmCachePath);

    StrCpy(wzFileName, wzTmp);
    *wzTmp = L'\0';


    // Copy the manifest PDB.

    // Hack for now
    dwSize = MAX_PATH;
    hr = GetPDBName(wzFileName, wzPDBName, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintfW(wzPDBSourcePath, MAX_PATH, L"%ws%ws", wzSourcePath, wzPDBName);
    wnsprintf(wzPDBTargetPath, MAX_PATH, L"%ws%ws", wzAsmCachePath, wzPDBName);

    if (GetFileAttributes(wzPDBTargetPath) == -1 && FusionCompareStringI(wzPDBSourcePath, wzPDBTargetPath)) {
        CopyFile(wzPDBSourcePath, wzPDBTargetPath, TRUE);
    }

    // Copy the module PDBs.

    dwIdx = 0;
    while (SUCCEEDED(hr)) {
        hr = pAsm->GetNextAssemblyModule(dwIdx++, &pModImport);

        if (SUCCEEDED(hr)) {
            if (pModImport->IsAvailable()) {
                dwSize = MAX_PATH;
                hr = pModImport->GetModulePath(wzModPath, &dwSize);
                if (FAILED(hr)) {
                    SAFERELEASE(pModImport);
                    goto Exit;
                }

                wzModName = PathFindFileName(wzModPath);
                ASSERT(wzModName);

                dwSize = MAX_PATH;
                hr = GetPDBName(wzModName, wzPDBName, &dwSize);
                if (FAILED(hr)) {
                    SAFERELEASE(pModImport);
                    goto Exit;
                }

                wnsprintfW(wzPDBSourcePath, MAX_PATH, L"%ws%ws", wzSourcePath,
                           wzPDBName);
                wnsprintfW(wzPDBTargetPath, MAX_PATH, L"%ws%ws", wzAsmCachePath,
                           wzPDBName);

                if (GetFileAttributes(wzPDBTargetPath) == -1 && FusionCompareStringI(wzPDBSourcePath, wzPDBTargetPath)) {
                    CopyFile(wzPDBSourcePath, wzPDBTargetPath, TRUE);
                }
            }

            SAFERELEASE(pModImport);
        }
    }

    // Copy complete. Return success.

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        hr = S_OK;
    }

Exit:
    SAFERELEASE(pName);
    SAFEDELETEARRAY(wzCodebase);
    return hr;
}

// ---------------------------------------------------------------------------
// GetCorSystemDirectory
// ---------------------------------------------------------------------------
BOOL GetCorSystemDirectory(LPWSTR szCorSystemDir)
{
    HRESULT                         hr = S_OK;
    BOOL                            fRet = FALSE;
    DWORD                           ccPath = MAX_PATH;

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = g_pfnGetCorSystemDirectory(szCorSystemDir, MAX_PATH, &ccPath);
    if (FAILED(hr)) {
        goto Exit;
    }

    fRet = TRUE;

Exit:
    return fRet;
}

// ---------------------------------------------------------------------------
// VerifySignature
// StronNameSignatureVerificationEx call behavior from RudiM 
// and associated fusion actions
//
// Note: fForceVerify assumed FALSE for all of the below:
//
// 1) successful verification of signed assembly
//    Returns TRUE, *pfWasVerified == TRUE.
//    Fusion action: Allow cache commit.
//
// 2) unsuccessful verification of fully signed assembly
//    Returns FALSE, StrongNameErrorInfo() returns NTE_BAD_SIGNATURE (probably), 
//    *pfWasVerified == Undefined.
//    Fusion action: Fail cache commit.
//
// 3) successful verification of delay signed assembly
//    Returns TRUE, *pfWasVerified == FALSE.
//    Fusion action: Allow cache commit, mark entry so that signature 
//    verification is performed on retrieval.
//
// 4) unsuccessful verification of delay signed assembly
//    (Assuming fForceVerify == FALSE): returns FALSE, StrongNameErrorInfo() 
//    some error code other than NTE_BAD_SIGNATURE, *pfWasVerified == Undefined.
// ---------------------------------------------------------------------------
BOOL VerifySignature(LPWSTR szFilePath, LPBOOL pfWasVerified, DWORD dwFlags)
{    
    HRESULT                         hr = S_OK;
    DWORD                           dwFlagsOut = 0;
    BOOL                            fRet = FALSE;

    // Initialize crypto if necessary. 

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto exit;
    }

    // Verify the signature
    if (!g_pfnStrongNameSignatureVerification(szFilePath, dwFlags, &dwFlagsOut)) {
        goto exit;
    }

    if (pfWasVerified) {
        *pfWasVerified = ((dwFlagsOut & SN_OUTFLAG_WAS_VERIFIED) != 0);
    }

    fRet = TRUE;

exit:

    return fRet;
}

// ---------------------------------------------------------------------------
// CreateFilePathHierarchy
// ---------------------------------------------------------------------------
HRESULT CreateFilePathHierarchy( LPCOLESTR pszName )
{
    HRESULT hr=S_OK;
    LPTSTR pszFileName;
    TCHAR szPath[MAX_PATH];

    // Assert (pszPath ) ;
    if (lstrlenW(pszName) >= MAX_PATH) {
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
        
    StrCpy (szPath, pszName);

    pszFileName = PathFindFileName ( szPath );

    if ( pszFileName <= szPath )
        return E_INVALIDARG; // Send some error 

    *(pszFileName-1) = 0;

    DWORD dw = GetFileAttributes( szPath );
    if ( dw != (DWORD) -1 )
        return S_OK;
    
    hr = FusionpHresultFromLastError();

    switch (hr)
    {
        case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
            {
                hr =  CreateFilePathHierarchy(szPath);
                if (hr != S_OK)
                    return hr;
            }

        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            {
                if ( CreateDirectory( szPath, NULL ) )
                    return S_OK;
                else
                {
                    hr = FusionpHresultFromLastError();
                    if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
                        hr = S_OK;
                    else
                        return hr;
                }
            }

        default:
            return hr;
    }
}

// ---------------------------------------------------------------------------
// Helper function to generate random name.

DWORD GetRandomName (LPTSTR szDirName, DWORD dwLen)
{
    static unsigned Counter;
    LARGE_INTEGER liRand;
    LARGE_INTEGER li;

    for (DWORD i = 0; i < dwLen; i++)
    {
        // Try using high performance counter, otherwise just use
        // the tick count
        if (QueryPerformanceCounter(&li)) {
            liRand.QuadPart = li.QuadPart + Counter++;
        }
        else {
            liRand.QuadPart = (GetTickCount() + Counter++);
        }
        BYTE bRand = (BYTE) (liRand.QuadPart % 36);

        // 10 digits + 26 letters
        if (bRand < 10)
            *szDirName++ = TEXT('0') + bRand;
        else
            *szDirName++ = TEXT('A') + bRand - 10;
    }

    *szDirName = 0;

    return dwLen; // returns length not including null
}

HRESULT GetRandomFileName(LPTSTR pszPath, DWORD dwFileName)
{
    HRESULT hr=S_OK;
    LPTSTR  pszFileName=NULL;
    DWORD dwPathLen = 0;
    DWORD dwErr=0;

    ASSERT(pszPath);
    //ASSERT(IsPathRelative(pszPath))

    StrCat (pszPath, TEXT("\\") );
    dwPathLen = lstrlen(pszPath);

    if (dwPathLen + dwFileName + 1 >= MAX_PATH) {
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }

    pszFileName = pszPath + dwPathLen;

    // Loop until we get a unique file name.
    int i;
    for (i = 0; i < MAX_RANDOM_ATTEMPTS; i++) {
        GetRandomName (pszFileName, dwFileName);
        if (GetFileAttributes(pszPath) != -1)
                    continue;

        dwErr = GetLastError();                
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            hr = S_OK;
            break;
        }

        if (dwErr == ERROR_PATH_NOT_FOUND)
        {
            if(FAILED(hr = CreateFilePathHierarchy(pszPath)))
                break;
            else
                continue;
        }

        hr = HRESULT_FROM_WIN32(dwErr);
        break;
    }

    if (i >= MAX_RANDOM_ATTEMPTS) {
        hr = E_UNEXPECTED;
    }

    return hr;

}

// ---------------------------------------------------------------------------
// Creates a new Dir for assemblies
HRESULT CreateDirectoryForAssembly
   (IN DWORD dwDirSize, IN OUT LPTSTR pszPath, IN OUT LPDWORD pcwPath)
{
    HRESULT hr=S_OK;
    DWORD dwErr;
    DWORD cszStore;
    LPTSTR pszDir=NULL;

    // Check output buffer can contain a full path.
    ASSERT (!pcwPath || *pcwPath >= MAX_PATH);

    if (!pszPath)
    {
        *pcwPath = MAX_PATH;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }


    cszStore = lstrlen (pszPath);
    if (cszStore + dwDirSize + 1 > *pcwPath) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto done;
    }
    
    pszDir = pszPath + cszStore;

    // Loop until we create a unique dir.
    int i;
    for (i = 0; i < MAX_RANDOM_ATTEMPTS; i++) {
        GetRandomName (pszDir, dwDirSize);

        hr = CreateFilePathHierarchy(pszPath);
        if(hr != S_OK)
            goto done;

        if (CreateDirectory (pszPath, NULL))
            break;
        dwErr = GetLastError();
        if (dwErr == ERROR_ALREADY_EXISTS)
            continue;
        hr = HRESULT_FROM_WIN32(dwErr);
        goto done;
    }

    if (i >= MAX_RANDOM_ATTEMPTS) {
        hr = E_UNEXPECTED;
        goto done;
    }

    *pcwPath = cszStore + dwDirSize + 1;
    hr = S_OK;

done:
    return hr;
}

HRESULT VersionFromString(LPCWSTR wzVersionIn, WORD *pwVerMajor, WORD *pwVerMinor,
                          WORD *pwVerBld, WORD *pwVerRev)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   wzVersion = NULL;
    WCHAR                                   *pchStart = NULL;
    WCHAR                                   *pch = NULL;
    WORD                                    *pawVersions[4] = {pwVerMajor, pwVerMinor, pwVerBld, pwVerRev};
    int                                      i;

    if (!wzVersionIn || !pwVerMajor || !pwVerMinor || !pwVerRev || !pwVerBld) {
        hr = E_INVALIDARG;
        goto Exit;
    }                          

    wzVersion = WSTRDupDynamic(wzVersionIn);
    if (!wzVersion) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pchStart = wzVersion;
    pch = wzVersion;

    *pwVerMajor = 0;
    *pwVerMinor = 0;
    *pwVerRev = 0;
    *pwVerBld = 0;

    for (i = 0; i < 4; i++) {

        while (*pch && *pch != L'.') {
            pch++;
        }
    
        if (i < 3) {
            if (!*pch) {
                // Badly formatted string
                hr = E_UNEXPECTED;
                goto Exit;
            }

            *pch++ = L'\0';
        }
    
        *(pawVersions[i]) = (WORD)StrToIntW(pchStart);
        pchStart = pch;
    }

Exit:
    SAFEDELETEARRAY(wzVersion);

    return hr;
}

HRESULT FusionGetUserFolderPath(LPWSTR pszPath)
{
    HRESULT hr = E_POINTER;
    PFNSHGETFOLDERPATH pfn = NULL;
    static WCHAR g_UserFolderPath[MAX_PATH+1];
    HMODULE hModShell32=NULL;
    HMODULE hModSHFolder=NULL;
    CCriticalSection cs(&g_csInitClb);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!g_UserFolderPath[0])
    {
        hModShell32 = LoadLibrary(TEXT("shell32.dll"));
        pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hModShell32, "SHGetFolderPathW");

        if (NULL == pfn)
        {
            hModSHFolder = LoadLibrary(TEXT("shfolder.dll"));
            if (NULL != hModSHFolder)
                pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hModSHFolder, "SHGetFolderPathW");
        }

        if (NULL != pfn)
        {
            if((hr = pfn(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, g_UserFolderPath))!= S_OK)
            {
                // hr = pfn(NULL, CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE , NULL, 0, g_UserFolderPath);
                // return an error if we cannot get user directory. this means no download cache.
                hr = HRESULT_FROM_WIN32(ERROR_BAD_USER_PROFILE);
            }
        }

#if 0
        // BUGBUG: There is a resource leak that occurs when loading/unloading
        // comctl32 (which gets statically pulled in by shell32). This causes
        // some failures when the re-loaded comctl32 tries to call some Win32
        // APIs, preventing particular winforms apps from working. 
        // See ASURT #96262

        if(hModShell32)
        {
            FreeLibrary(hModShell32);
        }

        if(hModSHFolder)
        {
            FreeLibrary(hModSHFolder);
        }
#endif    
    }

    if(g_UserFolderPath[0])
    {
        StrCpy(pszPath, g_UserFolderPath);
        hr = S_OK;
    }

    cs.Unlock();

Exit:
    return hr;
}


DWORD HashString(LPCWSTR wzKey, DWORD dwHashSize, BOOL bCaseSensitive)
{
    DWORD                                 dwHash = 0;
    DWORD                                 dwLen;
    DWORD                                 i;

    ASSERT(wzKey);

    dwLen = lstrlenW(wzKey);
    for (i = 0; i < dwLen; i++) {
        if (bCaseSensitive) {
            dwHash = (dwHash * 65599) + (DWORD)wzKey[i];
        }
        else {
            dwHash = (dwHash * 65599) + (DWORD)TOLOWER(wzKey[i]);
        }
    }

    dwHash %= dwHashSize;

    return dwHash;
}


HRESULT ExtractXMLAttribute(LPWSTR *ppwzValue, XML_NODE_INFO **aNodeInfo,
                            USHORT *pCurIdx, USHORT cNumRecs)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   pwzCurBuf = NULL;

    ASSERT(ppwzValue && aNodeInfo && pCurIdx && cNumRecs);

    // There shouldn't really be a previous value, but clear just to be safe.

    SAFEDELETEARRAY(*ppwzValue);

    (*pCurIdx)++;
    while (*pCurIdx < cNumRecs) {
        
        if (aNodeInfo[*pCurIdx]->dwType == XML_PCDATA ||
            aNodeInfo[*pCurIdx]->dwType == XML_ENTITYREF) {

            hr = AppendString(&pwzCurBuf, aNodeInfo[*pCurIdx]->pwcText,
                              aNodeInfo[*pCurIdx]->ulLen);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            // Reached end of data
            break;
        }

        (*pCurIdx)++;
    }

    if (!pwzCurBuf || !lstrlenW(pwzCurBuf)) {
        *ppwzValue = NULL;

        goto Exit;
    }

    *ppwzValue = WSTRDupDynamic(pwzCurBuf);
    if (!*ppwzValue) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(pwzCurBuf);

    return hr;
}

HRESULT AppendString(LPWSTR *ppwzHead, LPCWSTR pwzTail, DWORD dwLen)
{
    HRESULT                                    hr = S_OK;
    LPWSTR                                     pwzBuf = NULL;
    DWORD                                      dwLenBuf;
    
    ASSERT(ppwzHead && pwzTail);

    if (!*ppwzHead) {
        *ppwzHead = NEW(WCHAR[dwLen + 1]);

        if (!*ppwzHead) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
 
        // StrCpyN takes length in chars *including* NULL char

        StrCpyNW(*ppwzHead, pwzTail, dwLen + 1);
    }
    else {
        dwLenBuf = lstrlenW(*ppwzHead) + dwLen + 1;

        pwzBuf = NEW(WCHAR[dwLenBuf]);
        if (!pwzBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        StrCpyW(pwzBuf, *ppwzHead);
        StrNCatW(pwzBuf, pwzTail, dwLen + 1);

        SAFEDELETEARRAY(*ppwzHead);

        *ppwzHead = pwzBuf;
    }

Exit:
    return hr;
}


// this function works only on NT, caller should make sure not to call on Win9x 
HRESULT GetFileLastTime(LPWSTR pszPath, LPFILETIME pftFileLastWriteTime, LPFILETIME pftFileLastAccessTime)
{
    HRESULT hr=S_OK;
    typedef  BOOL (*PFNGETFILEATTRIBUTESEX) (LPWSTR, GET_FILEEX_INFO_LEVELS, LPVOID lpFileInformation);
    static PFNGETFILEATTRIBUTESEX pfn = NULL;
    WIN32_FILE_ATTRIBUTE_DATA fadDirAttribData;
    HMODULE hModKernel32=NULL;

    if (!pfn) {
        hModKernel32 = GetModuleHandle(TEXT("kernel32.dll"));
        if (hModKernel32 == NULL)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }
    
        pfn = (PFNGETFILEATTRIBUTESEX)GetProcAddress(hModKernel32, "GetFileAttributesExW");
        if (pfn == NULL)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }
    }

    if(!pfn(pszPath, GetFileExInfoStandard, &fadDirAttribData))
    {
            hr = FusionpHresultFromLastError();
            goto exit;
    }

    if(pftFileLastWriteTime)
    {
        memcpy(pftFileLastWriteTime, &fadDirAttribData.ftLastWriteTime, sizeof(FILETIME));
    }

    if(pftFileLastAccessTime)
    {
        memcpy(pftFileLastAccessTime, &fadDirAttribData.ftLastAccessTime, sizeof(FILETIME));
    }

exit:
    return hr;
}

LPWSTR GetNextDelimitedString(LPWSTR *ppwzList, WCHAR wcDelimiter)
{
    LPWSTR                         wzCurString = NULL;
    LPWSTR                         wzPos = NULL;

    if (!ppwzList) {
        goto Exit;
    }

    wzCurString = *ppwzList;
    wzPos = *ppwzList;

    while (*wzPos && *wzPos != wcDelimiter) {
        wzPos++;
    }

    if (*wzPos == wcDelimiter) {
        // Found a delimiter
        *wzPos = L'\0';
        *ppwzList = (wzPos + 1);
    }
    else {
        // End of string
        *ppwzList = NULL;
    }

Exit:
    return wzCurString;
}

HRESULT FusionpHresultFromLastError()
{
    HRESULT hr = S_OK;
    DWORD dwLastError = GetLastError();
    if (dwLastError != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT GetCORVersion(LPWSTR pbuffer, DWORD *dwLength)
{
    HRESULT                             hr = S_OK;

    if (!dwLength) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = (*g_pfnGetCORVersion)(pbuffer, *dwLength, dwLength);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT InitializeEEShim()
{
    HRESULT                              hr = S_OK;
    HMODULE                              hMod;
    CCriticalSection                     cs(&g_csInitClb);

    if (!g_hMSCorEE) {
        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        if (!g_hMSCorEE) {
            hMod = LoadLibrary(TEXT("mscoree.dll"));
            if (!hMod) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                cs.Unlock();
                goto Exit;
            }

            g_pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY)GetProcAddress(hMod, "GetCORSystemDirectory");
            g_pfnGetCORVersion = (pfnGetCORVersion)GetProcAddress(hMod, "GetCORVersion");
            g_pfnStrongNameTokenFromPublicKey = (PFNSTRONGNAMETOKENFROMPUBLICKEY)GetProcAddress(hMod, "StrongNameTokenFromPublicKey");
            g_pfnStrongNameErrorInfo = (PFNSTRONGNAMEERRORINFO)GetProcAddress(hMod, "StrongNameErrorInfo");
            g_pfnStrongNameFreeBuffer = (PFNSTRONGNAMEFREEBUFFER)GetProcAddress(hMod, "StrongNameFreeBuffer");
            g_pfnStrongNameSignatureVerification = (PFNSTRONGNAMESIGNATUREVERIFICATION)GetProcAddress(hMod, "StrongNameSignatureVerification");
            g_pfnGetAssemblyMDImport = (pfnGetAssemblyMDImport)GetProcAddress(hMod, "GetAssemblyMDImport");
            g_pfnCoInitializeCor = (COINITIALIZECOR) GetProcAddress(hMod, "CoInitializeCor");
            g_pfnGetXMLObject = (pfnGetXMLObject)GetProcAddress(hMod, "GetXMLObject");

            if (!g_pfnGetCorSystemDirectory || !g_pfnGetCORVersion || !g_pfnStrongNameTokenFromPublicKey ||
                !g_pfnStrongNameErrorInfo || !g_pfnStrongNameFreeBuffer || !g_pfnStrongNameSignatureVerification ||
                !g_pfnGetAssemblyMDImport || !g_pfnCoInitializeCor || !g_pfnGetXMLObject) {

                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
                cs.Unlock();
                goto Exit;
            }

            hr = (*g_pfnCoInitializeCor)(COINITCOR_DEFAULT);
            if (FAILED(hr)) {
                cs.Unlock();
                goto Exit;
            }

            // Interlocked exchange guarantees memory barrier
            
            InterlockedExchangePointer((void **)&g_hMSCorEE, hMod);
        }

        cs.Unlock();
    }

Exit:
    return hr;
}





#ifndef USE_FUSWRAPPERS

BOOL g_bRunningOnNT = FALSE;
BOOL g_bRunningOnNT5OrHigher = FALSE;
DWORD GlobalPlatformType;

/*----------------------------------------------------------
// Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.
*/


STDAPI_(BOOL) IsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if(GetVersionExA(&s_osvi))
        {
            switch(s_osvi.dwPlatformId)
            {
                case VER_PLATFORM_WIN32_WINDOWS:
                    GlobalPlatformType = PLATFORM_TYPE_WIN95;
                    break;

                case VER_PLATFORM_WIN32_NT:
                    GlobalPlatformType = PLATFORM_TYPE_WIN95;
                    break;
            }
        }
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId));
#endif
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_NT4:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId)) &&
#endif
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}   

int SetOsFlag(void)
{
  g_bRunningOnNT = IsOS(OS_NT);
  g_bRunningOnNT5OrHigher = IsOS(OS_NT5);
  return TRUE;
}

#endif //USE_FUSWRAPPERS


DWORD GetFileSizeInKB(DWORD dwFileSizeLow, DWORD dwFileSizeHigh)
{    
    static ULONG dwKBMask = (1023); // 1024-1
    ULONG   dwFileSizeInKB = dwFileSizeLow >> 10 ; // strip of 10 LSB bits to convert from bytes to KB.

    if(dwKBMask & dwFileSizeLow)
        dwFileSizeInKB++; // Round up to the next KB.

    if(dwFileSizeHigh)
        dwFileSizeInKB += (dwFileSizeHigh * (1 << 22) );

    return dwFileSizeInKB;
}



HRESULT GetManifestFileLock( LPWSTR pszFilename, HANDLE *phFile)
{
    HRESULT                                hr = S_OK;
    HANDLE                                 hFile = INVALID_HANDLE_VALUE;
    DWORD                                  dwShareMode = FILE_SHARE_READ;

    ASSERT(pszFilename);

    // take a soft lock; this maybe removed soon.
    if(g_bRunningOnNT)
        dwShareMode |= FILE_SHARE_DELETE;        

    hFile = CreateFile(pszFilename, GENERIC_READ, dwShareMode, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if(phFile)
    {
        *phFile = hFile;
        hFile = INVALID_HANDLE_VALUE;
    }

exit:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;

}

int GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDate,
                       LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
{
    int                                    iRet = 0;
    LPSTR                                  szDate = NULL;
    LPSTR                                  szFormat = NULL;


    if (g_bRunningOnNT) {
        iRet = GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
    }
    else {
        szDate = new CHAR[cchDate];
        if (!szDate) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        if (lpFormat) {
            if (FAILED(Unicode2Ansi(lpFormat, &szFormat))) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Exit;
            }
        }

        iRet = GetDateFormatA(Locale, dwFlags, lpDate, szFormat, szDate, cchDate);
        if (!iRet) {
            goto Exit;
        }

        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDate, -1, lpDateStr, cchDate)) {
            iRet = 0;
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(szFormat);
    SAFEDELETEARRAY(szDate);

    return iRet;
}

int GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDate,
                       LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
{
    int                                    iRet = 0;
    LPSTR                                  szTime = NULL;
    LPSTR                                  szFormat = NULL;


    if (g_bRunningOnNT) {
        iRet = GetTimeFormatW(Locale, dwFlags, lpDate, lpFormat, lpTimeStr, cchTime);
    }
    else {
        szTime = new CHAR[cchTime];
        if (!szTime) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        if (lpFormat) {
            if (FAILED(Unicode2Ansi(lpFormat, &szFormat))) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Exit;
            }
        }

        iRet = GetTimeFormatA(Locale, dwFlags, lpDate, szFormat, szTime, cchTime);
        if (!iRet) {
            goto Exit;
        }

        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szTime, -1, lpTimeStr, cchTime)) {
            iRet = 0;
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(szFormat);
    SAFEDELETEARRAY(szTime);

    return iRet;
}

DWORD GetPrivateProfileStringExW(LPCWSTR lpAppName, LPCWSTR lpKeyName,
                                 LPCWSTR lpDefault, LPWSTR *ppwzReturnedString,
                                 LPCWSTR lpFileName)
{
    DWORD                                        dwRet;
    LPWSTR                                       pwzBuf = NULL;
    int                                          iSizeCur = INI_READ_BUFFER_SIZE;


    for (;;) {
        pwzBuf = NEW(WCHAR[iSizeCur]);
        if (!pwzBuf) {
            dwRet = 0;
            *ppwzReturnedString = NULL;
            goto Exit;
        }
        
        dwRet = GetPrivateProfileStringW(lpAppName, lpKeyName,
                                         lpDefault, pwzBuf,
                                         iSizeCur, lpFileName);
        if (lpAppName && lpKeyName && dwRet == iSizeCur - 1) {
            SAFEDELETEARRAY(pwzBuf);
            iSizeCur += INI_READ_BUFFER_SIZE;
        }
        else if ((!lpAppName || !lpKeyName) && dwRet == iSizeCur - 2) {
            SAFEDELETEARRAY(pwzBuf);
            iSizeCur += INI_READ_BUFFER_SIZE;
        }
        else {
            break;
        }
    }

    *ppwzReturnedString = pwzBuf;

Exit:
    return dwRet;
}

HRESULT UpdatePublisherPolicyTimeStampFile(IAssemblyName *pName)
{
    HRESULT                                 hr = S_OK;
    DWORD                                   dwSize;
    HANDLE                                  hFile = INVALID_HANDLE_VALUE;
    WCHAR                                   wzTimeStampFile[MAX_PATH + 1];
    WCHAR                                   wzAsmName[MAX_PATH];

    ASSERT(pName);

    // If the name of the assembly begins with "policy." then update
    // the publisher policy timestamp file.

    wzAsmName[0] = L'\0';
    *wzTimeStampFile = L'\0';

    dwSize = MAX_PATH;
    hr = pName->GetProperty(ASM_NAME_NAME, wzAsmName, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (StrCmpNI(wzAsmName, POLICY_ASSEMBLY_PREFIX, lstrlenW(POLICY_ASSEMBLY_PREFIX))) {
        // No work needs to be done

        goto Exit;
    }

    // Touch the file

    dwSize = MAX_PATH;
    hr = GetCachePath(ASM_CACHE_GAC, wzTimeStampFile, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (lstrlenW(wzTimeStampFile) + lstrlenW(FILENAME_PUBLISHER_PCY_TIMESTAMP) + 1 >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }
        
    PathRemoveBackslash(wzTimeStampFile);
    lstrcatW(wzTimeStampFile, FILENAME_PUBLISHER_PCY_TIMESTAMP);

    hFile = CreateFileW(wzTimeStampFile, GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
    
    return hr;
} 

void FusionFormatGUID(GUID guid, LPWSTR pszBuf, DWORD cchSize)
{

    ASSERT(pszBuf && cchSize);

    wnsprintf(pszBuf,  cchSize, L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
            guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
}

BOOL PathIsRelativeWrap(LPCWSTR pwzPath)
{
    BOOL                             bRet = FALSE;
    
    ASSERT(pwzPath);

    if (pwzPath[0] == L'\\' || pwzPath[0] == L'/') {
        goto Exit;
    }

    if (PathIsURLW(pwzPath)) {
        goto Exit;
    }

    bRet = PathIsRelativeW(pwzPath);

Exit:
    return bRet;
}

//
// URL Combine madness from shlwapi:
//
//   \\server\share\ + Hello%23 = file://server/share/Hello%23 (left unescaped)
//   d:\a b\         + bin      = file://a%20b/bin
//
        
HRESULT UrlCombineUnescape(LPCWSTR pszBase, LPCWSTR pszRelative, LPWSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwSize;
    LPWSTR                                    pwzCombined = NULL;
    LPWSTR                                    pwzFileCombined = NULL;

    pwzCombined = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzCombined) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    // If we're just combining an absolute file path to an relative file
    // path, do this by concatenating the strings, and canonicalizing it.
    // This avoids UrlCombine randomness where you could end up with
    // a partially escaped (and partially unescaped) resulting URL!

    if (!PathIsURLW(pszBase) && PathIsRelativeWrap(pszRelative)) {
        pwzFileCombined = NEW(WCHAR[MAX_URL_LENGTH]);
        if (!pwzFileCombined) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        wnsprintfW(pwzFileCombined, MAX_URL_LENGTH, L"%ws%ws", pszBase, pszRelative);

        hr = UrlCanonicalizeUnescape(pwzFileCombined, pszCombined, pcchCombined, 0);
        goto Exit;
    }
    else {
        dwSize = MAX_URL_LENGTH;
        hr = UrlCombineW(pszBase, pszRelative, pwzCombined, &dwSize, dwFlags);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // Don't unescape if the relative part was already an URL because
    // URLs wouldn't have been escaped during the UrlCombined.

    if (UrlIsW(pwzCombined, URLIS_FILEURL)) {
        hr = UrlUnescapeW(pwzCombined, pszCombined, pcchCombined, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        if (*pcchCombined >= dwSize) {
            lstrcpyW(pszCombined, pwzCombined);
        }

        *pcchCombined = dwSize;
    }

Exit:
    SAFEDELETEARRAY(pwzCombined);
    SAFEDELETEARRAY(pwzFileCombined);

    return hr;
}

HRESULT UrlCanonicalizeUnescape(LPCWSTR pszUrl, LPWSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwSize;
    WCHAR                                     wzCanonical[MAX_URL_LENGTH];

    if (UrlIsW(pszUrl, URLIS_FILEURL) || !PathIsURLW(pszUrl)) {
        dwSize = MAX_URL_LENGTH;
        hr = UrlCanonicalizeW(pszUrl, wzCanonical, &dwSize, dwFlags);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = UrlUnescapeW(wzCanonical, pszCanonicalized, pcchCanonicalized, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        hr = UrlCanonicalizeW(pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags /*| URL_ESCAPE_PERCENT*/);
    }

    // Canonicalization not guaranteed to convert \ into / characters!
    //
    // Ex.
    //    1) c:\#folder\web\bin/foo.dll
    //           -> file:///c:/#folder\web\bin/foo.dll (?!)
    //    2) c:\Afolder\web\bin/foo.dll
    //           -> file:///c:/Afolder/web/bin/foo.dll
    //    3) c:\A#older\web\bin/foo.dll
    //           -> file:///c:/A%23older/web/bin/foo.dll
    
    if (hr == S_OK) {
        LPWSTR    pwzCur;
        pwzCur = (LPWSTR)pszCanonicalized;
    
        while (*pwzCur) {
            if (*pwzCur == L'\\') {
                *pwzCur = L'/';
            }
    
            pwzCur++;
        }
    }

Exit:
    return hr;
}

HRESULT GetCurrentUserSID(WCHAR *rgchSID)
{
    HRESULT                            hr = S_OK;
    HANDLE                             hToken = 0;
    UCHAR                              TokenInformation[SIZE_OF_TOKEN_INFORMATION];
    ULONG                              ReturnLength;
    BOOL                               bRet;
    PISID                              pSID;
    WCHAR                              wzBuffer[MAX_SID_LEN];

    bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    bRet = GetTokenInformation(hToken, TokenUser, TokenInformation,
                               sizeof(TokenInformation), &ReturnLength);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    pSID = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;

    if ((pSID->IdentifierAuthority.Value[0] != 0) ||
        (pSID->IdentifierAuthority.Value[1] != 0)) {

        wnsprintfW(rgchSID, MAX_SID_LEN, L"S-%u-0x%02hx%02hx%02hx%02hx%02hx%02hx",
                  (USHORT)pSID->Revision,
                  (USHORT)pSID->IdentifierAuthority.Value[0],
                  (USHORT)pSID->IdentifierAuthority.Value[1],
                  (USHORT)pSID->IdentifierAuthority.Value[2],
                  (USHORT)pSID->IdentifierAuthority.Value[3],
                  (USHORT)pSID->IdentifierAuthority.Value[4],
                  (USHORT)pSID->IdentifierAuthority.Value[5]);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        wnsprintfW(rgchSID, MAX_SID_LEN, L"S-%u-%lu",
                   (USHORT)pSID->Revision, Tmp);
    }

    for (int i=0; i<pSID->SubAuthorityCount; i++) {
        wnsprintfW(wzBuffer, MAX_SID_LEN, L"-%lu", pSID->SubAuthority[i]);
        lstrcatW(rgchSID, wzBuffer);
    }

Exit:
    if (hToken) {
        CloseHandle(hToken);
    }

    return hr;
}

BOOL IsHosted()
{
    static BOOL                     bIsHosted = FALSE;
    static BOOL                     bChecked = FALSE;

    if (bChecked) {
        return bIsHosted;
    }

    bIsHosted = IsLocalSystem();
    bChecked = TRUE;

    return bIsHosted;
}

BOOL FusionGetVolumePathNameW(LPCWSTR lpszFileName,         // file path
                              LPWSTR lpszVolumePathName,    // volume mount point
                              DWORD cchBufferLength         // size of buffer
                              )
{
    HINSTANCE                                       hInst;
    DWORD                                           cszDir = 0;

    if(!g_pfnGetVolumePathNameW)
    {
        hInst = GetModuleHandle(TEXT("KERNEL32.DLL"));
        if (hInst) {
            g_pfnGetVolumePathNameW = (pfnGetVolumePathNameW)GetProcAddress(hInst, "GetVolumePathNameW");
        }
    }

    if (g_pfnGetVolumePathNameW) {
        return (*g_pfnGetVolumePathNameW)(lpszFileName, lpszVolumePathName, cchBufferLength);
    }

    return FALSE;
}

#define MPR_DLL_NAME        (L"mpr.dll")
typedef DWORD (APIENTRY * pfnWNetGetUniversalNameW)(
        LPCWSTR lpLocalPath,
        DWORD    dwInfoLevel,
        LPVOID   lpBuffer,
        LPDWORD  lpBufferSize
        );
typedef DWORD (APIENTRY * pfnWNetGetUniversalNameA)(
        LPCSTR lpLocalPath,
        DWORD    dwInfoLevel,
        LPVOID   lpBuffer,
        LPDWORD  lpBufferSize
        );


pfnWNetGetUniversalNameW g_pfnWNetGetUniversalNameW = NULL;
pfnWNetGetUniversalNameA g_pfnWNetGetUniversalNameA = NULL;

DWORD
FusionGetRemoteUniversalName(LPWSTR pwzPathName, LPVOID lpBuff, LPDWORD pcbSize )
{
    DWORD dwRetVal;
    HMODULE hInst;
    LPSTR pszPathName = NULL;
    UNIVERSAL_NAME_INFOA *puni = NULL;
    UNIVERSAL_NAME_INFOW *puniW = (UNIVERSAL_NAME_INFO*) lpBuff;

    ASSERT(pwzPathName && lpBuff && pcbSize);

    if(!g_pfnWNetGetUniversalNameW && !g_pfnWNetGetUniversalNameA)
    {
        hInst = LoadLibrary(MPR_DLL_NAME);
        if (hInst) 
        {
            if(g_bRunningOnNT)
                g_pfnWNetGetUniversalNameW = (pfnWNetGetUniversalNameW)GetProcAddress(hInst, "WNetGetUniversalNameW");
            else
                g_pfnWNetGetUniversalNameA = (pfnWNetGetUniversalNameA)GetProcAddress(hInst, "WNetGetUniversalNameA");
        }
        else return ERROR_MOD_NOT_FOUND;
    }

    if(g_bRunningOnNT)
    {
        if(g_pfnWNetGetUniversalNameW)
        {
            return (*g_pfnWNetGetUniversalNameW)(
                                    pwzPathName,
                                    UNIVERSAL_NAME_INFO_LEVEL,
                                    lpBuff,
                                    pcbSize );
        }
        else return ERROR_PROC_NOT_FOUND;
    }
    else
    {
        if(g_pfnWNetGetUniversalNameA)
        {

            // Win95, so convert.
            if ( FAILED(WszConvertToAnsi(
                        pwzPathName,
                        &pszPathName,
                        0, NULL, TRUE)) )
            {
                dwRetVal = ERROR_OUTOFMEMORY;
                goto exit;
            }

            puni = (UNIVERSAL_NAME_INFOA*) new BYTE[(*pcbSize) * DBCS_MAXWID + sizeof(UNIVERSAL_NAME_INFO)];
            if( !puni )
            {
                dwRetVal = ERROR_OUTOFMEMORY;
                goto exit;
            }

            dwRetVal = (*g_pfnWNetGetUniversalNameA)(
                                    pszPathName,
                                    UNIVERSAL_NAME_INFO_LEVEL,
                                    (PVOID)puni,
                                    pcbSize );

            if(dwRetVal != NO_ERROR)
                goto exit;

            puniW->lpUniversalName = ((LPWSTR)puniW + sizeof(LPWSTR));
            if( FAILED(WszConvertToUnicode(puni->lpUniversalName, -1, 
                                           &(puniW->lpUniversalName), pcbSize, FALSE)) )
            {
                *pcbSize = 0;
                *(puniW->lpUniversalName) = L'\0';
            }
        }
        else return ERROR_PROC_NOT_FOUND;
    }

exit :

    /*
    if(pszPathName)
        delete [] pszPathName;
    */

    if(puni)
        delete [] puni;

    return dwRetVal;
}

BOOL IsLocalSystem(void)
/*++

Routine Description:
    Check if the process is local system.

Arguments:
        None.    

Returned Value:
        TRUE for if the process is Local System, FALSE otherwise

--*/
{
        //
        // Get LocalSystem sid
        //
        CPSID pLocalSystemSid;
        GetLocalSystemSid(&pLocalSystemSid);

        //
        // can i use P<SID> seems mistake (that what mqsec is using)
        // see P<SID> in mqsec\imprsont.cpp
        //
        //
        // Get process sid
        //
        BYTE *pProcessSid = NULL;
        GetProcessSid(reinterpret_cast<PSID*>(&pProcessSid));

        //
        // Compare
        //
        BOOL fLocalSystem = FALSE;
        if (pProcessSid && pLocalSystemSid)
        {
                fLocalSystem = EqualSid(pLocalSystemSid, pProcessSid);
        }

        SAFEDELETEARRAY(pProcessSid);

        return fLocalSystem;
}

HRESULT
GetLocalSystemSid(
        OUT PSID* ppLocalSystemSid
        )
/*++

Routine Description:
    Get LocalSystem Sid.
        If failed the function throw bad_win32_error()

Arguments:
    ppLocalSystemSid - pointer to PSID.

Returned Value:
        None.    

--*/
{
    //
    // Get LocalSystem Sid
    //
    HRESULT hr = S_OK;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    BOOL fSuccess = AllocateAndInitializeSid( 
                                                &NtAuth,
                                                1,
                                                SECURITY_LOCAL_SYSTEM_RID,
                                                0,
                                                0,
                                                0,
                                                0,
                                                0,
                                                0,
                                                0,
                                                ppLocalSystemSid
                                                );

        if(!fSuccess)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT
GetProcessSid( 
        OUT PSID* ppSid 
        )
/*++

Routine Description:
    Get process Sid.
        If failed the function throw bad_win32_error()

Arguments:
    ppSid - pointer to PSID.

Returned Value:
        None.    

--*/
{
        //
        // Get handle to process token
        //
        HRESULT hr = S_OK;
        HANDLE hProcessToken = NULL;
    BOOL fSuccess = OpenProcessToken(
                                                GetCurrentProcess(),
                                                TOKEN_QUERY,
                                                &hProcessToken
                                                );
        if(!fSuccess)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    
    ASSERT(hProcessToken);

        GetTokenSid( 
                hProcessToken,
                ppSid
                );
Exit:
    return hr;
}

HRESULT
GetTokenSid( 
        IN  HANDLE hToken,
        OUT PSID*  ppSid
        )
/*++

Routine Description:
    Get Sid from Token Handle.
        The function allocate the *ppSid which need to be free by the calling function.
        If failed the function throw bad_win32_error()

Arguments:
        hToken - handle to Token.
    ppSid - pointer to PSID.

Returned Value:
        None.    

--*/
{

        //
        // Get TokenInformation Length
        //
    HRESULT hr = S_OK;
    DWORD dwTokenLen = 0;
    GetTokenInformation(
                hToken, 
                TokenUser, 
                NULL, 
                0, 
                &dwTokenLen
                );

        //
        // It is ok to failed with this error because we only get the desired length
        //
        ASSERT(("failed in GetTokenInformation", GetLastError() == ERROR_INSUFFICIENT_BUFFER));

        //
        // bug in mqsec regarding P<char> insteadof AP<char>
        // mqsec\imprsont.cpp\_GetThreadUserSid()
        //
        char *pTokenInfo = NEW(char[dwTokenLen]);

    BOOL fSuccess = GetTokenInformation( 
                                                hToken,
                                                TokenUser,
                                                pTokenInfo,
                                                dwTokenLen,
                                                &dwTokenLen 
                                                );

        if(!fSuccess)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        //
        // Get the Sid from TokenInfo
        //
    PSID pOwner = ((TOKEN_USER*)(char*)pTokenInfo)->User.Sid;

        ASSERT(IsValidSid(pOwner));

    DWORD dwSidLen = GetLengthSid(pOwner);
    *ppSid = (PSID) new BYTE[dwSidLen];
    fSuccess = CopySid(dwSidLen, *ppSid, pOwner);
        if(!fSuccess)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
Exit:
    if (pTokenInfo) {
        SAFEDELETEARRAY(pTokenInfo);
    }

    return hr;
}

HRESULT PathCreateFromUrlWrap(LPCWSTR pszUrl, LPWSTR pszPath, LPDWORD pcchPath, DWORD dwFlags)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dw;
    WCHAR                                       wzEscaped[MAX_URL_LENGTH];

    if (!UrlIsW(pszUrl, URLIS_FILEURL)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dw = MAX_URL_LENGTH;
    hr = UrlEscapeW(pszUrl, wzEscaped, &dw, URL_ESCAPE_PERCENT);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = PathCreateFromUrlW(wzEscaped, pszPath, pcchPath, dwFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    return hr;
}

#define FILE_URL_PREFIX              L"file://"

LPWSTR StripFilePrefix(LPWSTR pwzURL)
{
    LPWSTR                         szCodebase = pwzURL;

    ASSERT(pwzURL);

    if (!StrCmpNIW(szCodebase, FILE_URL_PREFIX, lstrlenW(FILE_URL_PREFIX))) {
        szCodebase += lstrlenW(FILE_URL_PREFIX);

        if (*(szCodebase + 1) == L':') {
            // BUGBUG: CLR erroneously passes in file:// prepended to file
            // paths, so we can't tell the difference between UNC and local file.
            // Just strip this off, if it looks like it's local file path
            
            goto Exit;
        }

        if (*szCodebase == L'/') {
            szCodebase++;
        }
        else {
            // UNC Path, go back two characters to preserve \\

            szCodebase -= 2;

            LPWSTR    pwzTmp = szCodebase;

            while (*pwzTmp) {
                if (*pwzTmp == L'/') {
                    *pwzTmp = L'\\';
                }

                pwzTmp++;
            }
        }
    }

Exit:
    return szCodebase;
}

HRESULT CheckFileExistence(LPCWSTR pwzFile, BOOL *pbExists)
{
    HRESULT                               hr = S_OK;
    DWORD                                 dw;

    ASSERT(pwzFile && pbExists);

    dw = GetFileAttributes(pwzFile);
    if (dw == INVALID_FILE_ATTRIBUTES) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            *pbExists = FALSE;
            hr = S_OK;
        }

        goto Exit;
    }

    *pbExists = TRUE;

Exit:
    return hr;
}

#define IS_UPPER_A_TO_Z(x) (((x) >= L'A') && ((x) <= L'Z'))
#define IS_LOWER_A_TO_Z(x) (((x) >= L'a') && ((x) <= L'z'))
#define IS_0_TO_9(x) (((x) >= L'0') && ((x) <= L'9'))
#define CAN_SIMPLE_UPCASE(x) (IS_UPPER_A_TO_Z(x) || IS_LOWER_A_TO_Z(x) || IS_0_TO_9(x) || ((x) == L'.') || ((x) == L'_') || ((x) == L'-'))
#define SIMPLE_UPCASE(x) (IS_LOWER_A_TO_Z(x) ? ((x) - L'a' + L'A') : (x))

WCHAR FusionMapChar(WCHAR wc)
{
    int                       iRet;
    WCHAR                     wTmp;
    
    iRet = LCMapString(g_lcid, LCMAP_UPPERCASE, &wc, 1, &wTmp, 1);
    if (!iRet) {
        ASSERT(0);
        iRet = GetLastError();
        wTmp = wc;
    }

    return wTmp;
}

int FusionCompareStringNI(LPCWSTR pwz1, LPCWSTR pwz2, int nChar)
{
    return FusionCompareStringN(pwz1, pwz2, nChar, FALSE);
}

// if nChar < 0, compare the whole string
int FusionCompareStringN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar, BOOL bCaseSensitive)
{
    int                               iRet = 0;
    int                               nCount = 0;
    WCHAR                             ch1;
    WCHAR                             ch2;
    ASSERT(pwz1 && pwz2);

    // Case sensitive comparison 
    if (bCaseSensitive) {
        if (nChar >= 0)
            return StrCmpN(pwz1, pwz2, nChar);
        else
            return StrCmp(pwz1, pwz2);
    }
        
    // Case insensitive comparison
    if (!g_bRunningOnNT) {
        if (nChar >= 0)
            return StrCmpNI(pwz1, pwz2, nChar);
        else
            return StrCmpI(pwz1, pwz2);
    }
    
    for (;;) {
        ch1 = *pwz1++;
        ch2 = *pwz2++;

        if (ch1 == L'\0' || ch2 == L'\0') {
            break;
        }
        
        // We use OS mapping table 
        ch1 = (CAN_SIMPLE_UPCASE(ch1)) ? (SIMPLE_UPCASE(ch1)) : (FusionMapChar(ch1));
        ch2 = (CAN_SIMPLE_UPCASE(ch2)) ? (SIMPLE_UPCASE(ch2)) : (FusionMapChar(ch2));
        nCount++;

        if (ch1 != ch2 || (nChar >= 0 && nCount >= nChar)) {
            break;
        }
    }

    if (ch1 > ch2) {
        iRet = 1;
    }
    else if (ch1 < ch2) {
        iRet = -1;
    }

    return iRet; 
}

int FusionCompareStringI(LPCWSTR pwz1, LPCWSTR pwz2)
{
    return FusionCompareStringN(pwz1, pwz2, -1, FALSE);
}

int FusionCompareString(LPCWSTR pwz1, LPCWSTR pwz2, BOOL bCaseSensitive)
{
    return FusionCompareStringN(pwz1, pwz2, -1, bCaseSensitive);
}

#define FUSIONRETARGETRESOURCENAME "RETARGET"
#define FUSIONRETARGETRESOURCETYPE "POLICY"

CNodeFactory       *g_pNFRetargetCfg = NULL;
BOOL                g_bRetargetPolicyInitialized = FALSE;

// InitFusionRetargetPolicy
//
// Pull out retarget policy from fusion.dll,
// parse it, and store the result in g_pNFRetargetCfg
// 
HRESULT InitFusionRetargetPolicy()
{
    HRESULT             hr         = S_OK;
    HRSRC               hRes       = NULL;
    HGLOBAL             hGlobal    = NULL;
    LPVOID              lpRes      = NULL;
    ULONG               cbSize     = 0;
    CCriticalSection    cs(&g_csDownload);

    if (g_bRetargetPolicyInitialized)
    {
        if (g_pNFRetargetCfg == NULL)
        {
            // retarget policy is parse before
            // but we didn't find a valid nodefact,
            // only reason is we get a bad retarget policy
            hr = E_UNEXPECTED;
        }
        // we have a good nodefact,
        // nothing left to do
        goto Exit;
    }

    // first time visit, let's parse it. 
    hr = cs.Lock();
    if (FAILED(hr))
    {
        goto Exit;
    }
   
    if (g_bRetargetPolicyInitialized)
    {
        if (g_pNFRetargetCfg == NULL)
        {
            // retarget policy is parse before
            // but we didn't find a valid nodefact,
            // only reason is we get a bad retarget policy
            hr = E_UNEXPECTED;
        }
        // we have a good nodefact,
        // nothing left to do
        cs.Unlock();
        goto Exit;
    }

    // now we are parsing retarget policy
    g_bRetargetPolicyInitialized = TRUE;
    
    ASSERT(g_hInst);
    hRes = FindResourceA(g_hInst, FUSIONRETARGETRESOURCENAME, FUSIONRETARGETRESOURCETYPE);
    if (hRes == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    hGlobal = LoadResource(g_hInst, hRes);
    if (hGlobal == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    lpRes = LockResource(hGlobal);

    cbSize = (ULONG)SizeofResource(g_hInst, hRes);
    if (cbSize == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    // Parse Retarget policy
    hr = ParseXML(&g_pNFRetargetCfg, lpRes, cbSize, TRUE, NULL);

    cs.Unlock();

Exit:
    if (hGlobal != NULL)
        FreeResource(hGlobal);

    return hr;
}

#define FUSIONFXCONFIGRESOURCENAME "FXCONFIG"
#define FUSIONFXCONFIGRESOURCETYPE "POLICY"

CNodeFactory       *g_pNFFxConfig = NULL;
BOOL                g_bFxConfigInitialized = FALSE;

// InitFusionFxConfigPolicy
//
// Pull out FxConfig policy from fusion.dll,
// parse it, and store the result in g_pNFFxConfig
// 
HRESULT InitFusionFxConfigPolicy()
{
    HRESULT             hr         = S_OK;
    HRSRC               hRes       = NULL;
    HGLOBAL             hGlobal    = NULL;
    LPVOID              lpRes      = NULL;
    ULONG               cbSize     = 0;
    CCriticalSection    cs(&g_csDownload);

    if (g_bFxConfigInitialized)
    {
        if (g_pNFFxConfig == NULL)
        {
            // FxConfig policy is parse before
            // but we didn't find a valid nodefact,
            // only reason is we get a bad FxConfig policy
            hr = E_UNEXPECTED;
        }
        // we have a good nodefact,
        // nothing left to do
        goto Exit;
    }

    // first time visit, let's parse it. 
    hr = cs.Lock();
    if (FAILED(hr))
    {
        goto Exit;
    }
   
    if (g_bFxConfigInitialized)
    {
        if (g_pNFFxConfig == NULL)
        {
            // FxConfig policy is parse before
            // but we didn't find a valid nodefact,
            // only reason is we get a bad FxConfig policy
            hr = E_UNEXPECTED;
        }
        // we have a good nodefact,
        // nothing left to do
        cs.Unlock();
        goto Exit;
    }

    // now we are parsing FxConfig policy
    g_bFxConfigInitialized = TRUE;
    
    ASSERT(g_hInst);
    hRes = FindResourceA(g_hInst, FUSIONFXCONFIGRESOURCENAME, FUSIONFXCONFIGRESOURCETYPE);
    if (hRes == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    hGlobal = LoadResource(g_hInst, hRes);
    if (hGlobal == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    lpRes = LockResource(hGlobal);

    cbSize = (ULONG)SizeofResource(g_hInst, hRes);
    if (cbSize == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        cs.Unlock();
        goto Exit;
    }

    // Parse FxConfig policy
    hr = ParseXML(&g_pNFFxConfig, lpRes, cbSize, TRUE, NULL);

    cs.Unlock();

Exit:
    if (hGlobal != NULL)
        FreeResource(hGlobal);

    return hr;
}

// Base 32 encoding uses most letters, and all numbers. Some letters are
// removed to prevent accidental generation of offensive words.
//
// Translates 5 8-bit sequences into 8 5-bit sequences.

static WCHAR g_achBase32[] = { L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9',
                               L'A', L'B', L'C', L'D', L'E', L'G', L'H', L'J', L'K', L'L',
                               L'M', L'N', L'O', L'P', L'Q', L'R', L'T', L'V', L'W', L'X',
                               L'Y', L'Z' };

HRESULT Base32Encode(BYTE *pbData, DWORD cbData, LPWSTR *ppwzBase32)
{
    HRESULT                                hr = S_OK;
    DWORD                                  dwSizeBase32String;
    LPWSTR                                 pwzBase32 = NULL;
    LPWSTR                                 pwzCur = NULL;
    int                                    shift = 0;
    ULONG                                  accum = 0;
    ULONG                                  value;
    DWORD                                  dwRemainder;


    if (!pbData || !ppwzBase32) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppwzBase32 = NULL;

    // Figure out size of resulting string

    dwSizeBase32String = (cbData / 5) * 8;
    dwRemainder = cbData % 5;

    if (dwRemainder) {
        // A little more than we need (we can pad with '=' like in base64,
        // but since we don't need to decode, why bother).

        dwSizeBase32String += 8;
    }

    dwSizeBase32String++;

    pwzBase32 = NEW(WCHAR[dwSizeBase32String]);
    if (!pwzBase32) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    memset(pwzBase32, 0, dwSizeBase32String * sizeof(WCHAR));

    pwzCur = pwzBase32;

    //
    // 12345678 ABCDEF12
    //
    // You are processing up to two bytes at a time. The "shift" represents
    // the number of bits from the previously processed byte that haven't
    // been accounted for yet. That is, it's the number of bits that have
    // been read into the accumulator, but not processed yet.
    //

    while (cbData) {
        // Move current byte into low bits of accumulator

        accum = (accum << 8) | *pbData++;
        shift += 8;
        --cbData;


        while (shift >= 5) {
            // By subtracting five from the number of unprocessed
            // characters remaining, and shifting the accumulator
            // by that amount, we are essentially shifting all but
            // 5 characters (the top most bits that we want). 
            shift -= 5;
            value = (accum >> shift) & 0x1FL;
            *pwzCur++ = g_achBase32[value];
        }
    }

    // If shift is non-zero here, there's less than five bits remaining.
    // Pad this with zeros.

    if (shift) {
        value = (accum << (5 - shift)) & 0x1FL;
        *pwzCur++ = g_achBase32[value];
    }

    *ppwzBase32 = pwzBase32;

Exit:
    if (FAILED(hr)) {
        SAFEDELETEARRAY(pwzBase32);
    }

    return hr;
}

HRESULT PathAddBackslashWrap(LPWSTR pwzPath, DWORD dwMaxLen)
{
    HRESULT                        hr = S_OK;
    DWORD                          dwLen;

    ASSERT(pwzPath);

    dwLen = lstrlenW(pwzPath) + 2;

    if (dwLen > dwMaxLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    PathAddBackslashW(pwzPath);

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\io.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "windows.h"
#include "FusionBuffer.h"
#include "Util.h"
#include "FusionHandle.h"

BOOL
FusionpCreateDirectories(
    PCWSTR pszDirectory
    )
/*-----------------------------------------------------------------------------
like ::CreateDirectoryW, but will create the parent directories as needed;
origin of this code
\\lang5\V5.PRO\src\ide5\shell\path.cpp ("MakeDirectory")
\\kingbird\vseedev\src\vsee98\vsee\pkgs\scc\path.cpp ("MakeDirectory")
then ported to \\kingbird\vseedev\src\vsee70\pkgs\scc\path.cpp ("MakeDirectory")
then moved to \vsee\lib\io\io.cpp, converted to use exceptions ("NVseeLibIo::FCreateDirectories")
then copied to fusion\dll\whistler\util.cpp, exceptions converted to BOOL/LastError ("SxspCreateDirectories")
-----------------------------------------------------------------------------*/
{
	BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    CStringBuffer strBuffer;
    DWORD dwAttribs = 0;

    IFFALSE_EXIT(strBuffer.Win32Assign(pszDirectory));

	//::CreateDirectoryW will do the wrong thing if strBuffer has a trailing slash,
	//so we'll strip it off if it's there. (see bug VS7:31319) [MSantoro]
	strBuffer.RemoveTrailingSlashes();

    // cover the two common cases of its parent exists or it exists
    if ((!::CreateDirectoryW(strBuffer, NULL)) && (::GetLastError() != ERROR_ALREADY_EXISTS))
    {
        CStringBufferAccessor sbaBuffer;

        // now the slow path

	    //
	    // Try to create the subdirectories (if any) named in the path.
	    //

        sbaBuffer.Attach(&strBuffer);

	    WCHAR* pStart = sbaBuffer.GetBufferPtr();
	    WCHAR* pCurr = pStart;

	    // skip the leading drive or \\computer\share
	    // this way we don't try to create C: in trying to create C:\
	    // or \\computer\share in trying to create \\computer\share\dir
	    // FUTURE This is not ideal.. (need NVseeLibPath)
	    if (pCurr[0] != 0)
	    {
		    const static WCHAR rgchAZaz[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
		    C_ASSERT(NUMBER_OF(rgchAZaz) == 53);
		    if
		    (
				    pCurr[1] == L':'
			    &&	(pCurr[2] == L'\\' || pCurr[2] == L'/')
			    &&	wcschr(rgchAZaz, pCurr[0]) != NULL
		    )
		    {
			    pCurr += 3;
		    }
		    else if
		    (
				    (pCurr[0] == L'\\' || pCurr[0] == L'/')
			    &&	(pCurr[1] == L'\\' || pCurr[1] == L'/')
		    )
		    {
			    // skip to after the share, since we presumably can't create shares with CreateDirectory
			    pCurr +=  wcsspn(pCurr, L"\\/"); // skip leading two slashes
			    pCurr += wcscspn(pCurr, L"\\/"); // skip computer name
			    pCurr +=  wcsspn(pCurr, L"\\/"); // skip slashes after computer name
			    pCurr += wcscspn(pCurr, L"\\/"); // skip share name
			    pCurr +=  wcsspn(pCurr, L"\\/"); // skip slashes after share name
		    }
	    }

	    while (*pCurr != L'\0')
	    {
		    pCurr += wcscspn(pCurr, L"\\/"); // skip to next slash
		    if (*pCurr != 0)
		    {
                // [a-JayK April 2000] Why not just assume it's a backslash?
			    WCHAR chSaved = *pCurr;
			    *pCurr = 0;
			    if (!::CreateDirectoryW(pStart, NULL))
			    {
			        // In trying to create c:\foo\bar,
			        // we try to create c:\foo, which fails, but is ok.
                    const DWORD dwLastError = ::GetLastError();
				    const DWORD dwAttribs = ::GetFileAttributesW(pStart);
				    if (dwAttribs == 0xFFFFFFFF || (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0)
				    {
                        ::SetLastError(dwLastError);
                        goto Exit;
				    }
			    }

			    *pCurr = chSaved;
			    pCurr += 1;
		    }
	    }

	    IFFALSE_EXIT(::CreateDirectoryW(pStart, NULL));
    }

	//
	// Try again to see if the given directory exists and 
	// return true if successful.
	//

	dwAttribs = ::GetFileAttributesW(strBuffer);
	if ((dwAttribs == 0xFFFFFFFF) || ((dwAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
        goto Exit;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

VOID
CFusionDirectoryDifference::DbgPrint(
    PCWSTR dir1,
    PCWSTR dir2
    )
{
#if DBG // { {
    switch (m_e)
    {
    case eEqual:
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls match size-wise recursively\n",
            dir1,
            dir2
            );
        break;
    case eExtraOrMissingFile:
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, the file %ls is only in one of them.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrExtraOrMissingFile)
            );
        break;
    case eMismatchedFileSize:
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, file:%ls, size:%I64d, file:%ls, size:%I64d.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrMismatchedSizeFile1),
            m_nMismatchedFileSize1,
            static_cast<PCWSTR>(*m_pstrMismatchedSizeFile2),
            m_nMismatchedFileSize2
            );
        break;
    case eMismatchedFileCount:
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch in number of files,"
            "subdirectory %ls has %I64d files, subdirectory %ls has %I64d files\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrMismatchedCountDir1),
            m_nMismatchedFileCount1,
            static_cast<PCWSTR>(*m_pstrMismatchedCountDir2),
            m_nMismatchedFileCount2
            );
        break;
    case eFileDirectoryMismatch:
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, "
            "%ls is a file, %ls is a directory.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrFile),
            static_cast<PCWSTR>(*m_pstrDirectory)
            );
        break;
    }
#endif // } }
}

/*-----------------------------------------------------------------------------*/

int __cdecl
CFusionFilePathAndSize::QsortComparePath(
    const void* pvx,
    const void* pvy
    )
{
    const CFusionFilePathAndSize* px = reinterpret_cast<const CFusionFilePathAndSize*>(pvx);
    const CFusionFilePathAndSize* py = reinterpret_cast<const CFusionFilePathAndSize*>(pvy);
    int i =
        FusionpCompareStrings(
            px->m_path,
            px->m_path.Cch(),
            py->m_path,
            py->m_path.Cch(),
            TRUE
            );
    return i;
}

int __cdecl
CFusionFilePathAndSize::QsortIndirectComparePath(
    const void* ppvx,
    const void* ppvy
    )
{
    const void* pv = *reinterpret_cast<void const* const*>(ppvx);
    const void* py = *reinterpret_cast<void const* const*>(ppvy);
    int i = QsortComparePath(pv, py);
    return i;
}

/*----------------------------------------------------------------------------- 
See FusionpCompareDirectoriesSizewiseRecursively for what this does;
this function exists to reduce the stack usage of
FusionpCompareDirectoriesSizewiseRecursively.
-----------------------------------------------------------------------------*/
static BOOL
FusionpCompareDirectoriesSizewiseRecursivelyHelper(
    CFusionDirectoryDifference*  pResult,
    CStringBuffer&         dir1,
    CStringBuffer&         dir2,
    WIN32_FIND_DATAW&      wfd
    )
{
// either or both directories can be on FAT, we can't assume that FindFirstFile
// returns entries in any particular order, so we first enumerate one directory
// entirely, storing the leaf names in an array, sort the array, then
// walk the second directory doing a binary search in the first array
// if the file is not in the array, we have an extra on one side
// we count the elements in both directories, if the counts don't match,
// we have a mismatch
    typedef CFusionArray<CFusionFilePathAndSize> CDirEntries;
    CDirEntries dir1Entries;
    typedef CFusionArray<CFusionFilePathAndSize*> CIndirectDirEntries;
    CIndirectDirEntries indirectDir1Entries;
    CFusionFilePathAndSize*   pFoundDirEntry = NULL;
    CFusionFilePathAndSize** ppFoundDirEntry = NULL;
    CFindFile findFile;
    BOOL fSuccess = FALSE;
    const SIZE_T dirSlash1Length = dir1.Cch();
    const SIZE_T dirSlash2Length = dir2.Cch();
    CFusionFilePathAndSize  pathAndSize;
    CFusionFilePathAndSize* pPathAndSize = &pathAndSize;
    INT count1 = 0; // seperate from the array, because this includes directories, and the array does not
    INT count2 = 0;
    DWORD dwAttributes = 0;
    HRESULT hr;

    if (!dir1.Win32Append(L"*"))
        goto Exit;
    if (!findFile.Create(dir1, &wfd))
        goto Exit;
    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
            continue;
        ++count1;
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            dir1.Left(dirSlash1Length);
            dir2.Left(dirSlash2Length);
            if (!dir1.Win32Append(wfd.cFileName))
                goto Exit;
            if (!dir1.Win32EnsureTrailingSlash())
                goto Exit;
            if (!dir2.Win32Append(wfd.cFileName))
                goto Exit;
            dwAttributes = GetFileAttributesW(dir2);
            if (dwAttributes == 0xFFFFFFFF)
            {
                pResult->m_str1.Win32Assign(dir1, dirSlash1Length);
                pResult->m_str1.Win32Append(wfd.cFileName);
                pResult->m_e = CFusionDirectoryDifference::eExtraOrMissingFile;
                fSuccess = TRUE;
                goto Exit;
            }
            if ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                pResult->m_pstrDirectory->Win32Assign(dir1, dirSlash1Length);
                pResult->m_pstrDirectory->Win32Append(wfd.cFileName);
                pResult->m_pstrFile->Win32Assign(dir2, dirSlash2Length);
                pResult->m_pstrFile->Win32Append(wfd.cFileName);
                pResult->m_e = CFusionDirectoryDifference::eFileDirectoryMismatch;
                fSuccess = TRUE;
                goto Exit;
            }
            if (!dir2.Win32EnsureTrailingSlash())
                goto Exit;
            if (!FusionpCompareDirectoriesSizewiseRecursivelyHelper(
                pResult,
                dir1,
                dir2,
                wfd
                ))
            {
                goto Exit;
            }
            if (pResult->m_e != CFusionDirectoryDifference::eEqual)
            {
                fSuccess = TRUE;
                goto Exit;
            }
        }
        else
        {
            if (!pathAndSize.m_path.Win32Assign(wfd.cFileName))
                goto Exit;
            pathAndSize.m_size = FusionpFileSizeFromFindData(wfd);
            hr = dir1Entries.Append(pathAndSize);
            if (FAILED(hr))
            {
                FusionpSetLastErrorFromHRESULT(hr);
                goto Exit;
            }
        }
    } while (FindNextFileW(findFile, &wfd));
    if (GetLastError() != ERROR_NO_MORE_FILES)
    {
        goto Exit;
    }
    // dir1Entries cannot be sorted directly because it contains CStringBuffers.
    // first initialize the index to be an identity
    if (FAILED(hr = indirectDir1Entries.SetSize(dir1Entries.GetSize())))
    {
        FusionpSetLastErrorFromHRESULT(hr);
        goto Exit;
    }
    ULONG i;
    for (i = 0 ; i != dir1Entries.GetSize() ; ++i)
    {
        indirectDir1Entries[i] = &dir1Entries[i];
    }
    qsort(
        &*indirectDir1Entries.Begin(),
        indirectDir1Entries.GetSize(),
        sizeof(CIndirectDirEntries::ValueType),
        CFusionFilePathAndSize::QsortIndirectComparePath
        );

    if (!findFile.Close())
        goto Exit;

    dir2.Left(dirSlash2Length);

    if (!dir2.Win32Append(L"*"))
        goto Exit;

    if (!findFile.Create(dir2, &wfd))
        goto Exit;

    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
            continue;
        ++count2;
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            continue;

        if (!pathAndSize.m_path.Win32Assign(wfd.cFileName))
            goto Exit;
        pathAndSize.m_size = FusionpFileSizeFromFindData(wfd);

        ppFoundDirEntry = reinterpret_cast<CFusionFilePathAndSize**>(bsearch(
            &pPathAndSize,
            &*indirectDir1Entries.Begin(),
            indirectDir1Entries.GetSize(),
            sizeof(CIndirectDirEntries::ValueType),
            CFusionFilePathAndSize::QsortIndirectComparePath
            ));
        pFoundDirEntry = (ppFoundDirEntry != NULL) ? *ppFoundDirEntry : NULL;
        if (pFoundDirEntry == NULL)
        {
            pResult->m_str1.Win32Assign(dir2, dirSlash2Length);
            pResult->m_str1.Win32Append(wfd.cFileName);
            pResult->m_e = CFusionDirectoryDifference::eExtraOrMissingFile;
            fSuccess = TRUE;
            goto Exit;
        }

        if (pFoundDirEntry->m_size != pathAndSize.m_size)
        {
            pResult->m_str1.Win32Assign(dir1, dirSlash1Length);
            pResult->m_str1.Win32Append(wfd.cFileName);
            pResult->m_nMismatchedFileSize1 = pFoundDirEntry->m_size;

            pResult->m_str2.Win32Assign(dir2, dirSlash2Length);
            pResult->m_str2.Win32Append(wfd.cFileName);
            pResult->m_nMismatchedFileSize2 = pathAndSize.m_size;

            pResult->m_e = CFusionDirectoryDifference::eMismatchedFileSize;
            fSuccess = TRUE;
            goto Exit;
        }
    } while (FindNextFileW(findFile, &wfd));
    if (GetLastError() != ERROR_NO_MORE_FILES)
        goto Exit;
    if (count1 != count2)
    {
        pResult->m_str1.Win32Assign(dir1, dirSlash1Length - 1);
        pResult->m_str2.Win32Assign(dir2, dirSlash2Length - 1);
        pResult->m_nMismatchedFileCount1 = count1;
        pResult->m_nMismatchedFileCount2 = count2;
        pResult->m_e = CFusionDirectoryDifference::eMismatchedFileCount;

        fSuccess = TRUE;
        goto Exit;
    }
    if (!findFile.Close())
        goto Exit;

    pResult->m_e = CFusionDirectoryDifference::eEqual;
    fSuccess = TRUE;
Exit:
    // restore the paths for our caller
    dir1.Left(dirSlash1Length);
    dir2.Left(dirSlash2Length);
    return fSuccess;
}

/*-----------------------------------------------------------------------------
walk dirSlash1 and dirSlash2 recursively
for each file in either tree, see if it is in the other tree
at the same analogous position, and has the same size

if all files are present in both trees, no extra in either tree,
all with same size, return true

if any files are in one tree but not the other, or vice versa, or any
sizes mis match, return false

the algorithm short circuits
but it also does a depth first recursion
-----------------------------------------------------------------------------*/
BOOL
FusionpCompareDirectoriesSizewiseRecursively(
    CFusionDirectoryDifference*  pResult,
    const CStringBuffer& dir1,
    const CStringBuffer& dir2
    )
{
// only hog one stack frame with these large variables, rather than
// putting them in the recursive function
    WIN32_FIND_DATAW wfd = {0};
    CStringBuffer mutableDir1;
    CStringBuffer mutableDir2;
    pResult->m_e = pResult->eEqual;
    BOOL fSuccess = FALSE;

    if (!mutableDir1.Win32Assign(dir1))
        goto Exit;
    if (!mutableDir1.Win32EnsureTrailingSlash())
        goto Exit;
    if (!mutableDir2.Win32Assign(dir2))
        goto Exit;
    if (!mutableDir2.Win32EnsureTrailingSlash())
        goto Exit;

    // if either directory is a subdirectory of the other,
    // (or a subdir of a subdir, any generation descendant)
    // return an error; we could also interpret this as unequal,
    // since they can't be equal, or we could do the comparison
    // but not recurse on the subdir that is also a root;
    //
    // must do this check after the slashes are in place, because
    // "c:\food" is not a subdir of "c:\foo", but "c:\foo\d" is a subdir of "c:\foo\"
    // (quotes avoid backslash line continuation)
    if (_wcsnicmp(mutableDir1, mutableDir2, mutableDir1.Cch()) == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
    if (_wcsnicmp(mutableDir1, mutableDir2, mutableDir2.Cch()) == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    fSuccess = FusionpCompareDirectoriesSizewiseRecursivelyHelper(
        pResult,
        mutableDir1,
        mutableDir2,
        wfd
        );

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

static BOOL
IsStarOrStarDotStar(
    PCWSTR str
    )
{
    return (str[0] == '*'
        && (str[1] == 0 || (str[1] == '.' && str[2] == '*' && str[3] == 0)));
}

CDirWalk::ECallbackResult
CDirWalk::WalkHelper(
    )
{
    const PCWSTR* fileFilter = NULL;
    BOOL      fGotAll       = FALSE;
    BOOL      fThisIsAll    = FALSE;
    CFindFile hFind;
    SIZE_T directoryLength = m_strParent.Cch();
    ECallbackResult result = eKeepWalking;

    ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eBeginDirectory, this);
    if (result & (eError | eSuccess))
        goto Exit;

    if ((result & eStopWalkingFiles) == 0)
    {
        for (fileFilter = m_fileFiltersBegin ; fileFilter != m_fileFiltersEnd ; ++fileFilter)
        {
            //
            // FindFirstFile equates *.* with *, so we do too.
            //
            fThisIsAll = IsStarOrStarDotStar(*fileFilter);
            fGotAll = fGotAll || fThisIsAll;
            if (!m_strParent.Win32Append(L"\\"))
                goto Error;
            if (!m_strParent.Win32Append(*fileFilter))
                goto Error;
            hFind = FindFirstFileW(m_strParent, &m_fileData);
            m_strParent.Left(directoryLength);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                do
                {
                    if (FusionpIsDotOrDotDot(m_fileData.cFileName))
                        continue;

                    //
                    // we recurse on directories only if we are getting all of them
                    // otherwise we do them afterward
                    //
                    // the order directories are visited is therefore inconsistent, but
                    // most applications should be happy enough with the eEndDirectory
                    // notification (to implement rd /q/s)
                    //
                    if (m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if (fThisIsAll && (result & eStopWalkingDirectories) == 0)
                        {
                            if (!m_strParent.Win32Append("\\"))
                                goto Error;
                            if (!m_strParent.Win32Append(m_fileData.cFileName))
                                goto Error;

                            result |= WalkHelper();
                        }
                    }
                    else
                    {
                        if ((result & eStopWalkingFiles) == 0)
                        {
                            result |= m_callback(eFile, this);
                        }
                    }
                    m_strParent.Left(directoryLength);
                    if (result & (eError | eSuccess))
                        goto Exit;
                    if (fThisIsAll)
                    {
                        if ((result & eStopWalkingDirectories)
                            && (result & eStopWalkingFiles)
                            )
                        {
                            if (!hFind.Close())
                                goto Error;
                            goto StopWalking;
                        }
                    }
                    else
                    {
                        if (result & eStopWalkingFiles)
                        {
                            if (!hFind.Close())
                                goto Error;
                            goto StopWalking;
                        }
                    }
                } while(FindNextFileW(hFind, &m_fileData));
                if (GetLastError() != ERROR_NO_MORE_FILES)
                    goto Error;
                if (!hFind.Close())
                    goto Error;
            }
        }
    }
StopWalking:;
    //
    // make another pass with * to get all directories, if we haven't already
    //
    if (!fGotAll && (result & eStopWalkingDirectories) == 0)
    {
        if (!m_strParent.Win32Append("\\*"))
            goto Error;
        hFind = FindFirstFileW(m_strParent, &m_fileData);
        m_strParent.Left(directoryLength);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (FusionpIsDotOrDotDot(m_fileData.cFileName))
                    continue;

                if ((m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                    continue;
                if (!m_strParent.Win32Append("\\"))
                    goto Error;
                if (!m_strParent.Win32Append(m_fileData.cFileName))
                    goto Error;
                result |= WalkHelper();
                m_strParent.Left(directoryLength);

                if (result & (eError | eSuccess))
                    goto Exit;
                if (result & eStopWalkingDirectories)
                {
                    goto StopWalkingDirs;
                }
            } while(FindNextFileW(hFind, &m_fileData));
            if (GetLastError() != ERROR_NO_MORE_FILES)
                goto Error;
StopWalkingDirs:
            if (!hFind.Close())
                goto Error;
        }
    }
    ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eEndDirectory, this);
    if (result & (eError | eSuccess))
        goto Exit;

    result = eKeepWalking;
Exit:
    if ((result & eStopWalkingDeep) == 0)
    {
        result &= ~(eStopWalkingFiles | eStopWalkingDirectories);
    }
    if (result & eError)
    {
        result |= (eStopWalkingFiles | eStopWalkingDirectories | eStopWalkingDeep);
    }
    return result;
Error:
    result |= eError;
    goto Exit;
}

CDirWalk::CDirWalk(
    )
{
    const static PCWSTR defaultFileFilter[] =  { L"*" };

    m_fileFiltersBegin = defaultFileFilter;
    m_fileFiltersEnd = defaultFileFilter + NUMBER_OF(defaultFileFilter);
}

BOOL
CDirWalk::Walk(
    )
{
    BOOL fSuccess = FALSE;

    ECallbackResult result = WalkHelper();
    if (result & eError)
        goto Exit;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\ntdllwrap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
typedef struct tagMSG MSG, *LPMSG;
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#if 0
// #define NOGDICAPMASKS
// #define NOVIRTUALKEYCODES
// #define NOWINMESSAGES
// #define NOWINSTYLES
// #define NOSYSMETRICS
//#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
//#define NOCTLMGR
// #define NODRAWTEXT
// #define NOGDI
#define NOKERNEL
//#define NOUSER
//#define NONLS
//#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
// #define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOMCX
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#include "debmacro.h"
#include "util.h"

#if !FUSION_URT

int
FusionpCompareStrings(
    PCWSTR psz1,
    SSIZE_T cch1,
    PCWSTR psz2,
    SSIZE_T cch2,
    bool fCaseInsensitive
    )
{
    UNICODE_STRING s1, s2;

    if (cch1 >= 0)
    {
        s1.Buffer = const_cast<PWSTR>(psz1);
        s1.Length = static_cast<USHORT>(cch1 * sizeof(WCHAR));
        s1.MaximumLength = s1.Length;
    }
    else
        RtlInitUnicodeString(&s1, psz1);

    if (cch2 >= 0)
    {
        s2.Buffer = const_cast<PWSTR>(psz2);
        s2.Length = static_cast<USHORT>(cch2 * sizeof(WCHAR));
        s2.MaximumLength = s2.Length;
    }
    else
        RtlInitUnicodeString(&s2, psz2);

    return RtlCompareUnicodeString(&s1, &s2, fCaseInsensitive);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=utils

TARGETNAME=urtutils
TARGETTYPE=LIBRARY

SOURCES= \
    dbglog.cpp \
    disk.cpp \
    helpers.cpp \
    fstream.cpp \
    xmlns.cpp \
    serialst.cpp \
    utf8.cpp    \
    mstream.cpp

SOURCES_USED=sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\stdinc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
typedef struct tagMSG MSG, *LPMSG;
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#if 0
// #define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
// #define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
//#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
//#define NOCTLMGR
// #define NODRAWTEXT
// #define NOGDI
#define NOKERNEL
//#define NOUSER
//#define NONLS
//#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
// #define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOMCX
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "debmacro.h"
#include "fusionheap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\serialst.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

    05-Jul-1999 adriaanc
        nabbed for fusion
--*/

#include "debmacro.h"
#include <windows.h>
#include "serialst.h"



#if DBG

#if !defined(PRIVATE)
#define PRIVATE static
#endif

#if !defined(DEBUG_FUNCTION)
#define DEBUG_FUNCTION
#endif

#if !defined(DEBUG_PRINT)
#define DEBUG_PRINT(foo, bar, baz)
#endif

#if !defined(ENDEXCEPT)
#define ENDEXCEPT
#endif

#if !defined(DEBUG_BREAK)
#define DEBUG_BREAK(foo) DebugBreak()
#endif

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

#if 0
    // removed 1/7/2000 by mgrier - bad debug build
    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);
#endif // 0

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    InitializeCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    ASSERT(SerializedList != NULL);
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        ASSERT(IsListEmpty(&SerializedList->List));

    }
    DeleteCriticalSection(&SerializedList->Lock);
}

#if 0

DEBUG_FUNCTION
VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    None.

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->LockCount >= 0);

    EnterCriticalSection(&SerializedList->Lock);
    if (SerializedList->LockCount != 0) {

        ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());

    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    LeaveCriticalSection(&SerializedList->Lock);
}


#endif

DEBUG_FUNCTION
VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    __try {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertHeadList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;
    
        ASSERT(SerializedList->ElementCount > 0);
    }
    __finally {
        UnlockSerializedList(SerializedList);
    }
}


DEBUG_FUNCTION
VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    __try {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, FALSE);
        }
        InsertTailList(&SerializedList->List, Entry);
        ++SerializedList->ElementCount;
    
        ASSERT(SerializedList->ElementCount > 0);
    }
    __finally {
        UnlockSerializedList(SerializedList);
    }
}


VOID
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    None.

--*/

{
    ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    LockSerializedList(SerializedList);
    __try {
        if (fCheckEntryOnList) {
            CheckEntryOnList(&SerializedList->List, Entry, TRUE);
        }
    
        ASSERT(SerializedList->ElementCount > 0);
    
        RemoveEntryList(Entry);
        --SerializedList->ElementCount;
        Entry->Flink = NULL;
        Entry->Blink = NULL;
    }
    __finally {
        UnlockSerializedList(SerializedList);
    }
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    BOOL empty;

    LockSerializedList(SerializedList);

    __try {
        ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    
    
        if (IsListEmpty(&SerializedList->List)) {
    
            ASSERT(SerializedList->ElementCount == 0);
    
            empty = TRUE;
        } else {
    
            ASSERT(SerializedList->ElementCount != 0);
    
            empty = FALSE;
        }
    }
    __finally {
        UnlockSerializedList(SerializedList);
    }

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    BOOL result;

    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    
    LockSerializedList(SerializedList);

    __try {
        __try {
            result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
    
            DEBUG_PRINT(SERIALST,
                        FATAL,
                        ("List @ %#x (%d elements) is bad\n",
                        SerializedList,
                        SerializedList->ElementCount
                        ));
    
            result = FALSE;
        }
        ENDEXCEPT
    }
    __finally {
        UnlockSerializedList(SerializedList);
    }

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#endif // DBG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        __try {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)HeadOfSerializedList(SerializedList);
                RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
            } else {
                entry = NULL;
            }
        }
        __finally {
            UnlockSerializedList(SerializedList);
        }
    } else {
        entry = NULL;
    }
    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        __try {
            if (!IsSerializedListEmpty(SerializedList)) {
                entry = (LPVOID)TailOfSerializedList(SerializedList);
                RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
            } else {
                entry = NULL;
            }
        }
        __finally {
            UnlockSerializedList(SerializedList);
        }
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
//    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        __try {
            if (!IsSerializedListEmpty(SerializedList)) {
                for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                    entry != (PLIST_ENTRY)SlSelf(SerializedList);
                    entry = entry->Flink) {
    
                    if (entry == Entry) {
                        onList = TRUE;
                        break;
                    }
                }
            }
        }
        __finally {
            UnlockSerializedList(SerializedList);
        }
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\tablesizer.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "tablesizer.h"

#include "debmacro.h"
#include "fusionheap.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif

//
//  Helper table of likely primes.  Not all primes need be represented; these are candidate table
//  sizes to try to see how much wastage we get with the given table size.  We'll use a USHORT for
//  the types of the sizes; a table of more than 65535 items seems unlikely, so there's not much
//  point wasting the space for all the interesting small primes.
//

static const USHORT s_rgPrimes[] =
{
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
};

#define LARGEST_PRIME (s_rgPrimes[NUMBER_OF(s_rgPrimes) - 1])

CHashTableSizer::CHashTableSizer() :
    m_cPseudokeys(0),
    m_nHistogramTableSize(0),
    m_prgPseudokeys(NULL),
    m_prgHistogramTable(NULL)
{
}

CHashTableSizer::~CHashTableSizer()
{
    delete []m_prgPseudokeys;
    delete []m_prgHistogramTable;
}

BOOL CHashTableSizer::Initialize(SIZE_T cPseudokeys)
{
    BOOL fSuccess = FALSE;
    SIZE_T *prgHistogramTable = NULL;
    ULONG *prgPseudokeys = NULL;

    ASSERT(m_cPseudokeys == 0);
    ASSERT(m_nHistogramTableSize == 0);
    ASSERT(m_prgPseudokeys == NULL);
    ASSERT(m_prgHistogramTable == NULL);

    if ((m_cPseudokeys != 0) ||
        (m_nHistogramTableSize != 0) ||
        (m_prgPseudokeys != NULL) ||
        (m_prgHistogramTable))
    {
        ::SetLastError(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    prgHistogramTable = NEW(SIZE_T[LARGEST_PRIME]);
    if (prgHistogramTable == NULL)
        goto Exit;

    prgPseudokeys = NEW(ULONG[cPseudokeys]);
    if (prgPseudokeys == NULL)
        goto Exit;

    m_cPseudokeys = cPseudokeys;
    m_nHistogramTableSize = LARGEST_PRIME;
    m_iCurrentPseudokey = 0;
    m_prgPseudokeys = prgPseudokeys;
    prgPseudokeys = NULL;
    m_prgHistogramTable = prgHistogramTable;
    prgHistogramTable = NULL;

    fSuccess = TRUE;
Exit:
    delete []prgHistogramTable;
    delete []prgPseudokeys;

    return fSuccess;
}

VOID CHashTableSizer::AddSample(ULONG ulPseudokey)
{
    ASSERT(m_iCurrentPseudokey < m_cPseudokeys);

    if (m_iCurrentPseudokey < m_cPseudokeys)
        m_prgPseudokeys[m_iCurrentPseudokey++] = ulPseudokey;
}

BOOL CHashTableSizer::ComputeOptimalTableSize(
    DWORD dwFlags,
    SIZE_T &rnTableSize
    )
{
    BOOL fSuccess = FALSE;

    if (dwFlags != 0)
    {
        ::SetLastError(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    rnTableSize = 7;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\mstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "mstream.h"

CMemoryStream::CMemoryStream()
: _cRef(1) 
, _lpStart(NULL)
, _lpCurrent(NULL)
, _cbSize(0)
, _bReadOnly(TRUE)
{
}

CMemoryStream::~CMemoryStream()
{
}

HRESULT CMemoryStream::Init(LPVOID lpStart, ULONG cbSize, BOOL bReadOnly)
{
    // NULL pointer and zero-sized memory block do not make sense
	if (!lpStart||!cbSize)
		return E_INVALIDARG;

	_lpStart   = lpStart;
	_lpCurrent = _lpStart;
	_cbSize    = cbSize;
	_bReadOnly = bReadOnly;

	return S_OK;
}

HRESULT CMemoryStream::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream)) {
        *ppv = static_cast<IStream *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CMemoryStream::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CMemoryStream::Release()
{
    ULONG ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT CMemoryStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    LONG    bytesLeft = 0;
    ULONG   cbRead = 0;

    if (!pv)
        return E_INVALIDARG;
	
    if (pcbRead != NULL) {
        *pcbRead = 0;
    }

    ASSERT(_lpStart&&_lpCurrent);
	
	bytesLeft = (LPBYTE)_lpStart + _cbSize - (LPBYTE)_lpCurrent;
    ASSERT(bytesLeft >= 0);
    
    cbRead = (ULONG)bytesLeft;
	if (cbRead == 0) {
        return S_FALSE;
    }

    if (cbRead > cb)
		cbRead = cb;

	memcpy(pv, _lpCurrent, cbRead);
	_lpCurrent = (LPBYTE)_lpCurrent + cbRead;

    if (pcbRead != NULL) {
        *pcbRead = cbRead;
    }

    return hr;
}

HRESULT CMemoryStream::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::Revert()
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

HRESULT CMemoryStream::Clone(IStream **ppIStream)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\uuid\fuspriv_uuid.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <fuspriv_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\uuid\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Michael Grier (copied from Danpo Zhang's)

!ENDIF

MSC_WARNING_LEVEL=/W4 /WX

TARGETNAME=fusuuid
TARGETTYPE=LIBRARY

INCLUDES= $(FUSION_PATH)\idl\$(O)

!include $(CORBASE)\src\fusion\fusion.inc
SOURCES_USED=$(SOURCES_USED) $(CORBASE)\src\fusion\fusion.inc

# prevent system headers from being included.  They are not needed just to
# process a bunch of DEFINE_GUIDs anyhow.  Excluding them generates a much
# smaller library too.
#
C_DEFINES=$(C_DEFINES) /D_MIDL_USE_GUIDDEF_\
    /D__RPCNDR_H__ /D__RPC_H__ /DRPC_NO_WINDOWS_H /DCOM_NO_WINDOWS_H\
    /DGUID_DEFS_ONLY

SOURCES= \
	fusion_uuid.c \
	fuspriv_uuid.c

SOURCES_USED=sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\uuid\fusion_uuid.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <fusion_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\xmlns.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "xmlns.h"
#include "helpers.h"
#include "util.h"

//
// CNamespaceMapNode
//

CNamespaceMapNode::CNamespaceMapNode()
: _pwzPrefix(NULL)
, _pwzURI(NULL)
, _dwDepth(0)
{
}

CNamespaceMapNode::~CNamespaceMapNode()
{
    SAFEDELETEARRAY(_pwzPrefix);
    SAFEDELETEARRAY(_pwzURI);
}

HRESULT CNamespaceMapNode::Create(LPCWSTR pwzPrefix, LPCWSTR pwzURI,
                                  DWORD dwCurDepth, CNamespaceMapNode **ppMapNode)
{
    HRESULT                                      hr = S_OK;
    CNamespaceMapNode                           *pMapNode = NULL;

    if (!pwzURI || !ppMapNode) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppMapNode = NULL;

    pMapNode = NEW(CNamespaceMapNode);
    if (!pMapNode) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (pwzPrefix) {
        pMapNode->_pwzPrefix = WSTRDupDynamic(pwzPrefix);
        if (!pMapNode->_pwzPrefix) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    pMapNode->_pwzURI = WSTRDupDynamic(pwzURI);
    if (!pMapNode->_pwzURI) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pMapNode->_dwDepth = dwCurDepth;

    *ppMapNode = pMapNode;

Exit:
    if (FAILED(hr)) {
        SAFEDELETE(pMapNode);
    }

    return hr;
}

//
// CNamespaceManager
//

CNamespaceManager::CNamespaceManager()
: _dwCurDepth(0)
, _hrResult(S_OK)
{
}

CNamespaceManager::~CNamespaceManager()
{
    LISTNODE                                      pos;
    LISTNODE                                      posStack;
    CNamespaceMapNode                            *pMapNode;
    NamespaceStack                               *pStack;
    int                                           i;

    // Default namespace stack cleanup

    pos = _stackDefNamespace.GetHeadPosition();
    while (pos) {
        // Should be empty, if successful

        ASSERT(FAILED(_hrResult));

        pMapNode = _stackDefNamespace.GetNext(pos);
        ASSERT(pMapNode);

        SAFEDELETE(pMapNode);
    }

    _stackDefNamespace.RemoveAll();

    // Prefix stack clean up

    for (i = 0; i < NAMESPACE_HASH_TABLE_SIZE; i++) {
        pos = _listMap[i].GetHeadPosition();

        // Table should be empty, if successful

        while (pos) {
            ASSERT(FAILED(_hrResult));

            pStack = _listMap[i].GetNext(pos);
            ASSERT(pStack);

            // Clean up the stack entries
            
            posStack = pStack->GetHeadPosition();
            ASSERT(posStack);

            while (posStack) {
                // We didn't get cleaned up properly!
                
                pMapNode = pStack->GetNext(posStack);
                ASSERT(pMapNode);

                SAFEDELETE(pMapNode);
            }

            pStack->RemoveAll();

            // Clean up the stack

            SAFEDELETE(pStack)
        }
    }
}

HRESULT CNamespaceManager::OnCreateNode(IXMLNodeSource __RPC_FAR *pSource,
                                        PVOID pNodeParent, USHORT cNumRecs,
                                        XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      pwzURI = NULL;
    CNamespaceMapNode                          *pMapNode = NULL;
    LPWSTR                                      pwzPrefix = NULL;
    BOOL                                        bFound;
    DWORD                                       dwHash;
    LISTNODE                                    pos;
    LISTNODE                                    posStack;
    NamespaceStack                             *pStack = NULL;
    NamespaceStack                             *pStackCur = NULL;
    CNamespaceMapNode                          *pMapNodeCur = NULL;
    int                                         iLen;
    USHORT                                      idx = 1;

    if (aNodeInfo[0]->dwType == XML_ELEMENT) {
        _dwCurDepth++;
    }

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            if (aNodeInfo[idx]->ulLen == XML_NAMESPACE_TAG_LEN &&
                !FusionCompareStringN(aNodeInfo[idx]->pwcText, XML_NAMESPACE_TAG, XML_NAMESPACE_TAG_LEN)) {

                // This is in the default namespace

                hr = ::ExtractXMLAttribute(&pwzURI, aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    goto Exit;
                }

                hr = CNamespaceMapNode::Create(NULL, (pwzURI) ? (pwzURI) : (L""), _dwCurDepth, &pMapNode);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzURI);
                    goto Exit;
                }

                _stackDefNamespace.AddHead(pMapNode);

                SAFEDELETEARRAY(pwzURI);
                pMapNode = NULL;

                continue;
            }
            else if (aNodeInfo[idx]->ulLen >= XML_NAMESPACE_TAG_LEN &&
                     !FusionCompareStringN(aNodeInfo[idx]->pwcText, XML_NAMESPACE_PREFIX_TAG, XML_NAMESPACE_PREFIX_TAG_LEN)) {

                // This is a namespace prefix

                iLen = aNodeInfo[idx]->ulLen - XML_NAMESPACE_PREFIX_TAG_LEN;
                ASSERT(iLen > 0);

                pwzPrefix = NEW(WCHAR[iLen + 1]);
                if (!pwzPrefix) {
                    hr = E_OUTOFMEMORY;
                    SAFEDELETEARRAY(pwzURI);
                    goto Exit;
                }

                StrCpyN(pwzPrefix, aNodeInfo[idx]->pwcText + XML_NAMESPACE_PREFIX_TAG_LEN, iLen + 1);
                
                hr = ::ExtractXMLAttribute(&pwzURI, aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    goto Exit;
                }

                if (!pwzURI || !lstrlenW(pwzURI)) {
                    // It is illegal to have the form:
                    //    <tag xmlns:foo="">
                    // Error out in this case

                    hr = E_UNEXPECTED;
                    goto Exit;
                }

                hr = CNamespaceMapNode::Create(pwzPrefix, pwzURI, _dwCurDepth, &pMapNode);
                if (FAILED(hr)) {
                    goto Exit;
                }

                dwHash = HashString(pwzPrefix, NAMESPACE_HASH_TABLE_SIZE);

                pos = _listMap[dwHash].GetHeadPosition();
                if (!pos) {
                    // No entries at this hash table location. Make a stack
                    // at this location, and add the node.

                    pStack = NEW(NamespaceStack);
                    if (!pStack) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    pStack->AddHead(pMapNode);

                    _listMap[dwHash].AddHead(pStack);
                }
                else {
                    // Each node here represents a hash collision.
                    // Every node is a stack for a particular prefix. Find
                    // the prefix we want, and add to the stack, or add
                    // a new node.

                    bFound = FALSE;
                    while (pos) {
                        // Get the stack

                        pStackCur = _listMap[dwHash].GetNext(pos);
                        ASSERT(pStackCur);

                        // Get the first entry in the stack

                        posStack = pStackCur->GetHeadPosition();
                        ASSERT(posStack);
                        if (!posStack) {
                            continue;
                        }

                        // Get the head of the stack

                        pMapNodeCur = pStackCur->GetAt(posStack);
                        ASSERT(pMapNodeCur);

                        // See if the node at the head of the stack has the
                        // prefix we're interested in

                        if (!FusionCompareString(pMapNodeCur->_pwzPrefix, pwzPrefix)) {
                            // We found the right stack. Push node onto stack.

                            pStackCur->AddHead(pMapNode);
                            bFound = TRUE;
                            break;
                        }
                    }

                    if (!bFound) {
                        // We had a hash collision on the prefix,
                        // although the stack for this prefix hasn't been
                        // created yet.

                        pStack = NEW(NamespaceStack);
                        if (!pStack) {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }
    
                        pStack->AddHead(pMapNode);

                        _listMap[dwHash].AddHead(pStack);
                    }
                }

                SAFEDELETEARRAY(pwzPrefix);
                SAFEDELETEARRAY(pwzURI);

                pMapNode = NULL;
                continue;
            }
            else {
                idx++;
            }
        }
        else {
            idx++;
        }
    }

Exit:
    SAFEDELETEARRAY(pwzPrefix);
    SAFEDELETEARRAY(pwzURI);

    if (FAILED(hr)) {
        _hrResult = hr;
    }

    return hr;
}

HRESULT CNamespaceManager::OnEndChildren()
{
    HRESULT                                          hr = S_OK;
    LISTNODE                                         pos;
    LISTNODE                                         curPos;
    LISTNODE                                         posStack;
    CNamespaceMapNode                               *pMapNode;
    NamespaceStack                                  *pStack;
    int                                              i;
    
    // Pop stack for default namespace

    pos = _stackDefNamespace.GetHeadPosition();
    if (pos) {
        pMapNode = _stackDefNamespace.GetAt(pos);
        ASSERT(pMapNode);

        if (pMapNode->_dwDepth == _dwCurDepth) {
            // Match found. Pop the stack.

            _stackDefNamespace.RemoveAt(pos);
            SAFEDELETE(pMapNode);
        }
    }

    // Pop stack for namespace prefixes

    // Walk each entry in the hash table.

    for (i = 0; i < NAMESPACE_HASH_TABLE_SIZE; i++) {
        pos = _listMap[i].GetHeadPosition();

        while (pos) {
            // For each entry in the hash table, look at the list of
            // stacks.

            curPos = pos;
            pStack = _listMap[i].GetNext(pos);
            ASSERT(pStack);

            // See if the head of the stack is at the depth we're unwinding.

            posStack = pStack->GetHeadPosition();
            if (posStack) {
                pMapNode = pStack->GetAt(posStack);
                ASSERT(pMapNode);
    
                if (pMapNode->_dwDepth == _dwCurDepth) {
                    pStack->RemoveAt(posStack);
    
                    SAFEDELETE(pMapNode);
                }

                if (!pStack->GetHeadPosition()) {
                    SAFEDELETE(pStack);
                    _listMap[i].RemoveAt(curPos);
                }
            }
        }
    }

    // Decrease depth
    
    _dwCurDepth--;

    return hr;
}

HRESULT CNamespaceManager::Map(LPCWSTR pwzAttribute, LPWSTR *ppwzQualified,
                               DWORD dwFlags)
{
    HRESULT                                       hr = S_OK;
    LPWSTR                                        pwzPrefix = NULL;
    LPWSTR                                        pwzCur;
    DWORD                                         dwLen;
    DWORD                                         dwLenURI;
    DWORD                                         dwHash;
    LISTNODE                                      pos;
    LISTNODE                                      posStack;
    NamespaceStack                               *pStack;
    CNamespaceMapNode                            *pMapNode;

    if (!pwzAttribute || !ppwzQualified) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppwzQualified = NULL;

    pwzPrefix = WSTRDupDynamic(pwzAttribute);
    if (!pwzPrefix) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // See if there is a colon in the name

    pwzCur = pwzPrefix;
    while (*pwzCur) {
        if (*pwzCur == L':') {
            break;
        }

        pwzCur++;
    }

    if (!*pwzCur) {
        // No colon in name. Apply default name space, if applicable.

        if (dwFlags & XMLNS_FLAGS_APPLY_DEFAULT_NAMESPACE) {
            pos = _stackDefNamespace.GetHeadPosition();
            if (pos) {
                pMapNode = _stackDefNamespace.GetAt(pos);
                ASSERT(pMapNode && pMapNode->_pwzURI);
    
                dwLenURI = lstrlenW(pMapNode->_pwzURI);
                if (!dwLenURI) {
                    *ppwzQualified = WSTRDupDynamic(pwzAttribute);
                    if (!*ppwzQualified) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                }
                else {
                    dwLen = dwLenURI + lstrlenW(pwzAttribute) + 2;
        
                    *ppwzQualified = NEW(WCHAR[dwLen]);
                    if (!*ppwzQualified) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
        
                    wnsprintfW(*ppwzQualified, dwLen, L"%ws^%ws", pMapNode->_pwzURI, pwzAttribute);
                }
            }
            else {
                // No default namespace
    
                *ppwzQualified = WSTRDupDynamic(pwzAttribute);
                if (!*ppwzQualified) {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }
        }
        else {
            *ppwzQualified = WSTRDupDynamic(pwzAttribute);
            if (!*ppwzQualified) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
    }
    else {
        // Colon found in name. Apply mapping

        // Anchor NULL char so pwzPrefix points to the prefix.
        *pwzCur = L'\0';

        dwHash = HashString(pwzPrefix, NAMESPACE_HASH_TABLE_SIZE);

        pos = _listMap[dwHash].GetHeadPosition();
        if (!pos) {
            // Miss in hash table. Thus, we do not have a prefix.

            *ppwzQualified = WSTRDupDynamic(pwzAttribute);
            if (!*ppwzQualified) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
        else {
            // Hit in the hash table. Find the right stack, if any.

            while (pos) {
                pStack = _listMap[dwHash].GetNext(pos);
                ASSERT(pStack);

                posStack = pStack->GetHeadPosition();
                ASSERT(posStack);

                pMapNode = pStack->GetAt(posStack);
                ASSERT(pMapNode);

                if (!FusionCompareString(pMapNode->_pwzPrefix, pwzPrefix)) {
                    // Hit found. Apply the mapping.
                    
                    ASSERT(pMapNode->_pwzURI);

                    dwLen = lstrlenW(pMapNode->_pwzURI) + lstrlenW(pwzAttribute) + 2;

                    *ppwzQualified = NEW(WCHAR[dwLen]);
                    if (!*ppwzQualified) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    wnsprintfW(*ppwzQualified, dwLen, L"%ws^%ws", pMapNode->_pwzURI, pwzCur + 1);
                    goto Exit;
                }
            }

            // We collided in the hash table, but didn't find a hit.
            // This must be an error because we hit something of the form
            // <a f:z="foo"> where "f" was not previously defined!

            hr = E_UNEXPECTED;
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(pwzPrefix);

    if (FAILED(hr)) {
        _hrResult = hr;
    }

    return hr;
}


void CNamespaceManager::Error(HRESULT hrError)
{
    _hrResult = hrError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\gcdump\gcdump.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                                  GCDump.cpp
 *
 * Defines functions to display the GCInfo as defined by the GC-encoding 
 * spec. The GC information may be either dynamically created by a 
 * Just-In-Time compiler conforming to the standard code-manager spec,
 * or may be persisted by a managed native code compiler conforming
 * to the standard code-manager spec.
 */

#include "GCDump.h"
#include "Utilcode.h"           // For _ASSERTE()

/*****************************************************************************/



GCDump::GCDump(bool encBytes, unsigned maxEncBytes, bool dumpCodeOffs)
  : fDumpEncBytes   (encBytes    ), 
    cMaxEncBytes    (maxEncBytes ), 
    fDumpCodeOffsets(dumpCodeOffs)
{
	// By default, use the standard printf function to dump 
	GCDump::gcPrintf = (printfFtn) ::printf;
}

/*****************************************************************************
 *
 *  Display the byte encodings for the given range of the GC tables.
 */

const BYTE   *  GCDump::DumpEncoding(const BYTE *table, int cDumpBytes)
{
    _ASSERTE(cDumpBytes >= 0);

    if  (fDumpEncBytes)
    {
        const BYTE  *   pCurPos;
        unsigned        count;
        int             cBytesLeft;


        for (count = cMaxEncBytes, cBytesLeft = cDumpBytes, pCurPos = table; 
             count > 0; 
             count--, pCurPos++, cBytesLeft--)
        {
            if  (cBytesLeft > 0)
            {
                if  (cBytesLeft > 1 && count == 1)
                    gcPrintf("...");
                else
                    gcPrintf("%02X ", *pCurPos);
            }
            else
                gcPrintf("   ");
        }

        gcPrintf("| ");
    }

    return  table + cDumpBytes;
}

/*****************************************************************************/

void                GCDump::DumpOffset(unsigned o)
{
    gcPrintf("%04X", o);
}

void                GCDump::DumpOffsetEx(unsigned o)
{
    if (fDumpCodeOffsets) 
        DumpOffset(o);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\gcdump\alpha\gcdumpalpha.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                             GCDumpAlpha.cpp
 */

/*****************************************************************************/
#ifdef _ALPHA_
/*****************************************************************************/

#include "GCDump.h"
#include "Utilcode.h"           // For _ASSERTE()

/*****************************************************************************/

unsigned            GCDump::DumpInfoHdr (const BYTE *   table,
                                         InfoHdr*       header,
                                         unsigned *     methodSize,
                                         bool           verifyGCTables)
{
    _ASSERTE(!"Dumping of GC info for Alpha is NYI");
    return 0;
}

/*****************************************************************************/

unsigned            GCDump::DumpGCTable(const BYTE *   table,
                                        const InfoHdr& header,
                                        unsigned       methodSize,
                                        bool           verifyGCTables)
{
    _ASSERTE(!"Dumping of GC info for Alpha is NYI");
    return 0;
}


/*****************************************************************************/

void                GCDump::DumpPtrsInFrame(const void *infoBlock,
                                            const void *codeBlock,
                                            unsigned    offs,
                                            bool        verifyGCTables)
{
    _ASSERTE(!"Dumping of GC info for Alpha is NYI");
}

/*****************************************************************************/
#endif // _ALPHA_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\utf8.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    utf8.c

Abstract:

    Domain Name System (DNS) Library

    UTF8 to\from unicode and ANSI conversions

    The UTF8\unicode routines are similar to the generic ones floating
    around the NT group, but a heck of a lot cleaner and more robust,
    including catching the invalid UTF8 string case on the utf8 to unicode
    conversion.

    The UTF8\ANSI routines are optimized for the 99% case where all the
    characters are <128 and no conversions is actually required.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "fusionp.h"


//
//  Macros to simplify UTF8 conversions
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8

#define BIT7(ch)        ((ch) & 0x80)
#define BIT6(ch)        ((ch) & 0x40)
#define BIT5(ch)        ((ch) & 0x20)
#define BIT4(ch)        ((ch) & 0x10)

#define LOW6BITS(ch)    ((ch) & 0x3f)
#define LOW5BITS(ch)    ((ch) & 0x1f)
#define LOW4BITS(ch)    ((ch) & 0x0f)

#define HIGHBYTE(wch)   ((wch) & 0xff00)


DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    )
/*++

Routine Description:

    Convert unicode characters to UTF8.

Arguments:

    pwUnicode   -- ptr to start of unicode buffer

    cchUnicode  -- length of unicode buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    WCHAR   wch;                // current unicode character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string


    //
    //  loop converting unicode chars until run out or error
    //

    while ( cchUnicode-- )
    {
        wch = *pwUnicode++;

        //
        //  ASCII character (7 bits or less) -- converts to directly
        //

        if ( wch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)wch;
            }
        }

        //
        //  wide character less than 0x07ff (11bits) converts to two bytes
        //      - upper 5 bits in first byte
        //      - lower 6 bits in secondar byte
        //

        else if ( wch <= UTF8_2_MAX )
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | wch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)wch );
            }
        }

        //
        //  wide character (non-zero in top 5 bits) converts to three bytes
        //      - top 4 bits in first byte
        //      - middle 6 bits in second byte
        //      - low 6 bits in third byte
        //

        else
        {
            lengthUtf8 += 3;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_3 | (wch >> 12);
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch >> 6 );
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult )
    {
        *pchResult = 0;
    }
    return ( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );
}



DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    )
/*++

Routine Description:

    Convert UTF8 characters to unicode.

Arguments:

    pwResult    -- ptr to start of result buffer for unicode chars

    cwResult    -- length of result buffer

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of unicode characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    CHAR    ch;                     // current UTF8 character
    WCHAR   wch;                    // current unicode character
    DWORD   trailCount = 0;         // count of UTF8 trail bytes to follow
    DWORD   lengthUnicode = 0;      // length of unicode result string


    //
    //  loop converting UTF8 chars until run out or error
    //

    while ( cchUtf8-- )
    {
        ch = *pchUtf8++;

        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthUnicode++;
            if ( pwResult )
            {
                if ( lengthUnicode >= cwResult )
                {
                    goto OutOfBuffer;
                }
                *pwResult++ = (WCHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift unicode character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to unicode string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }
            wch <<= 6;
            wch |= LOW6BITS( ch );

            if ( --trailCount == 0 )
            {
                lengthUnicode++;
                if ( pwResult )
                {
                    if ( lengthUnicode >= cwResult )
                    {
                        goto OutOfBuffer;
                    }
                    *pwResult++ = wch;
                }
            }
            continue;
        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  invalid UTF8 byte (1111xxxx)

            else
            {
                ASSERT( (ch & 0xf0) == 0xf0 );
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return the number of Unicode characters written.
    //

    if ( pwResult )
    {
        *pwResult = 0;
    }
    return ( lengthUnicode );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



//
//  Convert between UTF8 and ANSI
//  Optimize for the 99% case and do no copy
//

DWORD
_fastcall
Dns_AnsiToUtf8(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    )
/*++

Routine Description:

    Convert ANSI characters to UTF8.

Arguments:

    pchAnsi   -- ptr to start of ansi buffer

    cchAnsi  -- length of ansi buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    CHAR    ch;                // current ansi character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string

    //
    //  loop through ANSI characters
    //

    while ( cchAnsi-- )
    {
        ch = *pchAnsi++;

        //
        //  ASCII character (7 bits) converts one to one
        //

        if ( ch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)ch;
            }
        }

        //
        //  ANSI > 127 converts to two UTF8 bytes
        //      - upper 2 bits in first byte
        //      - lower 6 bits in second byte
        //

        else
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | ch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)ch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult )
    {
        *pchResult = 0;
    }
    return ( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );
}


DWORD
_fastcall
Dns_Utf8ToAnsi(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    )
/*++

Routine Description:

    Convert UTF8 characters to ANSI.

Arguments:

    pchResult   -- ptr to start of result buffer for ansi chars

    cchResult   -- length of result buffer

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of ansi characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    CHAR    ch;                 // current UTF8 character
    WCHAR   wch;                // current unicode character being built
    DWORD   trailCount = 0;     // count of UTF8 trail bytes to follow
    DWORD   lengthAnsi = 0;     // length of ansi result string

    //
    //  loop converting UTF8 chars until run out or error
    //

    while ( cchUtf8-- )
    {
        ch = *pchUtf8;

        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthAnsi++;
            if ( pchResult )
            {
                if ( lengthAnsi >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift ansi character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to ansi string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }
            wch <<= 6;
            wch |= LOW6BITS( ch );

            if ( --trailCount == 0 )
            {
                lengthAnsi++;
                if ( pchResult )
                {
                    if ( lengthAnsi >= cchResult )
                    {
                        goto OutOfBuffer;
                    }
                    if ( HIGHBYTE(wch) )
                    {
                        goto InvalidAnsi;
                    }
                    *pchResult++ = (CHAR)wch;
                }
            }
            continue;
        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  invalid UTF8 byte (1111xxxx)

            else
            {
                ASSERT( (ch & 0xf0) == 0xf0 );
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return ANSI character count
    //

    if ( pchResult )
    {
        *pchResult = 0;
    }
    return ( lengthAnsi );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );

InvalidAnsi:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



DWORD
_fastcall
Dns_LengthOfUtf8ForAnsi(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi
    )
/*++

Routine Description:

    Check if ANSI string is already UTF8.
    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pchAnsi   -- ptr to start of ansi buffer

    cchAnsi  -- length of ansi buffer

Return Value:

    0 if ANSI is completely UTF8
    Otherwise count of UTF8 characters in converted string.

--*/
{
    DWORD   lengthUtf8 = 0;         // length of UTF8 result string
    BOOL    foundNonUtf8 = FALSE;   // flag indicating presence of non-UTF8 character

    //
    //  loop through ANSI characters
    //

    while ( cchAnsi-- )
    {
        if ( *pchAnsi++ < 0x80 )
        {
            lengthUtf8++;
            continue;
        }

        //
        //  ANSI > 127 converts to two UTF8 bytes
        //      - upper 2 bits in first byte
        //      - lower 6 bits in second byte
        //

        else
        {
            lengthUtf8 += 2;
            foundNonUtf8;
        }
    }

    //  no non-UTF8 characters

    if ( !foundNonUtf8 )
    {
        return( 0 );
    }

    //  non-UTF8 characters, return required buffer length

    return ( lengthUtf8 );
}


BOOL
_fastcall
Dns_IsStringAscii(
    IN      LPSTR       pszString
    )
/*++

Routine Description:

    Check if string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pszString -- ANSI or UTF8 string to check for ASCIIhood

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    register UCHAR   ch;

    //
    //  loop through until hit non-ASCII character
    //

    while ( ch = (UCHAR) *pszString++ )
    {
        if ( ch < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}


BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi
    )
/*++

Routine Description:

    Check if ANSI (or UTF8) string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pchAnsi   -- ptr to start of ansi buffer

    cchAnsi  -- length of ansi buffer

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    //
    //  loop through until hit non-ASCII character
    //

    while ( cchAnsi-- )
    {
        if ( *pchAnsi++ < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}



DWORD
Dns_ValidateUtf8Byte(
    IN      BYTE    chUtf8,
    IN OUT  PDWORD  pdwTrailCount
    )
/*++

Routine Description:

    Verifies that byte is valid UTF8 byte.

Arguments:

Return Value:

    ERROR_SUCCESS -- if valid UTF8 given trail count
    ERROR_INVALID_DATA -- if invalid

--*/
{
    DWORD   trailCount = *pdwTrailCount;

    //
    //  if ASCII byte, only requirement is no trail count
    //

    if ( chUtf8 < 0x80 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_SUCCESS );
        }
        return( ERROR_INVALID_DATA );
    }

    //
    //  trail byte
    //      - must be in multi-byte set
    //

    if ( BIT6(chUtf8) == 0 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        --trailCount;
    }

    //
    //  multi-byte lead byte
    //      - must NOT be in existing multi-byte set
    //      - verify valid lead byte

    else
    {
        if ( trailCount != 0 )
        {
            return( ERROR_INVALID_DATA );
        }

        //  first of two bytes (110xxxxx)

        if ( BIT5(chUtf8) == 0 )
        {
            trailCount = 1;
        }

        //  first of three bytes (1110xxxx)

        else if ( BIT4(chUtf8) == 0 )
        {
            trailCount = 2;
        }

        else    // invalid lead byte (1111xxxx)
        {
            return( ERROR_INVALID_DATA );
        }
    }

    //  reset caller's trail count

    *pdwTrailCount = trailCount;
    return( ERROR_SUCCESS );
}

//
//  End utf8.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\trace.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusiontrace.h"
// #include "shlwapi.h"
#include <stdio.h>
#include "fusionheap.h"

#if FUSION_TRACING_ENABLED

#include "debmacro.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif

#if FUSION_TRACING_ENABLED
DWORD g_FusionTraceContextTLSIndex = (DWORD) -1;
#endif

static HANDLE s_hFile; // trace file handle

PTRACECONTEXTSTACK
FusionpGetTraceContextStack()
{
    const DWORD dwLastError = ::GetLastError();
    PTRACECONTEXTSTACK ptcs = (PTRACECONTEXTSTACK) ::TlsGetValue(g_FusionTraceContextTLSIndex);
    if (ptcs == NULL)
    {
        // If you hit this assertion, it's because nobody's initialied the g_FusionTraceContextTLSIndex global
        // variable with TlsAlloc().  Check either your main() function if this code is running in an executable
        // or DllMain()'s DLL_PROCESS_ATTACH if this code is in a DLL.
        ASSERT(::GetLastError() == NO_ERROR);

        FUSION_HEAP_DISABLE_LEAK_TRACKING();

        ptcs = NEW(TRACECONTEXTSTACK);

        FUSION_HEAP_ENABLE_LEAK_TRACKING();

        if (ptcs != NULL)
        {
            ptcs->m_StackHead = NULL;
            ptcs->m_StackDepth = 1;
            ptcs->m_ErrorTracingDisabled = 0;
        }

        ::TlsSetValue(g_FusionTraceContextTLSIndex, ptcs);
    }
    ::SetLastError(dwLastError);
    return ptcs;
}

void
FusionpEnableTracing()
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT( ptcs != NULL );
    ptcs->m_ErrorTracingDisabled = false;
}

void
FusionpDisableTracing()
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT( ptcs != NULL );
    ptcs->m_ErrorTracingDisabled = true;
}

VOID
FusionpPushTraceContext(
    PTRACECONTEXT ptc
    )
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT( ptcs != NULL );
    ptc->m_pCtxOld = ptcs->m_StackHead;
    ptcs->m_StackHead = ptc;
    ptcs->m_StackDepth++;
}

VOID
FusionpPopTraceContext(
    PTRACECONTEXT ptc
    )
{
    const DWORD dwLastError = ::GetLastError();
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();

    ASSERT( ptcs != NULL );
    ASSERT(ptc == ptcs->m_StackHead);

    ASSERT(ptcs->m_StackDepth > 0);

    ptcs->m_StackDepth--;
    ptcs->m_StackHead = ptc->m_pCtxOld;

    ::SetLastError(dwLastError);
}

EXTERN_C int STDAPIVCALLTYPE _DebugTraceA(LPCSTR pszMsg, ...)
{
    int iResult;
    va_list ap;
    va_start(ap, pszMsg);
    iResult = _DebugTraceExVaA(0, TRACETYPE_INFO, NOERROR, pszMsg, ap);
    va_end(ap);
    return iResult;
}

EXTERN_C int STDAPICALLTYPE _DebugTraceVaA(LPCSTR pszMsg, va_list ap)
{
    return _DebugTraceExVaA(0, TRACETYPE_INFO, NOERROR, pszMsg, ap);
}

EXTERN_C int STDAPIVCALLTYPE _DebugTraceExA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, LPCSTR pszMsg, ...)
{
    int iResult;
    va_list ap;
    va_start(ap, pszMsg);
    iResult = _DebugTraceExVaA(dwFlags, tt, hr, pszMsg, ap);
    va_end(ap);
    return iResult;
}

EXTERN_C int STDAPICALLTYPE _DebugTraceExVaA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, LPCSTR pszMsg, va_list ap)
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];
    CHAR szMsgBuffer[4096];

    static const char szFormat_Info_NoFunc[] = "%s(%d): [%s] Message: \"%s\"\n";
    static const char szFormat_Info_Func[] = "%s(%d): [%s] Function %s. Message: \"%s\"\n";
    static const char szFormat_CallEntry[] = "%s(%d): [%s] Entered %s\n";
    static const char szFormat_CallExitVoid[] = "%s(%d): [%s] Exited %s\n";
    static const char szFormat_CallExitHRESULT[] = "%s(%d): [%s] Exited %s with HRESULT 0x%08lx\n";

    LPCSTR pszComponent = "<Unknown>";
    LPCSTR pszFile = pszComponent;
    LPCSTR pszFunction = pszComponent;
    int nLine = 0;

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
        _vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);

    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT( ptcs != NULL );

    const PTRACECONTEXT ptc = ptcs->m_StackHead;

    ASSERT(ptc != NULL);
    if (ptc != NULL)
    {
        pszComponent = ptc->m_szComponentName;
        pszFile = ptc->m_szFile;
        pszFunction = ptc->m_szFunctionName;
        nLine = ptc->m_nLine;
    }

    switch (tt)
    {
    default:
    case TRACETYPE_INFO:
        if (pszFunction != NULL)
            _snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_Info_Func, pszFile, nLine, pszComponent, pszFunction, szMsgBuffer);
        else
            _snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_Info_NoFunc, pszFile, nLine, pszComponent, szMsgBuffer);
        break;

    case TRACETYPE_CALL_START:
        _snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallEntry, pszFile, nLine, pszComponent, pszFunction);
        break;

    case TRACETYPE_CALL_EXIT_NOHRESULT:
        _snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallExitVoid, pszFile, nLine, pszComponent, pszFunction);
        break;

    case TRACETYPE_CALL_EXIT_HRESULT:
        _snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallExitHRESULT, pszFile, nLine, pszComponent, pszFunction, hr);
        break;
    }

    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);

    return 0;
}

VOID
FusionpTraceAllocFailure(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];
    _snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Memory allocation failed in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);
}

VOID
FusionpTraceNull(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];
    _snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Expression evaluated to NULL in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);
}

VOID
FusionpTraceZero(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];
    _snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Expression evaluated to zero in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);
}

VOID
FusionpTraceParameterCheck(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];
    _snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Input parameter validation failed in function %s\n   Validation expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);
}

VOID
FusionpTraceInvalidFlags(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    DWORD dwFlagsPassed,
    DWORD dwFlagsExpected
    )
{
    const DWORD dwLastError = ::GetLastError();
    CHAR szBuffer[4096];

    _snprintf(
        szBuffer,
        NUMBER_OF(szBuffer),
        "%s(%d): Function %s received invalid flags\n"
        "   Flags passed:  0x%08lx\n"
        "   Flags allowed: 0x%08lx\n",
        pszFile, nLine, pszFunction,
        dwFlagsPassed,
        dwFlagsExpected);

    ::OutputDebugStringA(szBuffer);
    ::SetLastError(dwLastError);
}

void
FusionpTraceWin32Failure(
    ULONG FilterLevel,
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    ...
    )
{
    const DWORD dwLastErrorSaved = ::GetLastError();
    va_list ap;
    va_start(ap, pszMsg);
    ::FusionpTraceWin32FailureVa(FilterLevel, pszFile, nLine, pszFunction, dwWin32Status, pszMsg, ap);
    va_end(ap);
    ::SetLastError(dwLastErrorSaved);
}

void
FusionpTraceWin32FailureVa(
    ULONG FilterLevel,
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    va_list ap
    )
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    const DWORD dwLastErrorSaved = ::GetLastError();
    CHAR szMsgBuffer[4096];
    CHAR szErrorBuffer[4096];
    CHAR szOutputBuffer[8192];
    CHAR szClassFuncBuffer[4096];
    LPCSTR pszFormatString = NULL;
    DWORD dwThreadId = ::GetCurrentThreadId();

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            dwWin32Status,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        _snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable Win32 status %d (0x%08lx)>",
            dwWin32Status, dwWin32Status);
    }

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        pszFormatString = "%s(%lu): [function %s tid 0x%lx] Win32 Error %d (%s) %s\n";
        _vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
    }
    else
        pszFormatString = "%s(%lu): [function %s tid 0x%lx] Win32 Error %d (%s)\n";

    const PTRACECONTEXT ptc = ptcs->m_StackHead;

    ASSERT(ptc != NULL);
    if (ptc != NULL)
        pszFile = ptc->m_szFile;

#if 1
    FusionpDbgPrintEx(FilterLevel, pszFormatString, pszFile, nLine, pszFunction, dwThreadId, dwWin32Status, szErrorBuffer, szMsgBuffer);
#else
    _snprintf(szOutputBuffer, NUMBER_OF(szOutputBuffer), pszFormatString, pszFile, nLine, pszFunction, dwThreadId, dwWin32Status, szErrorBuffer, szMsgBuffer);
    ::OutputDebugStringA(szOutputBuffer);

//
// Bug #166864 - PREfix:  FusionpTraceWin32FailureVa uses uninitialized memory szOutputBuffer
// http://sedmison5/prefix/pfxcgi.exe?proj=nt/base/win32/fusion/dll/whistler/obj/i386/sxs.dll&msgid=35226
//
// Looks like this is vestigial... moving the #endif below the output routine.  However,
// there's a bit in FusionpTraceCOMFailureVa that does something similar, and they do
// initialize the text above.  Maybe removing the entire #if block is a better choice?
//
// REVIEW (mgrier, jonwis)
//
// #endif

    if ((s_hFile != NULL) && (s_hFile != INVALID_HANDLE_VALUE))
    {
        DWORD cBytesWritten = 0;
        if (!::WriteFile(s_hFile, szOutputBuffer, (lstrlenA(szOutputBuffer) + 1) * sizeof(CHAR), &cBytesWritten, NULL))
        {
            // Avoid infinite loop if s_hFile is trashed...
            HANDLE hFileSaved = s_hFile;
            s_hFile = NULL;
            TRACE_WIN32_FAILURE(WriteFile);
            s_hFile = hFileSaved;
        }
    }

//
// See above
//
#endif

    // Don't log any more errors until we're told to turn them back on.
    ::FusionpDisableTracing();

    ::SetLastError(dwLastErrorSaved);
}

void
FusionpTraceCOMFailure(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    HRESULT hrIn,
    LPCSTR pszMsg,
    ...
    )
{
    const DWORD dwLastErrorSaved = ::GetLastError();
    va_list ap;
    va_start(ap, pszMsg);
    FusionpTraceCOMFailureVa(pszFile, nLine, pszFunction, hrIn, pszMsg, ap);
    va_end(ap);
    ::SetLastError(dwLastErrorSaved);
}

void
FusionpTraceCOMFailureVa(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT( ptcs != NULL );
    
    if (ptcs->m_ErrorTracingDisabled)
        return;

    const DWORD dwLastErrorSaved = ::GetLastError();
    CHAR szMsgBuffer[4096];
    CHAR szErrorBuffer[4096];
    CHAR szOutputBuffer[8192];
    CHAR szClassFuncBuffer[4096];
    LPCSTR pszFormatString = NULL;
    DWORD dwThreadId = ::GetCurrentThreadId();

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        _snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable HRESULT: 0x%08lx>",
            hrIn);
    }

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        pszFormatString = "%s(%lu): [function %s tid 0x%lx] COM Error 0x%08lx (%s) %s\n";
        _snprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
    }
    else
        pszFormatString = "%s(%lu): [function %s tid 0x%lx] COM Error 0x%08lx (%s)\n";

    const PTRACECONTEXT ptc = ptcs->m_StackHead;

    ASSERT(ptc != NULL);

    if (pszFile == NULL)
    {
        if (ptc != NULL)
        {
            pszFile = ptc->m_szFile;
            nLine = ptc->m_nLine;
            pszFunction = ptc->m_szFunctionName;
        }
    }

    _snprintf(szOutputBuffer, NUMBER_OF(szOutputBuffer), pszFormatString, pszFile, nLine, pszFunction, dwThreadId, hrIn, szErrorBuffer, szMsgBuffer);

    ::OutputDebugStringA(szOutputBuffer);

    if ((s_hFile != NULL) && (s_hFile != INVALID_HANDLE_VALUE))
    {
        DWORD cBytesWritten = 0;
        if (!::WriteFile(s_hFile, szOutputBuffer, (lstrlenA(szOutputBuffer) + 1) * sizeof(CHAR), &cBytesWritten, NULL))
        {
            // Avoid infinite loop if s_hFile is trashed...
            HANDLE hFileSaved = s_hFile;
            s_hFile = NULL;
            TRACE_WIN32_FAILURE(WriteFile);
            s_hFile = hFileSaved;
        }
    }

    ::SetLastError(dwLastErrorSaved);
}

struct ILogFile;

// --------------------------------------------------------------------------------
// TRACEMACROTYPE
// --------------------------------------------------------------------------------
typedef enum tagTRACEMACROTYPE {
    TRACE_INFO,
    TRACE_CALL,
    TRACE_RESULT
} TRACEMACROTYPE;

// --------------------------------------------------------------------------------
// These Traces are for c++ only
// --------------------------------------------------------------------------------
typedef DWORD SHOWTRACEMASK;
#define SHOW_TRACE_NONE     0x00000000
#define SHOW_TRACE_INFO     0x00000001
#define SHOW_TRACE_CALL     0x00000002
#define SHOW_TRACE_ALL      0xffffffff

// --------------------------------------------------------------------------------
// TRACELOGINFOINFO
// --------------------------------------------------------------------------------
typedef struct tagTRACELOGINFO {
    SHOWTRACEMASK       dwMask;
    ILogFile           *pLog;
} TRACELOGINFO, *LPTRACELOGINFO;

// function to make directdb happy
EXTERN_C HRESULT DebugTraceEx(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, LPTRACELOGINFO pLog,
    HRESULT hr, LPSTR pszFile, INT nLine, LPCSTR pszMsg, LPCSTR pszFunc)
{
    return hr;
}

EXTERN_C
void
FusionpTraceCallEntry(
    ULONG FilterMask
    )
{
    const DWORD dwLastError = ::GetLastError();

    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT(ptcs != NULL);
    if (ptcs != NULL)
    {
        const PTRACECONTEXT ptc = ptcs->m_StackHead;

        ASSERT(ptc != NULL);
        if (ptc != NULL)
        {
            FusionpDbgPrintEx(
                FilterMask,
                "%s(%d): Entered %s\n",
                ptc->m_szFile,
                ptc->m_nLine,
                ptc->m_szFunctionName);
        }
    }

    ::SetLastError(dwLastError);
}

EXTERN_C
void
FusionpTraceCallExit(
    ULONG FilterMask
    )
{
    const DWORD dwLastError = ::GetLastError();

    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT(ptcs != NULL);
    if (ptcs != NULL)
    {
        const PTRACECONTEXT ptc = ptcs->m_StackHead;

        ASSERT(ptc != NULL);
        if (ptc != NULL)
        {
            FusionpDbgPrintEx(
                FilterMask,
                "%s(%d): Exited %s\n",
                ptc->m_szFile,
                ptc->m_nLine,
                ptc->m_szFunctionName);
        }
    }

    ::SetLastError(dwLastError);
}

EXTERN_C
void
FusionpTraceCallSuccessfulExitVa(
    ULONG FilterMask,
    PCSTR szFormat,
    va_list ap
    )
{
    const DWORD dwLastError = ::GetLastError();
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();
    ASSERT(ptcs != NULL);
    if (ptcs != NULL)
    {
        const PTRACECONTEXT ptc = ptcs->m_StackHead;

        ASSERT(ptc != NULL);
        if (ptc != NULL)
        {
            CHAR Buffer[4096];

            Buffer[0] = '\0';

            if (szFormat != NULL)
            {
                va_list ap;
                va_start(ap, szFormat);
                _vsnprintf(Buffer, NUMBER_OF(Buffer), szFormat, ap);
                va_end(ap);
            }

            FusionpDbgPrintEx(
                FilterMask,
                "%s(%d): Successfully exiting %s%s%s\n",
                ptc->m_szFile,
                ptc->m_nLine,
                ptc->m_szFunctionName,
                Buffer[0] == '\0' ? "" : " - ",
                Buffer
                );
        }
    }

    ::SetLastError(dwLastError);
}

EXTERN_C
void
FusionpTraceCallSuccessfulExit(
    ULONG FilterMask,
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    FusionpTraceCallSuccessfulExitVa(FilterMask, szFormat, ap);
    va_end(ap);
}

EXTERN_C
void
FusionpTraceCallWin32UnsuccessfulExitVa(
    ULONG FilterMask,
    DWORD dwError,
    PCSTR szFormat,
    va_list ap
    )
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();

    ASSERT(ptcs != NULL);
    if (ptcs != NULL)
    {
        ULONG FilterLevel = FUSION_DBG_LEVEL_ERROR;

        if (ptcs->m_ErrorTracingDisabled)
            FilterLevel = FUSION_DBG_LEVEL_ERROREXITPATH;

        const PTRACECONTEXT ptc = ptcs->m_StackHead;
        ASSERT(ptc != NULL);
        if (ptc != NULL)
        {
            ::FusionpTraceWin32FailureVa(
                FilterLevel,
                ptc->m_szFile,
                ptc->m_nLine,
                ptc->m_szFunctionName,
                dwError,
                szFormat,
                ap);
        }
    }
}

EXTERN_C
void
FusionpTraceCallWin32UnsuccessfulExit(
    ULONG FilterMask,
    DWORD dwError,
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    FusionpTraceCallWin32UnsuccessfulExitVa(FilterMask, dwError, szFormat, ap);
    va_end(ap);
}

EXTERN_C
void
FusionpTraceCallCOMUnsuccessfulExitVa(
    ULONG FilterMask,
    HRESULT hrError,
    PCSTR szFormat,
    va_list ap
    )
{
    const PTRACECONTEXTSTACK ptcs = ::FusionpGetTraceContextStack();

    ASSERT(ptcs != NULL);

    if (ptcs != NULL)
    {
        if (!ptcs->m_ErrorTracingDisabled)
        {
            const PTRACECONTEXT ptc = ptcs->m_StackHead;

            ASSERT(ptc != NULL);
            if (ptc != NULL)
            {
                FusionpTraceCOMFailureVa(
                    ptc->m_szFile,
                    ptc->m_nLine,
                    ptc->m_szFunctionName,
                    hrError,
                    szFormat,
                    ap);
            }
        }
    }
}

EXTERN_C
void
FusionpTraceCallCOMUnsuccessfulExit(
    ULONG FilterMask,
    HRESULT hrError,
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    FusionpTraceCallCOMUnsuccessfulExitVa(FilterMask, hrError, szFormat, ap);
    va_end(ap);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\asmenum.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __asmenum_h__
#define __asmenum_h__

#define OLD_OPCODE_FORMAT 0		/* remove after 7/1/99 */

#include "openum.h"

typedef struct
{
    char *  pszName;
    OPCODE  op;
    
    BYTE    Type;   // Inline0 etc.

    BYTE    Len;    // std mapping
    BYTE    Std1;   
    BYTE    Std2;
} opcodeinfo_t;

#ifdef DECLARE_DATA
opcodeinfo_t OpcodeInfo[] =
{
#define OPALIAS(c,s,real) s, real, 0, 0, 0, 0,
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) s, c, args,l,s1,s2,
#include "opcode.def"
#undef OPDEF
#undef OPALIAS
};

unsigned  OpcodeInfoLen = sizeof(OpcodeInfo) / sizeof(opcodeinfo_t);
#else
extern opcodeinfo_t OpcodeInfo[];
extern unsigned OpcodeInfoLen;
#endif



#endif /* __openum_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\gcdump\i386\gcdumpx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                               GCDumpX86.cpp
 */

/*****************************************************************************/
#ifdef _X86_
/*****************************************************************************/

#include "GCDump.h"
#include "Utilcode.h"           // For _ASSERTE()
#include "Endian.h"


/*****************************************************************************/

#define castto(var,typ) (*(typ *)&var)

#define sizeto(typ,mem) (offsetof(typ, mem) + sizeof(((typ*)0)->mem))

#define CALLEE_SAVED_REG_MAXSZ  (4*sizeof(int)) // EBX,ESI,EDI,EBP

/*****************************************************************************/

const char *        RegName(unsigned reg)
{
    static const char * regNames[] =
    {
        "EAX",
        "ECX",
        "EDX",
        "EBX",

        "ESP",
        "EBP",
        "ESI",
        "EDI"
    };

    _ASSERTE(reg < (sizeof(regNames)/sizeof(regNames[0])));

    return regNames[reg];
}

const char *        CalleeSavedRegName(unsigned reg)
{
    static const char * regNames[] =
    {
        "EDI",
        "ESI",
        "EBX",
        "EBP"
    };

    _ASSERTE(reg < (sizeof(regNames)/sizeof(regNames[0])));

    return regNames[reg];
}

/*****************************************************************************/

unsigned            GCDump::DumpInfoHdr (const BYTE *   table,
                                         InfoHdr*       header,
                                         unsigned *     methodSize,
                                         bool           verifyGCTables)
{
    unsigned        count;
    unsigned        regMask;

    const BYTE  *   tableStart  = table;
    const BYTE  *   bp          = table;

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xFEEF);

    /* Get the method size */

    table += decodeUnsigned(table, methodSize);

    BYTE headerEncoding = *table++;

    decodeHeaderFirst(headerEncoding, header);
    while (headerEncoding & 0x80)
    {
        headerEncoding = *table++;
        decodeHeaderNext(headerEncoding, header);
    }

    if (header->untrackedCnt == 0xffff)
    {
        table += decodeUnsigned(table, &count);
        header->untrackedCnt = count;
    }

    if (header->varPtrTableSize == 0xffff)
    {
        table += decodeUnsigned(table, &count);
        header->varPtrTableSize = count;
    }

    regMask    =  ((unsigned) header->ediSaved)        |
                 (((unsigned) header->esiSaved) << 1)  |
                 (((unsigned) header->ebxSaved) << 2)  |
                 (((unsigned) header->ebpSaved) << 3);

    gcPrintf("    method      size   = %04X\n", *methodSize);
    gcPrintf("    prolog      size   = %3u \n", header->prologSize);
    gcPrintf("    epilog      size   = %3u \n", header->epilogSize);
    gcPrintf("    epilog     count   = %3u \n", header->epilogCount);
    gcPrintf("    epilog      end    = %s  \n", header->epilogAtEnd   ? "yes" : "no");
    gcPrintf("    saved reg.  mask   = %04X\n", regMask);
    gcPrintf("    ebp frame          = %s  \n", header->ebpFrame      ? "yes" : "no");
    gcPrintf("    fully interruptible=%s \n", header->interruptible ? "yes" : "no");
    gcPrintf("    double align       = %s  \n", header->doubleAlign   ? "yes" : "no");
    gcPrintf("    security check     = %s  \n", header->security      ? "yes" : "no");
    gcPrintf("    exception handlers = %s  \n", header->handlers      ? "yes" : "no");
    gcPrintf("    local alloc        = %s  \n", header->localloc      ? "yes" : "no");
    gcPrintf("    edit & continue    = %s  \n", header->editNcontinue ? "yes" : "no");
    gcPrintf("    varargs            = %s  \n", header->varargs       ? "yes" : "no");
    gcPrintf("    argument   count   = %3u \n", header->argCount);
    gcPrintf("    stack frame size   = %3u \n", header->frameSize);
    gcPrintf("    untracked count    = %3u \n", header->untrackedCnt);
    gcPrintf("    var ptr tab count  = %3u \n", header->varPtrTableSize);

    if  (header->epilogCount > 1 || (header->epilogCount != 0 &&
                                     header->epilogAtEnd == 0))
    {
        if (verifyGCTables)
            _ASSERTE(*castto(table, unsigned short *)++ == 0xFACE);

        unsigned offs = 0;

        for (unsigned i = 0; i < header->epilogCount; i++)
        {
            table += decodeUDelta(table, &offs, offs);
            gcPrintf("    epilog #%2u    at   %04X\n", i, offs);
        }
    }
    else
    {
        if  (header->epilogCount)
            gcPrintf("    epilog        at   %04X\n", (*methodSize - header->epilogSize));
    }

    {
        unsigned cur  = 0;
        unsigned last = table-bp;
        while (cur < last) 
        {
            unsigned amount;
            if (cur+5 < last)
                amount = 5;
            else
                amount = last-cur;

            DumpEncoding(bp+cur, amount);
	    gcPrintf("\n");

            cur += amount;
        }
    }

    return  (table - tableStart);
}

/*****************************************************************************/

unsigned            GCDump::DumpGCTable(const BYTE *   table,
                                        const InfoHdr& header,
                                        unsigned       methodSize,
                                        bool           verifyGCTables)
{
    int             sz;
    const BYTE  *   tableStart = table;
    const BYTE  *   bp;

    unsigned        count;
    unsigned        curOffs;

//#if!TGT_x86
//    _ASSERTE(!"NYI");
//#endif

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBEEF);

    unsigned        calleeSavedRegs = 0;
    if (header.doubleAlign)
    {
        calleeSavedRegs = 0;
        if (header.ediSaved) calleeSavedRegs++;
        if (header.esiSaved) calleeSavedRegs++;
        if (header.ebxSaved) calleeSavedRegs++;
    }

    /* Dump the untracked frame variable table */

    count = header.untrackedCnt;

    while (count-- > 0)
    {
        int       stkOffs;
        unsigned  lowBits;

        char      reg = header.ebpFrame ? 'B' : 'S';

        sz    = (unsigned int)decodeSigned(table, &stkOffs);
        table = DumpEncoding(table, sz);

        _ASSERTE(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  =   OFFSET_MASK & stkOffs;
        stkOffs &=  ~OFFSET_MASK;

        assert(!header.doubleAlign || stkOffs >= 0);

        if  (header.doubleAlign &&
             unsigned(stkOffs) >= sizeof(int)*(header.frameSize+calleeSavedRegs))
        {
            reg = 'B';
            stkOffs -= sizeof(int)*(header.frameSize+calleeSavedRegs);
            _ASSERTE(stkOffs >= 2*sizeof(int));
        }

        if  (stkOffs < 0)
            gcPrintf("            [E%cP-%02XH] ", reg, -stkOffs);
        else
            gcPrintf("            [E%cP+%02XH] ", reg, +stkOffs);

        gcPrintf("an untracked %s%s local\n",
                    (lowBits & pinned_OFFSET_FLAG)  ? "pinned " : "",
                    (lowBits & byref_OFFSET_FLAG)   ? "byref"   : ""
	       );
    }

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xCAFE);

    /* Dump the frame variable lifetime table */

    count   = header.varPtrTableSize;
    curOffs = 0;

    while (count-- > 0)
    {
        unsigned varOffs;
        unsigned begOffs;
        unsigned endOffs;
        unsigned lowBits;

        bp = table;

        table += decodeUnsigned(table, &varOffs);
        table += decodeUDelta  (table, &begOffs, curOffs);
        table += decodeUDelta  (table, &endOffs, begOffs);

        DumpEncoding(bp, table-bp);

        _ASSERTE(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  = varOffs & 0x3;
        varOffs &= ~OFFSET_MASK;

        // [EBP+0] is the return address - cant be a var
        _ASSERTE(!header.ebpFrame || varOffs);

        curOffs = begOffs;

        DumpOffset(begOffs);
        gcPrintf("..");
        DumpOffset(endOffs);
        gcPrintf("  [E%s%02XH] a ", header.ebpFrame ? "BP-" : "SP+",
                                  varOffs);

        gcPrintf("%s%s pointer\n",
                    (lowBits & byref_OFFSET_FLAG) ? "byref " : "",
                    (lowBits & this_OFFSET_FLAG)  ? "this"   : ""
	       );

        _ASSERTE(endOffs <= methodSize);
    }

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBABE);

    /* Dump the pointer table */

    curOffs = 0;
    bp      = table;

    if  (header.interruptible)
    {
        //
        // Dump the Fully Interruptible pointer table
        //
        unsigned argCnt = 0;
        bool     isThis = false;
        bool     iptr   = false;

        for (;;)
        {
            unsigned    isPop;
            unsigned    argOffs;
            unsigned    val = *table++;

            _ASSERTE(curOffs <= methodSize);

            if  (!(val & 0x80))
            {
                /* A small 'regPtr' encoding */

                curOffs += val & 0x7;

                DumpEncoding(bp, table-bp); bp = table;
                DumpOffsetEx(curOffs);
                gcPrintf("        reg %s becoming %s", RegName(((val >> 3) & 7)),
                                                     (val & 0x40) ? "live"
                                                                  : "dead");
                if (isThis)
                    gcPrintf(" 'this'");
                if (iptr)
                    gcPrintf(" (iptr)");
                gcPrintf("\n");

                isThis = false;
                iptr   = false;
                continue;
            }

            /* This is probably an argument push/pop */

            argOffs = (val & 0x38) >> 3;

            /* 6 [110] and 7 [111] are reserved for other encodings */

            if  (argOffs < 6)
            {
                /* A small argument encoding */

                curOffs += (val & 0x07);
                isPop    = (val & 0x40);

            ARG:

                if  (isPop)
                {
                    // A Pop of 0, means little-delta

                    if (argOffs != 0)
                    {
                        _ASSERTE(header.ebpFrame || argOffs <= argCnt);

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("        pop %2d ", argOffs);
                        if  (!header.ebpFrame)
                        {
                            argCnt -= argOffs;
                            gcPrintf("args (%d)", argCnt);
                        }
                        else
                            gcPrintf("ptrs");

                        gcPrintf("\n");
                    }
                }
                else
                {
                    _ASSERTE(header.ebpFrame || argOffs >= argCnt);

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        push ptr %2d", argOffs);
                    if  (!header.ebpFrame)
                    {
                        argCnt = argOffs+1;
                        gcPrintf("  (%d)", argCnt);
                    }
                    if (isThis)
                        gcPrintf(" 'this'");
                    if (iptr)
                        gcPrintf(" (iptr)");
                    gcPrintf("\n");

                    isThis = false;
                    iptr   = false;
                }

                continue;
            }
            else if (argOffs == 6)
            {
                if (val & 0x40)
                {
                    /* Bigger delta  000=8,001=16,010=24,...,111=64 */

                    curOffs += (((val & 0x07) + 1) << 3);
                }
                else
                {
                    /* non-ptr arg push */

                    curOffs += (val & 0x07);
                    _ASSERTE(!header.ebpFrame);
                    argCnt++;

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        push non-ptr (%d)\n", argCnt);
                }

                continue;
            }

            /* argOffs was 7 [111] which is reserved for the larger encodings */

            _ASSERTE(argOffs==7);

            switch (val)
            {
            case 0xFF:
                goto DONE_REGTAB;

            case 0xBC:
                isThis = true;
                break;

            case 0xBF:
                iptr = true;
                break;

            case 0xB8:
                table   += decodeUnsigned(table, &val);
                curOffs += val;
                break;

            case 0xF8:
            case 0xFC:
                isPop  = val & 0x04;
                table += decodeUnsigned(table, &argOffs);
                goto ARG;

            case 0xFD:
                table += decodeUnsigned(table, &argOffs);
                assert(argOffs);

                DumpEncoding(bp, table-bp); bp = table;
                DumpOffsetEx(curOffs);

                gcPrintf("        kill args %2d\n", argOffs);
                break;
                 
            case 0xF9:
                table  += decodeUnsigned(table, &argOffs);
                argCnt += argOffs;
                break;

            default:
                gcPrintf("Unexpected special code %04X\n", val);
                _ASSERTE(!"");
            }
        }
    }
    else if (header.ebpFrame)        // interruptible is false
    {
        //
        // Dump the Partially Interruptible, EBP-frame method, pointer table
        //

        for (;;)
        {
            unsigned        argMask = 0, byrefArgMask = 0;
            unsigned        regMask, byrefRegMask = 0;

            unsigned        argCnt = 0;
            const BYTE   *  argTab = NULL;
            unsigned        argTabSize;

            unsigned        val, nxt;

            /* Get the next byte and check for a 'special' entry */

            unsigned        encType = *table++;

            _ASSERTE(curOffs <= methodSize);

            switch (encType)
            {

            default:

                /* A tiny or small call entry */

                val = encType;

                if ((val & 0x80) == 0x00)
                {
                    if (val & 0x0F)
                    {
                        /* A tiny call entry */

                        curOffs += (val & 0x0F);
                        regMask  = (val & 0x70) >> 4;
                        argMask  = 0;
                    }
                    else
                    {
                        DumpEncoding(bp, table-bp); bp = table;

                        gcPrintf("            thisptr in ");
                        if (val & 0x10)
                            gcPrintf("EDI\n");
                        else if (val & 0x20)
                            gcPrintf("ESI\n");
                        else if (val & 0x40)
                            gcPrintf("EBX\n");
                        else
                            _ASSERTE(!"Reserved GC encoding");

                        continue;
                    }
                }
                else
                {
                    /* A small call entry */

                    curOffs += (val & 0x7F);
                    val      = *table++;
                    regMask  = val >> 5;
                    argMask  = val & 0x1F;
                }
                break;

            case 0xFD:  // medium encoding

                argMask  = *table++;
                val      = *table++;
                argMask |= (val & 0xF0) << 4;
                nxt      = *table++;
                curOffs += (val & 0x0F) + ((nxt & 0x1F) << 4);
                regMask  = nxt >> 5;                   // EBX,ESI,EDI

                break;

            case 0xF9:  // medium encoding with byrefs

                curOffs += *table++;
                val      = *table++;
                argMask  = val & 0x1F;
                regMask  = val >> 5;
                val      = *table++;
                byrefArgMask    = val & 0x1F;
                byrefRegMask    = val >> 5;

                break;

            case 0xFE:  // large encoding
            case 0xFA:  // large encoding with byrefs

                val         = *table++;
                regMask     = val & 0x7;
                byrefRegMask= val >> 4;
                curOffs    += readDWordSmallEndian(table);       table += sizeof(DWORD);
                argMask     = readDWordSmallEndian(table);       table += sizeof(DWORD);
                if (encType == 0xFA) // read byrefArgMask
                    {byrefArgMask = readDWordSmallEndian(table); table += sizeof(DWORD);}

                break;

            case 0xFB:  // huge encoding

                val         = *table++;
                regMask     = val & 0x7;
                byrefRegMask= val >> 4;
                curOffs     = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argCnt      = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argTabSize  = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argTab      = table;                        table += argTabSize;

                break;

            case 0xFF:
                goto DONE_REGTAB;
            }

            /*
                Here we have the following values:

                curOffs      ...    the code offset of the call
                regMask      ...    mask of live pointer register variables
                argMask      ...    bitmask of pushed pointer arguments
                byrefRegMask ...    byref qualifier for regMask
                byrefArgMask ...    byrer qualifier for argMask
             */

            _ASSERTE((byrefArgMask & argMask) == byrefArgMask);
            _ASSERTE((byrefRegMask & regMask) == byrefRegMask);

            DumpEncoding(bp, table-bp); bp = table;
            DumpOffsetEx(curOffs);

            gcPrintf("        call [ ");

            if (regMask & 1)
                gcPrintf("EDI%c", (byrefRegMask & 1) ? '\'' : ' ');
            if (regMask & 2)
                gcPrintf("ESI%c", (byrefRegMask & 2) ? '\'' : ' ');
            if (regMask & 4)
                gcPrintf("EBX%c", (byrefRegMask & 4) ? '\'' : ' ');

            if (!header.ebpFrame)
            {
                if (regMask & 8)
                    gcPrintf("EBP ");
            }

            if  (argCnt)
            {
                gcPrintf("] ptrArgs=[");

                do
                {
                    argTab += decodeUnsigned(argTab, &val);

                    assert((val & this_OFFSET_FLAG) == 0);
                    unsigned  stkOffs = val & ~byref_OFFSET_FLAG;
                    unsigned  lowBit  = val &  byref_OFFSET_FLAG;

                    gcPrintf("%u%s", stkOffs, lowBit ? "i" : "");
                    if  (argCnt > 1)
                        gcPrintf(" ");
                }
                while (--argCnt);
                assert(argTab == table);

                gcPrintf("]");
            }
            else
            {
                gcPrintf("] argMask=%02X", argMask);

                if (byrefArgMask) gcPrintf(" (iargs=%02X)", byrefArgMask);
            }

            gcPrintf("\n");
        }
    }
    else // interruptible is false, ebpFrame is false
    {
        //
        // Dump the Partially Interruptible, EBP-less method, pointer table
        //
        unsigned lastSkip = 0;
        unsigned imask    = 0;

        for (;;)
        {
            unsigned    val = *table++;

            _ASSERTE(curOffs <= methodSize);

            if  (!(val & 0x80))
            {
                if (!(val & 0x40))
                {
                    if (!(val & 0x20))
                    {
                        //
                        // push    000DDDDD          push one item, 5-bit delta
                        //

                        curOffs += val & 0x1F;

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("        push\n");
                    }
                    else
                    {
                        //
                        // push    00100000 [pushCount]     ESP push multiple items
                        //

                        unsigned pushCount;

                        assert(val == 0x20);
                        table    += decodeUnsigned(table, &pushCount);

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("       push %d\n", pushCount);
                    }
                }
                else
                {
                    unsigned    popSize;
                    unsigned    skip;

                    if ((val & 0x3f) == 0)
                    {
                        //
                        // skip    01000000 [Delta]  Skip arbitrary sized delta
                        //

                        table   += decodeUnsigned(table, &skip);
                        curOffs += skip;
                        lastSkip = skip;
                    }
                    else
                    {
                        //
                        //  pop     01CCDDDD         pop CC items, 4-bit delta
                        //

                        popSize = (val & 0x30) >> 4;
                        skip    =  val & 0x0f;
                        curOffs += skip;

                        if (popSize > 0)
                        {
                            DumpEncoding(bp, table-bp); bp = table;
                            DumpOffsetEx(curOffs);

                            gcPrintf("        pop %d\n", popSize);
                        }
                        else
                            lastSkip = skip;
                    }
                }
            }
            else
            {
                unsigned    callArgCnt;
                unsigned    callRegMask;
                bool        callPndTab = false;
                unsigned    callPndMask = 0;
                unsigned    callPndTabCnt = 0, callPndTabSize = 0;

                switch ((val & 0x70) >> 4)
                {
                default:
                    //
                    // call    1PPPPPPP          Call Pattern, P=[0..79]
                    //
                    decodeCallPattern((val & 0x7f), &callArgCnt,  &callRegMask,
                                                    &callPndMask, &lastSkip);
                    curOffs += lastSkip;

                PRINT_CALL:

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        call %d [ ", callArgCnt);

                    unsigned    iregMask, iargMask;

                    iregMask = imask & 0xF;
                    iargMask = imask >> 4;

                    assert((callRegMask & 0x0F) == callRegMask);
                    if (callRegMask & 1)
                        gcPrintf("EDI%c", (iregMask & 1) ? '\'' : ' ');
                    if (callRegMask & 2)
                        gcPrintf("ESI%c", (iregMask & 2) ? '\'' : ' ');
                    if (callRegMask & 4)
                        gcPrintf("EBX%c", (iregMask & 4) ? '\'' : ' ');
                    if (callRegMask & 8)
                        gcPrintf("EBP%c", (iregMask & 8) ? '\'' : ' ');
                    gcPrintf("]");

                    if (callPndTab)
                    {
                        const BYTE * offsStart = table;
                        gcPrintf(" argOffs(%d) =", callPndTabCnt);
                        for (unsigned i=0; i < callPndTabCnt; i++)
                        {
                            unsigned pndOffs;
                            table += decodeUnsigned(table, &pndOffs);
                            gcPrintf(" %4X", pndOffs);
                        }
                        assert(offsStart + callPndTabSize == table);
                        bp = table;
                    }
                    else
                    {
                        if (callPndMask)
                            gcPrintf(" argMask=%02X", callPndMask);
                        if (iargMask)
                            gcPrintf(" (iargs=%02X)", iargMask);
                    }
                    gcPrintf("\n");

                    imask = lastSkip = 0;
                    break;

                  case 5:
                    //
                    // call    1101RRRR DDCCCMMM  Call RegMask=RRRR,ArgCnt=CCC,
                    //                        ArgMask=MMM Delta=commonDelta[DD]
                    //
                    callRegMask     = val & 0xf;    // EBP,EBX,ESI,EDI
                    val             = *table++;
                    callPndMask     = (val & 0x7);
                    callArgCnt      = (val >> 3) & 0x7;
                    lastSkip        = callCommonDelta[val>>6];
                    curOffs        += lastSkip;

                    goto PRINT_CALL;

                  case 6:
                    //
                    // call    1110RRRR [ArgCnt] [ArgMask]
                    //                          Call ArgCnt,RegMask=RRR,ArgMask
                    //
                    callRegMask = val & 0xf;    // EBP,EBX,ESI,EDI
                    table += decodeUnsigned(table, &callArgCnt);
                    table += decodeUnsigned(table, &callPndMask);
                    goto PRINT_CALL;

                  case 7:
                    switch (val & 0x0C)
                    {
                    case 0x00:
                        assert(val == 0xF0);
                        /*  iptr 11110000 [IPtrMask] Arbitrary Interior Pointer Mask */
                        table += decodeUnsigned(table, &imask);
                        DumpEncoding(bp, table-bp); bp = table;
                        gcPrintf("            iptrMask = %02X\n", imask);
                        break;

                    case 0x04:
                        DumpEncoding(bp, table-bp); bp = table;
                        gcPrintf("            thisptr in %s\n", CalleeSavedRegName(val&0x3));
                        break;

                    case 0x08:
                        val             = *table++;
                        callRegMask     = val & 0xF;
                        imask           = val >> 4;
                        lastSkip        = *(DWORD*)table; table += sizeof(DWORD);
                        curOffs        += lastSkip;
                        callArgCnt      = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTabCnt   = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTabSize  = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTab      = true;
                        goto PRINT_CALL;

                    case 0x0C:
                        assert(val==0xff);
                        goto DONE_REGTAB;
                        break;

                    default:
                        _ASSERTE(!"reserved GC encoding");
                        break;
                    }
                    break;
                }
            }
        }
    }

DONE_REGTAB:

    _ASSERTE(curOffs <= methodSize);

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBEEB);

    _ASSERTE(table > bp);

    DumpEncoding(bp, table-bp);
//  gcPrintf("     ");
    gcPrintf("\n");

    return  (table - tableStart);
}


/*****************************************************************************/

void                GCDump::DumpPtrsInFrame(const void *infoBlock,
                                            const void *codeBlock,
                                            unsigned    offs,
                                            bool        verifyGCTables)
{
    const BYTE  *   table = (BYTE *)infoBlock;

    size_t          methodSize;
    size_t          stackSize;
    size_t          prologSize;
    size_t          epilogSize;
    unsigned        epilogCnt;
    BOOL            epilogEnd;
    size_t          argSize;
    BOOL            secCheck;
    BOOL            dblAlign;

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xFEEF);

    /* Get hold of the method size */

    table += decodeUnsigned(table, &methodSize);

    //
    // New style InfoBlk Header [briansul]
    //
    // Typically only uses one-byte to store everything.
    //
    InfoHdr header;
    BYTE headerEncoding = *table++;
    decodeHeaderFirst(headerEncoding, &header);
    BYTE encoding = headerEncoding;
    while (encoding & 0x80)
    {
        encoding = *table++;
        decodeHeaderNext(encoding, &header);
    }
    if (header.untrackedCnt == 0xffff)
    {
        unsigned count;
        table += decodeUnsigned(table, &count);
        header.untrackedCnt = count;
    }
    if (header.varPtrTableSize == 0xffff)
    {
        unsigned count;
        table += decodeUnsigned(table, &count);
        header.varPtrTableSize = count;
    }
    prologSize = header.prologSize;
    epilogSize = header.epilogSize;
    epilogCnt  = header.epilogCount;
    epilogEnd  = header.epilogAtEnd;
    secCheck   = header.security;
    dblAlign   = header.doubleAlign;
    argSize    = header.argCount * 4;
    stackSize  = header.frameSize;

#ifdef DEBUG
    if  (offs == 0)
    {
        gcPrintf("    method      size = %04X\n", methodSize);
        gcPrintf("    stack frame size = %3u \n",  stackSize);
        gcPrintf("    prolog      size = %3u \n", prologSize);
        gcPrintf("    epilog      size = %3u \n", epilogSize);
        gcPrintf("    epilog      end  = %s  \n", epilogEnd ? "yes" : "no");
        gcPrintf("    epilog     count = %3u \n", epilogCnt );
        gcPrintf("    security         = %s  \n", secCheck  ? "yes" : "no");
        gcPrintf("    dblAlign         = %s  \n", dblAlign  ? "yes" : "no");
        gcPrintf("    untracked count  = %3u \n", header.untrackedCnt);
        gcPrintf("    var ptr tab count= %3u \n", header.varPtrTableSize);
        gcPrintf("\n");
    }
#endif

    /* Are we within the prolog of the method? */

    if  (offs < prologSize)
    {
        gcPrintf("    Offset %04X is within the method's prolog\n", offs);
        return;
    }

    /* Are we within an epilog of the method? */

    if  (epilogCnt)
    {
        unsigned    eps;

        if  (epilogCnt > 1 || !epilogEnd)
        {
            if (verifyGCTables)
                _ASSERTE(*castto(table, unsigned short *)++ == 0xFACE);

            unsigned prevEps = 0;
            for (unsigned i = 0; i < epilogCnt; i++)
            {
                table += decodeUDelta(table, &eps, prevEps);

                if ((offs >= eps) && (offs <  eps + epilogSize))
                        goto EPILOG_MSG;
            }
        }
        else
        {
            eps = (int)(methodSize - epilogSize);
            if ((offs >= eps) && (offs <  eps + epilogSize))
            {
EPILOG_MSG:     gcPrintf("    Offset %04X is within the method's epilog"
                       " (%02X bytes into it)\n", offs, offs - eps);
                return;
            }
        }
    }
    gcPrintf("    Offset %04X is within the method's body\n", offs);
}

/*****************************************************************************/
#endif // _X86_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\gcdump\i486\gcdumpx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                               GCDumpX86.cpp
 */

/*****************************************************************************/
#ifdef _X86_
/*****************************************************************************/

#include "GCDump.h"
#include "Utilcode.h"           // For _ASSERTE()
#include "Endian.h"


/*****************************************************************************/

#define castto(var,typ) (*(typ *)&var)

#define sizeto(typ,mem) (offsetof(typ, mem) + sizeof(((typ*)0)->mem))

#define CALLEE_SAVED_REG_MAXSZ  (4*sizeof(int)) // EBX,ESI,EDI,EBP

/*****************************************************************************/

const char *        RegName(unsigned reg)
{
    static const char * regNames[] =
    {
        "EAX",
        "ECX",
        "EDX",
        "EBX",

        "ESP",
        "EBP",
        "ESI",
        "EDI"
    };

    _ASSERTE(reg < (sizeof(regNames)/sizeof(regNames[0])));

    return regNames[reg];
}

const char *        CalleeSavedRegName(unsigned reg)
{
    static const char * regNames[] =
    {
        "EDI",
        "ESI",
        "EBX",
        "EBP"
    };

    _ASSERTE(reg < (sizeof(regNames)/sizeof(regNames[0])));

    return regNames[reg];
}

/*****************************************************************************/

unsigned            GCDump::DumpInfoHdr (const BYTE *   table,
                                         InfoHdr*       header,
                                         unsigned *     methodSize,
                                         bool           verifyGCTables)
{
    unsigned        count;
    unsigned        regMask;

    const BYTE  *   tableStart  = table;
    const BYTE  *   bp          = table;

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xFEEF);

    /* Get the method size */

    table += decodeUnsigned(table, methodSize);

    BYTE headerEncoding = *table++;

    decodeHeaderFirst(headerEncoding, header);
    while (headerEncoding & 0x80)
    {
        headerEncoding = *table++;
        decodeHeaderNext(headerEncoding, header);
    }

    if (header->untrackedCnt == 0xffff)
    {
        table += decodeUnsigned(table, &count);
        header->untrackedCnt = count;
    }

    if (header->varPtrTableSize == 0xffff)
    {
        table += decodeUnsigned(table, &count);
        header->varPtrTableSize = count;
    }

    regMask    =  ((unsigned) header->ediSaved)        |
                 (((unsigned) header->esiSaved) << 1)  |
                 (((unsigned) header->ebxSaved) << 2)  |
                 (((unsigned) header->ebpSaved) << 3);

    gcPrintf("    method      size   = %04X\n", *methodSize);
    gcPrintf("    prolog      size   = %3u \n", header->prologSize);
    gcPrintf("    epilog      size   = %3u \n", header->epilogSize);
    gcPrintf("    epilog     count   = %3u \n", header->epilogCount);
    gcPrintf("    epilog      end    = %s  \n", header->epilogAtEnd   ? "yes" : "no");
    gcPrintf("    saved reg.  mask   = %04X\n", regMask);
    gcPrintf("    ebp frame          = %s  \n", header->ebpFrame      ? "yes" : "no");
    gcPrintf("    fully interruptible=%s \n", header->interruptible ? "yes" : "no");
    gcPrintf("    double align       = %s  \n", header->doubleAlign   ? "yes" : "no");
    gcPrintf("    security check     = %s  \n", header->security      ? "yes" : "no");
    gcPrintf("    exception handlers = %s  \n", header->handlers      ? "yes" : "no");
    gcPrintf("    local alloc        = %s  \n", header->localloc      ? "yes" : "no");
    gcPrintf("    edit & continue    = %s  \n", header->editNcontinue ? "yes" : "no");
    gcPrintf("    varargs            = %s  \n", header->varargs       ? "yes" : "no");
    gcPrintf("    argument   count   = %3u \n", header->argCount);
    gcPrintf("    stack frame size   = %3u \n", header->frameSize);
    gcPrintf("    untracked count    = %3u \n", header->untrackedCnt);
    gcPrintf("    var ptr tab count  = %3u \n", header->varPtrTableSize);

    if  (header->epilogCount > 1 || (header->epilogCount != 0 &&
                                     header->epilogAtEnd == 0))
    {
        if (verifyGCTables)
            _ASSERTE(*castto(table, unsigned short *)++ == 0xFACE);

        unsigned offs = 0;

        for (unsigned i = 0; i < header->epilogCount; i++)
        {
            table += decodeUDelta(table, &offs, offs);
            gcPrintf("    epilog #%2u    at   %04X\n", i, offs);
        }
    }
    else
    {
        if  (header->epilogCount)
            gcPrintf("    epilog        at   %04X\n", (*methodSize - header->epilogSize));
    }

    {
        unsigned cur  = 0;
        unsigned last = table-bp;
        while (cur < last) 
        {
            unsigned amount;
            if (cur+5 < last)
                amount = 5;
            else
                amount = last-cur;

            DumpEncoding(bp+cur, amount);
	    gcPrintf("\n");

            cur += amount;
        }
    }

    return  (table - tableStart);
}

/*****************************************************************************/

unsigned            GCDump::DumpGCTable(const BYTE *   table,
                                        const InfoHdr& header,
                                        unsigned       methodSize,
                                        bool           verifyGCTables)
{
    int             sz;
    const BYTE  *   tableStart = table;
    const BYTE  *   bp;

    unsigned        count;
    unsigned        curOffs;

//#if!TGT_x86
//    _ASSERTE(!"NYI");
//#endif

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBEEF);

    unsigned        calleeSavedRegs;
    if (header.doubleAlign)
    {
        calleeSavedRegs = 0;
        if (header.ediSaved) calleeSavedRegs++;
        if (header.esiSaved) calleeSavedRegs++;
        if (header.ebxSaved) calleeSavedRegs++;
    }

    /* Dump the untracked frame variable table */

    count = header.untrackedCnt;

    while (count-- > 0)
    {
        int       stkOffs;
        unsigned  lowBits;

        char      reg = header.ebpFrame ? 'B' : 'S';

        sz    = decodeSigned(table, &stkOffs);
        table = DumpEncoding(table, sz);

        _ASSERTE(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  =   OFFSET_MASK & stkOffs;
        stkOffs &=  ~OFFSET_MASK;

        assert(!header.doubleAlign || stkOffs >= 0);

        if  (header.doubleAlign &&
             unsigned(stkOffs) >= sizeof(int)*(header.frameSize+calleeSavedRegs))
        {
            reg = 'B';
            stkOffs -= sizeof(int)*(header.frameSize+calleeSavedRegs);
            _ASSERTE(stkOffs >= 2*sizeof(int));
        }

        if  (stkOffs < 0)
            gcPrintf("            [E%cP-%02XH] ", reg, -stkOffs);
        else
            gcPrintf("            [E%cP+%02XH] ", reg, +stkOffs);

        gcPrintf("an untracked %s%s local\n",
                    (lowBits & pinned_OFFSET_FLAG)  ? "pinned " : "",
                    (lowBits & byref_OFFSET_FLAG)   ? "byref"   : ""
	       );
    }

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xCAFE);

    /* Dump the frame variable lifetime table */

    count   = header.varPtrTableSize;
    curOffs = 0;

    while (count-- > 0)
    {
        unsigned varOffs;
        unsigned begOffs;
        unsigned endOffs;
        unsigned lowBits;

        bp = table;

        table += decodeUnsigned(table, &varOffs);
        table += decodeUDelta  (table, &begOffs, curOffs);
        table += decodeUDelta  (table, &endOffs, begOffs);

        DumpEncoding(bp, table-bp);

        _ASSERTE(0 == ~OFFSET_MASK % sizeof(void*));

        lowBits  = varOffs & 0x3;
        varOffs &= ~OFFSET_MASK;

        // [EBP+0] is the return address - cant be a var
        _ASSERTE(!header.ebpFrame || varOffs);

        curOffs = begOffs;

        DumpOffset(begOffs);
        gcPrintf("..");
        DumpOffset(endOffs);
        gcPrintf("  [E%s%02XH] a ", header.ebpFrame ? "BP-" : "SP+",
                                  varOffs);

        gcPrintf("%s%s pointer\n",
                    (lowBits & byref_OFFSET_FLAG) ? "byref " : "",
                    (lowBits & this_OFFSET_FLAG)  ? "this"   : ""
	       );

        _ASSERTE(endOffs <= methodSize);
    }

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBABE);

    /* Dump the pointer table */

    curOffs = 0;
    bp      = table;

    if  (header.interruptible)
    {
        //
        // Dump the Fully Interruptible pointer table
        //
        unsigned argCnt = 0;
        bool     isThis = false;
        bool     iptr   = false;

        for (;;)
        {
            unsigned    isPop;
            unsigned    argOffs;
            unsigned    val = *table++;

            _ASSERTE(curOffs <= methodSize);

            if  (!(val & 0x80))
            {
                /* A small 'regPtr' encoding */

                curOffs += val & 0x7;

                DumpEncoding(bp, table-bp); bp = table;
                DumpOffsetEx(curOffs);
                gcPrintf("        reg %s becoming %s", RegName(((val >> 3) & 7)),
                                                     (val & 0x40) ? "live"
                                                                  : "dead");
                if (isThis)
                    gcPrintf(" 'this'");
                if (iptr)
                    gcPrintf(" (iptr)");
                gcPrintf("\n");

                isThis = false;
                iptr   = false;
                continue;
            }

            /* This is probably an argument push/pop */

            argOffs = (val & 0x38) >> 3;

            /* 6 [110] and 7 [111] are reserved for other encodings */

            if  (argOffs < 6)
            {
                /* A small argument encoding */

                curOffs += (val & 0x07);
                isPop    = (val & 0x40);

            ARG:

                if  (isPop)
                {
                    // A Pop of 0, means little-delta

                    if (argOffs != 0)
                    {
                        _ASSERTE(header.ebpFrame || argOffs <= argCnt);

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("        pop %2d ", argOffs);
                        if  (!header.ebpFrame)
                        {
                            argCnt -= argOffs;
                            gcPrintf("args (%d)", argCnt);
                        }
                        else
                            gcPrintf("ptrs");

                        gcPrintf("\n");
                    }
                }
                else
                {
                    _ASSERTE(header.ebpFrame || argOffs >= argCnt);

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        push ptr %2d", argOffs);
                    if  (!header.ebpFrame)
                    {
                        argCnt = argOffs+1;
                        gcPrintf("  (%d)", argCnt);
                    }
                    if (isThis)
                        gcPrintf(" 'this'");
                    if (iptr)
                        gcPrintf(" (iptr)");
                    gcPrintf("\n");

                    isThis = false;
                    iptr   = false;
                }

                continue;
            }
            else if (argOffs == 6)
            {
                if (val & 0x40)
                {
                    /* Bigger delta  000=8,001=16,010=24,...,111=64 */

                    curOffs += (((val & 0x07) + 1) << 3);
                }
                else
                {
                    /* non-ptr arg push */

                    curOffs += (val & 0x07);
                    _ASSERTE(!header.ebpFrame);
                    argCnt++;

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        push non-ptr (%d)\n", argCnt);
                }

                continue;
            }

            /* argOffs was 7 [111] which is reserved for the larger encodings */

            _ASSERTE(argOffs==7);

            switch (val)
            {
            case 0xFF:
                goto DONE_REGTAB;

            case 0xBC:
                isThis = true;
                break;

            case 0xBF:
                iptr = true;
                break;

            case 0xB8:
                table   += decodeUnsigned(table, &val);
                curOffs += val;
                break;

            case 0xF8:
            case 0xFC:
                isPop  = val & 0x04;
                table += decodeUnsigned(table, &argOffs);
                goto ARG;

            case 0xFD:
                table += decodeUnsigned(table, &argOffs);
                assert(argOffs);

                DumpEncoding(bp, table-bp); bp = table;
                DumpOffsetEx(curOffs);

                gcPrintf("        kill args %2d\n", argOffs);
                break;
                 
            case 0xF9:
                table  += decodeUnsigned(table, &argOffs);
                argCnt += argOffs;
                break;

            default:
                gcPrintf("Unexpected special code %04X\n", val);
                _ASSERTE(!"");
            }
        }
    }
    else if (header.ebpFrame)        // interruptible is false
    {
        //
        // Dump the Partially Interruptible, EBP-frame method, pointer table
        //

        for (;;)
        {
            unsigned        argMask, byrefArgMask = 0;
            unsigned        regMask, byrefRegMask = 0;

            unsigned        argCnt = 0;
            const BYTE   *  argTab;
            unsigned        argTabSize;

            unsigned        val, nxt;

            /* Get the next byte and check for a 'special' entry */

            unsigned        encType = *table++;

            _ASSERTE(curOffs <= methodSize);

            switch (encType)
            {

            default:

                /* A tiny or small call entry */

                val = encType;

                if ((val & 0x80) == 0x00)
                {
                    if (val & 0x0F)
                    {
                        /* A tiny call entry */

                        curOffs += (val & 0x0F);
                        regMask  = (val & 0x70) >> 4;
                        argMask  = 0;
                    }
                    else
                    {
                        DumpEncoding(bp, table-bp); bp = table;

                        gcPrintf("            thisptr in ");
                        if (val & 0x10)
                            gcPrintf("EDI\n");
                        else if (val & 0x20)
                            gcPrintf("ESI\n");
                        else if (val & 0x40)
                            gcPrintf("EBX\n");
                        else
                            _ASSERTE(!"Reserved GC encoding");

                        continue;
                    }
                }
                else
                {
                    /* A small call entry */

                    curOffs += (val & 0x7F);
                    val      = *table++;
                    regMask  = val >> 5;
                    argMask  = val & 0x1F;
                }
                break;

            case 0xFD:  // medium encoding

                argMask  = *table++;
                val      = *table++;
                argMask |= (val & 0xF0) << 4;
                nxt      = *table++;
                curOffs += (val & 0x0F) + ((nxt & 0x1F) << 4);
                regMask  = nxt >> 5;                   // EBX,ESI,EDI

                break;

            case 0xF9:  // medium encoding with byrefs

                curOffs += *table++;
                val      = *table++;
                argMask  = val & 0x1F;
                regMask  = val >> 5;
                val      = *table++;
                byrefArgMask    = val & 0x1F;
                byrefRegMask    = val >> 5;

                break;

            case 0xFE:  // large encoding
            case 0xFA:  // large encoding with byrefs

                val         = *table++;
                regMask     = val & 0x7;
                byrefRegMask= val >> 4;
                curOffs    += readDWordSmallEndian(table);       table += sizeof(DWORD);
                argMask     = readDWordSmallEndian(table);       table += sizeof(DWORD);
                if (encType == 0xFA) // read byrefArgMask
                    byrefArgMask = readDWordSmallEndian(table);  table += sizeof(DWORD);

                break;

            case 0xFB:  // huge encoding

                val         = *table++;
                regMask     = val & 0x7;
                byrefRegMask= val >> 4;
                curOffs     = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argCnt      = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argTabSize  = readDWordSmallEndian(table);  table += sizeof(DWORD);
                argTab      = table;                        table += argTabSize;

                break;

            case 0xFF:
                goto DONE_REGTAB;
            }

            /*
                Here we have the following values:

                curOffs      ...    the code offset of the call
                regMask      ...    mask of live pointer register variables
                argMask      ...    bitmask of pushed pointer arguments
                byrefRegMask ...    byref qualifier for regMask
                byrefArgMask ...    byrer qualifier for argMask
             */

            _ASSERTE((byrefArgMask & argMask) == byrefArgMask);
            _ASSERTE((byrefRegMask & regMask) == byrefRegMask);

            DumpEncoding(bp, table-bp); bp = table;
            DumpOffsetEx(curOffs);

            gcPrintf("        call [ ");

            if (regMask & 1)
                gcPrintf("EDI%c", (byrefRegMask & 1) ? '\'' : ' ');
            if (regMask & 2)
                gcPrintf("ESI%c", (byrefRegMask & 2) ? '\'' : ' ');
            if (regMask & 4)
                gcPrintf("EBX%c", (byrefRegMask & 4) ? '\'' : ' ');

            if (!header.ebpFrame)
            {
                if (regMask & 8)
                    gcPrintf("EBP ");
            }

            if  (argCnt)
            {
                gcPrintf("] ptrArgs=[");

                do
                {
                    argTab += decodeUnsigned(argTab, &val);

                    assert((val & this_OFFSET_FLAG) == 0);
                    unsigned  stkOffs = val & ~byref_OFFSET_FLAG;
                    unsigned  lowBit  = val &  byref_OFFSET_FLAG;

                    gcPrintf("%u%s", stkOffs, lowBit ? "i" : "");
                    if  (argCnt > 1)
                        gcPrintf(" ");
                }
                while (--argCnt);
                assert(argTab == table);

                gcPrintf("]");
            }
            else
            {
                gcPrintf("] argMask=%02X", argMask);

                if (byrefArgMask) gcPrintf(" (iargs=%02X)", byrefArgMask);
            }

            gcPrintf("\n");
        }
    }
    else // interruptible is false, ebpFrame is false
    {
        //
        // Dump the Partially Interruptible, EBP-less method, pointer table
        //
        unsigned lastSkip = 0;
        unsigned imask    = 0;

        for (;;)
        {
            unsigned    val = *table++;

            _ASSERTE(curOffs <= methodSize);

            if  (!(val & 0x80))
            {
                if (!(val & 0x40))
                {
                    if (!(val & 0x20))
                    {
                        //
                        // push    000DDDDD          push one item, 5-bit delta
                        //

                        curOffs += val & 0x1F;

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("        push\n");
                    }
                    else
                    {
                        //
                        // push    00100000 [pushCount]     ESP push multiple items
                        //

                        unsigned pushCount;

                        assert(val == 0x20);
                        table    += decodeUnsigned(table, &pushCount);

                        DumpEncoding(bp, table-bp); bp = table;
                        DumpOffsetEx(curOffs);

                        gcPrintf("       push %d\n", pushCount);
                    }
                }
                else
                {
                    unsigned    popSize;
                    unsigned    skip;

                    if ((val & 0x3f) == 0)
                    {
                        //
                        // skip    01000000 [Delta]  Skip arbitrary sized delta
                        //

                        table   += decodeUnsigned(table, &skip);
                        curOffs += skip;
                        lastSkip = skip;
                    }
                    else
                    {
                        //
                        //  pop     01CCDDDD         pop CC items, 4-bit delta
                        //

                        popSize = (val & 0x30) >> 4;
                        skip    =  val & 0x0f;
                        curOffs += skip;

                        if (popSize > 0)
                        {
                            DumpEncoding(bp, table-bp); bp = table;
                            DumpOffsetEx(curOffs);

                            gcPrintf("        pop %d\n", popSize);
                        }
                        else
                            lastSkip = skip;
                    }
                }
            }
            else
            {
                unsigned    callArgCnt;
                unsigned    callRegMask;
                bool        callPndTab = false;
                unsigned    callPndMask;
                unsigned    callPndTabCnt, callPndTabSize;

                switch ((val & 0x70) >> 4)
                {
                default:
                    //
                    // call    1PPPPPPP          Call Pattern, P=[0..79]
                    //
                    decodeCallPattern((val & 0x7f), &callArgCnt,  &callRegMask,
                                                    &callPndMask, &lastSkip);
                    curOffs += lastSkip;

                PRINT_CALL:

                    DumpEncoding(bp, table-bp); bp = table;
                    DumpOffsetEx(curOffs);

                    gcPrintf("        call %d [ ", callArgCnt);

                    unsigned    iregMask, iargMask;

                    iregMask = imask & 0xF;
                    iargMask = imask >> 4;

                    assert((callRegMask & 0x0F) == callRegMask);
                    if (callRegMask & 1)
                        gcPrintf("EDI%c", (iregMask & 1) ? '\'' : ' ');
                    if (callRegMask & 2)
                        gcPrintf("ESI%c", (iregMask & 2) ? '\'' : ' ');
                    if (callRegMask & 4)
                        gcPrintf("EBX%c", (iregMask & 4) ? '\'' : ' ');
                    if (callRegMask & 8)
                        gcPrintf("EBP%c", (iregMask & 8) ? '\'' : ' ');
                    gcPrintf("]");

                    if (callPndTab)
                    {
                        const BYTE * offsStart = table;
                        gcPrintf(" argOffs(%d) =", callPndTabCnt);
                        for (unsigned i=0; i < callPndTabCnt; i++)
                        {
                            unsigned pndOffs;
                            table += decodeUnsigned(table, &pndOffs);
                            gcPrintf(" %4X", pndOffs);
                        }
                        assert(offsStart + callPndTabSize == table);
                        bp = table;
                    }
                    else
                    {
                        if (callPndMask)
                            gcPrintf(" argMask=%02X", callPndMask);
                        if (iargMask)
                            gcPrintf(" (iargs=%02X)", iargMask);
                    }
                    gcPrintf("\n");

                    imask = lastSkip = 0;
                    break;

                  case 5:
                    //
                    // call    1101RRRR DDCCCMMM  Call RegMask=RRRR,ArgCnt=CCC,
                    //                        ArgMask=MMM Delta=commonDelta[DD]
                    //
                    callRegMask     = val & 0xf;    // EBP,EBX,ESI,EDI
                    val             = *table++;
                    callPndMask     = (val & 0x7);
                    callArgCnt      = (val >> 3) & 0x7;
                    lastSkip        = callCommonDelta[val>>6];
                    curOffs        += lastSkip;

                    goto PRINT_CALL;

                  case 6:
                    //
                    // call    1110RRRR [ArgCnt] [ArgMask]
                    //                          Call ArgCnt,RegMask=RRR,ArgMask
                    //
                    callRegMask = val & 0xf;    // EBP,EBX,ESI,EDI
                    table += decodeUnsigned(table, &callArgCnt);
                    table += decodeUnsigned(table, &callPndMask);
                    goto PRINT_CALL;

                  case 7:
                    switch (val & 0x0C)
                    {
                    case 0x00:
                        assert(val == 0xF0);
                        /*  iptr 11110000 [IPtrMask] Arbitrary Interior Pointer Mask */
                        table += decodeUnsigned(table, &imask);
                        DumpEncoding(bp, table-bp); bp = table;
                        gcPrintf("            iptrMask = %02X\n", imask);
                        break;

                    case 0x04:
                        DumpEncoding(bp, table-bp); bp = table;
                        gcPrintf("            thisptr in %s\n", CalleeSavedRegName(val&0x3));
                        break;

                    case 0x08:
                        val             = *table++;
                        callRegMask     = val & 0xF;
                        imask           = val >> 4;
                        lastSkip        = *(DWORD*)table; table += sizeof(DWORD);
                        curOffs        += lastSkip;
                        callArgCnt      = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTabCnt   = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTabSize  = *(DWORD*)table; table += sizeof(DWORD);
                        callPndTab      = true;
                        goto PRINT_CALL;

                    case 0x0C:
                        assert(val==0xff);
                        goto DONE_REGTAB;
                        break;

                    default:
                        _ASSERTE(!"reserved GC encoding");
                        break;
                    }
                    break;
                }
            }
        }
    }

DONE_REGTAB:

    _ASSERTE(curOffs <= methodSize);

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xBEEB);

    _ASSERTE(table > bp);

    DumpEncoding(bp, table-bp);
//  gcPrintf("     ");
    gcPrintf("\n");

    return  (table - tableStart);
}


/*****************************************************************************/

void                GCDump::DumpPtrsInFrame(const void *infoBlock,
                                            const void *codeBlock,
                                            unsigned    offs,
                                            bool        verifyGCTables)
{
    const BYTE  *   table = (BYTE *)infoBlock;

    size_t          methodSize;
    size_t          stackSize;
    size_t          prologSize;
    size_t          epilogSize;
    unsigned        epilogCnt;
    BOOL            epilogEnd;
    size_t          argSize;
    BOOL            secCheck;
    BOOL            dblAlign;

    if (verifyGCTables)
        _ASSERTE(*castto(table, unsigned short *)++ == 0xFEEF);

    /* Get hold of the method size */

    table += decodeUnsigned(table, &methodSize);

    //
    // New style InfoBlk Header [briansul]
    //
    // Typically only uses one-byte to store everything.
    //
    InfoHdr header;
    BYTE headerEncoding = *table++;
    decodeHeaderFirst(headerEncoding, &header);
    BYTE encoding = headerEncoding;
    while (encoding & 0x80)
    {
        encoding = *table++;
        decodeHeaderNext(encoding, &header);
    }
    if (header.untrackedCnt == 0xffff)
    {
        unsigned count;
        table += decodeUnsigned(table, &count);
        header.untrackedCnt = count;
    }
    if (header.varPtrTableSize == 0xffff)
    {
        unsigned count;
        table += decodeUnsigned(table, &count);
        header.varPtrTableSize = count;
    }
    prologSize = header.prologSize;
    epilogSize = header.epilogSize;
    epilogCnt  = header.epilogCount;
    epilogEnd  = header.epilogAtEnd;
    secCheck   = header.security;
    dblAlign   = header.doubleAlign;
    argSize    = header.argCount * 4;
    stackSize  = header.frameSize;

#ifdef DEBUG
    if  (offs == 0)
    {
        gcPrintf("    method      size = %04X\n", methodSize);
        gcPrintf("    stack frame size = %3u \n",  stackSize);
        gcPrintf("    prolog      size = %3u \n", prologSize);
        gcPrintf("    epilog      size = %3u \n", epilogSize);
        gcPrintf("    epilog      end  = %s  \n", epilogEnd ? "yes" : "no");
        gcPrintf("    epilog     count = %3u \n", epilogCnt );
        gcPrintf("    security         = %s  \n", secCheck  ? "yes" : "no");
        gcPrintf("    dblAlign         = %s  \n", dblAlign  ? "yes" : "no");
        gcPrintf("    untracked count  = %3u \n", header.untrackedCnt);
        gcPrintf("    var ptr tab count= %3u \n", header.varPtrTableSize);
        gcPrintf("\n");
    }
#endif

    /* Are we within the prolog of the method? */

    if  (offs < prologSize)
    {
        gcPrintf("    Offset %04X is within the method's prolog\n", offs);
        return;
    }

    /* Are we within an epilog of the method? */

    if  (epilogCnt)
    {
        unsigned    eps;

        if  (epilogCnt > 1 || !epilogEnd)
        {
            if (verifyGCTables)
                _ASSERTE(*castto(table, unsigned short *)++ == 0xFACE);

            unsigned prevEps = 0;
            for (unsigned i = 0; i < epilogCnt; i++)
            {
                table += decodeUDelta(table, &eps, prevEps);

                if ((offs >= eps) && (offs <  eps + epilogSize))
                        goto EPILOG_MSG;
            }
        }
        else
        {
            eps = methodSize - epilogSize;
            if ((offs >= eps) && (offs <  eps + epilogSize))
            {
EPILOG_MSG:     gcPrintf("    Offset %04X is within the method's epilog"
                       " (%02X bytes into it)\n", offs, offs - eps);
                return;
            }
        }
    }
    gcPrintf("    Offset %04X is within the method's body\n", offs);
}

/*****************************************************************************/
#endif // _X86_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\asmman.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// asmman.cpp - manifest info handling (implementation of class AsmMan, see asmman.hpp)
//

#include "assembler.h"
#include "StrongName.h"
#include "safegetfilesize.h"

extern unsigned int g_uCodePage;
extern WCHAR *g_wzKeySourceName;
extern bool OnErrGo;
extern WCHAR		*pwzInputFiles[];

BinStr* BinStrToUnicode(BinStr* pSource)
{
    if(pSource)
    {
        pSource->appendInt8(0);
        BinStr* tmp = new BinStr();
        char*   pb = (char*)(pSource->ptr());
        int l=pSource->length(), L = sizeof(WCHAR)*l;
		if(tmp)
		{
			WCHAR*  wz = (WCHAR*)(tmp->getBuff(L));
			if(wz)
			{
				memset(wz,0,L);
				WszMultiByteToWideChar(g_uCodePage,0,pb,-1,wz,l);
				tmp->remove(L-(DWORD)wcslen(wz)*sizeof(WCHAR));
				delete pSource;
			}
			else
			{
				delete tmp;
				tmp = NULL;
				fprintf(stderr,"\nOut of memory!\n");
			}
		}
		else
			fprintf(stderr,"\nOut of memory!\n");
        return tmp;
    }
    return NULL;
}

AsmManFile*         AsmMan::GetFileByName(char* szFileName)
{
    AsmManFile* ret = NULL;
    if(szFileName)
    {
        for(int i=0; (ret = m_FileLst.PEEK(i))&&strcmp(ret->szName,szFileName); i++);
    }
    return ret;
}

mdToken             AsmMan::GetFileTokByName(char* szFileName)
{
    AsmManFile* tmp = GetFileByName(szFileName);
    return(tmp ? tmp->tkTok : mdFileNil);
}

AsmManComType*          AsmMan::GetComTypeByName(char* szComTypeName)
{
    AsmManComType*  ret = NULL;
    if(szComTypeName)
    {
        for(int i=0; (ret = m_ComTypeLst.PEEK(i))&&strcmp(ret->szName,szComTypeName); i++);
    }
    return ret;
}

mdToken             AsmMan::GetComTypeTokByName(char* szComTypeName)
{
    AsmManComType* tmp = GetComTypeByName(szComTypeName);
    return(tmp ? tmp->tkTok : mdExportedTypeNil);
}

AsmManAssembly*     AsmMan::GetAsmRefByName(char* szAsmRefName)
{
    AsmManAssembly* ret = NULL;
    if(szAsmRefName)
    {
        for(int i=0; (ret = m_AsmRefLst.PEEK(i))&&strcmp(ret->szAlias,szAsmRefName); i++);
    }
    return ret;
}
mdToken             AsmMan::GetAsmRefTokByName(char* szAsmRefName)
{
    AsmManAssembly* tmp = GetAsmRefByName(szAsmRefName);
    return(tmp ? tmp->tkTok : mdAssemblyRefNil);
}
//==============================================================================================================
void    AsmMan::SetModuleName(char* szName)
{
	if(m_szScopeName == NULL)	// ignore all duplicate declarations
	{
		WCHAR                   wzBuff[MAX_SCOPE_LENGTH];
		wzBuff[0] = 0;
		if(szName && *szName)
		{
			ULONG L = strlen(szName);
			if(L >= MAX_SCOPE_LENGTH)
			{
				((Assembler*)m_pAssembler)->report->warn("Module name too long (%d chars, max.allowed: %d chars), truncated\n",L,MAX_SCOPE_LENGTH-1);
				szName[MAX_SCOPE_LENGTH-1] = 0;
			}
			m_szScopeName = szName;
			strcpy(((Assembler*)m_pAssembler)->m_szScopeName,szName);
			WszMultiByteToWideChar(g_uCodePage,0,m_szScopeName,-1,wzBuff,MAX_SCOPE_LENGTH);
		}
		m_pEmitter->SetModuleProps(wzBuff);
	}
}
//==============================================================================================================
// Borrowed from VM\assembly.cpp

HRESULT GetHash(LPWSTR moduleName,
                          ALG_ID iHashAlg,
                          BYTE** pbCurrentValue,  // should be NULL
                          DWORD *cbCurrentValue)
{
    HRESULT     hr = E_FAIL;
    HCRYPTPROV  hProv = 0;
    HCRYPTHASH  hHash = 0;
    DWORD       dwCount = sizeof(DWORD);
    PBYTE       pbBuffer = NULL;
    DWORD       dwBufferLen;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hMapFile = NULL;
    
    hFile = WszCreateFile(moduleName, GENERIC_READ, FILE_SHARE_READ,
                         0, OPEN_EXISTING, 0, 0);
    if (hFile == INVALID_HANDLE_VALUE) return E_FAIL;

    dwBufferLen = SafeGetFileSize(hFile,NULL);
    if (dwBufferLen == 0xffffffff)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    hMapFile = WszCreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMapFile == NULL) goto exit;

    pbBuffer = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (pbBuffer == NULL) goto exit;

    // No need to late bind this stuff, all these crypto API entry points happen
    // to live in ADVAPI32.

    if ((!WszCryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
        (!CryptCreateHash(hProv, iHashAlg, 0, 0, &hHash)) ||
        (!CryptHashData(hHash, pbBuffer, dwBufferLen, 0)) ||
        (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *) cbCurrentValue, 
                            &dwCount, 0))) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    *pbCurrentValue = new BYTE[*cbCurrentValue];
    if (!(*pbCurrentValue)) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(!CryptGetHashParam(hHash, HP_HASHVAL, *pbCurrentValue, cbCurrentValue, 0)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        delete[] *pbCurrentValue;
        *pbCurrentValue = 0;
        goto exit;
    }

    hr = S_OK;

 exit:
    if (pbBuffer) UnmapViewOfFile(pbBuffer);
    if (hMapFile) CloseHandle(hMapFile); 
    CloseHandle(hFile);
    if (hHash)
        CryptDestroyHash(hHash);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return hr;
}
//==============================================================================================================

void    AsmMan::AddFile(char* szName, DWORD dwAttr, BinStr* pHashBlob)
{
    AsmManFile* tmp = GetFileByName(szName);
	Assembler* pAsm = (Assembler*)m_pAssembler;
	if(tmp==NULL)
	{
		tmp = new AsmManFile;
		if(tmp==NULL)
		{
			pAsm->report->error("\nOut of memory!\n");
			return;
		}
		memset(tmp,0,sizeof(AsmManFile));
		BOOL    fEntry = ((dwAttr & 0x80000000)!=0);
		dwAttr &= 0x7FFFFFFF;
		tmp->szName = szName;
		tmp->dwAttr = dwAttr;
		tmp->pHash = pHashBlob;
		{ // emit the file
			WCHAR                   wzBuff[2048];
			HRESULT                 hr = S_OK;

			wzBuff[0] = 0;

			if(m_pAsmEmitter==NULL)
				hr=m_pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &m_pAsmEmitter);

			if(SUCCEEDED(hr))
			{
				BYTE*       pHash=NULL;
				DWORD       cbHash= 0;

				WszMultiByteToWideChar(g_uCodePage,0,szName,-1,wzBuff,2048);
				if(pHashBlob==NULL) // if hash not explicitly specified
				{
					if(m_pAssembly      // and assembly is defined
						&& m_pAssembly->ulHashAlgorithm) // and hash algorithm is defined...
					{ // then try to compute it
						if(FAILED(GetHash(wzBuff,(ALG_ID)(m_pAssembly->ulHashAlgorithm),&pHash,&cbHash)))
						{
							pHash = NULL;
							cbHash = 0;
						}
						else
						{
							tmp->pHash = new BinStr(pHash,cbHash);
						}
					}
				}
				else 
				{
					pHash = pHashBlob->ptr();
					cbHash = pHashBlob->length();
				}

				hr = m_pAsmEmitter->DefineFile(wzBuff,
											(const void*)pHash,
											cbHash,
											dwAttr,
											(mdFile*)&(tmp->tkTok));
				if(FAILED(hr)) report->error("Failed to define file '%s': 0x%08X\n",szName,hr);
				else if(fEntry)
				{
					if(!pAsm->m_fEntryPointPresent)
					{
						pAsm->m_fEntryPointPresent = TRUE;
						if (FAILED(pAsm->m_pCeeFileGen->SetEntryPoint(pAsm->m_pCeeFile, tmp->tkTok)))
						{
							pAsm->report->error("Failed to set external entry point for file '%s'\n",szName);
						}
					}
				}
			}
			else 
				report->error("Failed to obtain IMetaDataAssemblyEmit interface: 0x%08X\n",hr);
		}
		m_FileLst.PUSH(tmp);
	}
	pAsm->m_tkCurrentCVOwner = 0;
	if(tmp) pAsm->m_pCustomDescrList = &(tmp->m_CustomDescrList);
}

void    AsmMan::StartAssembly(char* szName, char* szAlias, DWORD dwAttr, BOOL isRef)
{
    if(!isRef && (m_pAssembly != NULL))
    {
		if(strcmp(szName, m_pAssembly->szName))
			report->error("Multiple assembly declarations\n");
		// if name is the same, just ignore it
		m_pCurAsmRef = NULL;
    }
    else
    {
        if(m_pCurAsmRef = new AsmManAssembly)
        {
            memset(m_pCurAsmRef,0,sizeof(AsmManAssembly));
            m_pCurAsmRef->szName = szName;
            m_pCurAsmRef->szAlias = szAlias ? szAlias : szName;
            m_pCurAsmRef->dwAttr = dwAttr;
            m_pCurAsmRef->isRef = isRef;
            ((Assembler*)m_pAssembler)->m_tkCurrentCVOwner = 0;
            ((Assembler*)m_pAssembler)->m_pCustomDescrList = &(m_pCurAsmRef->m_CustomDescrList);
            if(!isRef) m_pAssembly = m_pCurAsmRef;
        }
        else
            report->error("Failed to allocate AsmManAssembly structure\n");
    }
}
// copied from asmparse.y
static void corEmitInt(BinStr* buff, unsigned data) 
{
    unsigned cnt = CorSigCompressData(data, buff->getBuff(5));
    buff->remove(5 - cnt);
}

void AsmMan::EmitDebuggableAttribute(mdToken tkOwner, BOOL bIsMscorlib)
{
    mdToken tkCA;
    Assembler* pAsm = (Assembler*)m_pAssembler;
    BinStr  *pbsTypeSpec = new BinStr();
    BinStr  *pbsSig = new BinStr();
    BinStr  bsSigArg;
    BinStr  bsBytes;
    unsigned len;
    char*   sz;
    char*   szName;

    sz = bIsMscorlib ? "System.Diagnostics.DebuggableAttribute"
        : "mscorlib^System.Diagnostics.DebuggableAttribute";
    pbsTypeSpec->appendInt8(ELEMENT_TYPE_NAME);
    len = (unsigned int)strlen(sz)+1;
    memcpy(pbsTypeSpec->getBuff(len), sz, len);
    bsSigArg.appendInt8(ELEMENT_TYPE_BOOLEAN);
    bsSigArg.appendInt8(ELEMENT_TYPE_BOOLEAN);
    
    pbsSig->appendInt8(IMAGE_CEE_CS_CALLCONV_HASTHIS);
    corEmitInt(pbsSig,2);
    pbsSig->appendInt8(ELEMENT_TYPE_VOID);
    pbsSig->append(&bsSigArg);

    bsBytes.appendInt8(1);
    bsBytes.appendInt8(0);
    bsBytes.appendInt8(1);
    bsBytes.appendInt8(1);
    bsBytes.appendInt8(0);
    bsBytes.appendInt8(0);

    szName = new char[16];
    strcpy(szName,".ctor");
    tkCA = pAsm->MakeMemberRef(pbsTypeSpec,szName,pbsSig,0);
    pAsm->DefineCV(tkOwner,tkCA,&bsBytes);
}
void    AsmMan::EndAssembly()
{
    if(m_pCurAsmRef)
    {
        if(m_pCurAsmRef->isRef)
        { // emit the assembly ref
            WCHAR                   wzBuff[2048];
            HRESULT                 hr = S_OK;

            wzBuff[0] = 0;
            if(GetAsmRefByName(m_pCurAsmRef->szAlias))
            {
                //report->warn("Multiple declarations of Assembly Ref '%s', ignored except the 1st one\n",m_pCurAsmRef->szName);
                delete m_pCurAsmRef;
                m_pCurAsmRef = NULL;
                return;
            }
            if(m_pAsmEmitter==NULL)
                hr=m_pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &m_pAsmEmitter);
            if(SUCCEEDED(hr))
            {
                // Fill ASSEMBLYMETADATA structure
                ASSEMBLYMETADATA md;
                md.usMajorVersion = m_pCurAsmRef->usVerMajor;
                md.usMinorVersion = m_pCurAsmRef->usVerMinor;
                md.usBuildNumber = m_pCurAsmRef->usBuild;
                md.usRevisionNumber = m_pCurAsmRef->usRevision;
                md.szLocale = m_pCurAsmRef->pLocale ? (LPWSTR)(m_pCurAsmRef->pLocale->ptr()) : NULL;
                md.cbLocale = m_pCurAsmRef->pLocale ? m_pCurAsmRef->pLocale->length()/sizeof(WCHAR) : 0;

                md.rProcessor = NULL;
                md.rOS = NULL;
                md.ulProcessor = 0;
                md.ulOS = 0;

                // See if we've got a full public key or the tokenized version (or neither).
                BYTE *pbPublicKeyOrToken = NULL;
                DWORD cbPublicKeyOrToken = 0;
                DWORD dwFlags = m_pCurAsmRef->dwAttr;
                if (m_pCurAsmRef->pPublicKeyToken)
                {
                    pbPublicKeyOrToken = m_pCurAsmRef->pPublicKeyToken->ptr();
                    cbPublicKeyOrToken = m_pCurAsmRef->pPublicKeyToken->length();
                    
                }
                else if (m_pCurAsmRef->pPublicKey)
                {
                    pbPublicKeyOrToken = m_pCurAsmRef->pPublicKey->ptr();
                    cbPublicKeyOrToken = m_pCurAsmRef->pPublicKey->length();
                    dwFlags |= afPublicKey;
                }
                // Convert name to Unicode
                WszMultiByteToWideChar(g_uCodePage,0,m_pCurAsmRef->szName,-1,wzBuff,2048);
                hr = m_pAsmEmitter->DefineAssemblyRef(           // S_OK or error.
                            pbPublicKeyOrToken,              // [IN] Public key or token of the assembly.
                            cbPublicKeyOrToken,              // [IN] Count of bytes in the key or token.
                            (LPCWSTR)wzBuff,                 // [IN] Name of the assembly being referenced.
                            (const ASSEMBLYMETADATA*)&md,  // [IN] Assembly MetaData.
                            (m_pCurAsmRef->pHashBlob ? (const void*)(m_pCurAsmRef->pHashBlob->ptr()) : NULL),           // [IN] Hash Blob.
                            (m_pCurAsmRef->pHashBlob ? m_pCurAsmRef->pHashBlob->length() : 0),            // [IN] Count of bytes in the Hash Blob.
                            dwFlags,     // [IN] Flags.
                            (mdAssemblyRef*)&(m_pCurAsmRef->tkTok));         // [OUT] Returned AssemblyRef token.
                if(FAILED(hr)) report->error("Failed to define assembly ref '%s': 0x%08X\n",m_pCurAsmRef->szName,hr);
                else
                {
                    ((Assembler*)m_pAssembler)->EmitCustomAttributes(m_pCurAsmRef->tkTok, &(m_pCurAsmRef->m_CustomDescrList));
                }
            }
            else 
                report->error("Failed to obtain IMetaDataAssemblyEmit interface: 0x%08X\n",hr);

            m_AsmRefLst.PUSH(m_pCurAsmRef);
        }
        else
        { // emit the assembly
            WCHAR                   wzBuff[2048];
            HRESULT                 hr = S_OK;

            wzBuff[0] = 0;

            if(m_pAsmEmitter==NULL)
                hr=m_pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &m_pAsmEmitter);
            if(SUCCEEDED(hr))
            {
                // Fill ASSEMBLYMETADATA structure
                ASSEMBLYMETADATA md;
                md.usMajorVersion = m_pAssembly->usVerMajor;
                md.usMinorVersion = m_pAssembly->usVerMinor;
                md.usBuildNumber = m_pAssembly->usBuild;
                md.usRevisionNumber = m_pAssembly->usRevision;
                md.szLocale = m_pAssembly->pLocale ? (LPWSTR)(m_pAssembly->pLocale->ptr()) : NULL;
                md.cbLocale = m_pAssembly->pLocale ? m_pAssembly->pLocale->length()/sizeof(WCHAR) : 0;

                md.rProcessor = NULL;
                md.rOS = NULL;
                md.ulProcessor = 0;
                md.ulOS = 0;

                // Convert name to Unicode
                WszMultiByteToWideChar(g_uCodePage,0,m_pAssembly->szName,-1,wzBuff,2048);

                // Determine the strong name public key. This may have been set
                // via a directive in the source or from the command line (which
                // overrides the directive). From the command line we may have
                // been provided with a file or the name of a CAPI key
                // container. Either may contain a public key or a full key
                // pair.
                if (g_wzKeySourceName)
                {
                    // Key file versus container is determined by the first
                    // character of the source ('@' for container).
                    if (*g_wzKeySourceName == L'@')
                    {
                        // Extract public key from container (works whether
                        // container has just a public key or an entire key
                        // pair).
                        m_sStrongName.m_wzKeyContainer = &g_wzKeySourceName[1];
                        if (!StrongNameGetPublicKey(m_sStrongName.m_wzKeyContainer,
                                                    NULL,
                                                    0,
                                                    &m_sStrongName.m_pbPublicKey,
                                                    &m_sStrongName.m_cbPublicKey))
                        {
                            hr = StrongNameErrorInfo();
                            report->error("Failed to extract public key from '%S': 0x%08X\n",m_sStrongName.m_wzKeyContainer,hr);
                            m_pCurAsmRef = NULL;
                            return;
                        }
                        m_sStrongName.m_fFullSign = TRUE;
                        m_sStrongName.m_dwPublicKeyAllocated = 1;
                    }
                    else
                    {
                        // Read public key or key pair from file.
                        HANDLE hFile = WszCreateFile(g_wzKeySourceName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                     NULL);
                        if(hFile == INVALID_HANDLE_VALUE)
                        {
                            hr = GetLastError();
                            report->error("Failed to open key file '%S': 0x%08X\n",g_wzKeySourceName,hr);
                            m_pCurAsmRef = NULL;
                            return;
                        }

                        // Determine file size and allocate an appropriate buffer.
                        m_sStrongName.m_cbPublicKey = SafeGetFileSize(hFile, NULL);
                        if (m_sStrongName.m_cbPublicKey == 0xffffffff) {
                            report->error("File size too large\n");
                            m_pCurAsmRef = NULL;
                            return;
                        }

                        m_sStrongName.m_pbPublicKey = new BYTE[m_sStrongName.m_cbPublicKey];
                        if (m_sStrongName.m_pbPublicKey == NULL) {
                            report->error("Failed to allocate key buffer\n");
                            m_pCurAsmRef = NULL;
                            return;
                        }
                        m_sStrongName.m_dwPublicKeyAllocated = 2;

                        // Read the file into the buffer.
                        DWORD dwBytesRead;
                        if (!ReadFile(hFile, m_sStrongName.m_pbPublicKey, m_sStrongName.m_cbPublicKey, &dwBytesRead, NULL)) {
                            hr = GetLastError();
                            report->error("Failed to read key file '%S': 0x%08X\n",g_wzKeySourceName,hr);
                            m_pCurAsmRef = NULL;
                            return;
                        }

                        CloseHandle(hFile);

                        // Guess whether we're full or delay signing based on
                        // whether the blob passed to us looks like a public
                        // key. (I.e. we may just have copied a full key pair
                        // into the public key buffer).
                        if (m_sStrongName.m_cbPublicKey >= sizeof(PublicKeyBlob) &&
                            (offsetof(PublicKeyBlob, PublicKey) +
                             ((PublicKeyBlob*)m_sStrongName.m_pbPublicKey)->cbPublicKey) == m_sStrongName.m_cbPublicKey)
                            m_sStrongName.m_fFullSign = FALSE;
                        else
                            m_sStrongName.m_fFullSign = TRUE;

                        // If we really have a key pair, we'll move it into a
                        // key container so the signing code gets the key pair
                        // from a consistent place.
                        if (m_sStrongName.m_fFullSign)
                        {

                            // Create a temporary key container name.
                            m_sStrongName.m_wzKeyContainer = m_sStrongName.m_wzKeyContainerBuffer;
                            swprintf(m_sStrongName.m_wzKeyContainer,
                                     L"__ILASM__%08X__",
                                     GetCurrentProcessId());

                            // Delete any stale container.
                            StrongNameKeyDelete(m_sStrongName.m_wzKeyContainer);

                            // Populate the container with the key pair.
                            if (!StrongNameKeyInstall(m_sStrongName.m_wzKeyContainer,
                                                      m_sStrongName.m_pbPublicKey,
                                                      m_sStrongName.m_cbPublicKey))
                            {
                                hr = StrongNameErrorInfo();
                                report->error("Failed to install key into '%S': 0x%08X\n",m_sStrongName.m_wzKeyContainer,hr);
                                m_pCurAsmRef = NULL;
                                return;
                            }

                            // Retrieve the public key portion as a byte blob.
                            if (!StrongNameGetPublicKey(m_sStrongName.m_wzKeyContainer,
                                                        NULL,
                                                        0,
                                                        &m_sStrongName.m_pbPublicKey,
                                                        &m_sStrongName.m_cbPublicKey))
                            {
                                hr = StrongNameErrorInfo();
                                report->error("Failed to extract public key from '%S': 0x%08X\n",m_sStrongName.m_wzKeyContainer,hr);
                                m_pCurAsmRef = NULL;
                                return;
                            }
                        }
                    }
                }
                else if (m_pAssembly->pPublicKey)
                {
                    m_sStrongName.m_pbPublicKey = m_pAssembly->pPublicKey->ptr();
                    m_sStrongName.m_cbPublicKey = m_pAssembly->pPublicKey->length();
                    m_sStrongName.m_wzKeyContainer = NULL;
                    m_sStrongName.m_fFullSign = FALSE;
                    m_sStrongName.m_dwPublicKeyAllocated = 0;
                }
                else
                {
                    m_sStrongName.m_pbPublicKey = NULL;
                    m_sStrongName.m_cbPublicKey = 0;
                    m_sStrongName.m_wzKeyContainer = NULL;
                    m_sStrongName.m_fFullSign = FALSE;
                    m_sStrongName.m_dwPublicKeyAllocated = 0;
                }

                hr = m_pAsmEmitter->DefineAssembly(              // S_OK or error.
                    (const void*)(m_sStrongName.m_pbPublicKey), // [IN] Public key of the assembly.
                    m_sStrongName.m_cbPublicKey,                // [IN] Count of bytes in the public key.
                    m_pAssembly->ulHashAlgorithm,            // [IN] Hash algorithm used to hash the files.
                    (LPCWSTR)wzBuff,                 // [IN] Name of the assembly.
                    (const ASSEMBLYMETADATA*)&md,  // [IN] Assembly MetaData.
                    m_pAssembly->dwAttr,        // [IN] Flags.
                    (mdAssembly*)&(m_pAssembly->tkTok));             // [OUT] Returned Assembly token.

                if(FAILED(hr)) report->error("Failed to define assembly '%s': 0x%08X\n",m_pAssembly->szName,hr);
                else
                {
                    Assembler* pAsm = ((Assembler*)m_pAssembler);
                    pAsm->EmitSecurityInfo(m_pAssembly->tkTok,
                                         m_pAssembly->m_pPermissions,
                                         m_pAssembly->m_pPermissionSets);
                    if(pAsm->m_fIncludeDebugInfo)
                    {
                        EmitDebuggableAttribute(m_pAssembly->tkTok,
                            (_stricmp(m_pAssembly->szName,"mscorlib")== 0));
                    }
                    pAsm->EmitCustomAttributes(m_pAssembly->tkTok, &(m_pAssembly->m_CustomDescrList));
                }
            }
            else 
                report->error("Failed to obtain IMetaDataAssemblyEmit interface: 0x%08X\n",hr);
        }
        m_pCurAsmRef = NULL;
    }
}

void    AsmMan::SetAssemblyPublicKey(BinStr* pPublicKey)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->pPublicKey = pPublicKey;
    }
}

void    AsmMan::SetAssemblyPublicKeyToken(BinStr* pPublicKeyToken)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->pPublicKeyToken = pPublicKeyToken;
    }
}

void    AsmMan::SetAssemblyHashAlg(ULONG ulAlgID)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->ulHashAlgorithm = ulAlgID;
    }
}

void    AsmMan::SetAssemblyVer(USHORT usMajor, USHORT usMinor, USHORT usBuild, USHORT usRevision)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->usVerMajor = usMajor;
        m_pCurAsmRef->usVerMinor = usMinor;
        m_pCurAsmRef->usBuild = usBuild;
        m_pCurAsmRef->usRevision = usRevision;
    }
}

void    AsmMan::SetAssemblyLocale(BinStr* pLocale, BOOL bConvertToUnicode)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->pLocale = bConvertToUnicode ? ::BinStrToUnicode(pLocale) : pLocale;
    }
}

void    AsmMan::SetAssemblyHashBlob(BinStr* pHashBlob)
{
    if(m_pCurAsmRef)
    {
        m_pCurAsmRef->pHashBlob = pHashBlob;
    }
}

void    AsmMan::StartComType(char* szName, DWORD dwAttr)
{
	if(GetComTypeByName(szName)) m_pCurComType = NULL;
	else
	{
		if(m_pCurComType = new AsmManComType)
		{
			memset(m_pCurComType,0,sizeof(AsmManComType));
			m_pCurComType->szName = szName;
			m_pCurComType->dwAttr = dwAttr;
			((Assembler*)m_pAssembler)->m_tkCurrentCVOwner = 0;
			((Assembler*)m_pAssembler)->m_pCustomDescrList = &(m_pCurComType->m_CustomDescrList);
		}
		else
			report->error("Failed to allocate AsmManComType structure\n");
	}
}

void    AsmMan::EndComType()
{
    if(m_pCurComType)
    {
        if(m_pAssembler)
        { 
            Class* pClass =((Assembler*)m_pAssembler)->m_pCurClass;
            if(pClass)
            {
                m_pCurComType->tkClass = pClass->m_cl;
                if(pClass->m_pEncloser)
                {
                    mdTypeDef tkEncloser = pClass->m_pEncloser->m_cl;
                    AsmManComType* pCT;
                    for(unsigned i=0; pCT=m_ComTypeLst.PEEK(i); i++)
                    {
                        if(pCT->tkClass == tkEncloser)
                        {
                            m_pCurComType->szComTypeName = pCT->szName;
                            break;
                        }
                    }
                }
            }
        }
        m_ComTypeLst.PUSH(m_pCurComType);
        m_pCurComType = NULL;
    }
}

void    AsmMan::SetComTypeFile(char* szFileName)
{
    if(m_pCurComType)
    {
        m_pCurComType->szFileName = szFileName;
    }
}

void    AsmMan::SetComTypeComType(char* szComTypeName)
{
    if(m_pCurComType)
    {
        m_pCurComType->szComTypeName = szComTypeName;
    }
}

void    AsmMan::SetComTypeClassTok(mdToken tkClass)
{
    if(m_pCurComType)
    {
        m_pCurComType->tkClass = tkClass;
    }
}

void    AsmMan::StartManifestRes(char* szName, DWORD dwAttr)
{
    if(m_pCurManRes = new AsmManRes)
    {
        memset(m_pCurManRes,0,sizeof(AsmManRes));
        m_pCurManRes->szName = szName;
        m_pCurManRes->dwAttr = dwAttr;
        ((Assembler*)m_pAssembler)->m_tkCurrentCVOwner = 0;
        ((Assembler*)m_pAssembler)->m_pCustomDescrList = &(m_pCurManRes->m_CustomDescrList);
    }
    else
        report->error("Failed to allocate AsmManRes structure\n");
}

void    AsmMan::EndManifestRes()
{
    if(m_pCurManRes)
    {
        m_ManResLst.PUSH(m_pCurManRes);
        m_pCurManRes = NULL;
    }
}


void    AsmMan::SetManifestResFile(char* szFileName, ULONG ulOffset)
{
    if(m_pCurManRes)
    {
        m_pCurManRes->szFileName = szFileName;
        m_pCurManRes->ulOffset = ulOffset;
    }
}

void    AsmMan::SetManifestResAsmRef(char* szAsmRefName)
{
    if(m_pCurManRes)
    {
        m_pCurManRes->szAsmRefName = szAsmRefName;
    }
}

HRESULT AsmMan::EmitManifest()
{
    WCHAR                   wzBuff[2048];
    AsmManFile*             pFile;
    //AsmManAssembly*           pAsmRef;
    AsmManComType*          pComType;
    AsmManRes*              pManRes;
    HRESULT                 hr = S_OK;

    wzBuff[0] = 0;

    if(m_pAsmEmitter==NULL)
        hr=m_pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &m_pAsmEmitter);

    if(SUCCEEDED(hr))
    {
        // Emit all files
        for(unsigned i=0; pFile = m_FileLst.PEEK(i); i++)
        {
            if(RidFromToken(pFile->tkTok))
            {
                ((Assembler*)m_pAssembler)->EmitCustomAttributes(pFile->tkTok, &(pFile->m_CustomDescrList));
            }

        }
        // Assembly and AssemblyRefs are already emitted
        if(((Assembler*)m_pAssembler)->m_fIncludeDebugInfo && (m_pAssembly == NULL))
        {
            mdToken tkOwner;
            BinStr  *pbsTypeSpec = new BinStr();
            unsigned len;
            char*   sz;

            sz = "mscorlib^System.Runtime.CompilerServices.AssemblyAttributesGoHere";
            pbsTypeSpec->appendInt8(ELEMENT_TYPE_NAME);
            len = (unsigned int)strlen(sz)+1;
            memcpy(pbsTypeSpec->getBuff(len), sz, len);

            tkOwner = ((Assembler*)m_pAssembler)->MakeTypeRef(pbsTypeSpec);

            EmitDebuggableAttribute(tkOwner,FALSE);
        }

        // Emit all com types
        for(i = 0; pComType = m_ComTypeLst.PEEK(i); i++)
        {
            WszMultiByteToWideChar(g_uCodePage,0,pComType->szName,-1,wzBuff,2048);
            mdToken     tkImplementation = mdTokenNil;
            if(pComType->szFileName)
            {
                tkImplementation = GetFileTokByName(pComType->szFileName);
                if(tkImplementation==mdFileNil)
                {
                    report->error("Undefined File '%s' in ExportedType '%s'\n",pComType->szFileName,pComType->szName);
                    if(!OnErrGo) continue;
                }
            }
            else if(pComType->szComTypeName)
            {
                tkImplementation = GetComTypeTokByName(pComType->szComTypeName);
                if(tkImplementation==mdExportedTypeNil)
                {
                    report->error("Undefined ExportedType '%s' in ExportedType '%s'\n",pComType->szComTypeName,pComType->szName);
                    if(!OnErrGo) continue;
                }
            }
            else 
            {
                report->warn("Undefined implementation in ExportedType '%s' -- ExportType not emitted\n",pComType->szName);
                if(!OnErrGo) continue;
            }
            hr = m_pAsmEmitter->DefineExportedType(               // S_OK or error.
                    (LPCWSTR)wzBuff,                 // [IN] Name of the Com Type.
                    tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ComType.
                    (mdTypeDef)pComType->tkClass,              // [IN] TypeDef token within the file.
                    pComType->dwAttr,         // [IN] Flags.
                    (mdExportedType*)&(pComType->tkTok));           // [OUT] Returned ComType token.
            if(FAILED(hr)) report->error("Failed to define ExportedType '%s': 0x%08X\n",pComType->szName,hr);
            else
            {
                ((Assembler*)m_pAssembler)->EmitCustomAttributes(pComType->tkTok, &(pComType->m_CustomDescrList));
            }
        }

        // Emit all manifest resources
        for(i = 0; pManRes = m_ManResLst.PEEK(i); i++)
        {
			BOOL fOK = TRUE;
            mdToken     tkImplementation = mdFileNil;
            WszMultiByteToWideChar(g_uCodePage,0,pManRes->szName,-1,wzBuff,2048);
			if(pManRes->szAsmRefName)
			{
				tkImplementation = GetAsmRefTokByName(pManRes->szAsmRefName);
				if(RidFromToken(tkImplementation)==0)
				{
                    report->error("Undefined AssemblyRef '%s' in MResource '%s'\n",pManRes->szAsmRefName,pManRes->szName);
					fOK = FALSE;
				}
			}
			else if(pManRes->szFileName)
			{
				tkImplementation = GetFileTokByName(pManRes->szFileName);
				if(RidFromToken(tkImplementation)==0)
				{
                    report->error("Undefined File '%s' in MResource '%s'\n",pManRes->szFileName,pManRes->szName);
					fOK = FALSE;
				}
			}
            else // embedded mgd.resource, go after the file
            {
                pManRes->ulOffset = m_dwMResSizeTotal;
                HANDLE hFile = INVALID_HANDLE_VALUE;
                int i;
                WCHAR  wzFileName[2048];
                WCHAR* pwz;

                for(i=0;(hFile==INVALID_HANDLE_VALUE)&&(pwzInputFiles[i]!=NULL);i++)
                {
                    wcscpy(wzFileName,pwzInputFiles[i]);
                    pwz = wcsrchr(wzFileName,'\\');
                    if(pwz==NULL) pwz = wcsrchr(wzFileName,':');
                    if(pwz==NULL) pwz = &wzFileName[0];
                    else pwz++;
                    wcscpy(pwz,wzBuff);
                    hFile = WszCreateFile(wzFileName, GENERIC_READ, FILE_SHARE_READ,
                                 0, OPEN_EXISTING, 0, 0);
                }
                
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    report->error("Failed to open managed resource file '%s'\n",pManRes->szName);
					fOK = FALSE;
                }
                else
                {
                    m_dwMResSize[m_dwMResNum] = SafeGetFileSize(hFile,NULL);
                    if(m_dwMResSize[m_dwMResNum] == 0xFFFFFFFF)
                    {
                        report->error("Failed to get size of managed resource file '%s'\n",pManRes->szName);
						fOK = FALSE;
                    }
                    else 
                    {
                        m_dwMResSizeTotal += m_dwMResSize[m_dwMResNum]+sizeof(DWORD);
                        m_wzMResName[m_dwMResNum] = new WCHAR[wcslen(wzFileName)+1];
                        wcscpy(m_wzMResName[m_dwMResNum],wzFileName);
                        m_dwMResNum++;
                    }
                    CloseHandle(hFile);
                }
            }
			if(fOK || OnErrGo)
			{
				hr = m_pAsmEmitter->DefineManifestResource(      // S_OK or error.
						(LPCWSTR)wzBuff,                 // [IN] Name of the resource.
						tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
						pManRes->ulOffset,               // [IN] Offset to the beginning of the resource within the file.
						pManRes->dwAttr,        // [IN] Flags.
						(mdManifestResource*)&(pManRes->tkTok));   // [OUT] Returned ManifestResource token.
				if(FAILED(hr))
					report->error("Failed to define manifest resource '%s': 0x%08X\n",pManRes->szName,hr);
			}
        }


        m_pAsmEmitter->Release();
        m_pAsmEmitter = NULL;
    }
    else 
        report->error("Failed to obtain IMetaDataAssemblyEmit interface: 0x%08X\n",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\asmparse.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* asmParse is basically a wrapper around a YACC grammer COM+ assembly  */

#ifndef asmparse_h
#define asmparse_h

#include <stdio.h>		// for FILE

#include "Assembler.h"	// for ErrorReporter Labels 
//class Assembler;
//class BinStr;


/**************************************************************************/
/* an abstraction of a stream of input characters */
class ReadStream {
public:
        // read at most 'buffLen' bytes into 'buff', Return the
        // number of characters read.  On EOF return 0
    virtual unsigned read(char* buff, unsigned buffLen) = 0;
        
        // Return the name of the stream, (for error reporting).  
    virtual const char* name() = 0;
		//return ptr to buffer containing specified source line
	virtual char* getLine(int lineNum) = 0;
};

/**************************************************************************/
class FileReadStream : public ReadStream {
public:
    FileReadStream(char* aFileName) 
    {
        fileName = aFileName;
		strcpy(fileNameANSI,fileName);
		fileNameW = NULL;
        file = fopen(fileName, "rb"); 
    }
    FileReadStream(WCHAR* wFileName) 
    {
        fileNameW = wFileName;
		fileName = NULL;
		memset(fileNameANSI,0,MAX_FILENAME_LENGTH*3);
		WszWideCharToMultiByte(CP_ACP,0,wFileName,-1,fileNameANSI,MAX_FILENAME_LENGTH*3,NULL,NULL);
        file = _wfopen(wFileName, L"rb"); 
    }

    unsigned read(char* buff, unsigned buffLen) 
    {
        _ASSERTE(file != NULL);
        return((unsigned int)fread(buff, 1, buffLen, file));
    }

    const char* name() 
    { 
        return(&fileNameANSI[0]); 
    }

    BOOL IsValid()
    {
        return(file != NULL); 
    }
    
	char* getLine(int lineNum)
	{
		char* buf = new char[65535];
		FILE* F;
		if (fileName) F = fopen(fileName,"rt");
		else F = _wfopen(fileNameW,L"rt");
		for(int i=0; i<lineNum; i++) fgets(buf,65535,F);
		fclose(F);
		return buf;
	}

private:
    const char* fileName;       // FileName (for error reporting)
    const WCHAR* fileNameW;     // FileName (for error reporting)
	char	fileNameANSI[MAX_FILENAME_LENGTH*3];
    FILE* file;                 // File we are reading from
};

/**************************************************************************/
/* AsmParse does all the parsing.  It also builds up simple data structures,  
   (like signatures), but does not do the any 'heavy lifting' like define
   methods or classes.  Instead it calls to the Assembler object to do that */

class AsmParse : public ErrorReporter 
{
public:
    AsmParse(ReadStream* stream, Assembler *aAssem);
    ~AsmParse();
	void ParseFile(ReadStream* stream) { in = stream; m_bFirstRead = true; m_iReadSize = IN_READ_SIZE/4; curLine = 1; yyparse(); in = NULL; }

        // The parser knows how to put line numbers on things and report the error 
    virtual void error(char* fmt, ...);
    virtual void warn(char* fmt, ...);
    virtual void msg(char* fmt, ...);
	char *getLine(int lineNum) { return in->getLine(lineNum); };
	bool Success() {return success; };

    unsigned curLine;           // Line number (for error reporting)

private:
    BinStr* MakeSig(unsigned callConv, BinStr* retType, BinStr* args);
    BinStr* MakeTypeClass(CorElementType kind, char* name);
    BinStr* MakeTypeArray(BinStr* elemType, BinStr* bounds);

    char* fillBuff(char* curPos);   // refill the input buffer 
	HANDLE	hstdout;
	HANDLE	hstderr;

private:
	friend void yyerror(char* str);
    friend int yyparse();
    friend int yylex();

	Assembler* assem;			// This does most of the semantic processing

        // Error reporting support
    char* curTok;         		// The token we are in the process of processing (for error reporting)
    bool success;               // overall success of the compilation

        // Input buffer logic
    enum { 
        IN_READ_SIZE = 32768, //16384,    // How much we like to read at one time
        IN_OVERLAP   = 8192, //2048,     // Extra space in buffer for overlapping one read with the next
                                // This limits the size of the largest individual token (except quoted strings)
    };
    char* buff;                 // the current block of input being read
    char* curPos;               // current place in input buffer
    char* limit;                // curPos should not go past this without fetching another block
    char* endPos;				// points just past the end of valid data in the buffer

    ReadStream* in;             // how we fill up our buffer

	bool	m_bFirstRead;
	int		m_iReadSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\asmman.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// asmman.hpp - header file for manifest-related ILASM functions
//

#ifndef ASMMAN_HPP
#define ASMMAN_HPP

#include "StrongName.h"

struct AsmManFile
{
    char*   szName;
    mdToken tkTok;
    DWORD   dwAttr;
    BinStr* pHash;
    CustomDescrList m_CustomDescrList;
    ~AsmManFile()
    {
        if(szName)  delete szName;
        if(pHash)   delete pHash;
    }
};
typedef FIFO<AsmManFile> AsmManFileList;

struct AsmManAssembly
{
	BOOL	isRef;
	char*	szName;
	char*	szAlias;
	mdToken	tkTok;
	DWORD	dwAttr;
	BinStr* pPublicKey;
	BinStr* pPublicKeyToken;
	ULONG	ulHashAlgorithm;
	BinStr*	pHashBlob;
	USHORT	usVerMajor;
	USHORT	usVerMinor;
	USHORT	usBuild;
	USHORT	usRevision;
	BinStr*	pLocale;
    // Security attributes
    PermissionDecl* m_pPermissions;
    PermissionSetDecl* m_pPermissionSets;
	CustomDescrList m_CustomDescrList;
	~AsmManAssembly() 
	{
		if(szAlias && (szAlias != szName)) delete [] szAlias;
		if(szName) delete [] szName;
		if(pPublicKey) delete pPublicKey;
		if(pPublicKeyToken) delete pPublicKeyToken;
		if(pHashBlob) delete pHashBlob;
		if(pLocale) delete pLocale;
	}
};
typedef FIFO<AsmManAssembly> AsmManAssemblyList;

struct AsmManComType
{
    char*   szName;
    mdToken tkTok;
    DWORD   dwAttr;
    char*   szFileName;
    char*   szComTypeName;
    mdToken tkClass;
    CustomDescrList m_CustomDescrList;
    ~AsmManComType()
    {
        if(szName) delete szName;
        if(szFileName) delete szFileName;
    }
};
typedef FIFO<AsmManComType> AsmManComTypeList;


struct AsmManRes
{
	char*	szName;
	mdToken	tkTok;
	DWORD	dwAttr;
	char*	szFileName;
	ULONG	ulOffset;
	CustomDescrList m_CustomDescrList;
	char*	szAsmRefName;
	AsmManRes() { szName = szAsmRefName = NULL; ulOffset = 0; };
	~AsmManRes()
	{
		if(szName) delete szName;
		if(szFileName) delete szFileName;
		if(szAsmRefName) delete szAsmRefName;
	}
};
typedef FIFO<AsmManRes> AsmManResList;

struct AsmManModRef
{
    char*   szName;
    mdToken tkTok;
    AsmManModRef() {szName = NULL; tkTok = 0; };
    ~AsmManModRef() { if(szName) delete szName; };
};
typedef FIFO<AsmManModRef> AsmManModRefList;

struct AsmManStrongName
{
    BYTE   *m_pbPublicKey;
    DWORD   m_cbPublicKey;
    WCHAR  *m_wzKeyContainer;
    BOOL    m_fFullSign;
    DWORD   m_dwPublicKeyAllocated;
    WCHAR   m_wzKeyContainerBuffer[32];
    AsmManStrongName() { ZeroMemory(this, sizeof(*this)); }
    ~AsmManStrongName()
    {
        if (m_dwPublicKeyAllocated == 1)
            StrongNameFreeBuffer(m_pbPublicKey);
        else if (m_dwPublicKeyAllocated == 2)
            delete [] m_pbPublicKey;
    }
};

class ErrorReporter;

class AsmMan
{
    AsmManFileList      m_FileLst;
    AsmManAssemblyList  m_AsmRefLst;
    AsmManComTypeList   m_ComTypeLst;
    AsmManResList       m_ManResLst;
    AsmManModRefList    m_ModRefLst;

    AsmManAssembly*     m_pCurAsmRef;
    AsmManComType*      m_pCurComType;
    AsmManRes*          m_pCurManRes;
    ErrorReporter*      report;
    void*               m_pAssembler;
    
    AsmManFile*         GetFileByName(char* szFileName);
    AsmManAssembly*     GetAsmRefByName(char* szAsmRefName);
    AsmManComType*      GetComTypeByName(char* szComTypeName);
    mdToken             GetComTypeTokByName(char* szComTypeName);

    IMetaDataAssemblyEmit*  m_pAsmEmitter;
    IMetaDataEmit*          m_pEmitter;

public:
    AsmManAssembly*     m_pAssembly;
    char*   m_szScopeName;
    BinStr* m_pGUID;
    AsmManStrongName    m_sStrongName;
	// Embedded manifest resources paraphernalia:
	WCHAR*  m_wzMResName[1024];
	DWORD	m_dwMResSize[1024];
	DWORD	m_dwMResNum;
	DWORD	m_dwMResSizeTotal;
	AsmMan() { m_pAssembly = NULL; m_szScopeName = NULL; m_pGUID = NULL; m_pAsmEmitter = NULL; 
				memset(m_wzMResName,0,sizeof(m_wzMResName)); 
				memset(m_dwMResSize,0,sizeof(m_dwMResSize)); 
				m_dwMResNum = m_dwMResSizeTotal = 0; };
	AsmMan(void* pAsm) { m_pAssembly = NULL; m_szScopeName = NULL; m_pGUID = NULL; m_pAssembler = pAsm;  m_pAsmEmitter = NULL;
				memset(m_wzMResName,0,sizeof(m_wzMResName)); 
				memset(m_dwMResSize,0,sizeof(m_dwMResSize)); 
				m_dwMResNum = m_dwMResSizeTotal = 0; };
	AsmMan(ErrorReporter* rpt) { m_pAssembly = NULL; m_szScopeName = NULL; m_pGUID = NULL; report = rpt;  m_pAsmEmitter = NULL;
				memset(m_wzMResName,0,sizeof(m_wzMResName)); 
				memset(m_dwMResSize,0,sizeof(m_dwMResSize)); 
				m_dwMResNum = m_dwMResSizeTotal = 0; };
	~AsmMan() 
	{ 
		if(m_pAssembly) delete m_pAssembly; 
		if(m_szScopeName) delete m_szScopeName; 
		if(m_pGUID) delete m_pGUID; 
	};
	void	SetErrorReporter(ErrorReporter* rpt) { report = rpt; };
	HRESULT EmitManifest(void);

    void    SetEmitter( IMetaDataEmit* pEmitter) { m_pEmitter = pEmitter; };

    void    SetModuleName(char* szName);

    void    AddFile(char* szName, DWORD dwAttr, BinStr* pHashBlob);
	void	EmitDebuggableAttribute(mdToken tkOwner, BOOL bIsMscorlib);

	void	StartAssembly(char* szName, char* szAlias, DWORD dwAttr, BOOL isRef);
	void	EndAssembly();
	void	SetAssemblyPublicKey(BinStr* pPublicKey);
	void	SetAssemblyPublicKeyToken(BinStr* pPublicKeyToken);
	void	SetAssemblyHashAlg(ULONG ulAlgID);
	void	SetAssemblyVer(USHORT usMajor, USHORT usMinor, USHORT usBuild, USHORT usRevision);
	void	SetAssemblyLocale(BinStr* pLocale, BOOL bConvertToUnicode);
	void	SetAssemblyHashBlob(BinStr* pHashBlob);

    void    StartComType(char* szName, DWORD dwAttr);
    void    EndComType();
    void    SetComTypeFile(char* szFileName);
    void    SetComTypeComType(char* szComTypeName);
    void    SetComTypeClassTok(mdToken tkClass);

    void    StartManifestRes(char* szName, DWORD dwAttr);
    void    EndManifestRes();
    void    SetManifestResFile(char* szFileName, ULONG ulOffset);
    void    SetManifestResAsmRef(char* szAsmRefName);

    mdToken             GetFileTokByName(char* szFileName);
    mdToken             GetAsmRefTokByName(char* szAsmRefName);
    mdToken             GetAsmTokByName(char* szAsmName) 
        { return (m_pAssembly && (strcmp(m_pAssembly->szName,szAsmName)==0)) ? m_pAssembly->tkTok : 0; };

    mdToken GetModuleRefTokByName(char* szName)
    {
        if(szName && *szName)
        {
            AsmManModRef* pMR;
            for(unsigned i=0; pMR=m_ModRefLst.PEEK(i); i++)
            {
                if(!strcmp(szName, pMR->szName)) return pMR->tkTok;
            }
        }
        return 0;
    };

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\binstr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* a binary string (blob) class */

#ifndef BINSTR_H
#define BINSTR_H

#include <string.h>			// for memmove, memcpy ... 

class BinStr {
public:
	BinStr()  { len = 0L; max = 8L; ptr_ = buff; }
	BinStr(BYTE* pb, DWORD cb) { len = cb; max = cb+8; ptr_ = pb; }
	~BinStr() { if (ptr_ != buff) delete [] ptr_; 	}

	void insertInt8(int val) { if (len >= max) realloc(); memmove(ptr_+1, ptr_, len); *ptr_ = val; len++; }
	void appendInt8(int val) { if (len >= max) realloc(); ptr_[len++] = val; }
	void appendInt16(int val) { if (len + 2 > max) realloc(); *((short*) &ptr_[len]) = val; len += 2; }
	void appendInt32(int val) { if (len + 4 > max) realloc(); *((int*) &ptr_[len]) = val; len += 4; }
	void appendInt64(__int64 *pval) { if (len + 8 > max) realloc(); memcpy(&ptr_[len],pval,8); len += 8; }
	unsigned __int8* getBuff(unsigned size) { 
		if (len + size > max) realloc(size); 
		_ASSERTE(len + size <= max);
		unsigned __int8* ret = &ptr_[len]; 
		len += size; 
		return(ret);
		}
    void append(BinStr* str) {
       memcpy(getBuff(str->length()), str->ptr(), str->length());
       }

	void remove(unsigned size) { _ASSERTE(len >= size); len -= size; }
	
	unsigned __int8* ptr() 		{ return(ptr_); }
	unsigned length() 	{ return(len); }
	
private:
	void realloc(unsigned atLeast = 4) {
		max = max * 2;
		if (max < atLeast + len)
			max = atLeast + len;
		_ASSERTE(max >= len + atLeast);
		unsigned __int8* newPtr = new unsigned __int8[max];
		memcpy(newPtr, ptr_, len);
		if (ptr_ != buff) delete [] ptr_; 
		ptr_ = newPtr;
		}
	
private:
	unsigned  len;
	unsigned  max;
	unsigned __int8 *ptr_;
	unsigned __int8 buff[8];
};
BinStr*	BinStrToUnicode(BinStr* pSource);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\class.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// class.hpp
//

#ifndef _CLASS_HPP
#define _CLASS_HPP

class PermissionDecl;
class PermissionSetDecl;

class Class
{
public:
	Class * m_pEncloser;
    char  * m_szName; //[MAX_CLASSNAME_LENGTH];
    char  * m_szNamespace; //[MAX_NAMESPACE_LENGTH];
	char  *	m_szFQN; //[MAX_NAMESPACE_LENGTH+MAX_CLASSNAME_LENGTH];
    mdTypeDef m_cl;
    mdTypeRef m_crExtends;
    mdTypeRef *m_crImplements;
    DWORD   m_Attr;
    DWORD   m_MemberAttr;
    DWORD   m_dwNumInterfaces;
	DWORD	m_dwNumFieldsWithOffset;
    PermissionDecl* m_pPermissions;
    PermissionSetDecl* m_pPermissionSets;
	ULONG	m_ulSize;
	ULONG	m_ulPack;
	BOOL	m_bIsEnum;
	BOOL	m_bIsMaster;

    MethodList			m_MethodList;
    MethodDList         m_MethodDList;
    FieldDList          m_FieldDList;	
    EventDList          m_EventDList;
    PropDList           m_PropDList;

    Class(char *pszName, char *pszNamespace, char* pszFQN, BOOL fValueClass, BOOL bIsEnum)
    {
		m_pEncloser = NULL;
        m_cl = mdTypeDefNil;
        m_crExtends = mdTypeRefNil;
        m_dwNumInterfaces = 0;
		m_dwNumFieldsWithOffset = 0;
		m_crImplements = NULL;
		m_szName = pszName;
		if(pszNamespace)
		{
			if(m_szNamespace = new char[(int)strlen(pszNamespace)+1])
						strcpy(m_szNamespace, pszNamespace);
			else
				fprintf(stderr,"\nOut of memory!\n");
		}
		else
		{
			m_szNamespace = new char[2];
			m_szNamespace[0] = 0;
		}
		m_szFQN = pszFQN;

        m_Attr = tdPublic;
        m_MemberAttr = 0;

		m_bIsEnum = bIsEnum;

        m_pPermissions = NULL;
        m_pPermissionSets = NULL;

		m_ulPack = 0;
		m_ulSize = 0xFFFFFFFF;
    }
	
	~Class()
	{
		delete [] m_szName;
		delete [] m_szNamespace;
		delete [] m_szFQN;
	}
    // find a method declared in this class
    Method *FindMethodByName(char *pszMethodName)
    {
		Method* pSearch = NULL;
		int i, N = m_MethodList.COUNT();

        for (i=0; i < N; i++)
        {
			pSearch = m_MethodList.PEEK(i);
            if (!strcmp(pSearch->m_szName, pszMethodName))
                break;
        }
        return pSearch;
    }
};


#endif /* _CLASS_HPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\dummy.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "cor.h"

unsigned DummyFunct(void)
{
	IMAGE_COR_ILMETHOD_SECT_EH* pCorEH;
	pCorEH = new IMAGE_COR_ILMETHOD_SECT_EH;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\assembler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/************************************************************************/
/*                           Assembler.h                                */
/************************************************************************/

#ifndef Assember_h
#define Assember_h

#define NEW_INLINE_NAMES

#include "cor.h"        // for CorMethodAttr ...
#include <crtdbg.h>     // For _ASSERTE
#include <corsym.h>

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "UtilCode.h"
#include "DebugMacros.h"
#include "corpriv.h"
#include <sighelper.h>
//#include "asmparse.h"
#include "binstr.h"

#include "asmenum.h"


// ELEMENT_TYPE_NAME has been removed from CORHDR.H, but the assembler uses it internally.                                  
#define    ELEMENT_TYPE_NAME    (ELEMENT_TYPE_MAX + 2)     // class by name NAME <count> <chars>

#define OUTPUT_BUFFER_SIZE          8192    // initial size of asm code for a single method
#define OUTPUT_BUFFER_INCREMENT     1024    // size of code buffer increment when it's full
#define MAX_FILENAME_LENGTH         512     //256
#define MAX_SIGNATURE_LENGTH        256     // unused
#define MAX_LABEL_SIZE              256     //64
#define MAX_CALL_SIG_SIZE           32      // unused
#define MAX_SCOPE_LENGTH            256     //64

//@TODO: The EE definitions for these maxes have changed to 1024.  Eventually,
// the EE will be fixed to handle class names with no max length.  IlAsm
// will need to be updated to do the same thing.
#define MAX_NAMESPACE_LENGTH        1024    //256    //64
#define MAX_MEMBER_NAME_LENGTH      1024    //256    //64

#define MAX_INTERFACES_IMPLEMENTED  16      // initial number; extended by 16 when needed
#define GLOBAL_DATA_SIZE            8192    // initial size of global data buffer
#define GLOBAL_DATA_INCREMENT       1024    // size of global data buffer increment when it's full
#define MAX_METHODS                 1024    // unused
#define MAX_INPUT_LINE_LEN          1024    // unused

#define BASE_OBJECT_CLASSNAME   "System.Object"

class Class;
class Method;
class PermissionDecl;
class PermissionSetDecl;


/*****************************************************************************/
/* LIFO (stack) and FIFO (queue) templates (must precede #include "method.h")*/
template <class T>
class LIST_EL
{
public:
    T*  m_Ptr;
    LIST_EL <T> *m_Next;
    LIST_EL(T *item) {m_Next = NULL; m_Ptr = item; };
};
    
template <class T>
class LIFO
{
public:
    inline LIFO() { m_pHead = NULL; };
    inline ~LIFO() {T *val; while(val = POP()) delete val; };
    void PUSH(T *item) 
    {
        m_pTemp = new LIST_EL <T>(item); 
        m_pTemp->m_Next = m_pHead; 
        m_pHead = m_pTemp;
    };
    T* POP() 
    {
        T* ret = NULL;
        if(m_pTemp = m_pHead)
        {
            m_pHead = m_pHead->m_Next;
            ret = m_pTemp->m_Ptr;
            delete m_pTemp;
        }
        return ret;
    };
private:
    LIST_EL <T> *m_pHead;
    LIST_EL <T> *m_pTemp;
};
#if (0)
template <class T>
class FIFO
{
public:
    inline FIFO() { m_pHead = m_pTail = NULL; m_ulCount = 0;};
    inline ~FIFO() {T *val; while(val = POP()) delete val; };
    void PUSH(T *item) 
    {
        m_pTemp = new LIST_EL <T>(item); 
        if(m_pTail) m_pTail->m_Next = m_pTemp;
        m_pTail = m_pTemp;
        if(m_pHead == NULL) m_pHead = m_pTemp;
        m_ulCount++;
    };
    T* POP() 
    {
        T* ret = NULL;
        if(m_pTemp = m_pHead)
        {
            m_pHead = m_pHead->m_Next;
            ret = m_pTemp->m_Ptr;
            delete m_pTemp;
            if(m_pHead == NULL) m_pTail = NULL;
            m_ulCount--;
        }
        return ret;
    };
    ULONG COUNT() { return m_ulCount; };
    T* PEEK(ULONG idx)
    {
        T* ret = NULL;
        ULONG   i;
        if(idx < m_ulCount)
        {
            if(idx == m_ulCount-1) m_pTemp = m_pTail;
            else for(m_pTemp = m_pHead, i = 0; i < idx; m_pTemp = m_pTemp->m_Next, i++);
            ret = m_pTemp->m_Ptr;
        }
        return ret;
    };
private:
    LIST_EL <T> *m_pHead;
    LIST_EL <T> *m_pTail;
    LIST_EL <T> *m_pTemp;
    ULONG       m_ulCount;
};
#else
template <class T>
class FIFO
{
public:
    FIFO() { m_Arr = NULL; m_ulArrLen = 0; m_ulCount = 0; m_ulOffset = 0; };
    ~FIFO() {
        if(m_Arr) {
            for(ULONG i=0; i < m_ulCount; i++) {
                if(m_Arr[i+m_ulOffset]) delete m_Arr[i+m_ulOffset];
            }
            delete [] m_Arr;
        }
    };
    void PUSH(T *item) 
    {
		if(item)
		{
			if(m_ulCount+m_ulOffset >= m_ulArrLen)
			{
				if(m_ulOffset)
				{
					memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
					m_ulOffset = 0;
				}
				else
				{
					m_ulArrLen += 1024;
					T** tmp = new T*[m_ulArrLen];
					if(tmp)
					{
						if(m_Arr)
						{
							memcpy(tmp,m_Arr,m_ulCount*sizeof(T*));
							delete [] m_Arr;
						}
						m_Arr = tmp;
					}
					else fprintf(stderr,"\nOut of memory!\n");
				}
			}
			m_Arr[m_ulOffset+m_ulCount] = item;
			m_ulCount++;
		}
    };
    ULONG COUNT() { return m_ulCount; };
    T* POP() 
    {
        T* ret = NULL;
        if(m_ulCount)
        {
            ret = m_Arr[m_ulOffset++];
            m_ulCount--;
            if(m_ulOffset >= 1024)
            {
                memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                m_ulOffset = 0;
            }
        }
        return ret;
    };
    T* PEEK(ULONG idx)
    {
        T* ret = NULL;
        if(idx < m_ulCount) ret = m_Arr[m_ulOffset+idx];
        return ret;
    };
private:
    T** m_Arr;
    ULONG       m_ulCount;
    ULONG       m_ulOffset;
    ULONG       m_ulArrLen;
};
#endif

struct MemberRefDescriptor
{
    mdTypeDef           m_tdClass;
    Class*              m_pClass;
    char*               m_szName;
    BinStr*             m_pSigBinStr;
    ULONG               m_ulOffset;
};
typedef FIFO<MemberRefDescriptor> MemberRefDList;

struct MethodImplDescriptor
{
    BinStr*             m_pbsImplementedTypeSpec;
    char*               m_szImplementedName;
    BinStr*             m_pbsSig;
    BinStr*             m_pbsImplementingTypeSpec;
    char*               m_szImplementingName;
    mdToken             m_tkImplementingMethod;
    mdToken             m_tkDefiningClass;
};
typedef FIFO<MethodImplDescriptor> MethodImplDList;
/**************************************************************************/
#include "method.hpp"
#include "ICeeFileGen.h"
#include "asmman.hpp"

#include "NVPair.h"


typedef enum
{
    STATE_OK,
    STATE_FAIL,
    STATE_ENDMETHOD,
    STATE_ENDFILE
} state_t;


class Label
{
public:
    char    m_szName[MAX_LABEL_SIZE];
    DWORD   m_PC;

    Label(char *pszName, DWORD PC)
    {
        _ASSERTE(strlen(pszName) < MAX_LABEL_SIZE);
        m_PC    = PC;
        strcpy(m_szName, pszName);
    }
};
typedef FIFO<Label> LabelList;

class GlobalLabel
{
public:
    char            m_szName[MAX_LABEL_SIZE];
    DWORD           m_GlobalOffset; 
    HCEESECTION     m_Section;

    GlobalLabel(char *pszName, DWORD GlobalOffset, HCEESECTION section)
    {
        _ASSERTE(strlen(pszName) < MAX_LABEL_SIZE);
        m_GlobalOffset  = GlobalOffset;
        m_Section       = section;
        strcpy(m_szName, pszName);
    }
};
typedef FIFO<GlobalLabel> GlobalLabelList;


class Fixup
{
public:
    char    m_szLabel[MAX_LABEL_SIZE]; // destination label
    BYTE *  m_pBytes; // where to make the fixup
    DWORD   m_RelativeToPC;
    BYTE    m_FixupSize;

    Fixup(char *pszName, BYTE *pBytes, DWORD RelativeToPC, BYTE FixupSize)
    {
        _ASSERTE(strlen(pszName) < MAX_LABEL_SIZE);
        m_pBytes        = pBytes;
        m_RelativeToPC  = RelativeToPC;
        m_FixupSize     = FixupSize;

        strcpy(m_szLabel, pszName);
    }
};
typedef FIFO<Fixup> FixupList;

class GlobalFixup
{
public:
    char    m_szLabel[MAX_LABEL_SIZE];  // destination label
    BYTE *  m_pReference;               // The place to fix up

    GlobalFixup(char *pszName, BYTE* pReference)
    {
        _ASSERTE(strlen(pszName) < MAX_LABEL_SIZE);
        m_pReference   = pReference;
        strcpy(m_szLabel, pszName);
    }
};
typedef FIFO<GlobalFixup> GlobalFixupList;


typedef enum { ilRVA, ilOffset, ilGlobal } ILFixupType;

class ILFixup
{
public:
    ILFixupType   m_Kind;
    DWORD         m_OffsetInMethod;
    GlobalFixup * m_Fixup;

    ILFixup(DWORD Offset, ILFixupType Kind, GlobalFixup *Fix)
    { 
      m_Kind           = Kind;
      m_OffsetInMethod = Offset;
      m_Fixup          = Fix;
    }
};
typedef FIFO<ILFixup> ILFixupList;

class CeeFileGenWriter;
class CeeSection;

class BinStr;

/************************************************************************/
/* represents an object that knows how to report errors back to the user */

class ErrorReporter 
{
public:
    virtual void error(char* fmt, ...) = 0; 
    virtual void warn(char* fmt, ...) = 0; 
    virtual void msg(char* fmt, ...) = 0; 
};

/**************************************************************************/
/* represents a switch table before the lables are bound */

struct Labels {
    Labels(char* aLabel, Labels* aNext, bool aIsLabel) : Label(aLabel), Next(aNext), isLabel(aIsLabel) {}
    ~Labels() { if(isLabel) delete [] Label; delete Next; }
        
    char*       Label;
    Labels*     Next;
    bool        isLabel;
};

/**************************************************************************/
/* descriptor of the structured exception handling construct  */
struct SEH_Descriptor
{
    DWORD       sehClause;  // catch/filter/finally
    DWORD       tryFrom;    // start of try block
    DWORD       tryTo;      // end of try block
    DWORD       sehHandler; // start of exception handler
    DWORD       sehHandlerTo; // end of exception handler
    union {
        DWORD       sehFilter;  // start of filter block
        mdTypeRef   cException; // what to catch
    };
};


typedef LIFO<char> StringStack;
typedef LIFO<SEH_Descriptor> SEHD_Stack;

typedef FIFO<Method> MethodList;
/**************************************************************************/
/* The method, field, event and property descriptor structures            */
struct MethodDescriptor
{
    mdTypeDef       m_tdClass;
    char*           m_szName;
    char*           m_szClassName;
    COR_SIGNATURE*  m_pSig;
    DWORD           m_dwCSig;
    mdMethodDef     m_mdMethodTok;
    WORD            m_wVTEntry;
    WORD            m_wVTSlot;
	DWORD			m_dwExportOrdinal;
	char*			m_szExportAlias;
};
typedef FIFO<MethodDescriptor> MethodDList;

struct FieldDescriptor
{
    mdTypeDef       m_tdClass;
    char*           m_szName;
    mdFieldDef      m_fdFieldTok;
    ULONG           m_ulOffset;
    char*           m_rvaLabel;         // if field has RVA associated with it, label for it goes here. 
    BinStr*         m_pbsSig;
	Class*			m_pClass;
	BinStr*			m_pbsValue;
	BinStr*			m_pbsMarshal;
	PInvokeDescriptor*	m_pPInvoke;
    CustomDescrList     m_CustomDescrList;
	DWORD			m_dwAttr;
    // Security attributes
    PermissionDecl* m_pPermissions;
    PermissionSetDecl* m_pPermissionSets;
    FieldDescriptor()  { m_szName = NULL; m_pbsSig = NULL; };
    ~FieldDescriptor() { if(m_szName) delete m_szName; if(m_pbsSig) delete m_pbsSig; };
};
typedef FIFO<FieldDescriptor> FieldDList;

struct EventDescriptor
{
    mdTypeDef           m_tdClass;
    char*               m_szName;
    DWORD               m_dwAttr;
    mdToken             m_tkEventType;
    MethodDescriptor*   m_pmdAddOn;
    MethodDescriptor*   m_pmdRemoveOn;
    MethodDescriptor*   m_pmdFire;
    MethodDList         m_mdlOthers;
    mdEvent             m_edEventTok;
    CustomDescrList     m_CustomDescrList;
};
typedef FIFO<EventDescriptor> EventDList;

struct PropDescriptor
{
    mdTypeDef           m_tdClass;
    char*               m_szName;
    DWORD               m_dwAttr;
    COR_SIGNATURE*      m_pSig;
    DWORD               m_dwCSig;
    DWORD               m_dwCPlusTypeFlag;
    PVOID               m_pValue;
	DWORD				m_cbValue;
    MethodDescriptor*   m_pmdSet;
    MethodDescriptor*   m_pmdGet;
    MethodDList         m_mdlOthers;
    mdProperty          m_pdPropTok;
    CustomDescrList     m_CustomDescrList;
};
typedef FIFO<PropDescriptor> PropDList;

struct ImportDescriptor
{
    char*   szDllName;
    mdModuleRef mrDll;
};
typedef FIFO<ImportDescriptor> ImportList;


/**************************************************************************/
#include "class.hpp"
typedef LIFO<Class> ClassStack;
typedef FIFO<Class> ClassList;

/**************************************************************************/
/* Classes to hold lists of security permissions and permission sets. We build
   these lists as we find security directives in the input stream and drain
   them every time we see a class or method declaration (to which the
   security info is attached). */

class PermissionDecl
{
public:
    PermissionDecl(CorDeclSecurity action, BinStr *type, NVPair *pairs)
    {
        m_Action = action;
        m_TypeSpec = type;
        BuildConstructorBlob(action, pairs);
        m_Next = NULL;
    }

    ~PermissionDecl()
    {
        delete m_TypeSpec;
        delete [] m_Blob;
    }

    CorDeclSecurity     m_Action;
    BinStr             *m_TypeSpec;
    BYTE               *m_Blob;
    long                m_BlobLength;
    PermissionDecl     *m_Next;

private:
    void BuildConstructorBlob(CorDeclSecurity action, NVPair *pairs)
    {
        NVPair *p = pairs;
        int count = 0;
        size_t bytes = 8;
        size_t length;
        int i;
        BYTE *pBlob;

        // Calculate number of name/value pairs and the memory required for the
        // custom attribute blob.
        while (p) {
            BYTE *pVal = (BYTE*)p->Value()->ptr();
            count++;
            bytes += 2; // One byte field/property specifier, one byte type code

            length = strlen((const char *)p->Name()->ptr());
            bytes += CPackedLen::Size((ULONG)length) + length;

            switch (pVal[0]) {
            case SERIALIZATION_TYPE_BOOLEAN:
                bytes += 1;
                break;
            case SERIALIZATION_TYPE_I4:
                bytes += 4;
                break;
            case SERIALIZATION_TYPE_STRING:
                length = strlen((const char *)&pVal[1]);
                bytes += (INT)(CPackedLen::Size((ULONG)length) + length);
                break;
            case SERIALIZATION_TYPE_ENUM:
                length = (int)strlen((const char *)&pVal[1]);
                if (strchr((const char *)&pVal[1], '^'))
                    length++;
                bytes += CPackedLen::Size((ULONG)length) + length;
                bytes += 4;
                break;
            }
            p = p->Next();
        }

        m_Blob = new BYTE[bytes];
		if(m_Blob==NULL)
		{
			fprintf(stderr,"\nOut of memory!\n");
			return;
		}

        m_Blob[0] = 0x01;           // Version
        m_Blob[1] = 0x00;
        m_Blob[2] = (BYTE)action;   // Constructor arg (security action code)
        m_Blob[3] = 0x00;
        m_Blob[4] = 0x00;
        m_Blob[5] = 0x00;
        m_Blob[6] = (BYTE)count;    // Property/field count
        m_Blob[7] = (BYTE)(count >> 8);

        for (i = 0, pBlob = &m_Blob[8], p = pairs; i < count; i++, p = p->Next()) {
            BYTE *pVal = (BYTE*)p->Value()->ptr();
            char *szType;
            char *szAssembly;

            // Set field/property setter type.
            // @todo: we always assume property setters for the moment.
            *pBlob++ = SERIALIZATION_TYPE_PROPERTY;

            // Set type code. There's additional info for enums (the enum class
            // name).
            *pBlob++ = pVal[0];
            if (pVal[0] == SERIALIZATION_TYPE_ENUM) {
                // If the name is assembly qualified, turn it into the standard
                // format (type name ',' assembly ref).
                if (szType = strchr((const char *)&pVal[1], '^')) {
                    szType++;
                    szAssembly = (char *)&pVal[1];
                    length = strlen(szAssembly) + 1;
                    pBlob = (BYTE*)CPackedLen::PutLength(pBlob, (ULONG)length);
                    strcpy((char *)pBlob, szType);
                    strcat((char *)pBlob, ", ");
                    strncat((char *)pBlob, szAssembly, szType - szAssembly - 1);
                } else {
                    szType = (char *)&pVal[1];
                    length = strlen(szType);
                    pBlob = (BYTE*)CPackedLen::PutLength(pBlob, (ULONG)length);
                    strcpy((char *)pBlob, szType);
                }
                pBlob += length;
            }

            // Record the field/property name.
            length = strlen((const char *)p->Name()->ptr());
            pBlob = (BYTE*)CPackedLen::PutLength(pBlob, (ULONG)length);
            strcpy((char *)pBlob, (const char *)p->Name()->ptr());
            pBlob += length;

            // Record the serialized value.
            switch (pVal[0]) {
            case SERIALIZATION_TYPE_BOOLEAN:
                *pBlob++ = pVal[1];
                break;
            case SERIALIZATION_TYPE_I4:
                *(__int32*)pBlob = *(__int32*)&pVal[1];
                pBlob += 4;
                break;
            case SERIALIZATION_TYPE_STRING:
                length = strlen((const char *)&pVal[1]);
                pBlob = (BYTE*)CPackedLen::PutLength(pBlob, (ULONG)length);
                strcpy((char *)pBlob, (const char *)&pVal[1]);
                pBlob += length;
                break;
            case SERIALIZATION_TYPE_ENUM:
                length = (int)strlen((const char *)&pVal[1]);
                // We can have enums with base type of I1, I2 and I4.
                switch (pVal[1 + length + 1]) {
                case 1:
                    *(__int8*)pBlob = *(__int8*)&pVal[1 + length + 2];
                    pBlob += 1;
                    break;
                case 2:
                    *(__int16*)pBlob = *(__int16*)&pVal[1 + length + 2];
                    pBlob += 2;
                    break;
                case 4:
                    *(__int32*)pBlob = *(__int32*)&pVal[1 + length + 2];
                    pBlob += 4;
                    break;
                default:
                    _ASSERTE(!"Invalid enum size");
                }
                break;
            }

        }

        _ASSERTE((pBlob - m_Blob) == bytes);

        m_BlobLength = (long)bytes;
    }
};

class PermissionSetDecl
{
public:
    PermissionSetDecl(CorDeclSecurity action, BinStr *value)
    {
        m_Action = action;
        m_Value = value;
        m_Next = NULL;
    }

    ~PermissionSetDecl()
    {
        delete m_Value;
    }

    CorDeclSecurity     m_Action;
    BinStr             *m_Value;
    PermissionSetDecl  *m_Next;
};

struct VTFEntry
{
    char*   m_szLabel;
    WORD    m_wCount;
    WORD    m_wType;
    VTFEntry(WORD wCount, WORD wType, char* szLabel) { m_wCount = wCount; m_wType = wType; m_szLabel = szLabel; }
    ~VTFEntry() { if(m_szLabel) delete m_szLabel; }
};
typedef FIFO<VTFEntry> VTFList;

struct	EATEntry
{
	DWORD	dwStubRVA;
	DWORD	dwOrdinal;
	char*	szAlias;
};
typedef FIFO<EATEntry> EATList;

struct LocalTypeRefDescr
{
    char*   m_szFullName;
    mdToken m_tok;
    LocalTypeRefDescr(char* szName) 
    { 
        if(szName && *szName) 
        { 
            if(m_szFullName = new char[strlen(szName)+1]) strcpy(m_szFullName,szName);
        }
        else m_szFullName = NULL;
    };
    ~LocalTypeRefDescr() { if(m_szFullName) delete m_szFullName; };
};
typedef FIFO<LocalTypeRefDescr> LocalTypeRefDList;

/**************************************************************************/
/* The assembler object does all the code generation (dealing with meta-data)
   writing a PE file etc etc. But does NOT deal with syntax (that is what
   AsmParse is for).  Thus the API below is how AsmParse 'controls' the 
   Assember.  Note that the Assembler object does know know about the 
   AsmParse object (that is Assember is more fundamental than AsmParse) */
struct Instr
{
    int opcode;
    unsigned linenum;
	unsigned column;
};

class Assembler {
public:
    Assembler();
    ~Assembler();
    //--------------------------------------------------------  
	LabelList		m_lstLabel;
	GlobalLabelList m_lstGlobalLabel;
	GlobalFixupList m_lstGlobalFixup;
	ILFixupList		m_lstILFixup;
	FixupList		m_lstFixup;

    Class *			m_pModuleClass;
    ClassList		m_lstClass;

    BYTE *  m_pOutputBuffer;
    BYTE *  m_pCurOutputPos;
    BYTE *  m_pEndOutputPos;


    DWORD   m_CurPC;
    BOOL    m_fStdMapping;
    BOOL    m_fDisplayTraceOutput;
    BOOL    m_fInitialisedMetaData;
    BOOL    m_fDidCoInitialise;
    BOOL    m_fAutoInheritFromObject;
    BOOL    m_fReportProgress;

    IMetaDataDispenser *m_pDisp;
    IMetaDataEmit *m_pEmitter;
    IMetaDataHelper *m_pHelper;
    ICeeFileGen* m_pCeeFileGen;
    HCEEFILE m_pCeeFile;
    HCEESECTION m_pGlobalDataSection;
    HCEESECTION m_pILSection;
    HCEESECTION m_pTLSSection;
    HCEESECTION m_pCurSection;      // The section EmitData* things go to

    AsmMan*     m_pManifest;

    char    m_szScopeName[MAX_SCOPE_LENGTH];
    char    *m_szNamespace; //[MAX_NAMESPACE_LENGTH];
    char    *m_szFullNS; //[MAX_NAMESPACE_LENGTH];
	unsigned	m_ulFullNSLen;

    StringStack m_NSstack;

    char    m_szExtendsClause[MAX_CLASSNAME_LENGTH];

    mdTypeRef   *m_crImplList;
    int     m_nImplList;
    int     m_nImplListSize;

    Method *m_pCurMethod;
    Class   *m_pCurClass;
    ClassStack m_ClassStack; // for nested classes

    // moved to Class
    //MethodList  m_MethodList;

    BOOL    m_fCPlusPlus;
    BOOL    m_fWindowsCE;
    BOOL    m_fGenerateListing;
    BOOL    m_fDLL;
    BOOL    m_fOBJ;
    BOOL    m_fEntryPointPresent;
    BOOL    m_fHaveFieldsWithRvas;

    state_t m_State;
    //--------------------------------------------------------------------------------
    void    ClearImplList(void);
    void    AddToImplList(char *name);
    //--------------------------------------------------------------------------------
    BOOL Init();
    void ProcessLabel(char *pszName);
    Label *FindLabel(char *pszName);
    Label *FindLabel(DWORD PC);
    GlobalLabel *FindGlobalLabel(char *pszName);
    void AddLabel(DWORD CurPC, char *pszName);
    void AddDeferredFixup(char *pszLabel, BYTE *pBytes, DWORD RelativeToPC, BYTE FixupSize);
    GlobalFixup *AddDeferredGlobalFixup(char *pszLabel, BYTE* reference);
    void AddDeferredDescrFixup(char *pszLabel);
    BOOL DoFixups();
    BOOL DoGlobalFixups();
    BOOL DoDescrFixups();
    BOOL GenerateListingFile(Method *pMethod);
    OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen);
    BOOL AddMethod(Method *pMethod);
    void SetTLSSection()        
	{ m_pCurSection = m_pTLSSection; m_dwComImageFlags &= ~COMIMAGE_FLAGS_ILONLY; m_dwComImageFlags |= COMIMAGE_FLAGS_32BITREQUIRED;}
    void SetDataSection()       { m_pCurSection = m_pGlobalDataSection; }
    BOOL EmitMethod(Method *pMethod);
    BOOL AddClass(Class *pClass, Class *pEnclosingClass);
    HRESULT CreatePEFile(WCHAR *pwzOutputFilename);
    HRESULT CreateTLSDirectory();
    HRESULT CreateDebugDirectory();
    HRESULT InitMetaData();
    Class *FindClass(char *pszFQN);
    BOOL EmitFieldRef(char *pszArg, int opcode);
    BOOL EmitSwitchData(char *pszArg);
    mdToken ResolveClassRef(char *pszClassName, Class** ppClass);
    BOOL ResolveTypeSpec(BinStr* typeSpec, mdTypeRef *pcr, Class** ppClass);
    BOOL ResolveTypeSpecToRef(BinStr* typeSpec, mdTypeRef *pcr);
    HRESULT ConvLocalSig(char* localsSig, CQuickBytes* corSig, DWORD* corSigLen, BYTE*& localTypes);
    DWORD GetCurrentILSectionOffset();
    BOOL EmitCALLISig(char *p);
    void AddException(DWORD pcStart, DWORD pcEnd, DWORD pcHandler, DWORD pcHandlerTo, mdTypeRef crException, BOOL isFilter, BOOL isFault, BOOL isFinally);
    state_t CheckLocalTypeConsistancy(int instr, unsigned arg);
    state_t AddGlobalLabel(char *pszName, HCEESECTION section);
    void DoDeferredILFixups(ULONG OffsetInFile);
    void AddDeferredILFixup(ILFixupType Kind);
    void AddDeferredILFixup(ILFixupType Kind, GlobalFixup *GFixup);
    void SetDLL(BOOL);
    void SetOBJ(BOOL);
    void ResetForNextMethod();
    void SetStdMapping(BOOL val = TRUE) { m_fStdMapping = val; };

    //--------------------------------------------------------------------------------
    BOOL isShort(unsigned instr) { return ((OpcodeInfo[instr].Type & 16) != 0); };
    void SetErrorReporter(ErrorReporter* aReport) { report = aReport; if(m_pManifest) m_pManifest->SetErrorReporter(aReport); }

    void StartNameSpace(char* name);
    void EndNameSpace();
    void StartClass(char* name, DWORD attr);
    void EndClass();
    void StartMethod(char* name, BinStr* sig, CorMethodAttr flags, BinStr* retMarshal, DWORD retAttr);
    void EndMethod();

    void AddField(char* name, BinStr* sig, CorFieldAttr flags, char* rvaLabel, BinStr* pVal, ULONG ulOffset);
	BOOL EmitField(FieldDescriptor* pFD);
    void EmitByte(int val);
    //void EmitTry(enum CorExceptionFlag kind, char* beginLabel, char* endLabel, char* handleLabel, char* filterOrClass);
    void EmitMaxStack(unsigned val);
    void EmitLocals(BinStr* sig);
    void EmitEntryPoint();
    void EmitZeroInit();
    void SetImplAttr(unsigned short attrval);
    void EmitData(void* buffer, unsigned len);
    void EmitDD(char *str);
    void EmitDataString(BinStr* str);

    void EmitInstrVar(Instr* instr, int var);
    void EmitInstrVarByName(Instr* instr, char* label);
    void EmitInstrI(Instr* instr, int val);
    void EmitInstrI8(Instr* instr, __int64* val);
    void EmitInstrR(Instr* instr, double* val);
    void EmitInstrBrOffset(Instr* instr, int offset);
    void EmitInstrBrTarget(Instr* instr, char* label);
    mdToken MakeMemberRef(BinStr* typeSpec, char* name, BinStr* sig, unsigned opcode_len);
    mdToken MakeTypeRef(BinStr* typeSpec);
    void EmitInstrStringLiteral(Instr* instr, BinStr* literal, BOOL ConvertToUnicode);
    void EmitInstrSig(Instr* instr, BinStr* sig);
    void EmitInstrRVA(Instr* instr, char* label, bool islabel);
    void EmitInstrSwitch(Instr* instr, Labels* targets);
    void EmitInstrPhi(Instr* instr, BinStr* vars);
    void EmitLabel(char* label);
    void EmitDataLabel(char* label);

    unsigned OpcodeLen(Instr* instr); //returns opcode length
    // Emit just the opcode (no parameters to the instruction stream.
    void EmitOpcode(Instr* instr);

    // Emit primitive types to the instruction stream.
    void EmitBytes(BYTE*, unsigned len);

    ErrorReporter* report;

	BOOL EmitMembers(Class* pClass);

    // named args/vars paraphernalia:
public:
    void addArgName(char *szNewName, BinStr* pbSig, BinStr* pbMarsh, DWORD dwAttr)
    {
        if(pbSig && (*(pbSig->ptr()) == ELEMENT_TYPE_VOID))
            report->error("Illegal use of type 'void'\n");
        if(m_firstArgName)
        {
            ARG_NAME_LIST *pArgList=m_firstArgName;
            int i;
            for(i=1; pArgList->pNext; pArgList = pArgList->pNext,i++) ;
            pArgList->pNext = new ARG_NAME_LIST(i,szNewName,pbSig,pbMarsh,dwAttr);
        }
        else 
            m_firstArgName = new ARG_NAME_LIST(0,szNewName,pbSig,pbMarsh,dwAttr);
    };
    ARG_NAME_LIST *getArgNameList(void) 
    { ARG_NAME_LIST *pRet = m_firstArgName; m_firstArgName=NULL; return pRet;};
    // Added because recursive destructor of ARG_NAME_LIST may overflow the system stack
    void delArgNameList(ARG_NAME_LIST *pFirst)
    {
        ARG_NAME_LIST *pArgList=pFirst, *pArgListNext;
        for(; pArgList; pArgListNext=pArgList->pNext,
                        delete pArgList, 
                        pArgList=pArgListNext);
    };
    ARG_NAME_LIST   *findArg(ARG_NAME_LIST *pFirst, int num)
    {
        ARG_NAME_LIST *pAN;
        for(pAN=pFirst; pAN; pAN = pAN->pNext)
        {
            if(pAN->nNum == num) return pAN;
        }
        return NULL;
    };
    ARG_NAME_LIST *m_firstArgName;

    // Structured exception handling paraphernalia:
public:
    SEH_Descriptor  *m_SEHD;    // current descriptor ptr
    void NewSEHDescriptor(void); //sets m_SEHD
    void SetTryLabels(char * szFrom, char *szTo);
    void SetFilterLabel(char *szFilter);
    void SetCatchClass(char *szClass);
    void SetHandlerLabels(char *szHandlerFrom, char *szHandlerTo);
    void EmitTry(void);         //uses m_SEHD

//private:
    SEHD_Stack  m_SEHDstack;

    // Events and Properties paraphernalia:
public:
    void EndEvent(void);    //emits event definition
    void EndProp(void);     //emits property definition
    void ResetEvent(char * szName, BinStr* typeSpec, DWORD dwAttr);
    void ResetProp(char * szName, BinStr* bsType, DWORD dwAttr, BinStr* bsValue);
    void SetEventMethod(int MethodCode, BinStr* typeSpec, char* pszMethodName, BinStr* sig);
    void SetPropMethod(int MethodCode, BinStr* typeSpec, char* pszMethodName, BinStr* sig);
    BOOL EmitEvent(EventDescriptor* pED);   // impl. in ASSEM.CPP
    BOOL EmitProp(PropDescriptor* pPD); // impl. in ASSEM.CPP
    mdMethodDef GetMethodTokenByDescr(MethodDescriptor* pMD);   // impl. in ASSEM.CPP
    mdEvent     GetEventTokenByDescr(EventDescriptor* pED); // impl. in ASSEM.CPP
    mdFieldDef  GetFieldTokenByDescr(FieldDescriptor* pFD); // impl. in ASSEM.CPP
    EventDescriptor*    m_pCurEvent;
    PropDescriptor*     m_pCurProp;

private:
	// All descriptor lists moved to Class
    //MethodDList         m_MethodDList;
    //FieldDList          m_FieldDList;	
    //EventDList          m_EventDList;
    //PropDList           m_PropDList;
    MemberRefDList      m_MemberRefDList;
    LocalTypeRefDList   m_LocalTypeRefDList;

    // PInvoke paraphernalia
public:
    PInvokeDescriptor*  m_pPInvoke;
    ImportList  m_ImportList;
    void SetPinvoke(BinStr* DllName, int Ordinal, BinStr* Alias, int Attrs);
    HRESULT EmitPinvokeMap(mdToken tk, PInvokeDescriptor* pDescr);
    ImportDescriptor* EmitImport(BinStr* DllName);

    // Debug metadata paraphernalia
public:
    ISymUnmanagedWriter* m_pSymWriter;
    ISymUnmanagedDocumentWriter* m_pSymDocument;
    ULONG m_ulCurLine; // set by Parser
    ULONG m_ulCurColumn; // set by Parser
    ULONG m_ulLastDebugLine;
    ULONG m_ulLastDebugColumn;
    BOOL  m_fIncludeDebugInfo;
    char m_szSourceFileName[MAX_FILENAME_LENGTH*3];
    WCHAR m_wzOutputFileName[MAX_FILENAME_LENGTH];
	GUID	m_guidLang;
	GUID	m_guidLangVendor;
	GUID	m_guidDoc;

    // Security paraphernalia
public:
    void AddPermissionDecl(CorDeclSecurity action, BinStr *type, NVPair *pairs)
    {
        PermissionDecl *decl = new PermissionDecl(action, type, pairs);
		if(decl==NULL)
		{
			report->error("\nOut of memory!\n");
			return;
		}
        if (m_pCurMethod) {
            decl->m_Next = m_pCurMethod->m_pPermissions;
            m_pCurMethod->m_pPermissions = decl;
        } else if (m_pCurClass) {
            decl->m_Next = m_pCurClass->m_pPermissions;
            m_pCurClass->m_pPermissions = decl;
        } else if (m_pManifest && m_pManifest->m_pAssembly) {
            decl->m_Next = m_pManifest->m_pAssembly->m_pPermissions;
            m_pManifest->m_pAssembly->m_pPermissions = decl;
        } else {
            report->error("Cannot declare security permissions without the owner\n");
            delete decl;
        }
    };

    void AddPermissionSetDecl(CorDeclSecurity action, BinStr *value)
    {
        PermissionSetDecl *decl = new PermissionSetDecl(action, value);
		if(decl==NULL)
		{
			report->error("\nOut of memory!\n");
			return;
		}
        if (m_pCurMethod) {
            decl->m_Next = m_pCurMethod->m_pPermissionSets;
            m_pCurMethod->m_pPermissionSets = decl;
        } else if (m_pCurClass) {
            decl->m_Next = m_pCurClass->m_pPermissionSets;
            m_pCurClass->m_pPermissionSets = decl;
        } else if (m_pManifest && m_pManifest->m_pAssembly) {
            decl->m_Next = m_pManifest->m_pAssembly->m_pPermissionSets;
            m_pManifest->m_pAssembly->m_pPermissionSets = decl;
        } else {
            report->error("Cannot declare security permission sets without the owner\n");
            delete decl;
        }
    };
    void EmitSecurityInfo(mdToken           token,
                          PermissionDecl*   pPermissions,
                          PermissionSetDecl*pPermissionSets);
    
    HRESULT AllocateStrongNameSignature();
    HRESULT StrongNameSign();

    // Custom values paraphernalia:
public:
    mdToken m_tkCurrentCVOwner;
    CustomDescrList* m_pCustomDescrList;
    void DefineCV(mdToken tkOwner, mdToken tkType, BinStr* pBlob)
    {
        ULONG               cTemp;
        void *          pBlobBody;
        mdToken         cv;
        if(pBlob)
        {
            pBlobBody = (void *)(pBlob->ptr());
            cTemp = pBlob->length();
        }
        else
        {
            pBlobBody = NULL;
            cTemp = 0;
        }
        m_pEmitter->DefineCustomAttribute(tkOwner,tkType,pBlobBody,cTemp,&cv);
    };
    void EmitCustomAttributes(mdToken tok, CustomDescrList* pCDL)
    {
        CustomDescr *pCD;
        if(pCDL == NULL || RidFromToken(tok)==0) return;
        while(pCD = pCDL->POP())
        {
            DefineCV(tok,pCD->tkType,pCD->pBlob);
            delete pCD;
        }
    };

    // VTable blob (if any)
public:
    BinStr *m_pVTable;
    // Field marshaling
    BinStr *m_pMarshal;
    // VTable fixup list
    VTFList m_VTFList;
	// Export Address Table entries list
	EATList m_EATList;
	HRESULT CreateExportDirectory();
	DWORD	EmitExportStub(DWORD dwVTFSlotRVA);

    // Method implementation paraphernalia:
private:
    MethodImplDList m_MethodImplDList;
public:
    void AddMethodImpl(BinStr* pImplementedTypeSpec, char* szImplementedName, BinStr* pSig, 
                    BinStr* pImplementingTypeSpec, char* szImplementingName);
    BOOL EmitMethodImpls();
    // lexical scope handling paraphernalia:
    void EmitScope(Scope* pSCroot); // struct Scope - see Method.hpp
    // obfuscating paraphernalia:
    BOOL    m_fOwnershipSet;
    BinStr* m_pbsOwner;
    // source file name paraphernalia
    BOOL m_fSourceFileSet;
    void SetSourceFileName(char* szName);
    void SetSourceFileName(BinStr* pbsName);
    // header flags
    DWORD   m_dwSubsystem;
    DWORD   m_dwComImageFlags;
	DWORD	m_dwFileAlignment;
	size_t	m_stBaseAddress;

};

#endif  // Assember_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\assembler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "Assembler.h"
#include "BinStr.h"         
#include "NVPair.h"

#define FAIL_UNLESS(x, y) if (!(x)) { report->error y; return; }

extern bool OnErrGo;
extern unsigned int g_uCodePage;

/**************************************************************************/
void Assembler::StartNameSpace(char* name)
{
	m_NSstack.PUSH(m_szNamespace);
	m_szNamespace = name;
	unsigned L = (unsigned)strlen(m_szFullNS);
	unsigned l = (unsigned)strlen(name);
	if(L+l+1 >= m_ulFullNSLen)
	{
		char* pch = new char[((L+l)/MAX_NAMESPACE_LENGTH + 1)*MAX_NAMESPACE_LENGTH];
		if(pch)
		{
			memcpy(pch,m_szFullNS,L+1);
			delete [] m_szFullNS;
			m_szFullNS = pch;
			m_ulFullNSLen = ((L+l)/MAX_NAMESPACE_LENGTH + 1)*MAX_NAMESPACE_LENGTH;
		}
		else report->error("Failed to reallocate the NameSpace buffer\n");
	}
	if(L) strcat(m_szFullNS,NAMESPACE_SEPARATOR_STR);
	strcat(m_szFullNS,m_szNamespace);
}

/**************************************************************************/
void Assembler::EndNameSpace()
{
	char *p = &m_szFullNS[strlen(m_szFullNS)-strlen(m_szNamespace)];
	if(p > m_szFullNS) p--;
	*p = 0;
	delete [] m_szNamespace;
	if((m_szNamespace = m_NSstack.POP())==NULL) 
	{
		m_szNamespace = new char[2];
		m_szNamespace[0] = 0;
	}
}

/**************************************************************************/
void	Assembler::ClearImplList(void)
{
	while(m_nImplList) m_crImplList[--m_nImplList] = mdTypeRefNil;
}
/**************************************************************************/
void	Assembler::AddToImplList(char *name)
{
	if(m_nImplList >= m_nImplListSize - 1)
	{
		mdTypeRef	*ptr = new mdTypeRef[m_nImplListSize + MAX_INTERFACES_IMPLEMENTED];
		if(ptr == NULL) 
		{
			report->error("Failed to reallocate Impl List from %d to %d bytes\n",
				m_nImplListSize,m_nImplListSize+MAX_INTERFACES_IMPLEMENTED);
			return;
		}
		memcpy(ptr,m_crImplList,m_nImplList*sizeof(mdTypeRef));
		delete m_crImplList;
		m_crImplList = ptr;
		m_nImplListSize += MAX_INTERFACES_IMPLEMENTED;
	}
	if((m_crImplList[m_nImplList] = ResolveClassRef(name,NULL))!=mdTokenNil) m_nImplList++;
	else	report->error("Unable to resolve interface reference '%s'\n",name);
	m_crImplList[m_nImplList] = mdTypeRefNil;
}
/**************************************************************************/
// Convert a class name into a class ref (mdTypeRef).
// Assume the scope and namespace are the same as in the Assembler object.
mdToken Assembler::ResolveClassRef(char *pszFullClassName, Class** ppClass)
{
	Class *pClass = NULL;
	mdToken tkRet;

	if(pszFullClassName == NULL) return mdTokenNil;
	if (m_fInitialisedMetaData == FALSE)
	{
		if (FAILED(InitMetaData())) // impl. see WRITER.CPP
		{
			_ASSERTE(0);
			if(ppClass) *ppClass = NULL;
			return mdTokenNil;
		}
	}
	if(pClass = FindClass(pszFullClassName))
	{
		if(ppClass) *ppClass = pClass;
		tkRet = pClass->m_cl;
	}
	else
	{
		BinStr* pbs = new BinStr();
		pbs->appendInt8(ELEMENT_TYPE_NAME);
		strcpy((char*)(pbs->getBuff((unsigned int)strlen(pszFullClassName)+1)),pszFullClassName);
		if(!ResolveTypeSpecToRef(pbs,&tkRet)) tkRet = mdTokenNil;
		if(ppClass) *ppClass = NULL;
		delete pbs;
	}
	return tkRet;
}

/**************************************************************************/
BOOL Assembler::ResolveTypeSpec(BinStr* typeSpec, mdTypeRef *pcr, Class** ppClass)
{
	if (typeSpec->ptr()[0] == ELEMENT_TYPE_NAME) {
		char* pszName = (char*) &typeSpec->ptr()[1];
		*pcr = ResolveClassRef(pszName, ppClass);
		return TRUE;
	}
	else {
		if(ppClass) *ppClass = NULL;
		return(SUCCEEDED(m_pEmitter->GetTokenFromTypeSpec(typeSpec->ptr(), typeSpec->length(), pcr)));
	}
}

/**************************************************************************/
BOOL Assembler::ResolveTypeSpecToRef(BinStr* typeSpec, mdTypeRef *pcr)
{
	static DWORD	dwRegFlag = 0xFFFFFFFF;

	if((typeSpec == NULL) || (pcr == NULL)) return FALSE;
	if (typeSpec->ptr()[0] == ELEMENT_TYPE_NAME) 
	{
		char *pszFullClassName = (char*) &typeSpec->ptr()[1];
		mdToken	tkResScope = 1; // default: this module
		mdToken tkRet;
		char* pc;
		char* pszNamespace;
		char* pszClassName;
		char* szFullName;

		if((pszFullClassName == NULL)||(*pszFullClassName == 0)
			|| (strcmp(pszFullClassName,"<Module>")==0))
		{
			*pcr = mdTokenNil;
			return TRUE;
		}
		if (m_fInitialisedMetaData == FALSE)
		{
			if (FAILED(InitMetaData())) // impl. see WRITER.CPP
			{
				_ASSERTE(0);
				*pcr = mdTokenNil;
				return FALSE;
			}
		}
		if(szFullName = new char[strlen(pszFullClassName)+1]) strcpy(szFullName,pszFullClassName);
		else
		{
			report->error("\nOut of memory!\n");
			_ASSERTE(0);
			*pcr = mdTokenNil;
			return FALSE;
		}
		if(pc = strrchr(szFullName,'/')) // scope: enclosing class
		{
			*pc = 0;
			pc++;
//			tkResScope = ResolveClassRef(szFullName,NULL); // can't do that - must have TypeRef

			BinStr* pbs = new BinStr();
			pbs->appendInt8(ELEMENT_TYPE_NAME);
			strcpy((char*)(pbs->getBuff((unsigned int)strlen(szFullName)+1)),szFullName);
			if(!ResolveTypeSpecToRef(pbs,&tkResScope)) tkResScope = mdTokenNil;
			delete pbs;
		}
		else if(pc = strrchr(szFullName,'^')) //scope: AssemblyRef or Assembly
		{
			*pc = 0;
			pc++;
			tkResScope = m_pManifest->GetAsmRefTokByName(szFullName);
			if(RidFromToken(tkResScope)==0)
			{
				// if it's mscorlib or self, emit the AssemblyRef
				if((strcmp(szFullName,"mscorlib")==0)||RidFromToken(m_pManifest->GetAsmTokByName(szFullName)))
				{
					char *sz = new char[strlen(szFullName)+1];
					if(sz)
					{
						strcpy(sz,szFullName);
						m_pManifest->StartAssembly(sz,NULL,0,TRUE);
						m_pManifest->EndAssembly();
						tkResScope = m_pManifest->GetAsmRefTokByName(szFullName);
					}
					else
						report->error("\nOut of memory!\n");
				}
				else
					report->error("Undefined assembly ref '%s'\n",szFullName);
			}
		}
		else if(pc = strrchr(szFullName,'~')) //scope: ModuleRef
		{
			*pc = 0;
			pc++;
			if(!strcmp(szFullName,m_szScopeName)) 
					tkResScope = 1; // scope is "this module"
			else
			{
				ImportDescriptor*	pID;	
				int i = 0;
				tkResScope = mdModuleRefNil;
				while(pID=m_ImportList.PEEK(i++))
				{
					if(!strcmp(pID->szDllName,szFullName))
					{
						tkResScope = pID->mrDll;
						break;
					}
				}
				//tkResScope = m_pManifest->GetModuleRefTokByName(szFullName);
				if(RidFromToken(tkResScope)==0)
					report->error("Undefined module ref '%s'\n",szFullName);
			}
		}
		else pc = szFullName;
		if(*pc)
		{
			pszNamespace = pc;
			pszClassName = strrchr(pszNamespace,'.');
			if(pszClassName)
			{
				*pszClassName = 0;
				pszClassName++;
			}
			else
			{
				pszClassName = pszNamespace;
				pszNamespace = NULL;
			}

			WCHAR* wzClassName = new WCHAR[strlen(pszClassName)+1];
			WCHAR* wzNamespace = NULL;
			LPWSTR fullName = wzClassName;
			if(wzClassName)
			{
				// convert name from ASCII to widechar
				WszMultiByteToWideChar(g_uCodePage,0,pszClassName,-1,wzClassName,(int)strlen(pszClassName)+1);
			}
			else
			{
				report->error("\nOut of memory!\n");
				return FALSE;
			}
			if(pszNamespace && strlen(pszNamespace))
			{
				if(wzNamespace = new WCHAR[strlen(pszNamespace)+strlen(pszClassName)+2])
				{
					WszMultiByteToWideChar(g_uCodePage,0,pszNamespace,-1,wzNamespace,(int)strlen(pszNamespace)+1);
					wcscat(wzNamespace,L".");
					wcscat(wzNamespace,wzClassName);
					fullName = wzNamespace;
				}
				else
				{
					report->error("\nOut of memory!\n");
					return FALSE;
				}
			}
			if(FAILED(m_pEmitter->DefineTypeRefByName(tkResScope, fullName, &tkRet))) tkRet = mdTokenNil;
			else if((strchr(pszFullClassName,'~') == NULL)
					&&(strchr(pszFullClassName,'^') == NULL)) // do it for 'local' type refs only
			{
				LocalTypeRefDescr*	pLTRD=NULL;
				int j;
				for(j=0; pLTRD = m_LocalTypeRefDList.PEEK(j); j++) 
				{
					if(pLTRD->m_tok == tkRet) break;
				}
				if(pLTRD == NULL)  // no such TypeRef recorded yet, record it
				{
					if(pLTRD = new LocalTypeRefDescr(pszFullClassName))
					{
						pLTRD->m_tok = tkRet;
						m_LocalTypeRefDList.PUSH(pLTRD);
					}
					else
					{
						report->error("\nOut of memory!\n");
						return FALSE;
					}
				}
			}
			delete szFullName;
			delete [] wzClassName;
			if(wzNamespace) delete [] wzNamespace;
		}
		else tkRet = tkResScope; // works for globals with AssemblyRef or ModuleRef
		return ((*pcr = tkRet) != mdTokenNil);
	}
	else 
	{
		return(SUCCEEDED(m_pEmitter->GetTokenFromTypeSpec(typeSpec->ptr(), typeSpec->length(), pcr)));
	}
}

/**************************************************************************/
static char* WithoutResScope(char* szFullName)
{
	char *pc;
	if(pc = strrchr(szFullName,'^')) pc++;
	else if(pc = strrchr(szFullName,'~')) pc++;
	else pc = szFullName;
	return pc;
}
/**************************************************************************/

void Assembler::StartClass(char* name, DWORD attr)
{
	mdTypeRef	crExtends = mdTypeRefNil;
	Class *pEnclosingClass = m_pCurClass;
	char *szFQN;
	BOOL bIsEnum = FALSE;
	BOOL bIsValueType = FALSE;

	if (m_pCurMethod != NULL)
	{ 
        report->error(".class can not be used when in a method scope\n");
	}
	if(strlen(m_szExtendsClause))
	{
		// has a superclass
		if(IsTdInterface(attr)) report->error("Base class in interface\n");
		bIsEnum = (strcmp(WithoutResScope(m_szExtendsClause),"System.Enum")==0);
		bIsValueType = (strcmp(WithoutResScope(m_szExtendsClause),"System.ValueType")==0);
		if(bIsValueType)
		{
			bIsValueType = !((strcmp(name,"Enum")==0)
				&& (strcmp(m_szFullNS,"System")==0)
				&& m_pManifest && m_pManifest->m_pAssembly && m_pManifest->m_pAssembly->szName
				&& (strcmp(m_pManifest->m_pAssembly->szName,"mscorlib")==0));
		}
		if ((crExtends = ResolveClassRef(m_szExtendsClause, NULL)) == mdTypeRefNil)
		{
			report->error("Unable to resolve class reference to parent class 's'\n",m_szExtendsClause);
		}
	}
	else
	{
		bIsEnum = ((attr & 0x40000000) != 0);
		bIsValueType = ((attr & 0x80000000) != 0);
	}
	attr &= 0x3FFFFFFF;
	if(pEnclosingClass)
	{
		if(szFQN = new char[(int)strlen(pEnclosingClass->m_szFQN)+(int)strlen(name)+2])
									sprintf(szFQN,"%s/%s",pEnclosingClass->m_szFQN,name);
		else
			report->error("\nOut of memory!\n");
	}
	else 
	{
		if(szFQN = new char[(int)strlen(m_szFullNS)+(int)strlen(name)+2])
		{
			if(strlen(m_szFullNS)) sprintf(szFQN,"%s.%s",m_szFullNS,name);
			else strcpy(szFQN,name);
			unsigned L = strlen(szFQN);
			if(L >= MAX_CLASSNAME_LENGTH)
				report->error("Full class name too long (%d characters, %d allowed).\n",L,MAX_CLASSNAME_LENGTH-1);
		}
		else
			report->error("\nOut of memory!\n");
	}
	if(szFQN == NULL) return;

    if(m_pCurClass = FindClass(szFQN))
	{
		m_pCurClass->m_bIsMaster = FALSE;
		//report->warn("Class '%s' already declared, augmenting the declaration.\n",name);
	}
	else
	{
		if (m_fAutoInheritFromObject && (crExtends == mdTypeRefNil) && (!IsTdInterface(attr)))
		{
			BOOL bIsMscorlib = (0 != RidFromToken(m_pManifest->GetAsmTokByName("mscorlib")));
			crExtends = bIsEnum ? 
				ResolveClassRef(bIsMscorlib ? "System.Enum" : "mscorlib^System.Enum",NULL)
				:( bIsValueType ? 
					ResolveClassRef(bIsMscorlib ? "System.ValueType" : "mscorlib^System.ValueType",NULL) 
					: ResolveClassRef(bIsMscorlib ? "System.Object" : "mscorlib^System.Object",NULL));
		}

		m_pCurClass = new Class(name, m_szFullNS, szFQN, bIsValueType, bIsEnum);
		if (m_pCurClass == NULL)
		{
			report->error("Failed to create class '%s'\n",name);
			return;
		}

		{
			DWORD wasAttr = attr;
			if(pEnclosingClass && (!IsTdNested(attr)))
			{
				if(OnErrGo)
					report->error("Nested class has non-nested visibility (0x%08X)\n",attr);
				else
				{
					attr &= ~tdVisibilityMask;
					attr |= (IsTdPublic(wasAttr) ? tdNestedPublic : tdNestedPrivate);
					report->warn("Nested class has non-nested visibility (0x%08X), changed to nested (0x%08X)\n",wasAttr,attr);
				}
			}
			else if((pEnclosingClass==NULL) && IsTdNested(attr))
			{
				if(OnErrGo)
					report->error("Non-nested class has nested visibility (0x%08X)\n",attr);
				else
				{
					attr &= ~tdVisibilityMask;
					attr |= (IsTdNestedPublic(wasAttr) ? tdPublic : tdNotPublic);
					report->warn("Non-nested class has nested visibility (0x%08X), changed to non-nested (0x%08X)\n",wasAttr,attr);
				}
			}
		}
		m_pCurClass->m_Attr = attr;
		m_pCurClass->m_crExtends = crExtends;
		if(!strcmp(szFQN,BASE_OBJECT_CLASSNAME)) m_pCurClass->m_crExtends = mdTypeRefNil;

		if (m_pCurClass->m_dwNumInterfaces = m_nImplList)
		{
			if(bIsEnum)	report->error("Interface(s) in enum\n");
			if(m_pCurClass->m_crImplements = new mdTypeRef[m_nImplList+1])
				memcpy(m_pCurClass->m_crImplements, m_crImplList, (m_nImplList+1)*sizeof(mdTypeRef));
			else
			{
				report->error("Failed to allocate Impl List for class '%s'\n", name);
				m_pCurClass->m_dwNumInterfaces = 0;
			}
		}
		else m_pCurClass->m_crImplements = NULL;
		if(bIsValueType)
		{
			if(!IsTdSealed(attr))
			{
				if(OnErrGo)	report->error("Non-sealed value class\n");
				else
				{
					report->warn("Non-sealed value class, made sealed\n");
					m_pCurClass->m_Attr |= tdSealed;
				}
			}
		}
		m_pCurClass->m_pEncloser = pEnclosingClass;
		m_pCurClass->m_bIsMaster = TRUE;
		AddClass(m_pCurClass, pEnclosingClass); //impl. see ASSEM.CPP
	} // end if(old class) else
	//delete [] szFQN;
	m_tkCurrentCVOwner = m_pCurClass->m_cl;

	m_ClassStack.PUSH(pEnclosingClass);
	ClearImplList();
	strcpy(m_szExtendsClause,"");
}

/**************************************************************************/
void Assembler::EndClass()
{
	m_pCurClass = m_ClassStack.POP();
}

/**************************************************************************/
void Assembler::SetPinvoke(BinStr* DllName, int Ordinal, BinStr* Alias, int Attrs)
{
	if(m_pPInvoke) delete m_pPInvoke;
	if(DllName->length())
	{
		if(m_pPInvoke = new PInvokeDescriptor)
		{
			unsigned l;
			int i=0;
			ImportDescriptor* pID;
			if(pID = EmitImport(DllName))
			{
				m_pPInvoke->mrDll = pID->mrDll;
				m_pPInvoke->szAlias = NULL;
				if(Alias)
				{
					l = Alias->length();
					if(m_pPInvoke->szAlias = new char[l+1])
					{
						memcpy(m_pPInvoke->szAlias,Alias->ptr(),l);
						m_pPInvoke->szAlias[l] = 0;
					}
					else report->error("\nOut of memory!\n");
				}
				m_pPInvoke->dwAttrs = (DWORD)Attrs;
			}
			else
			{
				delete m_pPInvoke;
				m_pPInvoke = NULL;
				report->error("PInvoke refers to undefined imported DLL\n");
			}
		}
		else
			report->error("Failed to allocate PInvokeDescriptor\n");
	}
	else
	{
		m_pPInvoke = NULL; // No DLL name, it's "local" (IJW) PInvoke
		report->error("Local (embedded native) PInvoke method, the resulting PE file is unusable\n");
	}
	if(DllName) delete DllName;
	if(Alias) delete Alias;
}

/**************************************************************************/
void Assembler::StartMethod(char* name, BinStr* sig, CorMethodAttr flags, BinStr* retMarshal, DWORD retAttr)
{
    if (m_pCurMethod != NULL)
    {
        report->error("Cannot declare a method '%s' within another method\n",name);
    }
    if (!m_fInitialisedMetaData)
    {
        if (FAILED(InitMetaData())) // impl. see WRITER.CPP
        {
            _ASSERTE(0);
        }
    }
	if(strlen(name) >= MAX_CLASSNAME_LENGTH)
			report->error("Method '%s' -- name too long (%d characters).\n",name,strlen(name));
	if (!(flags & mdStatic))
		*(sig->ptr()) |= IMAGE_CEE_CS_CALLCONV_HASTHIS;
	else if(*(sig->ptr()) & (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS))
	{
		if(OnErrGo)	report->error("Method '%s' -- both static and instance\n", name);
		else
		{
			report->warn("Method '%s' -- both static and instance, set to static\n", name);
			*(sig->ptr()) &= ~(IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS);
		}
	}

	if(!IsMdPrivateScope(flags))
	{
		Method* pMethod;
		Class* pClass = (m_pCurClass ? m_pCurClass : m_pModuleClass);
		for(int j=0; pMethod = pClass->m_MethodList.PEEK(j); j++)
		{
			if(	(!strcmp(pMethod->m_szName,name)) &&
				(pMethod->m_dwMethodCSig == sig->length())  &&
				(!memcmp(pMethod->m_pMethodSig,sig->ptr(),sig->length()))
				&&(!IsMdPrivateScope(pMethod->m_Attr)))
			{
				report->error("Duplicate method declaration\n");
				break;
			}
		}
	}
	if(m_pCurClass)
	{ // instance method
		if(IsMdAbstract(flags) && !IsTdAbstract(m_pCurClass->m_Attr))
		{
			report->error("Abstract method '%s' in non-abstract class '%s'\n",name,m_pCurClass->m_szName);
		}
        //@todo: check base class.
		//if(IsTdEnum(m_pCurClass->m_Attr)) report->error("Method in enum\n");

		if(!strcmp(name,COR_CTOR_METHOD_NAME))
		{
			flags = (CorMethodAttr)(flags | mdSpecialName);
			if(IsTdInterface(m_pCurClass->m_Attr)) report->error("Constructor in interface\n");

		}
		if(IsTdInterface(m_pCurClass->m_Attr))
		{
			if(!IsMdPublic(flags)) report->error("Non-public method in interface\n");
			if((!IsMdStatic(flags))&&(!(IsMdVirtual(flags) && IsMdAbstract(flags))))
			{
				if(OnErrGo)	report->error("Non-virtual, non-abstract instance method in interface\n");
				else
				{
					report->warn("Non-virtual, non-abstract instance method in interface, set to such\n");
					flags = (CorMethodAttr)(flags |mdVirtual | mdAbstract);
				}
			}

		}
		m_pCurMethod = new Method(this, m_pCurClass, name, sig, flags);
	}
	else
	{
		if(IsMdAbstract(flags))
		{
			if(OnErrGo)	report->error("Global method '%s' can't be abstract\n",name);
			else
			{
				report->warn("Global method '%s' can't be abstract, attribute removed\n",name);
				flags = (CorMethodAttr)(((int) flags) &~mdAbstract);
			}
		}
		if(!IsMdStatic(flags))
		{
			if(OnErrGo)	report->error("Non-static global method '%s'\n",name);
			else
			{
				report->warn("Non-static global method '%s', made static\n",name);
				flags = (CorMethodAttr)(flags | mdStatic);
			}
		}
		m_pCurMethod = new Method(this, m_pCurClass, name, sig, flags);
	    if (m_pCurMethod)
		{
			m_pCurMethod->SetIsGlobalMethod();
			if (m_fInitialisedMetaData == FALSE) InitMetaData();
        }
	}
	if(m_pCurMethod)
	{
		m_pCurMethod->m_pRetMarshal = retMarshal;
		m_pCurMethod->m_dwRetAttr = retAttr;
		m_tkCurrentCVOwner = 0;
		m_pCustomDescrList = &(m_pCurMethod->m_CustomDescrList);
		m_pCurMethod->m_MainScope.dwStart = m_CurPC;
	}
	else report->error("Failed to allocate Method class\n");
}

/**************************************************************************/
void Assembler::EndMethod()
{
	unsigned uLocals;

	strcpy(m_pCurMethod->m_szSourceFileName,m_szSourceFileName);
	memcpy(&(m_pCurMethod->m_guidLang),&m_guidLang,sizeof(GUID));
	memcpy(&(m_pCurMethod->m_guidLangVendor),&m_guidLangVendor,sizeof(GUID));
	memcpy(&(m_pCurMethod->m_guidDoc),&m_guidDoc,sizeof(GUID));
	if(m_pCurMethod->m_pCurrScope != &(m_pCurMethod->m_MainScope))
	{
		report->error("Invalid lexical scope structure in method %s\n",m_pCurMethod->m_szName);
	}
	m_pCurMethod->m_pCurrScope->dwEnd = m_CurPC;
	// ----------emit locals signature-------------------
	if(uLocals = m_pCurMethod->m_Locals.COUNT())
	{
		VarDescr* pVD;
		BinStr*	  pbsSig = new BinStr();
		unsigned cnt;
		HRESULT hr;
		DWORD   cSig;
		COR_SIGNATURE* mySig;

		pbsSig->appendInt8(IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
		cnt = CorSigCompressData(uLocals,pbsSig->getBuff(5));
		pbsSig->remove(5-cnt);
		for(cnt = 0; pVD = m_pCurMethod->m_Locals.PEEK(cnt); cnt++)
		{
			if(pVD->pbsSig) pbsSig->append(pVD->pbsSig);
			else report->error("Undefined type od local var slot %d in method %s\n",cnt,m_pCurMethod->m_szName);
		}

		cSig = pbsSig->length();
		mySig = (COR_SIGNATURE *)(pbsSig->ptr());
	
		if (cSig > 1)    // non-empty signature
		{
			hr = m_pEmitter->GetTokenFromSig(mySig, cSig, &m_pCurMethod->m_LocalsSig);
			m_pCurMethod->m_numLocals = CorSigUncompressData(mySig); // imported func.
			_ASSERTE(SUCCEEDED(hr));
		}
		delete pbsSig;
	}
	//-----------------------------------------------------
    if (DoFixups()) AddMethod(m_pCurMethod); //AddMethod - see ASSEM.CPP
	else
	{
		report->error("Method '%s' compilation failed.\n",m_pCurMethod->m_szName);
	}
    ResetForNextMethod(); // see ASSEM.CPP
}
/**************************************************************************/
BOOL Assembler::DoFixups()
{
    Fixup *pSearch;

    for (int i=0; pSearch = m_lstFixup.PEEK(i);i++)
    {
        Label * pLabel = FindLabel(pSearch->m_szLabel);
        long    offset;

        if (pLabel == NULL)
        {
            report->error("Unable to find forward reference label '%s' called from PC=%d\n",
                pSearch->m_szLabel, pSearch->m_RelativeToPC);

            m_State = STATE_FAIL;
            return FALSE;
        }

        offset = pLabel->m_PC - pSearch->m_RelativeToPC;

        if (pSearch->m_FixupSize == 1)
        {
            if (offset > 127 || offset < -128)
            {
                report->error("Offset of forward reference label '%s' called from PC=%d is too large for 1 byte pcrel\n",
                    pLabel->m_szName, pSearch->m_RelativeToPC);

                m_State = STATE_FAIL;
                return FALSE;
            }

            *pSearch->m_pBytes = (BYTE) offset;
        }   
        else if (pSearch->m_FixupSize == 4)
        {
			/* // why force Intel byte order?
            pSearch->m_pBytes[0] = (BYTE) offset;
            pSearch->m_pBytes[1] = (BYTE) (offset >> 8);
            pSearch->m_pBytes[2] = (BYTE) (offset >> 16);
            pSearch->m_pBytes[3] = (BYTE) (offset >> 24);
			*/
			memcpy(pSearch->m_pBytes,&offset,4);
        }
    }

    return TRUE;
}

/**************************************************************************/
/* rvaLabel is the optional label that indicates this field points at a particular RVA */
void Assembler::AddField(char* name, BinStr* sig, CorFieldAttr flags, char* rvaLabel, BinStr* pVal, ULONG ulOffset)
{
	FieldDescriptor*	pFD;
	ULONG	i,n;
	mdToken tkParent = mdTokenNil;
	Class* pClass;

    if (m_pCurMethod)
		report->error("field cannot be declared within a method\n");

	if(strlen(name) >= MAX_CLASSNAME_LENGTH)
			report->error("Field '%s' -- name too long (%d characters).\n",name,strlen(name));

	if(sig && (sig->length() >= 2))
	{
		if(sig->ptr()[1] == ELEMENT_TYPE_VOID)
			report->error("Illegal use of type 'void'\n");
	}

    if (m_pCurClass)
	{
		tkParent = m_pCurClass->m_cl;

		if(IsTdInterface(m_pCurClass->m_Attr))
		{
			if(!IsFdStatic(flags)) report->warn("Non-static field in interface (CLS violation)\n");
			if(!IsFdPublic(flags)) report->error("Non-public field in interface\n");
		}
	}
	else 
	{
		if(ulOffset != 0xFFFFFFFF)
		{
			report->warn("Offset in global field '%s' is ignored\n",name);
			ulOffset = 0xFFFFFFFF;
		}
		if(!IsFdStatic(flags))
		{
			if(OnErrGo)	report->error("Non-static global field\n");
			else
			{
				report->warn("Non-static global field, made static\n");
				flags = (CorFieldAttr)(flags | fdStatic);
			}
		}
	}
	pClass = (m_pCurClass ? m_pCurClass : m_pModuleClass);
	n = pClass->m_FieldDList.COUNT();
	for(i = 0; i < n; i++)
	{
		pFD = pClass->m_FieldDList.PEEK(i);
		if((pFD->m_tdClass == tkParent)&&(!strcmp(pFD->m_szName,name))
			&&(pFD->m_pbsSig->length() == sig->length())
			&&(memcmp(pFD->m_pbsSig->ptr(),sig->ptr(),sig->length())==0))
		{
			report->error("Duplicate field declaration: '%s'\n",name);
			break;
		}
	}
	if (rvaLabel && !IsFdStatic(flags))
		report->error("Only static fields can have 'at' clauses\n");

	if(i >= n)
	{
		if(pFD = new FieldDescriptor)
		{
			pFD->m_tdClass = tkParent;
			pFD->m_szName = name;
			pFD->m_fdFieldTok = mdTokenNil;
			if((pFD->m_ulOffset = ulOffset) != 0xFFFFFFFF) pClass->m_dwNumFieldsWithOffset++;
			pFD->m_rvaLabel = rvaLabel;
			pFD->m_pbsSig = sig;
			pFD->m_pClass = pClass;
			pFD->m_pbsValue = pVal;
			pFD->m_pbsMarshal = m_pMarshal;
			pFD->m_pPInvoke = m_pPInvoke;
			pFD->m_dwAttr = flags;

			m_tkCurrentCVOwner = 0;
			m_pCustomDescrList = &(pFD->m_CustomDescrList);

			pClass->m_FieldDList.PUSH(pFD);
		}
		else
			report->error("Failed to allocate Field Descriptor\n");
	}
	else
	{
		if(pVal) delete pVal;
		if(m_pPInvoke) delete m_pPInvoke;
		if(m_pMarshal) delete m_pMarshal;
		delete name;
	}
	m_pPInvoke = NULL;
	m_pMarshal = NULL;
}

BOOL Assembler::EmitField(FieldDescriptor* pFD)
{
	size_t	cFieldNameLength = strlen(pFD->m_szName) + 1;
    WCHAR* wzFieldName = new WCHAR[cFieldNameLength];
    HRESULT hr;
    DWORD   cSig;
    COR_SIGNATURE* mySig;
    mdFieldDef mb;
	BYTE	ValType = ELEMENT_TYPE_VOID;
	void * pValue = NULL;
	unsigned lVal = 0;
	BOOL ret = TRUE;

	cSig = pFD->m_pbsSig->length();
	mySig = (COR_SIGNATURE*)(pFD->m_pbsSig->ptr());

	if(wzFieldName)
	{
		// convert name from ASCII to widechar
		WszMultiByteToWideChar(g_uCodePage,0,pFD->m_szName,-1,wzFieldName,(int)cFieldNameLength);
	}
	else
	{
		report->error("\nOut of memory!\n");
		return FALSE;
	}
	if(IsFdPrivateScope(pFD->m_dwAttr))
	{
		WCHAR* p = wcsstr(wzFieldName,L"$PST04");
		if(p) *p = 0;
	}

	if(pFD->m_pbsValue && pFD->m_pbsValue->length())
	{
		ValType = *(pFD->m_pbsValue->ptr());
		lVal = pFD->m_pbsValue->length() - 1; // 1 is type byte
		pValue = (void*)(pFD->m_pbsValue->ptr() + 1);
		if(ValType == ELEMENT_TYPE_STRING)
		{
			//while(lVal % sizeof(WCHAR)) { pFD->m_pbsValue->appendInt8(0); lVal++; }
			lVal /= sizeof(WCHAR);
		}
	}

    hr = m_pEmitter->DefineField(
        pFD->m_tdClass,
        wzFieldName,
        pFD->m_dwAttr,
        mySig,
        cSig,
        ValType,
        pValue,
        lVal,
        &mb
    );
	delete [] wzFieldName;
    if (FAILED(hr))
	{
		report->error("Failed to define field '%s' (HRESULT=0x%08X)\n",pFD->m_szName,hr);
		ret = FALSE;
	}
	else
	{
		//--------------------------------------------------------------------------------
		if(IsFdPinvokeImpl(pFD->m_dwAttr)&&(pFD->m_pPInvoke))
		{
			if(pFD->m_pPInvoke->szAlias == NULL) pFD->m_pPInvoke->szAlias = pFD->m_szName;
			if(FAILED(EmitPinvokeMap(mb,pFD->m_pPInvoke)))
			{
				report->error("Failed to define PInvoke map of .field '%s'\n",pFD->m_szName);
				ret = FALSE;
			}
		}
		//--------------------------------------------------------------------------
		if(pFD->m_pbsMarshal)
		{
			if(FAILED(hr = m_pEmitter->SetFieldMarshal (    
										mb,						// [IN] given a fieldDef or paramDef token  
						(PCCOR_SIGNATURE)(pFD->m_pbsMarshal->ptr()),   // [IN] native type specification   
										pFD->m_pbsMarshal->length())))  // [IN] count of bytes of pvNativeType
			{
				report->error("Failed to set field marshaling for '%s' (HRESULT=0x%08X)\n",pFD->m_szName,hr);
				ret = FALSE;
			}
		}
		//--------------------------------------------------------------------------------
		// Set the the RVA to a dummy value.  later it will be fixed
		// up to be something correct, but if we don't emit something
		// the size of the meta-data will not be correct
		if (pFD->m_rvaLabel) 
		{
			m_fHaveFieldsWithRvas = TRUE;
			hr = m_pEmitter->SetFieldRVA(mb, 0xCCCCCCCC);
			if (FAILED(hr))
			{
				report->error("Failed to set RVA for field '%s' (HRESULT=0x%08X)\n",pFD->m_szName,hr);
				ret = FALSE;
			}
		}
		//--------------------------------------------------------------------------------
		EmitCustomAttributes(mb, &(pFD->m_CustomDescrList));

	}
	pFD->m_fdFieldTok = mb;
	return ret;
}

/**************************************************************************/
void Assembler::EmitByte(int val)
{
	char ch = (char)val;
	unsigned uval = (unsigned)val & 0xFFFFFF00;
	if(uval && (uval != 0xFFFFFF00))
			report->warn("Emitting 0x%X as a byte: data truncated to 0x%X\n",(unsigned)val,(BYTE)ch);
	EmitBytes((BYTE *)&ch,1);
}

/**************************************************************************/
void Assembler::NewSEHDescriptor(void) //sets m_SEHD
{
	m_SEHDstack.PUSH(m_SEHD);
	m_SEHD = new SEH_Descriptor;
	if(m_SEHD == NULL) report->error("Failed to allocate SEH descriptor\n");
}
/**************************************************************************/
void Assembler::SetTryLabels(char * szFrom, char *szTo)
{
	if(!m_SEHD) return;
	Label *pLbl = FindLabel(szFrom);
	if(pLbl)
	{
		m_SEHD->tryFrom = pLbl->m_PC;
		if(pLbl = FindLabel(szTo))	m_SEHD->tryTo = pLbl->m_PC; //FindLabel: ASSEM.CPP
		else report->error("Undefined 2nd label in 'try <label> to <label>'\n");
	}
	else report->error("Undefined 1st label in 'try <label> to <label>'\n");
}
/**************************************************************************/
void Assembler::SetFilterLabel(char *szFilter)
{
	if(!m_SEHD) return;
	Label *pLbl = FindLabel(szFilter);
	if(pLbl)	m_SEHD->sehFilter = pLbl->m_PC;
	else report->error("Undefined label in 'filter <label>'\n");
}
/**************************************************************************/
void Assembler::SetCatchClass(char *szClass)
{
	if(!m_SEHD) return;
	if((m_SEHD->cException = ResolveClassRef(szClass, NULL)) == mdTokenNil)
		report->error("Undefined class '%s' in 'catch <class name>'\n",szClass);
}
/**************************************************************************/
void Assembler::SetHandlerLabels(char *szHandlerFrom, char *szHandlerTo)
{
	if(!m_SEHD) return;
	Label *pLbl = FindLabel(szHandlerFrom);
	if(pLbl)
	{
		m_SEHD->sehHandler = pLbl->m_PC;
		if(szHandlerTo) 
		{
			pLbl = FindLabel(szHandlerTo);
			if(pLbl)
			{
				m_SEHD->sehHandlerTo = pLbl->m_PC;
				return;
			}
		}
		else
		{
			m_SEHD->sehHandlerTo = m_SEHD->sehHandler - 1;
			return;
		}
	}
	report->error("Undefined label in 'handler <label> to <label>'\n");
}
/**************************************************************************/
void Assembler::EmitTry(void) //enum CorExceptionFlag kind, char* beginLabel, char* endLabel, char* handleLabel, char* filterOrClass) 
{
	if(m_SEHD)
	{
		bool isFilter=(m_SEHD->sehClause == COR_ILEXCEPTION_CLAUSE_FILTER), 
			 isFault=(m_SEHD->sehClause == COR_ILEXCEPTION_CLAUSE_FAULT),
			 isFinally=(m_SEHD->sehClause == COR_ILEXCEPTION_CLAUSE_FINALLY);

		AddException(m_SEHD->tryFrom, m_SEHD->tryTo, m_SEHD->sehHandler, m_SEHD->sehHandlerTo,
			m_SEHD->cException, isFilter, isFault, isFinally);
	}
	else report->error("Attempt to EmitTry with NULL SEH descriptor\n");
}
/**************************************************************************/

void Assembler::AddException(DWORD pcStart, DWORD pcEnd, DWORD pcHandler, DWORD pcHandlerTo, mdTypeRef crException, BOOL isFilter, BOOL isFault, BOOL isFinally)
{
    if (m_pCurMethod == NULL)
    {
        report->error("Exceptions can be declared only when in a method scope\n");
        return;
    }

    if (m_pCurMethod->m_dwNumExceptions >= m_pCurMethod->m_dwMaxNumExceptions)
    {
		IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT *ptr = 
			new IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT[m_pCurMethod->m_dwMaxNumExceptions+MAX_EXCEPTIONS];
		if(ptr == NULL)
		{
			report->error("Failed to reallocate SEH buffer\n");
			return;
		}
		memcpy(ptr,m_pCurMethod->m_ExceptionList,m_pCurMethod->m_dwNumExceptions*sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
		delete m_pCurMethod->m_ExceptionList;
		m_pCurMethod->m_ExceptionList = ptr;
		m_pCurMethod->m_dwMaxNumExceptions += MAX_EXCEPTIONS;
    }
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags         = (CorExceptionFlag) (m_pCurMethod->m_dwExceptionFlags | COR_ILEXCEPTION_CLAUSE_OFFSETLEN);    
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].TryOffset     = pcStart;
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].TryLength     = pcEnd - pcStart;
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].HandlerOffset = pcHandler;
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].HandlerLength = pcHandlerTo - pcHandler;
    m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].ClassToken    = crException;
    if (isFilter) { 
        int flag = m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags | COR_ILEXCEPTION_CLAUSE_FILTER;
        m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags = (CorExceptionFlag)flag;  
    }   
    if (isFault) {    
        int flag = m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags | COR_ILEXCEPTION_CLAUSE_FAULT;
        m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags = (CorExceptionFlag)flag;  
    }   
    if (isFinally) {    
        int flag = m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags | COR_ILEXCEPTION_CLAUSE_FINALLY;
        m_pCurMethod->m_ExceptionList[m_pCurMethod->m_dwNumExceptions].Flags = (CorExceptionFlag)flag;  
    }   
    m_pCurMethod->m_dwNumExceptions++;
}

/**************************************************************************/
void Assembler::EmitMaxStack(unsigned val)
{
	if(val > 0xFFFF) report->warn(".maxstack parameter exceeds 65535, truncated to %d\n",val&0xFFFF);
    if (m_pCurMethod) m_pCurMethod->m_MaxStack = val&0xFFFF;
    else  report->error(".maxstack can be used only when in a method scope\n");
}

/**************************************************************************/
void Assembler::EmitLocals(BinStr* sig)
{
	if(sig)
	{
		if (m_pCurMethod)
		{
			ARG_NAME_LIST	*pAN, *pList= getArgNameList();
			if(pList)
			{
				VarDescr*		pVD;
				for(pAN=pList; pAN; pAN = pAN->pNext)
				{
					if(pAN->dwAttr == 0) pAN->dwAttr = m_pCurMethod->m_Locals.COUNT() +1;
					(pAN->dwAttr)--;
					if(pVD = m_pCurMethod->m_Locals.PEEK(pAN->dwAttr))
					{
						if(pVD->bInScope)
						{
							report->warn("Local var slot %d is in use\n",pAN->dwAttr);
						}
						if(pVD->pbsSig && ((pVD->pbsSig->length() != pAN->pSig->length()) ||
							(memcmp(pVD->pbsSig->ptr(),pAN->pSig->ptr(),pVD->pbsSig->length()))))
						{
							report->error("Local var slot %d: type conflict\n",pAN->dwAttr);
						}
					}
					else
					{ // create new entry:
						for(unsigned n = m_pCurMethod->m_Locals.COUNT(); n <= pAN->dwAttr; n++) 
							m_pCurMethod->m_Locals.PUSH(pVD = new VarDescr);
					}
					pVD->dwSlot = pAN->dwAttr;
					pVD->pbsSig = pAN->pSig;
					pVD->bInScope = TRUE;
				}
				if(pVD->pbsSig && (pVD->pbsSig->length() == 1))
				{
					if(pVD->pbsSig->ptr()[0] == ELEMENT_TYPE_VOID)
						report->error("Illegal local var type: 'void'\n");
				}
				m_pCurMethod->m_pCurrScope->pLocals = 
					m_pCurMethod->catArgNameList(m_pCurMethod->m_pCurrScope->pLocals, pList);
			}
		}
		else	report->error(".locals can be used only when in a method scope\n");
		delete sig;
	}
	else report->error("Attempt to EmitLocals with NULL argument\n");
}

/**************************************************************************/
void Assembler::EmitEntryPoint()
{
    if (m_pCurMethod)
    {
		if(!m_fEntryPointPresent)
		{
			if(IsMdStatic(m_pCurMethod->m_Attr))
			{
				m_pCurMethod->m_fEntryPoint = TRUE;
				m_fEntryPointPresent = TRUE;
			}
			else report->error("Non-static method as entry point\n");
		}
		else report->error("Multiple .entrypoint declarations\n");
	}
	else report->error(".entrypoint can be used only when in a method scope\n");
}

/**************************************************************************/
void Assembler::EmitZeroInit()
{
    if (m_pCurMethod) m_pCurMethod->m_Flags |= CorILMethod_InitLocals;
	else report->error(".zeroinit can be used only when in a method scope\n");
}

/**************************************************************************/
void Assembler::SetImplAttr(unsigned short attrval)
{
	if (m_pCurMethod) m_pCurMethod->m_wImplAttr = attrval;
}

/**************************************************************************/
void Assembler::EmitData(void* buffer, unsigned len)
{
	if(buffer && len)
	{
		void* ptr;
		HRESULT hr = m_pCeeFileGen->GetSectionBlock(m_pCurSection, len, 1, &ptr); 
		if (FAILED(hr)) 
		{
			report->error("Could not extend data section (out of memory?)");
			exit(1);
		}
		memcpy(ptr, buffer, len);
	}
}

/**************************************************************************/
void Assembler::EmitDD(char *str)
{
    DWORD       dwAddr = 0;
    GlobalLabel *pLabel = FindGlobalLabel(str);

	ULONG loc;
	HRESULT hr = m_pCeeFileGen->GetSectionDataLen(m_pCurSection, &loc);
	_ASSERTE(SUCCEEDED(hr));

	DWORD* ptr;
	hr = m_pCeeFileGen->GetSectionBlock(m_pCurSection, sizeof(DWORD), 1, (void**) &ptr); 
	if (FAILED(hr)) 
	{
		report->error("Could not extend data section (out of memory?)");
		exit(1);
	}

	if (pLabel != 0) {
		dwAddr = pLabel->m_GlobalOffset;
		if (pLabel->m_Section != m_pGlobalDataSection) {
			report->error("For '&label', label must be in data section");
			m_State = STATE_FAIL;
			}
		}
	else
		AddDeferredGlobalFixup(str, (BYTE*) ptr);

    hr = m_pCeeFileGen->AddSectionReloc(m_pCurSection, loc, m_pGlobalDataSection, srRelocHighLow);
	_ASSERTE(SUCCEEDED(hr));
	m_dwComImageFlags &= ~COMIMAGE_FLAGS_ILONLY; 
	m_dwComImageFlags |= COMIMAGE_FLAGS_32BITREQUIRED;
    *ptr = dwAddr;
}

/**************************************************************************/
GlobalLabel *Assembler::FindGlobalLabel(char *pszName)
{
    GlobalLabel *pSearch;

	for(int i=0; pSearch=m_lstGlobalLabel.PEEK(i); i++)
    {
        if (!strcmp(pSearch->m_szName, pszName)) break;
    }
    return pSearch;
}

/**************************************************************************/

GlobalFixup *Assembler::AddDeferredGlobalFixup(char *pszLabel, BYTE* pReference) 
{
    GlobalFixup *pNew = new GlobalFixup(pszLabel, (BYTE*) pReference);
    if (pNew == NULL)
    {
        report->error("Failed to allocate global fixup\n");
        m_State = STATE_FAIL;
    }
	else
		m_lstGlobalFixup.PUSH(pNew);

    return pNew;
}

/**************************************************************************/
void Assembler::AddDeferredILFixup(ILFixupType Kind)
{ 
    _ASSERTE(Kind != ilGlobal);
  AddDeferredILFixup(Kind, NULL);
}
/**************************************************************************/

void Assembler::AddDeferredILFixup(ILFixupType Kind,
                                   GlobalFixup *GFixup)
{ 
    ILFixup *pNew = new ILFixup(m_CurPC, Kind, GFixup);

	_ASSERTE(m_pCurMethod != NULL);
	if (pNew == NULL)
	{ 
        report->error("Failed to allocate IL fixup\n");
		m_State = STATE_FAIL;
	}
	else
		m_lstILFixup.PUSH(pNew);
}

/**************************************************************************/
void Assembler::EmitDataString(BinStr* str) 
{
	if(str)
	{
		str->appendInt8(0);
		DWORD   DataLen = str->length();
		char	*pb = (char*)(str->ptr());	
		WCHAR   *UnicodeString = new WCHAR[DataLen];

		if(UnicodeString)
		{
			WszMultiByteToWideChar(g_uCodePage,0,pb,-1,UnicodeString,DataLen);
			EmitData(UnicodeString,DataLen*sizeof(WCHAR));
			delete [] UnicodeString;
		}
		else report->error("\nOut of memory!\n");
		delete str;
	}
}



/**************************************************************************/
unsigned Assembler::OpcodeLen(Instr* instr)
{
	return (m_fStdMapping ? OpcodeInfo[instr->opcode].Len : 3);
}
/**************************************************************************/
void Assembler::EmitOpcode(Instr* instr)
{
	if((instr->linenum != m_ulLastDebugLine)||(instr->column != m_ulLastDebugColumn))
	{
		if(m_pCurMethod)
		{
			LinePC *pLPC = new LinePC;
			if(pLPC)
			{
				pLPC->Line = instr->linenum;
				pLPC->Column = instr->column;
				pLPC->PC = m_CurPC;
				m_pCurMethod->m_LinePCList.PUSH(pLPC);
			}
			else report->error("\nOut of memory!\n");
		}
		m_ulLastDebugLine = instr->linenum;
		m_ulLastDebugColumn = instr->column;
	}
	if(instr->opcode == CEE_ENDFILTER)
	{
		if(m_pCurMethod)
		{
			if(m_pCurMethod->m_dwNumEndfilters >= m_pCurMethod->m_dwMaxNumEndfilters)
			{
				DWORD *pdw = new DWORD[m_pCurMethod->m_dwMaxNumEndfilters+MAX_EXCEPTIONS];
				if(pdw == NULL)
				{
					report->error("Failed to reallocate auxiliary SEH buffer\n");
					return;
				}
				memcpy(pdw,m_pCurMethod->m_EndfilterOffsetList,m_pCurMethod->m_dwNumEndfilters*sizeof(DWORD));
				delete m_pCurMethod->m_EndfilterOffsetList;
				m_pCurMethod->m_EndfilterOffsetList = pdw;
				m_pCurMethod->m_dwMaxNumEndfilters += MAX_EXCEPTIONS;
			}
			m_pCurMethod->m_EndfilterOffsetList[m_pCurMethod->m_dwNumEndfilters++] = m_CurPC+2;
		}
	}
    if (m_fStdMapping)
    {
        if (OpcodeInfo[instr->opcode].Len == 2) 
			EmitByte(OpcodeInfo[instr->opcode].Std1);
        EmitByte(OpcodeInfo[instr->opcode].Std2);
    }
    else
    {
		unsigned short us = (unsigned short)instr->opcode;
        EmitByte(REFPRE);
        EmitBytes((BYTE *)&us,2);
    }
	delete instr;
}

/**************************************************************************/
void Assembler::EmitInstrVar(Instr* instr, int var) 
{
	unsigned opc = instr->opcode;
	EmitOpcode(instr);
	if (isShort(opc)) 
	{
		EmitByte(var);
	}
	else
	{ 
		short sh = (short)var;
		EmitBytes((BYTE *)&sh,2);
	}
} 

/**************************************************************************/
void Assembler::EmitInstrVarByName(Instr* instr, char* label)
{
	int idx = -1, nArgVarFlag=0;
	switch(instr->opcode)
	{
		case CEE_LDARGA:
		case CEE_LDARGA_S:
		case CEE_LDARG:
		case CEE_LDARG_S:
		case CEE_STARG:
		case CEE_STARG_S:
			nArgVarFlag++;
		case CEE_LDLOCA:
		case CEE_LDLOCA_S:
		case CEE_LDLOC:
		case CEE_LDLOC_S:
		case CEE_STLOC:
		case CEE_STLOC_S:

			if(m_pCurMethod)
			{
				if(nArgVarFlag == 1)
				{
					idx = m_pCurMethod->findArgNum(m_pCurMethod->m_firstArgName,label);
				}
				else
				{
					ARG_NAME_LIST	*pAN;
					for(Scope* pSC = m_pCurMethod->m_pCurrScope; pSC; pSC=pSC->pSuperScope)
					{
						for(pAN = pSC->pLocals; pAN; pAN = pAN->pNext)
						{
							if(!strcmp(pAN->szName,label))
							{
								idx = (int)(pAN->dwAttr);
								break;
							}
						}
						if(idx >= 0) break;
					}
				}
				if(idx >= 0) EmitInstrVar(instr, 
					((nArgVarFlag==0)||(m_pCurMethod->m_Attr & mdStatic))? idx : idx+1);
				else	report->error("Undeclared identifier %s\n",label);
			}
			else
				report->error("Instructions can be used only when in a method scope\n");
			break;
		default:
			report->error("Named argument illegal for this instruction\n");
	}
}

/**************************************************************************/
void Assembler::EmitInstrI(Instr* instr, int val) 
{
	unsigned opc = instr->opcode;
	EmitOpcode(instr);
	if (isShort(opc)) 
	{
		EmitByte(val);
	}
	else
	{
		int i = val;
		EmitBytes((BYTE *)&i,sizeof(int));
	}
}

/**************************************************************************/
void Assembler::EmitInstrI8(Instr* instr, __int64* val)
{
	EmitOpcode(instr);
	EmitBytes((BYTE *)val, sizeof(__int64));
	delete val;
}

/**************************************************************************/
void Assembler::EmitInstrR(Instr* instr, double* pval)
{
	unsigned opc = instr->opcode;
	EmitOpcode(instr);
	if (isShort(opc)) 
	{
		float val = (float)*pval;
		EmitBytes((BYTE *)&val, sizeof(float));
	}
	else
		EmitBytes((BYTE *)pval, sizeof(double));
}

/**************************************************************************/
void Assembler::EmitInstrBrTarget(Instr* instr, char* label) 
{
	int pcrelsize = (isShort(instr->opcode) ? 1 : 4);
	EmitOpcode(instr);
    AddDeferredFixup(label, m_pCurOutputPos,
                                   (m_CurPC + pcrelsize), pcrelsize);
	if(pcrelsize == 1) EmitByte(0);
	else
	{
		DWORD i = 0;
		EmitBytes((BYTE *)&i,4);
	}
}
/**************************************************************************/
void Assembler::AddDeferredFixup(char *pszLabel, BYTE *pBytes, DWORD RelativeToPC, BYTE FixupSize)
{
    Fixup *pNew = new Fixup(pszLabel, pBytes, RelativeToPC, FixupSize);

    if (pNew == NULL)
    {
        report->error("Failed to allocate deferred fixup\n");
        m_State = STATE_FAIL;
    }
    else
		m_lstFixup.PUSH(pNew);
}
/**************************************************************************/
void Assembler::EmitInstrBrOffset(Instr* instr, int offset) 
{
	unsigned opc=instr->opcode;
	EmitOpcode(instr);
	if(isShort(opc))	EmitByte(offset);
	else
	{
		int i = offset;
		EmitBytes((BYTE *)&i,4);
	}
}

/**************************************************************************/
mdToken Assembler::MakeMemberRef(BinStr* typeSpec, char* pszMemberName, BinStr* sig, unsigned opcode_len)
{	
    DWORD			cSig = sig->length();
    COR_SIGNATURE*	mySig = (COR_SIGNATURE *)(sig->ptr());
	mdMemberRef		mr = mdMemberRefNil;
	Class*			pClass = NULL;
	BOOL			bIsNotVararg = ((*mySig & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_VARARG);

    mdTypeRef cr = mdTypeRefNil;
    if (typeSpec != 0)
	{
		if(opcode_len && bIsNotVararg) // we are dealing with an instruction, so we can put a fixup here
		{
			if(!ResolveTypeSpec(typeSpec, &cr, &pClass))
			{
				report->error("Unable to resolve class reference\n");
				return 0;
			}
		}
		else
		{
			if(!ResolveTypeSpecToRef(typeSpec, &cr))
			{
				report->error("Unable to resolve class reference\n");
				return 0;
			}
		}
	}
	else cr=mdTokenNil;

	if(opcode_len 
		&& ((TypeFromToken(cr) == mdtTypeDef)||(cr == mdTokenNil))
		&& bIsNotVararg	)
	{
		MemberRefDescriptor* pMRD = new MemberRefDescriptor;
		if(pMRD)
		{
			pMRD->m_tdClass = cr;
			pMRD->m_pClass = pClass;
			pMRD->m_szName = pszMemberName;
			pMRD->m_pSigBinStr = sig;
			pMRD->m_ulOffset = m_CurPC + opcode_len;
			m_pCurMethod->m_MemberRefDList.PUSH(pMRD);
		}
		else
		{
			report->error("Failed to allocate MemberRef Descriptor\n");
			return 0;
		}
	}
	else
	{
			// convert name from ASCII to widechar
		WCHAR* wzMemberName = new WCHAR[strlen(pszMemberName) + 1];
		if(wzMemberName)
			WszMultiByteToWideChar(g_uCodePage,0,pszMemberName,-1,wzMemberName,(int)strlen(pszMemberName)+1);
		else
		{
			report->error("\nOut of memory!\n");
			return 0;
		}

		if(cr == mdTokenNil) cr = mdTypeRefNil;
		if(TypeFromToken(cr) == mdtAssemblyRef)
		{
			report->error("Cross-assembly global references are not supported ('%s')\n", pszMemberName);
			mr = 0;
		}
		else
		{
			HRESULT hr = m_pEmitter->DefineMemberRef(cr, wzMemberName, mySig, cSig, &mr);
			if(FAILED(hr))
			{
				report->error("Unable to define member reference '%s'\n", pszMemberName);
				mr = 0;
			}
		}
		//if(m_fOBJ)	m_pCurMethod->m_TRDList.PUSH(new TokenRelocDescr(m_CurPC,mr));
		delete pszMemberName;
		delete [] wzMemberName;
		delete sig;
	}

	delete typeSpec;
	return mr;
}
/**************************************************************************/
void Assembler::EndEvent(void) 
{ 
	Class* pClass = (m_pCurClass ? m_pCurClass : m_pModuleClass);
    if(m_pCurEvent->m_pmdAddOn == NULL)
        report->error("Event %s of class %s has no Add method. Event not emitted.",
                      m_pCurEvent->m_szName,m_pCurClass->m_szName);
    else if(m_pCurEvent->m_pmdRemoveOn == NULL)
        report->error("Event %s of class %s has no Remove method. Event not emitted.",
                      m_pCurEvent->m_szName,m_pCurClass->m_szName);
    else pClass->m_EventDList.PUSH(m_pCurEvent); 
	m_pCurEvent = NULL; 
}

void Assembler::ResetEvent(char* szName, BinStr* typeSpec, DWORD dwAttr) 
{
	if(strlen(szName) >= MAX_CLASSNAME_LENGTH)
			report->error("Event '%s' -- name too long (%d characters).\n",szName,strlen(szName));
	if(m_pCurEvent = new EventDescriptor)
	{
		memset(m_pCurEvent,0,sizeof(EventDescriptor));
		m_pCurEvent->m_tdClass = m_pCurClass->m_cl;
		m_pCurEvent->m_szName = new char[strlen(szName)+1];
		strcpy(m_pCurEvent->m_szName,szName);
		m_pCurEvent->m_dwAttr = dwAttr;
		m_pCurEvent->m_tkEventType = mdTypeRefNil;
		if (typeSpec) 
			FAIL_UNLESS(ResolveTypeSpec(typeSpec, &m_pCurEvent->m_tkEventType,NULL), ("Unable to resolve class reference\n"));
		m_tkCurrentCVOwner = 0;
		m_pCustomDescrList = &(m_pCurEvent->m_CustomDescrList);
	}
	else report->error("Failed to allocate Event Descriptor\n");

}

void Assembler::SetEventMethod(int MethodCode, BinStr* typeSpec, char* pszMethodName, BinStr* sig) 
{
    DWORD			cSig = sig->length();
    COR_SIGNATURE*	mySig = (COR_SIGNATURE *)(sig->ptr());
	MethodDescriptor* pMD = new MethodDescriptor;
	if(pMD == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	memset(pMD,0,sizeof(MethodDescriptor));
	pMD->m_szName = new char[strlen(pszMethodName)+1];
	if(pMD->m_szName == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	strcpy(pMD->m_szName,pszMethodName);
	pMD->m_pSig = new COR_SIGNATURE[cSig];
	if(pMD->m_pSig == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	memcpy(pMD->m_pSig,mySig,cSig);
	pMD->m_dwCSig = cSig;
	pMD->m_tdClass = m_pCurClass->m_cl;
	// for now, ignore TypeSpec
    //if (typeSpec) FAIL_UNLESS(ResolveTypeSpec(typeSpec, &cr), ("Unable to resolve class reference\n"));
	switch(MethodCode)
	{
		case 0:
			m_pCurEvent->m_pmdAddOn = pMD;
			break;
		case 1:
			m_pCurEvent->m_pmdRemoveOn = pMD;
			break;
		case 2:
			m_pCurEvent->m_pmdFire = pMD;
			break;
		case 3:
			m_pCurEvent->m_mdlOthers.PUSH(pMD);
			break;
	}
}
/**************************************************************************/

void Assembler::EndProp(void)
{ 
	Class* pClass = (m_pCurClass ? m_pCurClass : m_pModuleClass);
	pClass->m_PropDList.PUSH(m_pCurProp); 
	m_pCurProp = NULL; 
}

void Assembler::ResetProp(char * szName, BinStr* bsType, DWORD dwAttr, BinStr* pValue) 
{
    DWORD			cSig = bsType->length();
    COR_SIGNATURE*	mySig = (COR_SIGNATURE *)(bsType->ptr());

	if(strlen(szName) >= MAX_CLASSNAME_LENGTH)
			report->error("Property '%s' -- name too long (%d characters).\n",szName,strlen(szName));
	m_pCurProp = new PropDescriptor;
	if(m_pCurProp == NULL)
	{
		report->error("Failed to allocate Property Descriptor\n");
		return;
	}
	memset(m_pCurProp,0,sizeof(PropDescriptor));
	m_pCurProp->m_tdClass = m_pCurClass->m_cl;
	m_pCurProp->m_szName = new char[strlen(szName)+1];
	if(m_pCurProp->m_szName == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	strcpy(m_pCurProp->m_szName,szName);
	m_pCurProp->m_dwAttr = dwAttr;

	m_pCurProp->m_pSig = new COR_SIGNATURE[cSig];
	if(m_pCurProp->m_pSig == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	memcpy(m_pCurProp->m_pSig,mySig,cSig);
	m_pCurProp->m_dwCSig = cSig;

	if(pValue && pValue->length())
	{
		BYTE* pch = pValue->ptr();
		m_pCurProp->m_dwCPlusTypeFlag = (DWORD)(*pch);
		m_pCurProp->m_cbValue = pValue->length() - 1;
		m_pCurProp->m_pValue = (PVOID)(pch+1);
		if(m_pCurProp->m_dwCPlusTypeFlag == ELEMENT_TYPE_STRING) m_pCurProp->m_cbValue /= sizeof(WCHAR);
		m_pCurProp->m_dwAttr |= prHasDefault;
	}
	else
	{
		m_pCurProp->m_dwCPlusTypeFlag = ELEMENT_TYPE_VOID;
		m_pCurProp->m_pValue = NULL;
		m_pCurProp->m_cbValue = 0;
	}
	m_tkCurrentCVOwner = 0;
	m_pCustomDescrList = &(m_pCurProp->m_CustomDescrList);
}

void Assembler::SetPropMethod(int MethodCode, BinStr* typeSpec, char* pszMethodName, BinStr* sig)
{
    DWORD			cSig = sig->length();
    COR_SIGNATURE*	mySig = (COR_SIGNATURE *)(sig->ptr());
	MethodDescriptor* pMD = new MethodDescriptor;
	if(pMD == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	memset(pMD,0,sizeof(MethodDescriptor));
	pMD->m_szName = new char[strlen(pszMethodName)+1];
	if(pMD->m_szName == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	strcpy(pMD->m_szName,pszMethodName);
	pMD->m_pSig = new COR_SIGNATURE[cSig];
	if(pMD->m_pSig == NULL)
	{
		report->error("\nOut of memory!\n");
		return;
	}
	memcpy(pMD->m_pSig,mySig,cSig);
	pMD->m_dwCSig = cSig;
	pMD->m_tdClass = m_pCurClass->m_cl;
	// for now, ignore TypeSpec
    //if (typeSpec) FAIL_UNLESS(ResolveTypeSpec(typeSpec, &cr), ("Unable to resolve class reference\n"));
	switch(MethodCode)
	{
		case 0:
			m_pCurProp->m_pmdSet = pMD;
			break;
		case 1:
			m_pCurProp->m_pmdGet = pMD;
			break;
		case 2:
			m_pCurProp->m_mdlOthers.PUSH(pMD);
			break;
	}
}

/**************************************************************************/
mdToken Assembler::MakeTypeRef(BinStr* typeSpec)
{
    mdTypeRef cr;
	if(!ResolveTypeSpec(typeSpec, &cr,NULL))
	{
		report->error("Unable to resolve class reference\n");
		cr = 0;
	}
//	if(m_fOBJ)	m_pCurMethod->m_TRDList.PUSH(new TokenRelocDescr(m_CurPC,cr));
	return cr;
}

/**************************************************************************/
void Assembler::EmitInstrStringLiteral(Instr* instr, BinStr* literal, BOOL ConvertToUnicode)
{
    DWORD   DataLen = literal->length(),L;
	unsigned __int8	*pb = literal->ptr();
	HRESULT hr = S_OK;
	mdToken tk;
    WCHAR   *UnicodeString;
	if(DataLen == 0) 
	{
		//report->warn("Zero length string emitted\n");
		ConvertToUnicode = FALSE;
	}
	if(ConvertToUnicode)
	{
		UnicodeString = new WCHAR[DataLen+1];
		literal->appendInt8(0);
		pb = literal->ptr();
		// convert string to Unicode
		L = UnicodeString ? WszMultiByteToWideChar(g_uCodePage,0,(char*)pb,-1,UnicodeString,DataLen+1) : 0;
		if(L == 0)
		{
			char* sz=NULL;
			DWORD dw;
			switch(dw=GetLastError())
			{
				case ERROR_INSUFFICIENT_BUFFER: sz = "ERROR_INSUFFICIENT_BUFFER"; break;
				case ERROR_INVALID_FLAGS:		sz = "ERROR_INVALID_FLAGS"; break;
				case ERROR_INVALID_PARAMETER:	sz = "ERROR_INVALID_PARAMETER"; break;
				case ERROR_NO_UNICODE_TRANSLATION: sz = "ERROR_NO_UNICODE_TRANSLATION"; break;
			}
			if(sz)	report->error("Failed to convert string '%s' to Unicode: %s\n",(char*)pb,sz);
			else	report->error("Failed to convert string '%s' to Unicode: error 0x%08X\n",(char*)pb,dw);
			delete instr;
			goto OuttaHere;
		}
		L--;
	}
	else
	{
		UnicodeString = (WCHAR*)pb;
		L = DataLen/sizeof(WCHAR);
	}
	// Add the string data to the metadata, which will fold dupes.
	hr = m_pEmitter->DefineUserString(
		UnicodeString,
		L,
		&tk
	);
	if (FAILED(hr))
    {
        report->error("Failed to add user string using DefineUserString, hr=0x%08x, data: '%S'\n",
               hr, UnicodeString);
		delete instr;
    }
	else
	{
		EmitOpcode(instr);
		if(m_fOBJ)	m_pCurMethod->m_TRDList.PUSH(new TokenRelocDescr(m_CurPC,tk));

		EmitBytes((BYTE *)&tk,sizeof(mdToken));
	}
OuttaHere:
	delete literal;
	if((void*)UnicodeString != (void*)pb) delete [] UnicodeString;
}

/**************************************************************************/
void Assembler::EmitInstrSig(Instr* instr, BinStr* sig)
{
	mdSignature MetadataToken;
    DWORD       cSig = sig->length();
    COR_SIGNATURE* mySig = (COR_SIGNATURE *)(sig->ptr());

	if (FAILED(m_pEmitter->GetTokenFromSig(mySig, cSig, &MetadataToken)))
	{
		report->error("Unable to convert signature to metadata token.\n");
		delete instr;
	}
	else
	{
		EmitOpcode(instr);
		if(m_fOBJ)	m_pCurMethod->m_TRDList.PUSH(new TokenRelocDescr(m_CurPC,MetadataToken));
		EmitBytes((BYTE *)&MetadataToken, sizeof(mdSignature));
	}
	delete sig;
}

/**************************************************************************/
void Assembler::EmitInstrRVA(Instr* instr, char* label, bool islabel)
{
    long lOffset = 0;
    GlobalLabel *pGlobalLabel;

	EmitOpcode(instr);

	if(islabel)
	{
		AddDeferredILFixup(ilRVA);
        if(pGlobalLabel = FindGlobalLabel(label)) lOffset = pGlobalLabel->m_GlobalOffset;
		else 
		{
			GlobalFixup *GFixup = AddDeferredGlobalFixup(label, m_pCurOutputPos);
			AddDeferredILFixup(ilGlobal, GFixup);
		}
	}
	else
	{
		lOffset = (long)label;
	}
	EmitBytes((BYTE *)&lOffset,4);
}

/**************************************************************************/
void Assembler::EmitInstrSwitch(Instr* instr, Labels* targets) 
{
	Labels	*pLbls;
    int     NumLabels;
	Label	*pLabel;
	long	offset;

	EmitOpcode(instr);

    // count # labels
	for(pLbls = targets, NumLabels = 0; pLbls; pLbls = pLbls->Next, NumLabels++);

    EmitBytes((BYTE *)&NumLabels,sizeof(int));
    DWORD PC_nextInstr = m_CurPC + 4*NumLabels;
	for(pLbls = targets; pLbls; pLbls = pLbls->Next)
	{
		if(pLbls->isLabel)
		{
			if(pLabel = FindLabel(pLbls->Label))
			{
				offset = pLabel->m_PC - PC_nextInstr;
				if (m_fDisplayTraceOutput) report->msg("%d\n", offset);
			}
			else
			{
				// defer until we find the label
				AddDeferredFixup(pLbls->Label, m_pCurOutputPos, PC_nextInstr, 4 /* pcrelsize */ );
				offset = 0;
				if (m_fDisplayTraceOutput) report->msg("forward label %s\n", pLbls->Label);
			}
		}
		else
		{
            offset = (long)pLbls->Label;
            if (m_fDisplayTraceOutput) report->msg("%d\n", offset);
		}
        EmitBytes((BYTE *)&offset, sizeof(long));
	}
	delete targets;
}

/**************************************************************************/
void Assembler::EmitInstrPhi(Instr* instr, BinStr* vars) 
{
	BYTE i = (BYTE)(vars->length() / 2);
	EmitOpcode(instr);
	EmitBytes((BYTE *)&i,1);
	EmitBytes((BYTE *)vars->ptr(), vars->length());
	delete vars;
}

/**************************************************************************/
void Assembler::EmitLabel(char* label) 
{
	_ASSERTE(m_pCurMethod);
	AddLabel(m_CurPC, label);
}
/**************************************************************************/
void Assembler::EmitDataLabel(char* label) 
{
	AddGlobalLabel(label, m_pCurSection);
}

/**************************************************************************/
void Assembler::EmitBytes(BYTE *p, unsigned len) 
{
	if(m_pCurOutputPos + len >= m_pEndOutputPos)
	{
		size_t buflen = m_pEndOutputPos - m_pOutputBuffer;
		size_t newlen = buflen+(len/OUTPUT_BUFFER_INCREMENT + 1)*OUTPUT_BUFFER_INCREMENT;
		BYTE *pb = new BYTE[newlen];
		if(pb == NULL)
		{
			report->error("Failed to extend output buffer from %d to %d bytes. Aborting\n",
				buflen, newlen);
			exit(1);
		}
		size_t delta = pb - m_pOutputBuffer;
		int i;
		Fixup* pSearch;
		GlobalFixup *pGSearch;
	    for (i=0; pSearch = m_lstFixup.PEEK(i); i++) pSearch->m_pBytes += delta;
	    for (i=0; pGSearch = m_lstGlobalFixup.PEEK(i); i++) //need to move only those pointing to output buffer
		{
			if((pGSearch->m_pReference >= m_pOutputBuffer)&&(pGSearch->m_pReference <= m_pEndOutputPos))
				pGSearch->m_pReference += delta;
		}

		
		memcpy(pb,m_pOutputBuffer,m_CurPC);
		delete m_pOutputBuffer;
		m_pOutputBuffer = pb;
		m_pCurOutputPos = &m_pOutputBuffer[m_CurPC];
		m_pEndOutputPos = &m_pOutputBuffer[newlen];

	}
	memcpy(m_pCurOutputPos,p,len);
	m_pCurOutputPos += len;
	m_CurPC += len;
}

/**************************************************************************/
void Assembler::EmitSecurityInfo(mdToken            token,
                                 PermissionDecl*    pPermissions,
                                 PermissionSetDecl* pPermissionSets)
{
    PermissionDecl     *pPerm, *pPermNext;
    PermissionSetDecl  *pPset, *pPsetNext;
    unsigned            uCount = 0;
    COR_SECATTR        *pAttrs;
    unsigned            i;
    unsigned            uLength;
    mdTypeRef           tkTypeRef;
    BinStr             *pSig;
    char               *szMemberName;
    DWORD               dwErrorIndex;

    if (pPermissions) {

        for (pPerm = pPermissions; pPerm; pPerm = pPerm->m_Next)
            uCount++;

        if((pAttrs = new COR_SECATTR[uCount])==NULL)
		{
			report->error("\nOut of memory!\n");
			return;
		}

        for (pPerm = pPermissions, i = 0; pPerm; pPerm = pPermNext, i++) {
            pPermNext = pPerm->m_Next;

            tkTypeRef = ResolveClassRef("mscorlib^System.Security.Permissions.SecurityAction", NULL);
            pSig = new BinStr();
            pSig->appendInt8(IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS);
            pSig->appendInt8(1);
            pSig->appendInt8(ELEMENT_TYPE_VOID);
            pSig->appendInt8(ELEMENT_TYPE_VALUETYPE);
            uLength = CorSigCompressToken(tkTypeRef, pSig->getBuff(5));
            pSig->remove(5 - uLength);

            if(szMemberName = new char[strlen(COR_CTOR_METHOD_NAME) + 1])
			{
				strcpy(szMemberName, COR_CTOR_METHOD_NAME);
		        pAttrs[i].tkCtor = MakeMemberRef(pPerm->m_TypeSpec, szMemberName, pSig, 0);
				pAttrs[i].pCustomAttribute = (const void *)pPerm->m_Blob;
				pAttrs[i].cbCustomAttribute = pPerm->m_BlobLength;
				pPerm->m_TypeSpec = NULL;
				pPerm->m_Blob = NULL;
			}
			else report->error("\nOut of memory!\n");
            delete pPerm;
        }

        if (m_pEmitter->DefineSecurityAttributeSet(token,
                                                   pAttrs,
                                                   uCount,
                                                   &dwErrorIndex))
            if (dwErrorIndex == uCount)
                report->error("Failed to define security attribute set for 0x%08X\n", token);
            else
                report->error("Failed to define security attribute set for 0x%08X\n  (error in permission %u)\n",
                              token, uCount - dwErrorIndex);

        for (i =0; i < uCount; i++)
            delete [] (BYTE*)pAttrs[i].pCustomAttribute;
        delete [] pAttrs;
    }

    for (pPset = pPermissionSets; pPset; pPset = pPsetNext) {
        pPsetNext = pPset->m_Next;
        if(m_pEmitter->DefinePermissionSet(token,
                                           pPset->m_Action,
                                           pPset->m_Value->ptr(),
                                           pPset->m_Value->length(),
                                           NULL))
            report->error("Failed to define security permission set for 0x%08X\n", token);
        delete pPset;
    }
}

void Assembler::AddMethodImpl(BinStr* pImplementedTypeSpec, char* szImplementedName, BinStr* pSig, 
					BinStr* pImplementingTypeSpec, char* szImplementingName)
{
	if(m_pCurClass)
	{
		MethodImplDescriptor*	pMID = new MethodImplDescriptor;
		if(pMID == NULL)
		{
			report->error("Failed to allocate MethodImpl Descriptor\n");
			return;
		}
		pMID->m_pbsImplementedTypeSpec  = pImplementedTypeSpec;
		pMID->m_szImplementedName = szImplementedName;
		pMID->m_tkDefiningClass = m_pCurClass->m_cl;
		pMID->m_tkImplementingMethod = 0;
		if(pSig) //called from class scope, overriding method specified
		{
			pMID->m_pbsImplementingTypeSpec = pImplementingTypeSpec;
			pMID->m_szImplementingName = szImplementingName;
			pMID->m_pbsSig = pSig;
		}
		else	//called from method scope, use current method as overriding
		{
			if(m_pCurMethod)
			{
				pMID->m_pbsSig = new BinStr;
				memcpy(pMID->m_pbsSig->getBuff(m_pCurMethod->m_dwMethodCSig),m_pCurMethod->m_pMethodSig,m_pCurMethod->m_dwMethodCSig);
				pMID->m_pbsImplementingTypeSpec = new BinStr;
				if(m_pCurMethod->m_pClass)
				{
					pMID->m_pbsImplementingTypeSpec = new BinStr;
					char* szFQN = m_pCurMethod->m_pClass->m_szFQN;
					unsigned L = (unsigned)(strlen(szFQN)+1);
					pMID->m_pbsImplementingTypeSpec->appendInt8(ELEMENT_TYPE_NAME);
					memcpy(pMID->m_pbsImplementingTypeSpec->getBuff(L),szFQN,L);
				}
				else pMID->m_pbsImplementingTypeSpec = NULL;

				pMID->m_szImplementingName = new char[strlen(m_pCurMethod->m_szName)+1];
				strcpy(pMID->m_szImplementingName,m_pCurMethod->m_szName);
				
				m_pCurMethod->m_MethodImplDList.PUSH(pMID); // copy goes to method's own list (ptr only)
			}
			else
			{
				report->error("No overriding method specified");
				delete pMID;
				return;
			}
		}
		m_MethodImplDList.PUSH(pMID);
	}
	else
		report->error(".override directive outside class scope");
}
// source file name paraphernalia
void Assembler::SetSourceFileName(char* szName)
{
	if(szName && *szName)
	{
		if(strcmp(m_szSourceFileName,szName))
		{
			strcpy(m_szSourceFileName,szName);
		}
	}
}
void Assembler::SetSourceFileName(BinStr* pbsName)
{
	if(pbsName && pbsName->length())
	{
		pbsName->appendInt8(0);
		SetSourceFileName((char*)(pbsName->ptr()));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\assem.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// assem.cpp
//
// COM+ IL assembler (a quickly put-together hack).
//
// First version:  jforbes   01/27/98
//
#define INITGUID

#define DECLARE_DATA

#include "assembler.h"
extern unsigned int g_uCodePage;

char g_szSourceFileName[MAX_FILENAME_LENGTH*3];

Assembler::Assembler()
{
    m_pDisp = NULL; 
    m_pEmitter = NULL;  
    m_pHelper = NULL;   

    m_fCPlusPlus = FALSE;
    m_fWindowsCE = FALSE;
    m_fGenerateListing = FALSE;

	char* szName = new char[16];
	strcpy(szName,"<Module>");
	char* szFQN = new char[16];
	strcpy(szFQN,"<Module>");

    m_pModuleClass = new Class(szName,"",szFQN,FALSE,FALSE);
	m_pModuleClass->m_cl = mdTokenNil;
	m_lstClass.PUSH(m_pModuleClass);

    m_fStdMapping   = FALSE;
    m_fDisplayTraceOutput= FALSE;

    m_pCurOutputPos = NULL;

    m_CurPC             = 0;    // PC offset in method
    m_pCurMethod        = NULL;
    m_pCurClass         = NULL;
	m_pCurEvent			= NULL;
	m_pCurProp			= NULL;

    m_pEmitter          = NULL;
    
    m_pCeeFileGen            = NULL;
    m_pCeeFile               = 0;

	m_pManifest			= NULL;

	m_pCustomDescrList	= NULL;
    
    m_pGlobalDataSection = NULL;
    m_pILSection = NULL;
    m_pTLSSection = NULL;

    m_fDidCoInitialise = FALSE;

	m_fDLL = FALSE;
	m_fEntryPointPresent = FALSE;
	m_fHaveFieldsWithRvas = FALSE;

    strcpy(m_szScopeName, "");
	strcpy(m_szExtendsClause,"");

	m_nImplList = 0;

	m_SEHD = NULL;
	m_firstArgName = NULL;
	m_szNamespace = new char[2];
	m_szNamespace[0] = 0;
	m_NSstack.PUSH(m_szNamespace);

	m_szFullNS = new char[MAX_NAMESPACE_LENGTH];
	memset(m_szFullNS,0,MAX_NAMESPACE_LENGTH);
	m_ulFullNSLen = MAX_NAMESPACE_LENGTH;

    m_State             = STATE_OK;
    m_fInitialisedMetaData = FALSE;
    m_fAutoInheritFromObject = TRUE;

	m_ulLastDebugLine = 0xFFFFFFFF;
	m_ulLastDebugColumn = 0xFFFFFFFF;
	m_pSymWriter = NULL;
	m_pSymDocument = NULL;
	m_fIncludeDebugInfo = FALSE;

	m_pVTable = NULL;
	m_pMarshal = NULL;
	m_fReportProgress = TRUE;
	m_tkCurrentCVOwner = 1; // module
	m_pOutputBuffer = NULL;

	m_fOwnershipSet = FALSE;
	m_pbsOwner = NULL;

	m_dwSubsystem = IMAGE_SUBSYSTEM_UNKNOWN;
	m_dwComImageFlags = COMIMAGE_FLAGS_ILONLY;
	m_dwFileAlignment = 0;
    m_stBaseAddress = 0;

	g_szSourceFileName[0] = 0;

	memset(&m_guidLang,0,sizeof(GUID));
	memset(&m_guidLangVendor,0,sizeof(GUID));
	memset(&m_guidDoc,0,sizeof(GUID));
}


Assembler::~Assembler()
{
    Fixup   *pFix;
    Label   *pLab;
    Class   *pClass;
    GlobalLabel *pGlobalLab;
    GlobalFixup *pGlobalFix;

	if(m_pMarshal) delete m_pMarshal;
	if(m_pManifest) delete m_pManifest;

	if(m_pVTable) delete m_pVTable;

	while(pFix = m_lstFixup.POP()) delete(pFix);
	while(pLab = m_lstLabel.POP()) delete(pLab);
	while(pGlobalLab = m_lstGlobalLabel.POP()) delete(pGlobalLab);
	while(pGlobalFix = m_lstGlobalFixup.POP()) delete(pGlobalFix);
	while(pClass = m_lstClass.POP()) delete(pClass);
	while(m_ClassStack.POP());
	m_pCurClass = NULL;

    if (m_pOutputBuffer)	delete m_pOutputBuffer;
	if (m_crImplList)		delete m_crImplList;

    if (m_pCeeFileGen != NULL) {
        if (m_pCeeFile)
            m_pCeeFileGen->DestroyCeeFile(&m_pCeeFile);
        DestroyICeeFileGen(&m_pCeeFileGen);
        m_pCeeFileGen = NULL;
    }

	while(m_szNamespace = m_NSstack.POP()) ;
	delete [] m_szFullNS;

    if (m_pHelper != NULL)  
    {   
        m_pHelper->Release();   
        m_pHelper = NULL;   
    }   

    if (m_pSymWriter != NULL)
    {
		m_pSymWriter->Close();
        m_pSymWriter->Release();
        m_pSymWriter = NULL;
    }
    if (m_pEmitter != NULL)
    {
        m_pEmitter->Release();
        m_pEmitter = NULL;
    }

    if (m_pDisp != NULL)    
    {   
        m_pDisp->Release(); 
        m_pDisp = NULL; 
    }   

    if (m_fDidCoInitialise)
        CoUninitialize();


}


BOOL Assembler::Init()
{
    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        return FALSE;
    m_fDidCoInitialise = TRUE;

    if (FAILED(CreateICeeFileGen(&m_pCeeFileGen))) return FALSE;
    if (FAILED(m_pCeeFileGen->CreateCeeFile(&m_pCeeFile))) return FALSE;

    if (FAILED(m_pCeeFileGen->GetSectionCreate(m_pCeeFile, ".il", sdReadOnly, &m_pILSection))) return FALSE;
	if (FAILED(m_pCeeFileGen->GetSectionCreate (m_pCeeFile, ".sdata", sdReadWrite, &m_pGlobalDataSection))) return FALSE;
	if (FAILED(m_pCeeFileGen->GetSectionCreate (m_pCeeFile, ".tls", sdReadWrite, &m_pTLSSection))) return FALSE;

    m_pOutputBuffer = new BYTE[OUTPUT_BUFFER_SIZE];
    if (m_pOutputBuffer == NULL)
        return FALSE;
    
    m_pCurOutputPos = m_pOutputBuffer;
    m_pEndOutputPos = m_pOutputBuffer + OUTPUT_BUFFER_SIZE;

	m_crImplList = new mdTypeRef[MAX_INTERFACES_IMPLEMENTED];
	if(m_crImplList == NULL) return FALSE;
	m_nImplListSize = MAX_INTERFACES_IMPLEMENTED;

	m_pManifest = new AsmMan((void*)this);

    return TRUE;
}

void Assembler::SetDLL(BOOL IsDll)
{ 
	HRESULT OK = m_pCeeFileGen->SetDllSwitch(m_pCeeFile, IsDll);
	m_fDLL = IsDll;
	_ASSERTE(SUCCEEDED(OK));
}

void Assembler::SetOBJ(BOOL IsObj)
{ 
	HRESULT OK = m_pCeeFileGen->SetObjSwitch(m_pCeeFile, IsObj);
	m_fOBJ = IsObj;
	_ASSERTE(SUCCEEDED(OK));
}


void Assembler::ResetForNextMethod()
{
    Fixup   *pFix;
    Label   *pLab;

	if(m_firstArgName) delArgNameList(m_firstArgName);
	m_firstArgName = NULL;

    m_CurPC         = 0;
    m_pCurOutputPos = m_pOutputBuffer;
    m_State         = STATE_OK;
	while(pFix = m_lstFixup.POP()) delete(pFix);
	while(pLab = m_lstLabel.POP()) delete(pLab);
    m_pCurMethod = NULL;
}

BOOL Assembler::AddMethod(Method *pMethod)
{
	BOOL                     fIsInterface;
	ULONG                    PEFileOffset;
	MemberRefDescriptor*			 pMRD;
	
	_ASSERTE(m_pCeeFileGen != NULL);
	if (pMethod == NULL)
	{ 
		printf("pMethod == NULL");
		return FALSE;
	}
	fIsInterface = ((pMethod->m_pClass != NULL) && IsTdInterface(pMethod->m_pClass->m_Attr));
	if(m_CurPC)
	{
		char sz[1024];
		sz[0] = 0;
		if(fIsInterface  && (!IsMdStatic(pMethod->m_Attr))) strcat(sz," when non-static declared in interface");
		if(IsMdAbstract(pMethod->m_Attr)) strcat(sz," being abstract");
		if(IsMdPinvokeImpl(pMethod->m_Attr)&&(!IsMdUnmanagedExport(pMethod->m_Attr))) 
			strcat(sz," being pinvoke and not unmanagedexp");
		if(!IsMiIL(pMethod->m_wImplAttr)) strcat(sz," being non-IL");
		if(strlen(sz))
		{
			report->error("Method can't have body%s\n",sz);
		}
	}


	COR_ILMETHOD_FAT fatHeader;
	fatHeader.Flags              = pMethod->m_Flags;
	fatHeader.MaxStack           = (USHORT) pMethod->m_MaxStack;
	fatHeader.LocalVarSigTok     = pMethod->m_LocalsSig;
	fatHeader.CodeSize           = m_CurPC;
	bool moreSections            = (pMethod->m_dwNumExceptions != 0);
	
	// if max stack is specified <8, force fat header, otherwise (with tiny header) it will default to 8
	if((fatHeader.MaxStack < 8)&&(fatHeader.LocalVarSigTok==0)&&(fatHeader.CodeSize<64)&&(!moreSections))
		fatHeader.Flags |= CorILMethod_InitLocals; //forces fat header but does nothing else, since LocalVarSigTok==0

	unsigned codeSizeAligned     = fatHeader.CodeSize;
	if (moreSections)
		codeSizeAligned          = (codeSizeAligned + 3) & ~3;    // to insure EH section aligned 

	unsigned headerSize = COR_ILMETHOD::Size(&fatHeader, moreSections);
	unsigned ehSize     = COR_ILMETHOD_SECT_EH::Size(pMethod->m_dwNumExceptions, pMethod->m_ExceptionList);
	unsigned totalSize  = + headerSize + codeSizeAligned + ehSize;
	unsigned align      = 4;  
	if (headerSize == 1)      // Tiny headers don't need any alignement   
		align = 1;    

	BYTE* outBuff;
	if (FAILED(m_pCeeFileGen->GetSectionBlock (m_pILSection, totalSize, align, (void **) &outBuff)))
		return FALSE;
	BYTE* endbuf = &outBuff[totalSize];

    // The the offset where we start, (not where the alignment bytes start!   
	if (FAILED(m_pCeeFileGen->GetSectionDataLen (m_pILSection, &PEFileOffset)))
		return FALSE;
	PEFileOffset -= totalSize;

    // Emit the header  
	outBuff += COR_ILMETHOD::Emit(headerSize, &fatHeader, moreSections, outBuff);

	pMethod->m_pCode = outBuff;
	pMethod->m_headerOffset= PEFileOffset;
	pMethod->m_methodOffset= PEFileOffset + headerSize;
	pMethod->m_CodeSize = m_CurPC;

    // Emit the code    
	if (codeSizeAligned) 
	{
		memset(outBuff,0,codeSizeAligned);
		memcpy(outBuff, m_pOutputBuffer, fatHeader.CodeSize);
		outBuff += codeSizeAligned;  
	}
	DoDeferredILFixups(pMethod->m_methodOffset);

	// Validate the eh
	IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* pEx;
	DWORD	TryEnd,HandlerEnd, dwEx, dwEf;
	for(dwEx = 0, pEx = pMethod->m_ExceptionList; dwEx < pMethod->m_dwNumExceptions; dwEx++, pEx++)
	{
		if(pEx->TryOffset > m_CurPC) // i.e., pMethod->m_CodeSize
		{
			report->error("Invalid SEH clause #%d: Try block starts beyond code size\n",dwEx+1);
		}
		TryEnd = pEx->TryOffset+pEx->TryLength;
		if(TryEnd > m_CurPC) 
		{
			report->error("Invalid SEH clause #%d: Tryb lock ends beyond code size\n",dwEx+1);
		}
		if(pEx->HandlerOffset > m_CurPC)
		{
			report->error("Invalid SEH clause #%d: Handler block starts beyond code size\n",dwEx+1);
		}
		HandlerEnd = pEx->HandlerOffset+pEx->HandlerLength;
		if(HandlerEnd > m_CurPC) 
		{
			report->error("Invalid SEH clause #%d: Handler block ends beyond code size\n",dwEx+1);
		}
		if(pEx->Flags & COR_ILEXCEPTION_CLAUSE_FILTER)
		{
			if(!((pEx->FilterOffset >= TryEnd)||(pEx->TryOffset >= HandlerEnd)))
			{
				report->error("Invalid SEH clause #%d: Try and Filter/Handler blocks overlap\n",dwEx+1);
			}
			for(dwEf = 0; dwEf < pMethod->m_dwNumEndfilters; dwEf++)
			{
				if(pMethod->m_EndfilterOffsetList[dwEf] == pEx->HandlerOffset) break;
			}
			if(dwEf >= pMethod->m_dwNumEndfilters)
			{
				report->error("Invalid SEH clause #%d: Filter block separated from Handler, or not ending with endfilter\n",dwEx+1);
			}
		}
		else
		if(!((pEx->HandlerOffset >= TryEnd)||(pEx->TryOffset >= HandlerEnd)))
		{
			report->error("Invalid SEH clause #%d: Try and Handler blocks overlap\n",dwEx+1);
		}

	}
    // Emit the eh  
	outBuff += COR_ILMETHOD_SECT_EH::Emit(ehSize, pMethod->m_dwNumExceptions, 
                                pMethod->m_ExceptionList, false, outBuff);  

	_ASSERTE(outBuff == endbuf);
	while(pMRD = pMethod->m_MemberRefDList.POP())
	{
		pMRD->m_ulOffset += (ULONG)(pMethod->m_pCode);
		m_MemberRefDList.PUSH(pMRD); // transfer MRD to assembler's list
	}
	if(m_fReportProgress)
	{
		if (pMethod->IsGlobalMethod())
			report->msg("Assembled global method %s\n", pMethod->m_szName);
		else report->msg("Assembled method %s::%s\n", pMethod->m_pClass->m_szName,
				  pMethod->m_szName);
	}
	return TRUE;
}

void Assembler::DoDeferredILFixups(ULONG OffsetInSection)
{ // Now that we know where in the file the code bytes will wind up,
  // we can update the RVAs and offsets.
	ILFixup *pSearch;
	while (pSearch = m_lstILFixup.POP())
    { 
		if (pSearch->m_Kind == ilGlobal)
        { 
            GlobalFixup *Fix = pSearch->m_Fixup;
			_ASSERTE(Fix != NULL);
			_ASSERTE(m_pCurMethod != NULL);
            Fix->m_pReference = m_pCurMethod->m_pCode+pSearch->m_OffsetInMethod;
		}
		else
        { 
			HRESULT hr = m_pCeeFileGen->AddSectionReloc(m_pILSection, 
			pSearch->m_OffsetInMethod+OffsetInSection,
			m_pGlobalDataSection, 
			(pSearch->m_Kind==ilRVA) ? srRelocAbsolute : srRelocHighLow);
			_ASSERTE(SUCCEEDED(hr));
		}
		delete(pSearch);
	}
}

ImportDescriptor* Assembler::EmitImport(BinStr* DllName)
{
	WCHAR               wzDllName[MAX_MEMBER_NAME_LENGTH];
	int i = 0, l = 0;
	ImportDescriptor*	pID;	

	if(DllName) l = DllName->length();
	if(l)
	{
		while(pID=m_ImportList.PEEK(i++))
		{
			if(!memcmp(pID->szDllName,DllName->ptr(),l)) return pID;
		}
	}
	else
	{
		while(pID=m_ImportList.PEEK(i++))
		{
			if(strlen(pID->szDllName)==0) return pID;
		}
	}
	if(pID = new ImportDescriptor)
	{
		if(pID->szDllName = new char[l+1])
		{
			memcpy(pID->szDllName,DllName->ptr(),l);
			pID->szDllName[l] = 0;
				
			WszMultiByteToWideChar(g_uCodePage,0,pID->szDllName,-1,wzDllName,MAX_MEMBER_NAME_LENGTH);
			if(SUCCEEDED(m_pEmitter->DefineModuleRef(             // S_OK or error.   
								wzDllName,            // [IN] DLL name    
								&(pID->mrDll))))      // [OUT] returned   
			{
				m_ImportList.PUSH(pID);
				return pID;
			}
			else report->error("Failed to define module ref '%s'\n",pID->szDllName);
		}
		else report->error("Failed to allocate name for module ref\n");
	}
	else report->error("Failed to allocate import descriptor\n");
	return NULL;
}

HRESULT Assembler::EmitPinvokeMap(mdToken tk, PInvokeDescriptor* pDescr)	
{
	WCHAR               wzAlias[MAX_MEMBER_NAME_LENGTH];
	
	memset(wzAlias,0,sizeof(WCHAR)*MAX_MEMBER_NAME_LENGTH);
	if(pDescr->szAlias)	WszMultiByteToWideChar(g_uCodePage,0,pDescr->szAlias,-1,wzAlias,MAX_MEMBER_NAME_LENGTH);

	return m_pEmitter->DefinePinvokeMap(		// Return code.
						tk,						// [IN] FieldDef, MethodDef or MethodImpl.
						pDescr->dwAttrs,		// [IN] Flags used for mapping.
						(LPCWSTR)wzAlias,		// [IN] Import name.
						pDescr->mrDll);			// [IN] ModuleRef token for the target DLL.
}

void Assembler::EmitScope(Scope* pSCroot)
{
	static ULONG32      	scopeID;
	static ARG_NAME_LIST	*pVarList;
	int						i;
	static WCHAR            wzVarName[1024];
	static char 			szPhonyName[1024];
	Scope*					pSC = pSCroot;
	if(pSC && m_pSymWriter)
	{
		if(SUCCEEDED(m_pSymWriter->OpenScope(pSC->dwStart,&scopeID)))
		{
			if(pSC->pLocals)
			{
				for(pVarList = pSC->pLocals; pVarList; pVarList = pVarList->pNext)
				{
					if(pVarList->pSig)
					{
						if(strlen(pVarList->szName)) strcpy(szPhonyName,pVarList->szName);
						else sprintf(szPhonyName,"V_%d",pVarList->dwAttr);

						WszMultiByteToWideChar(g_uCodePage,0,szPhonyName,-1,wzVarName,1024);

						m_pSymWriter->DefineLocalVariable(wzVarName,0,pVarList->pSig->length(),
							(BYTE*)pVarList->pSig->ptr(),ADDR_IL_OFFSET,pVarList->dwAttr,0,0,0,0);
					}
					else
					{
						report->error("Local Var '%s' has no signature\n",pVarList->szName);
					}
				}
			}
			for(i = 0; pSC = pSCroot->SubScope.PEEK(i); i++) EmitScope(pSC);
			m_pSymWriter->CloseScope(pSCroot->dwEnd);
		}
	}
}

BOOL Assembler::EmitMethod(Method *pMethod)
{ 
// Emit the metadata for a method definition
	BOOL                fSuccess = FALSE;
	WCHAR               wzMemberName[MAX_MEMBER_NAME_LENGTH];
	BOOL                fIsInterface;
	DWORD               cSig;
	ULONG               methodRVA = 0;
	mdMethodDef         MethodToken;
	mdTypeDef           ClassToken = mdTypeDefNil;
	char                *pszClassName;
	char                *pszMethodName;
	COR_SIGNATURE       *mySig;
	char*				pColons = NULL;

    _ASSERTE((m_pCeeFileGen != NULL) && (pMethod != NULL));
	fIsInterface = ((pMethod->m_pClass != NULL) && IsTdInterface(pMethod->m_pClass->m_Attr));
	pszClassName = pMethod->m_szClassName;
	pszMethodName = pMethod->m_szName;
	mySig = pMethod->m_pMethodSig;
	cSig = pMethod->m_dwMethodCSig;

	// If  this is an instance method, make certain the signature says so

	if (!(pMethod->m_Attr & mdStatic))
		*mySig |= IMAGE_CEE_CS_CALLCONV_HASTHIS;
  
	if (!((fIsInterface && (!(pMethod->m_Attr & mdStatic))) || IsMiInternalCall(pMethod->m_wImplAttr) || IsMiRuntime(pMethod->m_wImplAttr) 
		|| IsMdPinvokeImpl(pMethod->m_Attr) || IsMdAbstract(pMethod->m_Attr)))
	{ 
		HRESULT hr = m_pCeeFileGen->GetMethodRVA(m_pCeeFile, pMethod->m_headerOffset,
												&methodRVA);
		_ASSERTE(SUCCEEDED(hr));
	}

	ClassToken = (pMethod->IsGlobalMethod())? mdTokenNil 
									: pMethod->m_pClass->m_cl;
	// Convert name to UNICODE
	memset(wzMemberName,0,sizeof(wzMemberName));
	WszMultiByteToWideChar(g_uCodePage,0,pszMethodName,-1,wzMemberName,MAX_MEMBER_NAME_LENGTH);
	if(IsMdPrivateScope(pMethod->m_Attr))
	{
		WCHAR* p = wcsstr(wzMemberName,L"$PST06");
		if(p) *p = 0;
	}

	if (FAILED(m_pEmitter->DefineMethod(ClassToken,       // parent class
									  wzMemberName,     // member name
									  pMethod->m_Attr & ~mdReservedMask,  // member attributes
									  mySig, // member signature
									  cSig,
									  methodRVA,                // RVA
									  pMethod->m_wImplAttr,                // implflags
									  &MethodToken))) 
	{
		report->error("Failed to define method '%s'\n",pszMethodName);
		goto exit;
	}
	//--------------------------------------------------------------------------------
	// the only way to set mdRequireSecObject:
	if(pMethod->m_Attr & mdRequireSecObject)
	{
		mdToken tkPseudoClass;
		if(FAILED(m_pEmitter->DefineTypeRefByName(1, COR_REQUIRES_SECOBJ_ATTRIBUTE, &tkPseudoClass)))
			report->error("Unable to define type reference '%s'\n", COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI);
		else
		{
			mdToken tkPseudoCtor;
			BYTE bSig[3] = {IMAGE_CEE_CS_CALLCONV_HASTHIS,0,ELEMENT_TYPE_VOID};
			if(FAILED(m_pEmitter->DefineMemberRef(tkPseudoClass, L".ctor", (PCCOR_SIGNATURE)bSig, 3, &tkPseudoCtor)))
				report->error("Unable to define member reference '%s::.ctor'\n", COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI);
			else DefineCV(MethodToken,tkPseudoCtor,NULL);
		}
	}
	//--------------------------------------------------------------------------------
    EmitSecurityInfo(MethodToken,
                     pMethod->m_pPermissions,
                     pMethod->m_pPermissionSets);
	//--------------------------------------------------------------------------------
	if(m_fOBJ)
	{
		TokenRelocDescr *pTRD;
		//if(pMethod->m_fEntryPoint)
		{
			char* psz;
			if(pMethod->IsGlobalMethod())
			{
				if(psz = new char[strlen(pMethod->m_szName)+1])
					strcpy(psz,pMethod->m_szName);
			}
			else
			{
				if(psz = new char[strlen(pMethod->m_szName)+strlen(pMethod->m_szClassName)+3])
						sprintf(psz,"%s::%s",pMethod->m_szClassName,pMethod->m_szName);
			}
			m_pCeeFileGen->AddSectionReloc(m_pILSection,(DWORD)psz,m_pILSection,(CeeSectionRelocType)0x7FFA);
		}
		m_pCeeFileGen->AddSectionReloc(m_pILSection,MethodToken,m_pILSection,(CeeSectionRelocType)0x7FFF);
		m_pCeeFileGen->AddSectionReloc(m_pILSection,pMethod->m_headerOffset,m_pILSection,(CeeSectionRelocType)0x7FFD);
		while(pTRD = pMethod->m_TRDList.POP())
		{
			m_pCeeFileGen->AddSectionReloc(m_pILSection,pTRD->token,m_pILSection,(CeeSectionRelocType)0x7FFE);
			m_pCeeFileGen->AddSectionReloc(m_pILSection,pTRD->offset+pMethod->m_methodOffset,m_pILSection,(CeeSectionRelocType)0x7FFD);
			delete pTRD;
		}
	}
	if (pMethod->m_fEntryPoint)
	{ 
		if(fIsInterface) report->error("Entrypoint in Interface: Method '%s'\n",pszMethodName); 

		if (FAILED(m_pCeeFileGen->SetEntryPoint(m_pCeeFile, MethodToken)))
		{
			report->error("Failed to set entry point for method '%s'\n",pszMethodName);
			goto exit;
		}

		if (FAILED(m_pCeeFileGen->SetComImageFlags(m_pCeeFile, 0)))
		{
			report->error("Failed to set COM image flags for method '%s'\n",pszMethodName);
			goto exit;
		}

	}
	//--------------------------------------------------------------------------------
	if(IsMdPinvokeImpl(pMethod->m_Attr))
	{
		if(pMethod->m_pPInvoke)
		{
			HRESULT hr;
			if(pMethod->m_pPInvoke->szAlias == NULL) pMethod->m_pPInvoke->szAlias = pszMethodName;
			hr = EmitPinvokeMap(MethodToken,pMethod->m_pPInvoke);
			if(pMethod->m_pPInvoke->szAlias == pszMethodName) pMethod->m_pPInvoke->szAlias = NULL;

			if(FAILED(hr))
			{
				report->error("Failed to set PInvoke map for method '%s'\n",pszMethodName);
				goto exit;
			}
		}
	}

	//--------------------------------------------------------------------------------
	if(m_fIncludeDebugInfo)
	{
		if(strcmp(g_szSourceFileName,pMethod->m_szSourceFileName))
		{
			WCHAR               wzInputFilename[MAX_FILENAME_LENGTH];
			WszMultiByteToWideChar(g_uCodePage,0,pMethod->m_szSourceFileName,-1,wzInputFilename,MAX_FILENAME_LENGTH);
			if(FAILED(m_pSymWriter->DefineDocument(wzInputFilename,&(pMethod->m_guidLang),
				&(pMethod->m_guidLangVendor),&(pMethod->m_guidDoc),&m_pSymDocument))) m_pSymDocument = NULL;
			strcpy(g_szSourceFileName,pMethod->m_szSourceFileName);
		}
		if(m_pSymDocument)
		{
			m_pSymWriter->OpenMethod(MethodToken);
			ULONG N = pMethod->m_LinePCList.COUNT();
			if(N)
			{
				LinePC	*pLPC;
				ULONG32  *offsets=new ULONG32[N], *lines = new ULONG32[N], *columns = new ULONG32[N];
				if(offsets && lines && columns)
				{
					for(int i=0; pLPC = pMethod->m_LinePCList.POP(); i++)
					{
						offsets[i] = pLPC->PC;
						lines[i] = pLPC->Line;
						columns[i] = pLPC->Column;
						delete pLPC;
					}
					if(pMethod->m_fEntryPoint) m_pSymWriter->SetUserEntryPoint(MethodToken);

					m_pSymWriter->DefineSequencePoints(m_pSymDocument,N,offsets,lines,columns,NULL,NULL);
				}
				else report->error("\nOutOfMemory!\n");
				delete [] offsets;
				delete [] lines;
				delete [] columns;
			}//enf if(N)
			HRESULT hrr;
			if(pMethod->m_ulLines[1])
				hrr = m_pSymWriter->SetMethodSourceRange(m_pSymDocument,pMethod->m_ulLines[0], pMethod->m_ulColumns[0],
												   m_pSymDocument,pMethod->m_ulLines[1], pMethod->m_ulColumns[1]);
			EmitScope(&(pMethod->m_MainScope)); // recursively emits all nested scopes

			m_pSymWriter->CloseMethod();
		}
	} // end if(fIncludeDebugInfo)
	{ // add parameters to metadata
		void const *pValue=NULL;
		ULONG		cbValue;
		DWORD dwCPlusTypeFlag=0;
		mdParamDef pdef;
		WCHAR wzParName[1024];
		char szPhonyName[1024];
		if(pMethod->m_dwRetAttr || pMethod->m_pRetMarshal || pMethod->m_RetCustDList.COUNT())
		{
			if(pMethod->m_pRetValue)
			{
				dwCPlusTypeFlag= (DWORD)*(pMethod->m_pRetValue->ptr());
				pValue = (void const *)(pMethod->m_pRetValue->ptr()+1);
				cbValue = pMethod->m_pRetValue->length()-1;
				if(dwCPlusTypeFlag == ELEMENT_TYPE_STRING) cbValue /= sizeof(WCHAR);
			}
			else
			{
				pValue = NULL;
				cbValue = -1;
				dwCPlusTypeFlag=0;
			}
			m_pEmitter->DefineParam(MethodToken,0,NULL,pMethod->m_dwRetAttr,dwCPlusTypeFlag,pValue,cbValue,&pdef);

			if(pMethod->m_pRetMarshal)
			{
				if(FAILED(m_pEmitter->SetFieldMarshal (    
											pdef,						// [IN] given a fieldDef or paramDef token  
							(PCCOR_SIGNATURE)(pMethod->m_pRetMarshal->ptr()),   // [IN] native type specification   
											pMethod->m_pRetMarshal->length())))  // [IN] count of bytes of pvNativeType
					report->error("Failed to set param marshaling for return\n");

			}
			EmitCustomAttributes(pdef, &(pMethod->m_RetCustDList));
		}
		for(ARG_NAME_LIST *pAN=pMethod->m_firstArgName; pAN; pAN = pAN->pNext)
		{
			if(pAN->nNum >= 65535) 
			{
				report->error("Method '%s': Param.sequence number (%d) exceeds 65535, unable to define parameter\n",pszMethodName,pAN->nNum+1);
				continue;
			}
			if(strlen(pAN->szName)) strcpy(szPhonyName,pAN->szName);
			else sprintf(szPhonyName,"A_%d",pAN->nNum);

			WszMultiByteToWideChar(g_uCodePage,0,szPhonyName,-1,wzParName,1024);

			if(pAN->pValue)
			{
				dwCPlusTypeFlag= (DWORD)*(pAN->pValue->ptr());
				pValue = (void const *)(pAN->pValue->ptr()+1);
				cbValue = pAN->pValue->length()-1;
				if(dwCPlusTypeFlag == ELEMENT_TYPE_STRING) cbValue /= sizeof(WCHAR);
			}
			else
			{
				pValue = NULL;
				cbValue = -1;
				dwCPlusTypeFlag=0;
			}
			m_pEmitter->DefineParam(MethodToken,pAN->nNum+1,wzParName,pAN->dwAttr,dwCPlusTypeFlag,pValue,cbValue,&pdef);
			if(pAN->pMarshal)
			{
				if(FAILED(m_pEmitter->SetFieldMarshal (    
											pdef,						// [IN] given a fieldDef or paramDef token  
							(PCCOR_SIGNATURE)(pAN->pMarshal->ptr()),   // [IN] native type specification   
											pAN->pMarshal->length())))  // [IN] count of bytes of pvNativeType
					report->error("Failed to set param marshaling for '%s'\n",pAN->szName);
			}
			EmitCustomAttributes(pdef, &(pAN->CustDList));
		}
	}
	fSuccess = TRUE;
	//--------------------------------------------------------------------------------
	// Update method implementations for this method
	{
		MethodImplDescriptor*	pMID;
		while(pMID = pMethod->m_MethodImplDList.POP())
		{
			pMID->m_tkImplementingMethod = MethodToken;
			// don't delete it here, it's still in the general list
		}
	}
	//--------------------------------------------------------------------------------
	{
		Class* pClass = (pMethod->m_pClass ? pMethod->m_pClass : m_pModuleClass);
		MethodDescriptor* pMD = new MethodDescriptor;
		if(pMD)
		{
			pMD->m_tdClass = ClassToken;
			if(pMD->m_szName = new char[strlen(pszMethodName)+1]) strcpy(pMD->m_szName,pszMethodName);
			if(pszClassName)
			{
				if(pMD->m_szClassName = new char[strlen(pszClassName)+1]) strcpy(pMD->m_szClassName,pszClassName);
			}
			else pMD->m_szClassName = NULL;
			if(pMD->m_pSig = new COR_SIGNATURE[cSig]) memcpy(pMD->m_pSig,mySig,cSig);
			else cSig = 0;
			pMD->m_dwCSig = cSig;
			pMD->m_mdMethodTok = MethodToken;
			pMD->m_wVTEntry = pMethod->m_wVTEntry;
			pMD->m_wVTSlot = pMethod->m_wVTSlot;
			if((pMD->m_dwExportOrdinal = pMethod->m_dwExportOrdinal) != 0xFFFFFFFF)
			{
				if(pMethod->m_szExportAlias)
				{
					if(pMD->m_szExportAlias = new char[strlen(pMethod->m_szExportAlias)+1])
											strcpy(pMD->m_szExportAlias,pMethod->m_szExportAlias);
				}
                else  pMD->m_szExportAlias = NULL;
			}
			pClass->m_MethodDList.PUSH(pMD);
		}
		else report->error("Failed to allocate MethodDescriptor\n");
	}
	//--------------------------------------------------------------------------------
	EmitCustomAttributes(MethodToken, &(pMethod->m_CustomDescrList));
exit:
	if (fSuccess == FALSE) m_State = STATE_FAIL;
	return fSuccess;
}

BOOL Assembler::EmitMethodImpls()
{
	MethodImplDescriptor*	pMID;
	mdToken	tkImplementingMethod, tkImplementedMethod, tkImplementedClass;
	BOOL ret = TRUE;
	Class*	pClass;

	while(pMID = m_MethodImplDList.POP())
	{
		if(pMID->m_pbsSig)
		{
			if((tkImplementingMethod = pMID->m_tkImplementingMethod) == 0)
			{
				BinStr* pbs = new BinStr();
				pbs->append(pMID->m_pbsSig);
				tkImplementingMethod = MakeMemberRef(pMID->m_pbsImplementingTypeSpec,
													 pMID->m_szImplementingName,
													 pMID->m_pbsSig, 0);
				pMID->m_pbsSig = pbs;
			}
			ResolveTypeSpec(pMID->m_pbsImplementedTypeSpec,&tkImplementedClass,&pClass);
			tkImplementedMethod = 0;
			if((TypeFromToken(tkImplementedClass)==mdtTypeDef)&&pClass)
			{
				MethodDescriptor* pMD;

				for(int j=0; pMD = pClass->m_MethodDList.PEEK(j); j++)
				{
					if(pMD->m_dwCSig != pMID->m_pbsSig->length()) continue;
					if(memcmp(pMD->m_pSig,pMID->m_pbsSig->ptr(),pMD->m_dwCSig)) continue;
					if(strcmp(pMD->m_szName,pMID->m_szImplementedName)) continue;
					tkImplementedMethod = pMD->m_mdMethodTok;
					break;
				}
			}
			if(tkImplementedMethod == 0)
				tkImplementedMethod = MakeMemberRef(pMID->m_pbsImplementedTypeSpec,
													pMID->m_szImplementedName,
													pMID->m_pbsSig, 0);


			if(FAILED(m_pEmitter->DefineMethodImpl( pMID->m_tkDefiningClass,
													tkImplementingMethod,
													tkImplementedMethod)))
			{
				report->error("Failed to define Method Implementation");
				ret = FALSE;
			}
			//delete pMID;


		}
		else
		{
			report->error("Invalid Method Impl descriptor: no signature");
			ret = FALSE;
		}
	}// end while
	return ret;
}


BOOL Assembler::EmitEvent(EventDescriptor* pED)
{
	mdMethodDef mdAddOn=mdMethodDefNil,
				mdRemoveOn=mdMethodDefNil,
				mdFire=mdMethodDefNil,
				*mdOthers;
	int					nOthers;
	WCHAR               wzMemberName[MAX_MEMBER_NAME_LENGTH];

	if(!pED) return FALSE;
	nOthers = pED->m_mdlOthers.COUNT();

	WszMultiByteToWideChar(g_uCodePage,0,pED->m_szName,-1,wzMemberName,MAX_MEMBER_NAME_LENGTH);

	mdOthers = new mdMethodDef[nOthers+1];
	if(mdOthers == NULL)
	{
		report->error("Failed to allocate Others array for event descriptor\n");
		nOthers = 0;
	}
	mdAddOn		= GetMethodTokenByDescr(pED->m_pmdAddOn);
	mdRemoveOn	= GetMethodTokenByDescr(pED->m_pmdRemoveOn);
	mdFire		= GetMethodTokenByDescr(pED->m_pmdFire);
	for(int j=0; j < nOthers; j++)
	{
		mdOthers[j] = GetMethodTokenByDescr(pED->m_mdlOthers.PEEK(j));
	}
	mdOthers[nOthers] = mdMethodDefNil; // like null-terminator
	if(FAILED(m_pEmitter->DefineEvent(	pED->m_tdClass,
										wzMemberName,
										pED->m_dwAttr,
										pED->m_tkEventType,
										mdAddOn,
										mdRemoveOn,
										mdFire,
										mdOthers,
										&(pED->m_edEventTok))))
	{
		report->error("Failed to define event '%s'.\n",pED->m_szName);
		delete mdOthers;
		return FALSE;
	}
	EmitCustomAttributes(pED->m_edEventTok, &(pED->m_CustomDescrList));
	return TRUE;
}

mdMethodDef Assembler::GetMethodTokenByDescr(MethodDescriptor* pMD)
{
	if(pMD)
	{
		MethodDescriptor* pListMD;
        Class *pSearch;
		int i,j;
        for (i = 0; pSearch = m_lstClass.PEEK(i); i++)
		{
			if(pSearch->m_cl != pMD->m_tdClass) continue;
			for(j=0; pListMD = pSearch->m_MethodDList.PEEK(j); j++)
			{
				if(pListMD->m_dwCSig  != pMD->m_dwCSig)  continue;
				if(strcmp(pListMD->m_szName,pMD->m_szName)) continue;
				if(memcmp(pListMD->m_pSig,pMD->m_pSig,pMD->m_dwCSig)) continue;
				return (pMD->m_mdMethodTok = pListMD->m_mdMethodTok);
			}
		}
		report->error("Failed to get token of method '%s'\n",pMD->m_szName);
		pMD->m_mdMethodTok = mdMethodDefNil;
	}
	return mdMethodDefNil;
}

mdEvent Assembler::GetEventTokenByDescr(EventDescriptor* pED)
{
	if(pED)
	{
		EventDescriptor* pListED;
        Class *pSearch;
		int i,j;
        for (i = 0; pSearch = m_lstClass.PEEK(i); i++)
		{
			if(pSearch->m_cl != pED->m_tdClass) continue;
			for(j=0; pListED = pSearch->m_EventDList.PEEK(j); j++)
			{
				if(strcmp(pListED->m_szName,pED->m_szName)) continue;
				return (pED->m_edEventTok = pListED->m_edEventTok);
			}
		}
		report->error("Failed to get token of event '%s'\n",pED->m_szName);
		pED->m_edEventTok = mdEventNil;
	}
	return mdEventNil;
}

mdFieldDef Assembler::GetFieldTokenByDescr(FieldDescriptor* pFD)
{
	if(pFD)
	{
		FieldDescriptor* pListFD;
        Class *pSearch;
		int i,j;
        for (i = 0; pSearch = m_lstClass.PEEK(i); i++)
		{
			if(pSearch->m_cl != pFD->m_tdClass) continue;
			for(j=0; pListFD = pSearch->m_FieldDList.PEEK(j); j++)
			{
				if(pListFD->m_tdClass != pFD->m_tdClass) continue;
				if(strcmp(pListFD->m_szName,pFD->m_szName)) continue;
				return (pFD->m_fdFieldTok = pListFD->m_fdFieldTok);
			}
		}
		report->error("Failed to get token of field '%s'\n",pFD->m_szName);
		pFD->m_fdFieldTok = mdFieldDefNil;
	}
	return mdFieldDefNil;
}


BOOL Assembler::EmitProp(PropDescriptor* pPD)
{
	mdMethodDef mdSet, mdGet, *mdOthers;
	int nOthers;
	WCHAR               wzMemberName[MAX_MEMBER_NAME_LENGTH];

	if(!pPD) return FALSE;
	nOthers = pPD->m_mdlOthers.COUNT();

	WszMultiByteToWideChar(g_uCodePage,0,pPD->m_szName,-1,wzMemberName,MAX_MEMBER_NAME_LENGTH);
	
	mdOthers = new mdMethodDef[nOthers+1];
	if(mdOthers == NULL)
	{
		report->error("Failed to allocate Others array for prop descriptor\n");
		nOthers = 0;
	}
	mdSet		= GetMethodTokenByDescr(pPD->m_pmdSet);
	mdGet		= GetMethodTokenByDescr(pPD->m_pmdGet);
	for(int j=0; j < nOthers; j++)
	{
		mdOthers[j] = GetMethodTokenByDescr(pPD->m_mdlOthers.PEEK(j));
	}
	mdOthers[nOthers] = mdMethodDefNil; // like null-terminator
	
	if(FAILED(m_pEmitter->DefineProperty(	pPD->m_tdClass,
											wzMemberName,
											pPD->m_dwAttr,
											pPD->m_pSig,
											pPD->m_dwCSig,
											pPD->m_dwCPlusTypeFlag,
											pPD->m_pValue,
											pPD->m_cbValue,
											mdSet,
											mdGet,
											mdOthers,
											&(pPD->m_pdPropTok))))
	{
		report->error("Failed to define property '%s'.\n",pPD->m_szName);
		delete mdOthers;
		return FALSE;
	}
	EmitCustomAttributes(pPD->m_pdPropTok, &(pPD->m_CustomDescrList));
	return TRUE;
}

Class *Assembler::FindClass(char *pszFQN)
{
    Class *pSearch = NULL;

	if(pszFQN)
	{
		char* pszScope = NULL;
		char* pszName = pszFQN;
		char* pch;
		unsigned Lscope;
		// check if Res.Scope is "this module"
		if(pch = strchr(pszFQN,'~'))
		{
			Lscope = pch-pszFQN;
			if(pszScope = new char[Lscope+1])
			{
				strncpy(pszScope,pszFQN,Lscope);
				pszScope[Lscope] = 0;
				if(strcmp(m_szScopeName,pszScope))
				{
					delete [] pszScope;
					return NULL;
				}
				delete [] pszScope;
				pszName  = pch+1;
			}
			else report->error("\nOut of memory!\n");
		}


        for (int i = 0; pSearch = m_lstClass.PEEK(i); i++)
		{
			if (!strcmp(pSearch->m_szFQN, pszName)) break;
		}
	}
    return pSearch;
}


BOOL Assembler::AddClass(Class *pClass, Class *pEnclosingClass)
{
    LPUTF8              szFullName;
    WCHAR               wzFullName[MAX_CLASSNAME_LENGTH];
    HRESULT             hr = E_FAIL;
    GUID                guid;

    hr = CoCreateGuid(&guid);
    if (FAILED(hr))
    {
        printf("Unable to create GUID\n");
        m_State = STATE_FAIL;
        return FALSE;
    }

//MAKE_FULL_PATH_ON_STACK_UTF8(szFullName, pEnclosingClass ? "" : m_szFullNS, pClass->m_szName);
	unsigned l = (unsigned)strlen(m_szFullNS);
	if(pEnclosingClass || (l==0))
		WszMultiByteToWideChar(g_uCodePage,0,pClass->m_szName,-1,wzFullName,MAX_CLASSNAME_LENGTH);
	else
	{
		if(szFullName = new char[strlen(pClass->m_szName)+l+2])
		{
			sprintf(szFullName,"%s.%s",m_szFullNS,pClass->m_szName);
			WszMultiByteToWideChar(g_uCodePage,0,szFullName,-1,wzFullName,MAX_CLASSNAME_LENGTH);
			delete [] szFullName;
		}
		else 
		{
			report->error("\nOut of memory!\n");
			delete pClass;
			return FALSE;
		}
	}

    if (pEnclosingClass)
    {
        hr = m_pEmitter->DefineNestedType( wzFullName,
									    pClass->m_Attr,      // attributes
									    pClass->m_crExtends,  // CR extends class
									    pClass->m_crImplements,// implements
                                        pEnclosingClass->m_cl,  // Enclosing class.
									    &pClass->m_cl);
    }
    else
    {
        hr = m_pEmitter->DefineTypeDef( wzFullName,
									    pClass->m_Attr,      // attributes
									    pClass->m_crExtends,  // CR extends class
									    pClass->m_crImplements,// implements
									    &pClass->m_cl);
    }

    if (FAILED(hr)) goto exit;

	m_lstClass.PUSH(pClass);
    hr = S_OK;

exit:
    return SUCCEEDED(hr);
}

#define PADDING 34

BOOL Assembler::GenerateListingFile(Method *pMethod)
{
    DWORD   PC = 0;
    BYTE *  pCode =  pMethod->m_pCode;
    BOOL    fNeedNewLine = FALSE;

    printf("PC (hex)  Opcodes and data (hex)           Label           Instruction\n");
    printf("-------- -------------------------------- --------------- ----------------\n");

    while (PC < pMethod->m_CodeSize)
    {
        DWORD   Len;
        DWORD   i;
        OPCODE  instr;
        Label * pLabel;
        char    szLabelStr[256];

        // does this PC have a label?
        pLabel = FindLabel(PC);
        
        if (pLabel != NULL)
        {
            sprintf(szLabelStr, "%-15s", pLabel->m_szName);
            fNeedNewLine = TRUE;
        }
        else
        {
            sprintf(szLabelStr, "%-15s", "");
        }

        instr = DecodeOpcode(&pCode[PC], &Len);

        if (instr == CEE_COUNT)
        {
            report->error("Instruction decoding error: invalid opcode\n");
            return FALSE;
        }

        if (fNeedNewLine)
        {
            fNeedNewLine = FALSE;
            printf("\n");
        }

        printf("%08x ", PC);

        for (i = 0; i < Len; i++)
            printf("%02x", pCode[PC+i]);

        PC += Len;
        printf("|");
        Len++;

        Len *= 2;

        char *pszInstrName = OpcodeInfo[instr].pszName;

        switch (OpcodeInfo[instr].Type)
        {
            default:
            {
                printf("Unknown instruction\n");
                return FALSE;
            }

            case InlineNone:
            {
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                printf("%-10s %s\n", szLabelStr, pszInstrName);
                break;
            }

            case ShortInlineVar:
            case ShortInlineI:
            {
                printf("%02x ", pCode[PC]);
                Len += 3;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                printf("%s %-10s %d\n", szLabelStr, pszInstrName, pCode[PC]);

                PC++;
                break;
            }

            case InlineVar:
            {
                printf("%02x%02x ", pCode[PC], pCode[PC+1]);
                Len += 5;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                USHORT v = pCode[PC] + (pCode[PC+1] << 8);

                printf("%s %-10s %d\n", szLabelStr, pszInstrName, v);
                PC += 2;
                break;
            }

            case InlineSig:
            case InlineI:
            case InlineString:
            {
                DWORD v = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);

                printf("%02x%02x%02x%02x ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                Len += 9;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }
                
                printf("%s %-10s %d\n", szLabelStr, pszInstrName, v);
                PC += 4;
                break;
            }

            case InlineI8:
            {
                __int64 v = (__int64) pCode[PC] + 
                            (((__int64) pCode[PC+1]) << 8) +
                            (((__int64) pCode[PC+2]) << 16) +
                            (((__int64) pCode[PC+3]) << 24) +
                            (((__int64) pCode[PC+4]) << 32) +
                            (((__int64) pCode[PC+5]) << 40) +
                            (((__int64) pCode[PC+6]) << 48) +
                            (((__int64) pCode[PC+7]) << 56);
                            
                printf("%02x%02x%02x%02x%02x%02x%02x%02x ", 
                    pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3],
                    pCode[PC+4], pCode[PC+5], pCode[PC+6], pCode[PC+7]);
                Len += (8*2+1);
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }
                
                printf("%s %-10s 0x%I64x\n", szLabelStr, pszInstrName, v);
                PC += 8;
                break;
            }

            case ShortInlineR:
            {
                union
                {
                    BYTE  b[4];
                    float f;
                } u;
                u.b[0] = pCode[PC];
                u.b[1] = pCode[PC+1];
                u.b[2] = pCode[PC+2];
                u.b[3] = pCode[PC+3];

                printf("%02x%02x%02x%02x ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                Len += 9;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }
                
                printf("%s %-10s %f\n", szLabelStr, pszInstrName, u.f);
                PC += 4;
                break;
            }

            case InlineR:
            {
                union
                {
                    BYTE    b[8];
                    double  d;
                } u;
                u.b[0] = pCode[PC];
                u.b[1] = pCode[PC+1];
                u.b[2] = pCode[PC+2];
                u.b[3] = pCode[PC+3];
                u.b[4] = pCode[PC+4];
                u.b[5] = pCode[PC+5];
                u.b[6] = pCode[PC+6];
                u.b[7] = pCode[PC+7];

                printf("%02x%02x%02x%02x%02x%02x%02x%02x ", 
                    pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3],
                    pCode[PC+4], pCode[PC+5], pCode[PC+6], pCode[PC+7]);
                Len += (8*2+1);
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }
                
                printf("%s %-10s %f\n", szLabelStr, pszInstrName, u.d);
                PC += 8;
                break;
            }

            case ShortInlineBrTarget:
            {
                char offset = (char) pCode[PC];
                long dest = (PC + 1) + (long) offset;
                Label *pLab = FindLabel(dest);

                printf("%02x ", pCode[PC]);
                Len += 3;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                if (pLab != NULL)
                    printf("%s %-10s %s\n", szLabelStr, pszInstrName, pLab->m_szName);
                else
                    printf("%s %-10s (abs) %d\n", szLabelStr, pszInstrName, dest);

                PC++;

                fNeedNewLine = TRUE;
                break;
            }

            case InlineBrTarget:
            {
                long offset = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                long dest = (PC + 4) + (long) offset;
                Label *pLab = FindLabel(dest);

                printf("%02x%02x%02x%02x ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                Len += 9;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                if (pLab != NULL)
                    printf("%s %-10s %s\n", szLabelStr, pszInstrName, pLab->m_szName);
                else
                    printf("%s %-10s (abs) %d\n", szLabelStr, pszInstrName, dest);

                PC += 4;

                fNeedNewLine = TRUE;
                break;
            }

            case InlineSwitch:
            {
                DWORD cases = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);

                printf("%02x%02x%02x%02x ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                Len += 9;
                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                PC += 4;
                DWORD PC_nextInstr = PC + 4 * cases;

                printf("%s %-10s (%d cases)\n", szLabelStr, pszInstrName, cases);

                for (i = 0; i < cases; i++)
                {
                    long offset = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                    long dest = PC_nextInstr + (long) offset;
                    Label *pLab = FindLabel(dest);

                    printf("%04d %02x%02x%02x%02x %-*s",
                        PC, pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3], PADDING+6, "");

                    PC += 4;

                    if (pLab != NULL)
                        printf("%s (abs %d)\n", pLab->m_szName, dest);
                    else
                        printf("(abs) %d\n", dest);
                }

                break;
            }

            case InlinePhi:
            {
                DWORD words = pCode[PC];
                PC += (words * 2);  
                printf("PHI NODE\n");   
                break;
            }

            case InlineMethod:
            case InlineField:
            case InlineType:
            {
                DWORD tk = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                DWORD tkType = TypeFromToken(tk);

                printf("%02x%02x%02x%02x ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);

                Len += 9;

                while (Len < PADDING)
                {
                    printf(" ");
                    Len++;
                }

                PC += 4;

                printf("%s %-10s\n", szLabelStr, pszInstrName);
                break;
            }

        }
    }

    printf("----------------------------------------------------------------------\n\n");
    return TRUE;
}

#undef PADDING

BOOL Assembler::DoGlobalFixups()
{
    GlobalFixup *pSearch;

    for (int i=0; pSearch = m_lstGlobalFixup.PEEK(i); i++)
    {
        GlobalLabel *   pLabel = FindGlobalLabel(pSearch->m_szLabel);
        if (pLabel == NULL)
        {
            report->error("Unable to find forward reference global label '%s'\n",
                pSearch->m_szLabel);

            m_State = STATE_FAIL;
            return FALSE;
        }
        BYTE * pReference = pSearch->m_pReference;
        DWORD  GlobalOffset = pLabel->m_GlobalOffset;
		memcpy(pReference,&GlobalOffset,4);
    }

    return TRUE;
}

state_t Assembler::AddGlobalLabel(char *pszName, HCEESECTION section)
{
    if (FindGlobalLabel(pszName) != NULL)
    {
        report->error("Duplicate global label '%s'\n", pszName);
        m_State = STATE_FAIL;
		return m_State;
    }

    ULONG GlobalOffset;
    HRESULT hr = m_pCeeFileGen->GetSectionDataLen(section, &GlobalOffset);
	_ASSERTE(SUCCEEDED(hr));

	GlobalLabel *pNew = new GlobalLabel(pszName, GlobalOffset, section);
	if (pNew == 0)
	{
		report->error("Failed to allocate global label '%s'\n",pszName);
		m_State = STATE_FAIL;
		return m_State;
	}

	m_lstGlobalLabel.PUSH(pNew);
    return m_State;
}

void Assembler::AddLabel(DWORD CurPC, char *pszName)
{
    if (FindLabel(pszName) != NULL)
    {
        report->error("Duplicate label: '%s'\n", pszName);

        m_State = STATE_FAIL;
    }
    else
    {
        Label *pNew = new Label(pszName, CurPC);

        if (pNew != NULL)
			m_lstLabel.PUSH(pNew);
        else
        {
            report->error("Failed to allocate label '%s'\n",pszName);
            m_State = STATE_FAIL;
        }
    }
}

OPCODE Assembler::DecodeOpcode(const BYTE *pCode, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch(opcode) {
        case CEE_PREFIX1:
            opcode = OPCODE(pCode[1] + 256);
            if (opcode < 0 || opcode >= CEE_COUNT)
                return CEE_COUNT;
            *pdwLen = 2;
            break;

        case CEE_PREFIXREF:
        case CEE_PREFIX2:
        case CEE_PREFIX3:
        case CEE_PREFIX4:
        case CEE_PREFIX5:
        case CEE_PREFIX6:
        case CEE_PREFIX7:
            return CEE_COUNT;
        }
    return opcode;
}

Label *Assembler::FindLabel(char *pszName)
{
    Label *pSearch;

    for (int i = 0; pSearch = m_lstLabel.PEEK(i); i++)
    {
        if (!strcmp(pszName, pSearch->m_szName))
            return pSearch;
    }

    return NULL;
}


Label *Assembler::FindLabel(DWORD PC)
{
    Label *pSearch;

    for (int i = 0; pSearch = m_lstLabel.PEEK(i); i++)
    {
        if (pSearch->m_PC == PC)
            return pSearch;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\makefile.inc ===
OBJECTS = $(OBJECTS) $O\asmParse.obj 

$O\asmParse.obj: asmParse.h $O\asmParse.c asmparse.grammar


$O\asmParse.c: asmparse.y asmparse.h ..\inc\openum.h 
	-del/f /q $O\asmparse.c 
    yacc_ms -o $O\asmparse -i asmparse.y

asmparse.grammar: asmparse.y
	perl extractGrammar.pl asmparse.y > asmparse.grammar

!if "$(LINKONLY)" == "1"

SetStack:
	editbin /STACK:4194304 $(TARGETCORBIN)\i386\$(DDKBUILDENV)\ilasm.exe
	editbin /STACK:4194304 $(TARGETCOMPLUSSDK)\bin\ilasm.exe

!else

SetStack:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\method.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// method.cpp
//
#include "assembler.h"

Method::Method(Assembler *pAssembler, Class *pClass, char *pszName, BinStr* pbsSig, DWORD Attr)
{

    // default values
    m_pClass        = pClass;
    m_MaxStack      = 8;
    m_Flags         = 0;
    m_LocalsSig     = 0;
    m_localTypes    = 0;
    m_numLocals     = 0;
    m_dwNumExceptions = 0;
	m_dwNumEndfilters = 0;
    m_dwExceptionFlags = 0;
	m_firstArgName = NULL;
	m_firstVarName = NULL;
	m_szClassName = NULL;
	m_pMethodSig = NULL;
	m_wImplAttr = miIL; //default, if native or optil are not specified
	m_wVTEntry = 0;
	m_wVTSlot = 0;
	m_pAssembler = pAssembler;
	m_pCurrScope = &m_MainScope;
	m_pRetMarshal = NULL;
	m_pRetValue = NULL;
	m_szExportAlias = NULL;
	m_dwExportOrdinal = 0xFFFFFFFF;
	m_ulLines[0]=m_ulLines[1]=0;
	m_ulColumns[0]=m_ulColumns[0]=0;

	memset(&m_guidLang,0,sizeof(GUID));
	memset(&m_guidLangVendor,0,sizeof(GUID));
	memset(&m_guidDoc,0,sizeof(GUID));

	// move the PInvoke descriptor (if any) from Assembler
	// (Assembler gets the descriptor BEFORE it calls new Method)
	m_pPInvoke = pAssembler->m_pPInvoke;
	pAssembler->m_pPInvoke = NULL;

    _ASSERTE(pszName);
    if (!pszName) return;

    m_szName = pszName;

	m_ExceptionList = new IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT[MAX_EXCEPTIONS];
	m_EndfilterOffsetList = new DWORD[MAX_EXCEPTIONS];
	if((m_ExceptionList==NULL)||(m_EndfilterOffsetList==NULL))
	{
		fprintf(stderr,"\nOutOfMemory!\n");
		return;
	}
	m_dwMaxNumExceptions = MAX_EXCEPTIONS;
	m_dwMaxNumEndfilters = MAX_EXCEPTIONS;

    m_Attr          = Attr;
	if((!strcmp(pszName,COR_CCTOR_METHOD_NAME))||(!strcmp(pszName,COR_CTOR_METHOD_NAME)))
		m_Attr |= mdSpecialName;
    m_fEntryPoint   = FALSE;
    m_fGlobalMethod = FALSE;

	if(pbsSig)
	{
		m_dwMethodCSig = pbsSig->length();
		m_pMethodSig = (COR_SIGNATURE*)(pbsSig->ptr());
		m_pbsMethodSig = pbsSig;
	}
	if(pClass)	m_szClassName = pClass->m_szName; 

	m_firstArgName = pAssembler->getArgNameList();

	if(pClass == NULL) pClass = pAssembler->m_pModuleClass; // fake "class" <Module>
    pClass->m_MethodList.PUSH(this);


    m_pPermissions = NULL;
    m_pPermissionSets = NULL;
	memset(m_szSourceFileName,0,sizeof(m_szSourceFileName));
}


// lexical scope handling 
void Method::OpenScope()
{
	Scope*	psc = new Scope;
	if(psc)
	{
		psc->dwStart = m_pAssembler->m_CurPC;
		psc->pSuperScope = m_pCurrScope;
#if(0)
		LinePC *pLPC = new LinePC;
		if(pLPC)
		{
			pLPC->Line = m_pAssembler->m_ulCurLine;
			pLPC->Column = m_pAssembler->m_ulCurColumn;
			pLPC->PC = m_pAssembler->m_CurPC;
			m_LinePCList.PUSH(pLPC);
		}
#endif
		m_pCurrScope->SubScope.PUSH(psc);
		m_pCurrScope = psc;
	}
}
void Method::CloseScope()
{
	ARG_NAME_LIST*	pAN;
	VarDescr*		pVD;
	for(pAN=m_pCurrScope->pLocals; pAN; pAN = pAN->pNext)
	{
		if(pVD = m_Locals.PEEK(pAN->dwAttr)) pVD->bInScope = FALSE;
	}
	m_pCurrScope->dwEnd = m_pAssembler->m_CurPC;
#if(0)
	LinePC *pLPC = new LinePC;
	if(pLPC)
	{
		pLPC->Line = m_pAssembler->m_ulCurLine;
		pLPC->Column = m_pAssembler->m_ulCurColumn;
		pLPC->PC = m_pAssembler->m_CurPC;
		m_LinePCList.PUSH(pLPC);
	}
#endif
	m_pCurrScope = m_pCurrScope->pSuperScope;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\method.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// method.hpp
//
#ifndef _METHOD_HPP
#define _METHOD_HPP

class Assembler;
class PermissionDecl;
class PermissionSetDecl;

#define MAX_EXCEPTIONS 16	// init.number; increased by 16 when needed

/**************************************************************************/
struct LinePC
{
	ULONG	Line;
	ULONG	Column;
	ULONG	PC;
};
typedef FIFO<LinePC> LinePCList;


struct PInvokeDescriptor
{
	mdModuleRef	mrDll;
	char*	szAlias;
	DWORD	dwAttrs;
};

struct CustomDescr
{
	mdToken	tkType;
	BinStr* pBlob;
	CustomDescr(mdToken tk, BinStr* pblob) { tkType = tk; pBlob = pblob; };
	~CustomDescr() { if(pBlob) delete pBlob; };
};
typedef FIFO<CustomDescr> CustomDescrList;
struct TokenRelocDescr // for OBJ generation only!
{
	DWORD	offset;
	mdToken token;
	TokenRelocDescr(DWORD off, mdToken tk) { offset = off; token = tk; };
};
typedef FIFO<TokenRelocDescr> TRDList;
/* structure - element of [local] signature name list */
struct	ARG_NAME_LIST
{
	char szName[128];
	BinStr*   pSig; // argument's signature  ptr
	BinStr*	  pMarshal;
	BinStr*	  pValue;
	int	 nNum;
	DWORD	  dwAttr;
	CustomDescrList	CustDList;
	ARG_NAME_LIST *pNext;
	inline ARG_NAME_LIST(int i, char *sz, BinStr *pbSig, BinStr *pbMarsh, DWORD attr) 
	{nNum = i; strcpy(szName,sz); pNext = NULL; pSig=pbSig; pMarshal = pbMarsh; dwAttr = attr; pValue=NULL; };
	inline ~ARG_NAME_LIST() { if(pSig) delete pSig; if(pMarshal) delete pMarshal; if(pValue) delete pValue; }
};


struct Scope;
typedef FIFO<Scope> ScopeList;
struct Scope
{
	DWORD	dwStart;
	DWORD	dwEnd;
	ARG_NAME_LIST*	pLocals;
	ScopeList		SubScope;
	Scope*			pSuperScope;
	Scope() { dwStart = dwEnd = 0; pLocals = NULL; pSuperScope = NULL; };
};
struct VarDescr
{
	DWORD	dwSlot;
	BinStr*	pbsSig;
	BOOL	bInScope;
	VarDescr() { dwSlot = -1; pbsSig = NULL; bInScope = FALSE; };
};
typedef FIFO<VarDescr> VarDescrList;

class Method
{
public:
    Class  *m_pClass;
    DWORD   m_SigInfoCount;
    DWORD   m_MaxStack;
    mdSignature  m_LocalsSig;
    DWORD   m_numLocals;        // total Number of locals   
    BYTE*   m_localTypes;       //  
    DWORD   m_Flags;
    char*   m_szName;
    char*   m_szExportAlias;
	DWORD	m_dwExportOrdinal;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT *m_ExceptionList;
    DWORD   m_dwNumExceptions;
	DWORD	m_dwMaxNumExceptions;
	DWORD*	m_EndfilterOffsetList;
    DWORD   m_dwNumEndfilters;
	DWORD	m_dwMaxNumEndfilters;
    DWORD   m_Attr;
    BOOL    m_fEntryPoint;
    BOOL    m_fGlobalMethod;
    DWORD   m_methodOffset;
    DWORD   m_headerOffset;
    BYTE *  m_pCode;
    DWORD   m_CodeSize;
    WORD    m_dwExceptionFlags;
	WORD	m_wImplAttr;
	ULONG	m_ulLines[2];
	ULONG	m_ulColumns[2];
	// PInvoke attributes
	PInvokeDescriptor* m_pPInvoke;
    // Security attributes
    PermissionDecl* m_pPermissions;
    PermissionSetDecl* m_pPermissionSets;
	// VTable attributes
	WORD			m_wVTEntry;
	WORD			m_wVTSlot;
	// Return marshaling
	BinStr*	m_pRetMarshal;
	BinStr* m_pRetValue;
	DWORD	m_dwRetAttr;
	CustomDescrList m_RetCustDList;
	// Member ref fixups
	MemberRefDList  m_MemberRefDList;
    Method(Assembler *pAssembler, Class *pClass, char *pszName, BinStr* pbsSig, DWORD Attr);
    ~Method() 
	{ 
		delete m_localTypes; 
		delete [] m_szName;
		if(m_szExportAlias) delete [] m_szExportAlias;
		delArgNameList(m_firstArgName);
		delArgNameList(m_firstVarName);
		delete m_pbsMethodSig;
		delete [] m_ExceptionList;
		delete [] m_EndfilterOffsetList;
		if(m_pRetMarshal) delete m_pRetMarshal;
		if(m_pRetValue) delete m_pRetValue;
		while(m_MethodImplDList.POP()); // ptrs in m_MethodImplDList are dups of those in Assembler
	};

    BOOL IsGlobalMethod()
    {
        return m_fGlobalMethod;
    };

    void SetIsGlobalMethod()
    {
        m_fGlobalMethod = TRUE;
    };
	
	void delArgNameList(ARG_NAME_LIST *pFirst)
	{
		ARG_NAME_LIST *pArgList=pFirst, *pArgListNext;
		for(; pArgList;	pArgListNext=pArgList->pNext,
						delete pArgList, 
						pArgList=pArgListNext);
	};
	
	ARG_NAME_LIST *catArgNameList(ARG_NAME_LIST *pBase, ARG_NAME_LIST *pAdd)
	{
		if(pAdd) //even if nothing to concatenate, result == head
		{
			ARG_NAME_LIST *pAN = pBase;
			if(pBase)
			{
				int i;
				for(; pAN->pNext; pAN = pAN->pNext) ;
				pAN->pNext = pAdd;
				i = pAN->nNum;
				for(pAN = pAdd; pAN; pAN->nNum = ++i, pAN = pAN->pNext);
			}
			else pBase = pAdd; //nothing to concatenate to, result == tail
			//printf("catArgNameList:\n");
			//for(pAN = pBase; pAN; pAN = pAN->pNext)
			//	printf("      %d:%s\n",pAN->nNum,pAN->szName);

		}
		return pBase;
	};

	int	findArgNum(ARG_NAME_LIST *pFirst, char *szArgName)
	{
		int ret=-1;
		ARG_NAME_LIST *pAN;
		for(pAN=pFirst; pAN; pAN = pAN->pNext)
		{
			//printf("findArgNum: %d:%s\n",pAN->nNum,pAN->szName);
			if(!strcmp(pAN->szName,szArgName))
			{
				ret = pAN->nNum;
				break;
			}
		}
		return ret;
	};

	char	*m_szClassName;
	BinStr	*m_pbsMethodSig;
	COR_SIGNATURE*	m_pMethodSig;
	DWORD	m_dwMethodCSig;
	ARG_NAME_LIST *m_firstArgName;
	ARG_NAME_LIST *m_firstVarName;
	// to call error() from Method:
    const char* m_FileName;
    unsigned m_LineNum;
	// debug info
	LinePCList m_LinePCList;
	char m_szSourceFileName[MAX_FILENAME_LENGTH*3];
	GUID	m_guidLang;
	GUID	m_guidLangVendor;
	GUID	m_guidDoc;
	// custom values
	CustomDescrList m_CustomDescrList;
	// token relocs (used for OBJ generation only)
	TRDList m_TRDList;
	// method's own list of method impls
	MethodImplDList	m_MethodImplDList;
	// lexical scope handling 
	Assembler*		m_pAssembler;
	Scope			m_MainScope;
	Scope*			m_pCurrScope;
	VarDescrList	m_Locals;
	void OpenScope();
	void CloseScope();
};

#endif /* _METHOD_HPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "asmparse.h"
#include "__file__.ver"
#include "corver.h"
#include "ShimLoad.h"

ExternC PfnDliHook __pfnDliNotifyHook = ShimDelayLoadHook;

WCHAR *g_wzResourceFile = NULL;
WCHAR *g_wzKeySourceName = NULL;

bool OnErrGo = false;
bool bClock = false;
clock_t		cBegin=0,cEnd=0,
			cParsBegin=0,cParsEnd=0,
			cMDEmitBegin=0,cMDEmitEnd=0,
			cMDEmit1=0,cMDEmit2=0,cMDEmit3=0,cMDEmit4=0,
			cRef2DefBegin=0,cRef2DefEnd=0,
			cFilegenBegin=0,cFilegenEnd=0;
extern unsigned int g_uCodePage;
WCHAR* EqualOrColon(WCHAR* szArg)
{
	WCHAR* pchE = wcschr(szArg,L'=');
	WCHAR* pchC = wcschr(szArg,L':');
	WCHAR* ret;
	if(pchE == NULL) ret = pchC;
	else if(pchC == NULL) ret = pchE;
	else ret = (pchE < pchC)? pchE : pchC;
	return ret;
}

DWORD	g_dwSubsystem=0,g_dwComImageFlags=0,g_dwFileAlignment=0;
size_t	g_stBaseAddress=0;
BOOL	g_bOnUnicode;
WCHAR		*pwzInputFiles[1024];

extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    char        szInputFilename[MAX_FILENAME_LENGTH*3];
	WCHAR		wzOutputFilename[MAX_FILENAME_LENGTH], wzInputFilename[MAX_FILENAME_LENGTH];
    int         i, NumFiles = 0;
    bool	    IsDLL = false, IsOBJ = false;
	char		szOpt[128];
	Assembler	*pAsm;
	FileReadStream *pIn;
	AsmParse	*pParser;
	int			exitval=1;
	bool		bLogo = TRUE;
	BOOL		bNoDebug = TRUE;

	cBegin = clock();

	g_bOnUnicode = OnUnicodeSystem();
	memset(wzOutputFilename,0,sizeof(wzOutputFilename));
	memset(pwzInputFiles,0,1024*sizeof(WCHAR*));

    if (argc < 2 || ! wcscmp(argv[1], L"/?") || ! wcscmp(argv[1],L"-?"))
    { 
		printf("\nMicrosoft (R) .NET Framework IL Assembler.  Version " VER_FILEVERSION_STR);
		printf("\n");
	    wprintf(VER_LEGALCOPYRIGHT_DOS_STR);
		printf("\n\n");
    ErrorExit:
      printf("\n\nUsage: ilasm [Options] <sourcefile> [Options]");
      printf("\n\nOptions:");
      printf("\n/LISTING		Type a formatted list file");
      printf("\n/NOLOGO			Don't type the logo");
//    printf("\n/REF				use old style 'reference' opcodes\n");
//    printf("\n/C++				';' comments and .end <name> to end methods");
      printf("\n/QUIET			Don't report assembly progress");
//      printf("\n/NOAUTOINHERIT		don't inherit from System.Object");
//    printf("\n/OBJ				compile to .obj");
      printf("\n/DLL			Compile to .dll");
      printf("\n/EXE			Compile to .exe (default)");
      printf("\n/DEBUG			Include debug information");
      printf("\n/CLOCK			Measure and report compilation times");
//    printf("\n/ERR				try to create .exe or .dl//l file despite errors reported");
	  printf("\n/RESOURCE=<res_file>	Link the specified resource file (*.res) \n\t\t\tinto resulting .exe or .dll");
	  printf("\n/OUTPUT=<targetfile>	Compile to file with specified name \n\t\t\t(user must provide extension, if any)");
	  printf("\n/KEY=<keyfile>		Compile with strong signature \n\t\t\t(<keyfile> contains private key)");
	  printf("\n/KEY=@<keysource>	Compile with strong signature \n\t\t\t(<keysource> is the private key source name)");
#ifdef OWNER_OPTION_ENABLED
	  printf("\n/OWNER			Protect the resulting file against disassembling");
	  printf("\n/OWNER=<ownersname>	Protect the resulting file against unauthorized disassembling");
	  printf("\n      			(<ownername> will be required to disassemble the file)");
	  printf("\n      			<ownername> is arbitrary string of alphanumeric characters");
	  printf("\n      			without spaces in between (use underscores)");
#endif
	  printf("\n/SUBSYSTEM=<int>	Set Subsystem value in the NT Optional header");
	  printf("\n/FLAGS=<int>		Set CLR ImageFlags value in the CLR header");
	  printf("\n/ALIGNMENT=<int>	Set FileAlignment value in the NT Optional header");
	  printf("\n/BASE=<int>		Set ImageBase value in the NT Optional header");
      printf("\n\nKey may be '-' or '/'\nOptions are recognized by first 3 characters\nDefault source file extension is .IL\n\n");

      exit(1);
    }

	g_uCodePage = g_bOnUnicode ? CP_UTF8 : CP_ACP;
    if(pAsm = new Assembler())
	{
		if(pAsm->Init())
		{
			pAsm->SetStdMapping(1);
			//-------------------------------------------------
			for (i = 1; i < argc; i++)
			{
				if((argv[i][0] == L'/') || (argv[i][0] == L'-'))
				{
					memset(szOpt,0,sizeof(szOpt));
					WszWideCharToMultiByte(g_uCodePage,0,&argv[i][1],10,szOpt,sizeof(szOpt),NULL,NULL);
					szOpt[3] = 0;
					if (!lstrcmpiA(szOpt,"NOA"))
					{
						pAsm->m_fAutoInheritFromObject = FALSE;
					}
				    else if (!lstrcmpiA(szOpt,"QUI"))
					{
						pAsm->m_fReportProgress = FALSE;
						bLogo = FALSE;
					}
					else if (!lstrcmpiA(szOpt, "NOL"))
					{ 
						bLogo = FALSE;
					}
					else if (!lstrcmpiA(szOpt, "LIS"))
					{ 
					  pAsm->m_fGenerateListing = TRUE;
					}
					else if (!lstrcmpiA(szOpt, "DEB"))
					{ 
					  pAsm->m_fIncludeDebugInfo = TRUE;
					  bNoDebug = FALSE;
					}
					else if (!lstrcmpiA(szOpt, "CLO"))
					{ 
					  bClock = true;
					}
					else if (!lstrcmpiA(szOpt, "DLL"))
					{ 
					  IsDLL = true; IsOBJ = false;
					}
					else if (!lstrcmpiA(szOpt, "OBJ"))
					{ 
					  IsOBJ = true; IsDLL = false;
					}
					else if (!lstrcmpiA(szOpt, "ERR"))
					{ 
					  OnErrGo = true;
					}
					else if (!lstrcmpiA(szOpt, "EXE"))
					{
					  IsDLL = false;
					}
					else if (!lstrcmpiA(szOpt, "RES"))
					{
						if(g_wzResourceFile==NULL)
						{
							WCHAR *pStr = EqualOrColon(argv[i]);
							if(pStr == NULL) goto ErrorExit;
							for(pStr++; *pStr == L' '; pStr++); //skip the blanks
							if(wcslen(pStr)==0) goto ErrorExit; //if no file name
							g_wzResourceFile = pStr;
						}
						else
							printf("Multiple resource files not allowed. Option %ls skipped\n",argv[i]);
					}
					else if (!lstrcmpiA(szOpt, "KEY"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						for(pStr++; *pStr == L' '; pStr++); //skip the blanks
						if(wcslen(pStr)==0) goto ErrorExit; //if no file name
						g_wzKeySourceName = pStr;
					}
					else if (!lstrcmpiA(szOpt, "OUT"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						for(pStr++; *pStr == L' '; pStr++); //skip the blanks
						if(wcslen(pStr)==0) goto ErrorExit; //if no file name
						wcscpy(wzOutputFilename,pStr);
					}
					else if (!lstrcmpiA(szOpt, "SUB"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						swscanf(pStr+1,L"%ld",&g_dwSubsystem);
						if(!g_dwSubsystem) swscanf(pStr+1,L"%lx",&g_dwSubsystem);
					}
					else if (!lstrcmpiA(szOpt, "ALI"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						swscanf(pStr+1,L"%ld",&g_dwFileAlignment);
						if(!g_dwFileAlignment) swscanf(pStr+1,L"%lx",&g_dwFileAlignment);
					}
					else if (!lstrcmpiA(szOpt, "FLA"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						swscanf(pStr+1,L"%ld",&g_dwComImageFlags);
						if(!g_dwComImageFlags) swscanf(pStr+1,L"%lx",&g_dwComImageFlags);
					}
					else if (!lstrcmpiA(szOpt, "BAS"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						if(pStr == NULL) goto ErrorExit;
						swscanf(pStr+1,L"%ld",&g_stBaseAddress);
						if(!g_stBaseAddress) swscanf(pStr+1,L"%lx",&g_stBaseAddress);
					}
#ifdef OWNER_OPTION_ENABLED
					else if (!lstrcmpiA(szOpt, "OWN"))
					{
						WCHAR *pStr = EqualOrColon(argv[i]);
						pAsm->m_fOwnershipSet = TRUE;
						pAsm->m_pbsOwner = NULL;
						if(pStr)
						{
							for(pStr++; *pStr == L' '; pStr++); //skip the blanks
							if(*pStr)
							{
								pAsm->m_pbsOwner = new BinStr();
								unsigned L = (unsigned int)(wcslen(pStr) * 3 + 3);
								char *sz = new char[L];
								memset(sz,0,L);
								WszWideCharToMultiByte(CP_UTF8,0,pStr,-1,sz,L,NULL,NULL);
								L = (unsigned)strlen(sz);
								BYTE* pb = (BYTE*)(pAsm->m_pbsOwner->getBuff(L));
								*pb = (BYTE)(*sz);
								for(unsigned jj=1; jj<L; jj++) pb[jj] = (pb[jj-1]+(BYTE)sz[jj])&0xFF;
								delete [] sz;
							}
						}
					}
#endif
					else
					{
						fwprintf(stderr,L"Error : Invalid Option: %s", argv[i]);
						goto ErrorExit;
					}
				}
				else
				{
					pwzInputFiles[NumFiles++] = argv[i];
					if(NumFiles == 1)
					{
						memset(szInputFilename,0,sizeof(szInputFilename));
						WszWideCharToMultiByte(g_uCodePage,0,argv[i],-1,szInputFilename,MAX_FILENAME_LENGTH*3-1,NULL,NULL);
						size_t j = strlen(szInputFilename);
						do
						{
							j--;
							if(szInputFilename[j] == '.') break;
							if((szInputFilename[j] == '\\')||(j == 0))
							{
								strcat(szInputFilename,".IL");
								break;
							}
						}
						while(j);
					}
				}
				
			}
			if(NumFiles == 0) goto ErrorExit;

			if(wzOutputFilename[0] == 0)
			{
				wcscpy(wzOutputFilename,pwzInputFiles[0]);
				size_t j = wcslen(wzOutputFilename);
				do
				{
					j--;
					if(wzOutputFilename[j] == L'.')
					{
						wzOutputFilename[j] = 0;
						break;
					}
				}
				while(j);
				wcscat(wzOutputFilename, (IsDLL ? L".DLL" : (IsOBJ ? L".OBJ" : L".EXE")));
			}    

			//------------ Assembler initialization done. Now, to business -----------------------
			if(pParser = new AsmParse(NULL, pAsm))
			{
				g_uCodePage = g_bOnUnicode ? CP_UTF8 : CP_ACP;
				//======================================================================
				if(bLogo)
				{
					printf("\nMicrosoft (R) .NET Framework IL Assembler.  Version " VER_FILEVERSION_STR);
					printf("\n");
					wprintf(VER_LEGALCOPYRIGHT_DOS_STR);
				}

				pAsm->SetDLL(IsDLL);
				pAsm->SetOBJ(IsOBJ);
				wcscpy(pAsm->m_wzOutputFileName,wzOutputFilename);
				strcpy(pAsm->m_szSourceFileName,szInputFilename);
				if(g_dwSubsystem)		pAsm->m_dwSubsystem = g_dwSubsystem;
				if(g_dwComImageFlags)	pAsm->m_dwComImageFlags = g_dwComImageFlags;
				if(g_dwFileAlignment)	pAsm->m_dwFileAlignment = g_dwFileAlignment;
				if(g_stBaseAddress)		pAsm->m_stBaseAddress = g_stBaseAddress;

				if (SUCCEEDED(pAsm->InitMetaData()))
				{
					int iFile;
					BOOL fAllFilesPresent = TRUE;
					if(bClock) cParsBegin = clock();
					for(iFile = 0; iFile < NumFiles; iFile++)
					{
						g_uCodePage = g_bOnUnicode ? CP_UTF8 : CP_ACP;
						if(iFile) // for the first file, it's already done
						{
							memset(szInputFilename,0,sizeof(szInputFilename));
							WszWideCharToMultiByte(g_uCodePage,0,pwzInputFiles[iFile],-1,szInputFilename,MAX_FILENAME_LENGTH*3-1,NULL,NULL);
							size_t j = strlen(szInputFilename);
							do
							{
								j--;
								if(szInputFilename[j] == '.') break;
								if((szInputFilename[j] == '\\')||(j == 0))
								{
									strcat(szInputFilename,".IL");
									break;
								}
							}
							while(j);
						}
						pParser->msg("\nAssembling '%s' ", szInputFilename);
						if(pAsm->m_fCPlusPlus)	pParser->msg(" C++");
						if(pAsm->m_fWindowsCE)	pParser->msg(" WINCE");
						if(!pAsm->m_fAutoInheritFromObject)	pParser->msg(" NOAUTOINHERIT");
						pParser->msg(pAsm->m_fGenerateListing ? ", with listing file," : ", no listing file,");
						pParser->msg(IsDLL ? " to DLL" : (IsOBJ? " to OBJ" : " to EXE"));
						//======================================================================
						if (pAsm->m_fStdMapping == FALSE)
							pParser->msg(", with REFERENCE mapping");

						{
							char szOutputFilename[MAX_FILENAME_LENGTH*3];
							memset(szOutputFilename,0,sizeof(szOutputFilename));
							WszWideCharToMultiByte(g_uCodePage,0,wzOutputFilename,-1,szOutputFilename,MAX_FILENAME_LENGTH*3-1,NULL,NULL);
							pParser->msg(" --> '%s'\n", szOutputFilename);
						}

						if(g_bOnUnicode)
						{
							memset(wzInputFilename,0,sizeof(wzInputFilename));
							WszMultiByteToWideChar(CP_UTF8,0,szInputFilename,-1,wzInputFilename,MAX_FILENAME_LENGTH);
							pIn = new FileReadStream(wzInputFilename);
						}
						else
							pIn = new FileReadStream(szInputFilename);
						if ((!pIn) || !(pIn->IsValid())) 
						{
							pParser->msg("Could not open %s\n", szInputFilename);
							fAllFilesPresent = FALSE;
						}
						else
						{
							DWORD dwBinType;
							if(g_bOnUnicode && GetBinaryTypeA(szInputFilename,&dwBinType))
							{
								pParser->msg("%s is not a text file\n",szInputFilename);
								fAllFilesPresent = FALSE;
							}
							else
							{
								pAsm->SetSourceFileName(szInputFilename);
								
								pParser->ParseFile(pIn);
							}
						}
						if(pIn) delete pIn;
					} // end for(iFile)
					if(bClock) cParsEnd = clock();
					if ((pParser->Success() && fAllFilesPresent) || OnErrGo)
					{
						HRESULT hr;
						//g_uCodePage = g_bOnUnicode ? CP_UTF8 : CP_ACP;
						if(FAILED(hr=pAsm->CreatePEFile(wzOutputFilename))) 
							pParser->msg("Could not create output file, error code=0x%08X\n",hr);
						else
						{
							if(pParser->Success() && fAllFilesPresent) exitval = 0;
							else
							{
								pParser->msg("Output file contains errors\n");
								if(OnErrGo) exitval = 0;
							}
							if(exitval == 0) // Write the output file
							{
								if(bClock) cFilegenEnd = clock();
								if(pAsm->m_fReportProgress) pParser->msg("Writing %s file\n", pAsm->m_fOBJ ? "COFF" : "PE");
								// Generate the file
								if (FAILED(hr = pAsm->m_pCeeFileGen->GenerateCeeFile(pAsm->m_pCeeFile)))
								{
									exitval = 1;
									pParser->msg("Failed to write output file, error code=0x%08X\n",hr);
								}
                                else if (pAsm->m_pManifest->m_sStrongName.m_fFullSign)
                                {
                                    // Strong name sign the resultant assembly.
                                    if(pAsm->m_fReportProgress) pParser->msg("Signing file with strong name\n");
                                    if (FAILED(hr=pAsm->StrongNameSign()))
                                    {
                                        exitval = 1;
                                        pParser->msg("Failed to strong name sign output file, error code=0x%08X\n",hr);
                                    }
                                }
								if(bClock) cEnd = clock();
							}

						}
					}
				}
				else pParser->msg("Failed to initialize Meta Data\n");
				delete pParser;
			}
			else printf("Could not create parser\n");
		}
		else printf("Failed to initialize Assembler\n");
		delete pAsm;
	}
	else printf("Insufficient memory\n");

	if(exitval || bNoDebug)
	{
		// PE file was not created, or no debug info required. Kill PDB if any
		WCHAR* pc = wcsrchr(wzOutputFilename,L'.');
		if(pc==NULL)
		{
			pc = &wzOutputFilename[wcslen(wzOutputFilename)];
			*pc = L'.';
		}
		wcscpy(pc+1,L"PDB");
#undef DeleteFileW
		DeleteFileW(wzOutputFilename);
	}
    if (exitval == 0)
	{
        printf("Operation completed successfully\n");
		if(bClock)
		{
			printf("Timing (msec): Total run               %d\n",((cEnd-cBegin)*1000)/CLOCKS_PER_SEC);
			printf("               Startup                 %d\n",((cParsBegin-cBegin)*1000)/CLOCKS_PER_SEC);
			printf("               Parsing                 %d\n",((cParsEnd - cParsBegin)*1000)/CLOCKS_PER_SEC);
			printf("               Emitting MD             %d\n",((cMDEmitEnd - cMDEmitBegin)*1000)/CLOCKS_PER_SEC);
			printf("                - global fixups        %d\n",((cMDEmit1 - cMDEmitBegin)*1000)/CLOCKS_PER_SEC);
			printf("                - SN sig alloc         %d\n",((cMDEmit2 - cMDEmit1)*1000)/CLOCKS_PER_SEC);
			printf("                - check local TypeRefs %d\n",((cMDEmit3 - cMDEmit2)*1000)/CLOCKS_PER_SEC);
			printf("                - emit members         %d\n",((cMDEmit4 - cMDEmit3)*1000)/CLOCKS_PER_SEC);
			printf("                - emit MethodImpls     %d\n",((cMDEmitEnd - cMDEmit4)*1000)/CLOCKS_PER_SEC);
			printf("               Ref to Def resolution   %d\n",((cRef2DefEnd - cRef2DefBegin)*1000)/CLOCKS_PER_SEC);
			printf("               Fixup and linking       %d\n",((cFilegenBegin - cRef2DefEnd)*1000)/CLOCKS_PER_SEC);
			printf("               CEE file generation     %d\n",((cFilegenEnd - cFilegenBegin)*1000)/CLOCKS_PER_SEC);
			printf("               PE file writing         %d\n",((cEnd - cFilegenEnd)*1000)/CLOCKS_PER_SEC);
		}
	}
    else
	{
        printf("\n***** FAILURE ***** \n");
	}
    exit(exitval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\nvpair.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/* Name value pair (both strings) which can be linked into a list of pairs */

#ifndef NVPAIR_H
#define NVPAIR_H

#include "BinStr.h"

class NVPair
{
public:

    NVPair(BinStr *name, BinStr *value)
    {
        m_Name = name;
        m_Value = value;
        m_Tail = NULL;
    }

    ~NVPair()
    {
        delete m_Name;
        delete m_Value;
        delete m_Tail;
    }

    NVPair *Concat(NVPair *list)
    {
        m_Tail = list;
        return this;
    }

    BinStr *Name() { return m_Name; }
    BinStr *Value() { return m_Value; }
    NVPair *Next() { return m_Tail; }

private:
    BinStr *m_Name;
    BinStr *m_Value;
    NVPair *m_Tail;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ILASM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework IL assembler\0"
#define VER_ORIGFILENAME_STR    "ilasm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\objd\i386\asmparse.c ===
/*
 * Created by Microsoft VCBU Internal YACC from "asmparse.y"
 */

#line 2 "asmparse.y"

// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include <asmparse.h>
#include <crtdbg.h>             // FOR ASSERTE
#include <string.h>             // for strcmp    
#include <mbstring.h>           // for _mbsinc    
#include <ctype.h>                      // for isspace    
#include <stdlib.h>             // for strtoul
#include "openum.h"             // for CEE_*
#include <stdarg.h>         // for vararg macros 

#define YYMAXDEPTH 65535

// #define DEBUG_PARSING
#ifdef DEBUG_PARSING
bool parseDBFlag = true;
#define dbprintf(x)     if (parseDBFlag) printf x
#define YYDEBUG 1
#else
#define dbprintf(x)     
#endif

#define FAIL_UNLESS(cond, msg) if (!(cond)) { parser->success = false; parser->error msg; }

static AsmParse* parser = 0;
#define PASM    (parser->assem)
#define PASMM   (parser->assem->m_pManifest)

static char* newStringWDel(char* str1, char* str2, char* str3 = 0);
static char* newString(char* str1);
void corEmitInt(BinStr* buff, unsigned data);
bool bParsingByteArray = FALSE;
bool bExternSource = FALSE;
int  nExtLine,nExtCol;
int iOpcodeLen = 0;

ARG_NAME_LIST *palDummy;

int  nTemp=0;

unsigned int g_uCodePage = CP_ACP;
extern DWORD	g_dwSubsystem,g_dwComImageFlags,g_dwFileAlignment;
extern size_t	g_stBaseAddress;
unsigned int uMethodBeginLine,uMethodBeginColumn;
extern BOOL	g_bOnUnicode;

#line 54 "asmparse.y"

#define UNION 1
typedef union  {
        CorRegTypeAttr classAttr;
        CorMethodAttr methAttr;
        CorFieldAttr fieldAttr;
        CorMethodImpl implAttr;
        CorEventAttr  eventAttr;
        CorPropertyAttr propAttr;
        CorPinvokeMap pinvAttr;
        CorDeclSecurity secAct;
        CorFileFlags fileAttr;
        CorAssemblyFlags asmAttr;
        CorTypeAttr comtAttr;
        CorManifestResourceFlags manresAttr;
        double*  float64;
        __int64* int64;
        __int32  int32;
        char*    string;
        BinStr*  binstr;
        Labels*  labels;
        Instr*   instr;         // instruction opcode
        NVPair*  pair;
} YYSTYPE;
# define ERROR_ 257 
# define BAD_COMMENT_ 258 
# define BAD_LITERAL_ 259 
# define ID 260 
# define DOTTEDNAME 261 
# define QSTRING 262 
# define SQSTRING 263 
# define INT32 264 
# define INT64 265 
# define FLOAT64 266 
# define HEXBYTE 267 
# define DCOLON 268 
# define ELIPSES 269 
# define VOID_ 270 
# define BOOL_ 271 
# define CHAR_ 272 
# define UNSIGNED_ 273 
# define INT_ 274 
# define INT8_ 275 
# define INT16_ 276 
# define INT32_ 277 
# define INT64_ 278 
# define FLOAT_ 279 
# define FLOAT32_ 280 
# define FLOAT64_ 281 
# define BYTEARRAY_ 282 
# define OBJECT_ 283 
# define STRING_ 284 
# define NULLREF_ 285 
# define DEFAULT_ 286 
# define CDECL_ 287 
# define VARARG_ 288 
# define STDCALL_ 289 
# define THISCALL_ 290 
# define FASTCALL_ 291 
# define CONST_ 292 
# define CLASS_ 293 
# define TYPEDREF_ 294 
# define UNMANAGED_ 295 
# define NOT_IN_GC_HEAP_ 296 
# define FINALLY_ 297 
# define HANDLER_ 298 
# define CATCH_ 299 
# define FILTER_ 300 
# define FAULT_ 301 
# define EXTENDS_ 302 
# define IMPLEMENTS_ 303 
# define TO_ 304 
# define AT_ 305 
# define TLS_ 306 
# define TRUE_ 307 
# define FALSE_ 308 
# define VALUE_ 309 
# define VALUETYPE_ 310 
# define NATIVE_ 311 
# define INSTANCE_ 312 
# define SPECIALNAME_ 313 
# define STATIC_ 314 
# define PUBLIC_ 315 
# define PRIVATE_ 316 
# define FAMILY_ 317 
# define FINAL_ 318 
# define SYNCHRONIZED_ 319 
# define INTERFACE_ 320 
# define SEALED_ 321 
# define NESTED_ 322 
# define ABSTRACT_ 323 
# define AUTO_ 324 
# define SEQUENTIAL_ 325 
# define EXPLICIT_ 326 
# define WRAPPER_ 327 
# define ANSI_ 328 
# define UNICODE_ 329 
# define AUTOCHAR_ 330 
# define IMPORT_ 331 
# define ENUM_ 332 
# define VIRTUAL_ 333 
# define NOTREMOTABLE_ 334 
# define SPECIAL_ 335 
# define NOINLINING_ 336 
# define UNMANAGEDEXP_ 337 
# define BEFOREFIELDINIT_ 338 
# define STRICT_ 339 
# define RETARGETABLE_ 340 
# define METHOD_ 341 
# define FIELD_ 342 
# define PINNED_ 343 
# define MODREQ_ 344 
# define MODOPT_ 345 
# define SERIALIZABLE_ 346 
# define ASSEMBLY_ 347 
# define FAMANDASSEM_ 348 
# define FAMORASSEM_ 349 
# define PRIVATESCOPE_ 350 
# define HIDEBYSIG_ 351 
# define NEWSLOT_ 352 
# define RTSPECIALNAME_ 353 
# define PINVOKEIMPL_ 354 
# define _CTOR 355 
# define _CCTOR 356 
# define LITERAL_ 357 
# define NOTSERIALIZED_ 358 
# define INITONLY_ 359 
# define REQSECOBJ_ 360 
# define CIL_ 361 
# define OPTIL_ 362 
# define MANAGED_ 363 
# define FORWARDREF_ 364 
# define PRESERVESIG_ 365 
# define RUNTIME_ 366 
# define INTERNALCALL_ 367 
# define _IMPORT 368 
# define NOMANGLE_ 369 
# define LASTERR_ 370 
# define WINAPI_ 371 
# define AS_ 372 
# define BESTFIT_ 373 
# define ON_ 374 
# define OFF_ 375 
# define CHARMAPERROR_ 376 
# define INSTR_NONE 377 
# define INSTR_VAR 378 
# define INSTR_I 379 
# define INSTR_I8 380 
# define INSTR_R 381 
# define INSTR_BRTARGET 382 
# define INSTR_METHOD 383 
# define INSTR_FIELD 384 
# define INSTR_TYPE 385 
# define INSTR_STRING 386 
# define INSTR_SIG 387 
# define INSTR_RVA 388 
# define INSTR_TOK 389 
# define INSTR_SWITCH 390 
# define INSTR_PHI 391 
# define _CLASS 392 
# define _NAMESPACE 393 
# define _METHOD 394 
# define _FIELD 395 
# define _DATA 396 
# define _EMITBYTE 397 
# define _TRY 398 
# define _MAXSTACK 399 
# define _LOCALS 400 
# define _ENTRYPOINT 401 
# define _ZEROINIT 402 
# define _PDIRECT 403 
# define _EVENT 404 
# define _ADDON 405 
# define _REMOVEON 406 
# define _FIRE 407 
# define _OTHER 408 
# define PROTECTED_ 409 
# define _PROPERTY 410 
# define _SET 411 
# define _GET 412 
# define READONLY_ 413 
# define _PERMISSION 414 
# define _PERMISSIONSET 415 
# define REQUEST_ 416 
# define DEMAND_ 417 
# define ASSERT_ 418 
# define DENY_ 419 
# define PERMITONLY_ 420 
# define LINKCHECK_ 421 
# define INHERITCHECK_ 422 
# define REQMIN_ 423 
# define REQOPT_ 424 
# define REQREFUSE_ 425 
# define PREJITGRANT_ 426 
# define PREJITDENY_ 427 
# define NONCASDEMAND_ 428 
# define NONCASLINKDEMAND_ 429 
# define NONCASINHERITANCE_ 430 
# define _LINE 431 
# define P_LINE 432 
# define _LANGUAGE 433 
# define _CUSTOM 434 
# define INIT_ 435 
# define _SIZE 436 
# define _PACK 437 
# define _VTABLE 438 
# define _VTFIXUP 439 
# define FROMUNMANAGED_ 440 
# define CALLMOSTDERIVED_ 441 
# define _VTENTRY 442 
# define RETAINAPPDOMAIN_ 443 
# define _FILE 444 
# define NOMETADATA_ 445 
# define _HASH 446 
# define _ASSEMBLY 447 
# define _PUBLICKEY 448 
# define _PUBLICKEYTOKEN 449 
# define ALGORITHM_ 450 
# define _VER 451 
# define _LOCALE 452 
# define EXTERN_ 453 
# define _MRESOURCE 454 
# define _LOCALIZED 455 
# define IMPLICITCOM_ 456 
# define IMPLICITRES_ 457 
# define NOAPPDOMAIN_ 458 
# define NOPROCESS_ 459 
# define NOMACHINE_ 460 
# define _MODULE 461 
# define _EXPORT 462 
# define MARSHAL_ 463 
# define CUSTOM_ 464 
# define SYSSTRING_ 465 
# define FIXED_ 466 
# define VARIANT_ 467 
# define CURRENCY_ 468 
# define SYSCHAR_ 469 
# define DECIMAL_ 470 
# define DATE_ 471 
# define BSTR_ 472 
# define TBSTR_ 473 
# define LPSTR_ 474 
# define LPWSTR_ 475 
# define LPTSTR_ 476 
# define OBJECTREF_ 477 
# define IUNKNOWN_ 478 
# define IDISPATCH_ 479 
# define STRUCT_ 480 
# define SAFEARRAY_ 481 
# define BYVALSTR_ 482 
# define LPVOID_ 483 
# define ANY_ 484 
# define ARRAY_ 485 
# define LPSTRUCT_ 486 
# define IN_ 487 
# define OUT_ 488 
# define OPT_ 489 
# define LCID_ 490 
# define RETVAL_ 491 
# define _PARAM 492 
# define _OVERRIDE 493 
# define WITH_ 494 
# define NULL_ 495 
# define HRESULT_ 496 
# define CARRAY_ 497 
# define USERDEFINED_ 498 
# define RECORD_ 499 
# define FILETIME_ 500 
# define BLOB_ 501 
# define STREAM_ 502 
# define STORAGE_ 503 
# define STREAMED_OBJECT_ 504 
# define STORED_OBJECT_ 505 
# define BLOB_OBJECT_ 506 
# define CF_ 507 
# define CLSID_ 508 
# define VECTOR_ 509 
# define _SUBSYSTEM 510 
# define _CORFLAGS 511 
# define ALIGNMENT_ 512 
# define _IMAGEBASE 513 
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
#ifndef YYFARDATA
#define	YYFARDATA	/*nothing*/
#endif
#if ! defined YYSTATIC
#define	YYSTATIC	/*nothing*/
#endif
#if ! defined YYCONST
#define	YYCONST	/*nothing*/
#endif
#ifndef	YYACT
#define	YYACT	yyact
#endif
#ifndef	YYPACT
#define	YYPACT	yypact
#endif
#ifndef	YYPGO
#define	YYPGO	yypgo
#endif
#ifndef	YYR1
#define	YYR1	yyr1
#endif
#ifndef	YYR2
#define	YYR2	yyr2
#endif
#ifndef	YYCHK
#define	YYCHK	yychk
#endif
#ifndef	YYDEF
#define	YYDEF	yydef
#endif
#ifndef	YYV
#define	YYV	yyv
#endif
#ifndef	YYS
#define	YYS	yys
#endif
#ifndef	YYLOCAL
#define	YYLOCAL
#endif
#ifndef YYR_T
#define	YYR_T	int
#endif
typedef	YYR_T	yyr_t;
#ifndef YYEXIND_T
#define	YYEXIND_T	unsigned int
#endif
typedef	YYEXIND_T	yyexind_t;
#ifndef YYOPTTIME
#define	YYOPTTIME	0
#endif
# define YYERRCODE 256

#line 1382 "asmparse.y"

/********************************************************************************/
/* Code goes here */

/********************************************************************************/

void yyerror(char* str) {
    char tokBuff[64];
    char *ptr;
    size_t len = parser->curPos - parser->curTok;
    if (len > 63) len = 63;
    memcpy(tokBuff, parser->curTok, len);
    tokBuff[len] = 0;
    fprintf(stderr, "%s(%d) : error : %s at token '%s' in: %s\n", 
            parser->in->name(), parser->curLine, str, tokBuff, (ptr=parser->getLine(parser->curLine)));
    parser->success = false;
    delete ptr;
}

struct Keywords {
    const char* name;
    unsigned short token;
    unsigned short tokenVal;// this holds the instruction enumeration for those keywords that are instrs
};

#define NO_VALUE        -1              // The token has no value

static Keywords keywords[] = {
// Attention! Because of aliases, the instructions MUST go first!
// Redefine all the instructions (defined in assembler.h <- asmenum.h <- opcode.def)
#undef InlineNone
#undef InlineVar        
#undef ShortInlineVar
#undef InlineI          
#undef ShortInlineI     
#undef InlineI8         
#undef InlineR          
#undef ShortInlineR     
#undef InlineBrTarget
#undef ShortInlineBrTarget
#undef InlineMethod
#undef InlineField 
#undef InlineType 
#undef InlineString
#undef InlineSig        
#undef InlineRVA        
#undef InlineTok        
#undef InlineSwitch
#undef InlinePhi        
#undef InlineVarTok     


#define InlineNone              INSTR_NONE
#define InlineVar               INSTR_VAR
#define ShortInlineVar          INSTR_VAR
#define InlineI                 INSTR_I
#define ShortInlineI            INSTR_I
#define InlineI8                INSTR_I8
#define InlineR                 INSTR_R
#define ShortInlineR            INSTR_R
#define InlineBrTarget          INSTR_BRTARGET
#define ShortInlineBrTarget             INSTR_BRTARGET
#define InlineMethod            INSTR_METHOD
#define InlineField             INSTR_FIELD
#define InlineType              INSTR_TYPE
#define InlineString            INSTR_STRING
#define InlineSig               INSTR_SIG
#define InlineRVA               INSTR_RVA
#define InlineTok               INSTR_TOK
#define InlineSwitch            INSTR_SWITCH
#define InlinePhi               INSTR_PHI

        // @TODO remove when this instruction goes away
#define InlineVarTok            0
#define NEW_INLINE_NAMES
                // The volatile instruction collides with the volatile keyword, so 
                // we treat it as a keyword everywhere and modify the grammar accordingly (Yuck!) 
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) { s, args, c },
#define OPALIAS(alias_c, s, c) { s, keywords[c].token, c },
#include "opcode.def"
#undef OPALIAS
#undef OPDEF

                /* keywords */
#define KYWD(name, sym, val)    { name, sym, val},
#include "il_kywd.h"
#undef KYWD

        // These are deprecated
        { "float",                      FLOAT_ },
};

/********************************************************************************/
/* used by qsort to sort the keyword table */
static int __cdecl keywordCmp(const void *op1, const void *op2)
{
    return  strcmp(((Keywords*) op1)->name, ((Keywords*) op2)->name);
}

/********************************************************************************/
/* looks up the keyword 'name' of length 'nameLen' (name does not need to be 
   null terminated)   Returns 0 on failure */

static int findKeyword(const char* name, size_t nameLen, Instr** value) 
{
    Keywords* low = keywords;
    Keywords* high = &keywords[sizeof(keywords) / sizeof(Keywords)];

    _ASSERTE (high > low);          // Table is non-empty
    for(;;) 
        {
        Keywords* mid = &low[(high - low) / 2];

                // compare the strings
        int cmp = strncmp(name, mid->name, nameLen);
        if (cmp == 0 && nameLen < strlen(mid->name)) --cmp;
        if (cmp == 0)
        {
            //printf("Token '%s' = %d opcode = %d\n", mid->name, mid->token, mid->tokenVal);
            if (mid->tokenVal != NO_VALUE)
            {
                if(*value = new Instr)
				{
					(*value)->opcode = mid->tokenVal;
					(*value)->linenum = (bExternSource ? nExtLine : parser->curLine);
					(*value)->column = (bExternSource ? nExtCol : 1);
				}
            }
            else *value = NULL;

            return(mid->token);
        }

        if (mid == low)  return(0);

        if (cmp > 0) low = mid;
        else        high = mid;
    }
}

/********************************************************************************/
/* convert str to a uint64 */

static unsigned __int64 str2uint64(const char* str, const char** endStr, unsigned radix) 
{
    static unsigned digits[256];
    static initialize=TRUE;
    unsigned __int64 ret = 0;
    unsigned digit;
    _ASSERTE(radix <= 36);
    if(initialize)
    {
        int i;
        memset(digits,255,sizeof(digits));
        for(i='0'; i <= '9'; i++) digits[i] = i - '0';
        for(i='A'; i <= 'Z'; i++) digits[i] = i + 10 - 'A';
        for(i='a'; i <= 'z'; i++) digits[i] = i + 10 - 'a';
        initialize = FALSE;
    }
    for(;;str++) 
        {
        digit = digits[*str];
        if (digit >= radix) 
                {
            *endStr = str;
            return(ret);
        }
        ret = ret * radix + digit;
    }
}

/********************************************************************************/
/* fetch the next token, and return it   Also set the yylval.union if the
   lexical token also has a value */

#define IsValidStartingSymbol(x) (isalpha((x)&0xFF)||((x)=='#')||((x)=='_')||((x)=='@')||((x)=='$'))
#define IsValidContinuingSymbol(x) (isalnum((x)&0xFF)||((x)=='_')||((x)=='@')||((x)=='$')||((x)=='?'))
char* nextchar(char* pos)
{
	return (g_uCodePage == CP_ACP) ? (char *)_mbsinc((const unsigned char *)pos) : ++pos;
}
int yylex() 
{
    char* curPos = parser->curPos;

        // Skip any leading whitespace and comments
    const unsigned eolComment = 1;
    const unsigned multiComment = 2;
    unsigned state = 0;
    for(;;) 
    {   // skip whitespace and comments
        if (curPos >= parser->limit) 
        {
            curPos = parser->fillBuff(curPos);
			if(strlen(curPos) < (unsigned)(parser->endPos - curPos))
			{
				yyerror("Not a text file");
				return 0;
			}
        }
        
        switch(*curPos) 
        {
            case 0: 
                if (state & multiComment) return (BAD_COMMENT_);
                return 0;       // EOF
            case '\n':
                state &= ~eolComment;
                parser->curLine++;
                PASM->m_ulCurLine = (bExternSource ? nExtLine : parser->curLine);
                PASM->m_ulCurColumn = (bExternSource ? nExtCol : 1);
                break;
            case '\r':
            case ' ' :
            case '\t':
            case '\f':
                break;

            case '*' :
                if(state == 0) goto PAST_WHITESPACE;
                if(state & multiComment)
                {
                    if (curPos[1] == '/') 
                    {
                        curPos++;
                        state &= ~multiComment;
                    }
                }
                break;

            case '/' :
                if(state == 0)
                {
                    if (curPos[1] == '/')  state |= eolComment;
                    else if (curPos[1] == '*') 
                    {
                        curPos++;
                        state |= multiComment;
                    }
                    else goto PAST_WHITESPACE;
                }
                break;

            default:
                if (state == 0)  goto PAST_WHITESPACE;
        }
        //curPos++;
		curPos = nextchar(curPos);
    }
PAST_WHITESPACE:

    char* curTok = curPos;
    parser->curTok = curPos;
    parser->curPos = curPos;
    int tok = ERROR_;
    yylval.string = 0;

    if(bParsingByteArray) // only hexadecimals w/o 0x, ')' and white space allowed!
    {
        int i,s=0;
        char ch;
        for(i=0; i<2; i++, curPos++)
        {
            ch = *curPos;
            if(('0' <= ch)&&(ch <= '9')) s = s*16+(ch - '0');
            else if(('A' <= ch)&&(ch <= 'F')) s = s*16+(ch - 'A' + 10);
            else if(('a' <= ch)&&(ch <= 'f')) s = s*16+(ch - 'a' + 10);
            else break; // don't increase curPos!
        }
        if(i)
        {
            tok = HEXBYTE;
            yylval.int32 = s;
        }
        else
        {
            if(ch == ')') 
            {
                bParsingByteArray = FALSE;
                goto Just_A_Character;
            }
        }
        parser->curPos = curPos;
        return(tok);
    }
    if(*curPos == '?') // '?' may be part of an identifier, if it's not followed by punctuation
    {
		if(IsValidContinuingSymbol(*(curPos+1))) goto Its_An_Id;
        goto Just_A_Character;
    }

    if (IsValidStartingSymbol(*curPos)) 
    { // is it an ID
Its_An_Id:
        size_t offsetDot = (size_t)-1; // first appearance of '.'
		size_t offsetDotDigit = (size_t)-1; // first appearance of '.<digit>' (not DOTTEDNAME!)
        do 
        {
            if (curPos >= parser->limit) 
            {
                size_t offsetInStr = curPos - curTok;
                curTok = parser->fillBuff(curTok);
                curPos = curTok + offsetInStr;
            }
            //curPos++;
			curPos = nextchar(curPos);
            if (*curPos == '.') 
            {
                if (offsetDot == (size_t)-1) offsetDot = curPos - curTok;
                curPos++;
				if((offsetDotDigit==(size_t)-1)&&(*curPos >= '0')&&(*curPos <= '9')) 
					offsetDotDigit = curPos - curTok - 1;
            }
        } while(IsValidContinuingSymbol(*curPos));
        size_t tokLen = curPos - curTok;

        // check to see if it is a keyword
        int token = findKeyword(curTok, tokLen, &yylval.instr);
        if (token != 0) 
        {
            //printf("yylex: TOK = %d, curPos=0x%8.8X\n",token,curPos);
            parser->curPos = curPos;
            parser->curTok = curTok;
            return(token);
        }
        if(*curTok == '#') 
        {
            parser->curPos = curPos;
            parser->curTok = curTok;
            return(ERROR_);
        }
        // Not a keyword, normal identifiers don't have '.' in them
        if (offsetDot < (size_t)-1) 
        {
			if(offsetDotDigit < (size_t)-1)
			{
				curPos = curTok+offsetDotDigit;
				tokLen = offsetDotDigit;
			}
			while((*(curPos-1)=='.')&&(tokLen))
			{
				curPos--;
				tokLen--;
			}
        }

        if(yylval.string = new char[tokLen+1])
		{
			memcpy(yylval.string, curTok, tokLen);
			yylval.string[tokLen] = 0;
			tok = (offsetDot == 0xFFFFFFFF)? ID : DOTTEDNAME;
			//printf("yylex: ID = '%s', curPos=0x%8.8X\n",yylval.string,curPos);
		}
		else return BAD_LITERAL_;
    }
    else if (isdigit((*curPos)&0xFF) 
        || (*curPos == '.' && isdigit(curPos[1]&0xFF))
        || (*curPos == '-' && isdigit(curPos[1]&0xFF))) 
        {
        // Refill buffer, we may be close to the end, and the number may be only partially inside
        if(parser->endPos - curPos < AsmParse::IN_OVERLAP)
        {
            curTok = parser->fillBuff(curPos);
            curPos = curTok;
        }
        const char* begNum = curPos;
        unsigned radix = 10;

        bool neg = (*curPos == '-');    // always make it unsigned 
        if (neg) curPos++;

        if (curPos[0] == '0' && curPos[1] != '.') 
                {
            curPos++;
            radix = 8;
            if (*curPos == 'x' || *curPos == 'X') 
                        {
                curPos++;
                radix = 16;
            }
        }
        begNum = curPos;
        {
            unsigned __int64 i64 = str2uint64(begNum, const_cast<const char**>(&curPos), radix);
            yylval.int64 = new __int64(i64);
            tok = INT64;                    
            if (neg) *yylval.int64 = -*yylval.int64;
        }
        if (radix == 10 && ((*curPos == '.' && curPos[1] != '.') || *curPos == 'E' || *curPos == 'e')) 
                {
            yylval.float64 = new double(strtod(begNum, &curPos));
            if (neg) *yylval.float64 = -*yylval.float64;
            tok = FLOAT64;
        }
    }
    else 
    {   //      punctuation
        if (*curPos == '"' || *curPos == '\'') 
        {
            //char quote = *curPos++;
            char quote = *curPos;
			curPos = nextchar(curPos);
            char* fromPtr = curPos;
			char* prevPos;
            bool escape = false;
            BinStr* pBuf = new BinStr(); 
            for(;;) 
            {     // Find matching quote
                if (curPos >= parser->limit)
                { 
                    curTok = parser->fillBuff(curPos);
                    curPos = curTok;
                }
                
                if (*curPos == 0) { parser->curPos = curPos; delete pBuf; return(BAD_LITERAL_); }
                if (*curPos == '\r') curPos++;  //for end-of-line \r\n
                if (*curPos == '\n') 
                {
                    parser->curLine++;
                    PASM->m_ulCurLine = (bExternSource ? nExtLine : parser->curLine);
                    PASM->m_ulCurColumn = (bExternSource ? nExtCol : 1);
                    if (!escape) { parser->curPos = curPos; delete pBuf; return(BAD_LITERAL_); }
                }
                if ((*curPos == quote) && (!escape)) break;
                escape =(!escape) && (*curPos == '\\');
                //pBuf->appendInt8(*curPos++);
				prevPos = curPos;
				curPos = nextchar(curPos);
                while(prevPos < curPos) pBuf->appendInt8(*prevPos++);
            }
            //curPos++;               // skip closing quote
			curPos = nextchar(curPos);
                                
            // translate escaped characters
            unsigned tokLen = pBuf->length();
            char* toPtr = new char[tokLen+1];
			if(toPtr==NULL) return BAD_LITERAL_;
            yylval.string = toPtr;
            fromPtr = (char *)(pBuf->ptr());
            char* endPtr = fromPtr+tokLen;
            while(fromPtr < endPtr) 
            {
                if (*fromPtr == '\\') 
                {
                    fromPtr++;
                    switch(*fromPtr) 
                    {
                        case 't':
                                *toPtr++ = '\t';
                                break;
                        case 'n':
                                *toPtr++ = '\n';
                                break;
                        case 'b':
                                *toPtr++ = '\b';
                                break;
                        case 'f':
                                *toPtr++ = '\f';
                                break;
                        case 'v':
                                *toPtr++ = '\v';
                                break;
                        case '?':
                                *toPtr++ = '\?';
                                break;
                        case 'r':
                                *toPtr++ = '\r';
                                break;
                        case 'a':
                                *toPtr++ = '\a';
                                break;
                        case '\n':
                                do      fromPtr++;
                                while(isspace(*fromPtr));
                                --fromPtr;              // undo the increment below   
                                break;
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                                if (isdigit(fromPtr[1]&0xFF) && isdigit(fromPtr[2]&0xFF)) 
                                {
                                    *toPtr++ = ((fromPtr[0] - '0') * 8 + (fromPtr[1] - '0')) * 8 + (fromPtr[2] - '0');
                                    fromPtr+= 2;                                                            
                                }
                                else if(*fromPtr == '0') *toPtr++ = 0;
                                break;
                        default:
                                *toPtr++ = *fromPtr;
                    }
                    fromPtr++;
                }
                else
				//  *toPtr++ = *fromPtr++;
				{
					char* tmpPtr = fromPtr;
					fromPtr = nextchar(fromPtr);
					while(tmpPtr < fromPtr) *toPtr++ = *tmpPtr++;
				}

            } //end while(fromPtr < endPtr)
            *toPtr = 0;                     // terminate string
            if(quote == '"')
            {
                BinStr* pBS = new BinStr();
                unsigned size = (unsigned)(toPtr - yylval.string);
                memcpy(pBS->getBuff(size),yylval.string,size);
                delete yylval.string;
                yylval.binstr = pBS;
                tok = QSTRING;
            }
            else tok = SQSTRING;
            delete pBuf;
        } // end if (*curPos == '"' || *curPos == '\'')
        else if (strncmp(curPos, "::", 2) == 0) 
        {
            curPos += 2;
            tok = DCOLON;
        }       
        else if (strncmp(curPos, "...", 3) == 0) 
        {
            curPos += 3;
            tok = ELIPSES;
        }
        else if(*curPos == '.') 
        {
            do
            {
                curPos++;
                if (curPos >= parser->limit) 
                {
                    size_t offsetInStr = curPos - curTok;
                    curTok = parser->fillBuff(curTok);
                    curPos = curTok + offsetInStr;
                }
            }
            while(isalnum(*curPos) || *curPos == '_' || *curPos == '$'|| *curPos == '@'|| *curPos == '?');
            size_t tokLen = curPos - curTok;

            // check to see if it is a keyword
            int token = findKeyword(curTok, tokLen, &yylval.instr);
            if(token)
			{
                //printf("yylex: TOK = %d, curPos=0x%8.8X\n",token,curPos);
                parser->curPos = curPos;
                parser->curTok = curTok; 
                return(token);
            }
            tok = '.';
            curPos = curTok + 1;
        }
        else 
        {
Just_A_Character:
            tok = *curPos++;
        }
        //printf("yylex: PUNCT curPos=0x%8.8X\n",curPos);
    }
    dbprintf(("    Line %d token %d (%c) val = %s\n", parser->curLine, tok, 
            (tok < 128 && isprint(tok)) ? tok : ' ', 
            (tok > 255 && tok != INT32 && tok != INT64 && tok!= FLOAT64) ? yylval.string : ""));

    parser->curPos = curPos;
    parser->curTok = curTok; 
    return(tok);
}

/**************************************************************************/
static char* newString(char* str1) 
{
    char* ret = new char[strlen(str1)+1];
    if(ret) strcpy(ret, str1);
    return(ret);
}

/**************************************************************************/
/* concatinate strings and release them */

static char* newStringWDel(char* str1, char* str2, char* str3) 
{
    size_t len = strlen(str1) + strlen(str2)+1;
    if (str3) len += strlen(str3);
    char* ret = new char[len];
    if(ret)
	{
		strcpy(ret, str1);
		delete [] str1;
		strcat(ret, str2);
		delete [] str2;
		if (str3)
		{
			strcat(ret, str3);
			delete [] str3;
		}
	}
    return(ret);
}

/**************************************************************************/
static void corEmitInt(BinStr* buff, unsigned data) 
{
    unsigned cnt = CorSigCompressData(data, buff->getBuff(5));
    buff->remove(5 - cnt);
}

/**************************************************************************/
/* move 'ptr past the exactly one type description */

static unsigned __int8* skipType(unsigned __int8* ptr) 
{
    mdToken  tk;
AGAIN:
    switch(*ptr++) {
        case ELEMENT_TYPE_VOID         :
        case ELEMENT_TYPE_BOOLEAN      :
        case ELEMENT_TYPE_CHAR         :
        case ELEMENT_TYPE_I1           :
        case ELEMENT_TYPE_U1           :
        case ELEMENT_TYPE_I2           :
        case ELEMENT_TYPE_U2           :
        case ELEMENT_TYPE_I4           :
        case ELEMENT_TYPE_U4           :
        case ELEMENT_TYPE_I8           :
        case ELEMENT_TYPE_U8           :
        case ELEMENT_TYPE_R4           :
        case ELEMENT_TYPE_R8           :
        case ELEMENT_TYPE_U            :
        case ELEMENT_TYPE_I            :
        case ELEMENT_TYPE_R            :
        case ELEMENT_TYPE_STRING       :
        case ELEMENT_TYPE_OBJECT       :
        case ELEMENT_TYPE_TYPEDBYREF   :
                /* do nothing */
                break;

        case ELEMENT_TYPE_VALUETYPE   :
        case ELEMENT_TYPE_CLASS        :
                ptr += CorSigUncompressToken(ptr, &tk);
                break;

        case ELEMENT_TYPE_CMOD_REQD    :
        case ELEMENT_TYPE_CMOD_OPT     :
                ptr += CorSigUncompressToken(ptr, &tk);
                goto AGAIN;

		/* uncomment when and if this type is supported by the Runtime
        case ELEMENT_TYPE_VALUEARRAY   :
                ptr = skipType(ptr);                    // element Type
                CorSigUncompressData(ptr);              // bound
                break;
		*/

        case ELEMENT_TYPE_ARRAY         :
                {
                    ptr = skipType(ptr);                    // element Type
                    unsigned rank = CorSigUncompressData(ptr);      
                    if (rank != 0) 
                    {
						unsigned numSizes = CorSigUncompressData(ptr);  
						while(numSizes > 0) 
						{
							CorSigUncompressData(ptr);      
							--numSizes;
						}
						unsigned numLowBounds = CorSigUncompressData(ptr);      
						while(numLowBounds > 0) 
						{
							CorSigUncompressData(ptr);      
							--numLowBounds;
						}
                    }
                }
                break;

                // Modifiers or depedant types
        case ELEMENT_TYPE_PINNED                :
        case ELEMENT_TYPE_PTR                   :
        case ELEMENT_TYPE_BYREF                 :
        case ELEMENT_TYPE_SZARRAY               :
                // tail recursion optimization
                // ptr = skipType(ptr);
                // break
                goto AGAIN;

        case ELEMENT_TYPE_VAR:
                CorSigUncompressData(ptr);              // bound
                break;

        case ELEMENT_TYPE_FNPTR: 
                {
                    CorSigUncompressData(ptr);                                              // calling convention
                    unsigned argCnt = CorSigUncompressData(ptr);    // arg count
                    ptr = skipType(ptr);                                                    // return type
                    while(argCnt > 0) 
                    {
                        ptr = skipType(ptr);
                        --argCnt;
                    }
                }
                break;

        default:
        case ELEMENT_TYPE_SENTINEL              :
        case ELEMENT_TYPE_END                   :
                _ASSERTE(!"Unknown Type");
                break;
    }
    return(ptr);
}

/**************************************************************************/
static unsigned corCountArgs(BinStr* args) 
{
    unsigned __int8* ptr = args->ptr();
    unsigned __int8* end = &args->ptr()[args->length()];
    unsigned ret = 0;
    while(ptr < end) 
        {
        if (*ptr != ELEMENT_TYPE_SENTINEL) 
                {
            ptr = skipType(ptr);
            ret++;
        }
        else ptr++;
    }
    return(ret);
}

/********************************************************************************/
AsmParse::AsmParse(ReadStream* aIn, Assembler *aAssem) 
{
#ifdef DEBUG_PARSING
    extern int yydebug;
    yydebug = 1;
#endif

    in = aIn;
    assem = aAssem;
    assem->SetErrorReporter((ErrorReporter *)this);

    char* buffBase = new char[IN_READ_SIZE+IN_OVERLAP+1];                // +1 for null termination
    _ASSERTE(buffBase);
	if(buffBase)
	{
		curTok = curPos = endPos = limit = buff = &buffBase[IN_OVERLAP];     // Offset it 
		curLine = 1;
		assem->m_ulCurLine = curLine;
		assem->m_ulCurColumn = 1;

		hstdout = GetStdHandle(STD_OUTPUT_HANDLE);
		hstderr = GetStdHandle(STD_ERROR_HANDLE);

		success = true; 
		_ASSERTE(parser == 0);          // Should only be one parser instance at a time

		// Sort the keywords for fast lookup 
		qsort(keywords, sizeof(keywords) / sizeof(Keywords), sizeof(Keywords), keywordCmp);
		parser = this;
	    //yyparse();
	}
	else
	{
		assem->report->error("Failed to allocate parsing buffer\n");
		delete this;
	}
}

/********************************************************************************/
AsmParse::~AsmParse() 
{
    parser = 0;
    delete [] &buff[-IN_OVERLAP];
}

/**************************************************************************/
DWORD IsItUnicode(CONST LPVOID pBuff, int cb, LPINT lpi)
{
	if(g_bOnUnicode) return IsTextUnicode(pBuff,cb,lpi);
	if(*((WORD*)pBuff) == 0xFEFF)
	{
		if(lpi) *lpi = IS_TEXT_UNICODE_SIGNATURE;
		return 1;
	}
	return 0;
}
/**************************************************************************/
char* AsmParse::fillBuff(char* pos) 
{
	static bool bUnicode = false;
    int iRead,iPutToBuffer,iOrdered;
	static char* readbuff = buff;

    _ASSERTE((buff-IN_OVERLAP) <= pos && pos <= &buff[IN_READ_SIZE]);
    curPos = pos;
    size_t tail = endPos - curPos; // endPos points just past the end of valid data in the buffer
    _ASSERTE(tail <= IN_OVERLAP);
    if(tail) memcpy(buff-tail, curPos, tail);    // Copy any stuff to the begining 
    curPos = buff-tail;
	iOrdered = m_iReadSize;
	if(m_bFirstRead)
	{
		int iOptions = IS_TEXT_UNICODE_UNICODE_MASK;
		m_bFirstRead = false;
		g_uCodePage = CP_ACP;
		if(bUnicode) // leftover fron previous source file
		{
			delete [] readbuff;
			readbuff = buff;
		}
		bUnicode = false;

        memset(readbuff,0,iOrdered);
	    iRead = in->read(readbuff, iOrdered);

		if(IsItUnicode(buff,iRead,&iOptions))
		{
			bUnicode = true;
			g_uCodePage = CP_UTF8;
			if(readbuff = new char[iOrdered+2]) // buffer for reading Unicode chars
			{
				if(iOptions & IS_TEXT_UNICODE_SIGNATURE)
					memcpy(readbuff,buff+2,iRead-2);   // only first time, next time it will be read into new buffer
				else
					memcpy(readbuff,buff,iRead);   // only first time, next time it will be read into new buffer
				printf("Source file is UNICODE\n\n");
			}
			else
				assem->report->error("Failed to allocate read buffer\n");
		}
		else
		{
			m_iReadSize = IN_READ_SIZE;
			if(((buff[0]&0xFF)==0xEF)&&((buff[1]&0xFF)==0xBB)&&((buff[2]&0xFF)==0xBF))
			{
				g_uCodePage = CP_UTF8;
				curPos += 3;
				printf("Source file is UTF-8\n\n");
			}
			else
				printf("Source file is ANSI\n\n");
		}
	}
	else
    {
        memset(readbuff,0,iOrdered);
        iRead = in->read(readbuff, iOrdered);
    }

	if(bUnicode)
	{
		WCHAR* pwc = (WCHAR*)readbuff;
		pwc[iRead/2] = 0;
		memset(buff,0,IN_READ_SIZE);
		WszWideCharToMultiByte(CP_UTF8,0,pwc,-1,(LPSTR)buff,IN_READ_SIZE,NULL,NULL);
		iPutToBuffer = (int)strlen(buff);
	}
	else iPutToBuffer = iRead;

    endPos = buff + iPutToBuffer;
    *endPos = 0;                        // null Terminate the buffer

    limit = endPos; // endPos points just past the end of valid data in the buffer
    if (iRead == iOrdered) 
    {
        limit-=4; // max look-ahead without reloading - 3 (checking for "...")
    }
    return(curPos);
}

/********************************************************************************/
BinStr* AsmParse::MakeSig(unsigned callConv, BinStr* retType, BinStr* args) 
{
    BinStr* ret = new BinStr();
	if(ret)
	{
		//if (retType != 0) 
				ret->insertInt8(callConv); 
		corEmitInt(ret, corCountArgs(args));

		if (retType != 0) 
			{
			ret->append(retType); 
			delete retType;
		}
		ret->append(args); 
	}
	else
		assem->report->error("\nOut of memory!\n");

    delete args;
    return(ret);
}

/********************************************************************************/
BinStr* AsmParse::MakeTypeArray(BinStr* elemType, BinStr* bounds) 
{
    // 'bounds' is a binary buffer, that contains an array of 'struct Bounds' 
    struct Bounds {
        int lowerBound;
        unsigned numElements;
    };

    _ASSERTE(bounds->length() % sizeof(Bounds) == 0);
    unsigned boundsLen = bounds->length() / sizeof(Bounds);
    _ASSERTE(boundsLen > 0);
    Bounds* boundsArr = (Bounds*) bounds->ptr();

    BinStr* ret = new BinStr();

    ret->appendInt8(ELEMENT_TYPE_ARRAY);
    ret->append(elemType);
    corEmitInt(ret, boundsLen);                     // emit the rank

    unsigned lowerBoundsDefined = 0;
    unsigned numElementsDefined = 0;
    unsigned i;
    for(i=0; i < boundsLen; i++) 
    {
        if(boundsArr[i].lowerBound < 0x7FFFFFFF) lowerBoundsDefined = i+1;
        else boundsArr[i].lowerBound = 0;

        if(boundsArr[i].numElements < 0x7FFFFFFF) numElementsDefined = i+1;
        else boundsArr[i].numElements = 0;
    }

    corEmitInt(ret, numElementsDefined);                    // emit number of bounds

    for(i=0; i < numElementsDefined; i++) 
    {
        _ASSERTE (boundsArr[i].numElements >= 0);               // enforced at rule time
        corEmitInt(ret, boundsArr[i].numElements);

    }

    corEmitInt(ret, lowerBoundsDefined);    // emit number of lower bounds
    for(i=0; i < lowerBoundsDefined; i++)
	{
		unsigned cnt = CorSigCompressSignedInt(boundsArr[i].lowerBound, ret->getBuff(5));
		ret->remove(5 - cnt);
	}
    delete elemType;
    delete bounds;
    return(ret);
}

/********************************************************************************/
BinStr* AsmParse::MakeTypeClass(CorElementType kind, char* name) 
{

    BinStr* ret = new BinStr();
    _ASSERTE(kind == ELEMENT_TYPE_CLASS || kind == ELEMENT_TYPE_VALUETYPE ||
                     kind == ELEMENT_TYPE_CMOD_REQD || kind == ELEMENT_TYPE_CMOD_OPT);
    ret->appendInt8(kind);
    mdToken tk = PASM->ResolveClassRef(name,NULL);
    unsigned cnt = CorSigCompressToken(tk, ret->getBuff(5));
    ret->remove(5 - cnt);
    delete [] name;
    return(ret);
}
/**************************************************************************/
void PrintANSILine(FILE* pF, char* sz)
{
	WCHAR wz[4096];
	if(g_uCodePage != CP_ACP)
	{
		memset(wz,0,sizeof(WCHAR)*4096);
		WszMultiByteToWideChar(g_uCodePage,0,sz,-1,wz,4096);

		memset(sz,0,4096);
		WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,4096,NULL,NULL);
	}
	fprintf(pF,"%s",sz);
}
/**************************************************************************/
void AsmParse::error(char* fmt, ...) 
{
	char sz[4096], *psz=&sz[0];
    success = false;
    va_list args;
    va_start(args, fmt);

    if(in) psz+=sprintf(psz, "%s(%d) : ", in->name(), curLine);
    psz+=sprintf(psz, "error -- ");
    vsprintf(psz, fmt, args);
	PrintANSILine(stderr,sz);
}

/**************************************************************************/
void AsmParse::warn(char* fmt, ...) 
{
	char sz[4096], *psz=&sz[0];
    va_list args;
    va_start(args, fmt);

    if(in) psz+=sprintf(psz, "%s(%d) : ", in->name(), curLine);
    psz+=sprintf(psz, "warning -- ");
    vsprintf(psz, fmt, args);
	PrintANSILine(stderr,sz);
}
/**************************************************************************/
void AsmParse::msg(char* fmt, ...) 
{
	char sz[4096];
    va_list args;
    va_start(args, fmt);

    vsprintf(sz, fmt, args);
	PrintANSILine(stdout,sz);
}


/**************************************************************************/
/*
#include <stdio.h>

int main(int argc, char* argv[]) {
    printf ("Beginning\n");
    if (argc != 2)
        return -1;

    FileReadStream in(argv[1]);
    if (!in) {
        printf("Could not open %s\n", argv[1]);
        return(-1);
        }

    Assembler assem;
    AsmParse parser(&in, &assem);
    printf ("Done\n");
    return (0);
}
*/

 // TODO remove when we use MS_YACC
//#undef __cplusplus
YYSTATIC YYCONST short yyexca[] = {
#if !(YYOPTTIME)
-1, 1,
#endif
	0, -1,
	-2, 0,
#if !(YYOPTTIME)
-1, 327,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 500,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 521,
#endif
	268, 346,
	46, 346,
	47, 346,
	-2, 327,
#if !(YYOPTTIME)
-1, 598,
#endif
	268, 346,
	46, 346,
	47, 346,
	-2, 108,
#if !(YYOPTTIME)
-1, 600,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 609,
#endif
	123, 114,
	-2, 346,
#if !(YYOPTTIME)
-1, 633,
#endif
	40, 188,
	-2, 352,
#if !(YYOPTTIME)
-1, 637,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 786,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 795,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 875,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 879,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 881,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 950,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 961,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 981,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1028,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1030,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1032,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1034,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1036,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1038,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1040,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1068,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1097,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1099,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1101,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1103,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1105,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1107,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1109,
#endif
	41, 337,
	-2, 189,
#if !(YYOPTTIME)
-1, 1121,
#endif
	41, 337,
	-2, 189,

};

# define YYNPROD 609
#if YYOPTTIME
YYSTATIC YYCONST yyexind_t yyexcaind[] = {
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    4,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    8,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   12,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   20,    0,
   28,    0,    0,    0,    0,    0,    0,    0,    0,   32,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   36,    0,    0,    0,   40,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   44,    0,    0,    0,
    0,    0,    0,    0,    0,   48,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   52,    0,    0,    0,   56,
    0,   60,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   64,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   68,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   72,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   76,    0,
   80,    0,   84,    0,   88,    0,   92,    0,   96,    0,
  100,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  104,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  108,    0,  112,
    0,  116,    0,  120,    0,  124,    0,  128,    0,  132,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  136
};
#endif
# define YYLAST 2333

YYSTATIC YYCONST short YYFARDATA YYACT[] = {
  495,  579,  779, 1014,  269,  584,  682,  577,   75,   83,
  402,  862,  282,  262,  525,  497,  561,  142,   56,   23,
  350,  622,  890,    6,    5,  259,  141,  930,   10,  174,
  140,  127,   17,  927,  811,   58,  858,   54,   62,  137,
  856,    7,  111,  857,    3,   54,  261,  110,   92,  120,
  121,  752,  507,  547,  812,  287,  582,   65,   64,   90,
   66,   65,   64,   61,   66,  532,   65,   64,  397,   66,
  177,  390,  223,  327,  387,  200,   63,  385,   65,   64,
  928,   66,  143,  403,   18,  227,  749,  770,  919,  920,
  917,  918,  778,   65,   64,  124,   66,  334,  681,  522,
  229,  147,  248,  454,  254,  199,  257,  455,  726,  727,
  867,  868,   65,   64,  200,   66,  782,  289,  781,  200,
  454,  531,  405,  530,  455,  139,  342,   48,  340,  344,
  343,  117,  374,  118,  170,  392,  725,  179,  550,  462,
  119,  506,  363,  454,  527,  319,   23,  455,  594,  813,
  258,  310,  306,  498,  313,   10,  453,  114,  312,   17,
  291,  739,   82,  361,   53,   55,  355,  311,    7,  289,
  362,  115,  307,  453, 1090, 1039,   87,   88,  232,  234,
  236,  238,  240,  762, 1037,  552,  553,  554,  623,  624,
  348,  351,  252,   59,  352,  294,  453,  295,  296,  297,
  301,  176,  332,  377, 1035, 1033,  359, 1031,  353,  354,
  314,   18,  412,  416,  222, 1029,  360,  555,  556,  557,
   85,  371, 1027,   65,   64,  878,   66,  352,   54,  346,
  923,  244,  585,  544,  357,  785,   65,   64,  748,   66,
  365,  353,  354,  634,  243,  372,  607,  471,  470,  440,
   93,  599,  442,  472,  503,  383,  383,  396,  401,  661,
  662,  663,  591,  178,   54,   59,  449,  452,  419,  443,
  582,  728,  730,  451,  729,  877,  325,  751,  326,  117,
  921,  118,   54,  575,  753,  481,  585,  473,  119,  460,
  331,  255,  256,  463,  246,  370,  363,  345,  347,  406,
  407,  408,  356,  438,   65,  114,  614,   66,  366,  508,
  249,  250,  251,  373,   65,   64,  474,   66,  320,  115,
   42,   27,   43,  122,   65,   65,  536,   66,   66,   54,
  321,  409,  410,  411,  635,  286,  322,  477,  247,  435,
   36,   45,   65,   64,   74,   66,  613,  478,  935,  931,
  932,  933,  934,  499,  395,  378,  490,   31,   32,   41,
   38,  487,  315,  316,  112,   65,  512,  113,   66,  414,
  413,  170,  523,  486,  491,  441,  415,   38,  654,  485,
  444,   52,  445,  535,  446,   51,   38,  399,  323,  533,
  400,  448,  537,   50,  513,   49,   38,  539,  390,  540,
  384,  391,  395,  380,  381,  519,  394,  543,  456,  457,
  458,  524,  546,  464,   47,  520,   46,  968,  514,  318,
  560,   36,   45,  147,  452,  456,  457,  458,  665,  494,
  403,  551, 1069,  505,  484,  201,  521,  623,  624,  565,
  576,   38,   54, 1020,   38,  526,  585,  139,  456,  457,
  458, 1019,   54,  376,  394,  384,  324, 1017,  380,  381,
  488,  489,  974,  200,  558,  581,  766,  967,  328,  764,
  765,  800,  589,  349,  590,  501,  799,  548,  504,  509,
  510,  511,  292,  293,   65,   64,  515,   66,  592,   31,
   32,   41,   38,  451,  798,  200,  562,  363,  929,  245,
  367,  619,  818,  814,  815,  816,  817,  615,   65,  564,
  874,   66,  593,   54,  528,  200,  625,  603,  595,  797,
  606,  738,  461,  596,   54,  534,  358,  363,  776,  388,
  364,  461,  633,  597,  976,  977,  978,  147,  363,  626,
  545,  632,  742,  454,  620,  660,  618,  744,  608,  466,
  467,  468,  469,  630,  598,  417,  200,  653,  656,  568,
  655,  139,  736,  447,  755,  756,  757,  758,  715,  609,
  737,  625,  434,  239,  926,  631,  658,  666,   73,  925,
  659,   81,   80,   79,   78,  627,   76,   77,   82,  731,
   31,   32,   41,   38,  735,  237,  453,  230,  586,  333,
  235,  750,  330,  580,  743,  233,   86,  641,   69,  633,
  117,  454,  118,  740,  741,  455,   89,  966,  747,  119,
  625,  319,  761,  769,  230,  586,  522,  310,  306,  771,
  313,  759,  768,  774,  312,  780,  114,  465,  788,  745,
 1000,  808,  542,  311,  734,  541,  230,  621,  307,  538,
  115,  230,  746,  628,  789,  790,  230,  476,  231,  773,
 1024,  629,  965,  808,  453,  807,  808,  801,  719,  228,
  720,  721,  722,  723,  724,  482,  642,  643,  454,  459,
  637, 1132,  455,  805,  303,  772,  314,  760,  767,  396,
  809,   65,   64,  363,   66,  775,   54,  285,   59,  352,
   65,   64,  125,   66,  664, 1023, 1022,  253,  864,  230,
 1013,  787,  809,  353,  354,  809,  526,  526,  911,  804,
  230,  803,  645,   24,   25,   42,   27,   43,  502,  329,
  200,  453,  794,    1,  950,  733,  865,   94,  867,  868,
  200,  860,  522, 1113,  870,   36,   45,  876,  640, 1071,
  869,  522, 1070,  522,  970, 1133,  735,  522,  806,  718,
  866,  522,   31,   32,   41,   38,  639,  617,  601,   44,
   30,  436,  300,  522,  225,   21, 1134, 1130,   33, 1121,
  832,  128,  903,  126, 1129,   34,  891,  909, 1128,  904,
  791, 1127,   35, 1126, 1125, 1124,  914, 1112,  625,  792,
 1110,  715,  859,  915,  912, 1108, 1106,  908, 1104, 1102,
 1100, 1098,  924, 1096, 1095, 1094, 1075, 1054,  916, 1053,
  913, 1052, 1051, 1050, 1049,  880,   95,   96,   97,   98,
   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,
  109,   19,   20, 1048,   22, 1047, 1046, 1045,  456,  457,
  458, 1044, 1042, 1061, 1025,  893, 1021, 1011,  906,  983,
  982,  612,  980,  674,  964,  675,  676,  677,  962, 1057,
  910,  882,  873,  872,  793,  784,  938, 1066,  783,  863,
  940,  777,  941,  586,  871,  732,  650,  649,  869,  647,
  644,  625,  638,  636, 1067,  616,  573,  715,  572,  951,
  939,  571,  570,  569,  669,  670,  671,  567,  566,  518,
  475,  439,   74,  299,  960, 1109,  456,  457,  458, 1058,
 1059, 1060, 1062, 1063, 1064, 1065,  298,  907,  284,  973,
  942,  943,  944,  945,  946,  947,  948,  242, 1107,  398,
 1105, 1103, 1101, 1099, 1097,  668,  672,  673, 1068,  678,
 1040,  999,  679, 1038,  922,  633,  633,  633,  633,  633,
  633,  633, 1012, 1036,  985,  987,  989,  991,  993,  995,
  997, 1010, 1018, 1001, 1003,  802, 1034, 1032,  625, 1030,
 1028,  981, 1026,  456,  457,  458,  961, 1015, 1002, 1004,
 1005, 1006, 1007, 1008, 1009,  842,  998,   71,  984,  986,
  988,  990,  992,  994,  996,  959,  393,  958,  823,  824,
  957,  831,  841,  825,  826,  827,  828,  956,  829,  830,
  955,  954,  170,  953,  602,  952,  937,  936,  892, 1077,
  454, 1079,  386, 1081,  455, 1083,  881, 1085,  879, 1087,
  625, 1089,  625,  875,  625, 1091,  625,  810,  625, 1076,
  625, 1078,  625, 1080, 1041, 1082,  963, 1084,  796, 1086,
  795, 1088,  786,  652,  651,  648,  646,  600,  969, 1092,
  971,  972, 1093,  588,  587,  563,  517, 1043, 1056,  516,
  500,  975,  979,  453,  483,  450,  437,  418,  368,  170,
  302,  529,  241,  226,  389,  382,  379,  375, 1114,  224,
 1115,  123, 1116,  625, 1117,   70, 1118,   28, 1119,  341,
 1120,  339, 1111, 1016,  338, 1123, 1122,  337,  336,  168,
  335,  149, 1131,  883,  884,  885,  886,  167,   72,  138,
  132,  130,  887,  888,  889,  134,   26,  763,   24,   25,
   42,   27,   43,  754,  317,  605,   73,  309,  604,   81,
   80,   79,   78,  308,   76,   77,   82,  305, 1055,   65,
   36,   45,   66,  657,  549,  404,   29, 1072, 1073, 1074,
   16,  175,   15,   14,  173,   13,  172,   31,   32,   41,
   38,   12,   11,    9,   44,   30,    8,  170,    4,  129,
   21,    2,  164,   33,  156,   91,   57,   37,  578,  493,
   34,  492,  221,  304,   67,  821,  822,   35,  833,  834,
  835,   60,  836,  837,  861,  894,  838,  839,   84,  840,
  369,  674,  583,  675,  676,  677,   65,  496,   68,   66,
  819,  574,  288,  820,  843,  844,  845,  846,  847,  848,
  849,  850,  851,  852,  853,  854,  855,   40,   39,  116,
 1061,  680,   65,   64,    0,   66,   19,   20,  949,   22,
    0,    0,  669,  670,  671,    0, 1057,    0,    0,    0,
    0,    0,    0,    0, 1066,    0,  151,  152,  153,  154,
  155,  157,  158,  159,  160,  161,  162,  163,  169,  165,
  166, 1067,    0,    0,    0,   43,  131,  171,  133,  150,
  135,  136,    0,  668,  672,  673,    0,  678,    0,    0,
  679,    0,    0,   36,   45,    0, 1058, 1059, 1060, 1062,
 1063, 1064, 1065,    0,   65,  268,    0,   66,    0,    0,
   31,   32,   41,   38,    0,  456,  457,  458,    0,    0,
    0,  145,    0,  151,  152,  153,  154,  155,  157,  158,
  159,  160,  161,  162,  163,  169,  165,  166,    0,    0,
    0,  144,   43,  131,  171,  133,  150,  135,  136,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   36,   45,    0,    0,    0,    0,    0,    0,  667,    0,
    0,  148,  146,    0,    0,    0,    0,   31,   32,   41,
   38,    0,    0,    0,    0,    0,  696,    0,  145,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  688,
  689,    0,  697,  710,  690,  691,  692,  693,  144,  694,
  695,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  151,  152,  153,  154,  155,  157,  158,  159,  160,
  161,  162,  163,  169,  165,  166,    0,    0,  148,  146,
   43,  131,  171,  133,  150,  135,  136,    0,    0,  708,
  320,  711,   42,   27,   43,    0,    0,  713,   36,   45,
    0,    0,  321,    0,    0,    0,    0,    0,  322,    0,
  283,    0,   36,   45,    0,   31,   32,   41,   38,    0,
    0,    0,    0,    0,    0,    0,  145,    0,    0,   31,
   32,   41,   38,    0,  315,  316,    0,    0,    0,  268,
    0,  716,    0,  363,  454,    0,  144,    0,  455,    0,
    0,    0,  902,  900,    0,    0,  901,  899,  898,  897,
  323,  895,  896,   82,    0,    0,  905,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  148,  146,    0,    0,
    0,    0,  272,  273,  271,  280,    0,  274,  275,  276,
  277,  318,  278,  279,  268,  264,  265,  480,    0,  454,
    0,    0,    0,  744,    0,  263,  270,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  266,  267,  281,    0,  426,  420,  421,  422,  423,
    0,    0,    0,  683,    0,  684,  685,  686,  687,  698,
  699,  700,  714,  701,  702,  703,  704,  705,  706,  707,
  709,  712,  480,  283,  674,  717,  675,  676,  677,  428,
  429,  430,  431,   65,    0,  425,   66,    0,    0,  432,
  433,  424,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  268,    0,    0,    0,    0,  454,    0,    0,    0,
  455,    0,    0,    0,    0,  669,  670,  671,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  182,    0,    0,    0,  197,    0,  180,  181,
    0,    0,    0,  184,  185,  195,  186,  187,  188,  189,
    0,  190,  191,  192,  193,  183,  668,  672,  673,  480,
  678,  196,    0,  679,    0,    0,    0,    0,    0,  194,
    0,    0,    0,    0,    0,    0,  198,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   65,   64,    0,   66,
    0,    0,    0,    0,    0,  427,  272,  273,  271,  280,
    0,  274,  275,  276,  277,  268,  278,  279,    0,  264,
  265,    0,    0,    0,    0,    0,    0,    0,    0,  263,
  270,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  266,  267,  281,    0,    0,
    0,   65,   64,    0,   66,    0,    0,    0,    0,    0,
    0,  272,  273,  271,  280,    0,  274,  275,  276,  277,
    0,  278,  279,  260,  264,  265,    0,  283,    0,  456,
  457,  458,    0,    0,  263,  270,    0,    0,    0,    0,
    0,  623,  624,    0,  268,    0,    0,    0,    0,  454,
  266,  267,  281,  455,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  283,    0,  456,  457,  458,  268,   65,   64,
    0,   66,    0,    0,    0,    0,  623,  624,  272,  273,
  271,  280,  480,  274,  275,  276,  277,    0,  278,  279,
    0,  264,  265,    0,    0,    0,    0,    0,    0,    0,
    0,  263,  270,  117,    0,  118,    0,    0,    0,    0,
    0,    0,  119,    0,    0,    0,    0,  266,  267,  281,
  268,    0,    0,    0,    0,  260,    0,    0,    0,  114,
  207,  202,  203,  204,  205,  206,    0,    0,    0,    0,
  209,    0,    0,  115,    0,    0,    0,    0,    0,  283,
  208,  456,  457,  458,  218,    0,  216,    0,    0,    0,
    0,    0,  268,  479,  210,  211,  212,  213,  214,  215,
  217,  220,   65,   64,    0,   66,    0,  219,  260,    0,
    0,    0,  272,  273,  271,  280,    0,  274,  275,  276,
  277,    0,  278,  279,    0,  264,  265,    0,    0,    0,
    0,    0,    0,    0,  268,  263,  270,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  559,  266,  267,  281,    0,  611,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   65,   64,  283,   66,    0,    0,    0,    0,    0,
    0,  272,  273,  271,  280,  610,  274,  275,  276,  277,
    0,  278,  279,    0,  264,  265,    0,    0,    0,    0,
    0,    0,    0,    0,  263,  270,    0,    0,    0,    0,
    0,    0,    0,    0,   65,   64,    0,   66,    0,    0,
  266,  267,  281,    0,  272,  273,  271,  280,    0,  274,
  275,  276,  277,    0,  278,  279,    0,  264,  265,    0,
    0,    0,    0,    0,    0,    0,    0,  263,  270,    0,
    0,    0,  283,    0,  456,  457,  458,    0,    0,    0,
    0,    0,    0,  266,  267,  281,    0,   65,   64,    0,
   66,    0,    0,    0,    0,    0,    0,  272,  273,  271,
  280,    0,  274,  275,  276,  277,    0,  278,  279,    0,
  264,  265,    0,    0,    0,  283,  290,    0,    0,    0,
  263,  270,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  266,  267,  281,  272,
  273,  271,  280,    0,  274,  275,  276,  277,    0,  278,
  279,    0,  264,  265,    0,    0,    0,    0,    0,    0,
    0,    0,  263,  270,    0,    0,    0,    0,  283,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  266,  267,
  281,  272,  273,  271,  280,    0,  274,  275,  276,  277,
    0,  278,  279,    0,  264,  265,    0,    0,    0,    0,
    0,    0,    0,    0,  263,  270,    0,    0,    0,    0,
  283,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  266,  267,  281,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  283
};

YYSTATIC YYCONST short YYFARDATA YYPACT[] = {
-1000,  746,-1000,  293,  291,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,  272,  270,  262,  258,-1000,-1000,-1000,   -1,
   -1, -494,    0,-1000, -390,  224,-1000,  517,  874,  -47,
  515,   -1,   -1, -394,-1000, -203,  410,  -47,  324,  -47,
  -47,   60,-1000, -211,  641,  410,-1000,-1000, 1064,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,   -1, -182,-1000,-1000,
 1383,-1000,  684,-1000,-1000,-1000,-1000, 1637,-1000,   -1,
-1000,  306,-1000,  732, 1053,  -47,  629,  618,  565,  560,
  555,  533, 1052,  896,  -23,-1000,   -1,  236,   76, -148,
-1000,  -24,  684,  224, 1907,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
  887,  636, 1854, 1991, -155, -155,-1000,-1000,-1000,  -92,
  885,  872,  728,   44,-1000, 1050,  623, 1078,  331,-1000,
-1000,   -1,-1000,   -1,   33,-1000,-1000,-1000,-1000,  671,
-1000,-1000,-1000,-1000,  511,   -1, 1907,-1000,  508, -171,
-1000,-1000,   64,   -1,    0,  433,  -47,   64, -155, 1991,
 1907, -120, -155,   64, 1854, 1048,-1000,-1000,  248,-1000,
-1000,-1000,    7,  -48,   10,  -57,-1000,   29,-1000, -180,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,  -16,-1000,-1000,-1000,   54,
  224,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
 1047, 1292,  479,  214,  727, 1046,   44,  870,  -39,-1000,
   -1,  -39,-1000,    0,-1000,   -1,-1000,   -1,-1000,   -1,
-1000,-1000,-1000,-1000,  470,-1000,   -1,-1000,  684,-1000,
-1000,-1000,-1000, -148,  684,-1000,-1000,  684, 1045,-1000,
 -194,  573,  632,  440,-1000,-1000, -154,  440,   -1, -155,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
  274,  -26,  684,-1000,-1000,  276,  869,-1000,-1000, -155,
 1991, 1628,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
   22,  614,-1000, 1044,-1000,-1000,-1000,  256,  250,  238,
-1000,-1000,-1000,-1000,-1000,   -1,   -1,  233, 1907,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, -116, 1040,-1000,
   -1,  670,  -14,   -1,-1000, -171,   11,   11,   11,   11,
  440,  248,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000, 1039, 1036,  868,-1000,-1000, 1991, 1811,
-1000,  730,  -47,-1000, 1991,-1000,-1000,-1000,   64,   -1,
  966,-1000, -181, -183,-1000,-1000, -385,-1000,-1000,  -47,
   -1,  265,  -47,-1000,  588,-1000,-1000,  -47,-1000,  -47,
  584,  581,-1000,-1000,  224, -220,-1000,-1000,-1000,  224,
 -400,-1000, -375,-1000, -165,  440,-1000,-1000,-1000,-1000,
-1000,-1000,  684,-1000,-1000, -130,  684, 1949,   34,  105,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, 1035,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,  306,   34,  867,-1000,
  866,  466,  862,  861,  860,  857,  855,-1000,   20,   68,
   34,  510,  224,  177,-1000,-1000,-1000, 1034, 1033,  224,
-1000, -199,  440,-1000,-1000, 1991,-1000,-1000,-1000,-1000,
-1000, -126,-1000,  730,-1000, -155, 1991, 1811,  -17, 1027,
  -37,  724,-1000,-1000,  899,-1000,-1000,-1000,-1000,-1000,
-1000,  -22, 1732,   -7,   54,  854,  723,-1000,-1000, 1949,
 -116,  451,   -1, -167,  446,-1000,-1000,-1000,   64,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,   -1,    0,-1000, 1486,
  -25,-1000,   72,  852,  640,  851,  722,  704,-1000,-1000,
   44,   -1,   -1,  849,  664,  730, 1026,  848, 1025,  846,
  845, 1024, 1023,  684,  224,-1000,   73,  224,  -47,-1000,
  440,-1000,-1000,-1000,-1000,-1000,-1000,-1000,   82, -228,
   56, 1347, -207, 1149,-1000,  718,-1000,  506,-1000,  506,
  506,  506,  506,  506, -169,-1000,  224,  844,  691,  583,
  224,  469,-1000,  477,-1000,-1000, -108,  440,  440,  684,
  449,  224,-1000,  505,-1000,  578, 1541,  -30,-1000, -269,
 -116,   14,-1000,  -74,  159,   58,  -38, -167,   44,-1000,
-1000,-1000, 1991,-1000,-1000,  684,-1000, -116,   65,  840,
 -280,-1000,-1000,-1000,-1000,  684,  574, -186, -188,  837,
  834,  -33, 1022,  684,   44,-1000,-1000, -116,-1000,   64,
   64,-1000,-1000,-1000,-1000,   -1,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,  684,   -1,  684,  833,  688,-1000, 1020,
 1018,  426,  401,  383,  378,   34,  934,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  663,  661,
  574,   44,  624, 1007, -431, -122,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,  228,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  738,
-1000, -440,-1000, -429,-1000,-1000, -448,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,   44,-1000,-1000,-1000,-1000,
-1000,  684,-1000,   34,  431,  632,  224,-1000,   17,   -1,
  832,  831,  224,  417, 1003,  235,  -43,  998,   44,  996,
  830,-1000,-1000,-1000,-1000, -155, -155, -155, -155,-1000,
-1000,-1000,-1000,-1000, -155, -155, -155,-1000,-1000,-1000,
-1000, -472,-1000,  992,-1000,-1000,  988,-1000,   44,-1000,
 1261,   44,   -1,-1000,-1000, -167, -116,-1000,  829,-1000,
-1000,  660,-1000, -318,  440, -116, 1149,-1000,-1000,-1000,
-1000,  730,-1000, -284, -286,-1000,-1000,-1000,-1000,  187,
   34,  488,  483,-1000,-1000,-1000,-1000,-1000,-1000,  -11,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,   74,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,  987,  730,  986,-1000,-1000,  632,
-1000,-1000,-1000,-1000,  224, -116,  730,-1000, -167, -116,
-1000, -116,-1000, 1991, 1991, 1991, 1991, 1991, 1991, 1991,
 -155,  694, 1149,-1000,-1000,  985,  983,  981,  980,  977,
  970,  967,  965,  730,  -47,-1000,-1000,-1000,  946,  827,
-1000,   -1,-1000,-1000,  823,  621,  576,-1000,-1000,-1000,
-1000,-1000,  374,   -1,  710,   -1,   -1,   34,  369,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,   -1,  259,  821,  941,
  819,  818, 1486, 1486, 1486, 1486, 1486, 1486, 1486, 1991,
 -116,  599,  -72,  -72,    0,    0,    0,    0,    0, -197,
  816, -116,-1000,  652,-1000, -167,-1000,-1000,   -1,  364,
   34,  358,  350,  730,-1000,  815,  648,  647,  602,  813,
-1000, -116,-1000,-1000,  -46,  940,  -53,  939,  -61,  937,
  -63,  936,  -64,  923,  -84,  913,  -93,  910, 1811,  811,
   44,  810,  806,  805,  804,  802,  783,  782,  781,  780,
  778,-1000,  776,   -1,  955,  908,  339,-1000,  708,-1000,
-1000,-1000,   -1,   -1,   -1,-1000,  775, -167, -116, -167,
 -116, -167, -116, -167, -116, -167, -116, -167, -116, -167,
 -116,  -94,  574,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000, -116,-1000,
   34,-1000,  774,  773,  772,-1000,  904,  770,  903,  769,
  902,  768,  901,  767,  900,  765,  898,  764,  875,  759,
 -167,-1000,  756,  699,-1000,-1000,-1000, -116,-1000, -116,
-1000, -116,-1000, -116,-1000, -116,-1000, -116,-1000, -116,
-1000,  739,-1000,   34,  754,  753,  752,  750,  747,  743,
  736, -116,  558,  714,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,  735,-1000,-1000,-1000
};

YYSTATIC YYCONST short YYFARDATA YYPGO[] = {
    0,   12,   76,   25,   21, 1251,   13,   14,  367, 1249,
  144, 1248, 1247,   42,  335, 1232, 1231,  353,  100, 1230,
 1228,   11,   20,   35,    0, 1227,   15,   46,    5, 1222,
 1220,   55,    9, 1218, 1215,    6,    2,    1, 1214, 1211,
 1204, 1202,    3, 1201, 1199,   16,    7, 1198,  737, 1197,
 1196,   10,  616,  105, 1195, 1194, 1192,  733, 1191,   44,
   31, 1188,   24,  127,   23,   39, 1186, 1183,   26, 1182,
 1181, 1176, 1175, 1174, 1173,   29, 1172, 1171, 1170,   30,
   82,   17, 1166, 1165, 1164, 1163, 1157, 1153, 1148, 1147,
 1145, 1144,    4, 1143, 1137, 1136, 1135, 1131, 1130, 1129,
   52, 1127, 1121,   97, 1120, 1119, 1118,  141, 1117, 1114,
 1111, 1109, 1107, 1105, 1101,   72, 1099,    8,   74, 1097,
  355, 1096, 1095, 1094, 1032, 1006,  939
};
YYSTATIC YYCONST yyr_t YYFARDATA YYR1[]={

   0,  57,  57,  58,  58,  58,  58,  58,  58,  58,
  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,
  58,  58,  58,  58,  37,  37,  81,  81,  81,  80,
  80,  80,  80,  80,  80,  78,  78,  78,  67,  16,
  16,  16,  16,  16,  16,  66,  82,  61,  59,  39,
  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,
  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,
  39,  39,  39,  39,  83,  83,  84,  84,  85,  85,
  60,  60,  86,  86,  86,  86,  86,  86,  86,  86,
  86,  86,  86,  86,  86,  86,  64,   5,   5,  36,
  36,  20,  20,  11,  12,  15,  15,  15,  15,  13,
  13,  14,  14,  87,  87,  43,  43,  43,  88,  88,
  93,  93,  93,  93,  93,  93,  93,  93,  93,  93,
  93,  89,  44,  44,  44,  90,  90,  94,  94,  94,
  94,  94,  94,  94,  94,  94,  95,  62,  62,  40,
  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,
  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,
  40,  45,  45,  45,  45,  45,  45,  45,  45,  45,
  45,  45,  45,  45,  45,  45,   4,   4,   4,  17,
  17,  17,  17,  17,  41,  41,  41,  41,  41,  41,
  41,  41,  41,  41,  41,  41,  41,  41,  41,  42,
  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,
  42,  96,  97,  97,  97,  97,  97,  97,  97,  97,
  97,  97,  97,  97,  97,  97,  97,  97,  97,  97,
  97,  97, 100, 101,  98, 103, 103, 102, 102, 102,
 105, 104, 104, 104, 104, 108, 108, 108, 111, 106,
 109, 110, 107, 107, 107,  63,  63,  65, 112, 112,
 114, 114, 113, 113, 115, 115,  18,  18, 116, 116,
 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
 116, 116, 116,  34,  34,  34,  34,  34,  34,  34,
  34,  34,  34,  34,  34,  34, 117,  32,  32,  33,
  33,  55,  56,  92,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  24,  24,  25,
  25,  26,  26,  26,  26,  26,   1,   1,   1,   3,
   3,   3,   6,   6,  31,  31,  31,  31,   8,   8,
   8,   9,   9,   9,   9,   9,   9,   9,  35,  35,
  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,
  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,
  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,
  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,
  35,  35,  35,  35,  35,  35,  35,  19,  19,  19,
  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
  19,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,
  27,  27,  29,  29,  28,  28,  28,  28,  28,   7,
   7,   7,   7,   7,   2,   2,  30,  30,  10,  23,
  22,  22,  22,  79,  79,  79,  49,  46,  46,  47,
  21,  21,  38,  38,  38,  38,  38,  38,  38,  38,
  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,
  48,  48,  48,  48,  48,  68,  68,  68,  68,  68,
  69,  69,  50,  50,  51,  51, 118,  70,  52,  52,
  52,  52,  52,  71,  71, 119, 119, 119, 120, 120,
 120, 120, 120, 121, 123, 122,  72,  72,  73,  73,
 124, 124, 124,  74,  91,  53,  53,  53,  53,  53,
  53,  53,  53,  53,  75,  75, 125, 125, 125, 125,
  76,  54,  54,  54,  77,  77, 126, 126, 126 };
YYSTATIC YYCONST yyr_t YYFARDATA YYR2[]={

   0,   0,   2,   4,   4,   3,   1,   1,   1,   1,
   1,   1,   4,   4,   4,   4,   1,   1,   1,   2,
   2,   3,   2,   1,   1,   3,   2,   4,   6,   2,
   4,   3,   5,   7,   3,   1,   2,   3,   7,   0,
   2,   2,   2,   2,   2,   3,   3,   2,   5,   0,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
   2,   2,   2,   2,   2,   3,   3,   3,   3,   3,
   3,   2,   2,   2,   0,   2,   0,   2,   3,   1,
   0,   2,   3,   4,   4,   4,   1,   1,   1,   1,
   1,   2,   2,   4,  13,   1,   7,   0,   2,   0,
   2,   0,   3,   4,   7,   9,   7,   5,   3,   8,
   6,   1,   1,   4,   3,   0,   2,   2,   0,   2,
   9,   7,   9,   7,   9,   7,   9,   7,   1,   1,
   1,   9,   0,   2,   2,   0,   2,   9,   7,   9,
   7,   9,   7,   1,   1,   1,   1,  11,  15,   0,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
   2,   2,   2,   2,   2,   2,   2,   2,   8,   6,
   5,   0,   2,   2,   2,   2,   2,   2,   2,   2,
   2,   2,   4,   4,   4,   4,   1,   1,   1,   0,
   4,   4,   4,   4,   0,   2,   2,   2,   2,   2,
   2,   2,   5,   2,   2,   2,   2,   2,   2,   0,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
   2,   1,   2,   1,   2,   4,   5,   1,   1,   1,
   1,   2,   1,   1,   1,   1,   4,   6,   4,   4,
   1,   5,   3,   1,   2,   2,   1,   2,   4,   4,
   1,   2,   2,   2,   2,   2,   2,   2,   1,   2,
   1,   1,   1,   4,   4,   0,   2,   2,   4,   2,
   0,   1,   3,   1,   3,   1,   0,   3,   5,   4,
   3,   5,   5,   5,   5,   5,   5,   2,   2,   2,
   2,   2,   2,   4,   4,   4,   4,   4,   4,   4,
   4,   4,   4,   1,   3,   1,   2,   0,   1,   1,
   2,   2,   1,   1,   1,   2,   2,   2,   2,   2,
   2,   3,   2,   2,   9,   7,   5,   3,   2,   2,
   4,   6,   2,   2,   2,   4,   2,   0,   1,   1,
   3,   1,   2,   3,   6,   7,   1,   1,   3,   4,
   5,   1,   1,   3,   1,   3,   4,   1,   2,   2,
   1,   0,   1,   1,   2,   2,   2,   2,   0,  10,
   6,   5,   5,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
   3,   4,   6,   5,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   2,   4,   1,   2,   2,
   1,   2,   1,   2,   1,   2,   1,   0,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,
   2,   2,   2,   1,   3,   2,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   2,   1,   1,   3,   2,   3,   4,   2,   2,
   2,   5,   5,   2,   7,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
   3,   2,   1,   3,   0,   1,   1,   3,   2,   0,
   3,   3,   1,   1,   1,   1,   0,   2,   1,   1,
   1,   4,   4,   6,   3,   3,   4,   1,   3,   3,
   1,   1,   1,   1,   4,   1,   6,   6,   6,   4,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   3,   2,   5,   4,   3,
   8,   4,   0,   2,   0,   1,   3,   3,   0,   2,
   2,   2,   2,   0,   2,   3,   1,   1,   3,   8,
   2,   3,   1,   3,   3,   3,   4,   6,   0,   2,
   3,   1,   3,   4,   3,   0,   2,   2,   3,   3,
   3,   3,   3,   3,   0,   2,   2,   3,   2,   1,
   3,   0,   2,   2,   0,   2,   4,   3,   1 };
YYSTATIC YYCONST short YYFARDATA YYCHK[]={

-1000, -57, -58, -59, -61, -62, -64, -65, -66, -67,
 -68, -69, -70, -72, -74, -76, -78, -79, -80, 510,
 511, 444, 513, -81, 392, 393, -95, 395,-112, -82,
 439, 431, 432, 447, 454, 461, 414, -49, 434, -11,
 -12, 433, 394, 396, 438, 415, 123, 123, -63, 123,
 123, 123, 123, -10, 265, -10, 512, -50, -23, 265,
 -39, 453,  -1,  -2, 261, 260, 263, -40, -20,  91,
-113, 123,-116, 272,  38,-117, 280, 281, 278, 277,
 276, 275, 282, -32, -33, 267,  91, -10, -10, -52,
 453, -54,  -1, 453, -48, 416, 417, 418, 419, 420,
 421, 422, 423, 424, 425, 426, 427, 428, 429, 430,
 -32, -13,  40,  -8, 312, 326,  -9, 286, 288, 295,
 -32, -32, 263,-114, 306,  61, -48, -60, -57, 125,
 -97, 397, -98, 399, -96, 401, 402, -65, -99,  -2,
 -79, -68, -81, -80, 462, 442, 493,-100, 492,-102,
 400, 377, 378, 379, 380, 381, -55, 382, 383, 384,
 385, 386, 387, 388, -56, 390, 391,-101,-105, 389,
 123, 398, -71, -73, -75, -77, -10,  -1, 445,  -2,
 315, 316, 309, 332, 320, 321, 323, 324, 325, 326,
 328, 329, 330, 331, 346, 322, 338, 313, 353, -53,
  46,  -8, 314, 315, 316, 317, 318, 313, 333, 323,
 347, 348, 349, 350, 351, 352, 339, 353, 337, 360,
 354, -41, -10,-115,-116,  42,  40, -32,  40, -18,
  91,  40, -18,  40, -18,  40, -18,  40, -18,  40,
 -18,  40,  41, 267, -10, 263,  58, 262,  -1, 458,
 459, 460, 340, -52,  -1, 315, 316,  -1, -31,  -3,
  91, -27,  -6, 293, 283, 284, 309, 310,  33, -92,
 294, 272, 270, 271, 275, 276, 277, 278, 280, 281,
 273, 311,  -1, 341,  41,  61, -14, -31, -15, -92,
 342, -27,  -8,  -8, 287, 289, 290, 291,  41,  41,
  44,  -2,  40,  61, 125, -86, -62, -59, -87, -89,
 -64, -65, -79, -68, -80, 436, 437, -91, 493, -81,
 392, 404, 410, 462, 125, -10, -10,  40, 435,  58,
  91, -10, -31,  91,-103,-104,-106,-108,-109,-110,
 299,-111, 297, 301, 300, -10,  -2, -10, -23,  40,
 -22, -23, 266, 280, 281, -32, -10,  -2,  -8, -27,
 -31, -37,-117, 262,  -8,  -2, -10, -14,  40, -30,
 -63,-100,  -2, -10, 125,-119, 446, -79,-120,-121,
 451, 452,-122, -80, 448, 125,-124,-118,-120,-123,
 446, 449, 125,-125, 444, 392, -80, 125,-126, 444,
 447, -80, -51, 401, -83, 302, 315, 316, 317, 347,
 348, 349,  -1, 316, 315, 322,  -1, -17,  40, -27,
 314, 315, 316, 317, 359, 353, 313, 463, 347, 348,
 349, 350, 357, 358,  93, 125,  44,  40,  -2,  41,
 -22, -10, -22, -23, -10, -10, -10,  93, -10,  -1,
  40,  -1, 461,  91,  38,  42, 343, 344, 345,  47,
  -3,  91, 293,  -3, -10,  -8, 275, 276, 277, 278,
 274, 273, 279, -37,  40,  41,  -8, -27, -31, 355,
  91, 263,  61,  40, -63, 123, 123, 123, -10, -10,
 123, -31, -43, -44, -53, -24, -25, -26, 269, -17,
  40, -10,  58, 268, -10,-103,-107,-100, 298,-107,
-107,-107,  -3,-100,  -2, -10,  40,  40,  41, -27,
 -31,  -2,  43, -32, -27,  -7,  -2, -10, -10, 125,
 304, 304, 450, -32, -10, -37,  61, -32,  61, -32,
 -32,  61,  61,  -1, 453, -10,  -1, 453,-118, -84,
 303,  -3, 315, 316, 317, 347, 348, 349, -27,  91,
 -37, -45,  -2,  40,-115, -37,  41,  41,  93,  41,
  41,  41,  41,  41, -16, 263, 372, -46, -47, -37,
  93,  -1,  93, -29, -28, 269, -10,  40,  40,  -1,
  -1, 461,  -3, -27, 274, -13, -27, -31,  -2, 268,
  40,  44, 125, -60, -88, -90, -75, 268, -31,  -2,
 353, 313,  -8, 353, 313,  -1,  41,  44, -27, -24,
  93, -10,  -4, 355, 356,  -1,  93,  -2, -10, -10,
 -23, -31,  -4,  -1, 268, 262,  41,  40,  41,  44,
  44,  -2, -10, -10,  41,  58,  40,  41,  40,  41,
  41,  40,  40,  -1, 305,  -1, -32, -85,  -3,  -4,
 463, 487, 488, 489, -10, 372, -45,  41, 369, 328,
 329, 330, 370, 371, 287, 289, 290, 291, 373, 376,
  -5, 305, -35, 464, 466, 467, 468, 469, 270, 271,
 275, 276, 277, 278, 280, 281, 257, 273, 470, 471,
 472, 474, 475, 476, 477, 478, 479, 480, 320, 481,
 274, 322, 482, 328, 473, -92, 372, 486,  41, -18,
 -18, -18, -18, -18, -18, 305, 277, 278, 440, 443,
 441,  -1,  41,  44,  61,  -6,  93,  93,  44, 269,
  -3,  -3,  93,  -1,  42,  61, -31,  -4, 268, 355,
 -24, 263, 125, 125, -93, 405, 406, 407, 408, -68,
 -80, -81, 125, -94, 411, 412, 408, -80, -68, -81,
 125,  -4,  -2, -27, -26,  -2, 463,  41, 372, -36,
  61, 304, 304,  41,  41, 268,  40,  -2, -24,  -7,
  -7, -10, -10,  41,  44,  40,  40,  93,  93,  93,
  93, -37,  41,  58,  58, -36,  -2,  41,  42,  91,
  40, 465, 485, 271, 275, 276, 277, 278, 274, -19,
 495, 467, 468, 270, 271, 275, 276, 277, 278, 280,
 281, 273,  42, 470, 471, 472, 474, 475, 478, 479,
 481, 274, 257, 496, 497, 498, 499, 500, 501, 502,
 503, 504, 505, 506, 507, 508, 480, 472, 484,  -2,
 -46, -38, -21, -10, 277, -37,  -3, 307, 308,  -6,
 -28, -10,  41,  41,  93,  40, -37,  40, 268,  40,
  -2,  40,  41,  -8,  -8,  -8,  -8,  -8,  -8,  -8,
 494,  -1,  40,  -2, -34, 280, 281, 278, 277, 276,
 272, 275, 271, -37,-117, 285,  -2, -10,  -4, -24,
  41,  58, -51,  -3, -24, -35, -45, 374, 375, 374,
 375,  93, -10,  43, -37,  91,  91,  44,  91, 509,
  38, 275, 276, 277, 278, 274,  40,  40, -24,  -4,
 -24, -24, -27, -27, -27, -27, -27, -27, -27,  -8,
  40, -35,  40,  40,  40,  40,  40,  40,  40,  40,
 -32,  40,  41, -10,  41,  41,  41,  93,  43, -10,
  44, -10, -10, -37,  93, -10, 275, 276, 277, -10,
  41,  40,  41,  41, -31,  -4, -31,  -4, -31,  -4,
 -31,  -4, -31,  -4, -31,  -4, -31,  -4, -27, -24,
  41, -22, -23, -22, -23, -23, -23, -23, -23, -23,
 -21,  41, -24,  58, -42,  -4, -10,  93, -37,  93,
  93,  41,  58,  58,  58,  41, -24, 268,  40, 268,
  40, 268,  40, 268,  40, 268,  40, 268,  40, 268,
  40, -31,  41,  -2,  41,  41,  41,  41,  41,  41,
  41,  41,  41,  41,  41, -10, 123, 311, 361, 362,
 363, 295, 364, 365, 366, 367, 319, 336,  40,  93,
  44,  41, -10, -10, -10,  41,  -4, -24,  -4, -24,
  -4, -24,  -4, -24,  -4, -24,  -4, -24,  -4, -24,
 268, -36, -24, -37,  41,  41,  41,  40,  41,  40,
  41,  40,  41,  40,  41,  40,  41,  40,  41,  40,
  41,  -4,  41,  44, -24, -24, -24, -24, -24, -24,
 -24,  40, -42, -37,  41,  41,  41,  41,  41,  41,
  41, -24, 123,  41,  41 };
YYSTATIC YYCONST short YYFARDATA YYDEF[]={

   1,  -2,   2,   0,   0, 265,   6,   7,   8,   9,
  10,  11,   0,   0,   0,   0,  16,  17,  18,   0,
   0, 552,   0,  23,  49,   0, 149, 101,   0, 307,
   0,   0,   0, 558, 601,  35,   0, 307, 361, 307,
 307,   0, 146, 270,   0,   0,  80,   1,   0, 563,
 578, 594, 604,  19, 508,  20,   0,   0,  22, 509,
   0, 585,  47, 346, 347, 504, 505, 361, 194,   0,
 267,   0, 273,   0,   0, 307, 276, 276, 276, 276,
 276, 276,   0,   0, 308, 309,   0, 546,   0,   0,
 558,   0,  36,   0,   0, 530, 531, 532, 533, 534,
 535, 536, 537, 538, 539, 540, 541, 542, 543, 544,
   0,  29,   0,   0, 361, 361, 360, 362, 363,   0,
   0,   0,  26, 269, 271,   0,   0,   0,   0,   5,
 266,   0, 223,   0,   0, 227, 228, 229, 230,   0,
 232, 233, 234, 235,   0,   0,   0, 240,   0,   0,
 221, 314,   0,   0,   0,   0, 307,   0, 361,   0,
   0,   0, 361,   0,   0,   0, 506, 265,   0, 312,
 243, 250,   0,   0,   0,   0,  21, 554, 553,  74,
  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
  60,  61,  62,  63,  64,   0,  71,  72,  73,   0,
   0, 189, 150, 151, 152, 153, 154, 155, 156, 157,
 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,
   0,   0,   0,   0, 275,   0,   0,   0,   0, 287,
   0,   0, 288,   0, 289,   0, 290,   0, 291,   0,
 292, 306,  45, 310,   0, 545,   0, 549, 557, 559,
 560, 561, 562,   0, 600, 602, 603,  37, 514, 354,
   0, 357, 351,   0, 462, 463,   0,   0,   0, 361,
 475, 476, 477, 478, 479, 480, 481, 482, 483, 484,
   0,   0, 352, 313, 515,   0,   0, 111, 112, 361,
   0,   0, 358, 359, 364, 365, 366, 367,  31,  34,
   0,   0,  46,   0,   3,  81, 265,   0,   0,   0,
  86,  87,  88,  89,  90,   0,   0,   0,   0,  95,
  49, 115, 132, 585,   4, 222, 224,  -2,   0, 231,
   0,   0,   0,   0, 244, 246,   0,   0,   0,   0,
   0,   0, 260, 261, 258, 315, 316, 317, 318, 311,
 319, 320, 510,   0,   0,   0, 322, 323,   0,   0,
 328, 329, 307,  24,   0, 332, 333, 334, 499, 336,
   0, 247,   0,   0,  12, 564,   0, 566, 567, 307,
   0,   0, 307, 572,   0,  13, 579, 307, 581, 307,
   0,   0,  14, 595,   0,   0, 599,  15, 605,   0,
   0, 608, 551, 555,  76,   0,  65,  66,  67,  68,
  69,  70, 583, 586, 587,   0, 348,   0, 171,   0,
 195, 196, 197, 198, 199, 200, 201,   0, 203, 204,
 205, 206, 207, 208, 102, 272,   0,   0,   0, 280,
   0,   0,   0,   0,   0,   0,   0,  39, 548, 576,
   0,   0,   0, 494, 468, 469, 470,   0,   0,   0,
 461,   0,   0, 465, 473,   0, 485, 486, 487, 488,
 489,   0, 491,  30, 103, 361,   0,   0,   0,   0,
 494,  27, 268, 516,   0,  80, 118, 135,  91,  92,
 594,   0,   0, 361,   0,   0, 338, 339, 341,   0,
  -2,   0,   0,   0,   0, 245, 251, 262,   0, 252,
 253, 254, 259, 255, 256, 257,   0,   0, 321,   0,
   0,  -2,   0,   0,   0,   0, 502, 503, 507, 242,
   0,   0,   0,   0,   0, 570,   0,   0,   0,   0,
   0,   0,   0, 596,   0, 598,   0,   0, 307,  48,
   0,  75, 588, 589, 590, 591, 592, 593,   0,   0,
 171,   0,  97, 368, 274,   0, 279, 276, 277, 276,
 276, 276, 276, 276,   0, 547,   0,   0, 517,   0,
 355,   0, 466,   0, 492, 495, 496,   0,   0, 353,
   0,   0, 464,   0, 490,  32,   0,   0,  -2,   0,
  -2,   0,  82,   0,   0,   0,   0,   0,   0,  -2,
 116, 117,   0, 133, 134, 584, 225, 189, 342,   0,
 236, 238, 239, 186, 187, 188,  99,   0,   0,   0,
   0,   0,   0,  -2,   0,  25, 330,  -2, 335, 499,
 499, 248, 249, 565, 568,   0, 575, 571, 573, 580,
 582, 556, 574, 597,   0, 607,   0,  77,  79,   0,
   0,   0,   0,   0,   0,   0,   0, 170, 172, 173,
 174, 175, 176, 177, 178, 179, 180, 181,   0,   0,
  99,   0,   0,   0,   0, 373, 374, 375, 376, 377,
 378, 379, 380, 381, 382, 383, 384,   0, 394, 395,
 396, 397, 398, 399, 400, 401, 402, 403, 404, 417,
 407,   0, 410,   0, 412, 414,   0, 416, 278, 281,
 282, 283, 284, 285, 286,   0,  40,  41,  42,  43,
  44, 577, 513,   0,   0, 349, 356, 467, 494, 498,
   0,   0,   0,   0, 469,   0,   0,   0,   0,   0,
   0,  28,  83,  84, 119, 361, 361, 361, 361, 128,
 129, 130,  85, 136, 361, 361, 361, 143, 144, 145,
  93,   0, 113,   0, 340, 343,   0, 226,   0, 241,
   0,   0,   0, 511, 512,   0,  -2, 326,   0, 500,
 501,   0, 606, 554,   0,  -2, 368, 190, 191, 192,
 193, 171, 169,   0,   0,  96,  98, 202, 389,   0,
   0,   0,   0, 413, 385, 386, 387, 388, 408, 405,
 418, 419, 420, 421, 422, 423, 424, 425, 426, 427,
 428,   0, 433, 437, 438, 439, 440, 441, 442, 443,
 444, 445, 447, 448, 449, 450, 451, 452, 453, 454,
 455, 456, 457, 458, 459, 460, 409, 411, 415,  38,
 518, 519, 522, 523,   0, 525,   0, 520, 521, 350,
 493, 497, 471, 472,   0,  -2,  33, 104,   0,  -2,
 107,  -2, 110,   0,   0,   0,   0,   0,   0,   0,
 361,   0, 368, 237, 100,   0,   0,   0,   0,   0,
   0,   0,   0, 303, 307, 305, 263, 264,   0,   0,
 331,   0, 550,  78,   0,   0,   0, 182, 183, 184,
 185, 390,   0,   0,   0,   0,   0,   0,   0, 435,
 436, 429, 430, 431, 432, 446,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  -2,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  -2, 325,   0, 209,   0, 168, 391,   0,   0,
   0,   0,   0, 406, 434,   0,   0,   0,   0,   0,
 474,  -2, 106, 109,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 344,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 304,   0,   0,   0,   0,   0, 393,   0, 371,
 372, 524,   0,   0,   0, 529,   0,   0,  -2,   0,
  -2,   0,  -2,   0,  -2,   0,  -2,   0,  -2,   0,
  -2,   0,  99, 345, 293, 295, 294, 296, 297, 298,
 299, 300, 301, 302, 324, 569, 147, 210, 211, 212,
 213, 214, 215, 216, 217, 218, 219, 220,  -2, 392,
   0, 370,   0,   0,   0, 105,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 131,   0,   0, 526, 527, 528,  -2, 121,  -2,
 123,  -2, 125,  -2, 127,  -2, 138,  -2, 140,  -2,
 142,   0, 209,   0,   0,   0,   0,   0,   0,   0,
   0,  -2,   0,   0, 120, 122, 124, 126, 137, 139,
 141,   0, 148, 369,  94 };
#ifdef YYRECOVER
YYSTATIC YYCONST short yyrecover[] = {
-1000
};
#endif

/* SCCSWHAT( "@(#)yypars.c	3.1 88/11/16 22:00:49	" ) */
#line 3 "e:\\com99\\env.cor\\bin\\i386\\yypars.c"
#if ! defined(YYAPI_PACKAGE)
/*
**  YYAPI_TOKENNAME		: name used for return value of yylex	
**	YYAPI_TOKENTYPE		: type of the token
**	YYAPI_TOKENEME(t)	: the value of the token that the parser should see
**	YYAPI_TOKENNONE		: the representation when there is no token
**	YYAPI_VALUENAME		: the name of the value of the token
**	YYAPI_VALUETYPE		: the type of the value of the token (if null, then the value is derivable from the token itself)
**	YYAPI_VALUEOF(v)	: how to get the value of the token.
*/
#define	YYAPI_TOKENNAME		yychar
#define	YYAPI_TOKENTYPE		int
#define	YYAPI_TOKENEME(t)	(t)
#define	YYAPI_TOKENNONE		-1
#define	YYAPI_TOKENSTR(t)	(sprintf(yytokbuf, "%d", t), yytokbuf)
#define	YYAPI_VALUENAME		yylval
#define	YYAPI_VALUETYPE		YYSTYPE
#define	YYAPI_VALUEOF(v)	(v)
#endif
#if ! defined(YYAPI_CALLAFTERYYLEX)
#define	YYAPI_CALLAFTERYYLEX
#endif

# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
char yytokbuf[20];
# ifndef YYDBFLG
#  define YYDBFLG (yydebug)
# endif
# define yyprintf(a, b, c, d) if (YYDBFLG) YYPRINT(a, b, c, d)
#else
# define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

/*	parser for yacc output	*/

#ifdef YYDUMP
int yydump = 1; /* 1 for dumping */
void yydumpinfo(void);
#endif
#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */

#if ! defined(YYRECURSIVE)
YYSTATIC YYAPI_TOKENTYPE	YYAPI_TOKENNAME = YYAPI_TOKENNONE;
#if defined(YYAPI_VALUETYPE)
// YYSTATIC YYAPI_VALUETYPE	YYAPI_VALUENAME;	 FIX 
#endif
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */
#endif

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(register char*t, register char*f)
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

#if defined(YYRECURSIVE)

	YYSTATIC YYAPI_TOKENTYPE	YYAPI_TOKENNAME = YYAPI_TOKENNONE;
  #if defined(YYAPI_VALUETYPE)
	YYSTATIC YYAPI_VALUETYPE	YYAPI_VALUENAME;  
  #endif
	YYSTATIC int yynerrs = 0;			/* number of errors */
	YYSTATIC short yyerrflag = 0;		/* error recovery flag */

	YYSTATIC short	yyn;
	YYSTATIC short	yystate = 0;
	YYSTATIC short	*yyps= &yys[-1];
	YYSTATIC YYSTYPE	*yypv= &yyv[-1];
	YYSTATIC short	yyj;
	YYSTATIC short	yym;

#endif

#pragma warning(disable:102)
YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
#if ! defined(YYRECURSIVE)

	register	short	yyn;
	short		yystate, *yyps;
	YYSTYPE		*yypv;
	short		yyj, yym;

	YYAPI_TOKENNAME = YYAPI_TOKENNONE;
	yystate = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];
#endif

#ifdef YYDUMP
	yydumpinfo();
#endif
 yystack:	 /* put a state and value onto the stack */

#ifdef YYDEBUG
	if(YYAPI_TOKENNAME == YYAPI_TOKENNONE) {
		yyprintf( "state %d, token # '%d'\n", yystate, -1, 0 );
		}
	else {
		yyprintf( "state %d, token # '%s'\n", yystate, YYAPI_TOKENSTR(YYAPI_TOKENNAME), 0 );
		}
#endif
	if( ++yyps > &yys[YYMAXDEPTH] ) {
		yyerror( "yacc stack overflow" );
		return(1);
	}
	*yyps = yystate;
	++yypv;

	*yypv = yyval;

yynewstate:

	yyn = YYPACT[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}
	if( YYAPI_TOKENNAME == YYAPI_TOKENNONE ) {	/*  need a lookahead */
		YYAPI_TOKENNAME = YYLEX();
		YYAPI_CALLAFTERYYLEX(YYAPI_TOKENNAME);
	}
	if( ((yyn += YYAPI_TOKENEME(YYAPI_TOKENNAME)) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}
	if( YYCHK[ yyn = YYACT[ yyn ] ] == YYAPI_TOKENEME(YYAPI_TOKENNAME) ) {		/* valid shift */
		yyval = YYAPI_VALUEOF(YYAPI_VALUENAME);
		yystate = yyn;
 		yyprintf( "SHIFT: saw token '%s', now in state %4d\n", YYAPI_TOKENSTR(YYAPI_TOKENNAME), yystate, 0 );
		YYAPI_TOKENNAME = YYAPI_TOKENNONE;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = YYDEF[yystate]) == -2 ) {
		register	YYCONST short	*yyxi;

		if( YYAPI_TOKENNAME == YYAPI_TOKENNONE ) {
			YYAPI_TOKENNAME = YYLEX();
			YYAPI_CALLAFTERYYLEX(YYAPI_TOKENNAME);
 			yyprintf("LOOKAHEAD: token '%s'\n", YYAPI_TOKENSTR(YYAPI_TOKENNAME), 0, 0);
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != YYAPI_TOKENEME(YYAPI_TOKENNAME) ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == YYAPI_TOKENEME(YYAPI_TOKENNAME) ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ){ /* error */
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:		/* brand new error */
#ifdef YYRECOVER
			{
			register	int		i,j;

			for(i = 0;
				(yyrecover[i] != -1000) && (yystate > yyrecover[i]);
				i += 3
			) {
				;
			}
			if(yystate == yyrecover[i]) {
				yyprintf("recovered, from state %d to state %d on token # %d\n",
						yystate,yyrecover[i+2],yyrecover[i+1]
						);
				j = yyrecover[i + 1];
				if(j < 0) {
				/*
				**  here we have one of the injection set, so we're not quite
				**  sure that the next valid thing will be a shift. so we'll
				**  count it as an error and continue.
				**  actually we're not absolutely sure that the next token
				**  we were supposed to get is the one when j > 0. for example,
				**  for(+) {;} error recovery with yyerrflag always set, stops
				**  after inserting one ; before the +. at the point of the +,
				**  we're pretty sure the guy wants a 'for' loop. without
				**  setting the flag, when we're almost absolutely sure, we'll
				**  give him one, since the only thing we can shift on this
				**  error is after finding an expression followed by a +
				*/
					yyerrflag++;
					j = -j;
					}
				if(yyerrflag <= 1) {	/*  only on first insertion  */
					yyrecerr(YYAPI_TOKENNAME, j);	/*  what was, what should be first */
				}
				yyval = yyeval(j);
				yystate = yyrecover[i + 2];
				goto yystack;
				}
			}
#endif
		yyerror("syntax error");

		yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = YYPACT[*yyps] + YYERRCODE;
			   if( yyn>= 0 && yyn < YYLAST && YYCHK[YYACT[yyn]] == YYERRCODE ){
			      yystate = YYACT[yyn];  /* simulate a shift of "error" */
 				  yyprintf( "SHIFT 'error': now in state %4d\n", yystate, 0, 0 );
			      goto yystack;
			      }
			   yyn = YYPACT[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */

 			   yyprintf( "error recovery pops state %4d, uncovers %4d\n", *yyps, yyps[-1], 0 );
			   --yyps;
			   --yypv;
			   }

			/* there is no state on the stack with an error shift ... abort */

	yyabort:
			return(1);


		case 3:  /* no shift yet; clobber input char */

 			yyprintf( "error recovery discards token '%s'\n", YYAPI_TOKENSTR(YYAPI_TOKENNAME), 0, 0 );

			if( YYAPI_TOKENEME(YYAPI_TOKENNAME) == 0 ) goto yyabort; /* don't discard EOF, quit */
			YYAPI_TOKENNAME = YYAPI_TOKENNONE;
			goto yynewstate;   /* try again in the same state */
			}
		}

	/* reduction by production yyn */
yyreduce:
		{
		register	YYSTYPE	*yypvt;
		yypvt = yypv;
		yyps -= YYR2[yyn];
		yypv -= YYR2[yyn];
		yyval = yypv[1];
 		yyprintf("REDUCE: rule %4d, popped %2d tokens, uncovered state %4d, ",yyn, YYR2[yyn], *yyps);
		yym = yyn;
		yyn = YYR1[yyn];		/* consult goto table to find next state */
		yyj = YYPGO[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (YYCHK[ yystate = YYACT[yyj] ] != -yyn) ) {
			yystate = YYACT[YYPGO[yyn]];
			}
 		yyprintf("goto state %4d\n", yystate, 0, 0);
#ifdef YYDUMP
		yydumpinfo();
#endif
		switch(yym){
			
case 3:
#line 192 "asmparse.y"
{ PASM->EndClass(); } break;
case 4:
#line 193 "asmparse.y"
{ PASM->EndNameSpace(); } break;
case 5:
#line 194 "asmparse.y"
{ if(PASM->m_pCurMethod->m_ulLines[1] ==0)
																				  {  PASM->m_pCurMethod->m_ulLines[1] = PASM->m_ulCurLine;
																					 PASM->m_pCurMethod->m_ulColumns[1]=PASM->m_ulCurColumn;}
														  						  PASM->EndMethod(); } break;
case 12:
#line 204 "asmparse.y"
{ PASMM->EndAssembly(); } break;
case 13:
#line 205 "asmparse.y"
{ PASMM->EndAssembly(); } break;
case 14:
#line 206 "asmparse.y"
{ PASMM->EndComType(); } break;
case 15:
#line 207 "asmparse.y"
{ PASMM->EndManifestRes(); } break;
case 19:
#line 211 "asmparse.y"
{ if(!g_dwSubsystem) PASM->m_dwSubsystem = yypvt[-0].int32; } break;
case 20:
#line 212 "asmparse.y"
{ if(!g_dwComImageFlags) PASM->m_dwComImageFlags = yypvt[-0].int32; } break;
case 21:
#line 213 "asmparse.y"
{ if(!g_dwFileAlignment) PASM->m_dwFileAlignment = yypvt[-0].int32; } break;
case 22:
#line 214 "asmparse.y"
{ if(!g_stBaseAddress) PASM->m_stBaseAddress = (size_t)(*(yypvt[-0].int64)); delete yypvt[-0].int64; } break;
case 24:
#line 218 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 25:
#line 219 "asmparse.y"
{ yyval.binstr = yypvt[-2].binstr; yyval.binstr->append(yypvt[-0].binstr); delete yypvt[-0].binstr; } break;
case 26:
#line 222 "asmparse.y"
{ LPCSTRToGuid(yypvt[-0].string,&(PASM->m_guidLang)); } break;
case 27:
#line 223 "asmparse.y"
{ LPCSTRToGuid(yypvt[-2].string,&(PASM->m_guidLang)); 
						                                                          LPCSTRToGuid(yypvt[-0].string,&(PASM->m_guidLangVendor));} break;
case 28:
#line 225 "asmparse.y"
{ LPCSTRToGuid(yypvt[-4].string,&(PASM->m_guidLang)); 
						                                                          LPCSTRToGuid(yypvt[-2].string,&(PASM->m_guidLangVendor));
						                                                          LPCSTRToGuid(yypvt[-2].string,&(PASM->m_guidDoc));} break;
case 29:
#line 230 "asmparse.y"
{ if(PASM->m_tkCurrentCVOwner) 
                                                                                    PASM->DefineCV(PASM->m_tkCurrentCVOwner, yypvt[-0].int32, NULL);
                                                                                  else if(PASM->m_pCustomDescrList)
                                                                                    PASM->m_pCustomDescrList->PUSH(new CustomDescr(yypvt[-0].int32, NULL)); } break;
case 30:
#line 234 "asmparse.y"
{ if(PASM->m_tkCurrentCVOwner) 
                                                                                    PASM->DefineCV(PASM->m_tkCurrentCVOwner, yypvt[-2].int32, yypvt[-0].binstr);
                                                                                  else if(PASM->m_pCustomDescrList)
                                                                                    PASM->m_pCustomDescrList->PUSH(new CustomDescr(yypvt[-2].int32, yypvt[-0].binstr)); } break;
case 31:
#line 238 "asmparse.y"
{ if(PASM->m_tkCurrentCVOwner) 
                                                                                    PASM->DefineCV(PASM->m_tkCurrentCVOwner, yypvt[-2].int32, yypvt[-1].binstr);
                                                                                   else if(PASM->m_pCustomDescrList)
                                                                                    PASM->m_pCustomDescrList->PUSH(new CustomDescr(yypvt[-2].int32, yypvt[-1].binstr)); } break;
case 32:
#line 242 "asmparse.y"
{ PASM->DefineCV(yypvt[-2].int32, yypvt[-0].int32, NULL); } break;
case 33:
#line 243 "asmparse.y"
{ PASM->DefineCV(yypvt[-4].int32, yypvt[-2].int32, yypvt[-0].binstr); } break;
case 34:
#line 244 "asmparse.y"
{ PASM->DefineCV(PASM->m_tkCurrentCVOwner, yypvt[-2].int32, yypvt[-1].binstr); } break;
case 35:
#line 247 "asmparse.y"
{ PASMM->SetModuleName(NULL); PASM->m_tkCurrentCVOwner=1; } break;
case 36:
#line 248 "asmparse.y"
{ PASMM->SetModuleName(yypvt[-0].string); PASM->m_tkCurrentCVOwner=1; } break;
case 37:
#line 249 "asmparse.y"
{ BinStr* pbs = new BinStr();
						                                                          strcpy((char*)(pbs->getBuff((unsigned)strlen(yypvt[-0].string)+1)),yypvt[-0].string);
																				  PASM->EmitImport(pbs); delete pbs;} break;
case 38:
#line 254 "asmparse.y"
{ /*PASM->SetDataSection(); PASM->EmitDataLabel($7);*/
                                                                                  PASM->m_VTFList.PUSH(new VTFEntry((USHORT)yypvt[-4].int32, (USHORT)yypvt[-2].int32, yypvt[-0].string)); } break;
case 39:
#line 258 "asmparse.y"
{ yyval.int32 = 0; } break;
case 40:
#line 259 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | COR_VTABLE_32BIT; } break;
case 41:
#line 260 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | COR_VTABLE_64BIT; } break;
case 42:
#line 261 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | COR_VTABLE_FROM_UNMANAGED; } break;
case 43:
#line 262 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN; } break;
case 44:
#line 263 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | COR_VTABLE_CALL_MOST_DERIVED; } break;
case 45:
#line 266 "asmparse.y"
{ PASM->m_pVTable = yypvt[-1].binstr; } break;
case 46:
#line 269 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 47:
#line 272 "asmparse.y"
{ PASM->StartNameSpace(yypvt[-0].string); } break;
case 48:
#line 275 "asmparse.y"
{ PASM->StartClass(yypvt[-2].string, yypvt[-3].classAttr); } break;
case 49:
#line 278 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) 0; } break;
case 50:
#line 279 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdVisibilityMask) | tdPublic); } break;
case 51:
#line 280 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdVisibilityMask) | tdNotPublic); } break;
case 52:
#line 281 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | 0x80000000); } break;
case 53:
#line 282 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | 0x40000000); } break;
case 54:
#line 283 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdInterface | tdAbstract); } break;
case 55:
#line 284 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdSealed); } break;
case 56:
#line 285 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdAbstract); } break;
case 57:
#line 286 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdLayoutMask) | tdAutoLayout); } break;
case 58:
#line 287 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdLayoutMask) | tdSequentialLayout); } break;
case 59:
#line 288 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdLayoutMask) | tdExplicitLayout); } break;
case 60:
#line 289 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdStringFormatMask) | tdAnsiClass); } break;
case 61:
#line 290 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdStringFormatMask) | tdUnicodeClass); } break;
case 62:
#line 291 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-1].classAttr & ~tdStringFormatMask) | tdAutoClass); } break;
case 63:
#line 292 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdImport); } break;
case 64:
#line 293 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdSerializable); } break;
case 65:
#line 294 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedPublic); } break;
case 66:
#line 295 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedPrivate); } break;
case 67:
#line 296 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedFamily); } break;
case 68:
#line 297 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedAssembly); } break;
case 69:
#line 298 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedFamANDAssem); } break;
case 70:
#line 299 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) ((yypvt[-2].classAttr & ~tdVisibilityMask) | tdNestedFamORAssem); } break;
case 71:
#line 300 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdBeforeFieldInit); } break;
case 72:
#line 301 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr | tdSpecialName); } break;
case 73:
#line 302 "asmparse.y"
{ yyval.classAttr = (CorRegTypeAttr) (yypvt[-1].classAttr); } break;
case 75:
#line 306 "asmparse.y"
{ strcpy(PASM->m_szExtendsClause,yypvt[-0].string); } break;
case 78:
#line 313 "asmparse.y"
{ PASM->AddToImplList(yypvt[-0].string); } break;
case 79:
#line 314 "asmparse.y"
{ PASM->AddToImplList(yypvt[-0].string); } break;
case 82:
#line 321 "asmparse.y"
{ if(PASM->m_pCurMethod->m_ulLines[1] ==0)
															  {  PASM->m_pCurMethod->m_ulLines[1] = PASM->m_ulCurLine;
																 PASM->m_pCurMethod->m_ulColumns[1]=PASM->m_ulCurColumn;}
															  PASM->EndMethod(); } break;
case 83:
#line 325 "asmparse.y"
{ PASM->EndClass(); } break;
case 84:
#line 326 "asmparse.y"
{ PASM->EndEvent(); } break;
case 85:
#line 327 "asmparse.y"
{ PASM->EndProp(); } break;
case 91:
#line 333 "asmparse.y"
{ PASM->m_pCurClass->m_ulSize = yypvt[-0].int32; } break;
case 92:
#line 334 "asmparse.y"
{ PASM->m_pCurClass->m_ulPack = yypvt[-0].int32; } break;
case 93:
#line 335 "asmparse.y"
{ PASMM->EndComType(); } break;
case 94:
#line 337 "asmparse.y"
{ PASM->AddMethodImpl(yypvt[-11].binstr,yypvt[-9].string,parser->MakeSig(yypvt[-7].int32,yypvt[-6].binstr,yypvt[-1].binstr),yypvt[-5].binstr,yypvt[-3].string); } break;
case 96:
#line 342 "asmparse.y"
{ yypvt[-3].binstr->insertInt8(IMAGE_CEE_CS_CALLCONV_FIELD);
                                                              PASM->AddField(yypvt[-2].string, yypvt[-3].binstr, yypvt[-4].fieldAttr, yypvt[-1].string, yypvt[-0].binstr, yypvt[-5].int32); } break;
case 97:
#line 347 "asmparse.y"
{ yyval.string = 0; } break;
case 98:
#line 348 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 99:
#line 351 "asmparse.y"
{ yyval.binstr = NULL; } break;
case 100:
#line 352 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 101:
#line 355 "asmparse.y"
{ yyval.int32 = 0xFFFFFFFF; } break;
case 102:
#line 356 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32; } break;
case 103:
#line 359 "asmparse.y"
{ yyval.int32 = yypvt[-2].int32; bParsingByteArray = TRUE; } break;
case 104:
#line 363 "asmparse.y"
{ PASM->m_pCustomDescrList = NULL;
															  PASM->m_tkCurrentCVOwner = yypvt[-4].int32;
															  yyval.int32 = yypvt[-2].int32; bParsingByteArray = TRUE; } break;
case 105:
#line 369 "asmparse.y"
{ yyval.int32 = PASM->MakeMemberRef(yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr),iOpcodeLen); 
                                                               delete PASM->m_firstArgName;
                                                               PASM->m_firstArgName = palDummy;
															} break;
case 106:
#line 374 "asmparse.y"
{ yyval.int32 = PASM->MakeMemberRef(NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr),iOpcodeLen); 
                                                               delete PASM->m_firstArgName;
                                                               PASM->m_firstArgName = palDummy;
															} break;
case 107:
#line 379 "asmparse.y"
{ yypvt[-3].binstr->insertInt8(IMAGE_CEE_CS_CALLCONV_FIELD); 
                                                               yyval.int32 = PASM->MakeMemberRef(yypvt[-2].binstr, yypvt[-0].string, yypvt[-3].binstr, 0); } break;
case 108:
#line 382 "asmparse.y"
{ yypvt[-1].binstr->insertInt8(IMAGE_CEE_CS_CALLCONV_FIELD); 
                                                               yyval.int32 = PASM->MakeMemberRef(NULL, yypvt[-0].string, yypvt[-1].binstr, 0); } break;
case 109:
#line 387 "asmparse.y"
{ yyval.int32 = PASM->MakeMemberRef(yypvt[-5].binstr, newString(COR_CTOR_METHOD_NAME), parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr),0); } break;
case 110:
#line 389 "asmparse.y"
{ yyval.int32 = PASM->MakeMemberRef(NULL, newString(COR_CTOR_METHOD_NAME), parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr),0); } break;
case 111:
#line 392 "asmparse.y"
{ yyval.int32 = PASM->MakeTypeRef(yypvt[-0].binstr); } break;
case 112:
#line 393 "asmparse.y"
{ yyval.int32 = yypvt[-0].int32; } break;
case 113:
#line 396 "asmparse.y"
{ PASM->ResetEvent(yypvt[-0].string, yypvt[-1].binstr, yypvt[-2].eventAttr); } break;
case 114:
#line 397 "asmparse.y"
{ PASM->ResetEvent(yypvt[-0].string, NULL, yypvt[-1].eventAttr); } break;
case 115:
#line 401 "asmparse.y"
{ yyval.eventAttr = (CorEventAttr) 0; } break;
case 116:
#line 402 "asmparse.y"
{ yyval.eventAttr = yypvt[-1].eventAttr; } break;
case 117:
#line 403 "asmparse.y"
{ yyval.eventAttr = (CorEventAttr) (yypvt[-1].eventAttr | evSpecialName); } break;
case 120:
#line 411 "asmparse.y"
{ PASM->SetEventMethod(0, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 121:
#line 413 "asmparse.y"
{ PASM->SetEventMethod(0, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 122:
#line 415 "asmparse.y"
{ PASM->SetEventMethod(1, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 123:
#line 417 "asmparse.y"
{ PASM->SetEventMethod(1, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 124:
#line 419 "asmparse.y"
{ PASM->SetEventMethod(2, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 125:
#line 421 "asmparse.y"
{ PASM->SetEventMethod(2, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 126:
#line 423 "asmparse.y"
{ PASM->SetEventMethod(3, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 127:
#line 425 "asmparse.y"
{ PASM->SetEventMethod(3, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 131:
#line 432 "asmparse.y"
{ PASM->ResetProp(yypvt[-4].string, 
                                                              parser->MakeSig((IMAGE_CEE_CS_CALLCONV_PROPERTY |
                                                              (yypvt[-6].int32 & IMAGE_CEE_CS_CALLCONV_HASTHIS)),yypvt[-5].binstr,yypvt[-2].binstr), yypvt[-7].propAttr, yypvt[-0].binstr); } break;
case 132:
#line 437 "asmparse.y"
{ yyval.propAttr = (CorPropertyAttr) 0; } break;
case 133:
#line 438 "asmparse.y"
{ yyval.propAttr = yypvt[-1].propAttr; } break;
case 134:
#line 439 "asmparse.y"
{ yyval.propAttr = (CorPropertyAttr) (yypvt[-1].propAttr | prSpecialName); } break;
case 137:
#line 448 "asmparse.y"
{ PASM->SetPropMethod(0, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 138:
#line 450 "asmparse.y"
{ PASM->SetPropMethod(0, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 139:
#line 452 "asmparse.y"
{ PASM->SetPropMethod(1, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 140:
#line 454 "asmparse.y"
{ PASM->SetPropMethod(1, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 141:
#line 456 "asmparse.y"
{ PASM->SetPropMethod(2, yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr)); } break;
case 142:
#line 458 "asmparse.y"
{ PASM->SetPropMethod(2, NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr)); } break;
case 146:
#line 465 "asmparse.y"
{ PASM->ResetForNextMethod(); 
															  uMethodBeginLine = PASM->m_ulCurLine;
															  uMethodBeginColumn=PASM->m_ulCurColumn;} break;
case 147:
#line 471 "asmparse.y"
{ PASM->StartMethod(yypvt[-5].string, parser->MakeSig(yypvt[-8].int32, yypvt[-6].binstr, yypvt[-3].binstr), yypvt[-9].methAttr, NULL, yypvt[-7].int32);
                                                              PASM->SetImplAttr((USHORT)yypvt[-1].implAttr);  
															  PASM->m_pCurMethod->m_ulLines[0] = uMethodBeginLine;
															  PASM->m_pCurMethod->m_ulColumns[0]=uMethodBeginColumn; } break;
case 148:
#line 476 "asmparse.y"
{ PASM->StartMethod(yypvt[-5].string, parser->MakeSig(yypvt[-12].int32, yypvt[-10].binstr, yypvt[-3].binstr), yypvt[-13].methAttr, yypvt[-7].binstr, yypvt[-11].int32);
                                                              PASM->SetImplAttr((USHORT)yypvt[-1].implAttr);
															  PASM->m_pCurMethod->m_ulLines[0] = uMethodBeginLine;
															  PASM->m_pCurMethod->m_ulColumns[0]=uMethodBeginColumn; } break;
case 149:
#line 483 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) 0; } break;
case 150:
#line 484 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdStatic); } break;
case 151:
#line 485 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdPublic); } break;
case 152:
#line 486 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdPrivate); } break;
case 153:
#line 487 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdFamily); } break;
case 154:
#line 488 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdFinal); } break;
case 155:
#line 489 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdSpecialName); } break;
case 156:
#line 490 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdVirtual); } break;
case 157:
#line 491 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdAbstract); } break;
case 158:
#line 492 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdAssem); } break;
case 159:
#line 493 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdFamANDAssem); } break;
case 160:
#line 494 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdFamORAssem); } break;
case 161:
#line 495 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) ((yypvt[-1].methAttr & ~mdMemberAccessMask) | mdPrivateScope); } break;
case 162:
#line 496 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdHideBySig); } break;
case 163:
#line 497 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdNewSlot); } break;
case 164:
#line 498 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | 0x0200); } break;
case 165:
#line 499 "asmparse.y"
{ yyval.methAttr = yypvt[-1].methAttr; } break;
case 166:
#line 500 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdUnmanagedExport); } break;
case 167:
#line 501 "asmparse.y"
{ yyval.methAttr = (CorMethodAttr) (yypvt[-1].methAttr | mdRequireSecObject); } break;
case 168:
#line 504 "asmparse.y"
{ PASM->SetPinvoke(yypvt[-4].binstr,0,yypvt[-2].binstr,yypvt[-1].pinvAttr); 
                                                              yyval.methAttr = (CorMethodAttr) (yypvt[-7].methAttr | mdPinvokeImpl); } break;
case 169:
#line 507 "asmparse.y"
{ PASM->SetPinvoke(yypvt[-2].binstr,0,NULL,yypvt[-1].pinvAttr); 
                                                              yyval.methAttr = (CorMethodAttr) (yypvt[-5].methAttr | mdPinvokeImpl); } break;
case 170:
#line 510 "asmparse.y"
{ PASM->SetPinvoke(new BinStr(),0,NULL,yypvt[-1].pinvAttr); 
                                                              yyval.methAttr = (CorMethodAttr) (yypvt[-4].methAttr | mdPinvokeImpl); } break;
case 171:
#line 514 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) 0; } break;
case 172:
#line 515 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmNoMangle); } break;
case 173:
#line 516 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCharSetAnsi); } break;
case 174:
#line 517 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCharSetUnicode); } break;
case 175:
#line 518 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCharSetAuto); } break;
case 176:
#line 519 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmSupportsLastError); } break;
case 177:
#line 520 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCallConvWinapi); } break;
case 178:
#line 521 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCallConvCdecl); } break;
case 179:
#line 522 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCallConvStdcall); } break;
case 180:
#line 523 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCallConvThiscall); } break;
case 181:
#line 524 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-1].pinvAttr | pmCallConvFastcall); } break;
case 182:
#line 525 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-3].pinvAttr | pmBestFitEnabled); } break;
case 183:
#line 526 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-3].pinvAttr | pmBestFitDisabled); } break;
case 184:
#line 527 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-3].pinvAttr | pmThrowOnUnmappableCharEnabled); } break;
case 185:
#line 528 "asmparse.y"
{ yyval.pinvAttr = (CorPinvokeMap) (yypvt[-3].pinvAttr | pmThrowOnUnmappableCharDisabled); } break;
case 186:
#line 531 "asmparse.y"
{ yyval.string = newString(COR_CTOR_METHOD_NAME); } break;
case 187:
#line 532 "asmparse.y"
{ yyval.string = newString(COR_CCTOR_METHOD_NAME); } break;
case 188:
#line 533 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 189:
#line 536 "asmparse.y"
{ yyval.int32 = 0; } break;
case 190:
#line 537 "asmparse.y"
{ yyval.int32 = yypvt[-3].int32 | pdIn; } break;
case 191:
#line 538 "asmparse.y"
{ yyval.int32 = yypvt[-3].int32 | pdOut; } break;
case 192:
#line 539 "asmparse.y"
{ yyval.int32 = yypvt[-3].int32 | pdOptional; } break;
case 193:
#line 540 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 + 1; } break;
case 194:
#line 543 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) 0; } break;
case 195:
#line 544 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) (yypvt[-1].fieldAttr | fdStatic); } break;
case 196:
#line 545 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdPublic); } break;
case 197:
#line 546 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdPrivate); } break;
case 198:
#line 547 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdFamily); } break;
case 199:
#line 548 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) (yypvt[-1].fieldAttr | fdInitOnly); } break;
case 200:
#line 549 "asmparse.y"
{ yyval.fieldAttr = yypvt[-1].fieldAttr; } break;
case 201:
#line 550 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) (yypvt[-1].fieldAttr | fdSpecialName); } break;
case 202:
#line 563 "asmparse.y"
{ PASM->m_pMarshal = yypvt[-1].binstr; } break;
case 203:
#line 564 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdAssembly); } break;
case 204:
#line 565 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdFamANDAssem); } break;
case 205:
#line 566 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdFamORAssem); } break;
case 206:
#line 567 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) ((yypvt[-1].fieldAttr & ~mdMemberAccessMask) | fdPrivateScope); } break;
case 207:
#line 568 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) (yypvt[-1].fieldAttr | fdLiteral); } break;
case 208:
#line 569 "asmparse.y"
{ yyval.fieldAttr = (CorFieldAttr) (yypvt[-1].fieldAttr | fdNotSerialized); } break;
case 209:
#line 572 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (miIL | miManaged); } break;
case 210:
#line 573 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) ((yypvt[-1].implAttr & 0xFFF4) | miNative); } break;
case 211:
#line 574 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) ((yypvt[-1].implAttr & 0xFFF4) | miIL); } break;
case 212:
#line 575 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) ((yypvt[-1].implAttr & 0xFFF4) | miOPTIL); } break;
case 213:
#line 576 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) ((yypvt[-1].implAttr & 0xFFFB) | miManaged); } break;
case 214:
#line 577 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) ((yypvt[-1].implAttr & 0xFFFB) | miUnmanaged); } break;
case 215:
#line 578 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miForwardRef); } break;
case 216:
#line 579 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miPreserveSig); } break;
case 217:
#line 580 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miRuntime); } break;
case 218:
#line 581 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miInternalCall); } break;
case 219:
#line 582 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miSynchronized); } break;
case 220:
#line 583 "asmparse.y"
{ yyval.implAttr = (CorMethodImpl) (yypvt[-1].implAttr | miNoInlining); } break;
case 221:
#line 586 "asmparse.y"
{ PASM->delArgNameList(PASM->m_firstArgName); PASM->m_firstArgName = NULL; } break;
case 222:
#line 590 "asmparse.y"
{ char c = (char)yypvt[-0].int32;
                                                              PASM->EmitByte(yypvt[-0].int32); } break;
case 223:
#line 592 "asmparse.y"
{ delete PASM->m_SEHD; PASM->m_SEHD = PASM->m_SEHDstack.POP(); } break;
case 224:
#line 593 "asmparse.y"
{ PASM->EmitMaxStack(yypvt[-0].int32); } break;
case 225:
#line 594 "asmparse.y"
{ PASM->EmitLocals(parser->MakeSig(IMAGE_CEE_CS_CALLCONV_LOCAL_SIG, 0, yypvt[-1].binstr)); } break;
case 226:
#line 595 "asmparse.y"
{ PASM->EmitZeroInit(); 
                                                              PASM->EmitLocals(parser->MakeSig(IMAGE_CEE_CS_CALLCONV_LOCAL_SIG, 0, yypvt[-1].binstr)); } break;
case 227:
#line 597 "asmparse.y"
{ PASM->EmitEntryPoint(); } break;
case 228:
#line 598 "asmparse.y"
{ PASM->EmitZeroInit(); } break;
case 231:
#line 601 "asmparse.y"
{ PASM->EmitLabel(yypvt[-1].string); } break;
case 236:
#line 606 "asmparse.y"
{ if(PASM->m_pCurMethod->m_dwExportOrdinal == 0xFFFFFFFF)
						                                          PASM->m_pCurMethod->m_dwExportOrdinal = yypvt[-1].int32;
														      else
															      PASM->report->warn("Duplicate .export directive, ignored\n");
															} break;
case 237:
#line 611 "asmparse.y"
{ if(PASM->m_pCurMethod->m_dwExportOrdinal == 0xFFFFFFFF)
						                                      {
						                                          PASM->m_pCurMethod->m_dwExportOrdinal = yypvt[-3].int32;
															      PASM->m_pCurMethod->m_szExportAlias = yypvt[-0].string;
															  }
														      else
															      PASM->report->warn("Duplicate .export directive, ignored\n");
															} break;
case 238:
#line 619 "asmparse.y"
{ PASM->m_pCurMethod->m_wVTEntry = (WORD)yypvt[-2].int32;
                                                              PASM->m_pCurMethod->m_wVTSlot = (WORD)yypvt[-0].int32; } break;
case 239:
#line 622 "asmparse.y"
{ PASM->AddMethodImpl(yypvt[-2].binstr,yypvt[-0].string,NULL,NULL,NULL); } break;
case 241:
#line 625 "asmparse.y"
{ if( yypvt[-2].int32 ) {
                                                                ARG_NAME_LIST* pAN=PASM->findArg(PASM->m_pCurMethod->m_firstArgName, yypvt[-2].int32 - 1);
                                                                if(pAN)
                                                                {
                                                                    PASM->m_pCustomDescrList = &(pAN->CustDList);
                                                                    pAN->pValue = yypvt[-0].binstr;
                                                                }
                                                                else
                                                                {
                                                                    PASM->m_pCustomDescrList = NULL;
                                                                    if(yypvt[-0].binstr) delete yypvt[-0].binstr;
                                                                }
                                                              } else {
                                                                PASM->m_pCustomDescrList = &(PASM->m_pCurMethod->m_RetCustDList);
                                                                PASM->m_pCurMethod->m_pRetValue = yypvt[-0].binstr;
                                                              }
                                                              PASM->m_tkCurrentCVOwner = 0;
                                                            } break;
case 242:
#line 645 "asmparse.y"
{ PASM->m_pCurMethod->CloseScope(); } break;
case 243:
#line 648 "asmparse.y"
{ PASM->m_pCurMethod->OpenScope(); } break;
case 247:
#line 658 "asmparse.y"
{ PASM->m_SEHD->tryTo = PASM->m_CurPC; } break;
case 248:
#line 659 "asmparse.y"
{ PASM->SetTryLabels(yypvt[-2].string, yypvt[-0].string); } break;
case 249:
#line 660 "asmparse.y"
{ if(PASM->m_SEHD) {PASM->m_SEHD->tryFrom = yypvt[-2].int32;
                                                              PASM->m_SEHD->tryTo = yypvt[-0].int32;} } break;
case 250:
#line 664 "asmparse.y"
{ PASM->NewSEHDescriptor();
                                                              PASM->m_SEHD->tryFrom = PASM->m_CurPC; } break;
case 251:
#line 669 "asmparse.y"
{ PASM->EmitTry(); } break;
case 252:
#line 670 "asmparse.y"
{ PASM->EmitTry(); } break;
case 253:
#line 671 "asmparse.y"
{ PASM->EmitTry(); } break;
case 254:
#line 672 "asmparse.y"
{ PASM->EmitTry(); } break;
case 255:
#line 676 "asmparse.y"
{ PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 256:
#line 677 "asmparse.y"
{ PASM->SetFilterLabel(yypvt[-0].string); 
                                                               PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 257:
#line 679 "asmparse.y"
{ PASM->m_SEHD->sehFilter = yypvt[-0].int32; 
                                                               PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 258:
#line 683 "asmparse.y"
{ PASM->m_SEHD->sehClause = COR_ILEXCEPTION_CLAUSE_FILTER;
                                                               PASM->m_SEHD->sehFilter = PASM->m_CurPC; } break;
case 259:
#line 687 "asmparse.y"
{ PASM->m_SEHD->sehClause = COR_ILEXCEPTION_CLAUSE_NONE;
                                                               PASM->SetCatchClass(yypvt[-0].string); 
                                                               PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 260:
#line 692 "asmparse.y"
{ PASM->m_SEHD->sehClause = COR_ILEXCEPTION_CLAUSE_FINALLY;
                                                               PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 261:
#line 696 "asmparse.y"
{ PASM->m_SEHD->sehClause = COR_ILEXCEPTION_CLAUSE_FAULT;
                                                               PASM->m_SEHD->sehHandler = PASM->m_CurPC; } break;
case 262:
#line 700 "asmparse.y"
{ PASM->m_SEHD->sehHandlerTo = PASM->m_CurPC; } break;
case 263:
#line 701 "asmparse.y"
{ PASM->SetHandlerLabels(yypvt[-2].string, yypvt[-0].string); } break;
case 264:
#line 702 "asmparse.y"
{ PASM->m_SEHD->sehHandler = yypvt[-2].int32;
                                                               PASM->m_SEHD->sehHandlerTo = yypvt[-0].int32; } break;
case 268:
#line 714 "asmparse.y"
{ PASM->EmitDataLabel(yypvt[-1].string); } break;
case 270:
#line 718 "asmparse.y"
{ PASM->SetDataSection(); } break;
case 271:
#line 719 "asmparse.y"
{ PASM->SetTLSSection(); } break;
case 276:
#line 730 "asmparse.y"
{ yyval.int32 = 1; } break;
case 277:
#line 731 "asmparse.y"
{ FAIL_UNLESS(yypvt[-1].int32 > 0, ("Illegal item count: %d\n",yypvt[-1].int32)); yyval.int32 = yypvt[-1].int32; } break;
case 278:
#line 734 "asmparse.y"
{ PASM->EmitDataString(yypvt[-1].binstr); } break;
case 279:
#line 735 "asmparse.y"
{ PASM->EmitDD(yypvt[-1].string); } break;
case 280:
#line 736 "asmparse.y"
{ PASM->EmitData(yypvt[-1].binstr->ptr(),yypvt[-1].binstr->length()); } break;
case 281:
#line 738 "asmparse.y"
{ float f = (float) (*yypvt[-2].float64); float* pf = new float[yypvt[-0].int32];
                                                               for(int i=0; i < yypvt[-0].int32; i++) pf[i] = f;
                                                               PASM->EmitData(pf, sizeof(float)*yypvt[-0].int32); delete yypvt[-2].float64; delete pf; } break;
case 282:
#line 742 "asmparse.y"
{ double* pd = new double[yypvt[-0].int32];
                                                               for(int i=0; i<yypvt[-0].int32; i++) pd[i] = *(yypvt[-2].float64);
                                                               PASM->EmitData(pd, sizeof(double)*yypvt[-0].int32); delete yypvt[-2].float64; delete pd; } break;
case 283:
#line 746 "asmparse.y"
{ __int64* pll = new __int64[yypvt[-0].int32];
                                                               for(int i=0; i<yypvt[-0].int32; i++) pll[i] = *(yypvt[-2].int64);
                                                               PASM->EmitData(pll, sizeof(__int64)*yypvt[-0].int32); delete yypvt[-2].int64; delete pll; } break;
case 284:
#line 750 "asmparse.y"
{ __int32* pl = new __int32[yypvt[-0].int32];
                                                               for(int i=0; i<yypvt[-0].int32; i++) pl[i] = yypvt[-2].int32;
                                                               PASM->EmitData(pl, sizeof(__int32)*yypvt[-0].int32); delete pl; } break;
case 285:
#line 754 "asmparse.y"
{ __int16 i = (__int16) yypvt[-2].int32; FAIL_UNLESS(i == yypvt[-2].int32, ("Value %d too big\n", yypvt[-2].int32));
                                                               __int16* ps = new __int16[yypvt[-0].int32];
                                                               for(int j=0; j<yypvt[-0].int32; j++) ps[j] = i;
                                                               PASM->EmitData(ps, sizeof(__int16)*yypvt[-0].int32); delete ps; } break;
case 286:
#line 759 "asmparse.y"
{ __int8 i = (__int8) yypvt[-2].int32; FAIL_UNLESS(i == yypvt[-2].int32, ("Value %d too big\n", yypvt[-2].int32));
                                                               __int8* pb = new __int8[yypvt[-0].int32];
                                                               for(int j=0; j<yypvt[-0].int32; j++) pb[j] = i;
                                                               PASM->EmitData(pb, sizeof(__int8)*yypvt[-0].int32); delete pb; } break;
case 287:
#line 763 "asmparse.y"
{ float* pf = new float[yypvt[-0].int32];
                                                               PASM->EmitData(pf, sizeof(float)*yypvt[-0].int32); delete pf; } break;
case 288:
#line 765 "asmparse.y"
{ double* pd = new double[yypvt[-0].int32];
                                                               PASM->EmitData(pd, sizeof(double)*yypvt[-0].int32); delete pd; } break;
case 289:
#line 767 "asmparse.y"
{ __int64* pll = new __int64[yypvt[-0].int32];
                                                               PASM->EmitData(pll, sizeof(__int64)*yypvt[-0].int32); delete pll; } break;
case 290:
#line 769 "asmparse.y"
{ __int32* pl = new __int32[yypvt[-0].int32];
                                                               PASM->EmitData(pl, sizeof(__int32)*yypvt[-0].int32); delete pl; } break;
case 291:
#line 771 "asmparse.y"
{ __int16* ps = new __int16[yypvt[-0].int32];
                                                               PASM->EmitData(ps, sizeof(__int16)*yypvt[-0].int32); delete ps; } break;
case 292:
#line 773 "asmparse.y"
{ __int8* pb = new __int8[yypvt[-0].int32];
                                                               PASM->EmitData(pb, sizeof(__int8)*yypvt[-0].int32); delete pb; } break;
case 293:
#line 777 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R4); 
                                                               float f = (float) (*yypvt[-1].float64); yyval.binstr->appendInt32(*((int*)&f)); delete yypvt[-1].float64; } break;
case 294:
#line 779 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R8); 
                                                               yyval.binstr->appendInt64((__int64 *)yypvt[-1].float64); delete yypvt[-1].float64; } break;
case 295:
#line 781 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R4); 
                                                               int f = *((int*)yypvt[-1].int64); 
                                                               yyval.binstr->appendInt32(f); delete yypvt[-1].int64; } break;
case 296:
#line 784 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R8); 
                                                               yyval.binstr->appendInt64((__int64 *)yypvt[-1].int64); delete yypvt[-1].int64; } break;
case 297:
#line 786 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I8); 
                                                               yyval.binstr->appendInt64((__int64 *)yypvt[-1].int64); delete yypvt[-1].int64; } break;
case 298:
#line 788 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I4); 
                                                               yyval.binstr->appendInt32(*((__int32*)yypvt[-1].int64)); delete yypvt[-1].int64;} break;
case 299:
#line 790 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I2); 
                                                               yyval.binstr->appendInt16(*((__int16*)yypvt[-1].int64)); delete yypvt[-1].int64;} break;
case 300:
#line 792 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_CHAR); 
                                                               yyval.binstr->appendInt16((int)*((unsigned __int16*)yypvt[-1].int64)); delete yypvt[-1].int64;} break;
case 301:
#line 794 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I1); 
                                                               yyval.binstr->appendInt8(*((__int8*)yypvt[-1].int64)); delete yypvt[-1].int64; } break;
case 302:
#line 796 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_BOOLEAN); 
                                                               yyval.binstr->appendInt8(yypvt[-1].int32);} break;
case 303:
#line 798 "asmparse.y"
{ yyval.binstr = BinStrToUnicode(yypvt[-0].binstr); yyval.binstr->insertInt8(ELEMENT_TYPE_STRING);} break;
case 304:
#line 799 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_STRING);
                                                               yyval.binstr->append(yypvt[-1].binstr); delete yypvt[-1].binstr;} break;
case 305:
#line 801 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_CLASS); 
																yyval.binstr->appendInt32(0); } break;
case 306:
#line 805 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 307:
#line 808 "asmparse.y"
{ yyval.binstr = new BinStr(); } break;
case 308:
#line 809 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 309:
#line 812 "asmparse.y"
{ __int8 i = (__int8) yypvt[-0].int32; yyval.binstr = new BinStr(); yyval.binstr->appendInt8(i); } break;
case 310:
#line 813 "asmparse.y"
{ __int8 i = (__int8) yypvt[-0].int32; yyval.binstr = yypvt[-1].binstr; yyval.binstr->appendInt8(i); } break;
case 311:
#line 816 "asmparse.y"
{ yyval.instr = yypvt[-1].instr; bParsingByteArray = TRUE; } break;
case 312:
#line 819 "asmparse.y"
{ yyval.instr = yypvt[-0].instr; iOpcodeLen = PASM->OpcodeLen(yypvt[-0].instr); } break;
case 313:
#line 822 "asmparse.y"
{ palDummy = PASM->m_firstArgName;
                                                               PASM->m_firstArgName = NULL; } break;
case 314:
#line 826 "asmparse.y"
{ PASM->EmitOpcode(yypvt[-0].instr); } break;
case 315:
#line 827 "asmparse.y"
{ PASM->EmitInstrVar(yypvt[-1].instr, yypvt[-0].int32); } break;
case 316:
#line 828 "asmparse.y"
{ PASM->EmitInstrVarByName(yypvt[-1].instr, yypvt[-0].string); } break;
case 317:
#line 829 "asmparse.y"
{ PASM->EmitInstrI(yypvt[-1].instr, yypvt[-0].int32); } break;
case 318:
#line 830 "asmparse.y"
{ PASM->EmitInstrI8(yypvt[-1].instr, yypvt[-0].int64); } break;
case 319:
#line 831 "asmparse.y"
{ PASM->EmitInstrR(yypvt[-1].instr, yypvt[-0].float64); delete (yypvt[-0].float64);} break;
case 320:
#line 832 "asmparse.y"
{ double f = (double) (*yypvt[-0].int64); PASM->EmitInstrR(yypvt[-1].instr, &f); } break;
case 321:
#line 833 "asmparse.y"
{ unsigned L = yypvt[-1].binstr->length();
                                                               FAIL_UNLESS(L >= sizeof(float), ("%d hexbytes, must be at least %d\n",
                                                                           L,sizeof(float))); 
                                                               if(L < sizeof(float)) {YYERROR; } 
                                                               else {
                                                                   double f = (L >= sizeof(double)) ? *((double *)(yypvt[-1].binstr->ptr()))
                                                                                    : (double)(*(float *)(yypvt[-1].binstr->ptr())); 
                                                                   PASM->EmitInstrR(yypvt[-2].instr,&f); }
                                                               delete yypvt[-1].binstr; } break;
case 322:
#line 842 "asmparse.y"
{ PASM->EmitInstrBrOffset(yypvt[-1].instr, yypvt[-0].int32); } break;
case 323:
#line 843 "asmparse.y"
{ PASM->EmitInstrBrTarget(yypvt[-1].instr, yypvt[-0].string); } break;
case 324:
#line 845 "asmparse.y"
{ if(yypvt[-8].instr->opcode == CEE_NEWOBJ || yypvt[-8].instr->opcode == CEE_CALLVIRT)
                                                                   yypvt[-7].int32 = yypvt[-7].int32 | IMAGE_CEE_CS_CALLCONV_HASTHIS; 
                                                               mdToken mr = PASM->MakeMemberRef(yypvt[-5].binstr, yypvt[-3].string, parser->MakeSig(yypvt[-7].int32, yypvt[-6].binstr, yypvt[-1].binstr),PASM->OpcodeLen(yypvt[-8].instr));
                                                               PASM->EmitInstrI(yypvt[-8].instr,mr);
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
                                                             } break;
case 325:
#line 853 "asmparse.y"
{ if(yypvt[-6].instr->opcode == CEE_NEWOBJ || yypvt[-6].instr->opcode == CEE_CALLVIRT)
                                                                   yypvt[-5].int32 = yypvt[-5].int32 | IMAGE_CEE_CS_CALLCONV_HASTHIS; 
                                                               mdToken mr = PASM->MakeMemberRef(NULL, yypvt[-3].string, parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr),PASM->OpcodeLen(yypvt[-6].instr));
                                                               PASM->EmitInstrI(yypvt[-6].instr,mr);
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
                                                             } break;
case 326:
#line 861 "asmparse.y"
{ yypvt[-3].binstr->insertInt8(IMAGE_CEE_CS_CALLCONV_FIELD); 
                                                               mdToken mr = PASM->MakeMemberRef(yypvt[-2].binstr, yypvt[-0].string, yypvt[-3].binstr, PASM->OpcodeLen(yypvt[-4].instr));
                                                               PASM->EmitInstrI(yypvt[-4].instr,mr);
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
                                                             } break;
case 327:
#line 868 "asmparse.y"
{ yypvt[-1].binstr->insertInt8(IMAGE_CEE_CS_CALLCONV_FIELD); 
                                                               mdToken mr = PASM->MakeMemberRef(NULL, yypvt[-0].string, yypvt[-1].binstr, PASM->OpcodeLen(yypvt[-2].instr));
                                                               PASM->EmitInstrI(yypvt[-2].instr,mr);
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
                                                             } break;
case 328:
#line 874 "asmparse.y"
{ mdToken mr = PASM->MakeTypeRef(yypvt[-0].binstr);
                                                               PASM->EmitInstrI(yypvt[-1].instr, mr); 
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
                                                             } break;
case 329:
#line 879 "asmparse.y"
{ PASM->EmitInstrStringLiteral(yypvt[-1].instr, yypvt[-0].binstr,TRUE); } break;
case 330:
#line 881 "asmparse.y"
{ PASM->EmitInstrStringLiteral(yypvt[-3].instr, yypvt[-1].binstr,FALSE); } break;
case 331:
#line 883 "asmparse.y"
{ PASM->EmitInstrSig(yypvt[-5].instr, parser->MakeSig(yypvt[-4].int32, yypvt[-3].binstr, yypvt[-1].binstr)); } break;
case 332:
#line 884 "asmparse.y"
{ PASM->EmitInstrRVA(yypvt[-1].instr, yypvt[-0].string, TRUE); 
                                                               PASM->report->warn("Deprecated instruction 'ldptr'\n"); } break;
case 333:
#line 886 "asmparse.y"
{ PASM->EmitInstrRVA(yypvt[-1].instr, (char *)yypvt[-0].int32, FALSE); 
                                                               PASM->report->warn("Deprecated instruction 'ldptr'\n"); } break;
case 334:
#line 889 "asmparse.y"
{ mdToken mr = yypvt[-0].int32;
                                                               PASM->EmitInstrI(yypvt[-1].instr,mr);
                                                               PASM->m_tkCurrentCVOwner = mr;
                                                               PASM->m_pCustomDescrList = NULL;
															   iOpcodeLen = 0;
                                                             } break;
case 335:
#line 895 "asmparse.y"
{ PASM->EmitInstrSwitch(yypvt[-3].instr, yypvt[-1].labels); } break;
case 336:
#line 896 "asmparse.y"
{ PASM->EmitInstrPhi(yypvt[-1].instr, yypvt[-0].binstr); } break;
case 337:
#line 899 "asmparse.y"
{ yyval.binstr = new BinStr(); } break;
case 338:
#line 900 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr;} break;
case 339:
#line 903 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 340:
#line 904 "asmparse.y"
{ yyval.binstr = yypvt[-2].binstr; yyval.binstr->append(yypvt[-0].binstr); delete yypvt[-0].binstr; } break;
case 341:
#line 907 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_SENTINEL); } break;
case 342:
#line 908 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->append(yypvt[-0].binstr); PASM->addArgName("", yypvt[-0].binstr, NULL, yypvt[-1].int32); } break;
case 343:
#line 909 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->append(yypvt[-1].binstr); PASM->addArgName(yypvt[-0].string, yypvt[-1].binstr, NULL, yypvt[-2].int32); } break;
case 344:
#line 911 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->append(yypvt[-4].binstr); PASM->addArgName("", yypvt[-4].binstr, yypvt[-1].binstr, yypvt[-5].int32); } break;
case 345:
#line 913 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->append(yypvt[-5].binstr); PASM->addArgName(yypvt[-0].string, yypvt[-5].binstr, yypvt[-2].binstr, yypvt[-6].int32); } break;
case 346:
#line 916 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 347:
#line 917 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 348:
#line 918 "asmparse.y"
{ yyval.string = newStringWDel(yypvt[-2].string, newString("."), yypvt[-0].string); } break;
case 349:
#line 921 "asmparse.y"
{ yyval.string = newStringWDel(yypvt[-2].string, newString("^"), yypvt[-0].string); } break;
case 350:
#line 922 "asmparse.y"
{ yyval.string = newStringWDel(yypvt[-2].string, newString("~"), yypvt[-0].string); } break;
case 351:
#line 923 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 352:
#line 926 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 353:
#line 927 "asmparse.y"
{ yyval.string = newStringWDel(yypvt[-2].string, newString("/"), yypvt[-0].string); } break;
case 354:
#line 930 "asmparse.y"
{ unsigned len = (unsigned int)strlen(yypvt[-0].string)+1;
                                                                yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_NAME);
                                                                memcpy(yyval.binstr->getBuff(len), yypvt[-0].string, len);
                                                                delete yypvt[-0].string;
                                                              } break;
case 355:
#line 935 "asmparse.y"
{ unsigned len = (unsigned int)strlen(yypvt[-1].string);
                                                                yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_NAME);
                                                                memcpy(yyval.binstr->getBuff(len), yypvt[-1].string, len);
                                                                delete yypvt[-1].string;
                                                                yyval.binstr->appendInt8('^');
                                                                yyval.binstr->appendInt8(0); 
                                                              } break;
case 356:
#line 942 "asmparse.y"
{ unsigned len = (unsigned int)strlen(yypvt[-1].string);
                                                                yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_NAME);
                                                                memcpy(yyval.binstr->getBuff(len), yypvt[-1].string, len);
                                                                delete yypvt[-1].string;
                                                                yyval.binstr->appendInt8('~');
                                                                yyval.binstr->appendInt8(0); 
                                                              } break;
case 357:
#line 949 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 358:
#line 952 "asmparse.y"
{ yyval.int32 = (yypvt[-0].int32 | IMAGE_CEE_CS_CALLCONV_HASTHIS); } break;
case 359:
#line 953 "asmparse.y"
{ yyval.int32 = (yypvt[-0].int32 | IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS); } break;
case 360:
#line 954 "asmparse.y"
{ yyval.int32 = yypvt[-0].int32; } break;
case 361:
#line 957 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_DEFAULT; } break;
case 362:
#line 958 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_DEFAULT; } break;
case 363:
#line 959 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_VARARG; } break;
case 364:
#line 960 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_C; } break;
case 365:
#line 961 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_STDCALL; } break;
case 366:
#line 962 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_THISCALL; } break;
case 367:
#line 963 "asmparse.y"
{ yyval.int32 = IMAGE_CEE_CS_CALLCONV_FASTCALL; } break;
case 368:
#line 966 "asmparse.y"
{ yyval.binstr = new BinStr(); } break;
case 369:
#line 968 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_CUSTOMMARSHALER);
                                                                corEmitInt(yyval.binstr,yypvt[-7].binstr->length()); yyval.binstr->append(yypvt[-7].binstr);
                                                                corEmitInt(yyval.binstr,yypvt[-5].binstr->length()); yyval.binstr->append(yypvt[-5].binstr);
                                                                corEmitInt(yyval.binstr,yypvt[-3].binstr->length()); yyval.binstr->append(yypvt[-3].binstr);
                                                                corEmitInt(yyval.binstr,yypvt[-1].binstr->length()); yyval.binstr->append(yypvt[-1].binstr); 
																PASM->report->warn("Deprecated 4-string form of custom marshaler, first two strings ignored\n");} break;
case 370:
#line 975 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_CUSTOMMARSHALER);
                                                                corEmitInt(yyval.binstr,0);
                                                                corEmitInt(yyval.binstr,0);
                                                                corEmitInt(yyval.binstr,yypvt[-3].binstr->length()); yyval.binstr->append(yypvt[-3].binstr);
                                                                corEmitInt(yyval.binstr,yypvt[-1].binstr->length()); yyval.binstr->append(yypvt[-1].binstr); } break;
case 371:
#line 980 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_FIXEDSYSSTRING);
                                                                corEmitInt(yyval.binstr,yypvt[-1].int32); } break;
case 372:
#line 982 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_FIXEDARRAY);
                                                                corEmitInt(yyval.binstr,yypvt[-1].int32); } break;
case 373:
#line 984 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_VARIANT); 
																PASM->report->warn("Deprecated native type 'variant'\n"); } break;
case 374:
#line 986 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_CURRENCY); } break;
case 375:
#line 987 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_SYSCHAR); 
																PASM->report->warn("Deprecated native type 'syschar'\n"); } break;
case 376:
#line 989 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_VOID); 
																PASM->report->warn("Deprecated native type 'void'\n"); } break;
case 377:
#line 991 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_BOOLEAN); } break;
case 378:
#line 992 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_I1); } break;
case 379:
#line 993 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_I2); } break;
case 380:
#line 994 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_I4); } break;
case 381:
#line 995 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_I8); } break;
case 382:
#line 996 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_R4); } break;
case 383:
#line 997 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_R8); } break;
case 384:
#line 998 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_ERROR); } break;
case 385:
#line 999 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_U1); } break;
case 386:
#line 1000 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_U2); } break;
case 387:
#line 1001 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_U4); } break;
case 388:
#line 1002 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_U8); } break;
case 389:
#line 1003 "asmparse.y"
{ yyval.binstr = yypvt[-1].binstr; yyval.binstr->insertInt8(NATIVE_TYPE_PTR); 
																PASM->report->warn("Deprecated native type '*'\n"); } break;
case 390:
#line 1005 "asmparse.y"
{ yyval.binstr = yypvt[-2].binstr; if(yyval.binstr->length()==0) yyval.binstr->appendInt8(NATIVE_TYPE_MAX);
                                                                yyval.binstr->insertInt8(NATIVE_TYPE_ARRAY); } break;
case 391:
#line 1007 "asmparse.y"
{ yyval.binstr = yypvt[-3].binstr; if(yyval.binstr->length()==0) yyval.binstr->appendInt8(NATIVE_TYPE_MAX); 
                                                                yyval.binstr->insertInt8(NATIVE_TYPE_ARRAY);
                                                                corEmitInt(yyval.binstr,0);
                                                                corEmitInt(yyval.binstr,yypvt[-1].int32); } break;
case 392:
#line 1011 "asmparse.y"
{ yyval.binstr = yypvt[-5].binstr; if(yyval.binstr->length()==0) yyval.binstr->appendInt8(NATIVE_TYPE_MAX); 
                                                                yyval.binstr->insertInt8(NATIVE_TYPE_ARRAY);
                                                                corEmitInt(yyval.binstr,yypvt[-1].int32);
                                                                corEmitInt(yyval.binstr,yypvt[-3].int32); } break;
case 393:
#line 1015 "asmparse.y"
{ yyval.binstr = yypvt[-4].binstr; if(yyval.binstr->length()==0) yyval.binstr->appendInt8(NATIVE_TYPE_MAX); 
                                                                yyval.binstr->insertInt8(NATIVE_TYPE_ARRAY);
                                                                corEmitInt(yyval.binstr,yypvt[-1].int32); } break;
case 394:
#line 1018 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_DECIMAL); 
																PASM->report->warn("Deprecated native type 'decimal'\n"); } break;
case 395:
#line 1020 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_DATE); 
																PASM->report->warn("Deprecated native type 'date'\n"); } break;
case 396:
#line 1022 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_BSTR); } break;
case 397:
#line 1023 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_LPSTR); } break;
case 398:
#line 1024 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_LPWSTR); } break;
case 399:
#line 1025 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_LPTSTR); } break;
case 400:
#line 1026 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_OBJECTREF); 
																PASM->report->warn("Deprecated native type 'objectref'\n"); } break;
case 401:
#line 1028 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_IUNKNOWN); } break;
case 402:
#line 1029 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_IDISPATCH); } break;
case 403:
#line 1030 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_STRUCT); } break;
case 404:
#line 1031 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_INTF); } break;
case 405:
#line 1032 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_SAFEARRAY); 
                                                                corEmitInt(yyval.binstr,yypvt[-0].int32); 
                                                                corEmitInt(yyval.binstr,0);} break;
case 406:
#line 1035 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_SAFEARRAY); 
                                                                corEmitInt(yyval.binstr,yypvt[-2].int32); 
                                                                corEmitInt(yyval.binstr,yypvt[-0].binstr->length()); yyval.binstr->append(yypvt[-0].binstr); } break;
case 407:
#line 1039 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_INT); } break;
case 408:
#line 1040 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_UINT); } break;
case 409:
#line 1041 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_NESTEDSTRUCT); 
																PASM->report->warn("Deprecated native type 'nested struct'\n"); } break;
case 410:
#line 1043 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_BYVALSTR); } break;
case 411:
#line 1044 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_ANSIBSTR); } break;
case 412:
#line 1045 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_TBSTR); } break;
case 413:
#line 1046 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_VARIANTBOOL); } break;
case 414:
#line 1047 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_FUNC); } break;
case 415:
#line 1048 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_ASANY); } break;
case 416:
#line 1049 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(NATIVE_TYPE_LPSTRUCT); } break;
case 417:
#line 1052 "asmparse.y"
{ yyval.int32 = VT_EMPTY; } break;
case 418:
#line 1053 "asmparse.y"
{ yyval.int32 = VT_NULL; } break;
case 419:
#line 1054 "asmparse.y"
{ yyval.int32 = VT_VARIANT; } break;
case 420:
#line 1055 "asmparse.y"
{ yyval.int32 = VT_CY; } break;
case 421:
#line 1056 "asmparse.y"
{ yyval.int32 = VT_VOID; } break;
case 422:
#line 1057 "asmparse.y"
{ yyval.int32 = VT_BOOL; } break;
case 423:
#line 1058 "asmparse.y"
{ yyval.int32 = VT_I1; } break;
case 424:
#line 1059 "asmparse.y"
{ yyval.int32 = VT_I2; } break;
case 425:
#line 1060 "asmparse.y"
{ yyval.int32 = VT_I4; } break;
case 426:
#line 1061 "asmparse.y"
{ yyval.int32 = VT_I8; } break;
case 427:
#line 1062 "asmparse.y"
{ yyval.int32 = VT_R4; } break;
case 428:
#line 1063 "asmparse.y"
{ yyval.int32 = VT_R8; } break;
case 429:
#line 1064 "asmparse.y"
{ yyval.int32 = VT_UI1; } break;
case 430:
#line 1065 "asmparse.y"
{ yyval.int32 = VT_UI2; } break;
case 431:
#line 1066 "asmparse.y"
{ yyval.int32 = VT_UI4; } break;
case 432:
#line 1067 "asmparse.y"
{ yyval.int32 = VT_UI8; } break;
case 433:
#line 1068 "asmparse.y"
{ yyval.int32 = VT_PTR; } break;
case 434:
#line 1069 "asmparse.y"
{ yyval.int32 = yypvt[-2].int32 | VT_ARRAY; } break;
case 435:
#line 1070 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | VT_VECTOR; } break;
case 436:
#line 1071 "asmparse.y"
{ yyval.int32 = yypvt[-1].int32 | VT_BYREF; } break;
case 437:
#line 1072 "asmparse.y"
{ yyval.int32 = VT_DECIMAL; } break;
case 438:
#line 1073 "asmparse.y"
{ yyval.int32 = VT_DATE; } break;
case 439:
#line 1074 "asmparse.y"
{ yyval.int32 = VT_BSTR; } break;
case 440:
#line 1075 "asmparse.y"
{ yyval.int32 = VT_LPSTR; } break;
case 441:
#line 1076 "asmparse.y"
{ yyval.int32 = VT_LPWSTR; } break;
case 442:
#line 1077 "asmparse.y"
{ yyval.int32 = VT_UNKNOWN; } break;
case 443:
#line 1078 "asmparse.y"
{ yyval.int32 = VT_DISPATCH; } break;
case 444:
#line 1079 "asmparse.y"
{ yyval.int32 = VT_SAFEARRAY; } break;
case 445:
#line 1080 "asmparse.y"
{ yyval.int32 = VT_INT; } break;
case 446:
#line 1081 "asmparse.y"
{ yyval.int32 = VT_UINT; } break;
case 447:
#line 1082 "asmparse.y"
{ yyval.int32 = VT_ERROR; } break;
case 448:
#line 1083 "asmparse.y"
{ yyval.int32 = VT_HRESULT; } break;
case 449:
#line 1084 "asmparse.y"
{ yyval.int32 = VT_CARRAY; } break;
case 450:
#line 1085 "asmparse.y"
{ yyval.int32 = VT_USERDEFINED; } break;
case 451:
#line 1086 "asmparse.y"
{ yyval.int32 = VT_RECORD; } break;
case 452:
#line 1087 "asmparse.y"
{ yyval.int32 = VT_FILETIME; } break;
case 453:
#line 1088 "asmparse.y"
{ yyval.int32 = VT_BLOB; } break;
case 454:
#line 1089 "asmparse.y"
{ yyval.int32 = VT_STREAM; } break;
case 455:
#line 1090 "asmparse.y"
{ yyval.int32 = VT_STORAGE; } break;
case 456:
#line 1091 "asmparse.y"
{ yyval.int32 = VT_STREAMED_OBJECT; } break;
case 457:
#line 1092 "asmparse.y"
{ yyval.int32 = VT_STORED_OBJECT; } break;
case 458:
#line 1093 "asmparse.y"
{ yyval.int32 = VT_BLOB_OBJECT; } break;
case 459:
#line 1094 "asmparse.y"
{ yyval.int32 = VT_CF; } break;
case 460:
#line 1095 "asmparse.y"
{ yyval.int32 = VT_CLSID; } break;
case 461:
#line 1098 "asmparse.y"
{ if((strcmp(yypvt[-0].string,"System.String")==0) ||
																   (strcmp(yypvt[-0].string,"mscorlib^System.String")==0))
                                                                {     yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_STRING); }
                                                                else if((strcmp(yypvt[-0].string,"System.Object")==0) ||
																   (strcmp(yypvt[-0].string,"mscorlib^System.Object")==0))
                                                                {     yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_OBJECT); }
                                                                else yyval.binstr = parser->MakeTypeClass(ELEMENT_TYPE_CLASS, yypvt[-0].string); } break;
case 462:
#line 1105 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_OBJECT); } break;
case 463:
#line 1106 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_STRING); } break;
case 464:
#line 1107 "asmparse.y"
{ yyval.binstr = parser->MakeTypeClass(ELEMENT_TYPE_VALUETYPE, yypvt[-0].string); } break;
case 465:
#line 1108 "asmparse.y"
{ yyval.binstr = parser->MakeTypeClass(ELEMENT_TYPE_VALUETYPE, yypvt[-0].string); } break;
case 466:
#line 1109 "asmparse.y"
{ yyval.binstr = yypvt[-2].binstr; yyval.binstr->insertInt8(ELEMENT_TYPE_SZARRAY); } break;
case 467:
#line 1110 "asmparse.y"
{ yyval.binstr = parser->MakeTypeArray(yypvt[-3].binstr, yypvt[-1].binstr); } break;
case 468:
#line 1114 "asmparse.y"
{ yyval.binstr = yypvt[-1].binstr; yyval.binstr->insertInt8(ELEMENT_TYPE_BYREF); } break;
case 469:
#line 1115 "asmparse.y"
{ yyval.binstr = yypvt[-1].binstr; yyval.binstr->insertInt8(ELEMENT_TYPE_PTR); } break;
case 470:
#line 1116 "asmparse.y"
{ yyval.binstr = yypvt[-1].binstr; yyval.binstr->insertInt8(ELEMENT_TYPE_PINNED); } break;
case 471:
#line 1117 "asmparse.y"
{ yyval.binstr = parser->MakeTypeClass(ELEMENT_TYPE_CMOD_REQD, yypvt[-1].string);
                                                                yyval.binstr->append(yypvt[-4].binstr); } break;
case 472:
#line 1119 "asmparse.y"
{ yyval.binstr = parser->MakeTypeClass(ELEMENT_TYPE_CMOD_OPT, yypvt[-1].string);
                                                                yyval.binstr->append(yypvt[-4].binstr); } break;
case 473:
#line 1121 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_VAR); yyval.binstr->appendInt8(yypvt[-0].int32); 
                                                                PASM->report->warn("Deprecated type modifier '!'(ELEMENT_TYPE_VAR)\n"); } break;
case 474:
#line 1124 "asmparse.y"
{ yyval.binstr = parser->MakeSig(yypvt[-5].int32, yypvt[-4].binstr, yypvt[-1].binstr);
                                                                yyval.binstr->insertInt8(ELEMENT_TYPE_FNPTR); 
                                                                delete PASM->m_firstArgName;
                                                                PASM->m_firstArgName = palDummy;
                                                              } break;
case 475:
#line 1129 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_TYPEDBYREF); } break;
case 476:
#line 1130 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_CHAR); } break;
case 477:
#line 1131 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_VOID); } break;
case 478:
#line 1132 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_BOOLEAN); } break;
case 479:
#line 1133 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I1); } break;
case 480:
#line 1134 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I2); } break;
case 481:
#line 1135 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I4); } break;
case 482:
#line 1136 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I8); } break;
case 483:
#line 1137 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R4); } break;
case 484:
#line 1138 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R8); } break;
case 485:
#line 1139 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_U1); } break;
case 486:
#line 1140 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_U2); } break;
case 487:
#line 1141 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_U4); } break;
case 488:
#line 1142 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_U8); } break;
case 489:
#line 1143 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_I); } break;
case 490:
#line 1144 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_U); } break;
case 491:
#line 1145 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt8(ELEMENT_TYPE_R); } break;
case 492:
#line 1148 "asmparse.y"
{ yyval.binstr = yypvt[-0].binstr; } break;
case 493:
#line 1149 "asmparse.y"
{ yyval.binstr = yypvt[-2].binstr; yypvt[-2].binstr->append(yypvt[-0].binstr); delete yypvt[-0].binstr; } break;
case 494:
#line 1152 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt32(0x7FFFFFFF); yyval.binstr->appendInt32(0x7FFFFFFF);  } break;
case 495:
#line 1153 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt32(0x7FFFFFFF); yyval.binstr->appendInt32(0x7FFFFFFF);  } break;
case 496:
#line 1154 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt32(0); yyval.binstr->appendInt32(yypvt[-0].int32); } break;
case 497:
#line 1155 "asmparse.y"
{ FAIL_UNLESS(yypvt[-2].int32 <= yypvt[-0].int32, ("lower bound %d must be <= upper bound %d\n", yypvt[-2].int32, yypvt[-0].int32));
                                                                if (yypvt[-2].int32 > yypvt[-0].int32) { YYERROR; };        
                                                                yyval.binstr = new BinStr(); yyval.binstr->appendInt32(yypvt[-2].int32); yyval.binstr->appendInt32(yypvt[-0].int32-yypvt[-2].int32+1); } break;
case 498:
#line 1158 "asmparse.y"
{ yyval.binstr = new BinStr(); yyval.binstr->appendInt32(yypvt[-1].int32); yyval.binstr->appendInt32(0x7FFFFFFF); } break;
case 499:
#line 1161 "asmparse.y"
{ yyval.labels = 0; } break;
case 500:
#line 1162 "asmparse.y"
{ yyval.labels = new Labels(yypvt[-2].string, yypvt[-0].labels, TRUE); } break;
case 501:
#line 1163 "asmparse.y"
{ yyval.labels = new Labels((char *)yypvt[-2].int32, yypvt[-0].labels, FALSE); } break;
case 502:
#line 1164 "asmparse.y"
{ yyval.labels = new Labels(yypvt[-0].string, NULL, TRUE); } break;
case 503:
#line 1165 "asmparse.y"
{ yyval.labels = new Labels((char *)yypvt[-0].int32, NULL, FALSE); } break;
case 504:
#line 1169 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 505:
#line 1170 "asmparse.y"
{ yyval.string = yypvt[-0].string; } break;
case 506:
#line 1173 "asmparse.y"
{ yyval.binstr = new BinStr();  } break;
case 507:
#line 1174 "asmparse.y"
{ FAIL_UNLESS((yypvt[-0].int32 == (__int16) yypvt[-0].int32), ("Value %d too big\n", yypvt[-0].int32));
                                                                yyval.binstr = yypvt[-1].binstr; yyval.binstr->appendInt8(yypvt[-0].int32); yyval.binstr->appendInt8(yypvt[-0].int32 >> 8); } break;
case 508:
#line 1178 "asmparse.y"
{ yyval.int32 = (__int32)(*yypvt[-0].int64); delete yypvt[-0].int64; } break;
case 509:
#line 1181 "asmparse.y"
{ yyval.int64 = yypvt[-0].int64; } break;
case 510:
#line 1184 "asmparse.y"
{ yyval.float64 = yypvt[-0].float64; } break;
case 511:
#line 1185 "asmparse.y"
{ float f; *((__int32*) (&f)) = yypvt[-1].int32; yyval.float64 = new double(f); } break;
case 512:
#line 1186 "asmparse.y"
{ yyval.float64 = (double*) yypvt[-1].int64; } break;
case 513:
#line 1190 "asmparse.y"
{ PASM->AddPermissionDecl(yypvt[-4].secAct, yypvt[-3].binstr, yypvt[-1].pair); } break;
case 514:
#line 1191 "asmparse.y"
{ PASM->AddPermissionDecl(yypvt[-1].secAct, yypvt[-0].binstr, NULL); } break;
case 515:
#line 1192 "asmparse.y"
{ PASM->AddPermissionSetDecl(yypvt[-2].secAct, yypvt[-1].binstr); } break;
case 516:
#line 1195 "asmparse.y"
{ yyval.secAct = yypvt[-2].secAct; bParsingByteArray = TRUE; } break;
case 517:
#line 1198 "asmparse.y"
{ yyval.pair = yypvt[-0].pair; } break;
case 518:
#line 1199 "asmparse.y"
{ yyval.pair = yypvt[-2].pair->Concat(yypvt[-0].pair); } break;
case 519:
#line 1202 "asmparse.y"
{ yypvt[-2].binstr->appendInt8(0); yyval.pair = new NVPair(yypvt[-2].binstr, yypvt[-0].binstr); } break;
case 520:
#line 1205 "asmparse.y"
{ yyval.int32 = 1; } break;
case 521:
#line 1206 "asmparse.y"
{ yyval.int32 = 0; } break;
case 522:
#line 1209 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_BOOLEAN);
                                                                yyval.binstr->appendInt8(yypvt[-0].int32); } break;
case 523:
#line 1212 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_I4);
                                                                yyval.binstr->appendInt32(yypvt[-0].int32); } break;
case 524:
#line 1215 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_I4);
                                                                yyval.binstr->appendInt32(yypvt[-1].int32); } break;
case 525:
#line 1218 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_STRING);
                                                                yyval.binstr->append(yypvt[-0].binstr); delete yypvt[-0].binstr;
                                                                yyval.binstr->appendInt8(0); } break;
case 526:
#line 1222 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_ENUM);
                                                                strcpy((char *)yyval.binstr->getBuff((unsigned)strlen(yypvt[-5].string) + 1), yypvt[-5].string);
                                                                yyval.binstr->appendInt8(1);
                                                                yyval.binstr->appendInt32(yypvt[-1].int32); } break;
case 527:
#line 1227 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_ENUM);
                                                                strcpy((char *)yyval.binstr->getBuff((unsigned)strlen(yypvt[-5].string) + 1), yypvt[-5].string);
                                                                yyval.binstr->appendInt8(2);
                                                                yyval.binstr->appendInt32(yypvt[-1].int32); } break;
case 528:
#line 1232 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_ENUM);
                                                                strcpy((char *)yyval.binstr->getBuff((unsigned)strlen(yypvt[-5].string) + 1), yypvt[-5].string);
                                                                yyval.binstr->appendInt8(4);
                                                                yyval.binstr->appendInt32(yypvt[-1].int32); } break;
case 529:
#line 1237 "asmparse.y"
{ yyval.binstr = new BinStr();
                                                                yyval.binstr->appendInt8(SERIALIZATION_TYPE_ENUM);
                                                                strcpy((char *)yyval.binstr->getBuff((unsigned)strlen(yypvt[-3].string) + 1), yypvt[-3].string);
                                                                yyval.binstr->appendInt8(4);
                                                                yyval.binstr->appendInt32(yypvt[-1].int32); } break;
case 530:
#line 1244 "asmparse.y"
{ yyval.secAct = dclRequest; } break;
case 531:
#line 1245 "asmparse.y"
{ yyval.secAct = dclDemand; } break;
case 532:
#line 1246 "asmparse.y"
{ yyval.secAct = dclAssert; } break;
case 533:
#line 1247 "asmparse.y"
{ yyval.secAct = dclDeny; } break;
case 534:
#line 1248 "asmparse.y"
{ yyval.secAct = dclPermitOnly; } break;
case 535:
#line 1249 "asmparse.y"
{ yyval.secAct = dclLinktimeCheck; } break;
case 536:
#line 1250 "asmparse.y"
{ yyval.secAct = dclInheritanceCheck; } break;
case 537:
#line 1251 "asmparse.y"
{ yyval.secAct = dclRequestMinimum; } break;
case 538:
#line 1252 "asmparse.y"
{ yyval.secAct = dclRequestOptional; } break;
case 539:
#line 1253 "asmparse.y"
{ yyval.secAct = dclRequestRefuse; } break;
case 540:
#line 1254 "asmparse.y"
{ yyval.secAct = dclPrejitGrant; } break;
case 541:
#line 1255 "asmparse.y"
{ yyval.secAct = dclPrejitDenied; } break;
case 542:
#line 1256 "asmparse.y"
{ yyval.secAct = dclNonCasDemand; } break;
case 543:
#line 1257 "asmparse.y"
{ yyval.secAct = dclNonCasLinkDemand; } break;
case 544:
#line 1258 "asmparse.y"
{ yyval.secAct = dclNonCasInheritance; } break;
case 545:
#line 1261 "asmparse.y"
{ bExternSource = TRUE; nExtLine = yypvt[-1].int32; nExtCol=1;
                                                                PASM->SetSourceFileName(yypvt[-0].string); delete yypvt[-0].string;} break;
case 546:
#line 1263 "asmparse.y"
{ bExternSource = TRUE; nExtLine = yypvt[-0].int32; nExtCol=1;} break;
case 547:
#line 1264 "asmparse.y"
{ bExternSource = TRUE; nExtLine = yypvt[-3].int32; nExtCol=yypvt[-1].int32;
                                                                PASM->SetSourceFileName(yypvt[-0].string); delete yypvt[-0].string;} break;
case 548:
#line 1266 "asmparse.y"
{ bExternSource = TRUE; nExtLine = yypvt[-2].int32; nExtCol=yypvt[-0].int32;} break;
case 549:
#line 1267 "asmparse.y"
{ bExternSource = TRUE; nExtLine = yypvt[-1].int32; nExtCol=1;
                                                                PASM->SetSourceFileName(yypvt[-0].binstr); delete yypvt[-0].binstr; } break;
case 550:
#line 1272 "asmparse.y"
{ PASMM->AddFile(yypvt[-5].string, yypvt[-6].fileAttr|yypvt[-4].fileAttr|yypvt[-0].fileAttr, yypvt[-2].binstr); } break;
case 551:
#line 1273 "asmparse.y"
{ PASMM->AddFile(yypvt[-1].string, yypvt[-2].fileAttr|yypvt[-0].fileAttr, NULL); } break;
case 552:
#line 1276 "asmparse.y"
{ yyval.fileAttr = (CorFileFlags) 0; } break;
case 553:
#line 1277 "asmparse.y"
{ yyval.fileAttr = (CorFileFlags) (yypvt[-1].fileAttr | ffContainsNoMetaData); } break;
case 554:
#line 1280 "asmparse.y"
{ yyval.fileAttr = (CorFileFlags) 0; } break;
case 555:
#line 1281 "asmparse.y"
{ yyval.fileAttr = (CorFileFlags) 0x80000000; } break;
case 556:
#line 1284 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 557:
#line 1287 "asmparse.y"
{ PASMM->StartAssembly(yypvt[-0].string, NULL, (DWORD)yypvt[-1].asmAttr, FALSE); } break;
case 558:
#line 1290 "asmparse.y"
{ yyval.asmAttr = (CorAssemblyFlags) 0; } break;
case 559:
#line 1291 "asmparse.y"
{ yyval.asmAttr = (CorAssemblyFlags) (yypvt[-1].asmAttr | afNonSideBySideAppDomain); } break;
case 560:
#line 1292 "asmparse.y"
{ yyval.asmAttr = (CorAssemblyFlags) (yypvt[-1].asmAttr | afNonSideBySideProcess); } break;
case 561:
#line 1293 "asmparse.y"
{ yyval.asmAttr = (CorAssemblyFlags) (yypvt[-1].asmAttr | afNonSideBySideMachine); } break;
case 562:
#line 1294 "asmparse.y"
{ yyval.asmAttr = (CorAssemblyFlags) (yypvt[-1].asmAttr | 0x0100); } break;
case 565:
#line 1301 "asmparse.y"
{ PASMM->SetAssemblyHashAlg(yypvt[-0].int32); } break;
case 568:
#line 1306 "asmparse.y"
{ PASMM->SetAssemblyPublicKey(yypvt[-1].binstr); } break;
case 569:
#line 1308 "asmparse.y"
{ PASMM->SetAssemblyVer((USHORT)yypvt[-6].int32, (USHORT)yypvt[-4].int32, (USHORT)yypvt[-2].int32, (USHORT)yypvt[-0].int32); } break;
case 570:
#line 1309 "asmparse.y"
{ yypvt[-0].binstr->appendInt8(0); PASMM->SetAssemblyLocale(yypvt[-0].binstr,TRUE); } break;
case 571:
#line 1310 "asmparse.y"
{ PASMM->SetAssemblyLocale(yypvt[-1].binstr,FALSE); } break;
case 573:
#line 1314 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 574:
#line 1317 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 575:
#line 1320 "asmparse.y"
{ bParsingByteArray = TRUE; } break;
case 576:
#line 1323 "asmparse.y"
{ PASMM->StartAssembly(yypvt[-0].string, NULL, yypvt[-1].asmAttr, TRUE); } break;
case 577:
#line 1325 "asmparse.y"
{ PASMM->StartAssembly(yypvt[-2].string, yypvt[-0].string, yypvt[-3].asmAttr, TRUE); } break;
case 580:
#line 1332 "asmparse.y"
{ PASMM->SetAssemblyHashBlob(yypvt[-1].binstr); } break;
case 582:
#line 1334 "asmparse.y"
{ PASMM->SetAssemblyPublicKeyToken(yypvt[-1].binstr); } break;
case 583:
#line 1337 "asmparse.y"
{ PASMM->StartComType(yypvt[-0].string, yypvt[-1].comtAttr);} break;
case 584:
#line 1340 "asmparse.y"
{ PASMM->StartComType(yypvt[-0].string, yypvt[-1].comtAttr); } break;
case 585:
#line 1343 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) 0; } break;
case 586:
#line 1344 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-1].comtAttr | tdNotPublic); } break;
case 587:
#line 1345 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-1].comtAttr | tdPublic); } break;
case 588:
#line 1346 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedPublic); } break;
case 589:
#line 1347 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedPrivate); } break;
case 590:
#line 1348 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedFamily); } break;
case 591:
#line 1349 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedAssembly); } break;
case 592:
#line 1350 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedFamANDAssem); } break;
case 593:
#line 1351 "asmparse.y"
{ yyval.comtAttr = (CorTypeAttr) (yypvt[-2].comtAttr | tdNestedFamORAssem); } break;
case 596:
#line 1358 "asmparse.y"
{ PASMM->SetComTypeFile(yypvt[-0].string); } break;
case 597:
#line 1359 "asmparse.y"
{ PASMM->SetComTypeComType(yypvt[-0].string); } break;
case 598:
#line 1360 "asmparse.y"
{ PASMM->SetComTypeClassTok(yypvt[-0].int32); } break;
case 600:
#line 1364 "asmparse.y"
{ PASMM->StartManifestRes(yypvt[-0].string, yypvt[-1].manresAttr); } break;
case 601:
#line 1367 "asmparse.y"
{ yyval.manresAttr = (CorManifestResourceFlags) 0; } break;
case 602:
#line 1368 "asmparse.y"
{ yyval.manresAttr = (CorManifestResourceFlags) (yypvt[-1].manresAttr | mrPublic); } break;
case 603:
#line 1369 "asmparse.y"
{ yyval.manresAttr = (CorManifestResourceFlags) (yypvt[-1].manresAttr | mrPrivate); } break;
case 606:
#line 1376 "asmparse.y"
{ PASMM->SetManifestResFile(yypvt[-2].string, (ULONG)yypvt[-0].int32); } break;
case 607:
#line 1377 "asmparse.y"
{ PASMM->SetManifestResAsmRef(yypvt[-0].string); } break;/* End of actions */
#line 329 "e:\\com99\\env.cor\\bin\\i386\\yypars.c"
			}
		}
		goto yystack;  /* stack new state and value */
	}
#pragma warning(default:102)


#ifdef YYDUMP
YYLOCAL void YYNEAR YYPASCAL yydumpinfo(void)
{
	short stackindex;
	short valindex;

	//dump yys
	printf("short yys[%d] {\n", YYMAXDEPTH);
	for (stackindex = 0; stackindex < YYMAXDEPTH; stackindex++){
		if (stackindex)
			printf(", %s", stackindex % 10 ? "\0" : "\n");
		printf("%6d", yys[stackindex]);
		}
	printf("\n};\n");

	//dump yyv
	printf("YYSTYPE yyv[%d] {\n", YYMAXDEPTH);
	for (valindex = 0; valindex < YYMAXDEPTH; valindex++){
		if (valindex)
			printf(", %s", valindex % 5 ? "\0" : "\n");
		printf("%#*x", 3+sizeof(YYSTYPE), yyv[valindex]);
		}
	printf("\n};\n");
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\ceeload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.CPP
// 

// CEELOAD reads in the PE file format using LoadLibrary
// ===========================================================================
#pragma warning (disable : 4121) // ntkxapi.h(59) alignment warning
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ceeload.h"
#include <CorHdr.h>
#pragma warning (default : 4121)
/*
#include "cor.h"
#include <ntrtl.h>
#include <nturtl.h>
*/
#include "util.hpp"


// ---------------------------------------------------------------------------
// LoadModule
// ---------------------------------------------------------------------------
// Following two functions lifted from NT sources, imagedir.c
PIMAGE_SECTION_HEADER
Cor_RtlImageRvaToSection(
	IN PIMAGE_NT_HEADERS NtHeaders,
	IN PVOID Base,
	IN ULONG Rva
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file
	that is mapped as a file and returns a pointer to the section
	table entry for that virtual address

Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

	NULL - The RVA was not found within any of the sections of the image.

	NON-NULL - Returns the pointer to the image section that contains
			   the RVA

--*/

{
	ULONG i;
	PIMAGE_SECTION_HEADER NtSection;

	NtSection = IMAGE_FIRST_SECTION( NtHeaders );
	for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
		if (Rva >= NtSection->VirtualAddress &&
			Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
		   ) {
			return NtSection;
			}
		++NtSection;
		}

	return NULL;
}

PVOID
Cor_RtlImageRvaToVa(
	IN PIMAGE_NT_HEADERS NtHeaders,
	IN PVOID Base,
	IN ULONG Rva,
	IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file that
	is mapped as a file and returns the virtual addrees of the
	corresponding byte in the file.


Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

	LastRvaSection - Optional parameter that if specified, points
		to a variable that contains the last section value used for
		the specified image to translate and RVA to a VA.

Return Value:

	NULL - The file does not contain the specified RVA

	NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
	PIMAGE_SECTION_HEADER NtSection;

	if (!ARGUMENT_PRESENT( LastRvaSection ) ||
		(NtSection = *LastRvaSection) == NULL ||
		Rva < NtSection->VirtualAddress ||
		Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
	   ) {
		NtSection = Cor_RtlImageRvaToSection( NtHeaders,
										  Base,
										  Rva
										);
		}

	if (NtSection != NULL) {
		if (LastRvaSection != NULL) {
			*LastRvaSection = NtSection;
			}

		return (PVOID)((PCHAR)Base +
					   (Rva - NtSection->VirtualAddress) +
					   NtSection->PointerToRawData
					  );
		}
	else {
		return NULL;
		}
}



// Class PELoader...

/*************************************************************************************/
// Constructor and destructor!
/*************************************************************************************/
PELoader::PELoader()
{
    m_hFile = NULL;
    m_hMod = NULL;
    m_hMapFile = NULL;
    m_pNT = NULL;
}

PELoader::~PELoader()
{
	
	m_hMod = NULL;
	m_pNT = NULL;
	// If we have an hFile then we opened this file ourselves!
	// If we do not then this file was loaded by the OS and the OS will
	// close it for us.
    if (m_hFile)
	    this->close();
}

/*************************************************************************************/
/*************************************************************************************/
void PELoader::close()
{
	
	// _ASSERTE(m_hFile != NULL);
	if (m_hFile)
    {
	    if (m_hMod)
		    UnmapViewOfFile((void*)m_hMod);
	    if (m_hMapFile)
		    CloseHandle(m_hMapFile);
	    CloseHandle(m_hFile);

        m_hMod = NULL;
        m_hMapFile = NULL;
        m_hFile = NULL;
    }
}


BOOL PELoader::open(LPCSTR moduleName)
{    
    HMODULE newhMod = NULL;
    
    _ASSERTE(moduleName);
    if (!moduleName)
        return FALSE;


    m_hFile = CreateFileA(moduleName, GENERIC_READ, FILE_SHARE_READ,
                         0, OPEN_EXISTING, 0, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    m_hMapFile = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMapFile == NULL)
        return FALSE;

    newhMod = (HMODULE) MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (newhMod == NULL)
        return FALSE;
   return open(newhMod);
}

BOOL PELoader::open(const WCHAR* moduleName)
{    
    HMODULE newhMod = NULL;
    
    _ASSERTE(moduleName);
    if (!moduleName)
        return FALSE;

#undef CreateFileW
    m_hFile = CreateFileW(moduleName, GENERIC_READ, FILE_SHARE_READ,
                         0, OPEN_EXISTING, 0, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    m_hMapFile = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMapFile == NULL)
        return FALSE;

    newhMod = (HMODULE) MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (newhMod == NULL)
        return FALSE;
   return open(newhMod);
}


/*************************************************************************************/
BOOL PELoader::open(HMODULE hMod)
{

    IMAGE_DOS_HEADER* pdosHeader;
    //DWORD cbRead;

    // _ASSERTE(hMod);
    // get the dos header...
	m_hMod = hMod;
	pdosHeader = (IMAGE_DOS_HEADER*) hMod;
    
    if (pdosHeader->e_magic == IMAGE_DOS_SIGNATURE && 
		0 < pdosHeader->e_lfanew && pdosHeader->e_lfanew < 0xFF0)	// has to start on first page
	{
		m_pNT = (IMAGE_NT_HEADERS*) (pdosHeader->e_lfanew + (DWORD) m_hMod);

	    if ((m_pNT->Signature != IMAGE_NT_SIGNATURE) ||
			(m_pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
		    (m_pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
		{
		    // @TODO - add some SetLastError info? Not sure that in this case this could happen...But!
			// Make this appear uninitalized because for some reason this file is toast...
			// Not sure that this could ever happen because this file has already been loaded 
			// bye the system loader unless someone gave us garbage as the hmod
			m_pNT = NULL;
			m_hMod = NULL;
			return FALSE;
		}
	}
	else
	{
    // @TODO - add some SetLastError info? Not sure that in this case this could happen...But!
		m_hMod = NULL;
		return FALSE;
	}

	return TRUE;
}

/*************************************************************************************/
void PELoader::dump()
{
	IMAGE_FILE_HEADER* pHeader = &m_pNT->FileHeader;
	IMAGE_OPTIONAL_HEADER* pOptHeader = &m_pNT->OptionalHeader;
	IMAGE_SECTION_HEADER* rgsh = (IMAGE_SECTION_HEADER*) (pOptHeader + 1);
}

/*************************************************************************************/
BOOL PELoader::getCOMHeader(IMAGE_COR20_HEADER **ppCorHeader) 
{

    PIMAGE_NT_HEADERS		pImageHeader;
	PIMAGE_SECTION_HEADER	pSectionHeader;

	// Get the image header from the image, then get the directory location
	// of the COM+ header which may or may not be filled out.
    pImageHeader = RtlpImageNtHeader(m_hMod);
	pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pImageHeader, m_hMod, 
		pImageHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
		NULL);

	// If the section header exists, then return ok and the address.
	if (pSectionHeader)
	{
		*ppCorHeader = (IMAGE_COR20_HEADER *) pSectionHeader;
        return TRUE;
	}
	// If there is no COM+ Data in this image, return false.
	else
		return FALSE;
}

/*************************************************************************************/
BOOL PELoader::getVAforRVA(DWORD rva,void **ppva) 
{

    PIMAGE_NT_HEADERS		pImageHeader;
	PIMAGE_SECTION_HEADER	pSectionHeader;

	// Get the image header from the image, then get the directory location
	// of the COM+ header which may or may not be filled out.
    pImageHeader = RtlpImageNtHeader(m_hMod);
	pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pImageHeader, m_hMod, 
		rva,
		NULL);

	// If the section header exists, then return ok and the address.
	if (pSectionHeader)
	{
		*ppva = pSectionHeader;
        return TRUE;
	}
	// If there is no COM+ Data in this image, return false.
	else
		return FALSE;
}

void SectionInfo::Init(PELoader *pPELoader, IMAGE_DATA_DIRECTORY *dir)
{
    _ASSERTE(dir);
    m_dwSectionOffset = dir->VirtualAddress;
	if (m_dwSectionOffset != 0)
		m_pSection = pPELoader->base() + m_dwSectionOffset;
	else
		m_pSection = 0;
    m_dwSectionSize = dir->Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ilasm\writer.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// writer.cpp
//
#include "cor.h"
#include "assembler.h"
#include <corsym_i.c>

#include "CeeFileGenWriter.h"
#include "StrongName.h"

extern WCHAR *g_wzResourceFile;  // resource file name - global, declared in MAIN.CPP
extern bool OnErrGo; // declared in main.cpp
extern unsigned int g_uCodePage;
extern WCHAR *g_wzKeySourceName;
extern bool bClock;
extern clock_t		cBegin,cEnd,
			cParsBegin,cParsEnd,
			cMDEmitBegin,cMDEmitEnd,
			cMDEmit1,cMDEmit2,cMDEmit3,cMDEmit4,
			cRef2DefBegin,cRef2DefEnd,
			cFilegenBegin,cFilegenEnd;

HRESULT Assembler::InitMetaData()
{
    HRESULT             hr = E_FAIL;
    WCHAR               wzScopeName[MAX_SCOPE_LENGTH];

	if(m_fInitialisedMetaData) return S_OK;

	if(m_szScopeName[0]) // default: scope name = output file name
	{
		WszMultiByteToWideChar(g_uCodePage,0,m_szScopeName,-1,wzScopeName,MAX_SCOPE_LENGTH);
	}
	else
	{
		wcscpy(wzScopeName,m_wzOutputFileName);
	}

	hr = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER,
								IID_IMetaDataDispenser, (void **)&m_pDisp);
	if (FAILED(hr))
		goto exit;

	hr = m_pDisp->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit,
						(IUnknown **)&m_pEmitter);
	if (FAILED(hr))
		goto exit;

	m_pManifest->SetEmitter(m_pEmitter);

#ifndef _WIN64  // @TODO: Remove when a symwrtr.dll exists for ia64
    hr = CoCreateInstance(CLSID_CorSymWriter_SxS,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_ISymUnmanagedWriter,
                           (void **)&m_pSymWriter);
	if(SUCCEEDED(hr))
	{
		if(m_pSymWriter) m_pSymWriter->Initialize((IUnknown*)m_pEmitter,
                                                  m_wzOutputFileName,
                                                  NULL,
                                                  TRUE);
	}
	else 
	{
	    fprintf(stderr, "Error: QueryInterface(IID_ISymUnmanagedWriter) returns %X\n",hr);
		m_pSymWriter = NULL;
	}
#endif // !_WIN64

	hr = m_pEmitter->QueryInterface(IID_IMetaDataHelper, (void **)&m_pHelper);
	if (FAILED(hr))
		goto exit;

    hr = m_pEmitter->SetModuleProps(
        wzScopeName
    );
    if (FAILED(hr))
        goto exit;

	//m_Parser = new AsmParse(m_pEmitter);
    m_fInitialisedMetaData = TRUE;

	if(m_fOwnershipSet)
	{
		DefineCV(1,0x02000001,m_pbsOwner);
	}

    hr = S_OK;

exit:
    return hr;
}
/*********************************************************************************/
/* if we have any Thread local store data, make the TLS directory record for it */

HRESULT Assembler::CreateTLSDirectory() {

	ULONG tlsEnd;
    HRESULT hr;
	if (FAILED(hr=m_pCeeFileGen->GetSectionDataLen(m_pTLSSection, &tlsEnd))) return(hr);

	if (tlsEnd == 0)		// No TLS data, we are done
		return(S_OK);

		// place to put the TLS directory
	HCEESECTION tlsDirSec = m_pGlobalDataSection;

		// Get memory for for the TLS directory block,as well as a spot for callback chain
	IMAGE_TLS_DIRECTORY* tlsDir;
	if(FAILED(hr=m_pCeeFileGen->GetSectionBlock(tlsDirSec, sizeof(IMAGE_TLS_DIRECTORY) + sizeof(DWORD), 4, (void**) &tlsDir))) return(hr);
	DWORD* callBackChain = (DWORD*) &tlsDir[1];
	*callBackChain = 0;

		// Find out where the tls directory will end up
	ULONG tlsDirOffset;
    if(FAILED(hr=m_pCeeFileGen->GetSectionDataLen(tlsDirSec, &tlsDirOffset))) return(hr);
	tlsDirOffset -= (sizeof(IMAGE_TLS_DIRECTORY) + sizeof(DWORD));
	
		// Set the start of the TLS data (offset 0 of hte TLS section)
	tlsDir->StartAddressOfRawData = 0;
    if(FAILED(hr=m_pCeeFileGen->AddSectionReloc(tlsDirSec, tlsDirOffset + offsetof(IMAGE_TLS_DIRECTORY, StartAddressOfRawData), m_pTLSSection, srRelocHighLow))) return(hr);

		// Set the end of the TLS data 
	tlsDir->EndAddressOfRawData = tlsEnd;
    if(FAILED(hr=m_pCeeFileGen->AddSectionReloc(tlsDirSec, tlsDirOffset + offsetof(IMAGE_TLS_DIRECTORY, EndAddressOfRawData), m_pTLSSection, srRelocHighLow))) return(hr);

		// Allocate space for the OS to put the TLS index for this PE file (needs to be Read/Write?)
	DWORD* tlsIndex;
	if(FAILED(hr=m_pCeeFileGen->GetSectionBlock(m_pGlobalDataSection, sizeof(DWORD), 4, (void**) &tlsIndex))) return(hr);
	*tlsIndex = 0xCCCCCCCC;		// Does't really matter, the OS will fill it in 
		
		// Find out where tlsIndex index is
	ULONG tlsIndexOffset;
    if(FAILED(hr=m_pCeeFileGen->GetSectionDataLen(tlsDirSec, &tlsIndexOffset))) return(hr);
	tlsIndexOffset -= sizeof(DWORD);
	
		// Set the address of the TLS index 
	tlsDir->AddressOfIndex = (DWORD)(PULONG)tlsIndexOffset;
    if(FAILED(hr=m_pCeeFileGen->AddSectionReloc(tlsDirSec, tlsDirOffset + offsetof(IMAGE_TLS_DIRECTORY, AddressOfIndex), m_pGlobalDataSection, srRelocHighLow))) return(hr);

		// Set addres of callbacks chain
	tlsDir->AddressOfCallBacks = (DWORD)(PIMAGE_TLS_CALLBACK*)(tlsDirOffset + sizeof(IMAGE_TLS_DIRECTORY));
    if(FAILED(hr=m_pCeeFileGen->AddSectionReloc(tlsDirSec, tlsDirOffset + offsetof(IMAGE_TLS_DIRECTORY, AddressOfCallBacks), tlsDirSec, srRelocHighLow))) return(hr);

		// Set the other fields.  
	tlsDir->SizeOfZeroFill = 0;
	tlsDir->Characteristics = 0;

    hr=m_pCeeFileGen->SetDirectoryEntry (m_pCeeFile, tlsDirSec, IMAGE_DIRECTORY_ENTRY_TLS, 
		sizeof(IMAGE_TLS_DIRECTORY), tlsDirOffset);

	return(hr);
}

HRESULT Assembler::CreateDebugDirectory()
{
    HRESULT hr = S_OK;

    // Only emit this if we're also emitting debug info.
    if (!(m_fIncludeDebugInfo && m_pSymWriter))
        return S_OK;
    
    IMAGE_DEBUG_DIRECTORY  debugDirIDD;
    DWORD                  debugDirDataSize;
    BYTE                  *debugDirData;

    // Get the debug info from the symbol writer.
    if (FAILED(hr=m_pSymWriter->GetDebugInfo(NULL, 0, &debugDirDataSize, NULL)))
        return hr;

    // Will there even be any?
    if (debugDirDataSize == 0)
        return S_OK;

    // Make some room for the data.
    debugDirData = (BYTE*)_alloca(debugDirDataSize);

    // Actually get the data now.
    if (FAILED(hr = m_pSymWriter->GetDebugInfo(&debugDirIDD,
                                               debugDirDataSize,
                                               NULL,
                                               debugDirData)))
        return hr;

    // Grab the timestamp of the PE file.
    time_t fileTimeStamp;

    if (FAILED(hr = m_pCeeFileGen->GetFileTimeStamp(m_pCeeFile,
                                                    &fileTimeStamp)))
        return hr;

    // Fill in the directory entry.
    debugDirIDD.TimeDateStamp = (DWORD)fileTimeStamp;
    debugDirIDD.AddressOfRawData = 0;

    // Grab memory in the section for our stuff.
    HCEESECTION sec = m_pGlobalDataSection;
    BYTE *de;

    if (FAILED(hr = m_pCeeFileGen->GetSectionBlock(sec,
                                                   sizeof(debugDirIDD) +
                                                   debugDirDataSize,
                                                   4,
                                                   (void**) &de)))
        return hr;

    // Where did we get that memory?
    ULONG deOffset;
    if (FAILED(hr = m_pCeeFileGen->GetSectionDataLen(sec,
                                                     &deOffset)))
        return hr;

    deOffset -= (sizeof(debugDirIDD) + debugDirDataSize);

    // Setup a reloc so that the address of the raw
    // data is setup correctly.
    debugDirIDD.PointerToRawData = deOffset + sizeof(debugDirIDD);
                    
    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(
                                          sec,
                                          deOffset +
                                          offsetof(IMAGE_DEBUG_DIRECTORY,
                                                   PointerToRawData),
                                          sec, srRelocFilePos)))
        return hr;
                    
    // Emit the directory entry.
    if (FAILED(hr = m_pCeeFileGen->SetDirectoryEntry(m_pCeeFile,
                                                     sec,
                                                     IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                     sizeof(debugDirIDD),
                                                     deOffset)))
        return hr;

    // Copy the debug directory into the section.
    memcpy(de, &debugDirIDD, sizeof(debugDirIDD));
    memcpy(de + sizeof(debugDirIDD), debugDirData,
           debugDirDataSize);

    return S_OK;
}
//#ifdef EXPORT_DIR_ENABLED
HRESULT Assembler::CreateExportDirectory()
{
    HRESULT hr = S_OK;
	DWORD	Nentries = m_EATList.COUNT();
	if(Nentries == 0) return S_OK;

    IMAGE_EXPORT_DIRECTORY  exportDirIDD;
    DWORD                   exportDirDataSize;
    BYTE                   *exportDirData;
	EATEntry			   *pEATE;
	unsigned				i, L, ordBase = 0xFFFFFFFF, Ldllname;
	// get the DLL name from output file name
	char*					pszDllName;
	Ldllname = wcslen(m_wzOutputFileName)*3+3;
	char*					szOutputFileName = new char[Ldllname];
	memset(szOutputFileName,0,wcslen(m_wzOutputFileName)*3+3);
	WszWideCharToMultiByte(CP_ACP,0,m_wzOutputFileName,-1,szOutputFileName,Ldllname,NULL,NULL);
	pszDllName = strrchr(szOutputFileName,'\\');
	if(pszDllName == NULL) pszDllName = strrchr(szOutputFileName,':');
	if(pszDllName == NULL) pszDllName = szOutputFileName;
	Ldllname = strlen(pszDllName)+1;

	// Allocate buffer for tables
	for(i = 0, L=0; i < Nentries; i++) L += 1+strlen(m_EATList.PEEK(i)->szAlias);
	exportDirDataSize = Nentries*5*sizeof(WORD) + L + Ldllname;
	exportDirData = new BYTE[exportDirDataSize];
	memset(exportDirData,0,exportDirDataSize);

	// Export address table
	DWORD*	pEAT = (DWORD*)exportDirData;
	// Name pointer table
	DWORD*	pNPT = pEAT + Nentries;
	// Ordinal table
	WORD*	pOT = (WORD*)(pNPT + Nentries);
	// Export name table
	char*	pENT = (char*)(pOT + Nentries);
	// DLL name
	char*	pDLLName = pENT + L;

	// sort the names/ordinals
	char**	pAlias = new char*[Nentries];
	for(i = 0; i < Nentries; i++)
	{
		pEATE = m_EATList.PEEK(i);
		pOT[i] = (WORD)pEATE->dwOrdinal;
		if(pOT[i] < ordBase) ordBase = pOT[i];
		pAlias[i] = pEATE->szAlias;
	}
	bool swapped = true;
	unsigned j;
	char*	 pch;
	while(swapped)
	{
		swapped = false;
		for(i=1; i < Nentries; i++)
		{
			if(strcmp(pAlias[i-1],pAlias[i]) > 0)
			{
				swapped = true;
				pch = pAlias[i-1];
				pAlias[i-1] = pAlias[i];
				pAlias[i] = pch;
				j = pOT[i-1];
				pOT[i-1] = pOT[i];
				pOT[i] = j;
			}
		}
	}
	// normalize ordinals
	for(i = 0; i < Nentries; i++) pOT[i] -= ordBase;
	// fill the export address table
	for(i = 0; i < Nentries; i++)
	{
		pEATE = m_EATList.PEEK(i);
		pEAT[pEATE->dwOrdinal - ordBase] = pEATE->dwStubRVA;
	}
	// fill the export names table
	unsigned l;
	for(i = 0, j = 0; i < Nentries; i++)
	{
		pNPT[i] = j; // relative offset in the table
		l = strlen(pAlias[i])+1;
		memcpy(&pENT[j],pAlias[i],l);
		j+=l;
	}
	_ASSERTE(j==L);
	// fill the DLL name
	memcpy(pDLLName,pszDllName,Ldllname);

	// Data blob is ready pending Name Pointer Table values offsetting

	memset(&exportDirIDD,0,sizeof(IMAGE_EXPORT_DIRECTORY));
    // Grab the timestamp of the PE file.
    time_t fileTimeStamp;
    if (FAILED(hr = m_pCeeFileGen->GetFileTimeStamp(m_pCeeFile,&fileTimeStamp))) return hr;
    // Fill in the directory entry.
	// Characteristics, MajorVersion and MinorVersion play no role and stay 0
    exportDirIDD.TimeDateStamp = (DWORD)fileTimeStamp;
	exportDirIDD.Name = exportDirDataSize - Ldllname; // to be offset later
	exportDirIDD.Base = ordBase;
	exportDirIDD.NumberOfFunctions = Nentries;
	exportDirIDD.NumberOfNames = Nentries;
	exportDirIDD.AddressOfFunctions = 0;	// to be offset later
	exportDirIDD.AddressOfNames = Nentries*sizeof(DWORD);	// to be offset later
	exportDirIDD.AddressOfNameOrdinals = Nentries*sizeof(DWORD)*2;	// to be offset later

    // Grab memory in the section for our stuff.
    HCEESECTION sec = m_pGlobalDataSection;
    BYTE *de;
    if (FAILED(hr = m_pCeeFileGen->GetSectionBlock(sec,
                                                   sizeof(IMAGE_EXPORT_DIRECTORY) + exportDirDataSize,
                                                   4,
                                                   (void**) &de))) return hr;
    // Where did we get that memory?
    ULONG deOffset, deDataOffset;
    if (FAILED(hr = m_pCeeFileGen->GetSectionDataLen(sec, &deDataOffset))) return hr;

    deDataOffset -= exportDirDataSize;
	deOffset = deDataOffset - sizeof(IMAGE_EXPORT_DIRECTORY);

	// Add offsets and set up relocs for header entries
	exportDirIDD.Name += deDataOffset;
    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(sec,deOffset + offsetof(IMAGE_EXPORT_DIRECTORY,Name),
                                          sec, srRelocAbsolute))) return hr;
	exportDirIDD.AddressOfFunctions += deDataOffset;
    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(sec,deOffset + offsetof(IMAGE_EXPORT_DIRECTORY,AddressOfFunctions),
                                          sec, srRelocAbsolute))) return hr;
	exportDirIDD.AddressOfNames += deDataOffset;
    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(sec,deOffset + offsetof(IMAGE_EXPORT_DIRECTORY,AddressOfNames),
                                          sec, srRelocAbsolute))) return hr;
	exportDirIDD.AddressOfNameOrdinals += deDataOffset;
    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(sec,deOffset + offsetof(IMAGE_EXPORT_DIRECTORY,AddressOfNameOrdinals),
                                          sec, srRelocAbsolute))) return hr;

   	// Add offsets and set up relocs for Name Pointer Table
	j = deDataOffset + Nentries*5*sizeof(WORD); // EA, NP and O Tables come first
	for(i = 0; i < Nentries; i++) 
	{
		pNPT[i] += j;
	    if (FAILED(hr = m_pCeeFileGen->AddSectionReloc(sec,exportDirIDD.AddressOfNames+i*sizeof(DWORD),
			sec, srRelocAbsolute))) return hr;
	}

	
    // Emit the directory entry.
    if (FAILED(hr = m_pCeeFileGen->SetDirectoryEntry(m_pCeeFile, sec, IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                     sizeof(IMAGE_EXPORT_DIRECTORY), deOffset)))  return hr;

    // Copy the debug directory into the section.
    memcpy(de, &exportDirIDD, sizeof(IMAGE_EXPORT_DIRECTORY));
    memcpy(de + sizeof(IMAGE_EXPORT_DIRECTORY), exportDirData, exportDirDataSize);
	delete pAlias;
	delete exportDirData;
    return S_OK;
}
DWORD	Assembler::EmitExportStub(DWORD dwVTFSlotRVA)
{
#define EXPORT_STUB_SIZE 6
	BYTE* outBuff;
	BYTE	bBuff[EXPORT_STUB_SIZE];
	WORD*	pwJumpInd = (WORD*)&bBuff[0];
	DWORD*	pdwVTFSlotRVA = (DWORD*)&bBuff[2];
	if (FAILED(m_pCeeFileGen->GetSectionBlock (m_pILSection, EXPORT_STUB_SIZE, 16, (void **) &outBuff))) return 0;
    // The offset where we start, (not where the alignment bytes start!)
	DWORD PEFileOffset;
	if (FAILED(m_pCeeFileGen->GetSectionDataLen (m_pILSection, &PEFileOffset)))	return 0;
	
	PEFileOffset -= EXPORT_STUB_SIZE;
	*pwJumpInd = 0x25FF;
	printf("EmitExportStub: dwVTFSlotRVA=0x%08x\n",dwVTFSlotRVA);
	*pdwVTFSlotRVA = dwVTFSlotRVA;
	memcpy(outBuff,bBuff,EXPORT_STUB_SIZE);
	m_pCeeFileGen->AddSectionReloc(m_pILSection, PEFileOffset+2,m_pGlobalDataSection, srRelocHighLow);
	m_pCeeFileGen->GetMethodRVA(m_pCeeFile, PEFileOffset,&PEFileOffset);
	return PEFileOffset;
}
//#endif

HRESULT Assembler::AllocateStrongNameSignature()
{
    HRESULT             hr = S_OK;
    HCEESECTION         hSection;
    DWORD               dwDataLength;
    DWORD               dwDataOffset;
    DWORD               dwDataRVA;
    VOID               *pvBuffer;
    AsmManStrongName   *pSN = &m_pManifest->m_sStrongName;

    // Determine size of signature blob.
    if (!StrongNameSignatureSize(pSN->m_pbPublicKey, pSN->m_cbPublicKey, &dwDataLength))
        return StrongNameErrorInfo();

    // Grab memory in the section for our stuff.
    if (FAILED(hr = m_pCeeFileGen->GetIlSection(m_pCeeFile,
                                                &hSection)))
        return hr;

    if (FAILED(hr = m_pCeeFileGen->GetSectionBlock(hSection,
                                                   dwDataLength,
                                                   4,
                                                   &pvBuffer)))
        return hr;

    // Where did we get that memory?
    if (FAILED(hr = m_pCeeFileGen->GetSectionDataLen(hSection,
                                                     &dwDataOffset)))
        return hr;

    dwDataOffset -= dwDataLength;

    // Convert to an RVA.
    if (FAILED(hr = m_pCeeFileGen->GetMethodRVA(m_pCeeFile,
                                                dwDataOffset,
                                                &dwDataRVA)))
        return hr;

    // Emit the directory entry.
    if (FAILED(hr = m_pCeeFileGen->SetStrongNameEntry(m_pCeeFile,
                                                      dwDataLength,
                                                      dwDataRVA)))
        return hr;

    return S_OK;
}

HRESULT Assembler::StrongNameSign()
{
    LPWSTR              wszOutputFile;
    HRESULT             hr = S_OK;
    AsmManStrongName   *pSN = &m_pManifest->m_sStrongName;

    // Determine what the ouput PE was called.
    if (FAILED(hr = m_pCeeFileGen->GetOutputFileName(m_pCeeFile,
                                                     &wszOutputFile)))
        return hr;

    // Update the output PE image with a strong name signature.
    if (!StrongNameSignatureGeneration(wszOutputFile,
                                       pSN->m_wzKeyContainer,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL))
        return StrongNameErrorInfo();

    return S_OK;
}

BOOL Assembler::EmitMembers(Class* pClass)
{
	unsigned n;
	BOOL ret = TRUE;
    // emit all field definition metadata tokens
	if(n = pClass->m_FieldDList.COUNT())
	{
		FieldDescriptor*	pFD;
		if(m_fReportProgress) printf("Fields: %d;\t",n);
		for(int j=0; pFD = pClass->m_FieldDList.PEEK(j); j++) // can't use POP here: we'll need field list for props
		{
			if(!EmitField(pFD))
			{
				if(!OnErrGo) return FALSE;
				ret = FALSE;
			}
		}
	}
	// Fields are emitted; emit the class layout
	{
		COR_FIELD_OFFSET *pOffsets = NULL;
		ULONG ul = pClass->m_ulPack;
		ULONG N = pClass->m_dwNumFieldsWithOffset;

		EmitSecurityInfo(pClass->m_cl,
						 pClass->m_pPermissions,
						 pClass->m_pPermissionSets);
		pClass->m_pPermissions = NULL;
		pClass->m_pPermissionSets = NULL;
		if((pClass->m_ulSize != 0xFFFFFFFF)||(ul != 0)||(N != 0))
		{
			if(ul == 0) ul = 1; //default: pack by byte
			if(IsTdAutoLayout(pClass->m_Attr)) report->warn("Layout specified for auto-layout class\n");
			if((ul > 128)||((ul & (ul-1)) !=0 ))
				report->error("Invalid packing parameter (%d), must be 1,2,4,8...128\n",pClass->m_ulPack);
			if(N)
			{
				pOffsets = new COR_FIELD_OFFSET[N+1];
				ULONG i,j=0;
				FieldDescriptor	*pFD;
				for(i=0; pFD = pClass->m_FieldDList.PEEK(i); i++)
				{
					if(pFD->m_ulOffset != 0xFFFFFFFF)
					{
						pOffsets[j].ridOfField = RidFromToken(pFD->m_fdFieldTok);
						pOffsets[j].ulOffset = pFD->m_ulOffset;
						j++;
					}
				}
				_ASSERTE(j == N);
				pOffsets[j].ridOfField = mdFieldDefNil;
			}
			m_pEmitter->SetClassLayout   (   
						pClass->m_cl,		// [IN] typedef 
						ul,						// [IN] packing size specified as 1, 2, 4, 8, or 16 
						pOffsets,				// [IN] array of layout specification   
						pClass->m_ulSize); // [IN] size of the class   
			if(pOffsets) delete pOffsets;
		}
	}
    // emit all method definition metadata tokens
	if(n = pClass->m_MethodList.COUNT())
	{
		Method*	pMethod;

		if(m_fReportProgress) printf("Methods: %d;\t",n);
		while(pMethod = pClass->m_MethodList.POP())
		{
			if(!EmitMethod(pMethod))
			{
				if(!OnErrGo) return FALSE;
				ret = FALSE;
			}
			if (m_fGenerateListing)
			{ 
			  if (pMethod->IsGlobalMethod())
				  report->msg("Method '%s'\n\n", pMethod->m_szName);
			  else report->msg("Method '%s::%s'\n\n", pMethod->m_pClass->m_szName,
						  pMethod->m_szName);
			  GenerateListingFile(pMethod);
			}
			delete pMethod;
		}
	}
	// emit all event definition metadata tokens
	if(n = pClass->m_EventDList.COUNT())
	{
		if(m_fReportProgress) printf("Events: %d;\t",n);
		EventDescriptor* pED;
		for(int j=0; pED = pClass->m_EventDList.PEEK(j); j++) // can't use POP here: we'll need event list for props
		{
			if(!EmitEvent(pED))
			{
				if(!OnErrGo) return FALSE;
				ret = FALSE;
			}
		}
	}
	// emit all property definition metadata tokens
	if(n = pClass->m_PropDList.COUNT())
	{
		if(m_fReportProgress) printf("Props: %d;\t",n);
		PropDescriptor* pPD;

		for(int j=0; pPD = pClass->m_PropDList.PEEK(j); j++)
		{
			if(!EmitProp(pPD))
			{
				if(!OnErrGo) return FALSE;
				ret = FALSE;
			}
		}
	}
	if(m_fReportProgress) printf("\n");
	return ret;
}

HRESULT Assembler::CreatePEFile(WCHAR *pwzOutputFilename)
{
    HRESULT             hr;
	DWORD				mresourceSize = 0;
	DWORD				mresourceOffset = 0;
	BYTE*				mresourceData = NULL;
	//IUnknown *pUnknown = NULL;
//    DWORD               i;

	if(bClock) cMDEmitBegin = clock();
    // @TODO - LBS
    // This is a check that needs to go away post - ALPHA
	if(m_fReportProgress) printf("Creating %s file\n", m_fOBJ ? "COFF" : "PE");
    if (!m_pEmitter)
    {
        printf("Error: Cannot create a PE file with no metadata\n");
        return E_FAIL;
    }
	if(!(m_fDLL || m_fEntryPointPresent))
	{
		printf("Error: No entry point declared for executable\n");
		if(!OnErrGo) return E_FAIL;
	}

    if (DoGlobalFixups() == FALSE)
        return E_FAIL;
	if(bClock) cMDEmit1 = clock();

	if(m_fOBJ)
	{
		// emit pseudo-relocs to pass file name and build number to PEWriter
		// this should be done BEFORE method emission!
		char* szInFileName = new char[strlen(m_szSourceFileName)+1];
		strcpy(szInFileName,m_szSourceFileName);
		m_pCeeFileGen->AddSectionReloc(m_pILSection,(DWORD)szInFileName,m_pILSection,(CeeSectionRelocType)0x7FFC);
		time_t tm;
		time(&tm);
		struct tm* loct = localtime(&tm);
		DWORD compid = 0x002E0000 | (loct->tm_mday + (loct->tm_mon+1)*100);
		m_pCeeFileGen->AddSectionReloc(m_pILSection,compid,m_pILSection,(CeeSectionRelocType)0x7FFB);
	}

    // Allocate space for a strong name signature if we're delay or full
    // signing the assembly.
    if (m_pManifest->m_sStrongName.m_pbPublicKey)
        if (FAILED(hr = AllocateStrongNameSignature()))
            goto exit;
	if(bClock) cMDEmit2 = clock();

	// Check undefined local TypeRefs
	if(m_LocalTypeRefDList.COUNT())
	{
		LocalTypeRefDescr*	pLTRD=NULL;
		BOOL	bIsUndefClass = FALSE;
		while(pLTRD = m_LocalTypeRefDList.POP()) 
		{
			if(NULL == FindClass(pLTRD->m_szFullName))
			{
				report->msg("%s: Reference to undefined class '%s' (token 0x%08X)\n",
                    "Error", pLTRD->m_szFullName,pLTRD->m_tok);
				bIsUndefClass = TRUE;
			}
			delete pLTRD;
		}
        if(bIsUndefClass && !OnErrGo) return E_FAIL;
	}
	if(bClock) cMDEmit3 = clock();

	// Emit class members and globals:
	{
        Class *pSearch;
		int i;
		if(m_fReportProgress)	printf("\nEmitting members:\n");
        for (i=0; pSearch = m_lstClass.PEEK(i); i++)
		{
			if(m_fReportProgress)
			{
				if(i == 0)	printf("Global \t");
				else		printf("Class %d\t",i);
			}
			if(!EmitMembers(pSearch))
			{
				if(!OnErrGo) return E_FAIL;
			}
		}
	}
	if(bClock) cMDEmit4 = clock();

	if(m_MethodImplDList.COUNT())
	{
		if(m_fReportProgress) report->msg("Method Implementations (total): %d\n",m_MethodImplDList.COUNT());
		if(!EmitMethodImpls())
		{
			if(!OnErrGo) return E_FAIL;
		}
	}
	if(bClock) cMDEmitEnd = cRef2DefBegin = clock();
	// Now, when all items defined in this file are emitted, let's try to resolve member refs to member defs:
	if(m_MemberRefDList.COUNT())
	{
		MemberRefDescriptor*	pMRD;
		mdToken			tkMemberDef = 0;
		int i,j;
		unsigned ulTotal=0, ulDefs=0, ulRefs=0;
		Class	*pSearch;

		if(m_fReportProgress) printf("Resolving member refs: ");
		while(pMRD = m_MemberRefDList.POP())
		{
			tkMemberDef = 0;
			MethodDescriptor* pListMD;
			mdToken			pMRD_tdClass = pMRD->m_tdClass;
			char*			pMRD_szName = pMRD->m_szName;
			ULONG			pMRD_dwCSig = (pMRD->m_pSigBinStr ? pMRD->m_pSigBinStr->length() : 0);
			PCOR_SIGNATURE	pMRD_pSig = (PCOR_SIGNATURE)(pMRD->m_pSigBinStr ? pMRD->m_pSigBinStr->ptr() : NULL);
			ulTotal++;
			// MemberRef may reference a method or a field
			if((pMRD_pSig==NULL)||(*pMRD_pSig != IMAGE_CEE_CS_CALLCONV_FIELD))
			{
				for (i=0; pSearch = m_lstClass.PEEK(i); i++)
				{
					if(pMRD_tdClass != pSearch->m_cl) continue;
					for(j=0; pListMD = pSearch->m_MethodDList.PEEK(j); j++)
					{
						if(pListMD->m_dwCSig  != pMRD_dwCSig)  continue;
						if(memcmp(pListMD->m_pSig,pMRD_pSig,pMRD_dwCSig)) continue;
						if(strcmp(pListMD->m_szName,pMRD_szName)) continue;
						tkMemberDef = pListMD->m_mdMethodTok;
						break;
					}
				}
			}
			if(tkMemberDef == 0)
			{
				if((pMRD_pSig==NULL)||(*pMRD_pSig == IMAGE_CEE_CS_CALLCONV_FIELD))
				{
					FieldDescriptor* pListFD;
					for (i=0; pSearch = m_lstClass.PEEK(i); i++)
					{
						if(pMRD_tdClass != pSearch->m_cl) continue;
						for(j=0; pListFD = pSearch->m_FieldDList.PEEK(j); j++)
						{
							if(pListFD->m_pbsSig)
							{
								if(pListFD->m_pbsSig->length()  != pMRD_dwCSig)  continue;
								if(memcmp(pListFD->m_pbsSig->ptr(),pMRD_pSig,pMRD_dwCSig)) continue;
							}
							else if(pMRD_dwCSig) continue;
							if(strcmp(pListFD->m_szName,pMRD_szName)) continue;
							tkMemberDef = pListFD->m_fdFieldTok;
							break;
						}
					}
				}
			}
			if(tkMemberDef==0)
			{ // could not resolve ref to def, make new ref and leave it this way
				if(pSearch = pMRD->m_pClass)
				{
					mdToken tkRef;
					BinStr* pbs = new BinStr();
					pbs->appendInt8(ELEMENT_TYPE_NAME);
					strcpy((char*)(pbs->getBuff((unsigned int)strlen(pSearch->m_szFQN)+1)),pSearch->m_szFQN);
					if(!ResolveTypeSpecToRef(pbs,&tkRef)) tkRef = mdTokenNil;
					delete pbs;

					if(RidFromToken(tkRef))
					{
						ULONG cTemp = (ULONG)(strlen(pMRD_szName)+1);
						WCHAR* wzMemberName = new WCHAR[cTemp];
						WszMultiByteToWideChar(g_uCodePage,0,pMRD_szName,-1,wzMemberName,cTemp);

						hr = m_pEmitter->DefineMemberRef(tkRef, wzMemberName, pMRD_pSig, 
							pMRD_dwCSig, &tkMemberDef);
						ulRefs++;
						delete [] wzMemberName;
					}
				}
			}
			else ulDefs++;
			if(RidFromToken(tkMemberDef))
			{
				memcpy((void*)(pMRD->m_ulOffset),&tkMemberDef,sizeof(mdToken));
				delete pMRD;
			}
			else
			{
				report->msg("Error: unresolved member ref '%s' of class 0x%08X\n",pMRD->m_szName,pMRD->m_tdClass);
				hr = E_FAIL;
				delete pMRD;
				if(!OnErrGo) goto exit;
			}
		}
		if(m_fReportProgress) printf("%d -> %d defs, %d refs\n",ulTotal,ulDefs,ulRefs);
	}
	if(bClock) cRef2DefEnd = clock();
	// emit manifest info (if any)
	hr = S_OK;
	if(m_pManifest) 
	{
		if (FAILED(hr = m_pManifest->EmitManifest())) goto exit;
	}

	if(g_wzResourceFile)
	    if (FAILED(hr=m_pCeeFileGen->SetResourceFileName(m_pCeeFile, g_wzResourceFile))) goto exit;

	if (FAILED(hr=CreateTLSDirectory())) goto exit;

	if (FAILED(hr=CreateDebugDirectory())) goto exit;
    
    if (FAILED(hr=m_pCeeFileGen->SetOutputFileName(m_pCeeFile, pwzOutputFilename))) goto exit;

		// Reserve a buffer for the meta-data
	DWORD metaDataSize;	
	if (FAILED(hr=m_pEmitter->GetSaveSize(cssAccurate, &metaDataSize))) goto exit;
	BYTE* metaData;
	if (FAILED(hr=m_pCeeFileGen->GetSectionBlock(m_pILSection, metaDataSize, sizeof(DWORD), (void**) &metaData))) goto exit; 
	ULONG metaDataOffset;
	if (FAILED(hr=m_pCeeFileGen->GetSectionDataLen(m_pILSection, &metaDataOffset))) goto exit;
	metaDataOffset -= metaDataSize;
	// set managed resource entry, if any
	if(m_pManifest && m_pManifest->m_dwMResSizeTotal)
	{
		mresourceSize = m_pManifest->m_dwMResSizeTotal;

		if (FAILED(hr=m_pCeeFileGen->GetSectionBlock(m_pILSection, mresourceSize, 
											sizeof(DWORD), (void**) &mresourceData))) goto exit; 
	    if (FAILED(hr=m_pCeeFileGen->SetManifestEntry(m_pCeeFile, mresourceSize, 0))) goto exit;
	}

	if(m_VTFList.COUNT())
	{
		GlobalLabel *pGlobalLabel;
		VTFEntry*	pVTFEntry;

		if(m_pVTable) delete m_pVTable; // can't have both; list takes precedence
		m_pVTable = new BinStr();
		hr = S_OK;
		for(WORD k=0; pVTFEntry = m_VTFList.POP(); k++)
		{
	        if(pGlobalLabel = FindGlobalLabel(pVTFEntry->m_szLabel))
			{
				MethodDescriptor*	pMD;
				Class* pClass;
				m_pVTable->appendInt32(pGlobalLabel->m_GlobalOffset);
				m_pVTable->appendInt16(pVTFEntry->m_wCount);
				m_pVTable->appendInt16(pVTFEntry->m_wType);
				for(int i=0; pClass = m_lstClass.PEEK(i); i++)
				{
					for(WORD j = 0; pMD = pClass->m_MethodDList.PEEK(j); j++)
					{
						if(pMD->m_wVTEntry == k+1)
						{
							char*	ptr;
							if(SUCCEEDED(hr = m_pCeeFileGen->ComputeSectionPointer(m_pGlobalDataSection,pGlobalLabel->m_GlobalOffset,&ptr)))
							{
								DWORD dwDelta = (pMD->m_wVTSlot-1)*((pVTFEntry->m_wType & COR_VTABLE_32BIT) ? sizeof(DWORD) : sizeof(__int64));
								ptr += dwDelta;
								mdMethodDef* mptr = (mdMethodDef*)ptr;
								*mptr = pMD->m_mdMethodTok;
								if(pMD->m_dwExportOrdinal != 0xFFFFFFFF)
								{
									EATEntry*	pEATE = new EATEntry;
									pEATE->dwOrdinal = pMD->m_dwExportOrdinal;
									pEATE->szAlias = pMD->m_szExportAlias ? pMD->m_szExportAlias : pMD->m_szName;
									pEATE->dwStubRVA = EmitExportStub(pGlobalLabel->m_GlobalOffset+dwDelta);
									m_EATList.PUSH(pEATE);
								}
							}
							else
								report->msg("Error: Failed to get pointer to label '%s' inVTable fixup\n",pVTFEntry->m_szLabel);
						}
					}
				}
			}
			else
			{
				report->msg("Error: Unresolved label '%s' in VTable fixup\n",pVTFEntry->m_szLabel);
				hr = E_FAIL;
			}
			delete pVTFEntry;
		}
		if(FAILED(hr)) goto exit;
	}
	if(m_pVTable)
	{
		//DWORD *pdw = (DWORD *)m_pVTable->ptr();
		ULONG i, N = m_pVTable->length()/sizeof(DWORD);
		ULONG ulVTableOffset;
		m_pCeeFileGen->GetSectionDataLen (m_pILSection, &ulVTableOffset);
		if (FAILED(hr=m_pCeeFileGen->SetVTableEntry(m_pCeeFile, m_pVTable->length(),(ULONG)(m_pVTable->ptr())))) goto exit;
		for(i = 0; i < N; i+=2)
		{
			m_pCeeFileGen->AddSectionReloc(m_pILSection, 
											ulVTableOffset+(i*sizeof(DWORD)),
											m_pGlobalDataSection, 
											srRelocAbsolute);
		}
	}
	if(m_EATList.COUNT())
	{
		if(FAILED(CreateExportDirectory())) goto exit;
	}
    if (m_fWindowsCE)
    {
        if (FAILED(hr=m_pCeeFileGen->SetSubsystem(m_pCeeFile, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI, 2, 10))) goto exit;

        if (FAILED(hr=m_pCeeFileGen->SetImageBase(m_pCeeFile, 0x10000))) goto exit;
    }
	else if(m_dwSubsystem)
	{
        if (FAILED(hr=m_pCeeFileGen->SetSubsystem(m_pCeeFile, m_dwSubsystem, 4, 0))) goto exit;
	}
	
    if (FAILED(hr=m_pCeeFileGen->ClearComImageFlags(m_pCeeFile, COMIMAGE_FLAGS_ILONLY))) goto exit;
    if (FAILED(hr=m_pCeeFileGen->SetComImageFlags(m_pCeeFile, m_dwComImageFlags & ~COMIMAGE_FLAGS_STRONGNAMESIGNED))) goto exit;

	if(m_dwFileAlignment)
	{
		if(FAILED(hr=m_pCeeFileGen->SetFileAlignment(m_pCeeFile, m_dwFileAlignment))) goto exit;
	}
    if(m_stBaseAddress)
    {
        if(FAILED(hr=m_pCeeFileGen->SetImageBase(m_pCeeFile, m_stBaseAddress))) goto exit;
    }
		//Compute all the RVAs
	if (FAILED(hr=m_pCeeFileGen->LinkCeeFile(m_pCeeFile))) goto exit;

		// Fix up any fields that have RVA associated with them
	if (m_fHaveFieldsWithRvas) {
		hr = S_OK;
		ULONG dataSectionRVA;
		if (FAILED(hr=m_pCeeFileGen->GetSectionRVA(m_pGlobalDataSection, &dataSectionRVA))) goto exit;
		
		ULONG tlsSectionRVA;
		if (FAILED(hr=m_pCeeFileGen->GetSectionRVA(m_pTLSSection, &tlsSectionRVA))) goto exit;

		FieldDescriptor* pListFD;
		Class* pClass;
		for(int i=0; pClass = m_lstClass.PEEK(i); i++)
		{
			for(int j=0; pListFD = pClass->m_FieldDList.PEEK(j); j++)
			{
				if (pListFD->m_rvaLabel != 0) 
				{
					GlobalLabel *pLabel = FindGlobalLabel(pListFD->m_rvaLabel);
					if (pLabel == 0)
					{
						report->msg("Error:Could not find label '%s' for the field '%s'\n", pListFD->m_rvaLabel, pListFD->m_szName);
						hr = E_FAIL;
						continue;
					}
				
					DWORD rva = pLabel->m_GlobalOffset;
					if (pLabel->m_Section == m_pTLSSection)
						rva += tlsSectionRVA;
					else {
						_ASSERTE(pLabel->m_Section == m_pGlobalDataSection);
						rva += dataSectionRVA;
					}
					if (FAILED(m_pEmitter->SetFieldRVA(pListFD->m_fdFieldTok, rva))) goto exit;
				}
			}
		}
		if (FAILED(hr)) goto exit;
	}

	if(bClock) cFilegenBegin = clock();
	// actually output the meta-data
    if (FAILED(hr=m_pCeeFileGen->EmitMetaDataAt(m_pCeeFile, m_pEmitter, m_pILSection, metaDataOffset, metaData, metaDataSize))) goto exit;
	// actually output the resources
	if(mresourceSize && mresourceData)
	{
		DWORD i, N = m_pManifest->m_dwMResNum, sizeread, L;
		BYTE	*ptr = (BYTE*)mresourceData;
		BOOL	mrfail = FALSE;
		FILE*	pFile;
		char sz[2048];
		for(i=0; i < N; i++)
		{
			memset(sz,0,2048);
			WszWideCharToMultiByte(CP_ACP,0,m_pManifest->m_wzMResName[i],-1,sz,2047,NULL,NULL);
			L = m_pManifest->m_dwMResSize[i];
			sizeread = 0;
			memcpy(ptr,&L,sizeof(DWORD));
			ptr += sizeof(DWORD);
			if(pFile = fopen(sz,"rb"))
			{
				sizeread = fread((void *)ptr,1,L,pFile);
				fclose(pFile);
				ptr += sizeread;
			}
			else
			{
				report->msg("Error: failed to open mgd resource file '%ls'\n",m_pManifest->m_wzMResName[i]);
				mrfail = TRUE;
			}
			if(sizeread < L)
			{
				report->msg("Error: failed to read expected %d bytes from mgd resource file '%ls'\n",L,m_pManifest->m_wzMResName[i]);
				mrfail = TRUE;
				L -= sizeread;
				memset(ptr,0,L);
				ptr += L;
			}
		}
		if(mrfail) 
		{ 
			hr = E_FAIL;
			goto exit;
		}
	}

	// Generate the file -- moved to main
    //if (FAILED(hr=m_pCeeFileGen->GenerateCeeFile(m_pCeeFile))) goto exit;


    hr = S_OK;

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasmenum.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "openum.h"

typedef struct
{
    char *  pszName;
    
    USHORT   Ref;   // reference codes
    
    BYTE    Type;   // Inline0 etc.

    BYTE    Len;    // std mapping
    BYTE    Std1;   
    BYTE    Std2;
} opcodeinfo_t;

#ifdef DECLARE_DATA
opcodeinfo_t OpcodeInfo[] =
{
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) s,c,args,l,s1,s2,
#include "opcode.def"
#undef OPDEF
};
#else
extern opcodeinfo_t OpcodeInfo[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasmgui.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
BOOL CreateGUI();
void GUISetModule(char *pszModule);
void GUIMainLoop();
void GUIAddOpcode(char *szString, void *GUICookie);
BOOL GUIAddItemsToList();
void GUIAddOpcode(char *szString);


BOOL DisassembleMemberByName(char *pszClassName, char *pszMemberName, char *pszSig);
BOOL IsGuiILOnly();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\ceeload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.H
// 

// CEELOAD.H defines the class use to represent the PE file
// ===========================================================================
#ifndef CEELoad_H 
#define CEELoad_H

#include <windows.h>
#include <cor.h>
//#include <wtypes.h>	// for HFILE, HANDLE, HMODULE

class PELoader;

//
// Used to cache information about sections we're interested in (descr, callsig, il)
//
class SectionInfo
{
public:
    BYTE *  m_pSection;         // pointer to the beginning of the section
    DWORD   m_dwSectionOffset;  // RVA
    DWORD   m_dwSectionSize;    

    // init this class's member variables from the provided directory
    void Init(PELoader *pPELoader, IMAGE_DATA_DIRECTORY *dir);

    // returns whether this RVA is inside the section
    BOOL InSection(DWORD dwRVA)
    {
        return (dwRVA >= m_dwSectionOffset) && (dwRVA < m_dwSectionOffset + m_dwSectionSize);
    }
};

class PELoader {
  protected:

    HMODULE m_hMod;
    HANDLE m_hFile;
    HANDLE m_hMapFile;

    PIMAGE_NT_HEADERS m_pNT;

  public:
    SectionInfo m_DescrSection;
    SectionInfo m_CallSigSection;
    SectionInfo m_ILSection;

    PELoader();
	~PELoader();
	BOOL open(const char* moduleNameIn);
	BOOL open(const WCHAR* moduleNameIn);
	BOOL open(HMODULE hMod);
	BOOL getCOMHeader(IMAGE_COR20_HEADER **ppCorHeader);
	BOOL getVAforRVA(DWORD rva,void **ppCorHeader);
	void close();
    void dump();
    inline PIMAGE_NT_HEADERS ntHeaders() { return m_pNT; }
    inline BYTE*  base() { return (BYTE*) m_hMod; }
    inline HMODULE getHModule() { return  m_hMod; }
	inline HANDLE getHFile()	{ return  m_hFile; }
};

#endif // CEELoad_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define INITGUID

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>
#include <utilcode.h>
#include <malloc.h>
#include <string.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "ceeload.h"
#include "DynamicArray.h"
#include <MetaModelPub.h>
#include "formatType.h"

#define DECLARE_DATA
#include "dasmenum.hpp"
#include "dis.h"
#include "GCDump.h"
#include "GCDecoder.cpp"

#include "dasmgui.h"
#include "resource.h"
#include "dasm_sz.h"

#include "safegetfilesize.h"

#define MAX_FILENAME_LENGTH         512     //256

#include <corsym.h>
#include "__file__.ver"
#include "corver.h"
struct MIDescriptor
{
    mdToken tkClass;    // defining class token
    mdToken tkDecl;     // implemented method token
    mdToken tkBody;     // implementing method token
    mdToken tkBodyParent;   // parent of the implementing method
};

ISymUnmanagedReader*        g_pSymReader = NULL;

IMDInternalImport*      g_pImport = NULL;
IMetaDataImport*        g_pPubImport;
extern IMetaDataAssemblyImport* g_pAssemblyImport;
PELoader *              g_pPELoader;
void *                  g_pMetaData;
IMAGE_COR20_HEADER *    g_CORHeader;
DynamicArray<__int32>   g_PtrTags;      //to keep track of all "ldptr"
DynamicArray<DWORD>   g_PtrSize;      //to keep track of all "ldptr"
int                     g_iPtrCount = 0;
//DynamicArray<mdToken>   g_cl_list;
//DynamicArray<mdToken>   g_cl_enclosing;
mdToken *				g_cl_list = NULL;
mdToken *				g_cl_enclosing = NULL;
DynamicArray<MIDescriptor>   g_mi_list;
DWORD                   g_NumMI;
DynamicArray<char*>     g_StringTags;
int                     g_iStringCount = 0;
DWORD                   g_NumClasses;
DWORD                   g_NumModules;
BOOL                    g_fDumpIL = TRUE;
BOOL                    g_fDumpHeader = FALSE;
BOOL                    g_fDumpAsmCode = TRUE;
extern BOOL             g_fDumpTokens; // declared in formatType.cpp
BOOL                    g_fDumpStats = FALSE;
BOOL                                    g_fTDC = FALSE;
BOOL                                    g_fShowCA = TRUE;

BOOL                    g_fDumpToPerfWriter = FALSE;
HANDLE                  g_PerfDataFilePtr = NULL;

BOOL                    g_fDumpClassList = FALSE;
BOOL                    g_fDumpSummary = FALSE;
BOOL                    g_fDecompile = FALSE; // still in progress
BOOL                    g_fShowBytes = FALSE;
BOOL                    g_fShowSource = FALSE;
BOOL                    g_fPrettyPrint = FALSE;
BOOL                    g_fInsertSourceLines = FALSE;
BOOL                    g_fThisIsInstanceMethod;
BOOL                    g_fTryInCode = TRUE;

BOOL                    g_fLimitedVisibility = FALSE;
BOOL                    g_fHidePub = TRUE;
BOOL                    g_fHidePriv = TRUE;
BOOL                    g_fHideFam = TRUE;
BOOL                    g_fHideAsm = TRUE;
BOOL                    g_fHideFAA = TRUE;
BOOL                    g_fHideFOA = TRUE;
BOOL                    g_fHidePrivScope = TRUE;

extern BOOL             g_fQuoteAllNames; // declared in formatType.cpp, init to FALSE
BOOL                    g_fShowProgressBar = TRUE;
extern BOOL				g_fOnUnicode;

char                    g_szAsmCodeIndent[MAX_MEMBER_LENGTH];
char                    g_szNamespace[MAX_MEMBER_LENGTH];

DWORD                   g_Mode = MODE_DUMP_ALL;
#ifdef COMPRESSION_SUPPORTED
void *                  g_pInstructionDecodingTable = NULL;
#endif

char                    g_pszClassToDump[MAX_CLASSNAME_LENGTH];
char                    g_pszMethodToDump[MAX_MEMBER_LENGTH];
char                    g_pszSigToDump[MAX_SIGNATURE_LENGTH];

BOOL                    g_fCustomInstructionEncodingSystem = FALSE;

BOOL                    g_AddContextfulAttrib = FALSE;
DynamicArray<char*>     g_ContextfulClasses;
int                     g_cContextfulClasses = 0;
BOOL                    g_AddMarshaledByRefAttrib = FALSE;
DynamicArray<char*>     g_MarshaledByRefClasses;
int                     g_cMarshaledByRefClasses = 0;

COR_FIELD_OFFSET        *g_rFieldOffset = NULL;
ULONG                   g_cFieldsMax, g_cFieldOffsets;
char					g_szInputFile[512]; // in UTF-8
char					g_szOutputFile[512]; // in UTF-8
char*					g_pszObjFileName;
FILE*                   g_pFile = NULL;

mdToken                 g_tkClassToDump = 0;
mdToken                 g_tkMethodToDump = 0;

BOOL                    g_fCheckOwnership = TRUE;
char*                   g_pszOwner = NULL;

unsigned				g_uCodePage = CP_ACP;

char*					g_rchCA = NULL; // dyn.allocated array of CA dumped/not flags
unsigned				g_uNCA = 0;		// num. of CAs

extern DynamicArray<LocalComTypeDescr*> g_pLocalComType;
extern ULONG    g_LocalComTypeNum;

// MetaInfo integration:
#include <ctype.h>
#include <crtdbg.h>
#include "..\tools\metainfo\mdinfo.h"
#include "IVEHandler.h"
BOOL                    g_fDumpMetaInfo = FALSE;
ULONG                   g_ulMetaInfoFilter = MDInfo::dumpDefault;
// Validator module type.
DWORD g_ValModuleType = ValidatorModuleTypeInvalid;
IMetaDataDispenserEx *g_pDisp = NULL;
void DisplayFile(wchar_t* szFile, BOOL isFile, ULONG DumpFilter, wchar_t* szObjFile, strPassBackFn pDisplayString);
extern mdMethodDef      g_tkEntryPoint; // integration with MetaInfo
// Abort disassembly flag:
BOOL    g_fAbortDisassembly = FALSE;

DWORD	DumpResourceToFile(WCHAR*	wzFileName); // see DRES.CPP

struct VTableRef
{
    mdMethodDef tkTok;
    WORD        wEntry;
    WORD        wSlot;
};
DynamicArray<VTableRef> g_rVTableRef;
ULONG   g_nVTableRef = 0;

#define DUMP_EAT_ENTRIES
#ifdef DUMP_EAT_ENTRIES
struct EATableRef
{
    mdMethodDef tkTok;
    char*       pszName;
};
DynamicArray<EATableRef> g_rEATableRef;
ULONG	g_nEATableRef = 0;
ULONG	g_nEATableBase = 0;
#endif

WCHAR* RstrW(unsigned n)
{
	static WCHAR wbuff[2048];
	_TCHAR* ptch = Rstr(n);
	if(sizeof(_TCHAR) == 1) // ANSI -> Unicode
	{
        memset(wbuff,0,sizeof(wbuff));
		if(!WszMultiByteToWideChar(CP_ACP,0,ptch,-1,wbuff,sizeof(wbuff)/sizeof(WCHAR)))
            wbuff[0] = 0;
        ptch = (_TCHAR*)wbuff;
    }
	return (WCHAR*)ptch;
}
char* RstrA(unsigned n)
{
	static char buff[2048];
    WCHAR* wz = RstrW(n);
    // Unicode -> UTF-8
    memset(buff,0,sizeof(buff));
    if(!WszWideCharToMultiByte(CP_UTF8,0,(LPCWSTR)wz,-1,buff,sizeof(buff),NULL,NULL))
        buff[0] = 0;
	return buff;
}
char* RstrANSI(unsigned n)
{
	static char buff[2048];
	char* ret = buff;
	_TCHAR* ptch = Rstr(n);
	if(sizeof(_TCHAR) > 1)
	{
		memset(buff,0,sizeof(buff));
		if(!WszWideCharToMultiByte(CP_ACP,0,(LPCWSTR)ptch,-1,buff,sizeof(buff),NULL,NULL))
            buff[0] = 0;
	}
	else
		ret = ptch;
	return ret;
}

DWORD FourBytesToU4(const BYTE *pBytes)
{
    return pBytes[0] | (pBytes[1] << 8) | (pBytes[2] << 16) | (pBytes[3] << 24);
}

DWORD TwoBytesToU4(const BYTE *pBytes)
{
    return pBytes[0] | (pBytes[1] << 8);
}

#ifdef COMPRESSION_SUPPORTED
void CreateInstructionDecodingTable(PELoader *pLoader, IMAGE_COR20_HEADER *pHdr)
{
    if (pHdr->Flags & COMIMAGE_FLAGS_COMPRESSIONDATA)   
    {   
        IMAGE_COR20_COMPRESSION_HEADER* compData;
        pLoader->getVAforRVA(pHdr->CompressionData.VirtualAddress, (void **) &compData);    

        if (compData->CompressionType == COR_COMPRESS_MACROS)   
        {   
            _ASSERTE(compData->Version == 0);   
            g_pInstructionDecodingTable = InstructionDecoder::CreateInstructionDecodingTable(   
                ((BYTE *) compData) + IMAGE_COR20_COMPRESSION_HEADER_SIZE, 
                pHdr->CompressionData.Size - IMAGE_COR20_COMPRESSION_HEADER_SIZE);  
            if (g_pInstructionDecodingTable == NULL)
            {
                printError(g_pFile,RstrA(IDS_E_INSTRDT));
                exit(1);
            }   
        }   
        else    
        {   
            printError(g_pFile,RstrA(IDS_E_NOCOMPR));
            exit(1);
        }   
    }   
}
#endif

#if 0
void PrintEncodingSystem()
{
    long i;

    printf("Custom opcode encoding system employed\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");

    for (i = 0; i < 256; i++)
    {
        long value = g_pInstructionDecodingTable->m_SingleByteOpcodes[i];

        printf("0x%02x --> ", i);
        printf("%s\n", OpcodeInfo[value].pszName);
    }
}
#endif

BOOL Init()
{
    CoInitialize(NULL);
    CoInitializeCor(COINITCOR_DEFAULT);
    CoInitializeEE(COINITEE_DEFAULT);
    return TRUE;
}
extern LPCSTR*  rAsmRefName;  // decl. in formatType.cpp -- for AsmRef aliases
extern ULONG	ulNumAsmRefs; // decl. in formatType.cpp -- for AsmRef aliases

void Cleanup()
{
#ifdef COMPRESSION_SUPPORTED
    if (g_pInstructionDecodingTable != NULL)
    {
        InstructionDecoder::DestroyInstructionDecodingTable(g_pInstructionDecodingTable);
        g_pInstructionDecodingTable = NULL;
    }
#endif
    if(g_pAssemblyImport)
    {
        g_pAssemblyImport->Release();
        g_pAssemblyImport = NULL;
    }
    if (g_pPubImport)
    {
        g_pPubImport->Release();
        g_pPubImport = NULL;
    }
    if (g_pImport)
    {
        g_pImport->Release();
        g_pImport = NULL;
    }
	if(g_pDisp)
	{
	    g_pDisp->Release();
		g_pDisp = NULL;
	}

    if(g_pSymReader)
    {
        g_pSymReader->Release();
        g_pSymReader = NULL;
    }
    if (g_pPELoader != NULL)
    {
        g_pPELoader->close();
        delete(g_pPELoader);
        g_pPELoader = NULL;
    }

    // Delete strings used to build ASM string table
    for(int i = 0; i< g_iStringCount; i++)
    {
        delete [] g_StringTags[i];
    }
    g_iStringCount = 0;
    g_iPtrCount = 0;
    g_NumClasses = 0;
    g_NumModules = 0;
    g_tkEntryPoint = 0;
    g_szAsmCodeIndent[0] = 0;
    g_szNamespace[0]=0;
    g_pszClassToDump[0]=0;
    g_pszMethodToDump[0]=0;
    g_pszSigToDump[0] = 0;

    g_fCustomInstructionEncodingSystem = FALSE;

    for(i = 0; i < g_cContextfulClasses; i++) delete g_ContextfulClasses[i];
    for(i = 0; i < g_cMarshaledByRefClasses; i++) delete g_MarshaledByRefClasses[i];    
    g_AddContextfulAttrib = FALSE;
    g_cContextfulClasses = 0;
    g_AddMarshaledByRefAttrib = FALSE;
    g_cMarshaledByRefClasses = 0;

    if(rAsmRefName) 
	{ 
		for(i=0; (unsigned)i < ulNumAsmRefs; i++)
		{
			if(rAsmRefName[i]) delete [] rAsmRefName[i];
		}
		delete [] rAsmRefName; 
		rAsmRefName = NULL; 
		ulNumAsmRefs = 0; 
	}

	if(g_rchCA) { delete [] g_rchCA; g_rchCA = NULL; }
}

void Uninit()
{
	GUIAddOpcode(NULL,NULL);
    CoUninitializeEE(COUNINITEE_DEFAULT);
    CoUninitializeCor();
    CoUninitialize();
}

HRESULT IsClassRefInScope(mdTypeRef classref)
{
    HRESULT     hr = S_OK;
    const char  *pszNameSpace;
    const char  *pszClassName;
    mdTypeDef   classdef;
    mdToken     tkRes;

    g_pImport->GetNameOfTypeRef(classref, &pszNameSpace, &pszClassName);
	MAKE_NAME_IF_NONE(pszClassName,classref);
    tkRes = g_pImport->GetResolutionScopeOfTypeRef(classref);

    hr = g_pImport->FindTypeDef(pszNameSpace, pszClassName,
        (TypeFromToken(tkRes) == mdtTypeRef) ? tkRes : mdTokenNil, &classdef);

    return hr;
}


BOOL EnumClasses()
{
    HRESULT         hr;
    HENUMInternal   hEnum;
    ULONG           i = 0,j;
    char            szString[1024];
    HENUMInternal   hBody;
    HENUMInternal   hDecl;

    hr = g_pImport->EnumTypeDefInit(
        &hEnum);

    if (FAILED(hr))
    {
        printError(g_pFile,RstrA(IDS_E_CLSENUM));
        return FALSE;
    }

    g_NumClasses = g_pImport->EnumTypeDefGetCount(&hEnum);

    g_tkClassToDump = 0;

    g_NumMI = 0;
	if(g_NumClasses == 0) return TRUE;
	
	if(g_cl_list) delete [] g_cl_list;
	g_cl_list = new mdToken[g_NumClasses];
	if(g_cl_list == NULL) return FALSE;

    if(g_cl_enclosing) delete [] g_cl_enclosing;
	g_cl_enclosing = new mdToken[g_NumClasses];
	if(g_cl_enclosing == NULL) 
	{ 
		delete [] g_cl_list;
		g_cl_list = NULL;
		return FALSE;
	}

    // fill the list of typedef tokens
    while(g_pImport->EnumTypeDefNext(&hEnum, &g_cl_list[i]))
    {
        const char *pszClassName;
        const char *pszNamespace;
        mdToken     tkEnclosing;
        HRESULT     hr;

        g_pImport->GetNameOfTypeDef(
            g_cl_list[i],
            &pszClassName,
            &pszNamespace
        );
		MAKE_NAME_IF_NONE(pszClassName,g_cl_list[i]);
        if (g_Mode == MODE_DUMP_CLASS || g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
        {
            if (strcmp(pszClassName, g_pszClassToDump) == 0) g_tkClassToDump = g_cl_list[i];
        }
        g_cl_enclosing[i] = mdTypeDefNil;

        hr = g_pImport->GetNestedClassProps(g_cl_list[i],&tkEnclosing);
        if(SUCCEEDED(hr) && RidFromToken(tkEnclosing))
            g_cl_enclosing[i] = tkEnclosing;
        if(SUCCEEDED(g_pImport->EnumMethodImplInit(g_cl_list[i],&hBody,&hDecl)))
        {
            if(j = g_pImport->EnumMethodImplGetCount(&hBody,&hDecl))
            {
                mdToken tkBody,tkDecl,tkBodyParent;
                for(ULONG k = 0; k < j; k++)
                {
                    if(SUCCEEDED(g_pImport->EnumMethodImplNext(&hBody,&hDecl,&tkBody,&tkDecl)))
                    {
                        if(SUCCEEDED(g_pImport->GetParentToken(tkBody,&tkBodyParent)))
                        {
                            g_mi_list[g_NumMI].tkClass = g_cl_list[i];
                            g_mi_list[g_NumMI].tkBody = tkBody;
                            g_mi_list[g_NumMI].tkDecl = tkDecl;
                            g_mi_list[g_NumMI].tkBodyParent = tkBodyParent;
                            g_NumMI++;
                        }
                    }
                }
            }
            g_pImport->EnumMethodImplClose(&hBody,&hDecl);
        }
        i++;
    }
    g_pImport->EnumTypeDefClose(&hEnum);
    // check nesting consistency
    for(i = 0; i < g_NumClasses; i++)
    {
        if(g_cl_enclosing[i] != mdTypeDefNil)
        {
            if(g_cl_enclosing[i] == g_cl_list[i])
            {
                sprintf(szString,RstrA(IDS_E_SELFNSTD),g_cl_enclosing[i]);
                printError(g_pFile,szString);
                g_cl_enclosing[i] = mdTypeDefNil;
            }
            else
            {
                for(j = 0; (j < g_NumClasses)&&(g_cl_enclosing[i] != g_cl_list[j]); j++);
                if(j == g_NumClasses)
                {
                    sprintf(szString,RstrA(IDS_E_NOENCLOS),
                        g_cl_list[i],g_cl_enclosing[i]);
                    printError(g_pFile,szString);
                    g_cl_enclosing[i] = mdTypeDefNil;
                }
            }
        }
    }

    return TRUE;
}

BOOL AddContextfulAttrib(const char* name)
{
    BOOL retVal = FALSE;
    if(g_AddContextfulAttrib)
    {
        
        for(int i = 0; i < g_cContextfulClasses; i++)        
        {
            if(lstrcmpi(g_ContextfulClasses[i], name) == 0)
            {
                retVal = TRUE;
                break;
            }
        }
    }

    return retVal;
}

BOOL AddMarshaledByRefAttrib(const char* name)
{
    BOOL retVal = FALSE;
    if(g_AddMarshaledByRefAttrib)
    {        
        for(int i = 0; i < g_cMarshaledByRefClasses; i++)        
        {
            if(lstrcmpi(g_MarshaledByRefClasses[i], name) == 0)
            {
                retVal = TRUE;
                break;
            }
        }
    }

    return retVal;
}
    

BOOL PrintClassList()
{
    DWORD           i;
    BOOL            fSuccess = FALSE;
    char    szString[1024];
    char*   szptr;

    if(g_NumClasses)
    {
        printLine(g_pFile,"// Classes defined in this module:");
        printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    
        for (i = 0; i < g_NumClasses; i++)
        {
            const char *pszClassName;
            const char *pszNamespace;
            DWORD   dwClassAttrs;
            mdTypeRef crExtends;

            g_pImport->GetNameOfTypeDef(
                g_cl_list[i],
                &pszClassName,
                &pszNamespace
            );
			MAKE_NAME_IF_NONE(pszClassName,g_cl_list[i]);
            // if this is the "<Module>" class (there is a misnomer) then skip it!
            g_pImport->GetTypeDefProps(
                g_cl_list[i],
                &dwClassAttrs,
                &crExtends
            );
			szptr = &szString[0];
            szptr+=sprintf(szptr,"// ");
            if (IsTdInterface(dwClassAttrs))        szptr+=sprintf(szptr,"Interface ");
            //else if (IsTdValueType(dwClassAttrs))   szptr+=sprintf(szptr,"Value Class");
            //else if (IsTdUnmanagedValueType(dwClassAttrs)) szptr+=sprintf(szptr,"NotInGCHeap Value Class");
            else   szptr+=sprintf(szptr,"Class ");

            szptr+=sprintf(szptr,"%-30s ", pszClassName);

            if (IsTdPublic(dwClassAttrs))           szptr+=sprintf(szptr,"(public) ");
            if (IsTdAbstract(dwClassAttrs))         szptr+=sprintf(szptr,"(abstract) ");
            if (IsTdAutoLayout(dwClassAttrs))       szptr+=sprintf(szptr,"(auto) ");
            if (IsTdSequentialLayout(dwClassAttrs)) szptr+=sprintf(szptr,"(sequential) ");
            if (IsTdExplicitLayout(dwClassAttrs))   szptr+=sprintf(szptr,"(explicit) ");
            if (IsTdAnsiClass(dwClassAttrs))        szptr+=sprintf(szptr,"(ansi) ");
            if (IsTdUnicodeClass(dwClassAttrs))     szptr+=sprintf(szptr,"(unicode) ");
            if (IsTdAutoClass(dwClassAttrs))        szptr+=sprintf(szptr,"(autochar) ");
            if (IsTdImport(dwClassAttrs))           szptr+=sprintf(szptr,"(import) ");
            //if (IsTdEnum(dwClassAttrs))             szptr+=sprintf(szptr,"(enum) ");
            if (IsTdSealed(dwClassAttrs))           szptr+=sprintf(szptr,"(sealed) ");
            if (IsTdNestedPublic(dwClassAttrs))     szptr+=sprintf(szptr,"(nested public) ");
            if (IsTdNestedPrivate(dwClassAttrs))    szptr+=sprintf(szptr,"(nested private) ");
            if (IsTdNestedFamily(dwClassAttrs))     szptr+=sprintf(szptr,"(nested family) ");
            if (IsTdNestedAssembly(dwClassAttrs))   szptr+=sprintf(szptr,"(nested assembly) ");
            if (IsTdNestedFamANDAssem(dwClassAttrs))   szptr+=sprintf(szptr,"(nested famANDassem) ");
            if (IsTdNestedFamORAssem(dwClassAttrs))    szptr+=sprintf(szptr,"(nested famORassem) ");

            printLine(g_pFile,szString);
        }
        printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        printLine(g_pFile,"");
    }
    else
        printLine(g_pFile,"// No classes defined in this module");
    fSuccess = TRUE;

    return fSuccess;
}

BOOL ValidateToken(mdToken tk, ULONG type = ~0)
{
    BOOL        bRtn;
    char szString[1024];
    bRtn = g_pImport->IsValidToken(tk);
    if (!bRtn)
    {
        sprintf(szString,RstrA(IDS_E_INVALIDTK), tk);
        printError(g_pFile,szString);
    }
    else if (type != ~0 && TypeFromToken(tk) != type)
    {
        sprintf(szString,RstrA(IDS_E_UNEXPTYPE),
               TypeFromToken(type), TypeFromToken(tk));
        printError(g_pFile,szString);
        bRtn = FALSE;
    }
    return bRtn;
}


BOOL DumpModule(mdModuleRef mdMod)
{
    const char  *pszModName;
    char szString[1024];
    g_pImport->GetModuleRefProps(mdMod,&pszModName);
	MAKE_NAME_IF_NONE(pszModName,mdMod);
    sprintf(szString,"%s.import \"%s\"",g_szAsmCodeIndent,pszModName); // what about GUID and MVID?
    printLine(g_pFile,szString);
    return TRUE;
}

char* DumpPinvokeMap(DWORD   dwMappingFlags, const char  *szImportName, 
                    mdModuleRef    mrImportDLL, char* szString, void* GUICookie)
{
    const char  *szImportDLLName;
    char*   szptr = &szString[strlen(szString)];

    g_pImport->GetModuleRefProps(mrImportDLL,&szImportDLLName);
    if(strlen(szImportDLLName))					szptr = DumpQString(GUICookie,
																	(char*)szImportDLLName,
																	szString,
																	g_szAsmCodeIndent,
																	80);
    //if(strlen(szImportDLLName))					szptr+=sprintf(szptr,"\"%s\"",szImportDLLName);
    //if(szImportName && strlen(szImportName))    szptr+=sprintf(szptr," as \"%s\"",szImportName);
    if(szImportName && strlen(szImportName))
	{
		szptr+=sprintf(szptr," as ");
		szptr = DumpQString(GUICookie,
							(char*)szImportName,
							szString,
							g_szAsmCodeIndent,
							80);
	}
    if(IsPmNoMangle(dwMappingFlags))            szptr+=sprintf(szptr," nomangle");
    if(IsPmCharSetAnsi(dwMappingFlags))         szptr+=sprintf(szptr," ansi");
    if(IsPmCharSetUnicode(dwMappingFlags))      szptr+=sprintf(szptr," unicode");
    if(IsPmCharSetAuto(dwMappingFlags))         szptr+=sprintf(szptr," autochar");
    if(IsPmSupportsLastError(dwMappingFlags))   szptr+=sprintf(szptr," lasterr");
    if(IsPmCallConvWinapi(dwMappingFlags))      szptr+=sprintf(szptr," winapi");
    if(IsPmCallConvCdecl(dwMappingFlags))       szptr+=sprintf(szptr," cdecl");
    if(IsPmCallConvThiscall(dwMappingFlags))    szptr+=sprintf(szptr," thiscall");
    if(IsPmCallConvFastcall(dwMappingFlags))    szptr+=sprintf(szptr," fastcall");
    if(IsPmBestFitEnabled(dwMappingFlags))        szptr+=sprintf(szptr," bestfit:on");
    if(IsPmBestFitDisabled(dwMappingFlags))       szptr+=sprintf(szptr," bestfit:off");
    if(IsPmThrowOnUnmappableCharEnabled(dwMappingFlags))        szptr+=sprintf(szptr," charmaperror:on");
    if(IsPmThrowOnUnmappableCharDisabled(dwMappingFlags))       szptr+=sprintf(szptr," charmaperror:off");
    return szptr;
}

void DumpByteArray(char* szString, BYTE* pBlob, ULONG ulLen, void* GUICookie)
{
    ULONG ulStrOffset,j,k;
    char sz[32];
    bool printsz = FALSE;
    char* szptr;
   
    ulStrOffset = strlen(szString);
    szptr = &szString[ulStrOffset];
	if(!pBlob) ulLen = 0;
    for(j = 0, k=0; j < ulLen; j++,k++)
    {
        if(k == 16)
        {
            if(printsz) sprintf(szptr,"  // %s",sz);
            printLine(GUICookie,szString);
			strcpy(szString,g_szAsmCodeIndent);
            for(k=strlen(szString); k < ulStrOffset; k++) szString[k] = ' ';
            szString[k] = 0;
            szptr = &szString[ulStrOffset];
            k = 0;
            printsz = FALSE;
        }
        szptr+=sprintf(szptr,"%2.2X ",pBlob[j]);
        if(isprint(pBlob[j]))
        {
            sz[k] = pBlob[j];
            printsz = TRUE;
        }
        else sz[k] = '.';
        sz[k+1] = 0;
    }
    szptr+=sprintf(szptr,") ");
    if(printsz)
    {
        for(j = k; j < 16; j++) szptr+=sprintf(szptr,"   ");
        szptr+=sprintf(szptr,"// %s",sz);
    }
}

void DumpCustomAttribute(mdCustomAttribute tkCA, void *GUICookie, bool bWithOwner)
{
    mdToken         tkType;
    BYTE*           pBlob=NULL;
    ULONG           ulLen=0;
    char            szString[4096];
    char*           szptr = &szString[0];
    BOOL            fCommentItOut = FALSE;
	mdToken			tkOwner;
	static mdToken	tkMod = 0xFFFFFFFF;

	_ASSERTE((TypeFromToken(tkCA)==mdtCustomAttribute)&&(RidFromToken(tkCA)>0));
	_ASSERTE(RidFromToken(tkCA) <= g_uNCA);
	if(tkMod == 0xFFFFFFFF) tkMod = g_pImport->GetModuleFromScope();

	// can't use InternalImport here: need the tkOwner 
    g_pPubImport->GetCustomAttributeProps(              // S_OK or error.
                                            tkCA,     // [IN] CustomValue token.
                                            &tkOwner,       // [OUT, OPTIONAL] Object token.
                                            &tkType,    // [OUT, OPTIONAL] Put TypeDef/TypeRef token here.
                                (const void **)&pBlob,  // [OUT, OPTIONAL] Put pointer to data here.
                                            &ulLen);    // [OUT, OPTIONAL] Put size of date here.

	if(!RidFromToken(tkOwner)) return;
	if(tkType == 0x02000001)
	{
		if(tkOwner == tkMod)
		{
            if(g_fCheckOwnership) return;
            fCommentItOut = TRUE;
		}
	}
	else if((TypeFromToken(tkType) == mdtMemberRef)||(TypeFromToken(tkType) == mdtMethodDef))
	{
		mdToken tkParent;
        const char *    pszClassName = NULL;
        const char *    pszNamespace = NULL;
		if(TypeFromToken(tkType) == mdtMemberRef)
			tkParent =  g_pImport->GetParentOfMemberRef(tkType);
		else
			g_pImport->GetParentToken(tkType,&tkParent);

		if(TypeFromToken(tkParent)==mdtTypeDef)
		{
			g_pImport->GetNameOfTypeDef(tkParent, &pszClassName, &pszNamespace);
		}
		else if(TypeFromToken(tkParent)==mdtTypeRef)
		{
			g_pImport->GetNameOfTypeRef(tkParent, &pszNamespace, &pszClassName);
		}
		if(pszClassName && pszNamespace 
			&& (strcmp(pszNamespace,"System.Diagnostics") == 0)
			&& (strcmp(pszClassName,"DebuggableAttribute") == 0)) fCommentItOut = TRUE;


    }
    if(fCommentItOut)
    {
        sprintf(szString,RstrA(IDS_E_AUTOCA),g_szAsmCodeIndent);
        printLine(GUICookie, szString);
		strcat(g_szAsmCodeIndent,"//  ");
    }
	szptr+=sprintf(szptr,"%s.custom ",g_szAsmCodeIndent);
	if(bWithOwner)
	{
		if(g_fDumpTokens)   szptr+=sprintf(szptr,"/*%08X*/ ",tkCA);
		szptr+=sprintf(szptr,"(");
		switch(TypeFromToken(tkOwner))
		{
			case mdtTypeDef :
			case mdtTypeRef	:
			case mdtTypeSpec:
				{
					CQuickBytes out;
					szptr+=sprintf(szptr, "%s",PrettyPrintClass(&out, tkOwner, g_pImport));
				}
				break;

			case mdtMemberRef:
				{
					PCCOR_SIGNATURE typePtr;
					const char*		pszMemberName;
					ULONG			cComSig;

					pszMemberName = g_pImport->GetNameAndSigOfMemberRef(
						tkOwner,
						&typePtr,
						&cComSig
					);
					unsigned callConv = CorSigUncompressData(typePtr);  

					if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
						szptr+=sprintf(szptr,"field ");
					else
						szptr+=sprintf(szptr,"method ");
					PrettyPrintMemberRef(szString,tkOwner,g_pImport,GUICookie);
				}
				break;

			case mdtMethodDef:
				szptr += sprintf(szptr, "method ");
				PrettyPrintMethodDef(szString,tkOwner,g_pImport,GUICookie);
				break;

			default :
				strcat(szString,"UNKNOWN_OWNER");
				break;
		}
	    szptr = &szString[strlen(szString)];
		if(g_fDumpTokens)   szptr+=sprintf(szptr,"/*%08X*/ ",tkOwner);
		szptr+=sprintf(szptr,") ");
	}
	else
	{
		if(g_fDumpTokens)   szptr+=sprintf(szptr,"/*%08X:%08X*/ ",tkCA,tkType);
	}
    switch(TypeFromToken(tkType))
    {
        case mdtTypeDef :
        case mdtTypeRef	:
			{
				CQuickBytes out;
				szptr+=sprintf(szptr, "%s",PrettyPrintClass(&out, tkType, g_pImport));
			}
            break;

        case mdtMemberRef:
            PrettyPrintMemberRef(szString,tkType,g_pImport,GUICookie);
            break;

        case mdtMethodDef:
            PrettyPrintMethodDef(szString,tkType,g_pImport,GUICookie);
            break;

        default :
            strcat(szString,"UNNAMED_CUSTOM_ATTR");
            break;
    }
    szptr = &szString[strlen(szString)];
    if(pBlob && ulLen)
    {
        ULONG ulStrOffset,j;

        ulStrOffset = strlen(szString);
        if(ulStrOffset+ulLen+5 >= sizeof(szString)) goto DumpAsHexbytes;

        for(j = 0; (j < ulLen)&&(isprint(pBlob[j])); j++);
        if(j == ulLen) // all symbols printable, display it as quoted string
        {
            szptr+=sprintf(szptr," = \"");
            ulStrOffset = strlen(szString);
            memcpy(&szString[strlen(szString)],pBlob,ulLen);
            szptr+=ulLen;
            szptr+=sprintf(szptr,"\"");
        }
        else
        {
DumpAsHexbytes:
            sprintf(szptr," = ( ");
            DumpByteArray(szString,pBlob,ulLen,GUICookie);
        }
    }
    printLine(GUICookie, szString);
    if(fCommentItOut) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-4] = 0;
	_ASSERTE(g_rchCA);
	_ASSERTE(RidFromToken(tkCA) <= g_uNCA);
	g_rchCA[RidFromToken(tkCA)] = 1;
}

void DumpCustomAttributes(mdToken tkOwner, void *GUICookie)
{
    if(g_fShowCA)
    {
        HENUMInternal    hEnum;
        mdCustomAttribute tkCA;
        
        g_pImport->EnumInit(mdtCustomAttribute, tkOwner,&hEnum);
        while(g_pImport->EnumNext(&hEnum,&tkCA) && RidFromToken(tkCA))
        {
            DumpCustomAttribute(tkCA,GUICookie,false);
        }
        g_pImport->EnumClose( &hEnum);
    }
}

void DumpDefaultValue(mdToken tok, char* szString, void* GUICookie)
{
    MDDefaultValue  MDDV;
    char*           szptr = &szString[strlen(szString)];

    g_pImport->GetDefaultValue(tok,&MDDV);
    switch(MDDV.m_bType)
    {
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
            szptr+=sprintf(szptr," = int8(0x%02X)",MDDV.m_byteValue);
            break;
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
            szptr+=sprintf(szptr," = int16(0x%04X)",MDDV.m_usValue);
            break;
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
            szptr+=sprintf(szptr," = int32(0x%08X)",MDDV.m_ulValue);
            break;
		case ELEMENT_TYPE_CHAR:
			szptr+=sprintf(szptr," = char(0x%04X)",MDDV.m_usValue);
			break;
		case ELEMENT_TYPE_BOOLEAN:
			szptr+=sprintf(szptr," = bool(%s)",MDDV.m_byteValue ? "true" : "false");
			break;
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
            szptr+=sprintf(szptr," = int64(0x%I64X)",MDDV.m_ullValue);
            break;
        case ELEMENT_TYPE_R4:
            {
                char szf[32];
                _gcvt(MDDV.m_fltValue, 8, szf);
                float df = (float)atof(szf);
                if((df == MDDV.m_fltValue)&&(strchr(szf,'#') == NULL))
                    szptr+=sprintf(szptr," = float32(%s)",szf);             
                else
                    szptr+=sprintf(szptr, " = float32(0x%08X)",MDDV.m_ulValue);
                
            }
            break;
        case ELEMENT_TYPE_R8:
            {
                char szf[32], *pch;
                _gcvt(MDDV.m_dblValue, 17, szf);
                double df = strtod(szf, &pch); //atof(szf);
                szf[31]=0;
                if((df == MDDV.m_dblValue)&&(strchr(szf,'#') == NULL))
                    szptr+=sprintf(szptr," = float64(%s)",szf);             
                else
                    szptr+=sprintf(szptr, " = float64(0x%I64X) // %s",MDDV.m_ullValue,szf);
            }
            break;

        case ELEMENT_TYPE_STRING:
			szptr+=sprintf(szptr," = ");
			szptr = DumpUnicodeString(GUICookie,szString,(WCHAR*)MDDV.m_wzValue,MDDV.m_cbSize/sizeof(WCHAR));
            break;

        case ELEMENT_TYPE_CLASS:
			if(MDDV.m_wzValue==NULL)
			{
				szptr+=sprintf(szptr," = nullref");
				break;
			}
			//else fall thru to default case, to report the error

		default:
			szptr+=sprintf(szptr," /* ILLEGAL CONSTANT type:0x%02X, size:%d bytes, blob: ",MDDV.m_bType,MDDV.m_cbSize);
			if(MDDV.m_wzValue)
			{
				szptr+=sprintf(szptr,"(");
				DumpByteArray(szString,(BYTE*)MDDV.m_wzValue,MDDV.m_cbSize,GUICookie);
			}
			else
			{
				szptr+=sprintf(szptr,"NULL");
			}
			strcat(szString, " */");
			break;
    }
}

void DumpParams(ParamDescriptor* pPD, ULONG ulParams, void* GUICookie)
{
    if(pPD)
    {
        for(ULONG i = ulParams; i<2*ulParams+1; i++) // pPD[ulParams] is return value
        {
            ULONG j = i % (ulParams+1);
            if(RidFromToken(pPD[j].tok))
            {
				HENUMInternal    hEnum;
				mdCustomAttribute tkCA;
                ULONG           ulCAs= 0;

                if(g_fShowCA)
				{
					g_pImport->EnumInit(mdtCustomAttribute, pPD[j].tok,&hEnum);
					ulCAs = g_pImport->EnumGetCount(&hEnum);
				}
                if(ulCAs || IsPdHasDefault(pPD[j].attr))
                {
                    char    szString[4096], *szptr = &szString[0];
                    szptr+=sprintf(szptr,"%s.param [%d]",g_szAsmCodeIndent,i-ulParams);
					if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",pPD[j].tok);
					if(IsPdHasDefault(pPD[j].attr)) DumpDefaultValue(pPD[j].tok, szString, GUICookie);
                    printLine(GUICookie, szString);
					if(ulCAs)
					{
						while(g_pImport->EnumNext(&hEnum,&tkCA) && RidFromToken(tkCA))
						{
							DumpCustomAttribute(tkCA,GUICookie,false);
						}
					}
                }
		        if(g_fShowCA) g_pImport->EnumClose( &hEnum);
            }
        }
    }
}

void DumpPermissions(mdToken tkOwner, void* GUICookie)
{
    HCORENUM hEnum = NULL;
    mdPermission rPerm[16384];
    ULONG count;
    HRESULT hr;
    char    szString[4096];

	// can't use internal import here: EnumInit not impl. for mdtPrmission
    while (SUCCEEDED(hr = g_pPubImport->EnumPermissionSets( &hEnum,
                     tkOwner, 0, rPerm, 16384, &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++)
        {
            DWORD dwAction;
            const BYTE *pvPermission=NULL;
            ULONG cbPermission=0;
            char *szAction;


            if(SUCCEEDED(hr = g_pPubImport->GetPermissionSetProps( rPerm[i], &dwAction,
                                                (const void**)&pvPermission, &cbPermission)))
            {
                switch(dwAction)
                {
                    case dclActionNil:          szAction = ""; break;
                    case dclRequest:            szAction = "request"; break;
                    case dclDemand:             szAction = "demand"; break;
                    case dclAssert:             szAction = "assert"; break;
                    case dclDeny:               szAction = "deny"; break;
                    case dclPermitOnly:         szAction = "permitonly"; break;
                    case dclLinktimeCheck:      szAction = "linkcheck"; break;
                    case dclInheritanceCheck:   szAction = "inheritcheck"; break;
                    case dclRequestMinimum:             szAction = "reqmin"; break;
                    case dclRequestOptional:    szAction = "reqopt"; break;
                    case dclRequestRefuse:      szAction = "reqrefuse"; break;
                    case dclPrejitGrant:                szAction = "prejitgrant"; break;
                    case dclPrejitDenied:               szAction = "prejitdeny"; break;
                    case dclNonCasDemand:               szAction = "noncasdemand"; break;
                    case dclNonCasLinkDemand:           szAction = "noncaslinkdemand"; break;
                    case dclNonCasInheritance:          szAction = "noncasinheritance"; break;
                    default:                    szAction = "<UNKNOWN_ACTION>"; break;
                }
                if(pvPermission && cbPermission)
                {
                    sprintf(szString,"%s.permissionset %s = (",g_szAsmCodeIndent,szAction);

                    DumpByteArray(szString,(BYTE*)pvPermission,cbPermission,GUICookie);
                    printLine(GUICookie,szString);
                }
                else // i.e. if pvPermission == NULL or cbPermission == NULL
                {
                    sprintf(szString,"%s.permissionset %s = ()",g_szAsmCodeIndent,szAction);
                    printLine(GUICookie,szString);
                }
                DumpCustomAttributes(rPerm[i],GUICookie);   
            }// end if(GetPermissionProps)
        } // end for(all permissions)
    }//end while(EnumPermissionSets)
    g_pPubImport->CloseEnum( hEnum);
}

void PrettyPrintMethodSig(char* szString, unsigned* puStringLen, CQuickBytes* pqbMemberSig, PCCOR_SIGNATURE pComSig, ULONG cComSig,
						  char* buff, char* szArgPrefix, void* GUICookie)
{
    if(*buff && (strlen(szString) > 40))
    {
        printLine(GUICookie,szString);
        strcpy(szString,g_szAsmCodeIndent);
        strcat(szString,"        "); // to align with ".method "
    }
    appendStr(pqbMemberSig, szString);
    {
        char* pszTailSig = (char*)PrettyPrintSig(pComSig, cComSig, buff, pqbMemberSig, g_pImport,szArgPrefix);
		if(*buff)
		{
			char* newbuff = new char[strlen(buff)+3];
			sprintf(newbuff," %s(", buff);
			char* pszOffset = strstr(pszTailSig,newbuff);
			if(pszOffset)
			{
				if(pszOffset - pszTailSig > 40)
				{
					char* pszOffset2 = strstr(pszTailSig," marshal(");
					if(pszOffset2 && (pszOffset2 < pszOffset))
					{
						*pszOffset2 = 0;
						printLine(GUICookie,pszTailSig);
						strcpy(pszTailSig,g_szAsmCodeIndent);
						strcat(pszTailSig,"        "); // to align with ".method "
						strcat(pszTailSig,pszOffset2+1);
						pszOffset = strstr(pszTailSig,newbuff);
					}
					*pszOffset = 0 ;
					printLine(GUICookie,pszTailSig);
					strcpy(pszTailSig,g_szAsmCodeIndent);
					strcat(pszTailSig,"        "); // to align with ".method "
					strcat(pszTailSig,pszOffset+1);
					pszOffset = strstr(pszTailSig,newbuff);
				}
				int i, j, k, indent = pszOffset - pszTailSig + strlen(buff) + 2;
				char chAfterComma;
				char *pComma = pszTailSig+strlen(buff), *pch;
				while(pComma = strchr(pComma,','))
				{
					for(pch = pszTailSig, i=0, j = 0, k=0; pch < pComma; pch++)
					{
						if(*pch == '\'') j=1-j;
						else if(*pch == '\"') k=1-k;
						else if(j==0)
						{
								if(*pch == '[') i++;
								else if(*pch == ']') i--;
						}
					}
					pComma++; 
					if((i==0)&&(j==0)&&(k==0))// no brackets/quotes or all opened/closed
					{
						chAfterComma = *pComma;
						*pComma = 0;
						printLine(GUICookie,pszTailSig);
						*pComma = chAfterComma;
						for(i=0; i<indent; i++) pszTailSig[i] = ' ';
						strcpy(&pszTailSig[indent],pComma);
						pComma = pszTailSig;
					}
				}
				if(*puStringLen < (unsigned)strlen(pszTailSig)+128)
				{
					free(szString);
					*puStringLen = (unsigned)strlen(pszTailSig)+128; // need additional space for "il managed" etc.
					szString = (char*)malloc(*puStringLen);
				}
			}
			sprintf(szString,"%s",pszTailSig);
			delete newbuff;
		}
		else // it's for GUI, don't split it into several lines
		{
			ULONG L = strlen(szString);
			if(L < 2048)
			{
				L = 2048-L;
				strncpy(szString,pszTailSig,L);
			}
		}
    }
}
BOOL DumpMethod(mdToken FuncToken, const char *pszClassName, DWORD dwEntryPointToken,void *GUICookie,BOOL DumpBody)
{
    const char      *pszMemberName;//[MAX_MEMBER_LENGTH];
    int             nAccess=0;
    const char      *pszMemberSig;
    DWORD           dwAttrs;
    DWORD           dwImplAttrs;
    DWORD           dwOffset;
    DWORD           dwTargetRVA;
    CQuickBytes     qbMemberSig;
    PCCOR_SIGNATURE pComSig;
    ULONG           cComSig;
    char            *buff;//[MAX_MEMBER_LENGTH];
    char            *szString;
    ParamDescriptor* pszArgname = NULL;
    ULONG           ulArgs=0;
    unsigned        retParamIx;
	unsigned		uStringLen = 4096;

    char szArgPrefix[16];
    char*           szptr;
    mdToken         OrigFuncToken = FuncToken;
//_ASSERTE(0);
    dwAttrs = g_pImport->GetMethodDefProps(FuncToken);
    if(g_fLimitedVisibility)
    {
            if(g_fHidePub && IsMdPublic(dwAttrs)) return FALSE;
            if(g_fHidePriv && IsMdPrivate(dwAttrs)) return FALSE;
            if(g_fHideFam && IsMdFamily(dwAttrs)) return FALSE;
            if(g_fHideAsm && IsMdAssem(dwAttrs)) return FALSE;
            if(g_fHideFOA && IsMdFamORAssem(dwAttrs)) return FALSE;
            if(g_fHideFAA && IsMdFamANDAssem(dwAttrs)) return FALSE;
            if(g_fHidePrivScope && IsMdPrivateScope(dwAttrs)) return FALSE;
    }
    //if(g_fPubOnly && !(IsMdPublic(dwAttrs) || IsMdFamily(dwAttrs) || IsMdFamORAssem(dwAttrs))) return FALSE;
    g_pImport->GetMethodImplProps(FuncToken, &dwOffset, &dwImplAttrs );
    pszMemberName = g_pImport->GetNameOfMethodDef(FuncToken);
	MAKE_NAME_IF_NONE(pszMemberName,FuncToken);
    pComSig = g_pImport->GetSigOfMethodDef(FuncToken, &cComSig);

	if(cComSig == 0)
	{
		char sz[2048];
		sprintf(sz,"%sERROR: method '%s' has no signature",g_szAsmCodeIndent,pszMemberName);
		printError(GUICookie,sz);
		return FALSE;
	}
    pszMemberSig = PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL);
    
    if (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
    {
        if (strcmp(pszMemberName, g_pszMethodToDump) != 0) return FALSE;

        if (g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
        {
            if (strcmp(pszMemberSig, g_pszSigToDump) != 0) return FALSE;
        }
    }

    if(!DumpBody)
    {
        printLine(GUICookie,(char*)pszMemberSig);
        return TRUE;
    }

	szString = (char*)malloc(uStringLen);
	szptr = &szString[0];
    szString[0] = 0;
    if(DumpBody) szptr+=sprintf(szptr,"%s.method ",g_szAsmCodeIndent);
    else szptr+=sprintf(szptr,".method ");

    if(g_fDumpTokens)               szptr+=sprintf(szptr,"/*%08X*/ ",FuncToken);
    if(IsMdPublic(dwAttrs))         szptr+=sprintf(szptr,"public ");
    if(IsMdPrivate(dwAttrs))        szptr+=sprintf(szptr,"private ");
    if(IsMdFamily(dwAttrs))         szptr+=sprintf(szptr,"family ");
    if(IsMdAssem(dwAttrs))          szptr+=sprintf(szptr,"assembly ");
    if(IsMdFamANDAssem(dwAttrs))    szptr+=sprintf(szptr,"famandassem ");
    if(IsMdFamORAssem(dwAttrs))     szptr+=sprintf(szptr,"famorassem ");
    if(IsMdPrivateScope(dwAttrs))   szptr+=sprintf(szptr,"privatescope ");
    if(IsMdHideBySig(dwAttrs))      szptr+=sprintf(szptr,"hidebysig ");
    if(IsMdNewSlot(dwAttrs))        szptr+=sprintf(szptr,"newslot ");
    if(IsMdSpecialName(dwAttrs))    szptr+=sprintf(szptr,"specialname ");
    if(IsMdRTSpecialName(dwAttrs))  szptr+=sprintf(szptr,"rtspecialname ");
    if (IsMdStatic(dwAttrs))        szptr+=sprintf(szptr,"static ");
    if (IsMdAbstract(dwAttrs))      szptr+=sprintf(szptr,"abstract ");
    if (dwAttrs & 0x00000200)       szptr+=sprintf(szptr,"strict ");
    if (IsMdVirtual(dwAttrs))       szptr+=sprintf(szptr,"virtual ");
    if (IsMdFinal(dwAttrs))         szptr+=sprintf(szptr,"final ");
    if (IsMdUnmanagedExport(dwAttrs))      szptr+=sprintf(szptr,"unmanagedexp ");
	if(IsMdRequireSecObject(dwAttrs))      szptr+=sprintf(szptr,"reqsecobj ");
    if (IsMdPinvokeImpl(dwAttrs))
    {
        DWORD   dwMappingFlags;
        const char  *szImportName;
        mdModuleRef mrImportDLL;

        szptr+=sprintf(szptr,"pinvokeimpl(");
        if(FAILED(g_pImport->GetPinvokeMap(FuncToken,&dwMappingFlags,
            &szImportName,&mrImportDLL)))  szptr+=sprintf(szptr,"/* No map */");
        else
            szptr=DumpPinvokeMap(dwMappingFlags,  (strcmp(szImportName,pszMemberName)? szImportName : NULL), 
                mrImportDLL,szString,GUICookie);
        szptr+=sprintf(szptr,") ");
    }
    // A little hack to get the formatting we need for Assem.
    g_fThisIsInstanceMethod = !IsMdStatic(dwAttrs);
	{
		char *psz;
		if(IsMdPrivateScope(dwAttrs))
		{
			buff = new char[strlen(pszMemberName)+15];
			sprintf(buff,"%s$PST%08X", pszMemberName,FuncToken );
		}
		else
		{
			buff = new char[strlen(pszMemberName)+3];
			sprintf(buff,"%s", pszMemberName );
		}
		psz = ProperName(buff);
		delete [] buff;
		buff = new char[strlen(psz)+1];
		strcpy(buff,psz);
	}
    qbMemberSig.ReSize(0);
    // Get the argument names, if any
    strcpy(szArgPrefix,(g_fThisIsInstanceMethod ? "A1": "A0"));
    {
        PCCOR_SIGNATURE typePtr = pComSig;
        CorSigUncompressData(typePtr);  // get the calling convention out of the way  
        unsigned  numArgs = CorSigUncompressData(typePtr)+1;
		HENUMInternal    hArgEnum;
        mdParamDef  tkArg;
        g_pImport->EnumInit(mdtParamDef,FuncToken,&hArgEnum);
		ulArgs = g_pImport->EnumGetCount(&hArgEnum);
        retParamIx = numArgs-1;
        if(ulArgs < numArgs) ulArgs = numArgs;
        if(ulArgs)
        {
            pszArgname = new ParamDescriptor[ulArgs+2];
            memset(pszArgname,0,(ulArgs+2)*sizeof(ParamDescriptor));
			LPCSTR szName;
            ULONG ulSequence, ix;
            DWORD dwAttr;
			for(ULONG j=0; g_pImport->EnumNext(&hArgEnum,&tkArg) && RidFromToken(tkArg); j++)
            {
				ulSequence = 0;
				szName = g_pImport->GetParamDefProps(tkArg,(USHORT*)&ulSequence,&dwAttr);
                if(ulSequence > ulArgs+1)
                {
                    char sz[256];
                    sprintf(sz,RstrA(IDS_E_PARAMSEQNO),j,ulSequence,ulSequence);
                    printError(GUICookie,sz);
                }
				else
				{
					ix = retParamIx;
					if(ulSequence)
					{
						ix = ulSequence-1;
						if(*szName)
						{
							pszArgname[ix].name = new char[strlen(szName)+1];
							strcpy(pszArgname[ix].name,szName);
						}
					}
					pszArgname[ix].attr = dwAttr;
					pszArgname[ix].tok = tkArg;
				}
			}// end for( along the params)
			for(j=0; j <numArgs; j++)
            {
                if(pszArgname[j].name == NULL) // we haven't got the name!
                {
                    pszArgname[j].name = new char[16];
                    *pszArgname[j].name = 0;
                }
                if(*pszArgname[j].name == 0) // we haven't got the name!
                {
                    sprintf(pszArgname[j].name,"A_%d",g_fThisIsInstanceMethod ? j+1 : j);
                }
            }// end for( along the argnames)
            sprintf(szArgPrefix,"@%d0",pszArgname);
        } //end if (ulArgs)
        g_pImport->EnumClose(&hArgEnum);
    }
	PrettyPrintMethodSig(szString, &uStringLen, &qbMemberSig, pComSig, cComSig,
						  buff, szArgPrefix, GUICookie);
    szptr = &szString[strlen(szString)];
    delete buff;

    if(IsMiNative(dwImplAttrs))         szptr+=sprintf(szptr," native");
    if(IsMiIL(dwImplAttrs))             szptr+=sprintf(szptr," cil");
    if(IsMiOPTIL(dwImplAttrs))          szptr+=sprintf(szptr," optil");
    if(IsMiRuntime(dwImplAttrs))        szptr+=sprintf(szptr," runtime");
    if(IsMiUnmanaged(dwImplAttrs))      szptr+=sprintf(szptr," unmanaged");
    if(IsMiManaged(dwImplAttrs))        szptr+=sprintf(szptr," managed");
    if(IsMiPreserveSig(dwImplAttrs))    szptr+=sprintf(szptr," preservesig");
    if(IsMiForwardRef(dwImplAttrs))     szptr+=sprintf(szptr," forwardref");
    if(IsMiInternalCall(dwImplAttrs))   szptr+=sprintf(szptr," internalcall");
    if(IsMiSynchronized(dwImplAttrs))   szptr+=sprintf(szptr," synchronized");
    if(IsMiNoInlining(dwImplAttrs))     szptr+=sprintf(szptr," noinlining");

    printLine(GUICookie, szString);

    if(!DumpBody)
	{
		free(szString);
		return TRUE;
	}

	if(g_fShowBytes)
	{
	    pComSig = g_pImport->GetSigOfMethodDef(FuncToken, &cComSig);
		szptr = &szString[0];
		szptr+=sprintf(szptr,"%s// SIG:", g_szAsmCodeIndent);
		for(ULONG i=0; i<cComSig; i++) szptr+=sprintf(szptr," %02X",pComSig[i]);
		printLine(GUICookie, szString); 
	}
	
    szptr = &szString[0];
    szptr+=sprintf(szptr,"%s{", g_szAsmCodeIndent);
    printLine(GUICookie, szString); 
    szptr = &szString[0];
    strcat(g_szAsmCodeIndent,"  ");

    // We have recoreded the entry point token from the CLR Header.  Check to see if this
    // method is the entry point.
    if(FuncToken == static_cast<mdToken>(dwEntryPointToken))
    {
        sprintf(szString,"%s.entrypoint", g_szAsmCodeIndent);
        printLine(GUICookie, szString); 
    }
    DumpCustomAttributes(FuncToken,GUICookie);
    DumpParams(pszArgname, retParamIx, GUICookie);
    DumpPermissions(FuncToken,GUICookie);
    // Check if the method represents entry in VTable fixups and in EATable
    {
        for(ULONG j=0; j<g_nVTableRef; j++)
        {
            if(g_rVTableRef[j].tkTok == FuncToken)
            {
                sprintf(szString,"%s.vtentry %d : %d", 
                    g_szAsmCodeIndent,g_rVTableRef[j].wEntry+1,g_rVTableRef[j].wSlot+1);
                printLine(GUICookie, szString); 
                break;
            }
        }
#ifdef DUMP_EAT_ENTRIES
        for(j=0; j<g_nEATableRef; j++)
        {
            if(g_rEATableRef[j].tkTok == FuncToken)
            {
                sprintf(szString,"%s.export [%d] as %s", 
                    g_szAsmCodeIndent,j+g_nEATableBase, ProperName(g_rEATableRef[j].pszName));
                printLine(GUICookie, szString); 
                break;
            }
        }
#endif
    }
    // Dump method impls of this method:
    for(ULONG i = 0; i < g_NumMI; i++)
    {
        if(g_mi_list[i].tkBody == FuncToken)
        {
            const char *    pszMemberName;
            mdToken         tkDeclParent;
            szptr = &szString[0];
            szptr+=sprintf(szptr,"%s.override ",g_szAsmCodeIndent);
            if(TypeFromToken(g_mi_list[i].tkDecl) == mdtMethodDef)
                pszMemberName = g_pImport->GetNameOfMethodDef(g_mi_list[i].tkDecl);
            else 
            {
                PCCOR_SIGNATURE pComSig;
                ULONG       cComSig;

                pszMemberName = g_pImport->GetNameAndSigOfMemberRef(g_mi_list[i].tkDecl,
                    &pComSig,
                    &cComSig
                );
            }
			MAKE_NAME_IF_NONE(pszMemberName,g_mi_list[i].tkDecl);

            if(FAILED(g_pImport->GetParentToken(g_mi_list[i].tkDecl,&tkDeclParent))) continue;
            if(TypeFromToken(tkDeclParent) == mdtMethodDef) //get the parent's parent
            {
                mdTypeRef cr1;
                if(FAILED(g_pImport->GetParentToken(tkDeclParent,&cr1))) cr1 = mdTypeRefNil;
                tkDeclParent = cr1;
            }
            if(RidFromToken(tkDeclParent))
            {
				CQuickBytes     out;
                szptr+=sprintf(szptr,"%s::",PrettyPrintClass(&out,tkDeclParent,g_pImport));
            }
            szptr+=sprintf(szptr,"%s",ProperName((char*)pszMemberName));

            if(g_fDumpTokens) szptr+=sprintf(szptr," /*%08X::%08X*/ ",tkDeclParent,g_mi_list[i].tkDecl);
            printLine(GUICookie,szString);
        }
    }
    dwTargetRVA = dwOffset;
    if (IsMdPinvokeImpl(dwAttrs) &&(!IsMdUnmanagedExport(dwAttrs)))
    {
		if(dwOffset)
		{
			sprintf(szString,"%s// Embedded native code",g_szAsmCodeIndent);
			printLine(GUICookie, szString);
			goto ItsMiNative;
		}
        if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
        sprintf(szString,"%s}",g_szAsmCodeIndent);
        printLine(GUICookie, szString);
        return TRUE;
    }

//@todo: I don't think we will be requiring an IL section.
#if 0
    if (g_pPELoader->m_ILSection.InSection(dwTargetRVA) == FALSE)
    {
        printf("descr points to non-IL code\n\n");
        continue;
    }
#endif

    if(IsMiManaged(dwImplAttrs))
    {
        if(IsMiIL(dwImplAttrs) || IsMiOPTIL(dwImplAttrs))
        {
            if(g_fShowBytes)
            {
                sprintf(szString,RstrA(IDS_E_METHBEG), g_szAsmCodeIndent,dwTargetRVA);
                printLine(GUICookie, szString);
            }
            szString[0] = 0;
            if (dwTargetRVA != 0)
            {
                void* newTarget;
                g_pPELoader->getVAforRVA(dwTargetRVA,&newTarget);
				try 
				{
					Disassemble(g_pImport, (unsigned char*)newTarget, GUICookie, FuncToken,pszArgname, ulArgs);
				} 
				catch(...) 
				{
					sprintf(szString,RstrA(IDS_E_DASMERR),g_szAsmCodeIndent);
					printLine(GUICookie, szString);
				}
            }
        }
        else if(IsMiNative(dwImplAttrs))
        {
ItsMiNative:
            sprintf(szString,RstrA(IDS_E_DASMNATIVE), g_szAsmCodeIndent);
            printError(GUICookie, szString); 

            sprintf(szString,"%s//  Managed TargetRVA = 0x%x", g_szAsmCodeIndent, dwTargetRVA);
            printLine(GUICookie, szString); 
        }
    }
    else if(IsMiUnmanaged(dwImplAttrs)&&IsMiNative(dwImplAttrs))
    {
        _ASSERTE(IsMiNative(dwImplAttrs));
        sprintf(szString,"%s//  Unmanaged TargetRVA = 0x%x", g_szAsmCodeIndent, dwTargetRVA);
        printLine(GUICookie, szString); 
    }
    else if(IsMiRuntime(dwImplAttrs))
    {
        sprintf(szString,RstrA(IDS_E_METHODRT), g_szAsmCodeIndent); 
        printLine(GUICookie, szString); 
    }
#ifdef _DEBUG
    else  _ASSERTE(!"Bad dwImplAttrs");
#endif

    if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
	{
		unsigned L = (unsigned)strlen(ProperName((char*)pszMemberName)) +
					 (unsigned)strlen(g_szAsmCodeIndent) + 32 +
					 (pszClassName ? (unsigned)strlen(ProperName((char*)pszClassName)) : 0);
		if(L > uStringLen)
		{
			free(szString);
			szString = (char*)malloc(L);
		}
		if(pszClassName)
		{
			sprintf(szString,"%s} // end of method %s::",g_szAsmCodeIndent, ProperName((char*)pszClassName));
			sprintf(&szString[strlen(szString)],"%s", ProperName((char*)pszMemberName));
		}
		else
			sprintf(szString,"%s} // end of global method %s",g_szAsmCodeIndent, ProperName((char*)pszMemberName));
	}
    printLine(GUICookie, szString);
    szString[0] = 0;
    printLine(GUICookie, szString); 

    if(pszArgname)
    {
        for(ULONG i=0; i < ulArgs; i++)
        {
            if(pszArgname[i].name) delete pszArgname[i].name;
        }
        delete pszArgname;
    }
	free(szString);
    return TRUE;
}

BOOL DumpField(mdToken FuncToken, const char *pszClassName,void *GUICookie, BOOL DumpBody)
{
    char            *pszMemberName;//[MAX_MEMBER_LENGTH];
    int             nAccess=0;
    DWORD           dwAttrs;
    CQuickBytes     qbMemberSig;
    PCCOR_SIGNATURE pComSig;
    ULONG           cComSig, L;
    const char            *szStr;//[1024];
    char *szString = NULL;
    char*           szptr;

    const char *psz = g_pImport->GetNameOfFieldDef(FuncToken);
	MAKE_NAME_IF_NONE(psz,FuncToken);

    dwAttrs = g_pImport->GetFieldDefProps(FuncToken);
    if(g_fLimitedVisibility)
    {
        if(g_fHidePub && IsFdPublic(dwAttrs)) return FALSE;
        if(g_fHidePriv && IsFdPrivate(dwAttrs)) return FALSE;
        if(g_fHideFam && IsFdFamily(dwAttrs)) return FALSE;
        if(g_fHideAsm && IsFdAssembly(dwAttrs)) return FALSE;
        if(g_fHideFOA && IsFdFamORAssem(dwAttrs)) return FALSE;
        if(g_fHideFAA && IsFdFamANDAssem(dwAttrs)) return FALSE;
        if(g_fHidePrivScope && IsFdPrivateScope(dwAttrs)) return FALSE;
    }

	{
		char* psz1;
		if(IsFdPrivateScope(dwAttrs))
		{
			pszMemberName = new char[strlen(psz)+15];
			sprintf(pszMemberName,"%s$PST%08X", psz,FuncToken );
		}
		else
		{
			pszMemberName = new char[strlen(psz)+3];
			sprintf(pszMemberName,"%s", psz );
		}
		psz1 = ProperName(pszMemberName);
		delete [] pszMemberName;
		pszMemberName = new char[strlen(psz1)+1];
		strcpy(pszMemberName,psz1);
	}
    pComSig = g_pImport->GetSigOfFieldDef(FuncToken, &cComSig);
	if(cComSig == 0)
	{
		char sz[2048];
		sprintf(sz,"%sERROR: field '%s' has no signature",g_szAsmCodeIndent,pszMemberName);
		delete [] pszMemberName;
		printError(GUICookie,sz);
		return FALSE;
	}
    //memset(szStr,0,sizeof(szStr));
    szStr = PrettyPrintSig(pComSig, cComSig, (DumpBody ? pszMemberName : ""), &qbMemberSig, g_pImport,NULL);

    if (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
    {
        if (strcmp(pszMemberName, g_pszMethodToDump) != 0)
        {
                delete pszMemberName;
                return FALSE;
        }

        if (g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
        {
            if (strcmp(szStr, g_pszSigToDump) != 0)
            {
                    delete pszMemberName;
                    return FALSE;
            }
        }
    }
    delete pszMemberName;
	L = 2048+strlen(szStr);
	szString = new char[L];
	if(szString == NULL)
	{
		printError(GUICookie, "ERROR: not enough memory");
		return FALSE;
	}
    memset(szString,0,L);
    szptr = &szString[0];
    if(DumpBody)
    {
        szptr+=sprintf(szptr,"%s.field ", g_szAsmCodeIndent);
        if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",FuncToken);
    }

    {   // put offset (if any)
        for(ULONG i=0; i < g_cFieldOffsets; i++)
        {
            if(g_rFieldOffset[i].ridOfField == FuncToken)
            {
                if(g_rFieldOffset[i].ulOffset != 0xFFFFFFFF) szptr+=sprintf(szptr,"[%d] ",g_rFieldOffset[i].ulOffset);
                break;
            }
        }
    }
    if(IsFdPublic(dwAttrs))         szptr+=sprintf(szptr,"public ");
    if(IsFdPrivate(dwAttrs))        szptr+=sprintf(szptr,"private ");
    if(IsFdStatic(dwAttrs))         szptr+=sprintf(szptr,"static ");
    if(IsFdFamily(dwAttrs))         szptr+=sprintf(szptr,"family ");
    if(IsFdAssembly(dwAttrs))       szptr+=sprintf(szptr,"assembly ");
    if(IsFdFamANDAssem(dwAttrs))    szptr+=sprintf(szptr,"famandassem ");
    if(IsFdFamORAssem(dwAttrs))     szptr+=sprintf(szptr,"famorassem ");
    if(IsFdPrivateScope(dwAttrs))   szptr+=sprintf(szptr,"privatescope ");
    if(IsFdInitOnly(dwAttrs))       szptr+=sprintf(szptr,"initonly ");
    if(IsFdLiteral(dwAttrs))        szptr+=sprintf(szptr,"literal ");
    if(IsFdNotSerialized(dwAttrs))  szptr+=sprintf(szptr,"notserialized ");
    if(IsFdSpecialName(dwAttrs))    szptr+=sprintf(szptr,"specialname ");
    if(IsFdRTSpecialName(dwAttrs))  szptr+=sprintf(szptr,"rtspecialname ");
    if (IsFdPinvokeImpl(dwAttrs))
    {
        DWORD   dwMappingFlags;
        const char  *szImportName;
        mdModuleRef mrImportDLL;

        szptr+=sprintf(szptr,"pinvokeimpl(");
        if(FAILED(g_pImport->GetPinvokeMap(FuncToken,&dwMappingFlags,
            &szImportName,&mrImportDLL)))  szptr+=sprintf(szptr,"/* No map */");
        else
            szptr = DumpPinvokeMap(dwMappingFlags,  (strcmp(szImportName,psz)? szImportName : NULL), 
                mrImportDLL, szString,GUICookie);
        szptr+=sprintf(szptr,") ");
    }
    szptr = DumpMarshaling(g_pImport,szString,FuncToken);

	szptr+=sprintf(szptr,"%s",szStr);

    if (IsFdHasFieldRVA(dwAttrs))       // Do we have an RVA associated with this?
    {
        szptr+=sprintf(szptr, " at ");

        ULONG fieldRVA;
        HRESULT hr = g_pImport->GetFieldRVA(FuncToken, &fieldRVA);
        if (SUCCEEDED(hr))
            szptr = DumpDataPtr(&szString[strlen(szString)], fieldRVA, SizeOfField(FuncToken,g_pImport));
        else 
            szptr+=sprintf(szptr,RstrA(IDS_E_NORVA));
    }
    
    // dump default value (if any):
    if(IsFdHasDefault(dwAttrs) && DumpBody)  DumpDefaultValue(FuncToken,szString,GUICookie);
    printLine(GUICookie, szString); 
	delete [] szString;
    if(DumpBody)
    {
        DumpCustomAttributes(FuncToken,GUICookie);      
        DumpPermissions(FuncToken,GUICookie);
    }

    return TRUE;

}

BOOL DumpEvent(mdToken FuncToken, const char *pszClassName, DWORD dwClassAttrs, void *GUICookie, BOOL DumpBody)
{
    int             nAccess=0;
    DWORD           dwAttrs;
    mdToken         tkEventType;
    LPCSTR          psz;
    HENUMInternal   hAssoc;
    ASSOCIATE_RECORD rAssoc[128];
    CQuickBytes     qbMemberSig;
    //PCCOR_SIGNATURE pComSig;
    //ULONG           cComSig;
    ULONG           nAssoc;
    //char            *buff;
    char            szString[4096];
    char*           szptr;

    
    g_pImport->GetEventProps(FuncToken,&psz,&dwAttrs,&tkEventType);
	MAKE_NAME_IF_NONE(psz,FuncToken);
    if (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
    {
        if (strcmp(psz, g_pszMethodToDump) != 0)  return FALSE;
    }

    g_pImport->EnumAssociateInit(FuncToken,&hAssoc);
    if(nAssoc = hAssoc.m_ulCount)
    {
        memset(rAssoc,0,sizeof(rAssoc));
        g_pImport->GetAllAssociates(&hAssoc,rAssoc,nAssoc);

                if(g_fLimitedVisibility)
                {
                        for(unsigned i=0; i < nAssoc;i++)
                        {
                                //if(IsMsAddOn(rAssoc[i].m_dwSemantics) || IsMsRemoveOn(rAssoc[i].m_dwSemantics) || IsMsFire(rAssoc[i].m_dwSemantics))
                                {
                                        DWORD dwAttrs = g_pImport->GetMethodDefProps(rAssoc[i].m_memberdef);
                                        if(g_fHidePub && IsMdPublic(dwAttrs)) continue;
                                        if(g_fHidePriv && IsMdPrivate(dwAttrs)) continue;
                                        if(g_fHideFam && IsMdFamily(dwAttrs)) continue;
                                        if(g_fHideAsm && IsMdAssem(dwAttrs)) continue;
                                        if(g_fHideFOA && IsMdFamORAssem(dwAttrs)) continue;
                                        if(g_fHideFAA && IsMdFamANDAssem(dwAttrs)) continue;
                                        if(g_fHidePrivScope && IsMdPrivateScope(dwAttrs)) continue;
                                        break;
                                        //if(IsMdPublic(dwAttrs) || IsMdFamily(dwAttrs) || IsMdFamORAssem(dwAttrs)) break;
                                }
                        }
                        if(i >= nAssoc) return FALSE;
                }
        }
    
    szptr = &szString[0];
    if(DumpBody)
    {
        szptr+=sprintf(szptr,"%s.event ", g_szAsmCodeIndent);
        if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",FuncToken);
    }
    else
    {
        szptr+=sprintf(szptr,"%s : ",ProperName((char*)psz));
    }

    if(IsEvSpecialName(dwAttrs))    szptr+=sprintf(szptr,"specialname ");
    if(IsEvRTSpecialName(dwAttrs))  szptr+=sprintf(szptr,"rtspecialname ");

    if(RidFromToken(tkEventType))
    {
            switch(TypeFromToken(tkEventType))
            {
                    case mdtTypeRef:
                    case mdtTypeDef:
                    case mdtTypeSpec:
                        {
                            CQuickBytes     out;
                            szptr+=sprintf(szptr,"%s",PrettyPrintClass(&out,tkEventType,g_pImport));
                            if(g_fDumpTokens) szptr+=sprintf(szptr," /*%08X*/",tkEventType);
                        }
                        break;
                    default:
                        break;
            }
    }

    if(!DumpBody)
    {
        printLine(GUICookie,szString);
        return TRUE;
    }

    
    szptr+=sprintf(szptr," %s", ProperName((char*)psz));
    printLine(GUICookie,szString);
    sprintf(szString,"%s{",g_szAsmCodeIndent);
    printLine(GUICookie,szString);
    strcat(g_szAsmCodeIndent,"  ");

    DumpCustomAttributes(FuncToken,GUICookie);    
    DumpPermissions(FuncToken,GUICookie);
    
    if(nAssoc)
    {
        for(unsigned i=0; i < nAssoc;i++)
        {
            szptr = &szString[0];
            if(IsMsAddOn(rAssoc[i].m_dwSemantics))          szptr+=sprintf(szptr,"%s.addon ",g_szAsmCodeIndent);
            else if(IsMsRemoveOn(rAssoc[i].m_dwSemantics))  szptr+=sprintf(szptr,"%s.removeon ",g_szAsmCodeIndent);
            else if(IsMsFire(rAssoc[i].m_dwSemantics))      szptr+=sprintf(szptr,"%s.fire ",g_szAsmCodeIndent);
            else if(IsMsOther(rAssoc[i].m_dwSemantics))     szptr+=sprintf(szptr,"%s.other ",g_szAsmCodeIndent);

            if (TypeFromToken(rAssoc[i].m_memberdef) == mdtMethodDef)
                PrettyPrintMethodDef(szString,rAssoc[i].m_memberdef,g_pImport,GUICookie);
            else
            {
                _ASSERTE(TypeFromToken(rAssoc[i].m_memberdef) == mdtMemberRef);
                PrettyPrintMemberRef(szString,rAssoc[i].m_memberdef,g_pImport,GUICookie);
            }
            printLine(GUICookie,szString);
        }
    }
    if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
    sprintf(szString,"%s} // end of event %s::",g_szAsmCodeIndent, ProperName((char*)pszClassName));
    sprintf(&szString[strlen(szString)],"%s",ProperName((char*)psz));
    printLine(GUICookie,szString);
    return TRUE;

}

BOOL DumpProp(mdToken FuncToken, const char *pszClassName, DWORD dwClassAttrs, void *GUICookie, BOOL DumpBody)
{
    int             nAccess=0;
    DWORD           dwAttrs;
    LPCSTR          psz;
    HENUMInternal   hAssoc;
    ASSOCIATE_RECORD rAssoc[128];
    CQuickBytes     qbMemberSig;
    PCCOR_SIGNATURE pComSig;
    ULONG           cComSig, nAssoc;
    char*            szString=NULL;
	unsigned		uStringLen = 4096;
    char*           szptr;

    
    g_pImport->GetPropertyProps(FuncToken,&psz,&dwAttrs,&pComSig,&cComSig);
	MAKE_NAME_IF_NONE(psz,FuncToken);
	if(cComSig == 0)
	{
		char sz[2048];
		sprintf(sz,"%sERROR: property '%s' has no signature",g_szAsmCodeIndent,psz);
		printError(GUICookie,sz);
		return FALSE;
	}

    if (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
    {
        if (strcmp(psz, g_pszMethodToDump) != 0)  return FALSE;
    }

    g_pImport->EnumAssociateInit(FuncToken,&hAssoc);
    if(nAssoc = hAssoc.m_ulCount)
    {
        memset(rAssoc,0,sizeof(rAssoc));
        g_pImport->GetAllAssociates(&hAssoc,rAssoc,nAssoc);

        if(g_fLimitedVisibility)
        {
            for(unsigned i=0; i < nAssoc;i++)
            {
                //if(IsMsSetter(rAssoc[i].m_dwSemantics) || IsMsGetter(rAssoc[i].m_dwSemantics))
                {
                    DWORD dwAttrs = g_pImport->GetMethodDefProps(rAssoc[i].m_memberdef);
                    if(g_fHidePub && IsMdPublic(dwAttrs)) continue;
                    if(g_fHidePriv && IsMdPrivate(dwAttrs)) continue;
                    if(g_fHideFam && IsMdFamily(dwAttrs)) continue;
                    if(g_fHideAsm && IsMdAssem(dwAttrs)) continue;
                    if(g_fHideFOA && IsMdFamORAssem(dwAttrs)) continue;
                    if(g_fHideFAA && IsMdFamANDAssem(dwAttrs)) continue;
                    if(g_fHidePrivScope && IsMdPrivateScope(dwAttrs)) continue;
                    break;
                }
            }
            if(i >= nAssoc) return FALSE;
        }
    }
	szString = (char*)malloc(uStringLen);
	if(szString==NULL) return FALSE;
    szptr = &szString[0];
    if(DumpBody)
    {
        szptr+=sprintf(szptr,"%s.property ", g_szAsmCodeIndent);
        if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",FuncToken);
    }
    else
    {
        szptr+=sprintf(szptr,"%s : ",ProperName((char*)psz));
    }

    if(IsPrSpecialName(dwAttrs))        szptr+=sprintf(szptr,"specialname ");
    if(IsPrRTSpecialName(dwAttrs))      szptr+=sprintf(szptr,"rtspecialname ");

	{
		char *pch = "";
		if(DumpBody)
		{
			pch = szptr+1;
			strcpy(pch,ProperName((char*)psz));
		}
	    qbMemberSig.ReSize(0);
		PrettyPrintMethodSig(szString, &uStringLen, &qbMemberSig, pComSig, cComSig,
							  pch, NULL, GUICookie);
		if(IsPrHasDefault(dwAttrs) && DumpBody) DumpDefaultValue(FuncToken,szString,GUICookie);
	}
    printLine(GUICookie,szString);

    if(DumpBody) 
	{
		sprintf(szString,"%s{",g_szAsmCodeIndent);
		printLine(GUICookie,szString);
		strcat(g_szAsmCodeIndent,"  ");

		DumpCustomAttributes(FuncToken,GUICookie);    
		DumpPermissions(FuncToken,GUICookie);
    
		if(nAssoc)
		{
			for(unsigned i=0; i < nAssoc;i++)
			{
				szptr = &szString[0];
				if(IsMsSetter(rAssoc[i].m_dwSemantics))         szptr+=sprintf(szptr,"%s.set ",g_szAsmCodeIndent);
				else if(IsMsGetter(rAssoc[i].m_dwSemantics))    szptr+=sprintf(szptr,"%s.get ",g_szAsmCodeIndent);
				else if(IsMsOther(rAssoc[i].m_dwSemantics))     szptr+=sprintf(szptr,"%s.other ",g_szAsmCodeIndent);
				if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",rAssoc[i].m_memberdef);
				if (TypeFromToken(rAssoc[i].m_memberdef) == mdtMethodDef)
					PrettyPrintMethodDef(szString,rAssoc[i].m_memberdef,g_pImport,GUICookie);
				else
				{
					_ASSERTE(TypeFromToken(rAssoc[i].m_memberdef) == mdtMemberRef);
					PrettyPrintMemberRef(szString,rAssoc[i].m_memberdef,g_pImport,GUICookie);
				}
				printLine(GUICookie,szString);
			}
		}
		if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
		sprintf(szString,"%s} // end of property %s::",g_szAsmCodeIndent, ProperName((char*)pszClassName));
		sprintf(&szString[strlen(szString)],"%s",ProperName((char*)psz));
		printLine(GUICookie,szString);
	} // end if(DumpBody)
	free(szString);
    return TRUE;

}

BOOL DumpMembers(mdTypeDef cl, const char *pszClassNamespace, const char *pszClassName, 
                 DWORD dwClassAttrs, DWORD dwEntryPointToken, void* GUICookie)
{
    HRESULT         hr;
    mdToken         *pMemberList = NULL;
    DWORD           NumMembers, NumFields,NumMethods,NumEvents,NumProps;
    DWORD           i;
    BOOL            fAnyFieldsYet = FALSE;
    BOOL            fAnyMethodsYet = FALSE;
    HENUMInternal   hEnumMethod;
    HENUMInternal   hEnumField;
    HENUMInternal   hEnumEvent;
    HENUMInternal   hEnumProp;
    int             nAccess=0;
    CQuickBytes     qbMemberSig;
    BOOL            ret;

    // Get the total count of methods + fields
    hr = g_pImport->EnumInit(mdtMethodDef, cl, &hEnumMethod);
    if (FAILED(hr))
    {
FailedToEnum:
        printLine(GUICookie,RstrA(IDS_E_MEMBRENUM));
        ret = FALSE;
        goto CloseHandlesAndReturn;
    }
    NumMembers = NumMethods = g_pImport->EnumGetCount(&hEnumMethod);


    if (FAILED(g_pImport->EnumInit(mdtFieldDef, cl, &hEnumField)))   goto FailedToEnum;
    NumFields = g_pImport->EnumGetCount(&hEnumField);
    NumMembers += NumFields;

    if (FAILED(g_pImport->EnumInit(mdtEvent, cl, &hEnumEvent))) goto FailedToEnum;
    NumEvents = g_pImport->EnumGetCount(&hEnumEvent);
    NumMembers += NumEvents;

    if (FAILED(g_pImport->EnumInit(mdtProperty, cl, &hEnumProp))) goto FailedToEnum;
    NumProps = g_pImport->EnumGetCount(&hEnumProp);
    NumMembers += NumProps;
    ret = TRUE;
    if(NumMembers)
    {
        pMemberList = (mdToken*) _alloca(sizeof(mdToken) * NumMembers);
        if(pMemberList == NULL) ret = FALSE;
    }
    if ((NumMembers == 0)||(pMemberList == NULL)) goto CloseHandlesAndReturn;

    for (i = 0; g_pImport->EnumNext(&hEnumField, &pMemberList[i]); i++);
    for (; g_pImport->EnumNext(&hEnumMethod, &pMemberList[i]); i++);
    for (; g_pImport->EnumNext(&hEnumEvent, &pMemberList[i]); i++);
    for (; g_pImport->EnumNext(&hEnumProp, &pMemberList[i]); i++);
    _ASSERTE(i == NumMembers);

    for (i = 0; i < NumMembers; i++)
    {
        switch (TypeFromToken(pMemberList[i]))
        {
            case mdtFieldDef:
                ret = DumpField(pMemberList[i], pszClassName, GUICookie,TRUE);
                break;

            case mdtMethodDef:
                ret = DumpMethod(pMemberList[i], pszClassName, dwEntryPointToken,GUICookie,TRUE);
                break;

            case mdtEvent:
                ret = DumpEvent(pMemberList[i], pszClassName, dwClassAttrs,GUICookie,TRUE);
                break;

            case mdtProperty:
                ret = DumpProp(pMemberList[i], pszClassName, dwClassAttrs,GUICookie,TRUE);
                break;

            default:
                {
                    char szStr[256];
                    sprintf(szStr,RstrA(IDS_E_ODDMEMBER),pMemberList[i],pszClassName);
                    printLine(GUICookie,szStr);
                }
                ret = FALSE;
                break;
        } // end switch
        if(ret && (g_Mode == MODE_DUMP_CLASS_METHOD_SIG)) break;
    } // end for
    ret = TRUE;
CloseHandlesAndReturn:
    g_pImport->EnumClose(&hEnumMethod);
    g_pImport->EnumClose(&hEnumField);
    g_pImport->EnumClose(&hEnumEvent);
    g_pImport->EnumClose(&hEnumProp);
    return ret;
}
BOOL GetClassLayout(mdTypeDef cl, ULONG* pulPackSize, ULONG* pulClassSize)
{ // Dump class layout
    HENUMInternal   hEnumField;
    BOOL ret = FALSE;

    if(g_rFieldOffset) {delete g_rFieldOffset; g_rFieldOffset = NULL; }
    g_cFieldOffsets = 0;
    g_cFieldsMax = 0;
    
    if(RidFromToken(cl)==0) return TRUE;

    if (SUCCEEDED(g_pImport->EnumInit(mdtFieldDef, cl, &hEnumField)))
    {
        g_cFieldsMax = g_pImport->EnumGetCount(&hEnumField);
        g_pImport->EnumClose(&hEnumField);
    }

	if(SUCCEEDED(g_pImport->GetClassPackSize(cl,pulPackSize))) ret = TRUE;
	else *pulPackSize = 0xFFFFFFFF;
	if(SUCCEEDED(g_pImport->GetClassTotalSize(cl,pulClassSize))) ret = TRUE;
	else *pulClassSize = 0xFFFFFFFF;

    if(g_cFieldsMax)
	{
		MD_CLASS_LAYOUT Layout;
		if(SUCCEEDED(g_pImport->GetClassLayoutInit(cl,&Layout)))
		{
			g_rFieldOffset = new COR_FIELD_OFFSET[g_cFieldsMax+1];
			if(g_rFieldOffset)
			{
				COR_FIELD_OFFSET* pFO = g_rFieldOffset;
				for(g_cFieldOffsets=0; 
					SUCCEEDED(g_pImport->GetClassLayoutNext(&Layout,&(pFO->ridOfField),&(pFO->ulOffset)))
						&&RidFromToken(pFO->ridOfField);
					g_cFieldOffsets++, pFO++) ret = TRUE;
			}
		}
	}
    return ret;
}

BOOL DumpClass(mdTypeDef cl, DWORD dwEntryPointToken, void* GUICookie, ULONG WhatToDump)
// WhatToDump: 0-title,flags,extends,implements;
//            +1-pack,size and custom attrs; 
//			  +2-nested classes
//			  +4-members
{
    char            *pszClassName; // name associated with this CL
    char            *pszNamespace;
    const char      *pc1,*pc2;
    DWORD           dwClassAttrs;
    mdTypeRef       crExtends;
    HRESULT         hr;
    mdInterfaceImpl ii;
    DWORD           NumInterfaces;
    DWORD           i;
    HENUMInternal   hEnumII;            // enumerator for interface impl
    char            *szString;
    char*           szptr;


    g_pImport->GetNameOfTypeDef(
        cl,
        &pc1,   //&pszClassName,
        &pc2    //&pszNamespace
    );
	MAKE_NAME_IF_NONE(pc1,cl);

    if (g_Mode == MODE_DUMP_CLASS || g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)
    {
	    LPUTF8              szFullName;
		MAKE_FULL_PATH_ON_STACK_UTF8(szFullName, pc2, pc1);
        if (strcmp(szFullName, g_pszClassToDump) != 0)
            return TRUE;
    }
    
    g_pImport->GetTypeDefProps(
        cl,
        &dwClassAttrs,
        &crExtends
    );
    if(g_fLimitedVisibility)
    {
            if(g_fHidePub && (IsTdPublic(dwClassAttrs)||IsTdNestedPublic(dwClassAttrs))) return FALSE;
            if(g_fHidePriv && (IsTdNotPublic(dwClassAttrs)||IsTdNestedPrivate(dwClassAttrs))) return FALSE;
            if(g_fHideFam && IsTdNestedFamily(dwClassAttrs)) return FALSE;
            if(g_fHideAsm && IsTdNestedAssembly(dwClassAttrs)) return FALSE;
            if(g_fHideFOA && IsTdNestedFamORAssem(dwClassAttrs)) return FALSE;
            if(g_fHideFAA && IsTdNestedFamANDAssem(dwClassAttrs)) return FALSE;
    }


    pszClassName = (char*)(pc1 ? pc1 : "");
    pszNamespace = (char*)(pc2 ? pc2 : "");
	szString = new char[4096];//(char*)malloc(4096);

    if((!IsTdNested(dwClassAttrs))&&(!(g_Mode & MODE_GUI))) // don't dump namespaces in GUI mode!
    {
        // take care of namespace, if any
        if(strcmp(pszNamespace,g_szNamespace))
        {
            if(strlen(g_szNamespace))
            {
                if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                sprintf(szString,"%s} // end of namespace %s",g_szAsmCodeIndent, ProperName(g_szNamespace));
                printLine(GUICookie,szString);
                printLine(GUICookie,"");
            }
            strcpy(g_szNamespace,pszNamespace);
            if(strlen(g_szNamespace))
            {
                sprintf(szString,"%s.namespace %s",
					g_szAsmCodeIndent, ProperName(g_szNamespace));
                printLine(GUICookie,szString);
                sprintf(szString,"%s{",g_szAsmCodeIndent);
                printLine(GUICookie,szString);
                strcat(g_szAsmCodeIndent,"  ");
            }
        }
    }

    szptr = &szString[0];
    szptr+=sprintf(szptr,"%s.class ",g_szAsmCodeIndent);
    if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",cl);

	if (IsTdInterface(dwClassAttrs))                szptr+=sprintf(szptr,"interface ");
	if (IsTdPublic(dwClassAttrs))                   szptr+=sprintf(szptr,"public ");
	if (IsTdNotPublic(dwClassAttrs))                szptr+=sprintf(szptr,"private ");
	if (IsTdAbstract(dwClassAttrs))                 szptr+=sprintf(szptr,"abstract ");
	if (IsTdAutoLayout(dwClassAttrs))               szptr+=sprintf(szptr,"auto ");
	if (IsTdSequentialLayout(dwClassAttrs))         szptr+=sprintf(szptr,"sequential ");
	if (IsTdExplicitLayout(dwClassAttrs))           szptr+=sprintf(szptr,"explicit ");
	if (IsTdAnsiClass(dwClassAttrs))                szptr+=sprintf(szptr,"ansi ");
	if (IsTdUnicodeClass(dwClassAttrs))             szptr+=sprintf(szptr,"unicode ");
	if (IsTdAutoClass(dwClassAttrs))                szptr+=sprintf(szptr,"autochar ");
	if (IsTdImport(dwClassAttrs))                   szptr+=sprintf(szptr,"import ");
	if (IsTdSerializable(dwClassAttrs))             szptr+=sprintf(szptr,"serializable ");
	if (IsTdSealed(dwClassAttrs))                   szptr+=sprintf(szptr,"sealed ");
	if (IsTdNestedPublic(dwClassAttrs))             szptr+=sprintf(szptr,"nested public ");
	if (IsTdNestedPrivate(dwClassAttrs))            szptr+=sprintf(szptr,"nested private ");
	if (IsTdNestedFamily(dwClassAttrs))             szptr+=sprintf(szptr,"nested family ");
	if (IsTdNestedAssembly(dwClassAttrs))           szptr+=sprintf(szptr,"nested assembly ");
	if (IsTdNestedFamANDAssem(dwClassAttrs))        szptr+=sprintf(szptr,"nested famandassem ");
	if (IsTdNestedFamORAssem(dwClassAttrs))         szptr+=sprintf(szptr,"nested famorassem ");
	if (IsTdBeforeFieldInit(dwClassAttrs))          szptr+=sprintf(szptr,"beforefieldinit ");
	if (IsTdSpecialName(dwClassAttrs))              szptr+=sprintf(szptr,"specialname ");
	if (IsTdRTSpecialName(dwClassAttrs))            szptr+=sprintf(szptr,"rtspecialname ");

    szptr+=sprintf(szptr,"%s", ProperName(pszClassName));
	printLine(GUICookie,szString);
	if (!IsNilToken(crExtends))
	{
		CQuickBytes out;
		sprintf(szString,"%s       extends %s",g_szAsmCodeIndent,PrettyPrintClass(&out,crExtends,g_pImport));
		printLine(GUICookie,szString);
	}

	hr = g_pImport->EnumInit(
		mdtInterfaceImpl, 
		cl, 
		&hEnumII);
	if (FAILED(hr))
	{
		printLine(GUICookie,RstrA(IDS_E_ENUMINIT));
		delete [] szString; //free(szString);
		return FALSE;
	}

	NumInterfaces = g_pImport->EnumGetCount(&hEnumII);

	if (NumInterfaces > 0)
	{
		CQuickBytes out;
		mdTypeRef   crInterface;
		for (i=0; g_pImport->EnumNext(&hEnumII, &ii); i++)
		{
			szptr = szString;
			szptr+=sprintf(szptr, (i == 0 ? "%s       implements " : "%s                  "),g_szAsmCodeIndent);
			crInterface = g_pImport->GetTypeOfInterfaceImpl(ii);
			szptr += sprintf(szptr,"%s",PrettyPrintClass(&out,crInterface,g_pImport));
			if(i < NumInterfaces-1) strcat(szString,",");
			printLine(GUICookie,szString);
			out.ReSize(0);
		}
		// The assertion will fire if the enumerator is bad
		_ASSERTE(NumInterfaces == i);

		g_pImport->EnumClose(&hEnumII);
	}
    if(WhatToDump == 0) // 0 = title only
	{
		sprintf(szString,"%s{ }",g_szAsmCodeIndent);
		printLine(GUICookie,szString);
		delete [] szString; //free(szString);
		return TRUE;
	}
    sprintf(szString,"%s{",g_szAsmCodeIndent);
    printLine(GUICookie,szString);
    strcat(g_szAsmCodeIndent,"  ");

	ULONG ulPackSize=0xFFFFFFFF,ulClassSize=0xFFFFFFFF;
	if(WhatToDump & 1)
	{
		if(GetClassLayout(cl,&ulPackSize,&ulClassSize))
		{ // Dump class layout
			if(ulPackSize != 0xFFFFFFFF)
			{
				sprintf(szString,"%s.pack %d",g_szAsmCodeIndent,ulPackSize);
				printLine(GUICookie,szString);
			}
			if(ulClassSize != 0xFFFFFFFF)
			{
				sprintf(szString,"%s.size %d",g_szAsmCodeIndent,ulClassSize);
				printLine(GUICookie,szString);
			}
		}
		DumpCustomAttributes(cl,GUICookie);
		DumpPermissions(cl,GUICookie);
		for(i=0; i<g_LocalComTypeNum; i++)
		{
			if(cl == g_pLocalComType[i]->tkTypeDef)
			{
				mdToken tkImpl;
				g_pLocalComType[i]->tkTypeDef = mdTokenNil; // to avoid printing ".class 0x1234ABCD"
				tkImpl = g_pLocalComType[i]->tkImplementation;
				g_pLocalComType[i]->tkImplementation = mdTokenNil; // to avoid printing implementation
						sprintf(szString,"%s.export ",g_szAsmCodeIndent);
				DumpComType(g_pLocalComType[i],szString,GUICookie);
				g_pLocalComType[i]->tkTypeDef = cl;
				g_pLocalComType[i]->tkImplementation = tkImpl;
			}
		}
	}

    // Dump method impls declared in this class whose implementing methods belong somewhere else:
	if(WhatToDump & 4) // 4 - dump members
	{
		for(i = 0; i < g_NumMI; i++)
		{
			if((g_mi_list[i].tkClass == cl)&&(g_mi_list[i].tkBodyParent != cl))
			{
				const char *    pszMemberName;
				mdToken         tkDeclParent;
				szptr = &szString[0];
				szptr+=sprintf(szptr,"%s.override ",g_szAsmCodeIndent);

				if(TypeFromToken(g_mi_list[i].tkDecl) == mdtMethodDef)
					pszMemberName = g_pImport->GetNameOfMethodDef(g_mi_list[i].tkDecl);
				else 
				{
					PCCOR_SIGNATURE pComSig;
					ULONG       cComSig;

					pszMemberName = g_pImport->GetNameAndSigOfMemberRef(g_mi_list[i].tkDecl,
						&pComSig,
						&cComSig
					);
				}
				MAKE_NAME_IF_NONE(pszMemberName,g_mi_list[i].tkDecl);

				if(FAILED(g_pImport->GetParentToken(g_mi_list[i].tkDecl,&tkDeclParent))) continue;
				if(TypeFromToken(tkDeclParent) == mdtMethodDef) //get the parent's parent
				{
					mdTypeRef cr1;
					if(FAILED(g_pImport->GetParentToken(tkDeclParent,&cr1))) cr1 = mdTypeRefNil;
					tkDeclParent = cr1;
				}
				if(RidFromToken(tkDeclParent))
				{
					CQuickBytes     out;
					szptr+=sprintf(szptr,"%s::",PrettyPrintClass(&out,tkDeclParent,g_pImport));
				}
				szptr+=sprintf(szptr,"%s with ",ProperName((char*)pszMemberName));
				if (TypeFromToken(g_mi_list[i].tkBody) == mdtMethodDef)
					PrettyPrintMethodDef(szString,g_mi_list[i].tkBody,g_pImport,GUICookie);
				else
				{
					_ASSERTE(TypeFromToken(g_mi_list[i].tkBody) == mdtMemberRef);
					PrettyPrintMemberRef(szString,g_mi_list[i].tkBody,g_pImport,GUICookie);
				}
				printLine(GUICookie,szString);
			}
		}
	}
	delete [] szString; //free(szString); 
    if(WhatToDump & 2) // nested classes
    {
        BOOL    fRegetClassLayout=FALSE;
        for(i = 0; i < g_NumClasses; i++)
        {
            if(g_cl_enclosing[i] == cl)
            {
                DumpClass(g_cl_list[i],dwEntryPointToken,GUICookie,WhatToDump);
                if(g_fAbortDisassembly)
				{
					return FALSE;
				}
                fRegetClassLayout = TRUE;
            }
        }
        if(fRegetClassLayout) GetClassLayout(cl,&ulPackSize,&ulClassSize);
    }

	if(WhatToDump & 4)
	{
		DumpMembers(cl, pszNamespace, pszClassName, dwClassAttrs, dwEntryPointToken,GUICookie);
	    if(!ProgressStep()) g_fAbortDisassembly = TRUE;
	}

	szString = new char[4096]; //(char*)malloc(4096);
    if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
    sprintf(szString,"%s} // end of class %s",g_szAsmCodeIndent, ProperName(pszClassName));
    printLine(GUICookie,szString);
	delete [] szString; //free(szString); 
    if(!(g_Mode & MODE_GUI)) printLine(GUICookie,"");
    return TRUE;
}



void DumpGlobalMethods(DWORD dwEntryPointToken)
{
    BOOL            fPrintedAny = FALSE;
    HENUMInternal   hEnumMethod;
    mdToken         FuncToken;
    DWORD           i;
    CQuickBytes     qbMemberSig;

    if (FAILED(g_pImport->EnumGlobalFunctionsInit(&hEnumMethod)))
        return;

    for (i = 0; g_pImport->EnumNext(&hEnumMethod, &FuncToken); i++)
    {
        if ((fPrintedAny == FALSE)&&(!(g_Mode & MODE_GUI)))
        {
            fPrintedAny = TRUE;

            printLine(g_pFile,"//Global methods");
            printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        }
        if(DumpMethod(FuncToken, NULL, dwEntryPointToken, g_pFile, TRUE)&&
            (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)) break;
        if(!ProgressStep())
        {
            g_fAbortDisassembly = TRUE;
            break;
        }
    }
    g_pImport->EnumClose(&hEnumMethod);
}

void DumpGlobalFields()
{
    BOOL            fPrintedAny = FALSE;
    HENUMInternal   hEnum;
    mdToken         FieldToken;
    DWORD           i;
    CQuickBytes     qbMemberSig;

    if (FAILED(g_pImport->EnumGlobalFieldsInit(&hEnum)))
        return;

    for (i = 0; g_pImport->EnumNext(&hEnum, &FieldToken); i++)
    {
        if ((fPrintedAny == FALSE)&&(!(g_Mode & MODE_GUI)))
        {
            fPrintedAny = TRUE;

            printLine(g_pFile,"//Global fields");
            printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        }
        if(DumpField(FieldToken, NULL, g_pFile, TRUE)&&
            (g_Mode == MODE_DUMP_CLASS_METHOD || g_Mode == MODE_DUMP_CLASS_METHOD_SIG)) break;
    }
    g_pImport->EnumClose(&hEnum);
}

extern IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* g_ehInfo; // declared in dis.cpp
extern ULONG    g_ehCount;                  // declared in dis.cpp

void    DumpExceptions(IMDInternalImport *      pImport, 
                       const BYTE *             exceptions)
{
    const COR_ILMETHOD_SECT_EH* eh = (const COR_ILMETHOD_SECT_EH*)exceptions;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT ehBuff;
    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo;
    if(g_ehInfo) delete g_ehInfo;
    g_ehInfo = NULL;
    g_ehCount = 0;
    if(!eh) return;
    if(g_ehCount = eh->EHCount())
    {
        g_ehInfo = new IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT[g_ehCount];
        _ASSERTE(g_ehInfo != NULL);
        for (unsigned i = 0; i < g_ehCount; i++)  
        {   
            ehInfo = eh->EHClause(i, &ehBuff);
            memcpy(&g_ehInfo[i],ehInfo,sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
            g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | NEW_TRY_BLOCK);
            _ASSERTE((ehInfo->Flags & SEH_NEW_PUT_MASK) == 0); // we are using 0x80000000 and 0x40000000
        }
        if(!(g_Mode&MODE_GUI)) printLine(g_pFile,"/*----------------------------");
        dumpEHInfo(pImport, g_pFile);
        if(!(g_Mode&MODE_GUI)) printLine(g_pFile,"/*----------------------------");

    }
}


void DumpNativeInfo(const BYTE * ipmap, DWORD IPMapSize)
{
    const IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY * pIPMap 
      = (const IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY *) ipmap;

    DWORD   dwNumEntries = (IPMapSize / sizeof(*pIPMap));
    DWORD   dwLittleEndian;
    char szString[1024];

    if (IPMapSize)
    {
        printLine(g_pFile,"// GC/EH info for managed native functions");
        printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    }

    for(DWORD count=0; count<dwNumEntries; count++)
    {
        DWORD   dwMethodRVA = pIPMap[count].BeginAddress;
        DWORD   dwMethodEndRVA = pIPMap[count].EndAddress;

        sprintf(szString,"// IPMap[0x%x]", count);
        printLine(g_pFile,szString);
        printLine(g_pFile,"//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~n");
        sprintf(szString,"// Method at RVA 0x%x-0x%x", dwMethodRVA, dwMethodEndRVA);
        printLine(g_pFile,szString);

        const IMAGE_COR_MIH_ENTRY *   pMIHEntry;

        g_pPELoader->getVAforRVA(pIPMap[count].MIH, (void **) &pMIHEntry);  
        pMIHEntry = (const IMAGE_COR_MIH_ENTRY *)(((BYTE *) pMIHEntry) - offsetof(IMAGE_COR_MIH_ENTRY,Flags));  

        /*---------------------------------------------------------------------
         * Exception info
         */

        if (pMIHEntry->Flags & IMAGE_COR_MIH_EHRVA)
        {
            dwLittleEndian      = pMIHEntry->EHRVA;
            unsigned    EH_RVA  = FourBytesToU4((const BYTE *)&dwLittleEndian);
    
            if (!EH_RVA)
            {
                printLine(g_pFile,"// Exception count 0");
            }
            else
            {
                BYTE *EH_VA;    
                g_pPELoader->getVAforRVA(EH_RVA, (void **) &EH_VA); 
                DumpExceptions(g_pImport, EH_VA);
            }
        }

        /*---------------------------------------------------------------------
         * GC info 
         */

        if ((pMIHEntry->Flags & IMAGE_COR_MIH_BASICBLOCK) == 0)
        {
            const BYTE *pGCInfo = pMIHEntry->MIHData;
    
            GCDump      gcDump;
            InfoHdr     infoHdr;
            unsigned    size;   
            unsigned    methodSize;
    
            printLine(g_pFile,"");
            printLine(g_pFile,"// Method info block:");
            size = gcDump.DumpInfoHdr(pGCInfo, &infoHdr, &methodSize);
            pGCInfo += size;
    
            printLine(g_pFile,"// Pointer table:");
            size = gcDump.DumpGCTable(pGCInfo,  infoHdr,  methodSize);
        }
    }
}



void DumpVTables(IMAGE_COR20_HEADER *CORHeader, void* GUICookie)
{
    IMAGE_COR_VTABLEFIXUP *pFixup;
    DWORD       iCount;
    DWORD       i;
    USHORT      iSlot;
    char szString[1024];
    char* szStr = &szString[0];
    
	if (CORHeader->VTableFixups.VirtualAddress == 0) return;

    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode
    
    sprintf(szString,"// VTableFixup Directory:");
    printLine(GUICookie,szStr);    

    // Pull back a pointer to the guy.
    iCount = CORHeader->VTableFixups.Size / sizeof(IMAGE_COR_VTABLEFIXUP);
    if (g_pPELoader->getVAforRVA((DWORD) CORHeader->VTableFixups.VirtualAddress, (void **) &pFixup) == FALSE)
    {
        printLine(GUICookie,RstrA(IDS_E_VTFUTABLE));    
        goto exit;
    }

    // Walk every v-table fixup entry and dump the slots.
    for (i=0;  i<iCount;  i++)
    {
        sprintf(szString,"//   IMAGE_COR_VTABLEFIXUP[%d]:", i);
        printLine(GUICookie,szStr);    
        sprintf(szString,"//       RVA:               %08x", pFixup->RVA);
        printLine(GUICookie,szStr);    
        sprintf(szString,"//       Count:             %04x", pFixup->Count);
        printLine(GUICookie,szStr);    
        sprintf(szString,"//       Type:              %04x", pFixup->Type);
        printLine(GUICookie,szStr);    

        BYTE *pSlot;
        if (g_pPELoader->getVAforRVA(pFixup->RVA, (void **) &pSlot) == FALSE)
        {
            printLine(GUICookie,RstrA(IDS_E_BOGUSRVA));    
            goto NextEntry;
        }

        for (iSlot=0;  iSlot<pFixup->Count;  iSlot++)
        {
            mdMethodDef tkMethod = *(DWORD *) pSlot;
            if ((pFixup->Type & COR_VTABLE_32BIT) == COR_VTABLE_32BIT)
            {
                sprintf(szString,"//         [%04x]            (%08x)", iSlot, *(DWORD *) pSlot);
                pSlot += sizeof(DWORD);
            }
            else
            {
                sprintf(szString,"//         [%04x]            (%16x)", iSlot, *(unsigned __int64 *) pSlot);
                pSlot += sizeof(unsigned __int64);
            }
            printLine(GUICookie,szStr);    

            ValidateToken(tkMethod, mdtMethodDef);
        }

        // Pointer to next fixup entry.
NextEntry:        
        ++pFixup;
    }

exit:
    printLine(GUICookie,"");    
}


void DumpEATTable(IMAGE_COR20_HEADER *CORHeader, void* GUICookie)
{
    BYTE        *pFixup;
    DWORD       iCount;
    DWORD       BufferRVA;
    DWORD       i;
    char szString[1024];
    char* szStr = &szString[0];
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode
    
    sprintf(szString,"// Export Address Table Jumps:");
    printLine(GUICookie,szStr);    
    
    if (CORHeader->ExportAddressTableJumps.VirtualAddress == 0)
    {
        printLine(GUICookie,RstrA(IDS_E_NODATA));    
        return;
    }

    // Pull back a pointer to the guy.
    iCount = CORHeader->ExportAddressTableJumps.Size / IMAGE_COR_EATJ_THUNK_SIZE;
    if (g_pPELoader->getVAforRVA((DWORD) CORHeader->ExportAddressTableJumps.VirtualAddress, (void **) &pFixup) == FALSE)
    {
        printLine(GUICookie,RstrA(IDS_E_EATJTABLE));    
        goto exit;
    }

    // Quick sanity check on the linker.
    if (CORHeader->ExportAddressTableJumps.Size % IMAGE_COR_EATJ_THUNK_SIZE)
    {
        sprintf(szString,RstrA(IDS_E_EATJSIZE),
                CORHeader->ExportAddressTableJumps.Size, IMAGE_COR_EATJ_THUNK_SIZE);
        printLine(GUICookie,szStr);    
    }

    // Walk every v-table fixup entry and dump the slots.
    BufferRVA = CORHeader->ExportAddressTableJumps.VirtualAddress;
    for (i=0;  i<iCount;  i++)
    {
        ULONG ReservedFlag = *(ULONG *) (pFixup + sizeof(ULONG));
        sprintf(szString,"//   Fixup Jump Entry [%d], at RVA %08x:", i, BufferRVA);
        printLine(GUICookie,szStr);    
        sprintf(szString,"//       RVA of slot:       %08x", *(ULONG *) pFixup);
        printLine(GUICookie,szStr);    
        sprintf(szString,"//       Reserved flag:     %08x", ReservedFlag);
        printLine(GUICookie,szStr);    
        if (ReservedFlag != 0)
        {
            printLine(GUICookie,RstrA(IDS_E_RESFLAGS));    
        }
        // @Future: would be nice to go back to v-table fixup table and find
        // what entry points to this slot and give the token of the target guy.

        pFixup += IMAGE_COR_EATJ_THUNK_SIZE;
        BufferRVA += IMAGE_COR_EATJ_THUNK_SIZE;
    }

exit:
    printLine(GUICookie,"");    
}


void DumpCodeManager(IMAGE_COR20_HEADER *CORHeader, void* GUICookie)
{
    char szString[1024];
    char* szStr = &szString[0];
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode

    sprintf(szString,"// Code Manager Table:");
    printLine(GUICookie,szStr);
    if (!CORHeader->CodeManagerTable.Size)
    {        
        sprintf(szString,"//  default");
        printLine(GUICookie,szStr);
        return;
    }

    const GUID *pcm;
    if (g_pPELoader->getVAforRVA((DWORD) CORHeader->CodeManagerTable.VirtualAddress, (void **) &pcm) == FALSE)
    {
        printLine(GUICookie,RstrA(IDS_E_CODEMGRTBL));
        return;
    }

    sprintf(szString,"//   [index]       ID");
    printLine(GUICookie,szStr);
    ULONG iCount = CORHeader->CodeManagerTable.Size / sizeof(GUID);
    for (ULONG i=0;  i<iCount;  i++)
    {
        WCHAR        rcguid[128];
        StringFromGUID2(*pcm, rcguid, NumItems(rcguid));
        sprintf(szString,"//   [%08x]    %S", i, rcguid);
        printLine(GUICookie,szStr);
        pcm++;
    }
    printLine(GUICookie,"");
}

void DumpIAT(const char *szName, IMAGE_DATA_DIRECTORY *pDir, void* GUICookie)
{
    char szString[1024];
    char* szStr = &szString[0];
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode
    sprintf(szString,"// %s", szName);
    printLine(GUICookie,szStr);
    if (!pDir->Size)
    {
        printLine(GUICookie,RstrA(IDS_E_NODATA));
        return;
    }

    const char *szDLLName;
    const IMAGE_IMPORT_DESCRIPTOR *pImportDesc;
    
    if (g_pPELoader->getVAforRVA((DWORD) pDir->VirtualAddress, (void **) &pImportDesc) == FALSE)
    {
        printLine(GUICookie,RstrA(IDS_E_IMPORTDATA));
        return;
    }

    const DWORD *pImportTableID;
    ULONG iCount = pDir->Size / sizeof(IMAGE_IMPORT_DESCRIPTOR);
    while (pImportDesc->FirstThunk)
    {
        if (g_pPELoader->getVAforRVA((DWORD) pImportDesc->Name, (void **) &szDLLName) == FALSE ||
            g_pPELoader->getVAforRVA((DWORD) pImportDesc->FirstThunk, (void **) &pImportTableID) == FALSE)
        {
            printLine(GUICookie,RstrA(IDS_E_IMPORTDATA));
            return;
        }
    
        sprintf(szString,"//     %s", szDLLName);
        printLine(GUICookie,szStr);
        sprintf(szString,"//              %08x Import Address Table", pImportDesc->FirstThunk);
        printLine(GUICookie,szStr);
        sprintf(szString,"//              %08x Import Name Table", pImportDesc->Name);
        printLine(GUICookie,szStr);
        sprintf(szString,"//              %-8d time date stamp", pImportDesc->TimeDateStamp);
        printLine(GUICookie,szStr);
        sprintf(szString,"//              %-8d Index of first forwarder reference", pImportDesc->ForwarderChain);
        printLine(GUICookie,szStr);
        sprintf(szString,"//");
        printLine(GUICookie,szStr);
        
        for ( ; *pImportTableID;  pImportTableID++)
        {
            const IMAGE_IMPORT_BY_NAME *pName;
            if(g_pPELoader->getVAforRVA((DWORD) (*pImportTableID & 0x7fffffff), (void **) &pName))
			{
				if (*pImportTableID & 0x80000000)
					sprintf(szString,"//             %8x  by ordinal %d", pName->Hint, (*pImportTableID & 0x7fffffff));
				else
					sprintf(szString,"//             %8x  %s", pName->Hint, pName->Name);
				printLine(GUICookie,szStr);
			}
			else
			{
				printLine(GUICookie,RstrA(IDS_E_IMPORTDATA));
				break;
			}
       }
       printLine(GUICookie,"");
    
        // Next import descriptor.
        pImportDesc++;
    }
}


#define DUMP_DIRECTORY(szName, Directory) \
    sprintf(szString,"// %-8x [%-8x] address [size] of " ## szName, Directory.VirtualAddress, Directory.Size); \
    printLine(GUICookie,szStr)

void DumpHeader(IMAGE_COR20_HEADER *CORHeader, void* GUICookie)
{
    char szString[1024];
    char* szStr = &szString[0];
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode
    sprintf(szString,"// PE Header:");
    printLine(GUICookie,szStr);
    IMAGE_NT_HEADERS *pNTHeader = g_pPELoader->ntHeaders();
    IMAGE_OPTIONAL_HEADER *pOptHeader = &pNTHeader->OptionalHeader;
    
    sprintf(szString,"// Subsystem:                      %08x", pOptHeader->Subsystem);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Native entry point address:     %08x", pOptHeader->AddressOfEntryPoint);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Image base:                     %08x", pOptHeader->ImageBase);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Section alignment:              %08x", pOptHeader->SectionAlignment);
    printLine(GUICookie,szStr);
    sprintf(szString,"// File alignment:                 %08x", pOptHeader->FileAlignment);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Stack reserve size:             %08x", pOptHeader->SizeOfStackReserve);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Stack commit size:              %08x", pOptHeader->SizeOfStackCommit);
    printLine(GUICookie,szStr);
    sprintf(szString,"// Directories:                    %08x", pOptHeader->NumberOfRvaAndSizes);
    printLine(GUICookie,szStr);
    DUMP_DIRECTORY("Export Directory:          ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
    DUMP_DIRECTORY("Import Directory:          ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    DUMP_DIRECTORY("Resource Directory:        ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]);
    DUMP_DIRECTORY("Exception Directory:       ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION]);
    DUMP_DIRECTORY("Security Directory:        ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]);
    DUMP_DIRECTORY("Base Relocation Table:     ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
    DUMP_DIRECTORY("Debug Directory:           ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG]);
    DUMP_DIRECTORY("Architecture Specific:     ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_ARCHITECTURE]);
    DUMP_DIRECTORY("Global Pointer:            ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR]);
    DUMP_DIRECTORY("TLS Directory:             ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS]);
    DUMP_DIRECTORY("Load Config Directory:     ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]);
    DUMP_DIRECTORY("Bound Import Directory:    ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]);
    DUMP_DIRECTORY("Import Address Table:      ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT]);
    DUMP_DIRECTORY("Delay Load IAT:            ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]);
    DUMP_DIRECTORY("CLR Header:               ", pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]);
    printLine(GUICookie,"");

    DumpIAT("Import Address Table", &pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT],GUICookie);
    DumpIAT("Delay Load Import Address Table", &pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT],GUICookie);

    if (!CORHeader)
    {
        printLine(GUICookie,RstrA(IDS_E_COMIMAGE));
        return;
    }
    
    sprintf(szString,"// CLR Header:");
    printLine(GUICookie,szStr);
    sprintf(szString,"// %-8d Header Size", CORHeader->cb);
    printLine(GUICookie,szStr);
    sprintf(szString,"// %-8d Major Runtime Version", CORHeader->MajorRuntimeVersion);
    printLine(GUICookie,szStr);
    sprintf(szString,"// %-8d Minor Runtime Version", CORHeader->MinorRuntimeVersion);
    printLine(GUICookie,szStr);
    sprintf(szString,"// %-8x Flags", CORHeader->Flags);
    printLine(GUICookie,szStr);
    sprintf(szString,"// %-8x Entrypoint Token", CORHeader->EntryPointToken);
    printLine(GUICookie,szStr);

    // Metadata
    DUMP_DIRECTORY("Metadata Directory:        ", CORHeader->MetaData);

    // Binding
    DUMP_DIRECTORY("Resources Directory:       ", CORHeader->Resources);
    DUMP_DIRECTORY("Strong Name Signature:     ", CORHeader->StrongNameSignature);
    DUMP_DIRECTORY("CodeManager Table:         ", CORHeader->CodeManagerTable);

    // Fixups
    DUMP_DIRECTORY("VTableFixups Directory:    ", CORHeader->VTableFixups);
    DUMP_DIRECTORY("Export Address Table:      ", CORHeader->ExportAddressTableJumps);
    
    // Managed Native Code
    DUMP_DIRECTORY("Precompile Header:         ", CORHeader->ManagedNativeHeader);

#ifdef COMPRESSION_SUPPORTED    
    DUMP_DIRECTORY("CompressionData Directory: ", CORHeader->CompressionData);
#endif    
}


void DumpHeaderDetails(IMAGE_COR20_HEADER *CORHeader, void* GUICookie)
{
    DumpCodeManager(CORHeader,GUICookie);
    DumpVTables(CORHeader,GUICookie);
    DumpEATTable(CORHeader,GUICookie);
    printLine(GUICookie,"");
}


void WritePerfData(const char *KeyDesc, const char *KeyName, const char *UnitDesc, const char *UnitName, void* Value, BOOL IsInt) 
{

    DWORD BytesWritten;

    if(!g_fDumpToPerfWriter) return;

    if (!g_PerfDataFilePtr)
    {
        if((g_PerfDataFilePtr = CreateFile("c:\\perfdata.dat", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE) 
        {
         printLine(NULL,"PefTimer::LogStoppedTime(): Unable to open the FullPath file. No performance data will be generated");
         g_fDumpToPerfWriter = FALSE;
         return;
        }
        WriteFile(g_PerfDataFilePtr,"ExecTime=0\r\n",14,&BytesWritten,NULL);
        WriteFile(g_PerfDataFilePtr,"ExecUnit=bytes\r\n",18,&BytesWritten,NULL);
        WriteFile(g_PerfDataFilePtr,"ExecUnitDescr=File Size\r\n",27,&BytesWritten,NULL);
        WriteFile(g_PerfDataFilePtr,"ExeciDirection=False\r\n",24,&BytesWritten,NULL);
    }

    char ValueStr[10];
    char TmpStr[201];

    if (IsInt)
    {
        sprintf(ValueStr,"%d",(int)*(int*)Value);
    }
    else
    {
        sprintf(ValueStr,"%5.2f",(float)*(float*)Value);
    }
    sprintf(TmpStr, "%s=%s\r\n", KeyName, ValueStr);
    WriteFile(g_PerfDataFilePtr, TmpStr, strlen(TmpStr), &BytesWritten, NULL);

    sprintf(TmpStr, "%s Descr=%s\r\n", KeyName, KeyDesc);
    WriteFile(g_PerfDataFilePtr, TmpStr, strlen(TmpStr), &BytesWritten, NULL);

    sprintf(TmpStr, "%s Unit=%s\r\n", KeyName, UnitName);
    WriteFile(g_PerfDataFilePtr, TmpStr, strlen(TmpStr), &BytesWritten, NULL);

    sprintf(TmpStr, "%s Unit Descr=%s\r\n", KeyName, UnitDesc);
    WriteFile(g_PerfDataFilePtr, TmpStr, strlen(TmpStr), &BytesWritten, NULL);

    sprintf(TmpStr, "%s IDirection=%s\r\n", KeyName, "False");
    WriteFile(g_PerfDataFilePtr, TmpStr, strlen(TmpStr), &BytesWritten, NULL);
}

void WritePerfDataInt(const char *KeyDesc, const char *KeyName, const char *UnitDesc, const char *UnitName, int Value)
{
    WritePerfData(KeyDesc,KeyName,UnitDesc,UnitName, (void*)&Value, TRUE);
}
void WritePerfDataFloat(const char *KeyDesc, const char *KeyName, const char *UnitDesc, const char *UnitName, float Value)
{
    WritePerfData(KeyDesc,KeyName,UnitDesc,UnitName, (void*)&Value, FALSE); 
}


IMetaDataTables *pITables = NULL;
ULONG sizeRec, count;
int   size, size2;
int   metaSize = 0;
__int64 fTableSeen;
inline void TableSeen(unsigned long n) { fTableSeen |= (1i64 << n); }
inline int IsTableSeen(unsigned long n) { return (fTableSeen & (1i64 << n)) ? 1 : 0;}
inline void TableSeenReset() { fTableSeen = 0;}

void DumpTable(unsigned long Table, const char *TableName, void* GUICookie) 
{
    char szString[1024];
    char *szStr = &szString[0];
    const char **ppTableName = 0;
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode

    // Record that this table has been seen.
    TableSeen(Table);
    
    // If no name passed in, get from table info.
    if (!TableName)
        ppTableName = &TableName;
    
    pITables->GetTableInfo(Table, &sizeRec, &count, NULL, NULL, ppTableName);
    if(count > 0) 
    {
        metaSize += size = count * sizeRec;                                   
        WritePerfDataInt(TableName,TableName,"count","count",count);
        WritePerfDataInt(TableName,TableName,"bytes","bytes",size);
        sprintf(szString,"//   %-14s- %4d (%d bytes)", TableName, count, size);
        printLine(GUICookie,szStr);
    }
}


   
void DumpStatistics(IMAGE_COR20_HEADER *CORHeader, void* GUICookie) 
{

   int    fileSize, miscPESize, miscCOMPlusSize, methodHeaderSize, methodBodySize, dataSize;
   int    methodBodies, fatHeaders, tinyHeaders, deprecatedHeaders;
   int    size, size2;
   int    fatSections, smallSections;
   ULONG  methodDefs;
   ULONG  i;
   ULONG  sizeRec, count;
   char   buf[MAX_MEMBER_LENGTH];
    char szString[1024];
    char* szStr = &szString[0];
    if(g_Mode & MODE_GUI) szStr += 2; // no need for "//" in GUI mode

    TableSeenReset();
    metaSize = 0;

   sprintf(szString,"// File size            : %d", fileSize = SafeGetFileSize(g_pPELoader->getHFile(), NULL));
    printLine(GUICookie,szStr);

   WritePerfDataInt("FileSize","FileSize","standard byte","bytes",fileSize);

   size = ((IMAGE_DOS_HEADER*) g_pPELoader->getHModule())->e_lfanew +
            sizeof(IMAGE_NT_HEADERS) - sizeof(IMAGE_OPTIONAL_HEADER32) +
            g_pPELoader->ntHeaders()->FileHeader.SizeOfOptionalHeader +
            g_pPELoader->ntHeaders()->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
   size2 = (size + g_pPELoader->ntHeaders()->OptionalHeader.FileAlignment - 1) & ~(g_pPELoader->ntHeaders()->OptionalHeader.FileAlignment - 1);
//@todo - seems to be bogus currently
//   _ASSERTE(size2 == (int) g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders);


   WritePerfDataInt("PE header size", "PE header size", "standard byte", "bytes", g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders);
   WritePerfDataInt("PE header size used", "PE header size used", "standard byte", "bytes", size);
   WritePerfDataFloat("PE header size", "PE header size", "percentage", "percentage", (float) ((g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders * 100) / fileSize));
   

   sprintf(szString,"// PE header size       : %d (%d used)    (%5.2f%%)", 
      g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders, 
      size,  
      (double) (g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders * 100) / fileSize);
    printLine(GUICookie,szStr);

   miscPESize = 0;
   for (i=0; i < (int) g_pPELoader->ntHeaders()->OptionalHeader.NumberOfRvaAndSizes; ++i) {
      // Skip the CLR header.
      if (i != IMAGE_DIRECTORY_ENTRY_COMHEADER) miscPESize += (int) g_pPELoader->ntHeaders()->OptionalHeader.DataDirectory[i].Size;
      }

   WritePerfDataInt("PE additional info", "PE additional info", "standard byte", "bytes",miscPESize);
   WritePerfDataFloat("PE additional info", "PE additional info", "percentage", "percent", (float) ((miscPESize * 100) / fileSize));

   sprintf(buf, "PE additional info   : %d", miscPESize);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (miscPESize * 100) / fileSize);
    printLine(GUICookie,szStr);

   WritePerfDataInt("Num.of PE sections", "Num.of PE sections", "Nbr of sections", "sections",g_pPELoader->ntHeaders()->FileHeader.NumberOfSections);
   sprintf(szString,"// Num.of PE sections   : %d", g_pPELoader->ntHeaders()->FileHeader.NumberOfSections);
    printLine(GUICookie,szStr);

   WritePerfDataInt("CLR header size", "CLR header size", "byte", "bytes",CORHeader->cb);
   WritePerfDataFloat("CLR header size", "CLR header size", "percentage", "percent",(float) ((CORHeader->cb * 100) / fileSize));

   sprintf(buf, "CLR header size     : %d", CORHeader->cb);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (CORHeader->cb * 100) / fileSize);
    printLine(GUICookie,szStr);

   WritePerfDataInt("CLR meta-data size", "CLR meta-data size", "bytes", "bytes",CORHeader->MetaData.Size);
   WritePerfDataFloat("CLR meta-data size", "CLR meta-data size", "percentage", "percent",(float) ((CORHeader->MetaData.Size * 100) / fileSize));

   sprintf(buf, "CLR meta-data size  : %d", CORHeader->MetaData.Size);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (CORHeader->MetaData.Size * 100) / fileSize);
    printLine(GUICookie,szStr);

   IMAGE_DATA_DIRECTORY *pFirst = &CORHeader->Resources;
   int iCount = ((BYTE *) &CORHeader->ManagedNativeHeader - (BYTE *) &CORHeader->Resources) / sizeof(IMAGE_DATA_DIRECTORY) + 1;
   miscCOMPlusSize = 0;
   for (int iDir=0;  iDir<iCount;  iDir++)
   {
        miscCOMPlusSize += pFirst->Size;
        pFirst++;
   }

   WritePerfDataInt("CLR Additional info", "CLR Additional info", "bytes", "bytes",miscCOMPlusSize);
   WritePerfDataFloat("CLR Additional info", "CLR Additional info", "percentage", "percent",(float) ((miscCOMPlusSize * 100) / fileSize));

   sprintf(buf, "CLR additional info : %d", miscCOMPlusSize);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (miscCOMPlusSize * 100) / fileSize);
    printLine(GUICookie,szStr);

   //@todo: We don't handle method impls right now.
   //  _ASSERTE(g_pImport->GetCountWithTokenKind(mdtMethodImpl) == 0);

   // Go through each method def collecting some statistics.
   methodHeaderSize = methodBodySize = 0;
   methodBodies = fatHeaders = tinyHeaders = deprecatedHeaders = fatSections = smallSections = 0;
   methodDefs = g_pImport->GetCountWithTokenKind(mdtMethodDef);
   for (i=1; i <= methodDefs; ++i) {
       ULONG   rva;
       DWORD   flags;

       g_pImport->GetMethodImplProps(TokenFromRid(i, mdtMethodDef), &rva, &flags);
       if ((rva != 0)&&(IsMiIL(flags) || IsMiOPTIL(flags)))	// We don't handle native yet.
       {
            ++methodBodies;

           COR_ILMETHOD_FAT *pMethod;
           g_pPELoader->getVAforRVA(rva, (void **) &pMethod);
           if (pMethod->IsFat())
           {
               ++fatHeaders;

               methodHeaderSize += pMethod->Size * 4;
               methodBodySize += pMethod->GetCodeSize();

               // Add in the additional sections.
               BYTE *sectsBegin = (BYTE *) (pMethod->GetCode() + pMethod->GetCodeSize());
               const COR_ILMETHOD_SECT *pSect = pMethod->GetSect();
               const COR_ILMETHOD_SECT *pOldSect;
               if (pSect != NULL) {
                   // Keep skipping a pointer past each section.
                   do
                   {
                       pOldSect = pSect;
                       if (((COR_ILMETHOD_SECT_FAT *) pSect)->Kind & CorILMethod_Sect_FatFormat)
                       {
                           ++fatSections;
                           pSect = (COR_ILMETHOD_SECT *)((BYTE *) pSect + ((COR_ILMETHOD_SECT_FAT *) pSect)->DataSize);
                       }
                       else
                       {
                           ++smallSections;
                           pSect = (COR_ILMETHOD_SECT *)((BYTE *) pSect + ((COR_ILMETHOD_SECT_SMALL *) pSect)->DataSize);
                       }
                       pSect = (COR_ILMETHOD_SECT *) (((UINT_PTR) pSect + 3) & ~3);
                   }
                   while (pOldSect->More());

                   // Add on the section sizes.
                   methodHeaderSize += (int) ((BYTE *) pSect - sectsBegin);
               }
           }
           else if (((COR_ILMETHOD_TINY *) pMethod)->IsTiny())
           {
               ++tinyHeaders;
               methodHeaderSize += sizeof(COR_ILMETHOD_TINY);
               methodBodySize += ((COR_ILMETHOD_TINY *) pMethod)->GetCodeSize();
           }
           else
               _ASSERTE(!"Unrecgonized header type");
       }
   }


   WritePerfDataInt("CLR method headers", "CLR method headers", "bytes", "bytes",methodHeaderSize);
   WritePerfDataFloat("CLR method headers", "CLR method headers", "percentage", "percent",(float) ((methodHeaderSize * 100) / fileSize));

   sprintf(buf, "CLR method headers  : %d", methodHeaderSize);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (methodHeaderSize * 100) / fileSize);
    printLine(GUICookie,szStr);

   WritePerfDataInt("Managed code", "Managed code", "bytes", "bytes",methodBodySize);
   WritePerfDataFloat("Managed code", "Managed code", "percentage", "percent",(float) ((methodBodySize * 100) / fileSize));

   sprintf(buf, "Managed code         : %d", methodBodySize);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (methodBodySize * 100) / fileSize);
    printLine(GUICookie,szStr);

	dataSize = 0;
   IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(g_pPELoader->ntHeaders());

   for (i=0; i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections; ++i) {
	   if(pSecHdr->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)
		   dataSize += pSecHdr->Misc.VirtualSize;
       ++pSecHdr;
   }

   WritePerfDataInt("Data", "Data", "bytes", "bytes",dataSize);
   WritePerfDataFloat("Data", "Data", "percentage", "percent",(float) ((dataSize * 100) / fileSize));
   
   sprintf(buf, "Data                 : %d", dataSize);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (dataSize * 100) / fileSize);
    printLine(GUICookie,szStr);
   
   size = fileSize - g_pPELoader->ntHeaders()->OptionalHeader.SizeOfHeaders - miscPESize - CORHeader->cb -
          CORHeader->MetaData.Size - miscCOMPlusSize - 
          dataSize -
          methodHeaderSize - methodBodySize ;

   WritePerfDataInt("Unaccounted", "Unaccounted", "bytes", "bytes",size);
   WritePerfDataFloat("Unaccounted", "Unaccounted", "percentage", "percent",(float) ((size * 100) / fileSize));

   sprintf(buf, "Unaccounted          : %d", size);
   sprintf(szString,"// %-40s (%5.2f%%)", buf, (double) (size * 100) / fileSize);
    printLine(GUICookie,szStr);


   // Detail...
   WritePerfDataInt("Num.of PE sections", "Num.of PE sections", "bytes", "bytes",g_pPELoader->ntHeaders()->FileHeader.NumberOfSections);
    printLine(GUICookie,"");
   sprintf(szString,"// Num.of PE sections   : %d", g_pPELoader->ntHeaders()->FileHeader.NumberOfSections);
    printLine(GUICookie,szStr);

            
   pSecHdr = IMAGE_FIRST_SECTION(g_pPELoader->ntHeaders());

   for (i=0; i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections; ++i) {
      WritePerfDataInt((char*)pSecHdr->Name,(char*)pSecHdr->Name, "bytes", "bytes",pSecHdr->SizeOfRawData);
      sprintf(szString,"//   %-8s - %d", pSecHdr->Name, pSecHdr->SizeOfRawData);
        printLine(GUICookie,szStr);
      ++pSecHdr;
      }

//   if(FAILED(GetMetaDataPublicInterfaceFromInternal(g_pImport, IID_IMetaDataTables, (void**)&pITables)))
   if(FAILED(g_pPubImport->QueryInterface(IID_IMetaDataTables, (void**)&pITables)))
   {
	   sprintf(szString,"// Unable to get IMetaDataTables interface");
	   printLine(GUICookie,szStr);
	   return;
   }

   if (pITables == 0)
   {
        printLine(GUICookie,RstrA(IDS_E_MDDETAILS));
   }
    else
    {
        WritePerfDataInt("CLR meta-data size", "CLR meta-data size", "bytes", "bytes",CORHeader->MetaData.Size);
        printLine(GUICookie,"");
        sprintf(szString,"// CLR meta-data size  : %d", CORHeader->MetaData.Size);
        printLine(GUICookie,szStr);
        metaSize = 0;

        pITables->GetTableInfo(TBL_Module, &sizeRec, &count, NULL, NULL, NULL);
        TableSeen(TBL_Module);
        metaSize += size = count * sizeRec;                                     \
            WritePerfDataInt("Module (count)", "Module (count)", "count", "count",count);
        WritePerfDataInt("Module (bytes)", "Module (bytes)", "bytes", "bytes",size);
        sprintf(szString,"//   %-14s- %4d (%d bytes)", "Module", count, size); \
            printLine(GUICookie,szStr);

        if ((count = g_pImport->GetCountWithTokenKind(mdtTypeDef)) > 0)
        {
            int     flags, interfaces = 0, explicitLayout = 0;
            for (i=1; i <= count; ++i)
            {
                g_pImport->GetTypeDefProps(TokenFromRid(i, mdtTypeDef), (ULONG *) &flags, NULL);
                if (flags & tdInterface) ++interfaces;
                if (flags & tdExplicitLayout)   ++explicitLayout;
            }
            // Get count from table -- count reported by GetCount... doesn't include the "global" typedef.
            pITables->GetTableInfo(TBL_TypeDef, &sizeRec, &count, NULL, NULL, NULL);
            TableSeen(TBL_TypeDef);
            metaSize += size = count * sizeRec;

            WritePerfDataInt("TypeDef (count)", "TypeDef (count)", "count", "count", count);
            WritePerfDataInt("TypeDef (bytes)", "TypeDef (bytes)", "bytes", "bytes", size);
            WritePerfDataInt("interfaces", "interfaces", "count", "count", interfaces);
            WritePerfDataInt("explicitLayout", "explicitLayout", "count", "count", explicitLayout);

            sprintf(buf, "  TypeDef       - %4d (%d bytes)", count, size);
            sprintf(szString,"// %-38s %d interfaces, %d explicit layout", buf, interfaces, explicitLayout);
            printLine(GUICookie,szStr);
        }
    }

    pITables->GetTableInfo(TBL_TypeRef, &sizeRec, &count, NULL, NULL, NULL);
    TableSeen(TBL_TypeRef);
    if (count > 0)
    {
        metaSize += size = count * sizeRec;                                      \
            WritePerfDataInt("TypeRef (count)", "TypeRef (count)", "count", "count", count);
        WritePerfDataInt("TypeRef (bytes)", "TypeRef (bytes)", "bytes", "bytes", size);
        sprintf(szString,"//   %-14s- %4d (%d bytes)", "TypeRef", count, size); \
            printLine(GUICookie,szStr);
    }

    if ((count = g_pImport->GetCountWithTokenKind(mdtMethodDef)) > 0)
    {
        int     flags, abstract = 0, native = 0;
        for (i=1; i <= count; ++i)
        {
            flags = g_pImport->GetMethodDefProps(TokenFromRid(i, mdtMethodDef));
            if (flags & mdAbstract) ++abstract;
        }
        pITables->GetTableInfo(TBL_Method, &sizeRec, NULL, NULL, NULL, NULL);
        TableSeen(TBL_Method);
        if (count > 0)
        {
            metaSize += size = count * sizeRec;

            WritePerfDataInt("MethodDef (count)", "MethodDef (count)", "count", "count", count);
            WritePerfDataInt("MethodDef (bytes)", "MethodDef (bytes)", "bytes", "bytes", size);
            WritePerfDataInt("abstract", "abstract", "count", "count", abstract);
            WritePerfDataInt("native", "native", "count", "count", native);
            WritePerfDataInt("methodBodies", "methodBodies", "count", "count", methodBodies);

            sprintf(buf, "  MethodDef     - %4d (%d bytes)", count, size);
            sprintf(szString,"// %-38s %d abstract, %d native, %d bodies", buf, abstract, native, methodBodies);
            printLine(GUICookie,szStr);
        }
    }

    if ((count = g_pImport->GetCountWithTokenKind(mdtFieldDef)) > 0)
    {
        int     flags, constants = 0;

        for (i=1; i <= count; ++i)
        {
            flags = g_pImport->GetFieldDefProps(TokenFromRid(i, mdtFieldDef));
            if ((flags & (fdStatic|fdInitOnly)) == (fdStatic|fdInitOnly)) ++constants;
        }
        pITables->GetTableInfo(TBL_Field, &sizeRec, NULL, NULL, NULL, NULL);
        metaSize += size = count * sizeRec;

        WritePerfDataInt("FieldDef (count)", "FieldDef (count)", "count", "count", count);
        WritePerfDataInt("FieldDef (bytes)", "FieldDef (bytes)", "bytes", "bytes", size);
        WritePerfDataInt("constant", "constant", "count", "count", constants);

        sprintf(buf, "  FieldDef      - %4d (%d bytes)", count, size);
        sprintf(szString,"// %-38s %d constant", buf, constants);
        printLine(GUICookie,szStr);
        TableSeen(TBL_Field);
    }

    DumpTable(TBL_MemberRef,          "MemberRef",              GUICookie);
    DumpTable(TBL_Param,              "ParamDef",               GUICookie);
    DumpTable(TBL_MethodImpl,         "MethodImpl",             GUICookie);
    DumpTable(TBL_Constant,           "Constant",               GUICookie);
    DumpTable(TBL_CustomAttribute,    "CustomAttribute",        GUICookie);
    DumpTable(TBL_FieldMarshal,       "NativeType",             GUICookie);
    DumpTable(TBL_ClassLayout,        "ClassLayout",            GUICookie);
    DumpTable(TBL_FieldLayout,        "FieldLayout",            GUICookie);
    DumpTable(TBL_StandAloneSig,      "StandAloneSig",          GUICookie);
    DumpTable(TBL_InterfaceImpl,      "InterfaceImpl",          GUICookie);
    DumpTable(TBL_PropertyMap,        "PropertyMap",            GUICookie);
    DumpTable(TBL_Property,           "Property",               GUICookie);
    DumpTable(TBL_MethodSemantics,    "MethodSemantic",         GUICookie);
    DumpTable(TBL_DeclSecurity,       "Security",               GUICookie);
    DumpTable(TBL_TypeSpec,           "TypeSpec",               GUICookie);
    DumpTable(TBL_ModuleRef,          "ModuleRef",              GUICookie);
    DumpTable(TBL_Assembly,           "Assembly",               GUICookie);
    DumpTable(TBL_AssemblyProcessor,  "AssemblyProcessor",      GUICookie);
    DumpTable(TBL_AssemblyOS,         "AssemblyOS",             GUICookie);
    DumpTable(TBL_AssemblyRef,        "AssemblyRef",            GUICookie);
    DumpTable(TBL_AssemblyRefProcessor, "AssemblyRefProcessor", GUICookie);
    DumpTable(TBL_AssemblyRefOS,      "AssemblyRefOS",          GUICookie);
    DumpTable(TBL_File,               "File",                   GUICookie);
    DumpTable(TBL_ExportedType,       "ExportedType",           GUICookie);
    DumpTable(TBL_ManifestResource,   "ManifestResource",       GUICookie);
    DumpTable(TBL_NestedClass,        "NestedClass",            GUICookie);

    // Rest of the tables.
    pITables->GetNumTables(&count);
    for (i=0; i<count; ++i)
    {
        if (!IsTableSeen(i))
            DumpTable(i, NULL, GUICookie);
    }

    // String heap
    pITables->GetStringHeapSize(&sizeRec);
    if (sizeRec > 0)
    {
        metaSize += sizeRec;
        WritePerfDataInt("Strings", "Strings", "bytes", "bytes",sizeRec);
        sprintf(szString,"//   Strings       - %5d bytes", sizeRec);
        printLine(GUICookie,szStr);
    }
    // Blob heap
    pITables->GetBlobHeapSize(&sizeRec);
    if (sizeRec > 0)
    {
        metaSize += sizeRec;
        WritePerfDataInt("Blobs", "Blobs", "bytes", "bytes",sizeRec);
        sprintf(szString,"//   Blobs         - %5d bytes", sizeRec);
        printLine(GUICookie,szStr);
    }
    // User String Heap
    pITables->GetUserStringHeapSize(&sizeRec);
    if (sizeRec > 0)
    {
        metaSize += sizeRec;
        WritePerfDataInt("UserStrings", "UserStrings", "bytes", "bytes",sizeRec);
        sprintf(szString,"//   UserStrings   - %5d bytes", sizeRec);
        printLine(GUICookie,szStr);
    }
    // Guid heap
    pITables->GetGuidHeapSize(&sizeRec);
    if (sizeRec > 0)
    {
        metaSize += sizeRec;
        WritePerfDataInt("Guids", "Guids", "bytes", "bytes", sizeRec);
        sprintf(szString,"//   Guids         - %5d bytes", sizeRec);
        printLine(GUICookie,szStr);
    }

    if (CORHeader->MetaData.Size - metaSize > 0)
    {
        WritePerfDataInt("Uncategorized", "Uncategorized", "bytes", "bytes",CORHeader->MetaData.Size - metaSize);
        sprintf(szString,"//   Uncategorized - %5d bytes", CORHeader->MetaData.Size - metaSize);
        printLine(GUICookie,szStr);
    }

    if (miscCOMPlusSize != 0)
    {
        WritePerfDataInt("CLR additional info", "CLR additional info", "bytes", "bytes", miscCOMPlusSize);
        sprintf(szString,"// CLR additional info : %d", miscCOMPlusSize);
        printLine(GUICookie,"");
        printLine(GUICookie,szStr);

        if (CORHeader->CodeManagerTable.Size != 0)
        {
            WritePerfDataInt("CodeManagerTable", "CodeManagerTable", "bytes", "bytes", CORHeader->CodeManagerTable.Size);
            sprintf(szString,"//   CodeManagerTable  - %d", CORHeader->CodeManagerTable.Size);
            printLine(GUICookie,szStr);
        }

#ifdef COMPRESSION_SUPPORTED      
        if (CORHeader->CompressionData.Size != 0)
        {
            WritePerfDataInt("CompressionData", "CompressionData", "bytes", "bytes",CORHeader->CompressionData.Size);
            sprintf(szString,"//   CompressionData   - %d", CORHeader->CompressionData.Size);
            printLine(GUICookie,szStr);
        }
#endif // COMPRESSION_SUPPORTED

        if (CORHeader->VTableFixups.Size != 0)
        {
            WritePerfDataInt("VTableFixups", "VTableFixups", "bytes", "bytes", CORHeader->VTableFixups.Size);
            sprintf(szString,"//   VTableFixups      - %d", CORHeader->VTableFixups.Size);
            printLine(GUICookie,szStr);
        }

        if (CORHeader->Resources.Size != 0)
        {
            WritePerfDataInt("Resources", "Resources", "bytes", "bytes", CORHeader->Resources.Size);
            sprintf(szString,"//   Resources         - %d", CORHeader->Resources.Size);
            printLine(GUICookie,szStr);
        }
    }
   WritePerfDataInt("CLR method headers", "CLR method headers", "count", "count", methodHeaderSize);
   sprintf(szString,"// CLR method headers : %d", methodHeaderSize);
    printLine(GUICookie,"");
    printLine(GUICookie,szStr);
   WritePerfDataInt("Num.of method bodies", "Num.of method bodies", "count", "count",methodBodies);
   sprintf(szString,"//   Num.of method bodies  - %d", methodBodies);
    printLine(GUICookie,szStr);
   WritePerfDataInt("Num.of fat headers", "Num.of fat headers", "count", "count", fatHeaders);
   sprintf(szString,"//   Num.of fat headers    - %d", fatHeaders);
    printLine(GUICookie,szStr);
   WritePerfDataInt("Num.of tiny headers", "Num.of tiny headers", "count", "count", tinyHeaders);
   sprintf(szString,"//   Num.of tiny headers   - %d", tinyHeaders);
    printLine(GUICookie,szStr);
    
   if (deprecatedHeaders > 0) {
      WritePerfDataInt("Num.of old headers", "Num.of old headers", "count", "count", deprecatedHeaders);
      sprintf(szString,"//   Num.of old headers    - %d", deprecatedHeaders);
        printLine(GUICookie,szStr);
      }

   if (fatSections != 0 || smallSections != 0) {
      WritePerfDataInt("Num.of fat sections", "Num.of fat sections", "count", "count", fatSections);
      sprintf(szString,"//   Num.of fat sections   - %d", fatSections);
        printLine(GUICookie,szStr);
   
      WritePerfDataInt("Num.of small section", "Num.of small section", "count", "count", smallSections);
      sprintf(szString,"//   Num.of small sections - %d", smallSections);
        printLine(GUICookie,szStr);
      }

   WritePerfDataInt("Managed code", "Managed code", "bytes", "bytes", methodBodySize);
   sprintf(szString,"// Managed code : %d", methodBodySize);
    printLine(GUICookie,"");
    printLine(GUICookie,szStr);
   
   if (methodBodies != 0) {
      WritePerfDataInt("Ave method size", "Ave method size", "bytes", "bytes", methodBodySize / methodBodies);
      sprintf(szString,"//   Ave method size - %d", methodBodySize / methodBodies);
        printLine(GUICookie,szStr);
      }
    
   if (pITables)
        pITables->Release();

   if(g_fDumpToPerfWriter) CloseHandle((char*) g_PerfDataFilePtr);
}

void DumpHexbytes(char* szString,BYTE *pb, DWORD fromPtr, DWORD toPtr, DWORD limPtr)
{
    char sz[32];
    char* szptr = &szString[strlen(szString)];
    int k,i;
    DWORD curPtr;
    bool printsz = FALSE;
    BYTE zero = 0;
    *szptr = 0;
    for(i = 0,k = 0,curPtr=fromPtr; curPtr < toPtr; i++,k++,curPtr++,pb++)
    {

        if(k == 16)
        {
            if(printsz) szptr+=sprintf(szptr,"  // %s",sz);
            printLine(g_pFile,szString);
            szptr = &szString[0];
            szptr+=sprintf(szptr,"%s                ",g_szAsmCodeIndent);
            k = 0;
            printsz = FALSE;
        }
        if(curPtr >= limPtr) pb = &zero;    // at limPtr and after, pad with 0
        szptr+=sprintf(szptr," %2.2X", *pb);
        if(isprint(*pb))
        {
            sz[k] = *pb;
            printsz = TRUE;
        }
        else sz[k] = '.';
        sz[k+1] = 0;
    }
    szptr+=sprintf(szptr,") ");
    if(printsz)
    {
        for(i = k; i < 16; i++) szptr+=sprintf(szptr,"   ");
        szptr+=sprintf(szptr,"// %s",sz);
    }
    printLine(g_pFile,szString);
}

struct  VTableEntry
{
    DWORD   dwAddr;
    WORD    wCount;
    WORD    wType;
};

#ifdef DUMP_EAT_ENTRIES
struct ExpDirTable
{
	DWORD	dwFlags;
	DWORD	dwDateTime;
	WORD	wVMajor;
	WORD	wVMinor;
	DWORD	dwNameRVA;
	DWORD	dwOrdinalBase;
	DWORD	dwNumATEntries;
	DWORD	dwNumNamePtrs;
	DWORD	dwAddrTableRVA;
	DWORD	dwNamePtrRVA;
	DWORD	dwOrdTableRVA;
};
#endif

void DumpVtable(void* GUICookie)
{
    // VTable : primary processing
    DWORD  pVTable=0;
    VTableEntry*    pVTE;
    DWORD i,j,k;
    char szString[4096];
    char* szptr;
    
    IMAGE_NT_HEADERS *pNTHeader = g_pPELoader->ntHeaders();
    IMAGE_OPTIONAL_HEADER *pOptHeader = &pNTHeader->OptionalHeader;

    sprintf(szString,"%s.imagebase 0x%08x", g_szAsmCodeIndent,pOptHeader->ImageBase);
    printLine(GUICookie,szString);
    sprintf(szString,"%s.subsystem 0x%08x", g_szAsmCodeIndent,pOptHeader->Subsystem);
    printLine(GUICookie,szString);
    sprintf(szString,"%s.file alignment %d", g_szAsmCodeIndent,pOptHeader->FileAlignment);
    printLine(GUICookie,szString);
    sprintf(szString,"%s.corflags 0x%08x", g_szAsmCodeIndent,g_CORHeader->Flags);
    printLine(GUICookie,szString);
	sprintf(szString,"%s// Image base: 0x%08x",g_szAsmCodeIndent,g_pPELoader->base());
	printLine(GUICookie,szString);
#ifdef DUMP_EAT_ENTRIES
/////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(pOptHeader->NumberOfRvaAndSizes)
	{
		IMAGE_DATA_DIRECTORY *pExportDir = pOptHeader->DataDirectory;
		ExpDirTable *pExpTable = NULL;
		if(pExportDir->Size)
		{
			IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(pNTHeader);
			DWORD N = pNTHeader->FileHeader.NumberOfSections;
#ifdef _DEBUG
			sprintf(szString,"// Export dir VA=%X size=%X ",pExportDir->VirtualAddress,pExportDir->Size);
			printLine(GUICookie,szString);
#endif
			DWORD vaExpTable = pExportDir->VirtualAddress;
			for (i=0; i < N; i++,pSecHdr++)
			{
				if((vaExpTable >= pSecHdr->VirtualAddress)&&
					(vaExpTable < pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize))
				{
					pExpTable = (ExpDirTable*)( g_pPELoader->base()
						+pSecHdr->PointerToRawData 
						+ vaExpTable - pSecHdr->VirtualAddress);
#ifdef _DEBUG
					sprintf(szString,"// in section '%s': VA=%X Misc.VS=%X PRD=%X ",(char*)(pSecHdr->Name),
						pSecHdr->VirtualAddress,pSecHdr->Misc.VirtualSize,pSecHdr->PointerToRawData);
					printLine(GUICookie,szString);
					sprintf(szString,"// Export Directory Table:"); printLine(GUICookie,szString);
					sprintf(szString,"// dwFlags = %X",pExpTable->dwFlags); printLine(GUICookie,szString);
					sprintf(szString,"// dwDateTime = %X",pExpTable->dwDateTime); printLine(GUICookie,szString);
					sprintf(szString,"// wVMajor = %X",pExpTable->wVMajor); printLine(GUICookie,szString);
					sprintf(szString,"// wVMinor = %X",pExpTable->wVMinor); printLine(GUICookie,szString);
					sprintf(szString,"// dwNameRVA = %X",pExpTable->dwNameRVA); printLine(GUICookie,szString);
					sprintf(szString,"// dwOrdinalBase = %X",pExpTable->dwOrdinalBase); printLine(GUICookie,szString);
					sprintf(szString,"// dwNumATEntries = %X",pExpTable->dwNumATEntries); printLine(GUICookie,szString);
					sprintf(szString,"// dwNumNamePtrs = %X",pExpTable->dwNumNamePtrs); printLine(GUICookie,szString);
					sprintf(szString,"// dwAddrTableRVA = %X",pExpTable->dwAddrTableRVA); printLine(GUICookie,szString);
					sprintf(szString,"// dwNamePtrRVA = %X",pExpTable->dwNamePtrRVA); printLine(GUICookie,szString);
					sprintf(szString,"// dwOrdTableRVA = %X",pExpTable->dwOrdTableRVA); printLine(GUICookie,szString);
#endif
					try 
					{
						if(pExpTable->dwNameRVA)
						{
							char*	szName;
							g_pPELoader->getVAforRVA(pExpTable->dwNameRVA, (void **) &szName);
	#ifdef _DEBUG
							sprintf(szString,"// DLL Name: '%s'",szName); printLine(GUICookie,szString);
	#endif
						}
						if(pExpTable->dwNumATEntries && pExpTable->dwAddrTableRVA)
						{
							DWORD* pExpAddr;
							BYTE *pCont;
							DWORD dwTokRVA;
							mdToken* pTok;
							g_pPELoader->getVAforRVA(pExpTable->dwAddrTableRVA, (void **) &pExpAddr);
	#ifdef _DEBUG
							sprintf(szString,"// Export Address Table:"); printLine(GUICookie,szString);
	#endif
							g_nEATableRef = pExpTable->dwNumATEntries;
							g_rEATableRef[g_nEATableRef].tkTok = 0; // to avoid multiple reallocations of DynamicArray
							for(j=0; j < pExpTable->dwNumATEntries; j++,pExpAddr++)
							{
								g_pPELoader->getVAforRVA(*pExpAddr, (void **) &pCont);
	#ifdef _DEBUG
								sprintf(szString,"// [%d]: RVA=%X VA=%X(",j,*pExpAddr,pCont); 
								DumpByteArray(szString,pCont,16,GUICookie);
								printLine(GUICookie,szString);
	#endif
								g_rEATableRef[j].tkTok = 0;
								if(*((WORD*)pCont) == 0x25FF)
								{
									dwTokRVA = *((DWORD*)(pCont+2)); // first two bytes - JumpIndirect (0x25FF)
									dwTokRVA -= pOptHeader->ImageBase;
									if(g_pPELoader->getVAforRVA(dwTokRVA,(void**)&pTok))
																g_rEATableRef[j].tkTok = *pTok;
								}
								g_rEATableRef[j].pszName = NULL;

							}
						}
						if(pExpTable->dwNumNamePtrs && pExpTable->dwNamePtrRVA && pExpTable->dwOrdTableRVA)
						{
							DWORD *pNamePtr;
							WORD	*pOrd;
							char*	szName;
							g_pPELoader->getVAforRVA(pExpTable->dwNamePtrRVA, (void **) &pNamePtr);
							g_pPELoader->getVAforRVA(pExpTable->dwOrdTableRVA, (void **) &pOrd);
	#ifdef _DEBUG
							sprintf(szString,"// Export Names:"); printLine(GUICookie,szString);
	#endif
							for(j=0; j < pExpTable->dwNumATEntries; j++,pNamePtr++,pOrd++)
							{
								g_pPELoader->getVAforRVA(*pNamePtr, (void **) &szName);
	#ifdef _DEBUG
								sprintf(szString,"// [%d]: NamePtr=%X Ord=%X Name='%s'",j,*pNamePtr,*pOrd,szName); printLine(GUICookie,szString);
	#endif
								g_rEATableRef[*pOrd].pszName = szName;
							}
						}
						g_nEATableBase = pExpTable->dwOrdinalBase;
					}
					catch(...)
					{
						strcpy(szString,"// ERROR READING EXPORT ADDRESS TABLE");
						printLine(GUICookie,szString);
						g_nEATableRef = 0;
					}
					break;
				}
			}
		}
	}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif    

	g_nVTableRef = 0;
    if(g_CORHeader->VTableFixups.Size)
    {
        IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(g_pPELoader->ntHeaders());

        pVTable = g_CORHeader->VTableFixups.VirtualAddress;
        for (i=0; i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections; i++,pSecHdr++)
        {
            if(((DWORD)pVTable >= pSecHdr->VirtualAddress)&&
                ((DWORD)pVTable < pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize))
            {
                pVTE = (VTableEntry*)( g_pPELoader->base()
                    +pSecHdr->PointerToRawData 
                    + pVTable - pSecHdr->VirtualAddress);
                for(j=g_CORHeader->VTableFixups.Size,k=0; j > 0; pVTE++, j-=sizeof(VTableEntry),k++)
                {
                    szptr = &szString[0];
                    szptr+=sprintf(szptr,"%s.vtfixup [%d] ",g_szAsmCodeIndent,pVTE->wCount);
					DWORD dwSize = pVTE->wCount * 4;
                    if(pVTE->wType & COR_VTABLE_32BIT) szptr+=sprintf(szptr,"int32 ");
                    else if(pVTE->wType & COR_VTABLE_64BIT)
					{
						szptr+=sprintf(szptr,"int64 ");
						dwSize <<= 1;
					}
                    if(pVTE->wType & COR_VTABLE_FROM_UNMANAGED) szptr+=sprintf(szptr,"fromunmanaged ");
                    if(pVTE->wType & COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN) szptr+=sprintf(szptr,"retainappdomain ");
                    
                    if(pVTE->wType & COR_VTABLE_CALL_MOST_DERIVED) szptr+=sprintf(szptr,"callmostderived ");
                    szptr+=sprintf(szptr,"at ");
                    szptr = DumpDataPtr(szptr,pVTE->dwAddr, dwSize);
                    // Walk every v-table fixup entry and dump the slots.
                    {
                        BYTE *pSlot;
                        if (g_pPELoader->getVAforRVA(pVTE->dwAddr, (void **) &pSlot))
                        {
                            szptr+=sprintf(szptr," //");
                            for (WORD iSlot=0;  iSlot<pVTE->wCount;  iSlot++)
                            {
                                mdMethodDef tkMethod = *(DWORD *) pSlot;
                                if (pVTE->wType & COR_VTABLE_32BIT)
                                {
                                    szptr+=sprintf(szptr," %08X", *(DWORD *)pSlot);
                                    pSlot += sizeof(DWORD);
                                }
                                else
                                {
                                    szptr+=sprintf(szptr," %016I64X", *(unsigned __int64 *)pSlot);
                                    pSlot += sizeof(unsigned __int64);
                                }
                                g_rVTableRef[g_nVTableRef].tkTok = tkMethod;
                                g_rVTableRef[g_nVTableRef].wEntry = (WORD)k;
                                g_rVTableRef[g_nVTableRef].wSlot = iSlot;
                                g_nVTableRef++;

                                //ValidateToken(tkMethod, mdtMethodDef);
                            }
                        }
                        else
                            szptr+=sprintf(szptr," %s",RstrA(IDS_E_BOGUSRVA));
                    }
                    printLine(GUICookie,szString);
                }
                break;
            }
        }
    }
}
// MetaInfo integration:
void DumpMI(char *str)
{
    static char szStringBuf[8192];
    static BOOL fInit = TRUE;
    static char* szString = &szStringBuf[0];
    static void* GUICookie;
    char* pch;

    if(fInit)
    {
        memset(szStringBuf,0,8192);
        strcpy(szStringBuf,"// ");
        fInit = FALSE;
        GUICookie = (void*)str;
        if(g_Mode & MODE_GUI) szString += 3; // don't need "//" in GUI mode
        return;
    }
    strcat(szString,str);
    if(pch = strchr(szString,'\n'))
    {
        *pch = 0;
        printLine(GUICookie,szString);
        pch++;
        memcpy(&szStringBuf[3], pch, strlen(pch)+1);
    }
}

HRESULT VEHandlerReporter( // Return status.
    LPCWSTR     szMsg,                  // Error message.
    VEContext   Context,                // Error context (offset,token)
    HRESULT     hrRpt)                  // HRESULT for the message
{
    WCHAR* wzMsg;
    char szString[8192];
    if(szMsg)
    {
        wzMsg = (WCHAR*)malloc(sizeof(WCHAR)*(lstrlenW(szMsg)+256)); //new WCHAR[lstrlenW(szMsg)+256];
        lstrcpyW(wzMsg,szMsg);
        // include token and offset from Context
        if(Context.Token) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [token:0x%08X]",Context.Token);
        if(Context.uOffset) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [at:0x%X]",Context.uOffset);
        swprintf(&wzMsg[lstrlenW(wzMsg)],L" [hr:0x%08X]",hrRpt);
        //wprintf(L"%s\n", wzMsg);
        sprintf(szString,"%ls\n",wzMsg);
        //delete wzMsg;
		free(wzMsg);
        DumpMI(szString);
    }
    return S_OK;
}

void DumpMetaInfo(char* pszFileName, char* pszObjFileName, void* GUICookie)
{
    char* pch = strrchr(pszFileName,'.');
    static BOOL fInit = TRUE;
    if(fInit)
    {
        DumpMI((char*)GUICookie); // initialize the print function for DumpMetaInfo
        fInit = FALSE;
    }

	int L = strlen(pszFileName)+1;
    WCHAR *pwzFileName = (WCHAR*)malloc(sizeof(WCHAR)*L); //new WCHAR[L];
	memset(pwzFileName,0,sizeof(WCHAR)*L);
	WszMultiByteToWideChar(CP_UTF8,0,pszFileName,-1,pwzFileName,L);


    if(pch && (!_strcmpi(pch+1,"lib") || !_strcmpi(pch+1,"obj")))
    {   // This works only when all the rest does not
        // Init and run.
        CoInitialize(0);    
        CoInitializeCor(0);

        if(SUCCEEDED(CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, 
                      IID_IMetaDataDispenserEx, (void **) &g_pDisp)))
        {
			WCHAR *pwzObjFileName=NULL;
			if (pszObjFileName)
			{
				int L = strlen(pszObjFileName)+1;
				pwzObjFileName = new WCHAR[L];
				memset(pwzObjFileName,0,sizeof(WCHAR)*L);
				WszMultiByteToWideChar(CP_UTF8,0,pszObjFileName,-1,pwzObjFileName,L);
			}
            DisplayFile(pwzFileName, true, g_ulMetaInfoFilter, pwzObjFileName, DumpMI);
            g_pDisp->Release();
			g_pDisp = NULL;
		    if (pwzObjFileName) delete pwzObjFileName;
        }
        CoUninitializeCor();
        CoUninitialize();
    }
    else
    {
		HRESULT hr = S_OK;
		if(g_pDisp == NULL)
		{
			hr  = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, 
						  IID_IMetaDataDispenserEx, (void **) &g_pDisp);
		}
        if(SUCCEEDED(hr))
        {
			g_ValModuleType = ValidatorModuleTypePE;
			if(g_pAssemblyImport==NULL) g_pAssemblyImport = GetAssemblyImport(NULL);
			if(!(g_Mode & MODE_GUI)) printLine(GUICookie,RstrA(IDS_E_MISTART));
			if(!g_fCheckOwnership) g_ulMetaInfoFilter |= 0x10000000;
			//MDInfo metaDataInfo(g_pPubImport, g_pAssemblyImport, (LPCWSTR)pwzFileName, DumpMI, g_ulMetaInfoFilter);
			MDInfo metaDataInfo(g_pDisp,(LPCWSTR)pwzFileName, DumpMI, g_ulMetaInfoFilter);
			g_ulMetaInfoFilter &= ~0x10000000;
			metaDataInfo.SetVEHandlerReporter((__int64)VEHandlerReporter);
			metaDataInfo.DisplayMD();
			if(!(g_Mode & MODE_GUI)) printLine(GUICookie,RstrA(IDS_E_MIEND));
		}
    }
    //delete pwzFileName;
	free(pwzFileName);
}

void DumpPreamble()
{
	char szString[1024];
    if((g_uCodePage == CP_UTF8)&&g_pFile) fwrite("\357\273\277",3,1,g_pFile);
    else if((g_uCodePage == 0xFFFFFFFF)&&g_pFile) fwrite("\377\376",2,1,g_pFile);
	printLine(g_pFile,"");
    sprintf(szString,"//  Microsoft (R) .NET Framework IL Disassembler.  Version " VER_FILEVERSION_STR);
    printLine(g_pFile,szString);
    sprintf(szString,"//  %s", VER_LEGALCOPYRIGHT_DOS_STR);
    printLine(g_pFile,szString);
    printLine(g_pFile,"");
    if(g_fLimitedVisibility || (!g_fShowCA) || (!g_fDumpAsmCode) 
        || (g_Mode & (MODE_DUMP_CLASS | MODE_DUMP_CLASS_METHOD | MODE_DUMP_CLASS_METHOD_SIG)))
    {
        printLine(g_pFile,"");
        printError(g_pFile,RstrA(IDS_E_PARTDASM));
        printLine(g_pFile,"");
    }

    if(g_fLimitedVisibility)
    {
        strcpy(szString, RstrA(IDS_E_ONLYITEMS));
        if(!g_fHidePub) strcat(szString," Public");
        if(!g_fHidePriv) strcat(szString," Private");
        if(!g_fHideFam) strcat(szString," Family");
        if(!g_fHideAsm) strcat(szString," Assembly");
        if(!g_fHideFAA) strcat(szString," FamilyANDAssembly");
        if(!g_fHidePrivScope) strcat(szString," PrivateScope");
        printLine(g_pFile,szString);
    }
}

void DumpSummary()
{
	ULONG i;
    const char      *pcClass,*pcNS,*pcMember, *pcSig;
	char szString[4096];
	char szFQN[4096];
    HENUMInternal   hEnum;
	mdToken tkMember;
    CQuickBytes     qbMemberSig;
    PCCOR_SIGNATURE pComSig;
    ULONG           cComSig;
	DWORD dwAttrs;
	mdToken tkEventType;

	printLine(g_pFile,"//============ S U M M A R Y =================================");
    if (SUCCEEDED(g_pImport->EnumGlobalFunctionsInit(&hEnum)))
	{
		while(g_pImport->EnumNext(&hEnum, &tkMember))
		{
			pcMember = g_pImport->GetNameOfMethodDef(tkMember);
			pComSig = g_pImport->GetSigOfMethodDef(tkMember, &cComSig);
			qbMemberSig.ReSize(0);
			pcSig = cComSig ? PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL) : "NO SIGNATURE";
			sprintf(szString,"// %08X [GLM] %s : %s", tkMember,ProperName((char*)pcMember),pcSig);
			printLine(g_pFile,szString);
		}
	}
    g_pImport->EnumClose(&hEnum);
    if (SUCCEEDED(g_pImport->EnumGlobalFieldsInit(&hEnum)))
	{
		while(g_pImport->EnumNext(&hEnum, &tkMember))
		{
			pcMember = g_pImport->GetNameOfFieldDef(tkMember);
			pComSig = g_pImport->GetSigOfFieldDef(tkMember, &cComSig);
			qbMemberSig.ReSize(0);
			pcSig = cComSig ? PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL) : "NO SIGNATURE";
			sprintf(szString,"// %08X [GLF] %s : %s", tkMember,ProperName((char*)pcMember),pcSig);
			printLine(g_pFile,szString);
		}
	}
    g_pImport->EnumClose(&hEnum);

    for (i = 0; i < g_NumClasses; i++)
    {
	    g_pImport->GetNameOfTypeDef(g_cl_list[i],&pcClass,&pcNS);
		if(*pcNS) sprintf(szFQN,"%s.%s", ProperName((char*)pcNS),ProperName((char*)pcClass));
		else sprintf(szFQN,"%s",ProperName((char*)pcClass));
		sprintf(szString,"// %08X [CLS] %s", g_cl_list[i],szFQN);
		printLine(g_pFile,szString);
		if(SUCCEEDED(g_pImport->EnumInit(mdtMethodDef, g_cl_list[i], &hEnum)))
		{
			while(g_pImport->EnumNext(&hEnum, &tkMember))
			{
				pcMember = g_pImport->GetNameOfMethodDef(tkMember);
				pComSig = g_pImport->GetSigOfMethodDef(tkMember, &cComSig);
				qbMemberSig.ReSize(0);
			    pcSig = cComSig ? PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL) : "NO SIGNATURE";
				sprintf(szString,"// %08X [MET] %s::%s : %s", tkMember,szFQN,ProperName((char*)pcMember),pcSig);
				printLine(g_pFile,szString);
			}
		}
	    g_pImport->EnumClose(&hEnum);
		if(SUCCEEDED(g_pImport->EnumInit(mdtFieldDef, g_cl_list[i], &hEnum)))
		{
			while(g_pImport->EnumNext(&hEnum, &tkMember))
			{
				pcMember = g_pImport->GetNameOfFieldDef(tkMember);
				pComSig = g_pImport->GetSigOfFieldDef(tkMember, &cComSig);
				qbMemberSig.ReSize(0);
			    pcSig = cComSig ? PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL) : "NO SIGNATURE";
				sprintf(szString,"// %08X [FLD] %s::%s : %s", tkMember,szFQN,ProperName((char*)pcMember),pcSig);
				printLine(g_pFile,szString);
			}
		}
	    g_pImport->EnumClose(&hEnum);
		if(SUCCEEDED(g_pImport->EnumInit(mdtEvent, g_cl_list[i], &hEnum)))
		{
			while(g_pImport->EnumNext(&hEnum, &tkMember))
			{
			    g_pImport->GetEventProps(tkMember,&pcMember,&dwAttrs,&tkEventType);
				qbMemberSig.ReSize(0);
				pcSig = "NO TYPE";
				if(RidFromToken(tkEventType))
				{
						switch(TypeFromToken(tkEventType))
						{
								case mdtTypeRef:
								case mdtTypeDef:
								case mdtTypeSpec:
										pcSig = PrettyPrintClass(&qbMemberSig,tkEventType,g_pImport);
									break;
								default:
									break;
						}
				}
				sprintf(szString,"// %08X [EVT] %s::%s : %s", tkMember,szFQN,ProperName((char*)pcMember),pcSig);
				printLine(g_pFile,szString);
			}
		}
	    g_pImport->EnumClose(&hEnum);
		if(SUCCEEDED(g_pImport->EnumInit(mdtProperty, g_cl_list[i], &hEnum)))
		{
			while(g_pImport->EnumNext(&hEnum, &tkMember))
			{
			    g_pImport->GetPropertyProps(tkMember,&pcMember,&dwAttrs,&pComSig,&cComSig);
				qbMemberSig.ReSize(0);
			    pcSig = cComSig ? PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL) : "NO SIGNATURE";
				sprintf(szString,"// %08X [PRO] %s::%s : %s", tkMember,szFQN,ProperName((char*)pcMember),pcSig);
				printLine(g_pFile,szString);
			}
		}
	    g_pImport->EnumClose(&hEnum);
    }
	printLine(g_pFile,"//=============== END SUMMARY ==================================");
}
//
// Init PELoader, dump file header info
//
BOOL DumpFile(char *pszFilename)
{
 // DWORD       dwEntryPointRVA;
    BOOL        fSuccess = FALSE;
    DWORD       i;
    char		szString[1024];
    WCHAR       wzInputFileName[MAX_FILENAME_LENGTH];
	char		szFilenameANSI[MAX_FILENAME_LENGTH*3];

    if(!(g_Mode & MODE_GUI)) DumpPreamble();
    {
        char* pch = strrchr(g_szInputFile,'.');
        if(pch && (!_strcmpi(pch+1,"lib") || !_strcmpi(pch+1,"obj")))
        {
            if(g_pFile) DumpMetaInfo(g_szInputFile,g_pszObjFileName,g_pFile);
            return FALSE;
        }
    }

    if(g_pPELoader) goto DumpTheSucker; // skip initialization, it's already done

    g_pPELoader = new PELoader();
    if (g_pPELoader == NULL)
    {
        printError(g_pFile,RstrA(IDS_E_INITLDR));
        goto exit;
    }

	memset(wzInputFileName,0,sizeof(WCHAR)*MAX_FILENAME_LENGTH);
	WszMultiByteToWideChar(CP_UTF8,0,pszFilename,-1,wzInputFileName,MAX_FILENAME_LENGTH);
	memset(szFilenameANSI,0,MAX_FILENAME_LENGTH*3);
	WszWideCharToMultiByte(CP_ACP,0,wzInputFileName,-1,szFilenameANSI,MAX_FILENAME_LENGTH*3,NULL,NULL);
	if(g_fOnUnicode)
	{
		fSuccess = g_pPELoader->open(wzInputFileName);
	}
	else
	{
		fSuccess = g_pPELoader->open(szFilenameANSI);
	}

    if (fSuccess == FALSE)
    {
        sprintf(szString,RstrANSI(IDS_E_FILEOPEN), szFilenameANSI);
        printError(g_pFile,szString);
        delete(g_pPELoader);
        g_pPELoader = NULL;
        goto exit;
    }
    fSuccess = FALSE;

    if (g_pPELoader->getCOMHeader(&g_CORHeader) == FALSE)
    {
        sprintf(szString,RstrANSI(IDS_E_NOCORHDR), szFilenameANSI);
        printError(g_pFile,szString);
        if (g_fDumpHeader)
            DumpHeader(g_CORHeader,NULL);
        goto exit;
    }

    if (g_CORHeader->MajorRuntimeVersion == 1 || g_CORHeader->MajorRuntimeVersion > COR_VERSION_MAJOR)
    {
        //@todo: Decide if this is the right version check.
        sprintf(szString,"CORHeader->MajorRuntimeVersion = %d",g_CORHeader->MajorRuntimeVersion);
        printError(g_pFile,szString);
        printError(g_pFile,RstrANSI(IDS_E_BADCORHDR));
        goto exit;
    }
    g_tkEntryPoint = g_CORHeader->EntryPointToken; // integration with MetaInfo
#ifdef COMPRESSION_SUPPORTED
    CreateInstructionDecodingTable(g_pPELoader, g_CORHeader);
#endif // COMPRESSION_SUPPORTED


    if (g_pPELoader->getVAforRVA((DWORD) g_CORHeader->MetaData.VirtualAddress,&g_pMetaData) == FALSE)
    {
        printError(g_pFile,RstrANSI(IDS_E_OPENMD));
        goto exit;
    }

    if (FAILED(GetMetaDataInternalInterface(
        g_pMetaData, 
        g_CORHeader->MetaData.Size, 
        ofRead, 
        IID_IMDInternalImport,
        (void **)&g_pImport)))
    {
        printError(g_pFile,RstrANSI(IDS_E_OPENMD));
        goto exit;
    }

    GetMetaDataPublicInterfaceFromInternal(g_pImport, IID_IMetaDataImport, (void**)&g_pPubImport);
    // Get a symbol binder.
    ISymUnmanagedBinder *binder;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_CorSymBinder_SxS, NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_ISymUnmanagedBinder,
                                  (void**)&binder);

    if (SUCCEEDED(hr))
    {
        hr = binder->GetReaderForFile(g_pPubImport,
                                      wzInputFileName,
                                      NULL,
                                      &g_pSymReader);

        // Release the binder
        binder->Release();
    }

    if (FAILED(hr))
        g_fShowSource = FALSE;

    if(g_fCheckOwnership)
    {
        mdModule mdm;
        BOOL fPassed = TRUE;
        if(SUCCEEDED(g_pPubImport->GetModuleFromScope(&mdm)))
        {
            HCORENUM        hEnum = NULL;
            mdCustomAttribute rCA[4096];
            ULONG           ulCAs;

            g_pPubImport->EnumCustomAttributes(&hEnum, mdm, 0, rCA, 4096, &ulCAs);
            for(ULONG i = 0; i < ulCAs; i++)
            {
                mdToken         tkType;
                BYTE*           pBlob;
                ULONG           ulLen;

                g_pPubImport->GetCustomAttributeProps(              // S_OK or error.
                                                        rCA[i],     // [IN] CustomValue token.
                                                        NULL,       // [OUT, OPTIONAL] Object token.
                                                        &tkType,    // [OUT, OPTIONAL] Put TypeDef/TypeRef token here.
                                            (const void **)&pBlob,  // [OUT, OPTIONAL] Put pointer to data here.
                                                        &ulLen);    // [OUT, OPTIONAL] Put size of date here.

                if(tkType == 0x02000001)
                {
                    fPassed = FALSE;
                    if(pBlob && ulLen && g_pszOwner)
                        fPassed = (0 == memcmp(pBlob,g_pszOwner,ulLen));
                }
            }
            g_pPubImport->CloseEnum( hEnum);
        }
        if(!fPassed)
        {
            printError(g_pFile,RstrA(IDS_E_COPYRIGHT));
            goto exit;
        }
    }
	if(g_uNCA = g_pImport->GetCountWithTokenKind(mdtCustomAttribute))
	{
		g_rchCA = new char[g_uNCA+1];
		_ASSERTE(g_rchCA);
	}
	
    EnumClasses();

DumpTheSucker:
	if(g_uNCA)
	{
		_ASSERTE(g_rchCA);
		memset(g_rchCA,0,g_uNCA+1);
	}

    if (g_Mode & MODE_GUI)  
    {
        GUIAddItemsToList();
    }
    else
    {
        // Dump the CLR header info if requested.
        if (g_fDumpHeader)
        {
            DumpHeader(g_CORHeader,g_pFile);
            DumpHeaderDetails(g_CORHeader,g_pFile);
        }
        else
            DumpVTables(g_CORHeader,g_pFile);
        if (g_fDumpStats)
            DumpStatistics(g_CORHeader,g_pFile);

        if(g_fDumpClassList) PrintClassList();
        // MetaInfo integration:
        if(g_fDumpMetaInfo) DumpMetaInfo(pszFilename,NULL,g_pFile);

		if(g_fDumpSummary) DumpSummary();

        if (g_fDumpAsmCode)
        {
            g_szNamespace[0] = 0;
            if(g_tkClassToDump) //g_tkClassToDump is set in EnumClasses
            {
                DumpClass(g_tkClassToDump, g_CORHeader->EntryPointToken,g_pFile,7); //7-dump everything at once
                goto CloseNamespace;
            }
            {
                HENUMInternal   hEnumMethod;
                ULONG           ulNumGlobalFunc=0;
                if (SUCCEEDED(g_pImport->EnumGlobalFunctionsInit(&hEnumMethod)))
                {
                    ulNumGlobalFunc = g_pImport->EnumGetCount(&hEnumMethod);
                    g_pImport->EnumClose(&hEnumMethod);
                }
                if(g_fShowProgressBar) CreateProgressBar((LONG) (g_NumClasses + ulNumGlobalFunc));
            }
            ProgressStep();
            g_fAbortDisassembly = FALSE;
            //DumpVtable(g_pFile);
            DumpManifest(g_pFile);

            /* First dump the classes w/o members*/
			if(g_NumClasses)
			{
				printLine(g_pFile,"//");
				printLine(g_pFile,"// ============== CLASS STRUCTURE DECLARATION ==================");
				printLine(g_pFile,"//");
				for (i = 0; i < g_NumClasses; i++)
				{
					if(g_cl_enclosing[i] == mdTypeDefNil) // nested classes are dumped within enclosing ones
					{
						DumpClass(g_cl_list[i], g_CORHeader->EntryPointToken,g_pFile,2); // 2=header+nested classes
					}
				}
				if(strlen(g_szNamespace))
				{
					if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
					sprintf(szString,"%s} // end of namespace %s",g_szAsmCodeIndent, ProperName(g_szNamespace));
					printLine(g_pFile,szString);
					printLine(g_pFile,"");
					g_szNamespace[0] = 0;
				}
				printLine(g_pFile,"");
				printLine(g_pFile,"// =============================================================");
				printLine(g_pFile,"");
			}
            /* Second, dump the global methods */
			printLine(g_pFile,"");
			printLine(g_pFile,"// =============== GLOBAL FIELDS AND METHODS ===================");
			printLine(g_pFile,"");
            DumpGlobalFields();
            DumpGlobalMethods(g_CORHeader->EntryPointToken);
			printLine(g_pFile,"");
			printLine(g_pFile,"// =============================================================");
			printLine(g_pFile,"");
			/* Third, dump the classes with members */
			if(g_NumClasses)
			{
				printLine(g_pFile,"");
				printLine(g_pFile,"// =============== CLASS MEMBERS DECLARATION ===================");
                printLine(g_pFile,"//   note that class flags, 'extends' and 'implements' clauses");
                printLine(g_pFile,"//          are provided here for information only");
				printLine(g_pFile,"");
				for (i = 0; i < g_NumClasses; i++)
				{
					if(g_cl_enclosing[i] == mdTypeDefNil) // nested classes are dumped within enclosing ones
					{
						DumpClass(g_cl_list[i], g_CORHeader->EntryPointToken,g_pFile,7); //7=everything
						if(g_fAbortDisassembly) 
						{
							printError(g_pFile,"");
							printError(g_pFile,RstrA(IDS_E_DASMABORT));
							fSuccess = FALSE; 
							goto CloseFileAndExit; 
						}
					}
				}
				printLine(g_pFile,"");
				printLine(g_pFile,"// =============================================================");
				printLine(g_pFile,"");
			}

			if(g_uNCA)	_ASSERTE(g_rchCA);
			for(i=1; i<= g_uNCA; i++)
			{
				if(g_rchCA[i] == 0) DumpCustomAttribute(TokenFromRid(i,mdtCustomAttribute),g_pFile,true);
			}
            if(g_fAbortDisassembly) 
            {
                printError(g_pFile,"");
                printError(g_pFile,RstrA(IDS_E_DASMABORT));
                fSuccess = FALSE; 
                goto CloseFileAndExit; 
            }
            ProgressStep();

            /* Third, dump GC/EH info about the native methods, using the IPMap */
            IMAGE_DATA_DIRECTORY *pIPMap;
            pIPMap = &g_pPELoader->ntHeaders()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
            DWORD        IPMapSize;
            const BYTE * ipmap;
            IPMapSize  = pIPMap->Size;
            g_pPELoader->getVAforRVA(pIPMap->VirtualAddress, (void **) &ipmap);   

            DumpNativeInfo(ipmap, IPMapSize);

            // If there were strings reference in the IL, they will reference tags that need to be
            // written here.
            if(g_iStringCount)
            {
                for(int i = 0; i < g_iStringCount; i++)
                {
                    char *strTag = g_StringTags[i];
                    // The strings come through with 2 extra characters on them
                    strTag += 2;
                    // They are also quoted with ' instead of "
                    strTag[0] = '\"';
                    strTag[strlen(strTag) - 1] = '\"';

                    char strNum[5];
                    _itoa(i, strNum, 10);
                    sprintf(szString,".data String%s = char*(%s)", strNum, strTag);
                    printLine(g_pFile,szString);
                }
            }
            // If there were "ldptr", dump the .rdata section with labels
            if(g_iPtrCount)
            {
                //first, sort the pointers
                int i,j;
                bool swapped;
                do {
                    swapped = FALSE;

                    for(i = 1; i < g_iPtrCount; i++)
                    {
                        if(g_PtrTags[i-1] > g_PtrTags[i])
                        {
                            j = g_PtrTags[i-1];
                            g_PtrTags[i-1] = g_PtrTags[i];
                            g_PtrTags[i] = j;
                            j = g_PtrSize[i-1];
                            g_PtrSize[i-1] = g_PtrSize[i];
                            g_PtrSize[i] = j;
                            swapped = TRUE;
                        }
                    }
                } while(swapped);

                //second, dump data for each ptr as binarray
                
                IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(g_pPELoader->ntHeaders());
                DWORD fromPtr,toPtr,limPtr;
                for(j = 0; j < g_iPtrCount; j++)
                {
                    BYTE *pb;
                    fromPtr = g_PtrTags[j];
                    for (i=0; i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections; i++,pSecHdr++)
                    {
                        if((fromPtr >= pSecHdr->VirtualAddress)&&
                            (fromPtr < pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize)) break;
                    }
                    if(i == g_pPELoader->ntHeaders()->FileHeader.NumberOfSections)
                    {
                        sprintf(szString,RstrA(IDS_E_ROGUEPTR), fromPtr);
                        printLine(g_pFile,szString);
                        break;
                    }
                    // OK, now we have the section; what about end of BLOB?
                    char* szTls = (strcmp((char*)(pSecHdr->Name),".tls") ? "D_" : "tls T_");
                    if(j == g_iPtrCount-1) toPtr = pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize;
                    else
                    {
                        toPtr = g_PtrTags[j+1];
                        if(toPtr > pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize)
                            toPtr = pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize;
                    }
					if(toPtr - fromPtr > g_PtrSize[j]) toPtr = fromPtr + g_PtrSize[j];
                    limPtr = toPtr; // at limPtr and after, pad with 0
                    if(limPtr > pSecHdr->VirtualAddress+pSecHdr->SizeOfRawData)
                            limPtr = pSecHdr->VirtualAddress+pSecHdr->SizeOfRawData;
                    if(fromPtr >= limPtr)
                    {   // uninitialized data
                        sprintf(szString,"%s.data %s%8.8X = int8[%d]",g_szAsmCodeIndent,szTls,fromPtr,toPtr-fromPtr);
                        printLine(g_pFile,szString);
                    }
                    else
                    {   // initialized data
                        sprintf(szString,"%s.data %s%8.8X = bytearray (",g_szAsmCodeIndent,szTls,fromPtr);
                        printLine(g_pFile,szString);
                        sprintf(szString,"%s                ",g_szAsmCodeIndent);
                        pb =  g_pPELoader->base()
                                +pSecHdr->PointerToRawData 
                                + fromPtr - pSecHdr->VirtualAddress;
                        // now fromPtr is the beginning of the BLOB, and toPtr is [exclusive] end of it
                        // dump the sucker!
                        DumpHexbytes(szString, pb, fromPtr, toPtr, limPtr);
                    }
                }
            }
CloseNamespace:
            if(strlen(g_szNamespace))
            {
                if(g_szAsmCodeIndent[0]) g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                sprintf(szString,"%s} // end of namespace %s",g_szAsmCodeIndent, ProperName(g_szNamespace));
                printLine(g_pFile,szString);
                printLine(g_pFile,"");

            }
            printLine(g_pFile,RstrA(IDS_E_DASMOK));
			fSuccess = TRUE;
        }
		fSuccess = TRUE;
		if(g_pFile) // dump .RES file (if any), if not to console
		{
			WCHAR wzResFileName[2048], *pwc;
			memset(wzResFileName,0,sizeof(wzResFileName));
			WszMultiByteToWideChar(CP_UTF8,0,g_szOutputFile,-1,wzResFileName,2048);
			pwc = wcsrchr(wzResFileName,L'.');
			if(pwc == NULL) pwc = &wzResFileName[wcslen(wzResFileName)];
			wcscpy(pwc,L".res");
			DWORD ret = DumpResourceToFile(wzResFileName);
			switch(ret)
			{
				case 0: szString[0] = 0; break;
				case 1: sprintf(szString,"// WARNING: Created Win32 resource file %ls", wzResFileName); break;
				case 0xEFFFFFFF: sprintf(szString,"// ERROR: Unable to open file %ls", wzResFileName); break;
				case 0xFFFFFFFF: sprintf(szString,"// ERROR: Unable access Win32 resources"); break;
			}
			if(szString[0]) printError(g_pFile,szString);
		}

CloseFileAndExit:
        if(g_pFile)
		{
			fclose(g_pFile);
	        g_pFile = NULL;
		}
        DestroyProgressBar();
    } // end if MODE_GUI - else

exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasm_mi.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "..\tools\metainfo\mdinfo.cpp"
#include "..\tools\metainfo\mdobj.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasm_sz.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>
#include <string.h>
#include <metadata.h>
#include <utilcode.h>
#include "DebugMacros.h"
#include "dasm_sz.h"

unsigned SizeOfValueType(mdToken tk, IMDInternalImport* pImport)
{
	unsigned ret = 0xFFFFFFFF;
	if((TypeFromToken(tk)==mdtTypeDef)&&RidFromToken(tk)&&pImport)
	{
		DWORD dwAttrs;
		mdToken tkExtends;
		pImport->GetTypeDefProps(tk, &dwAttrs, &tkExtends);
		if(!(IsTdInterface(dwAttrs)||IsTdAbstract(dwAttrs)||IsTdImport(dwAttrs)))
		{
			mdToken tkField;
			DWORD dwFieldAttrs;
			unsigned uFieldSize;
			ULONG	ulPack=0, 
					ulSize = 0, 
					ulInstFieldSize = 0;

			if(FAILED(pImport->GetClassPackSize(tk,&ulPack))) ulPack = 0;
			if(FAILED(pImport->GetClassTotalSize(tk,&ulSize))) ulSize = 0;

			if(IsTdExplicitLayout(dwAttrs))
			{
				MD_CLASS_LAYOUT	hLayout;
				if(SUCCEEDED(pImport->GetClassLayoutInit(tk,&hLayout)))
				{
					ULONG ulOffset;
					while(SUCCEEDED(pImport->GetClassLayoutNext(&hLayout,&tkField,&ulOffset)) && RidFromToken(tkField))
					{
						dwFieldAttrs = pImport->GetFieldDefProps(tkField);
						if(!(IsFdStatic(dwFieldAttrs)||IsFdLiteral(dwFieldAttrs)))
						{
							uFieldSize = SizeOfField(tkField,pImport);
							if(uFieldSize == 0xFFFFFFFF) return uFieldSize;
							uFieldSize += ulOffset;
							if(uFieldSize > ulInstFieldSize) ulInstFieldSize = uFieldSize;
						}
					}
				}
			}
			else 
			{
				HENUMInternal   hEnumField;
				unsigned cFieldsMax = 0;
				if (SUCCEEDED(pImport->EnumInit(mdtFieldDef, tk, &hEnumField)))
				{
					if(cFieldsMax = pImport->EnumGetCount(&hEnumField))
					{
					    while(pImport->EnumNext(&hEnumField, &tkField) && RidFromToken(tkField))
						{
							dwFieldAttrs = pImport->GetFieldDefProps(tkField);
							if(!(IsFdStatic(dwFieldAttrs)||IsFdLiteral(dwFieldAttrs)))
							{
								uFieldSize = SizeOfField(tkField,pImport);
								if(uFieldSize == 0xFFFFFFFF) return uFieldSize;
								if(ulPack > 1)
								{
									ULONG ulDelta = ulInstFieldSize % ulPack;
									if(ulDelta) ulInstFieldSize += ulPack - ulDelta;
								}
								ulInstFieldSize += uFieldSize;
							}
						}
					}
					pImport->EnumClose(&hEnumField);
				}
			}
			ret = (ulInstFieldSize > ulSize) ? ulInstFieldSize : ulSize;
			if(ret == 0) ret = 1; // zero-sized value types automatically get 1 byte
		}
	}
	return ret;
}

unsigned SizeOfField(mdToken tk, IMDInternalImport* pImport)
{
	unsigned ret = 0xFFFFFFFF;
	if((TypeFromToken(tk) == mdtFieldDef) && RidFromToken(tk) && pImport)
	{
		PCCOR_SIGNATURE	pSig;
		ULONG		cSig;
	    pSig = pImport->GetSigOfFieldDef(tk, &cSig);
		ret = SizeOfField(&pSig,cSig,pImport);
	}
	return ret;
}

unsigned SizeOfField(PCCOR_SIGNATURE *ppSig, ULONG cSig, IMDInternalImport* pImport)
{
	unsigned ret = 0xFFFFFFFF;
	if(ppSig && *ppSig && cSig && pImport)
	{
        unsigned callConv = CorSigUncompressData(*ppSig);  
        if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
        {
			mdToken  tk;    
			int typ;
			BOOL Reiterate;
			unsigned uElementNumber = 1;
			PCCOR_SIGNATURE pSigOrig = *ppSig;
			PCCOR_SIGNATURE pSigEnd = *ppSig+cSig;

			do {
				Reiterate = FALSE;
				switch(typ = *(*ppSig)++) {    
					case ELEMENT_TYPE_VOID          :   
						return 0;
						
					case ELEMENT_TYPE_I1            :   
					case ELEMENT_TYPE_U1            :   
					case ELEMENT_TYPE_BOOLEAN       :   
						return uElementNumber; 

					case ELEMENT_TYPE_CHAR          :   
					case ELEMENT_TYPE_I2            :   
					case ELEMENT_TYPE_U2            :   
						return (uElementNumber << 1); 

					case ELEMENT_TYPE_I4            :   
					case ELEMENT_TYPE_U4            :   
					case ELEMENT_TYPE_R4            :   
						return (uElementNumber << 2); 
						
					case ELEMENT_TYPE_I8            :   
					case ELEMENT_TYPE_U8            :   
					case ELEMENT_TYPE_R8            :   
						return (uElementNumber << 3); 
						
					//case ELEMENT_TYPE_R             :   
					//	return (uElementNumber * sizeof(float)); 
						
					case ELEMENT_TYPE_OBJECT        :   
					case ELEMENT_TYPE_STRING        :   
					case ELEMENT_TYPE_FNPTR :   
					case ELEMENT_TYPE_CLASS         :   
					case ELEMENT_TYPE_PTR           :   
					case ELEMENT_TYPE_BYREF         :   
					//case ELEMENT_TYPE_VAR        :   
					case ELEMENT_TYPE_U             :   
					case ELEMENT_TYPE_I             :   
						return (uElementNumber * sizeof(void*)); 
						
					case ELEMENT_TYPE_TYPEDBYREF        :   // pair of ptrs
						return (uElementNumber * sizeof(void*)<<1); 

					case ELEMENT_TYPE_VALUETYPE    :
						*ppSig += CorSigUncompressToken(*ppSig, &tk); 
						ret = SizeOfValueType(tk,pImport);
						if(ret != 0xFFFFFFFF) ret *= uElementNumber;
						return ret;

						// Modifiers or depedant types  

					// uncomment when and if this type is supported by the Runtime
					//case ELEMENT_TYPE_VALUEARRAY    :   

					case ELEMENT_TYPE_ARRAY       :   
						ret = SizeOfField(ppSig, cSig-(unsigned)((*ppSig)-pSigOrig), pImport);
						if(ret != 0xFFFFFFFF)
						{
							unsigned rank = CorSigUncompressData(*ppSig);  
							if (rank == 0) ret = 0xFFFFFFFF;
							else 
							{
								int* lowerBounds = (int*) _alloca(sizeof(int)*2*rank);  
								int* sizes       = &lowerBounds[rank];  
								memset(lowerBounds, 0, sizeof(int)*2*rank); 
								
								unsigned numSizes = CorSigUncompressData(*ppSig);  
								_ASSERTE(numSizes <= rank); 
								for(unsigned i =0; i < numSizes; i++)   
									sizes[i] = CorSigUncompressData(*ppSig);   
								
								unsigned numLowBounds = CorSigUncompressData(*ppSig);  
								_ASSERTE(numLowBounds <= rank); 
								for(i = 0; i < numLowBounds; i++)   
									*ppSig+=CorSigUncompressSignedInt(*ppSig,&lowerBounds[i]); 
								
								for(i = 0; i < numSizes; i++)   
								{   
									if (sizes[i]) uElementNumber *= sizes[i];
								}   
								ret *= uElementNumber;  
							}
						}
						return ret;    

					case ELEMENT_TYPE_CMOD_OPT	:
					case ELEMENT_TYPE_CMOD_REQD	:
						*ppSig += CorSigUncompressToken(*ppSig, &tk); 
					case ELEMENT_TYPE_PINNED	:
					case ELEMENT_TYPE_SZARRAY    : // uElementNumber doesn't change
						if(*ppSig < pSigEnd) Reiterate = TRUE;
						break;  

					default:    
					case ELEMENT_TYPE_SENTINEL      :   
					case ELEMENT_TYPE_END           :   
						break;  
				} // end switch
			} while(Reiterate);
		} // end if(CALLCONV_FIELD)
	} // end if(signature && import)
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasm_sz.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _DASM_SZ_H_
#define _DASM_SZ_H_

unsigned SizeOfValueType(mdToken tk, IMDInternalImport* pImport);

unsigned SizeOfField(mdToken tk, IMDInternalImport* pImport);

unsigned SizeOfField(PCCOR_SIGNATURE *ppSig, ULONG cSig, IMDInternalImport* pImport);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dis.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// dis.h
//
#include "formatType.h"

#define MAX_INTERFACES_IMPLEMENTED  256     // unused
#define MAX_CLASSNAME_LENGTH        1024    // single global buffer size
#define MAX_MEMBER_LENGTH           1024    // single global buffer size
#define MAX_SIGNATURE_LENGTH        2048    // single global buffer size
#define DESCR_SIZE                  8       // unused

#define MODE_DUMP_ALL               0
#define MODE_DUMP_CLASS             1
#define MODE_DUMP_CLASS_METHOD      2
#define MODE_DUMP_CLASS_METHOD_SIG  3
#define MODE_GUI                    4

BOOL Disassemble(IMDInternalImport *pImport, BYTE *pCode, void *GUICookie, mdToken FuncToken, ParamDescriptor* pszArgname, ULONG ulArgs);
BOOL Decompile(IMDInternalImport *pImport, BYTE *pCode);
DWORD FourBytesToU4(const BYTE *pBytes);
DWORD TwoBytesToU4(const BYTE *pBytes);
OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen);
bool IsNameToQuote(const char *name);
struct LineCodeDescr
{
	ULONG Line;
	ULONG Column;
	ULONG PC;
	ULONG FileToken;
};
BOOL DumpMethod(mdToken FuncToken, const char *pszClassName, DWORD dwEntryPointToken,void *GUICookie,BOOL DumpBody);
void printLine(void* GUICookie, char* string);
void printError(void* GUICookie, char* string);
BOOL DumpField(mdToken FuncToken, const char *pszClassName,void *GUICookie, BOOL DumpBogy);
BOOL DumpEvent(mdToken FuncToken, const char *pszClassName, DWORD dwClassAttrs, void *GUICookie, BOOL DumpBody);
BOOL DumpProp(mdToken FuncToken, const char *pszClassName, DWORD dwClassAttrs, void *GUICookie, BOOL DumpBody);
void dumpEHInfo(IMDInternalImport *pImport, void *GUICookie);
BOOL DumpClass(mdTypeDef cl, DWORD dwEntryPointToken, void* GUICookie, ULONG WhatToDump);
// WhatToDump: 0-title only; 1-pack,size and custom attrs; 2-everything
BOOL GetClassLayout(mdTypeDef cl, ULONG* pulPackSize, ULONG* pulClassSize);
void DumpCustomAttribute(mdCustomAttribute tkCA, void *GUICookie, bool bWithOwner);
void DumpCustomAttributes(mdToken tkOwner, void *GUICookie);
void DumpByteArray(char* szString, BYTE* pBlob, ULONG ulLen, void* GUICookie);
char* DumpDataPtr(char* buffer, DWORD ptr, DWORD size);

void PrettyPrintMemberRef(char* szString, mdToken tk, IMDInternalImport *pImport, void* GUICookie);
void PrettyPrintMethodDef(char* szString, mdToken tk, IMDInternalImport *pImport, void* GUICookie);
void DumpPermissions(mdToken tkOwner, void* GUICookie);
void DumpHeader(IMAGE_COR20_HEADER *CORHeader, void* GUICookie);
void DumpHeaderDetails(IMAGE_COR20_HEADER *CORHeader, void* GUICookie);
void DumpMetaInfo(char* pszFileName, char* pszObjFileName, void* GUICookie);
void DumpStatistics(IMAGE_COR20_HEADER *CORHeader, void* GUICookie);
BOOL DumpFile(char *pszFilename);
void Cleanup();
void CreateProgressBar(LONG lRange);
BOOL ProgressStep();
void DestroyProgressBar();
char * DumpQString(void* GUICookie, char* szToDump, char* szWhereTo, char* szPrefix, unsigned uMaxLen);
_TCHAR* Rstr(unsigned id);
char* RstrA(unsigned id);
WCHAR* RstrW(unsigned id);
char* RstrANSI(unsigned id);
void DumpVtable(void* GUICookie);
char* DumpUnicodeString(void* GUICookie,char* szString,WCHAR* pszString,ULONG cbString);



//---------------- see DMAN.CPP--------------------------------------------------
struct LocalComTypeDescr
{
	mdExportedType		tkComTypeTok;
	mdTypeDef			tkTypeDef;
	mdToken				tkImplementation;
	WCHAR*				wzName;
	DWORD				dwFlags;
	LocalComTypeDescr()	 { wzName=NULL; };
	~LocalComTypeDescr() { if(wzName) delete wzName; };
};

struct	MTokName
{
	mdFile	tok;
	WCHAR*	name;
	MTokName() { tok = 0; name = NULL; };
	~MTokName() { if(name) delete name; };
};
extern BOOL g_fPrettyPrint;
extern MTokName*	rExeloc;
extern ULONG	nExelocs;	
void DumpImplementation(mdToken tkImplementation, DWORD dwOffset, char* szString, void* GUICookie);
void DumpComType(LocalComTypeDescr* pCTD,char * szString,void* GUICookie);
void DumpManifest(void* GUICookie);
IMetaDataAssemblyImport* GetAssemblyImport(void* GUICookie);
//-------------------------------------------------------------------------------
#define	NEW_TRY_BLOCK	0x80000000
#define PUT_INTO_CODE	0x40000000
#define ERR_OUT_OF_CODE	0x20000000
#define SEH_NEW_PUT_MASK	(NEW_TRY_BLOCK | PUT_INTO_CODE | ERR_OUT_OF_CODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dis.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// dis.cpp
// 
// Disassembler
//
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <utilcode.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "dasmenum.hpp"
#include "dasmgui.h"
#include "formatType.h"
#include "dis.h"
#include "resource.h"
#include "ILFormatter.h"
#include "OutString.h"
#include "utilcode.h" // for CQuickByte

#include "ceeload.h"
#include "DynamicArray.h"
extern PELoader * g_pPELoader;
#include <corsym.h>
#include <corsym_i.c>
extern ISymUnmanagedReader*     g_pSymReader;
extern BOOL     g_fDumpAsmCode;
extern char     g_szAsmCodeIndent[];
extern BOOL     g_fShowBytes;
extern BOOL     g_fShowSource;
extern BOOL     g_fInsertSourceLines;
extern BOOL     g_fTryInCode;
extern BOOL		g_fQuoteAllNames;
extern BOOL		g_fDumpTokens;
extern DynamicArray<char*>  g_StringTags;
extern int                  g_iStringCount;
extern DynamicArray<__int32>   g_PtrTags;       //to keep track of all "ldptr"
extern DynamicArray<DWORD>   g_PtrSize;       //to keep track of all "ldptr"
extern int                     g_iPtrCount;
static BOOL ConvToLiteral(char* retBuff, const WCHAR* str, int cbStr);
extern DWORD                   g_Mode;

#define PADDING 28

#ifdef COMPRESSION_SUPPORTED
extern void *g_pInstructionDecodingTable;
#endif 

extern BOOL                 g_fThisIsInstanceMethod;
extern unsigned				g_uCodePage;
extern HANDLE				hConsoleOut;
extern HANDLE				hConsoleErr;
// globals for source file info
ULONG ulWasFileToken = 0xFFFFFFFF;
GUID guidWasLang={0}, guidWasLangVendor={0},guidWasDoc={0};
WCHAR wzWasFileName[2048];
ULONG ulWasLine = 0;
FILE* pFile=NULL;
BOOL	bIsNewFile = TRUE;
//-----------------------------------
struct LexScope
{
    DWORD               dwStart;
    DWORD               dwEnd;
    ISymUnmanagedScope* pISymScope;
};
//-----------------------------------

// Used for IL pretty printing 
#ifdef _DEBUG
static ILFormatter ilFormatter;
static OutString formatOut;
static OutString line;
#endif

OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch(opcode) {
        case CEE_PREFIX1:
            opcode = OPCODE(pCode[1] + 256);
            if (opcode < 0 || opcode >= CEE_COUNT)
                opcode = CEE_COUNT;
            *pdwLen = 2;
            break;
        case CEE_PREFIXREF:
        case CEE_PREFIX2:
        case CEE_PREFIX3:
        case CEE_PREFIX4:
        case CEE_PREFIX5:
        case CEE_PREFIX6:
        case CEE_PREFIX7:
            *pdwLen = 3;
            return CEE_COUNT;
        }
    return opcode;
}
void printError(void* GUICookie, char* string)
{
	if(g_Mode & MODE_GUI) printLine(GUICookie, string);
	else
	{
		DWORD dw;
		if(GUICookie) printLine(GUICookie, string);
		WriteFile(hConsoleErr,(CONST VOID *)string, strlen(string),&dw,NULL);
		WriteFile(hConsoleErr,(CONST VOID *)"\r\n", 2,&dw,NULL);
	}
}
void printLine(void* GUICookie, char* string) 
{
	char* sz = string;
	if(g_uCodePage != CP_UTF8)
	{
		int L = strlen(string);
		WCHAR* wz = new WCHAR[L+4];
		//WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L+4));
		_ASSERTE(wz);
		memset(wz,0,sizeof(WCHAR)*(L+2));
		L = WszMultiByteToWideChar(CP_UTF8,0,string,-1,wz,L+2);
		if(g_uCodePage == CP_ACP)
		{
			sz = new char[3*L+3];
			//sz = (char*)malloc(3*L+3);
			_ASSERTE(sz);
			memset(sz,0,3*L+3);
			WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,3*L+3,NULL,NULL);
			delete [] wz;
		}
		else if(GUICookie && (!(g_Mode & MODE_GUI)))
		{
			//fwprintf((FILE*)GUICookie,L"%ls\n",wz);
			unsigned endofline = 0x000A000D;
			if(L=wcslen(wz)) fwrite(wz,L*sizeof(WCHAR),1,(FILE*)GUICookie);
			fwrite(&endofline,4,1,(FILE*)GUICookie);
			delete [] wz;
//			free(wz);
			return;
		}
		else sz = (char*)wz;
	}
    if (GUICookie == NULL)
    {
        if (g_Mode & MODE_GUI) 
                MessageBox(NULL,sz,"ERROR",MB_OK|MB_ICONERROR);
        else
		{
			if(g_uCodePage == 0xFFFFFFFF)
			{
				DWORD dw;
				wcscat((WCHAR*)sz,L"\r\n");
				WriteFile(hConsoleOut,(CONST VOID *)sz,wcslen((WCHAR*)sz)*sizeof(WCHAR),&dw,NULL);
				delete [] sz;
				//free(sz);
			}
            else printf("%s\r\n", sz);
		}
    }
    else
    {
        if (g_Mode & MODE_GUI) GUIAddOpcode(sz, GUICookie);
        else fprintf((FILE*)GUICookie,"%s\n",sz);
    }
	if(g_uCodePage == CP_ACP) delete [] sz;
	//if(g_uCodePage == CP_ACP) free(sz);
}
void printANSILine(void* GUICookie, char* string) 
{
	char* sz = string;
	if(g_uCodePage != CP_ACP)
	{
		int L = strlen(string);
		WCHAR* wz = new WCHAR[L+4];
		memset(wz,0,sizeof(WCHAR)*(L+2));
		WszMultiByteToWideChar(CP_ACP,0,string,-1,wz,L+2);
		if(g_uCodePage == CP_UTF8)
		{
			sz = new char[3*L+3];
			memset(sz,0,3*L+3);
			WszWideCharToMultiByte(CP_UTF8,0,wz,-1,sz,3*L+3,NULL,NULL);
			delete [] wz;
		}
		else if(GUICookie && (!(g_Mode & MODE_GUI)))
		{
			//fwprintf((FILE*)GUICookie,L"%ls\n",wz);
			unsigned endofline = 0x000A000D;
			if(L=wcslen(wz)) fwrite(wz,L*sizeof(WCHAR),1,(FILE*)GUICookie);
			fwrite(&endofline,4,1,(FILE*)GUICookie);
			delete [] wz;
			return;
		}
		else sz = (char*)wz;
	}
    if (GUICookie == NULL)
    {
        if (g_Mode & MODE_GUI) 
                MessageBox(NULL,sz,"ERROR",MB_OK|MB_ICONERROR);
        else
		{
			if(g_uCodePage == 0xFFFFFFFF)
			{
				DWORD dw;
				wcscat((WCHAR*)sz,L"\r\n");
				WriteConsoleW(hConsoleOut,(CONST VOID *)sz,wcslen((WCHAR*)sz),&dw,NULL);
				delete [] sz;
			}
            else printf("%s\r\n", sz);
		}
    }
    else
    {
        if (g_Mode & MODE_GUI) GUIAddOpcode(sz, GUICookie);
        else fprintf((FILE*)GUICookie,"%s\n",sz);
    }
	if(g_uCodePage == CP_UTF8) delete [] sz;
}

char * DumpQString(void* GUICookie, char* szToDump, char* szWhereTo, char* szPrefix, unsigned uMaxLen)
{
	unsigned Lwt = (unsigned)strlen(szWhereTo);
	char* szptr = &szWhereTo[Lwt];
	char* p = szToDump;
	unsigned L = (unsigned)strlen(szToDump);
	unsigned l,i;
	unsigned tally=0;
	*szptr++ = '"';

	do 
	{
		l = L;
		if(l > uMaxLen+2) // +2 - to account for leading/trailing doublequotes in szToDump
		{
			l = uMaxLen;
			while((p[l-1] == '\\')&& l) l--;
			if(l == 0) l = (uMaxLen+1) & 0xFFFFFFFE;
		}
		if(tally)
		{
			printLine(GUICookie,szWhereTo);
			szptr = szWhereTo;
			szptr+=sprintf(szptr,"%s+ \"",szPrefix);
		}
		else uMaxLen = uMaxLen - strlen(szPrefix) + Lwt;
		tally++;
		for(i=0; i < l; i++, szptr++, p++)
		{
			switch(*p)
			{
				case '\n':	*szptr++ = '\\'; *szptr = 'n'; break;
				case '\r':	*szptr++ = '\\'; *szptr = 'r'; break;
				case '\t':	*szptr++ = '\\'; *szptr = 't'; break;
				case '\b':	*szptr++ = '\\'; *szptr = 'b'; break;
				case '\f':	*szptr++ = '\\'; *szptr = 'f'; break;
				case '\v':	*szptr++ = '\\'; *szptr = 'v'; break;
				case '\a':	*szptr++ = '\\'; *szptr = 'a'; break;
				case '\?':	*szptr++ = '\\'; *szptr = '?'; break;
				case '\\':	*szptr++ = '\\'; *szptr = '\\'; break;
				case '"':	*szptr++ = '\\'; *szptr = '"'; break;
				default:	*szptr = *p; break;
			}
		}
		*szptr++ = '"';
		*szptr = 0;
		L -= l;
	} while(L);
	return szptr;
}
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* g_ehInfo = NULL;
ULONG   g_ehCount = 0;
/********************************************************************************/
/* used by qsort to sort the g_ehInfo table */
static int __cdecl ehInfoCmp(const void *op1, const void *op2)
{
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* p1 = (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)op1;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* p2 = (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)op2;
    int d;
    d = p1->TryOffset - p2->TryOffset; if(d) return d;
    d = p1->TryLength - p2->TryLength; if(d) return d;
    d = p1->HandlerOffset - p2->HandlerOffset; if(d) return d;
    d = p1->HandlerLength - p2->HandlerLength; if(d) return d;
    return 0;
}

BOOL enumEHInfo(const COR_ILMETHOD_SECT_EH* eh, IMDInternalImport *pImport, DWORD dwCodeSize)
{
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT ehBuff;
    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo;
	BOOL	fTryInCode = FALSE;
    if(g_ehInfo) delete g_ehInfo;
    g_ehInfo = NULL;
    g_ehCount = 0;
    if(eh && (g_ehCount = eh->EHCount()))
    {
        g_ehInfo = new IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT[g_ehCount];
        _ASSERTE(g_ehInfo != NULL);
        for (unsigned i = 0; i < g_ehCount; i++)  
        {   
            ehInfo = eh->EHClause(i, &ehBuff);
            memcpy(&g_ehInfo[i],ehInfo,sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
            _ASSERTE((ehInfo->Flags & SEH_NEW_PUT_MASK) == 0); // we are using 0x80000000 and 0x40000000
        }
		// check if all boundaries are within method code:
		fTryInCode = g_fTryInCode;
        for(i=0; i < g_ehCount; i++)
        {
			if( (g_ehInfo[i].TryOffset >= dwCodeSize) ||
				(g_ehInfo[i].TryOffset + g_ehInfo[i].TryLength >= dwCodeSize)||
				(g_ehInfo[i].HandlerOffset >= dwCodeSize) ||
				(g_ehInfo[i].HandlerOffset + g_ehInfo[i].HandlerLength >= dwCodeSize))
			{
	            g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | ERR_OUT_OF_CODE);
				fTryInCode = FALSE; // if out of code, don't expand
			}
		}
			
        if(fTryInCode)
		{
	        DWORD dwWasTryOffset=0xFFFFFFFF, dwWasTryLength=0xFFFFFFFF, dwLastOffset=0xFFFFFFFF;
			qsort(g_ehInfo, g_ehCount, sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT), ehInfoCmp);
			for(i=0; i < g_ehCount; i++)
			{
				if((g_ehInfo[i].TryOffset != dwWasTryOffset)||(g_ehInfo[i].TryLength != dwWasTryLength))
				{
					g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | NEW_TRY_BLOCK); // insert try in source
					dwLastOffset = g_ehInfo[i].TryOffset + g_ehInfo[i].TryLength;
					dwWasTryOffset = g_ehInfo[i].TryOffset;
					dwWasTryLength = g_ehInfo[i].TryLength;
				}
				if((!(g_ehInfo[i].Flags & COR_ILEXCEPTION_CLAUSE_FILTER))&&(g_ehInfo[i].HandlerOffset == dwLastOffset))
				{
					g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | PUT_INTO_CODE); // insert catch/finally in source
					dwLastOffset += g_ehInfo[i].HandlerLength;
				}
				else
					g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | NEW_TRY_BLOCK); // insert try in source
			}
		}
        else
		{
			for(i=0; i < g_ehCount; i++)
			{
	            g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags | NEW_TRY_BLOCK); // insert try in source
			}
        }
    }
	return fTryInCode;
}

void dumpOneEHInfo(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo, IMDInternalImport *pImport, void *GUICookie)
{
    char    szString[4096];
    char*   szptr = &szString[0];
    if(!ehInfo) return;
    if(ehInfo->Flags & PUT_INTO_CODE) return; // by the time dumpEHInfo is called, this ehInfo is done
    if(ehInfo->Flags & NEW_TRY_BLOCK)
        szptr+=sprintf(szptr,"%s.try IL_%04x to IL_%04x ",g_szAsmCodeIndent,ehInfo->TryOffset,ehInfo->TryOffset+ehInfo->TryLength);
    else
        szptr+=sprintf(szptr,"%s                        ",g_szAsmCodeIndent);

    if (ehInfo->Flags & COR_ILEXCEPTION_CLAUSE_FILTER) 
        szptr+=sprintf(szptr, "filter IL_%04x ",ehInfo->FilterOffset);
    else if (ehInfo->Flags & COR_ILEXCEPTION_CLAUSE_FAULT)
        szptr+=sprintf(szptr, "fault ");    
    else if (ehInfo->Flags & COR_ILEXCEPTION_CLAUSE_FINALLY || IsNilToken(ehInfo->ClassToken))
        szptr+=sprintf(szptr, "finally ");    
    else 
    {  
        CQuickBytes out;
        szptr+=sprintf(szptr, "catch %s ",PrettyPrintClass(&out, ehInfo->ClassToken, pImport));
    }
    szptr+=sprintf(szptr, "handler IL_%04x", 
        ehInfo->HandlerOffset);
    if(ehInfo->HandlerLength != -1)
        szptr+=sprintf(szptr, " to IL_%04x", 
            ehInfo->HandlerOffset+ehInfo->HandlerLength);

    printLine(GUICookie, szString); 
    if(g_fShowBytes)
    {
        BYTE    *pb = (BYTE *)ehInfo;
        int i;
        szptr = &szString[0];
        szptr+=sprintf(szptr,"%s// HEX:",g_szAsmCodeIndent);
        ehInfo->Flags = (CorExceptionFlag)((int)ehInfo->Flags & ~SEH_NEW_PUT_MASK);
        for(i = 0; i < sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT); i++) 
            szptr+=sprintf(szptr," %2.2X",*pb++);
        printLine(GUICookie, szString);
    }
	/*
    if(ehInfo->Flags & ERR_OUT_OF_CODE)
	{
		sprintf(szString,"%s// WARNING: Boundary outside the method code",g_szAsmCodeIndent);
		printLine(GUICookie,szString);
	}
	*/
}   
void dumpEHInfo(IMDInternalImport *pImport, void *GUICookie)
{
    char    szString[4096];

    if(! g_ehCount) return;
    sprintf(szString, "%s// Exception count %d", g_szAsmCodeIndent,g_ehCount);  
    printLine(GUICookie, szString); 

    for (unsigned i = 0; i < g_ehCount; i++)  
    {   
        IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo = &g_ehInfo[i];
        dumpOneEHInfo(ehInfo,pImport,GUICookie);
    }   
}   

static int __cdecl cmpLineCode(const void *p1, const void *p2)
{	int ret = (((LineCodeDescr*)p1)->PC - ((LineCodeDescr*)p2)->PC);
	if(ret==0)
	{
		ret= (((LineCodeDescr*)p1)->Line - ((LineCodeDescr*)p2)->Line);
		if(ret==0) ret= (((LineCodeDescr*)p1)->Column - ((LineCodeDescr*)p2)->Column);
	}
	return ret;
}

static int __cdecl cmpLexScope(const void *p1, const void *p2)
{ 
    LexScope* pls1 = (LexScope*)p1;
    LexScope* pls2 = (LexScope*)p2;
    int d;
    if(d = pls1->dwStart - pls2->dwStart) return d;
    return (pls2->dwEnd - pls1->dwEnd);
}

char* DumpDataPtr(char* buffer, DWORD ptr, DWORD size)
{
    // check if ptr really points to some data in one of sections
    IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(g_pPELoader->ntHeaders());
    DWORD i;
    for (i=0; i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections; i++,pSecHdr++)
    {
        if((ptr >= pSecHdr->VirtualAddress)&&
            (ptr < pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize)) break;
    }
    if(i < g_pPELoader->ntHeaders()->FileHeader.NumberOfSections)
    { // yes, the pointer points to real data
        int j;
        for(j=0; (j < g_iPtrCount)&&(g_PtrTags[j] != (__int32)ptr); j++);
        if(j == g_iPtrCount)
		{
			g_PtrSize[g_iPtrCount] = size;
			g_PtrTags[g_iPtrCount++] = ptr;
		}
		else if(g_PtrSize[j] < size) g_PtrSize[j] = size;
        char* szTls = (strcmp((char*)(pSecHdr->Name),".tls") ? "D_" : "T_");
        buffer+=sprintf(buffer, "%s%8.8X",szTls,ptr);
    } //else print as hex
    else
    {
        buffer+=sprintf(buffer,"0x%08X /* WARNING: rogue pointer! */",ptr);
    }
    return buffer;
}

void DumpLocals(IMDInternalImport *pImport,COR_ILMETHOD_DECODER *pMethod, char* szVarPrefix, void* GUICookie)
{
    if (pMethod->LocalVarSigTok)
    {
        DWORD           cbSigLen;   
        PCCOR_SIGNATURE pComSig;    
        CQuickBytes     qbMemberSig;
        DWORD           dwL;


        pComSig = pImport->GetSigFromToken((mdSignature)(pMethod->LocalVarSigTok), &cbSigLen);   
    
        _ASSERTE(*pComSig == IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
        pComSig++;

        appendStr(&qbMemberSig, g_szAsmCodeIndent);
        appendStr(&qbMemberSig, ".locals ");
        if(g_fDumpTokens)
		{
			char sz[32];
			sprintf(sz,"/*%08X*/ ",pMethod->LocalVarSigTok);
			appendStr(&qbMemberSig,sz);
		}
        if(pMethod->Flags & CorILMethod_InitLocals) appendStr(&qbMemberSig, "init ");
        dwL = qbMemberSig.Size();

        char* pszTailSig = (char *) PrettyPrintSig(pComSig, cbSigLen, 0, &qbMemberSig, pImport,szVarPrefix);
        if(strlen(pszTailSig) < dwL+3) return;

        {
            int i,j,indent = strlen(g_szAsmCodeIndent)+9; // indent+.locals (
            char chAfterComma;
            char *pComma = pszTailSig, *pch;
            while(pComma = strchr(pComma,','))
            {
                for(pch = pszTailSig, i=0, j=0; pch < pComma; pch++)
                {
					if(*pch == '\'') j=1-j;
					else if(j==0)
					{
						if(*pch == '[') i++;
						else if(*pch == ']') i--;
					}
                }
				pComma++; 
				if((i==0)&&(j==0)) // no brackets or all opened/closed
                {
                    chAfterComma = *pComma;
                    *pComma = 0;
                    printLine(GUICookie,pszTailSig);
                    *pComma = chAfterComma;
                    for(i=0; i<indent; i++) pszTailSig[i] = ' ';
                    strcpy(&pszTailSig[indent],pComma);
                    pComma = pszTailSig;
                } 
            }
        }
        printLine(GUICookie, pszTailSig);
	}
}
void LoadScope(ISymUnmanagedScope       *pIScope, 
               DynamicArray<LexScope>   *pdaScope,
               ULONG                    *pulScopes)
{
    ULONG32 dummy;
    ULONG32 ulVars;
    ISymUnmanagedScope**    ppChildScope = new ISymUnmanagedScope*[4096];
    ULONG32              ulChildren;
    unsigned            i;

    pIScope->GetLocalCount(&ulVars);

    if(ulVars)
    {
        pIScope->GetStartOffset(&dummy);
        (*pdaScope)[*pulScopes].dwStart = dummy;
        pIScope->GetEndOffset(&dummy);
        (*pdaScope)[*pulScopes].dwEnd = dummy;
        (*pdaScope)[*pulScopes].pISymScope = pIScope;
		pIScope->AddRef();
        (*pulScopes)++;
    }
    if(SUCCEEDED(pIScope->GetChildren(4096,&ulChildren,ppChildScope)))
    {
        for(i = 0; i < ulChildren; i++) 
        {
            if(ppChildScope[i])	{
				LoadScope(ppChildScope[i],pdaScope,pulScopes);
				ppChildScope[i]->Release();
			}
        }
    }
    delete ppChildScope;

}
//#define SHOW_LEXICAL_SCOPES
void OpenScope(ISymUnmanagedScope               *pIScope, 
               ParamDescriptor                  *pLV,
               ULONG                            ulLocals)
{
    ULONG32 dummy;
    ULONG32 ulVars;
    ISymUnmanagedVariable** pVars;

    pIScope->GetLocalCount(&ulVars);

    ULONG32 ulNameLen;
#ifdef  SHOW_LEXICAL_SCOPES
    for(unsigned jj = 0; jj < ulLocals; jj++) pLV[jj].attr = 0xFFFFFFFF;
#endif
    if(ulVars)
    {
        pVars = new ISymUnmanagedVariable*[ulVars+4];
        memset(pVars,0,sizeof(PVOID)*(ulVars+4));
        pIScope->GetLocals(ulVars+4,&dummy,pVars);

        WCHAR wzName[2048];
        char  szName[2048];
        for(ULONG ilv = 0; ilv < ulVars; ilv++)
        {
            if(pVars[ilv])
            {
                if(SUCCEEDED(pVars[ilv]->GetName(2048,&ulNameLen,wzName)))
                {   
                    // get the local var slot number:
                    pVars[ilv]->GetAddressField1(&dummy);
					memset(szName,0,2048);
					WszWideCharToMultiByte(CP_UTF8,0,wzName,-1,szName,2048,NULL,NULL);
#ifndef  SHOW_LEXICAL_SCOPES
					for(ULONG j=0; j<dummy; j++)
					{
						if(!strcmp(szName,pLV[j].name))
						{
							sprintf(szName,"V_%d",dummy);
							ulNameLen = strlen(szName);
							break;
						}
					}
#endif
                    delete pLV[dummy].name;
					ulNameLen = strlen(szName)+1;
                    if(pLV[dummy].name = new char[ulNameLen])
                        strcpy(pLV[dummy].name,szName);
                }
                pLV[dummy].attr = dummy;
				pVars[ilv]->Release();
            }
        }
        delete pVars;
    }
}

char* DumpUnicodeString(void* GUICookie,char* szString,WCHAR* pszString,ULONG cbString)
{
    unsigned     i,L;
	char*	szStr=NULL, *szRet;

	// first, check for embedded zeros:
	for(i=0; i < cbString; i++)
	{
		if(pszString[i] == 0) goto DumpAsByteArray;
	}

	szStr = new char[cbString*3 + 5];
	memset(szStr,0,cbString*3 + 5);

	WszWideCharToMultiByte(CP_UTF8,0,pszString,cbString,&szStr[0],cbString*3,NULL,NULL);
	L = (unsigned)strlen(szStr);

	szStr[L] = 0;
	for(i=0; i < L; i++) 
	{ 
		if((!isprint(((BYTE)(szStr[i]))))&&(szStr[i]!='\t')&&(szStr[i]!='\n')&&(szStr[i]!='\r')) break; 
	}

	if(i == L)
	{
		szRet = DumpQString(GUICookie,szStr,szString,g_szAsmCodeIndent, 50);
	}
	else
	{
DumpAsByteArray:
        strcat(szString,"bytearray (");
        DumpByteArray(szString,(BYTE*)pszString,cbString*sizeof(WCHAR),GUICookie);
		szRet = &szString[strlen(szString)];
	}
	if(szStr) delete [] szStr;
	return szRet;
}

BOOL Disassemble(IMDInternalImport *pImport, BYTE *ILHeader, void *GUICookie, mdToken FuncToken, ParamDescriptor* pszArgname, ULONG ulArgs)
{
    DWORD      PC;
    BOOL    fNeedNewLine = FALSE;
    char    szString[4096];
    char*   szptr;
    BYTE*   pCode; 
	BOOL	fTryInCode;

    COR_ILMETHOD_DECODER method((COR_ILMETHOD*) ILHeader);

#ifdef COMPRESSION_SUPPORTED
    if (g_pInstructionDecodingTable != 0)
    {
        HRESULT hr = InstructionDecoder::DecompressMethod(
            g_pInstructionDecodingTable,
            method.Code, method.CodeSize, &pCode);

        if (FAILED(hr))
        {
            printLine(GUICookie,RstrA(IDS_E_DECOMPRESS));
            return FALSE;
        }

        printLine(GUICookie,RstrA(IDS_E_COMPRESSED));
    }
    else
#endif
    {
        pCode = const_cast<BYTE*>(method.Code);
    }

    sprintf(szString, RstrA(IDS_E_CODESIZE),g_szAsmCodeIndent, method.CodeSize, method.CodeSize);
    printLine(GUICookie, szString);

    if(method.CodeSize == 0) return TRUE;

    sprintf(szString, "%s.maxstack  %d",g_szAsmCodeIndent, method.MaxStack);
    printLine(GUICookie, szString);

    //------------ Source lines display ---------------------------------
    ULONG32 ulLines =0;
    LineCodeDescr* LineCode = NULL;
    BOOL fShowSource = FALSE;
    BOOL fInsertSourceLines = FALSE;
    ULONG nextPC = 0;
    LineCodeDescr* pLCD = NULL;
    ParamDescriptor* pszLVname = NULL;
    ULONG ulVars=0;
    char szVarPrefix[16];
    // scope handling:
    DynamicArray<LexScope>          daScope;
    ULONG                           ulScopes=0;
    ISymUnmanagedScope*             pRootScope = NULL;
    ISymUnmanagedMethod*			pSymMethod = NULL;
	char szFileName[2048];
	ISymUnmanagedDocument*			pMethodDoc[2] = {NULL,NULL};
	ULONG32							ulMethodLine[2];
	ULONG32							ulMethodCol[2];
	BOOL							fHasRangeInfo = FALSE;

    strcpy(szVarPrefix,"V0");
    if(g_pSymReader)
    {
        g_pSymReader->GetMethod(FuncToken,&pSymMethod);
        if(g_fShowSource || g_fInsertSourceLines)
        {
            if(pSymMethod)
			{
				unsigned ulActualLines=0; // VS compilers produce "Hidden" line numbers, don't count them
				HRESULT hrr;
				hrr=pSymMethod->GetSourceStartEnd(pMethodDoc,ulMethodLine,ulMethodCol,&fHasRangeInfo);
				pSymMethod->GetSequencePointCount(&ulLines);
				LineCode = new LineCodeDescr[ulLines+2];
				if(LineCode)
				{
					pLCD = &LineCode[0];
					if(fHasRangeInfo)
					{
						//printLine(GUICookie,"// Has source range info");
						pLCD->Line = ulMethodLine[0];
						pLCD->Column = ulMethodCol[0];
						pLCD->PC = 0;
						pLCD->FileToken = (ULONG)pMethodDoc[0];
						ulActualLines++;
						pLCD++;
					}
					if(ulLines)
					{
						ULONG32 *offsets=new ULONG32[ulLines], *lines=new ULONG32[ulLines], *columns=new ULONG32[ulLines];
						ISymUnmanagedDocument** docs = (ISymUnmanagedDocument**)(new PVOID[ulLines]);
						ULONG32 actualCount;
						pSymMethod->GetSequencePoints(ulLines,&actualCount, offsets,docs,lines,columns, NULL, NULL);
						for(ULONG i = 0; i < ulLines; i++)
						{
							if(lines[i] < 0xFEEFED)
							{
								pLCD->Line = lines[i];
								pLCD->Column = columns[i];
								pLCD->PC = offsets[i];
								pLCD->FileToken = (ULONG)docs[i];
								ulActualLines++;
								pLCD++;
							}
						}
						delete offsets;
						delete lines;
						delete columns;
						delete docs;
					} // end if(ulLines)
					if(fHasRangeInfo)
					{
						pLCD->Line = ulMethodLine[1];
						pLCD->Column = ulMethodCol[1];
						pLCD->PC = method.CodeSize;
						pLCD->FileToken = (ULONG)pMethodDoc[1];
						ulActualLines++;
						pLCD++;
					}

					ulLines = ulActualLines;
					qsort(LineCode,ulLines,sizeof(LineCodeDescr),cmpLineCode);
					fShowSource = g_fShowSource;
					fInsertSourceLines = g_fInsertSourceLines;
					pLCD = &LineCode[0];
				} // end if(LineCode)
			} //end if (pSymMethod)
        }//end if(g_fShowSource)
        if (method.LocalVarSigTok)
        {
            // first, get the real number of local vars from signature
            DWORD           cbSigLen;   
            PCCOR_SIGNATURE pComSig;
            if((TypeFromToken(method.LocalVarSigTok) != mdtSignature) ||
				(!pImport->IsValidToken(method.LocalVarSigTok)) || (RidFromToken(method.LocalVarSigTok)==0))
			{
				sprintf(szString,RstrA(IDS_E_BOGUSLVSIG),method.LocalVarSigTok);
				printLine(GUICookie,szString);
				return FALSE;
			}
            pComSig = pImport->GetSigFromToken((mdSignature)method.LocalVarSigTok, &cbSigLen);   
            _ASSERTE(*pComSig == IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
            pComSig++;

            ULONG ulVarsInSig = CorSigUncompressData(pComSig);
            if(pSymMethod)  pSymMethod->GetRootScope(&pRootScope);
            else pRootScope = NULL;

            if(pRootScope)
            {
                ulVars = ulVarsInSig;
            }
            else ulVars = 0;
            if(ulVars)
            {
	            ULONG ilvs;
                pszLVname = new ParamDescriptor[ulVars];
                memset(pszLVname,0,ulVars*sizeof(ParamDescriptor));
                for(ilvs = 0; ilvs < ulVars; ilvs++)
                {
                    pszLVname[ilvs].name = new char[10];
                    sprintf(pszLVname[ilvs].name,"V_%d",ilvs);
                    pszLVname[ilvs].attr = ilvs;
                }
                LoadScope(pRootScope,&daScope,&ulScopes);
                qsort(&daScope[0],ulScopes,sizeof(LexScope),cmpLexScope);
                OpenScope(pRootScope,pszLVname,ulVars);
                sprintf(szVarPrefix,"@%d0",pszLVname);
#ifndef SHOW_LEXICAL_SCOPES
                for(unsigned jjj = 0; jjj < ulScopes; jjj++)
				{
					OpenScope(daScope[jjj].pISymScope,pszLVname,ulVars);
					daScope[jjj].pISymScope->Release();
				}
                ulScopes = 0;
#endif
            } //end if(ulLVScount)
			if(pRootScope) pRootScope->Release();
        } //end if (method.LocalVarSigTok)
    } //end if(g_pDebugImport)
    //-------------------------------------------------------------------
    DumpLocals(pImport,&method, szVarPrefix, GUICookie);

#ifdef _DEBUG
	const BYTE* curFormat = pCode;
	if (g_fPrettyPrint)  {
		extern IMetaDataImport*     g_pPubImport;
		ilFormatter.init(g_pPubImport, method.Code, &method.Code[method.CodeSize], method.MaxStack, method.EH);
	}
#endif

    PC = 0;
    fTryInCode = enumEHInfo(method.EH, pImport, method.CodeSize);
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfoToPutNext = NULL;
	if(g_Mode & MODE_GUI)
	{ // in GUI, reset everything for each method
		ulWasFileToken = 0xFFFFFFFF;
		memset(&guidWasLang,0,sizeof(GUID)); 
		memset(&guidWasLangVendor,0,sizeof(GUID)); 
		memset(&guidWasDoc,0,sizeof(GUID)); 
		memset(wzWasFileName,0,sizeof(wzWasFileName));
		ulWasLine = 0;
	}
    while (PC < method.CodeSize)
    {
        DWORD   Len;
        DWORD   i,ii;
        OPCODE  instr;
        char sz[1024];

        instr = DecodeOpcode(&pCode[PC], &Len);
        if (instr == CEE_COUNT)
        {
            sprintf(szString,RstrA(IDS_E_INSTRDECOD), pCode[PC],PC,PC);
            printLine(GUICookie, szString);
            /*
            while (PC < method.CodeSize)
            {
                printf("%02x\n", pCode[PC]);
                PC++;
            }
            */
            return FALSE;
        }

        if (fNeedNewLine)
        {
            fNeedNewLine = FALSE;
            if (!(g_Mode & MODE_GUI)) printLine(GUICookie,"");
        }

        if(fShowSource || fInsertSourceLines)
		{
			while(PC == pLCD->PC)
			{
				bIsNewFile = FALSE;
				if((pLCD->FileToken != ulWasFileToken) || (pLCD->Line < ulWasLine))
				{
					WCHAR wzFileName[2048];
					ULONG32 k;
					GUID guidLang={0},guidLangVendor={0},guidDoc={0};
					try {
						if(pLCD->FileToken != ulWasFileToken)
						{
							((ISymUnmanagedDocument*)(pLCD->FileToken))->GetLanguage(&guidLang);
							((ISymUnmanagedDocument*)(pLCD->FileToken))->GetLanguageVendor(&guidLangVendor);
							((ISymUnmanagedDocument*)(pLCD->FileToken))->GetDocumentType(&guidDoc);
							if(memcmp(&guidLang,&guidWasLang,sizeof(GUID))
								||memcmp(&guidLangVendor,&guidWasLangVendor,sizeof(GUID))
								||memcmp(&guidDoc,&guidWasDoc,sizeof(GUID)))
							{
								GuidToLPWSTR(guidLang,wzFileName,64);
								GuidToLPWSTR(guidLangVendor,&wzFileName[128],64);
								GuidToLPWSTR(guidDoc,&wzFileName[256],64);
								sprintf(szString,"%s.language '%ls', '%ls', '%ls'", g_szAsmCodeIndent,
									wzFileName,&wzFileName[128],&wzFileName[256]);
								printLine(GUICookie,szString);
								memcpy(&guidWasLang,&guidLang,sizeof(GUID));
								memcpy(&guidWasLangVendor,&guidLangVendor,sizeof(GUID));
								memcpy(&guidWasDoc,&guidDoc,sizeof(GUID));
							}
							/*
							BOOL fHasEmbeddedSource=FALSE;
							((ISymUnmanagedDocument*)(pLCD->FileToken))->HasEmbeddedSource(&fHasEmbeddedSource);
							sprintf(szString,"%s// PDB has %sembedded source",g_szAsmCodeIndent,
								fHasEmbeddedSource ? "" : "no ");
							printLine(GUICookie,szString);
							*/
						}
						((ISymUnmanagedDocument*)(pLCD->FileToken))->GetURL(2048,&k,wzFileName);
						ulWasFileToken = pLCD->FileToken;
					} catch(...) {
						sprintf(szString,"Error reopening the file with FileToken 0x%08X",pLCD->FileToken);
						printLine(GUICookie, szString);
					}
					bIsNewFile = (wcscmp(wzFileName,wzWasFileName)!=0);
					if(bIsNewFile||(pLCD->Line < ulWasLine))
					{
						wcscpy(wzWasFileName,wzFileName);
						memset(szFileName,0,2048);
						WszWideCharToMultiByte(CP_UTF8,0,wzFileName,-1,szFileName,2048,NULL,NULL);
						if(fShowSource)
						{
							if(pFile) fclose(pFile);
							pFile = fopen(szFileName,"rt");
							if(pFile == NULL)
							{
								char* pch = strrchr(szFileName,'\\');
								if(pch == NULL) pch = strrchr(szFileName,':');
								if(pch) pFile = fopen(pch+1,"rt");
							}
							if(bIsNewFile)
							{
								sprintf(szString,"// Source File '%s' %s",szFileName,(pFile ? "" : "not found"));
								printLine(GUICookie, szString);
							}
							ulWasLine = 0;
						}
					}
				}
				if(fInsertSourceLines)
				{
					if(bIsNewFile)
					{
						char* pszFN = ProperName(szFileName);
						sprintf(szString,(*pszFN == '\'' ? "%s.line %d:%d %s" : "%s.line %d:%d '%s'"),
							g_szAsmCodeIndent,pLCD->Line,pLCD->Column,pszFN);
					}
					else
						sprintf(szString,"%s.line %d:%d",g_szAsmCodeIndent,pLCD->Line,pLCD->Column);

					printLine(GUICookie,szString);
				}

				ULONG k= pLCD->Line;
				if(pFile)
				{
					for(k = ulWasLine; k < pLCD->Line; k++)
					{
						if(NULL==fgets(sz,1024,pFile)) { k--; break;}
						if((ulWasLine != 0)||(k == (pLCD->Line-1)))
						{
							while((sz[strlen(sz)-1]=='\n') || (sz[strlen(sz)-1]=='\r')) sz[strlen(sz)-1]=0;
							sprintf(szString,"//%6.6d: %s",k+1,sz);
							printANSILine(GUICookie, szString);
						}
					}
					ulWasLine = k;
				}
				if(pLCD < &LineCode[ulLines-1]) pLCD++;
				else { fShowSource = FALSE; break; }
			}
		}
        if(fTryInCode)
        {
            dumpOneEHInfo(ehInfoToPutNext,pImport,GUICookie); //doesn't do anything if ehInfoToPutNext == NULL
            ehInfoToPutNext = NULL;

			for(ii = g_ehCount; ii > 0; ii--)
			{
				i = g_ehCount - ii;
				DWORD	theEnd = g_ehInfo[i].HandlerOffset+g_ehInfo[i].HandlerLength;
				if(g_ehInfo[i].Flags & PUT_INTO_CODE)
                { 
	                if(PC == theEnd) 
					{
                        // reduce indent, close }
                        g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                        sprintf(szString,"%s}  // end handler",g_szAsmCodeIndent);
                        printLine(GUICookie,szString);
                        if(g_fShowBytes)
                        {
                            BYTE    *pb = (BYTE *)&g_ehInfo[i];
							char*	psz;
                            int j;
                            CorExceptionFlag Flg = g_ehInfo[i].Flags;
                            sprintf(szString,"%s// HEX:",g_szAsmCodeIndent);
                            g_ehInfo[i].Flags = (CorExceptionFlag)((int)g_ehInfo[i].Flags & ~SEH_NEW_PUT_MASK);
							psz = &szString[strlen(szString)];
                            for(j = 0; j < sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT); j++) 
                                psz += sprintf(psz," %2.2X",*pb++);
                            printLine(GUICookie, szString);
                            g_ehInfo[i].Flags = Flg;
                        }
						g_ehInfo[i].TryOffset = 0xFF000000;
						g_ehInfo[i].HandlerOffset = 0xFF000000;
                    }
				}
				else
				{
					DWORD theTryEnd = g_ehInfo[i].TryOffset+g_ehInfo[i].TryLength;
					if(theTryEnd > theEnd) theEnd = theTryEnd; // try block after the handler
					if(PC == theEnd) ehInfoToPutNext = &g_ehInfo[i];
				}
			}

            for(i = 0; i < g_ehCount; i++)
            {
                if(g_ehInfo[i].Flags & PUT_INTO_CODE)
                {
                    if(g_ehInfo[i].Flags & NEW_TRY_BLOCK)
                    {
                        if(PC == g_ehInfo[i].TryOffset+g_ehInfo[i].TryLength)
                        {
                            // reduce indent, close }
                            g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                            sprintf(szString,"%s}  // end .try",g_szAsmCodeIndent);
                            printLine(GUICookie,szString);
                        }
                        if(PC == g_ehInfo[i].TryOffset)
                        {
                            // Put try, {, increase indent
                            sprintf(szString,"%s.try",g_szAsmCodeIndent);
                            printLine(GUICookie,szString);
                            sprintf(szString,"%s{",g_szAsmCodeIndent);
                            printLine(GUICookie,szString);
                            strcat(g_szAsmCodeIndent,"  ");
                        }
                    }
                    if(PC == g_ehInfo[i].HandlerOffset) 
                    { 
                        // Dump catch or finally clause, {, increase indent
                        if (g_ehInfo[i].Flags & COR_ILEXCEPTION_CLAUSE_FAULT)
                            sprintf(szString, "%sfault", g_szAsmCodeIndent);    
                        else if (g_ehInfo[i].Flags & COR_ILEXCEPTION_CLAUSE_FINALLY || IsNilToken(g_ehInfo[i].ClassToken))
                            sprintf(szString, "%sfinally", g_szAsmCodeIndent);    
                        else 
                        {  
							CQuickBytes out;
							sprintf(szString, "%scatch %s ",g_szAsmCodeIndent,
								PrettyPrintClass(&out, g_ehInfo[i].ClassToken, pImport));
                        }
                        printLine(GUICookie,szString);
                        sprintf(szString,"%s{",g_szAsmCodeIndent);
                        printLine(GUICookie,szString);
                        strcat(g_szAsmCodeIndent,"  ");
                    }
                } // end if(g_ehInfo[i].Flags & PUT_INTO_CODE)
            } // end for(i<g_ehCount)
        } // end if(fTryInCode)
        //----------------- lexical scope handling -----------------------------
        if(ulScopes) // non-zero only if local var info present
        {
            for(i=0; i < ulScopes; i++)
            {
                if((PC == daScope[i].dwEnd)&&(daScope[i].pISymScope != pRootScope))
                {
                    g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                    sprintf(szString,"%s}",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                }
                if((PC == daScope[i].dwStart)&&(daScope[i].pISymScope != pRootScope))
                {
                    sprintf(szString,"%s{",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                    strcat(g_szAsmCodeIndent,"  ");
                    OpenScope(daScope[i].pISymScope,pszLVname,ulVars);
                    DumpLocals(pImport,&method, szVarPrefix, GUICookie);
                }
            }
        }

#ifdef _DEBUG
		if (g_fPrettyPrint && &pCode[PC] >= curFormat) {
			formatOut.clear();
			curFormat = ilFormatter.formatStatement(curFormat, &formatOut);
			char* ptr = const_cast<char*>(formatOut.val());
			do {
				char* newLine = strchr(ptr, '\n');
				if (newLine)
					*newLine++ = 0;
				line.clear();
				line << "// **** " << ptr;
				printLine(GUICookie, const_cast<char*>(line.val()));
				ptr = newLine;
			} while (ptr != 0 && *ptr != 0);
		}
#endif

        szptr = &szString[0];
        szptr+=sprintf(szptr,"%sIL_%04x:  ",g_szAsmCodeIndent, PC);
        if(g_fShowBytes)
        {
            szptr+=sprintf(szptr,"/* ");
            for(i=0; i<Len; i++) szptr+=sprintf(szptr,"%2.2X",pCode[PC+i]);
            for(; i<2; i++) szptr+=sprintf(szptr,"  "); // 2 is max.opcode length
            szptr+=sprintf(szptr," | ");
        }

        PC += Len;
        Len = 0;

        char *pszInstrName = OpcodeInfo[instr].pszName;

        switch (OpcodeInfo[instr].Type)
        {
            DWORD tk;
            DWORD tkType;
            default:
            {
                szptr+=sprintf(szptr,RstrA(IDS_E_INSTRTYPE),
                    OpcodeInfo[instr].Type,instr);
                printLine(GUICookie, szString);
                return FALSE;
            }

#define PadTheString    { if(Len < 16) szptr+=sprintf(szptr, "%-*s", (16-Len), ""); \
            szptr+=sprintf(szptr," */ "); }

            case InlineNone:
            {
                if(g_fShowBytes)
                    PadTheString;
 
                szptr+=sprintf(szptr, pszInstrName);

                switch (instr)
                {
                    case CEE_RET:
                    case CEE_THROW:
                        fNeedNewLine = TRUE;
                        break;
                }

                break;
            }

            case ShortInlineI:
            case ShortInlineVar:
            {
                unsigned char  ch= pCode[PC];
                short sh = OpcodeInfo[instr].Type==ShortInlineVar ? ch : (ch > 127 ? -(256-ch) : ch);
                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X ", ch);
                    Len += 3;
                    PadTheString;
                }
                switch(instr)
                {
                    case CEE_LDARG_S:
                    case CEE_LDARGA_S:
                    case CEE_STARG_S:
                        if(g_fThisIsInstanceMethod &&(ch==0))
                        { // instance methods have arg0="this", do not label it!
                            szptr+=sprintf(szptr, "%-10s %d", pszInstrName, ch);
                        }
                        else
                        {
                            if(pszArgname) 
                            {
                                unsigned char ch1 = g_fThisIsInstanceMethod ? ch-1 : ch;
                                if(ch1 < ulArgs)
                                    szptr+=sprintf(szptr,"%-10s %s",pszInstrName,
                                                    ProperName(pszArgname[ch1].name));
                                else
                                    szptr+=sprintf(szptr,RstrA(IDS_E_ARGINDEX) ,pszInstrName, ch,ulArgs);
                            }
                            else szptr+=sprintf(szptr, "%-10s A_%d",pszInstrName, ch);
                        }
                        break;

                    case CEE_LDLOC_S:
                    case CEE_LDLOCA_S:
                    case CEE_STLOC_S:
                        if(pszLVname)
                        {
                            if(ch < ulVars) szptr+=sprintf(szptr, "%-10s %s", pszInstrName, 
								ProperName(pszLVname[ch].name));
                            else 
                                szptr+=sprintf(szptr, RstrA(IDS_E_LVINDEX),pszInstrName, ch, ulVars);
                        }
                        else szptr+=sprintf(szptr, "%-10s V_%d",pszInstrName, ch);
                        break;

                    default:
                        szptr+=sprintf(szptr, "%-10s %d", pszInstrName,sh); 
                }

                PC++;
                break;
            }

            case InlineVar:
            {
                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X ", pCode[PC], pCode[PC+1]);
                    Len += 5;
                    PadTheString;
                }

                USHORT v = pCode[PC] + (pCode[PC+1] << 8);
                long l = OpcodeInfo[instr].Type==InlineVar ? v : (v > 0x7FFF ? -(0x10000 - v) : v);

                switch(instr)
                {
                    case CEE_LDARGA:
                    case CEE_LDARG:
                    case CEE_STARG:
                        if(g_fThisIsInstanceMethod &&(v==0))
                        { // instance methods have arg0="this", do not label it!
                            szptr+=sprintf(szptr, "%-10s %d", pszInstrName, v);
                        }
                        else
                        {
                            if(pszArgname) 
                            {
                                USHORT v1 = g_fThisIsInstanceMethod ? v-1 : v;
                                if(v1 < ulArgs)
                                    szptr+=sprintf(szptr,"%-10s %s",pszInstrName,
                                                    ProperName(pszArgname[v1].name));
                                else
                                    szptr+=sprintf(szptr, RstrA(IDS_E_ARGINDEX),pszInstrName, v,ulArgs);
                            }
                            else szptr+=sprintf(szptr, "%-10s A_%d",pszInstrName, v);
                        }
                        break;

                    case CEE_LDLOCA:
                    case CEE_LDLOC:
                    case CEE_STLOC:
                        if(pszLVname)
                        {
                            if(v < ulVars)  szptr+=sprintf(szptr, "%-10s %s", pszInstrName, 
								ProperName(pszLVname[v].name));
                            else 
                                szptr+=sprintf(szptr, RstrA(IDS_E_LVINDEX),pszInstrName, v,ulVars);
                        }
                        else szptr+=sprintf(szptr, "%-10s V_%d",pszInstrName, v);
                        break;

                    default:
                        szptr+=sprintf(szptr, "%-10s %d", pszInstrName, l);
                        break;
                }
                PC += 2;
                break;
            }

            case InlineI:
            case InlineRVA:
            {
                DWORD v = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                    Len += 9;
                    PadTheString;
                }
				szptr+=sprintf(szptr, "%-10s 0x%x", pszInstrName, v);
                PC += 4;
                break;
            }

            case InlineI8:
            {
                __int64 v = (__int64) pCode[PC] + 
                            (((__int64) pCode[PC+1]) << 8) +
                            (((__int64) pCode[PC+2]) << 16) +
                            (((__int64) pCode[PC+3]) << 24) +
                            (((__int64) pCode[PC+4]) << 32) +
                            (((__int64) pCode[PC+5]) << 40) +
                            (((__int64) pCode[PC+6]) << 48) +
                            (((__int64) pCode[PC+7]) << 56);
                  
                if(g_fShowBytes)
                {          
                    szptr+=sprintf(szptr,
                        "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X", 
                        pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3],
                        pCode[PC+4], pCode[PC+5], pCode[PC+6], pCode[PC+7]);
                    Len += 8*2;
                    PadTheString;
                }
                
                szptr+=sprintf(szptr, "%-10s 0x%I64x", pszInstrName, v);
                PC += 8;
                break;
            }

            case ShortInlineR:
            {
                union
                {
                    BYTE  b[4];
                    float f;
                } u;
                u.b[0] = pCode[PC];
                u.b[1] = pCode[PC+1];
                u.b[2] = pCode[PC+2];
                u.b[3] = pCode[PC+3];

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                    Len += 9;
                    PadTheString;
                }
                
                char szf[32];
				if(u.f==0.0)
					strcpy(szf,(u.b[3]==0)? "0.0" : "-0.0");
				else  
					_gcvt((double)u.f, 8, szf);
                float df = (float)atof(szf);
                if((df == u.f)&&(strchr(szf,'#') == NULL))
                    szptr+=sprintf(szptr, "%-10s %s", pszInstrName, szf);
                else
                    szptr+=sprintf(szptr, "%-10s (%2.2X %2.2X %2.2X %2.2X)", 
                        pszInstrName, pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                PC += 4;
                break;
            }

            case InlineR:
            {
                union
                {
                    BYTE    b[8];
                    double  d;
                } u;
                u.b[0] = pCode[PC];
                u.b[1] = pCode[PC+1];
                u.b[2] = pCode[PC+2];
                u.b[3] = pCode[PC+3];
                u.b[4] = pCode[PC+4];
                u.b[5] = pCode[PC+5];
                u.b[6] = pCode[PC+6];
                u.b[7] = pCode[PC+7];

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr,
                        "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X", 
                        pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3],
                        pCode[PC+4], pCode[PC+5], pCode[PC+6], pCode[PC+7]);
                    Len += 8*2;
                    PadTheString;
                }
                char szf[32],*pch;
				if(u.d==0.0)
					strcpy(szf,(u.b[7]==0)? "0.0" : "-0.0");
				else  
					_gcvt(u.d, 17, szf);
                double df = strtod(szf, &pch); //atof(szf);
                if((df == u.d)&&(strchr(szf,'#') == NULL))
                    szptr+=sprintf(szptr, "%-10s %s", pszInstrName, szf);
                else
                    szptr+=sprintf(szptr, "%-10s (%2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X)", 
                        pszInstrName, pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3],
                        pCode[PC+4], pCode[PC+5], pCode[PC+6], pCode[PC+7]);
                PC += 8;
                break;
            }

            case ShortInlineBrTarget:
            {
                char offset = (char) pCode[PC];
                long dest = (PC + 1) + (long) offset;

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X ", pCode[PC]);
                    Len += 3;
                    PadTheString;
                }
				PC++;
				szptr+=sprintf(szptr, "%-10s IL_%04x", pszInstrName, dest);

                fNeedNewLine = TRUE;
                break;
            }

            case InlineBrTarget:
            {
                long offset = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                long dest = (PC + 4) + (long) offset;

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                    Len += 9;
                    PadTheString;
                }
				PC += 4;
				szptr+=sprintf(szptr, "%-10s IL_%04x", pszInstrName, dest);

                fNeedNewLine = TRUE;
                break;
            }

            case InlineSwitch:
            {
                DWORD cases = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
        
                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                    Len += 9;
                    PadTheString;
                }
                if(cases) szptr+=sprintf(szptr, "%-10s ( ", pszInstrName);
				else szptr+=sprintf(szptr, "%-10s ( )", pszInstrName);
                printLine(GUICookie, szString);
                PC += 4;
                DWORD PC_nextInstr = PC + 4 * cases;
                for (i = 0; i < cases; i++)
                {
                    long offset = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                    long dest = PC_nextInstr + (long) offset;
                    szptr = &szString[0];
                    szptr+=sprintf(szptr,"%s          ",g_szAsmCodeIndent); //indent+label
                    if(g_fShowBytes)
                    {
                        szptr+=sprintf(szptr,"/*      | %2.2X%2.2X%2.2X%2.2X ",
                            pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                        Len = 9;
                        PadTheString;
                    }

                    szptr+=sprintf(szptr,"            IL_%04x%s", dest,(i == cases-1)? ")" : ",");
                    PC += 4;
                    printLine(GUICookie, szString);
                }
                continue;
            }

            case InlinePhi:
            {
                DWORD cases = pCode[PC];
                unsigned short *pus;
                DWORD i;

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X", cases);
                    Len += 2;
                    for(i=0; i < cases*2; i++)
                    {
                        szptr+=sprintf(szptr, "%2.2X", pCode[PC+1+i]);
                        Len += 2;
                    }
                    PadTheString;
                }

                szptr+=sprintf(szptr, "%-10s", pszInstrName);
                for(i=0, pus=(unsigned short *)(&pCode[PC+1]); i < cases; i++,pus++)
                {
                    szptr+=sprintf(szptr," %d",*pus);
                }
                PC += 2 * cases + 1;
                break;
            }

            case InlineString:
            case InlineField:
            case InlineType:
            case InlineTok:
            case InlineMethod:
            {
                tk = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                tkType = TypeFromToken(tk);

                // Backwards compatible ldstr instruction.
                if (instr == CEE_LDSTR && TypeFromToken(tk) != mdtString) 
                {
                    WCHAR *v1 = L"";

                    if(g_fShowBytes)
                    {
                        szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", 
                            pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                        Len += 9;
                        PadTheString;
                    }

                    if(!g_pPELoader->getVAforRVA(tk, (void**) &v1))
                    {
                        char szStr[256];
                        sprintf(szStr,RstrA(IDS_E_SECTHEADER),tk);
                        printLine(GUICookie,szStr);
                    }
                    szptr+=sprintf(szptr, "%-10s ", pszInstrName);
                    ConvToLiteral(szptr, v1, 0xFFFF);
                    PC += 4;
                    break;
                }

                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "(%2.2X)%2.2X%2.2X%2.2X ", 
                        pCode[PC+3], pCode[PC+2], pCode[PC+1], pCode[PC]);
                    Len += 11;
                    PadTheString;               
                }
                PC += 4;

                szptr+=sprintf(szptr, "%-10s ", pszInstrName);

                if ((tk & 0xFF000000) == 0) 
                {
                    szptr+=sprintf(szptr, "%#x ", tk);
                    break;
                }
				if(OpcodeInfo[instr].Type== InlineTok)
				{
					switch (tkType)
					{
						default:
							break;

						case mdtMethodDef:
							szptr+=sprintf(szptr,"method ");
							break;

						case mdtFieldDef:
							szptr+=sprintf(szptr,"field ");
							break;

						case mdtMemberRef:
							{
								PCCOR_SIGNATURE typePtr;
								const char*			pszMemberName;
								ULONG       cComSig;

								pszMemberName = pImport->GetNameAndSigOfMemberRef(
									tk,
									&typePtr,
									&cComSig
								);
								unsigned callConv = CorSigUncompressData(typePtr);  

								if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
									szptr+=sprintf(szptr,"field ");
								else
									szptr+=sprintf(szptr,"method ");
								break;
							}
					}
				}
				switch (tkType)
                {
                    default:
                    {
                        szptr+=sprintf(szptr, "<unknown token type 0x%02x>", (BYTE) (tkType >> 24));
                        break;
                    }

                    case mdtTypeDef:
                    case mdtTypeRef:
                    case mdtTypeSpec:
                    {
                        CQuickBytes out;
                        strcpy(szptr, PrettyPrintClass(&out, tk, pImport));
                        break;
                    }

                    case mdtMethodDef:
                        PrettyPrintMethodDef(szString,tk,pImport,GUICookie);
                        break;

                    case mdtFieldDef:
                    {
                        HRESULT         hr;
                        mdTypeRef       cr=0;
                        const char *    pszMemberName;
                        CQuickBytes     qbMemberSig;
						DWORD			dwAttrs;

                        PCCOR_SIGNATURE pComSig;
                        ULONG       cComSig;

                        pszMemberName = pImport->GetNameOfFieldDef(tk);
						MAKE_NAME_IF_NONE(pszMemberName,tk);
					    dwAttrs = pImport->GetFieldDefProps(tk);

                        pComSig = pImport->GetSigOfFieldDef(
                            tk,
                            &cComSig
                        );
                        hr = pImport->GetParentToken(
                            tk,
                            &cr
                        );
                        if (FAILED(hr))
                        {
                            strcat(szString, "??");
                            break;
                        }

                        // use the tail as a buffer 
                        char* curPos = &szString[strlen(szString)];
						if(RidFromToken(cr))
						{
							CQuickBytes out;
							const char* pszClass = PrettyPrintClass(&out, cr, pImport);
							if(strcmp(pszClass,"'<Module>'"))
							{
								sprintf(curPos,"%s::", pszClass);
							}
						}
						char* curPos1 = &curPos[strlen(curPos)];
						if(IsFdPrivateScope(dwAttrs))
							sprintf(curPos1,"%s$PST%08X",pszMemberName,tk);
						else
							sprintf(curPos1,"%s",pszMemberName);
						strcpy(curPos1,ProperName(curPos1));
                        qbMemberSig.ReSize(0);
                        strcpy(curPos, PrettyPrintSig(pComSig, cComSig, curPos, &qbMemberSig, pImport,NULL));
						if(g_fDumpTokens)
							sprintf(&curPos[strlen(curPos)]," /* %08X */",tk);
                        break;
                    }

                    case mdtMemberRef:
                        PrettyPrintMemberRef(szString,tk,pImport,GUICookie);
                        printLine(GUICookie,szString);
                        DumpCustomAttributes(tk,GUICookie);
                        continue;
                        //break;

                    case mdtString:
                    {
                        const WCHAR * pszString;
                        ULONG   cbString;
                        pszString = pImport->GetUserString(tk, &cbString, 0);
						DumpUnicodeString(GUICookie,szString,(WCHAR *)pszString,cbString);
						if(g_fDumpTokens)
							sprintf(&szString[strlen(szString)]," /* %08X */",tk);
						break;
                    }
                }
                break;
            }

            case InlineSig:
            {
                if(g_fShowBytes)
                {
                    szptr+=sprintf(szptr, "%2.2X%2.2X%2.2X%2.2X ", 
                        pCode[PC], pCode[PC+1], pCode[PC+2], pCode[PC+3]);
                    // output the offset and the raw bytes
                    Len += 9;
                    PadTheString;
                }

                // get the signature token
                tk = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                PC += 4;
                tkType = TypeFromToken(tk);
                if(tkType == mdtSignature)
                {
                    // get the signature from the token
                    DWORD           cbSigLen;
                    PCCOR_SIGNATURE pComSig;
                    CQuickBytes     qbMemberSig;
                    pComSig = pImport->GetSigFromToken(tk, &cbSigLen);

                    qbMemberSig.ReSize(0);
                    const char* pszTailSig = PrettyPrintSig(pComSig, cbSigLen, "", &qbMemberSig, pImport,NULL); 
                    szptr+=sprintf(szptr, "%-10s %s", pszInstrName, pszTailSig,NULL);
					if(g_fDumpTokens) szptr+=sprintf(szptr," /*%08X*/",tk);
                }
                else
                    szptr+=sprintf(szptr, RstrA(IDS_E_BADTOKENTYPE), pszInstrName, tk);
                break;
            }
        }

        printLine(GUICookie, szString);
    } // end     while (PC < method.CodeSize)

	if(g_ehCount)
	{
		if(fTryInCode) dumpOneEHInfo(ehInfoToPutNext,pImport,GUICookie); //doesn't do anything if ehInfoToPutNext == NULL
		else
		{
			sprintf(szString,"%sIL_%04x:  ",g_szAsmCodeIndent, method.CodeSize); //add dummy label
			printLine(GUICookie, szString);
			dumpEHInfo(pImport,GUICookie);
		}
	}
	//----------------- lexical scope handling -----------------------------
    if(ulScopes) // non-zero only if local var info present
    {
        for(unsigned i=0; i < ulScopes; i++)
        {
            if((PC == daScope[i].dwEnd)&&(daScope[i].pISymScope != pRootScope))
            {
                g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                sprintf(szString,"%s}",g_szAsmCodeIndent);
                printLine(GUICookie,szString);
            }
			daScope[i].pISymScope->Release();
        }
    }
	if(pSymMethod) pSymMethod->Release();
    if(LineCode) delete LineCode;
    if(pszLVname)
    {
        for(ULONG i = 0; i < ulVars; i++) delete pszLVname[i].name;
        delete pszLVname;
    }
//  dumpEHInfo(pImport, GUICookie);

    return TRUE;
}

void PrettyPrintMemberRef(char* szString, mdToken tk, IMDInternalImport *pImport, void* GUICookie)
{
    mdTypeRef       cr;
    const char *    pszMemberName;
    CQuickBytes     qbMemberSig;
	char*			curPos;

    PCCOR_SIGNATURE pComSig;
    ULONG       cComSig;

    pszMemberName = pImport->GetNameAndSigOfMemberRef(
        tk,
        &pComSig,
        &cComSig
    );
	MAKE_NAME_IF_NONE(pszMemberName,tk);

    cr = pImport->GetParentOfMemberRef(tk);
        // @TODO LBS GetTypeRefFromMemberRef can return three things    
        // A TypeRef, a ModuleRef or a MethodDesc (for ndirect) 
        // right now we blow two of these off.
    if(TypeFromToken(cr) == mdtMethodDef) //get the parent's parent
    {
        mdTypeRef cr1;
        if(FAILED(pImport->GetParentToken(cr,&cr1))) cr1 = mdTypeRefNil;
        cr = cr1;
    }

    curPos = &szString[strlen(szString)+1];
	*curPos = 0;
    qbMemberSig.ReSize(0);
	if(RidFromToken(cr))
	{
		const char* pszClass = PrettyPrintClass(&qbMemberSig,cr,pImport);
		if(strcmp(pszClass,"'<Module>'"))
		{
			sprintf(curPos,"%s::",pszClass);
		}
		qbMemberSig.ReSize(0);
	}
	strcat(curPos,ProperName((char*)pszMemberName));

    appendStr(&qbMemberSig, szString);
    {
        char* pszTailSig = (char*)PrettyPrintSig(pComSig, cComSig, curPos, &qbMemberSig, pImport,NULL);
        char* pszOffset = strstr(pszTailSig,curPos);
        int i,j,k, indent = pszOffset - pszTailSig + strlen(curPos) + 1;
        char chAfterComma;
        char *pComma = pszOffset+strlen(curPos), *pch;
        while(pComma = strchr(pComma,','))
        {
            for(pch = pszTailSig, i=0,j=0,k=0; pch < pComma; pch++)
            {
				if(*pch == '\'') j=1-j;
				else if(j==0)
				{
					if(*pch == '[') i++;
					else if(*pch == ']') i--;
					else if(*pch == '(') k++;
					else if(*pch == ')') k--;
				}
            }
            pComma++;
			if((i==0)&&(j==0)&&(k<=1)) // no brackets or all opened/closed
            {
                chAfterComma = *pComma;
                *pComma = 0;
                printLine(GUICookie,pszTailSig);
                *pComma = chAfterComma;
				strcpy(pszTailSig,g_szAsmCodeIndent);
                for(i=strlen(g_szAsmCodeIndent); i<indent; i++) pszTailSig[i] = ' ';
                strcpy(&pszTailSig[indent],pComma);
                pComma = pszTailSig;
            } 
        }
		if(g_fDumpTokens)
	        sprintf(szString,"%s /* %08X */",pszTailSig,tk);
		else
			sprintf(szString,"%s",pszTailSig);
    }
}
void PrettyPrintMethodDef(char* szString, mdToken tk, IMDInternalImport *pImport,void* GUICookie)
{
    HRESULT         hr;
    mdTypeRef       cr;
    const char *    pszMemberName;
    CQuickBytes     qbMemberSig;
	char*			curPos;
	DWORD			dwAttrs;

    PCCOR_SIGNATURE pComSig;
    ULONG       cComSig;
    pszMemberName = pImport->GetNameOfMethodDef(tk);
	MAKE_NAME_IF_NONE(pszMemberName,tk);
    dwAttrs = pImport->GetMethodDefProps(tk);

    pComSig = pImport->GetSigOfMethodDef(tk, &cComSig);

    hr = pImport->GetParentToken(
        tk,
        &cr
    );
    if (FAILED(hr))
    {
        strcat(szString, "??");
        return;
    }
    // use the tail as a buffer 
    curPos = &szString[strlen(szString)+1];
	*curPos=0;
    qbMemberSig.ReSize(0);
	if(RidFromToken(cr))
	{
		const char* pszClass = PrettyPrintClass(&qbMemberSig,cr,pImport);
		if(strcmp(pszClass,"'<Module>'"))
		{
			sprintf(curPos,"%s::",pszClass);
		}
		qbMemberSig.ReSize(0);
	}
	{
		char* curPos1 = &curPos[strlen(curPos)];
		if(IsMdPrivateScope(dwAttrs))
			sprintf(curPos1,"%s$PST%08X",pszMemberName,tk);
		else
			sprintf(curPos1,"%s",pszMemberName);
		strcpy(curPos1,ProperName(curPos1));
	}
    appendStr(&qbMemberSig, szString);
    {
        char* pszTailSig = (char*)PrettyPrintSig(pComSig, cComSig, curPos, &qbMemberSig, pImport,NULL);
        char* pszOffset = strstr(pszTailSig,curPos);
        int i,j,k, indent = pszOffset - pszTailSig + strlen(curPos) + 1;
        char chAfterComma;
        char *pComma = pszOffset+strlen(curPos), *pch;
        while(pComma = strchr(pComma,','))
        {
            for(pch = pszTailSig, i=0,j=0,k=0; pch < pComma; pch++)
            {
				if(*pch == '\'') j=1-j;
				else if(j==0)
				{
					if(*pch == '[') i++;
					else if(*pch == ']') i--;
					else if(*pch == '(') k++;
					else if(*pch == ')') k--;
				}
            }
            pComma++;
			if((i==0)&&(j==0)&&(k<=1)) // no quotes/brackets/parentheses, or all opened/closed
            {
                chAfterComma = *pComma;
                *pComma = 0;
                printLine(GUICookie,pszTailSig);
                *pComma = chAfterComma;
				strcpy(pszTailSig,g_szAsmCodeIndent);
                for(i=strlen(g_szAsmCodeIndent); i<indent; i++) pszTailSig[i] = ' ';
                strcpy(&pszTailSig[indent],pComma);
                pComma = pszTailSig;
            }
        }
		if(g_fDumpTokens)
	        sprintf(szString,"%s /* %08X */",pszTailSig,tk);
		else
			sprintf(szString,"%s",pszTailSig);
    }
}

static char* keyword[] = {
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) s,
#define OPALIAS(alias_c, s, c) s,
#include "opcode.def"
#undef OPALIAS
#undef OPDEF
#define KYWD(name, sym, val)    name,
#include "il_kywd.h"
#undef KYWD
};
/* used by qsort to sort the keyword table */
static int __cdecl keywordCmp(const void *op1, const void *op2)
{
    return  strcmp(*(char **)op1, *(char**)op2);
}
static bool KywdNotSorted = TRUE;
static char* szAllowedSymbols = "?_@$.";
static char DisallowedStarting[256];
static char DisallowedCont[256];
/********************************************************************************/
/* looks up the keyword 'name' Returns FALSE on failure */
bool IsNameToQuote(const char *name)
{
    BYTE* p;
	BOOL	bStarting;
	if((name==NULL)||(*name==0)) return TRUE;
	if(g_fQuoteAllNames) 
		return ((strcmp(name,COR_CTOR_METHOD_NAME)!=0) && (strcmp(name,COR_CCTOR_METHOD_NAME)!=0));
    if(KywdNotSorted)
    {
        int j;
        // name must start with alpha or one of allowed chars
        memset(DisallowedStarting,1,256);
        for(p = (BYTE*)szAllowedSymbols; *p; DisallowedStarting[*p]=0,p++);
        for(j='a'; j<= 'z'; DisallowedStarting[j]=0,j++);
        for(j='A'; j<= 'Z'; DisallowedStarting[j]=0,j++);
        // name must continue with the same chars, plus digits
        memcpy(DisallowedCont,DisallowedStarting,256);
        for(j='0'; j<= '9'; DisallowedCont[j]=0,j++);
        // Sort the keywords for fast lookup 
        qsort(keyword, sizeof(keyword) / sizeof(char*), sizeof(char*), keywordCmp);
        KywdNotSorted = FALSE;
    }
    //first, check for forbidden characters
	for(p = (BYTE*)name, bStarting = TRUE; *p; p++)
	{
		if(bStarting)
		{
			if(DisallowedStarting[*p]) return TRUE;
		}
		else
		{
			if(DisallowedCont[*p]) return TRUE;
		}
		bStarting = (*p == '.');
	}

    //second, check for matching keywords (remember: .ctor and .cctor are names AND keywords)
    char** low = keyword;
    char** high = &keyword[sizeof(keyword) / sizeof(char*)];
    char** mid;

    _ASSERTE (high > low);      // Table is non-empty
    for(;;) {
        mid = &low[(high - low) / 2];

        int cmp = strcmp(name, *mid);
        if (cmp == 0) 
            return ((strcmp(name,COR_CTOR_METHOD_NAME)!=0) && (strcmp(name,COR_CCTOR_METHOD_NAME)!=0));

        if (mid == low) break;

        if (cmp > 0)    low = mid;
        else            high = mid;
    }
    //third, check if the name starts or ends with dot (.ctor and .cctor are out of the way)
    return ((*name == '.') || (name[strlen(name)-1] == '.'));
}

/********************************************************************/
static char* ConvNumericEscape(char* retBuff, unsigned val) {
    _ASSERTE(val < 256);

        // print as octal
    *retBuff++ = '\\';
    *retBuff++ = (val >> 6) + '0';
    *retBuff++ = ((val >> 3) & 7) + '0';
    *retBuff++ = (val & 7) + '0';
    return(retBuff);
}

/********************************************************************/
/* returns the quoted version of a string (including the quotes)
/* TODO really need to do buffer management (so we don't fall off the end */

static BOOL ConvToLiteral(char* retBuff, const WCHAR* str, int cbString) 
{
    BOOL ret = TRUE;
    char* was_retBuff = retBuff;

    *retBuff++ = '"';

    for(int tally=0; (tally < cbString)&&ret; tally++) 
    {
        if (*str > 255) 
        {
            //retBuff = ConvNumericEscape(retBuff, *str >> 8);
            //retBuff = ConvNumericEscape(retBuff, *str & 0xFF);
            ret = FALSE;
        }
        else if(!isprint(*str)) 
        {
            if (*str == '\n') 
            {
                *retBuff++ = '\\';
                *retBuff++ = 'n';
            }
            else
                //retBuff = ConvNumericEscape(retBuff, *str);
                ret = FALSE;
        }
        else if (*str == '"') 
        {
            *retBuff++ = '\\';
            *retBuff++ = '"';
        }
        else if (*str == '\\') 
        {
            *retBuff++ = '\\';
            *retBuff++ = '\\';
        }
        else if (*str == '\t') 
        {
            *retBuff++ = '\\';
            *retBuff++ = 't';
        }
        else
            *retBuff++ = (char) *str;
        str++;
    }
    *retBuff++ = '"';
    *retBuff++ = 0;
    if(!ret) *was_retBuff = 0;
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dasm_pr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define OEMRESOURCE
#include <stdio.h>
#include <stdlib.h>
#include <utilcode.h>
#include <malloc.h>
#include <string.h>
#include <windows.h>
#include <winuser.h>
#include <commctrl.h>
#include "resource.h"

char* RstrANSI(unsigned id);

extern HINSTANCE			g_hAppInstance;
extern DWORD                g_NumClasses;
extern char					g_szInputFile[]; // in UTF-8
extern char					g_szOutputFile[]; // in UTF-8

#define IDC_CANCEL	101

HWND	g_hwndProgress = NULL;
HWND	g_hwndProgBox = NULL;
HWND	g_hwndFromFile = NULL;
HWND	g_hwndToFile = NULL;
HWND	g_hwndTally = NULL;
HWND	g_hwndCancel = NULL;
HANDLE	g_hThreadReady = NULL; // event

BOOL	g_fInitCommonControls = TRUE;
BOOL	g_fRegisterClass = TRUE;
ULONG	g_ulCount, g_ulRange;
RECT	rcClient;  // client area of parent window 

LRESULT CALLBACK ProgBoxWndProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM  lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDC_CANCEL:
					g_hwndProgress = NULL;
					g_hwndProgBox = NULL;
					g_hwndFromFile = NULL;
					g_hwndToFile = NULL;
					g_hwndTally = NULL;
					g_hwndCancel = NULL;
					DestroyWindow (hwnd);
					break;
			}
			break;


        case WM_CLOSE:
			g_hwndProgress = NULL;
			g_hwndProgBox = NULL;
			g_hwndFromFile = NULL;
			g_hwndToFile = NULL;
			g_hwndTally = NULL;
			g_hwndCancel = NULL;
            //break;          
		default:
			return DefWindowProc(hwnd, uMsg, wParam, lParam);     
	}
	return 0;
}
DWORD WINAPI ProgressMainLoop(LPVOID pv)
{    
    MSG msg;     
	DWORD cyVScroll;
    HFONT hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT); //(ANSI_FIXED_FONT);
	char szStr[1024];

	if(g_fInitCommonControls)
	{
		InitCommonControls();
		g_fInitCommonControls = FALSE;
	}
	g_ulCount = 0;
	if(g_fRegisterClass)
	{
		WNDCLASSEXA  wndClass;

		wndClass.cbSize			= sizeof(wndClass);
		wndClass.style          = CS_HREDRAW|CS_VREDRAW|CS_NOCLOSE;
		wndClass.lpfnWndProc    = ProgBoxWndProc;
		wndClass.cbClsExtra     = 0;
		wndClass.cbWndExtra     = 0;
		wndClass.hInstance      = g_hAppInstance;
		wndClass.hIcon          = LoadIcon(g_hAppInstance,MAKEINTRESOURCE(IDI_ICON2));
		wndClass.hCursor        = NULL;
		wndClass.hbrBackground  = (HBRUSH) GetStockObject(LTGRAY_BRUSH);
		wndClass.lpszMenuName   = NULL; 
		wndClass.lpszClassName  = "ProgressBox";
		wndClass.hIconSm        = NULL;

		if (RegisterClassEx(&wndClass) == 0) return 0;

		g_fRegisterClass = FALSE;
	}
	cyVScroll = GetSystemMetrics(SM_CYVSCROLL); 
	if(g_hwndProgBox = CreateWindowExA (0,
									"ProgressBox",
									RstrANSI(IDS_PBAR_TITLE),
									WS_VISIBLE | WS_CAPTION | WS_POPUP | WS_SYSMENU | WS_CLIPCHILDREN,
									400, 200, 400, 8*cyVScroll,
									HWND_DESKTOP, 
									(HMENU)0, 
									g_hAppInstance,
									NULL))
	{
		GetClientRect(g_hwndProgBox, &rcClient);
		
		if(g_hwndFromFile = CreateWindowExA (0,
										"STATIC",
										"",
										WS_CHILD|WS_VISIBLE|SS_CENTER,
										rcClient.left, rcClient.bottom-6*cyVScroll,rcClient.right, cyVScroll,
										g_hwndProgBox, 
										(HMENU)0, 
										g_hAppInstance,
										NULL))
		{
		    SendMessageA(g_hwndFromFile,WM_SETFONT,(LPARAM)hFont,FALSE);
			if(strlen(g_szInputFile) <= 60) sprintf(szStr,RstrANSI(IDS_PBAR_FILE1),g_szInputFile);
			else 
			{
				char * p=g_szInputFile;
				while(p = strchr(p,'\\'))
				{
					if(strlen(p) <= 60) break;
					p++;
				}
				if(p == NULL) p = &g_szInputFile[strlen(g_szInputFile)-50];
				sprintf(szStr,RstrANSI(IDS_PBAR_FILE2),p);
			}
			SendMessage(g_hwndFromFile, WM_SETTEXT,0,(LPARAM)szStr);
		}
		if(g_hwndToFile = CreateWindowExA (0,
										"STATIC",
										"",
										WS_CHILD|WS_VISIBLE|SS_CENTER,
										rcClient.left, rcClient.bottom-5*cyVScroll,rcClient.right, cyVScroll,
										g_hwndProgBox, 
										(HMENU)0, 
										g_hAppInstance,
										NULL))
		{
		    SendMessageA(g_hwndToFile,WM_SETFONT,(LPARAM)hFont,FALSE);
			sprintf(szStr,RstrANSI(IDS_PBAR_TOFILE),g_szOutputFile);
			SendMessage(g_hwndToFile, WM_SETTEXT,0,(LPARAM)szStr);
		}
		if(g_hwndTally = CreateWindowExA (0,
										"STATIC",
										"",
										WS_CHILD|WS_VISIBLE|SS_CENTER,
										rcClient.left, rcClient.bottom-4*cyVScroll,rcClient.right, cyVScroll,
										g_hwndProgBox, 
										(HMENU)0, 
										g_hAppInstance,
										NULL))
		{
		    SendMessageA(g_hwndTally,WM_SETFONT,(LPARAM)hFont,FALSE);
			if(g_ulCount <= g_NumClasses) sprintf(szStr,RstrANSI(IDS_PBAR_STAGE1),g_NumClasses,g_ulCount);
			else sprintf(szStr,RstrANSI(IDS_PBAR_STAGE2),g_ulRange-g_NumClasses,g_ulCount-g_NumClasses);
			SendMessage(g_hwndTally, WM_SETTEXT,0,(LPARAM)szStr);
		}
		if(g_hwndProgress = CreateWindowEx (0,
										PROGRESS_CLASS,
										"",
										WS_CHILD|WS_VISIBLE|SS_CENTER, // SS_CENTER gives smooth progress and solid bar
										rcClient.left, rcClient.bottom-3*cyVScroll,rcClient.right, cyVScroll,
										g_hwndProgBox, 
										(HMENU)0, 
										g_hAppInstance,
										NULL))
		{
			// Set the range for the progress bar.
			SendMessage (g_hwndProgress, PBM_SETRANGE, 0L, MAKELPARAM(0, g_ulRange));
			// Set the step.
			SendMessage (g_hwndProgress, PBM_SETSTEP, (WPARAM)1, 0L);
		}
		if(g_hwndCancel = CreateWindowExA (0,
										"BUTTON",
										"Cancel",
										WS_CHILD|WS_VISIBLE|BS_DEFPUSHBUTTON|BS_TEXT,
										rcClient.left+150, rcClient.bottom-3*cyVScroll/2,rcClient.right-300, 4*cyVScroll/3,
										g_hwndProgBox, 
										(HMENU)IDC_CANCEL, 
										g_hAppInstance,
										NULL))
		{
		    SendMessageA(g_hwndCancel,WM_SETFONT,(LPARAM)hFont,FALSE);
		}
	}
	SetEvent(g_hThreadReady);
    while (GetMessage(&msg, NULL, 0, 0)) 
    { 
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    }
	return 0;
}


void	CreateProgressBar(LONG lRange)
{
	DWORD dwThreadID;
	g_ulCount = 0;
	if((g_ulRange = (ULONG)lRange)==0) return;
	if(g_hThreadReady == NULL) g_hThreadReady = CreateEvent(NULL,FALSE,FALSE,NULL);
	CreateThread(NULL,0,ProgressMainLoop,NULL,0,&dwThreadID);
	WaitForSingleObject(g_hThreadReady,INFINITE);
}

BOOL ProgressStep()
{
	if(g_hwndProgBox)
	{
		char szStr[2048];
		if(g_hwndTally)
		{
			if(g_ulCount <= g_NumClasses) 
				sprintf(szStr,RstrANSI(IDS_PBAR_STAGE1),g_NumClasses,g_ulCount);
			else if(g_ulCount <= g_ulRange) 
				sprintf(szStr,RstrANSI(IDS_PBAR_STAGE2),g_ulRange-g_NumClasses,g_ulCount-g_NumClasses);
			else
				strcpy(szStr,RstrANSI(IDS_PBAR_STAGE3));
			SendMessageA(g_hwndTally, WM_SETTEXT,0,(LPARAM)szStr);
		}

		if(g_hwndProgress && g_ulCount && (g_ulCount <= g_ulRange)) 
			SendMessage (g_hwndProgress, PBM_STEPIT, 0L, 0L);
		g_ulCount++;
	}
	else if(g_ulCount) return FALSE; // disassembly started and was aborted
	return TRUE;
}

void DestroyProgressBar()
{
	if(g_hwndProgBox) SendMessage (g_hwndProgBox,WM_COMMAND,IDC_CANCEL,0);
	g_hwndProgress = NULL;
	g_hwndProgBox = NULL;
	g_hwndFromFile = NULL;
	g_hwndToFile = NULL;
	g_hwndTally = NULL;
	g_hwndCancel = NULL;
	g_ulCount = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dman.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// dman.cpp
// 
// Assembly and Manifest Disassembler
//
#include <stdio.h>
#include <stdlib.h>
#include <utilcode.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "dasmenum.hpp"
#include "dasmgui.h"
#include "formatType.h"
#include "dis.h"
#include "Mlang.h"

#include "utilcode.h" // for CQuickByte

#include "ceeload.h"
#include "DynamicArray.h"
#include "resource.h"

extern IMAGE_COR20_HEADER *    g_CORHeader;
extern IMDInternalImport*      g_pImport;
extern PELoader * g_pPELoader;
extern IMetaDataImport*        g_pPubImport;
IMetaDataAssemblyImport*    g_pAssemblyImport=NULL;
extern BOOL     g_fDumpAsmCode;
extern char     g_szAsmCodeIndent[];
extern char     g_szOutputFile[];
extern BOOL     g_fDumpTokens;
extern DWORD	g_Mode;
extern FILE*    g_pFile;
extern LPCSTR*  rAsmRefName;  // decl. in formatType.cpp -- for AsmRef aliases
extern ULONG	ulNumAsmRefs; // decl. in formatType.cpp -- for AsmRef aliases
extern BOOL				g_fOnUnicode;
MTokName*   rFile = NULL;
ULONG   nFiles = 0; 
void DumpFiles(void* GUICookie)
{
    mdFile      rFileTok[4096];
    HCORENUM    hEnum=NULL;
    if(rFile) { delete [] rFile; rFile = NULL; nFiles = 0; }
    if(SUCCEEDED(g_pAssemblyImport->EnumFiles(&hEnum,rFileTok,4096,&nFiles)))
    {
        if(nFiles)
        {
            WCHAR       wzName[1024];
            ULONG       ulNameLen;
            char*       szName = (char*)&wzName[0];
            const void* pHashValue;
            ULONG       cbHashValue;
            DWORD       dwFlags;
            char        szString[4096];
            char*       szptr;
            rFile = new MTokName[nFiles];
            for(ULONG ix = 0; ix < nFiles; ix++)
            {
                pHashValue=NULL;
                cbHashValue=0;
                ulNameLen=0;
                if(SUCCEEDED(g_pAssemblyImport->GetFileProps(rFileTok[ix],wzName,1024,&ulNameLen,
                                                            &pHashValue,&cbHashValue,&dwFlags)))
                {
                    szptr = &szString[0];
                    rFile[ix].tok = rFileTok[ix];
                    rFile[ix].name = new WCHAR[ulNameLen+1];
                    memcpy(rFile[ix].name,wzName,ulNameLen*sizeof(WCHAR));
                    rFile[ix].name[ulNameLen] = 0;

                    szptr+=sprintf(szptr,"%s.file ",g_szAsmCodeIndent);
                    if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",rFileTok[ix]);
                    if(IsFfContainsNoMetaData(dwFlags)) szptr+=sprintf(szptr,"nometadata ");
                    {
                        int L = ulNameLen*3+3;
                        char* sz = new char[L];
                        memset(sz,0,L);
                        WszWideCharToMultiByte(CP_UTF8,0,rFile[ix].name,-1,sz,L,NULL,NULL);
                        sprintf(szptr,"%s", ProperName(sz));
                        delete [] sz;
                    }
                    printLine(GUICookie,szString);
					if(g_CORHeader->EntryPointToken == rFileTok[ix])
					{
						printLine(GUICookie, "    .entrypoint");
					}
                    if(pHashValue && cbHashValue)
                    {
                        strcpy(szString,"    .hash = (");
                        DumpByteArray(szString,(BYTE*)pHashValue,cbHashValue,GUICookie);
                        printLine(GUICookie,szString);
                    }
                    DumpCustomAttributes(rFile[ix].tok, GUICookie);
                }
            }
        }
        g_pAssemblyImport->CloseEnum(hEnum);
    }
    else nFiles=0;
}

void DumpAssemblyMetaData(ASSEMBLYMETADATA* pmd, void* GUICookie)
{
    if(pmd)
    {
        char    szString[4096];
        sprintf(szString,"%s.ver %d:%d:%d:%d",g_szAsmCodeIndent,pmd->usMajorVersion,pmd->usMinorVersion,
			pmd->usBuildNumber,pmd->usRevisionNumber);
        printLine(GUICookie,szString);
        if(pmd->szLocale && pmd->cbLocale)
        {
            sprintf(szString,"%s.locale = (",g_szAsmCodeIndent);
            DumpByteArray(szString,(BYTE*)(pmd->szLocale),pmd->cbLocale*sizeof(WCHAR),GUICookie);
            printLine(GUICookie,szString);
        }
    }
}
void DumpScope(void* GUICookie)
{
    mdModule mdm;
    GUID mvid;
    WCHAR scopeName[1024];
    WCHAR guidString[1024];
    char szString[2048];
	memset(scopeName,0,1024*sizeof(WCHAR));
    if(SUCCEEDED(g_pPubImport->GetScopeProps( scopeName, 1024, NULL, &mvid))&& scopeName[0])
    {
        {
            int L = wcslen(scopeName)*3+3;
            char* sz = new char[L];
            memset(sz,0,L);
            WszWideCharToMultiByte(CP_UTF8,0,scopeName,-1,sz,L,NULL,NULL);
            sprintf(szString,"%s.module %s",g_szAsmCodeIndent,ProperName(sz));
            delete [] sz;
        }
        printLine(GUICookie,szString);
        StringFromGUID2(mvid, guidString, 1024);
        {
            int L = wcslen(guidString)*3+3;
            char* sz = new char[L];
            memset(sz,0,L);
            WszWideCharToMultiByte(CP_UTF8,0,guidString,-1,sz,L,NULL,NULL);
            sprintf(szString,"%s// MVID: %s",g_szAsmCodeIndent,sz);
            delete [] sz;
        }
        printLine(GUICookie,szString);
		if(SUCCEEDED(g_pPubImport->GetModuleFromScope(&mdm)))
		{
			//sprintf(szString,"%s// mdModule: %08X",g_szAsmCodeIndent,mdm);
			//printLine(GUICookie,szString);
			DumpCustomAttributes(mdm, GUICookie);
			DumpPermissions(mdm, GUICookie);
		}
    }
}

void DumpModuleRefs(void *GUICookie)
{
    HCORENUM        hEnum=NULL;
    ULONG           N;
    mdToken         tk[4096];
    char            szString[2048], *szptr;
    LPCSTR          szName;

    g_pPubImport->EnumModuleRefs(&hEnum,tk,4096,&N);
    for(ULONG i = 0; i < N; i++)
    {
        if(RidFromToken(tk[i]))
        {
            g_pImport->GetModuleRefProps(tk[i],&szName);
			MAKE_NAME_IF_NONE(szName,tk[i]);
            szptr = &szString[0];
            szptr+=sprintf(szptr,"%s.module extern %s",g_szAsmCodeIndent,ProperName((char*)szName));
            if(g_fDumpTokens) szptr+=sprintf(szptr," /*%08X*/",tk[i]);
            printLine(GUICookie,szString);
            DumpCustomAttributes(tk[i], GUICookie);
            DumpPermissions(tk[i], GUICookie);
        }
    }
    g_pPubImport->CloseEnum(hEnum);
}

void DumpAssembly(void* GUICookie, BOOL fFullDump)
{
    mdAssembly  tkAsm;
    if(SUCCEEDED(g_pAssemblyImport->GetAssemblyFromScope(&tkAsm))&&(tkAsm != mdAssemblyNil))
    {
        const void* pPublicKey;
        ULONG       cbPublicKey = 0;
        ULONG       ulHashAlgId;
        WCHAR       wzName[1024];
        ULONG       ulNameLen=0;
        char*       szName = (char*)&wzName[0];
        ASSEMBLYMETADATA    md;
        WCHAR       wzLocale[MAX_LOCALE_NAME];
        DWORD       dwFlags;
        char        szString[4096];
        char*       szptr;

        md.szLocale = wzLocale;
        md.cbLocale = MAX_LOCALE_NAME;
        md.rProcessor = NULL;
        md.ulProcessor = 0;
        md.rOS = NULL;
        md.ulOS = 0;

        if(SUCCEEDED(g_pAssemblyImport->GetAssemblyProps(            // S_OK or error.
                                                        tkAsm,       // [IN] The Assembly for which to get the properties.
                                                        &pPublicKey, // [OUT] Pointer to the public key.
                                                        &cbPublicKey,// [OUT] Count of bytes in the public key.
                                                        &ulHashAlgId,// [OUT] Hash Algorithm.
                                                        wzName,      // [OUT] Buffer to fill with name.
                                                        1024,        // [IN] Size of buffer in wide chars.
                                                        &ulNameLen,  // [OUT] Actual # of wide chars in name.
                                                        &md,         // [OUT] Assembly MetaData.
                                                        &dwFlags)))  // [OUT] Flags.
        {
			if(ulNameLen >= 1024)
			{
				sprintf(szString,"error *** Assembly name too long, truncated to 1023 characters");
				printError(GUICookie,szString);
				wzName[1023] = 0;
			}
            szptr = &szString[0];
            szptr+=sprintf(szptr,"%s.assembly ",g_szAsmCodeIndent);
            if(g_fDumpTokens) szptr+=sprintf(szptr,"/*%08X*/ ",tkAsm);
            if(dwFlags & 0x00000100) szptr+=sprintf(szptr,"retargetable ");
            if(IsAfNonSideBySideAppDomain(dwFlags)) szptr+=sprintf(szptr,"noappdomain ");
            if(IsAfNonSideBySideProcess(dwFlags))   szptr+=sprintf(szptr,"noprocess ");
            if(IsAfNonSideBySideMachine(dwFlags))   szptr+=sprintf(szptr,"nomachine ");

			wzName[ulNameLen] = 0;
			{
				char* sz = new char[3*ulNameLen+3];
				memset(sz,0,3*ulNameLen+3);
				WszWideCharToMultiByte(CP_UTF8,0,wzName,-1,sz,3*ulNameLen+3,NULL,NULL);
				szptr += sprintf(szptr,"%s",ProperName(sz));
				delete [] sz;
			}
            printLine(GUICookie,szString);
            sprintf(szString,"%s{",g_szAsmCodeIndent);
            printLine(GUICookie,szString);
            strcat(g_szAsmCodeIndent,"  ");
            if(fFullDump)
            {
                DumpCustomAttributes(tkAsm, GUICookie);
                DumpPermissions(tkAsm, GUICookie);
            }

			if(fFullDump)
			{
				if(pPublicKey && cbPublicKey)
				{
                    sprintf(szString,"%s.publickey = (",g_szAsmCodeIndent);
					DumpByteArray(szString,(BYTE*)pPublicKey,cbPublicKey,GUICookie);
					printLine(GUICookie,szString);
				}
				if(ulHashAlgId)
				{
					sprintf(szString,"%s.hash algorithm 0x%08X",g_szAsmCodeIndent,ulHashAlgId);
					printLine(GUICookie,szString);
				}
			}
            DumpAssemblyMetaData(&md,GUICookie);
            g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
            sprintf(szString,"%s}",g_szAsmCodeIndent);
            printLine(GUICookie,szString);
        } //end if(OK(GetAssemblyProps))
    } //end if(OK(GetAssemblyFromScope))
}

MTokName*   rAsmRef = NULL;
ULONG   nAsmRefs = 0;   

void DumpAssemblyRefs(void* GUICookie)
{
    mdAssemblyRef       rAsmRefTok[4096];
    HCORENUM    hEnum=NULL;
	ULONG ix;
    if(rAsmRef) { delete [] rAsmRef; rAsmRef = NULL; nAsmRefs = 0; }
    if(rAsmRefName) 
	{ 
		for(ix=0; ix < ulNumAsmRefs; ix++)
		{
			if(rAsmRefName[ix]) delete [] rAsmRefName[ix];
		}
		delete [] rAsmRefName; 
		rAsmRefName = NULL; 
		ulNumAsmRefs = 0; 
	}
    if(SUCCEEDED(g_pAssemblyImport->EnumAssemblyRefs(&hEnum,rAsmRefTok,4096,&nAsmRefs)))
    {
        if(nAsmRefs)
        {
            const void* pPublicKeyOrToken;
            ULONG       cbPublicKeyOrToken = 0;
            const void* pHashValue;
            ULONG       cbHashValue;
            WCHAR       wzName[1024];
            ULONG       ulNameLen=0;
            char*       szName = (char*)&wzName[0];
            ASSEMBLYMETADATA    md;
            WCHAR       wzLocale[MAX_LOCALE_NAME];
            DWORD       dwFlags;
            char        szString[4096];

            rAsmRef = new MTokName[nAsmRefs];
			rAsmRefName = new LPCSTR[nAsmRefs];
			ulNumAsmRefs = nAsmRefs;

            for(ix = 0; ix < nAsmRefs; ix++)
            {
                md.szLocale = wzLocale;
                md.cbLocale = MAX_LOCALE_NAME;
                md.rProcessor = NULL;
                md.ulProcessor = 0;
                md.rOS = NULL;
                md.ulOS = 0;

                ulNameLen=cbHashValue=0;
                pHashValue = NULL;
                if(SUCCEEDED(g_pAssemblyImport->GetAssemblyRefProps(            // S_OK or error.
                                                                rAsmRefTok[ix], // [IN] The Assembly for which to get the properties.
                                                                &pPublicKeyOrToken, // [OUT] Pointer to the public key or token.
                                                                &cbPublicKeyOrToken,// [OUT] Count of bytes in the public key or token.
                                                                wzName,      // [OUT] Buffer to fill with name.
                                                                1024,        // [IN] Size of buffer in wide chars.
                                                                &ulNameLen,  // [OUT] Actual # of wide chars in name.
                                                                &md,         // [OUT] Assembly MetaData.
                                                                &pHashValue, // [OUT] Hash blob.
                                                                &cbHashValue,// [OUT] Count of bytes in the hash blob.
                                                                &dwFlags)))  // [OUT] Flags.
                {
					ULONG ixx;
                    rAsmRef[ix].tok = rAsmRefTok[ix];
                    rAsmRef[ix].name = new WCHAR[ulNameLen+16];
                    memcpy(rAsmRef[ix].name,wzName,ulNameLen*sizeof(WCHAR));
                    rAsmRef[ix].name[ulNameLen] = 0;
					if(ulNameLen >= 1024)
					{
						sprintf(szString,"error *** AssemblyRef name too long, truncated to 1023 characters");
						printError(GUICookie,szString);
						wzName[1023] = 0;
					}

                    sprintf(szString,"%s.assembly extern ",g_szAsmCodeIndent);
                    if(g_fDumpTokens) sprintf(&szString[strlen(szString)],"/*%08X*/ ",rAsmRefTok[ix]);
                    if(dwFlags & 0x00000100) strcat(szString,"retargetable ");

                    char* pc=&szString[strlen(szString)];
                    {
                        char* sz = new char[3*ulNameLen+32];
                        memset(sz,0,3*ulNameLen+3);
                        WszWideCharToMultiByte(CP_UTF8,0,rAsmRef[ix].name,-1,sz,3*ulNameLen+3,NULL,NULL);
                        pc+=sprintf(pc,"%s", ProperName(sz));
						// check for name duplication and introduce alias if needed
						for(ixx = 0; ixx < ix; ixx++)
						{
							if(!wcscmp(rAsmRef[ixx].name,rAsmRef[ix].name))
							{
								sprintf(&sz[strlen(sz)],"_%d",ix);
								sprintf(pc," as %s", ProperName(sz));
								break;
							}
						}
						rAsmRefName[ix] = sz;
                    }
                    printLine(GUICookie,szString);
                    sprintf(szString,"%s{",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                    strcat(g_szAsmCodeIndent,"  ");
                    DumpCustomAttributes(rAsmRefTok[ix], GUICookie);
                    if(pPublicKeyOrToken && cbPublicKeyOrToken)
                    {
                        if (IsAfPublicKey(dwFlags))
                            sprintf(szString,"%s.publickey = (",g_szAsmCodeIndent);
                        else
                            sprintf(szString,"%s.publickeytoken = (",g_szAsmCodeIndent);
                        DumpByteArray(szString,(BYTE*)pPublicKeyOrToken,cbPublicKeyOrToken,GUICookie);
                        printLine(GUICookie,szString);
                    }
                    if(pHashValue && cbHashValue)
                    {
                        sprintf(szString,"%s.hash = (",g_szAsmCodeIndent);
                        DumpByteArray(szString,(BYTE*)pHashValue,cbHashValue,GUICookie);
                        printLine(GUICookie,szString);
                    }
                    DumpAssemblyMetaData(&md,GUICookie);
                    g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                    sprintf(szString,"%s}",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                } //end if(OK(GetAssemblyRefProps))
            }//end for(all assembly refs)
        }//end if(nAsmRefs
        g_pAssemblyImport->CloseEnum(hEnum);
    }//end if OK(EnumAssemblyRefs)
    else nAsmRefs=0;
}

DynamicArray<LocalComTypeDescr*>    g_pLocalComType;
ULONG   g_LocalComTypeNum = 0;

void DumpImplementation(mdToken tkImplementation, DWORD dwOffset, char* szString, void* GUICookie)
{
    ULONG i;
    char* pc;
    if(RidFromToken(tkImplementation))
    {
        if(TypeFromToken(tkImplementation) == mdtFile)
        {
            for(i=0; (i < nFiles)&&(rFile[i].tok != tkImplementation); i++);
            if(i < nFiles)
            {
                {
                    int L = wcslen(rFile[i].name)*3+3;
                    char* sz = new char[L];
                    memset(sz,0,L);
                    WszWideCharToMultiByte(CP_UTF8,0,rFile[i].name,-1,sz,L,NULL,NULL);
                    sprintf(szString,"%s.file %s",g_szAsmCodeIndent,ProperName(sz));
                    delete [] sz;
                }
                pc=&szString[strlen(szString)];
                if(g_fDumpTokens) pc+=sprintf(pc,"/*%08X*/ ",tkImplementation);
                if(dwOffset != 0xFFFFFFFF) sprintf(pc," at 0x%08X",dwOffset);
                printLine(GUICookie,szString);
            }
        }
        else if(TypeFromToken(tkImplementation) == mdtAssemblyRef)
        {
            for(i=0; (i < nAsmRefs)&&(rAsmRef[i].tok != tkImplementation); i++);
            if(i < nAsmRefs)
            {
                {
                    int L = wcslen(rAsmRef[i].name)*3+3;
                    char* sz = new char[L];
                    memset(sz,0,L);
                    WszWideCharToMultiByte(CP_UTF8,0,rAsmRef[i].name,-1,sz,L,NULL,NULL);
                    sprintf(szString,"%s.assembly extern %s",g_szAsmCodeIndent,ProperName(sz));
                    delete [] sz;
                }
                pc=&szString[strlen(szString)];
                if(g_fDumpTokens) sprintf(pc," /*%08X*/ ",tkImplementation);
                printLine(GUICookie,szString);
            }
        }
        else if(TypeFromToken(tkImplementation) == mdtExportedType)
        {
            for(i=0; (i < g_LocalComTypeNum)&&(g_pLocalComType[i]->tkComTypeTok != tkImplementation); i++);
            if(i < g_LocalComTypeNum)
            {
                {
                    int L = wcslen(g_pLocalComType[i]->wzName)*3+3;
                    char* sz = new char[L];
                    memset(sz,0,L);
                    WszWideCharToMultiByte(CP_UTF8,0,g_pLocalComType[i]->wzName,-1,sz,L,NULL,NULL);
                    sprintf(szString,"%s.comtype '%s'",g_szAsmCodeIndent,ProperName(sz));
                    delete [] sz;
                }
                pc=&szString[strlen(szString)];
                if(g_fDumpTokens) sprintf(pc," /*%08X*/ ",tkImplementation);
                printLine(GUICookie,szString);
            }
        }
    }
}

void DumpComType(LocalComTypeDescr* pCTD, char* szString, void* GUICookie)
{
    if(g_fDumpTokens) sprintf(&szString[strlen(szString)],"/*%08X*/ ",pCTD->tkComTypeTok);
    if (IsTdPublic(pCTD->dwFlags))                   strcat(szString,"public ");
    if (IsTdNestedPublic(pCTD->dwFlags))             strcat(szString,"nested public ");
    if (IsTdNestedPrivate(pCTD->dwFlags))            strcat(szString,"nested private ");
    if (IsTdNestedFamily(pCTD->dwFlags))             strcat(szString,"nested family ");
    if (IsTdNestedAssembly(pCTD->dwFlags))           strcat(szString,"nested assembly ");
    if (IsTdNestedFamANDAssem(pCTD->dwFlags))        strcat(szString,"nested famandassem ");
    if (IsTdNestedFamORAssem(pCTD->dwFlags))         strcat(szString,"nested famorassem ");

    char* pc=&szString[strlen(szString)];
	{
		int L = wcslen(pCTD->wzName)*3+3;
		char* sz = new char[L];
		memset(sz,0,L);
		WszWideCharToMultiByte(CP_UTF8,0,pCTD->wzName,-1,sz,L,NULL,NULL);
		pc += sprintf(pc,"%s",ProperName(sz));
		delete [] sz;
	}
	if(strstr(szString,".export "))	sprintf(&szString[strlen(szString)],RstrA(IDS_E_DEPRDIR)," ");
	printLine(GUICookie,szString);

    sprintf(szString,"%s{",g_szAsmCodeIndent);
    printLine(GUICookie,szString);
    strcat(g_szAsmCodeIndent,"  ");
    DumpCustomAttributes(pCTD->tkComTypeTok, GUICookie);
    DumpImplementation(pCTD->tkImplementation,0xFFFFFFFF,szString,GUICookie);
	if(TypeFromToken(pCTD->tkImplementation) == mdtAssemblyRef)
	{
		sprintf(szString,"error: AssemblyRef as implementation of ExportedType");
		printError(GUICookie,szString);
	}
    if(RidFromToken(pCTD->tkTypeDef))
    {
        sprintf(szString,"%s.class 0x%08X",g_szAsmCodeIndent,pCTD->tkTypeDef);
        printLine(GUICookie,szString);
    }
    g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
    sprintf(szString,"%s}",g_szAsmCodeIndent);
    printLine(GUICookie,szString);
}


void DumpComTypes(void* GUICookie)
{
    mdExportedType  rComTypeTok[4096];
    ULONG           nComTypes;
    HCORENUM    hEnum=NULL;
    char            szString[4096];

	g_LocalComTypeNum = 0;
    if(SUCCEEDED(g_pAssemblyImport->EnumExportedTypes(&hEnum,rComTypeTok,4096,&nComTypes)))
    {
        if(nComTypes)
        {
            WCHAR       wzName[1024];
            ULONG       ulNameLen=0;
            DWORD       dwFlags;
            mdToken     tkImplementation;
            mdTypeDef   tkTypeDef;

            for(ULONG ix = 0; ix < nComTypes; ix++)
            {
                ulNameLen=0;
                if(SUCCEEDED(g_pAssemblyImport->GetExportedTypeProps(                    // S_OK or error.
                                                                rComTypeTok[ix],    // [IN] The ComType for which to get the properties.
                                                                wzName,             // [OUT] Buffer to fill with name.
                                                                1024,               // [IN] Size of buffer in wide chars.
                                                                &ulNameLen,         // [OUT] Actual # of wide chars in name.
                                                                &tkImplementation,  // [OUT] mdFile or mdAssemblyRef that provides the ComType.
                                                                &tkTypeDef,         // [OUT] TypeDef token within the file.
                                                                &dwFlags)))         // [OUT] Flags.
                {
                    LocalComTypeDescr* pCTD = new LocalComTypeDescr;
                    memset(pCTD,0,sizeof(LocalComTypeDescr));
                    pCTD->tkComTypeTok = rComTypeTok[ix];
                    pCTD->tkTypeDef = tkTypeDef;
					pCTD->tkImplementation = tkImplementation;
                    pCTD->wzName = new WCHAR[ulNameLen+1];
                    memcpy(pCTD->wzName,wzName,ulNameLen*sizeof(WCHAR));
					pCTD->wzName[ulNameLen] = 0;
                    pCTD->dwFlags = dwFlags;

                    g_pLocalComType[g_LocalComTypeNum] = pCTD;
                    g_LocalComTypeNum++;
                } //end if(OK(GetComTypeProps))
            }//end for(all com types)

            // now, print all "external" com types
            for(ix = 0; ix < nComTypes; ix++)
            {
				tkImplementation = g_pLocalComType[ix]->tkImplementation;
				// ComType of a nested class has its nester's ComType as implementation
				while(TypeFromToken(tkImplementation)==mdtExportedType)
				{
					for(unsigned k=0; k<g_LocalComTypeNum; k++)
					{
						if(g_pLocalComType[k]->tkComTypeTok == tkImplementation)
						{
							tkImplementation = g_pLocalComType[k]->tkImplementation;
							break;
						}
					}
					if(k==g_LocalComTypeNum) break;
				}
				// At this moment, tkImplementation is impl.of top nester
                if(RidFromToken(tkImplementation))
                {
                    sprintf(szString,"%s.class extern ",g_szAsmCodeIndent);
                    DumpComType(g_pLocalComType[ix],szString,GUICookie);
                    g_pLocalComType[ix]->tkTypeDef = 0;
                }
            }
        }//end if(nComTypes)
        g_pAssemblyImport->CloseEnum(hEnum);
    }//end if OK(EnumComTypes)
    else nComTypes=0;
}

void DumpManifestResources(void* GUICookie)
{
    mdManifestResource      rManResTok[4096];
    ULONG           nManRes = 0;
    HCORENUM    hEnum=NULL;
	BYTE*		pRes = NULL;
    if(SUCCEEDED(g_pAssemblyImport->EnumManifestResources(&hEnum,rManResTok,4096,&nManRes)))
    {
        if(nManRes)
        {
            WCHAR*      wzName;
            ULONG       ulNameLen=0;
            DWORD       dwFlags;
            char        szString[4096];
            mdToken     tkImplementation;
            DWORD       dwOffset;
            ULONG       nLocRes = 0;

            WCHAR wzFileName[2048];

            WszMultiByteToWideChar(CP_UTF8,0,g_szOutputFile,-1,wzFileName,1024);
            wzName = wcsrchr(wzFileName,'\\');
            if(wzName == NULL) wzName = wcsrchr(wzFileName,':');
            if(wzName == NULL) wzName = &wzFileName[0];
            else wzName++;

            for(ULONG ix = 0; ix < nManRes; ix++)
            {
                ulNameLen=0;
                if(SUCCEEDED(g_pAssemblyImport->GetManifestResourceProps(           // S_OK or error.
                                                                rManResTok[ix],     // [IN] The ManifestResource for which to get the properties.
                                                                wzName,             // [OUT] Buffer to fill with name.
                                                                1024,               // [IN] Size of buffer in wide chars.
                                                                &ulNameLen,         // [OUT] Actual # of wide chars in name.
                                                                &tkImplementation,  // [OUT] mdFile or mdAssemblyRef that provides the ComType.
                                                                &dwOffset,          // [OUT] Offset to the beginning of the resource within the file.
                                                                &dwFlags)))         // [OUT] Flags.
                {
                    sprintf(szString,"%s.mresource ",g_szAsmCodeIndent);
                    if(g_fDumpTokens) sprintf(&szString[strlen(szString)],"/*%08X*/ ",rManResTok[ix]);
                    if(IsMrPublic(dwFlags))     strcat(szString,"public ");
                    if(IsMrPrivate(dwFlags))    strcat(szString,"private ");

                    char* pc=&szString[strlen(szString)];
					wzName[ulNameLen]=0;

					int L = ulNameLen*3+3;
					char* sz = new char[L];
					memset(sz,0,L);
					WszWideCharToMultiByte(CP_UTF8,0,wzName,-1,sz,L,NULL,NULL);
					pc+=sprintf(pc,"%s",ProperName(sz));

                    printLine(GUICookie,szString);
                    sprintf(szString,"%s{",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                    strcat(g_szAsmCodeIndent,"  ");
                    DumpCustomAttributes(rManResTok[ix], GUICookie);
					if((tkImplementation == mdFileNil)&&(!(g_Mode & MODE_GUI))&&(g_pFile!=NULL)) // embedded resource -- dump as .resources file
					{
						if(pRes == NULL)
						{
							if (g_pPELoader->getVAforRVA((DWORD) g_CORHeader->Resources.VirtualAddress, (void **) &pRes) == FALSE)
							{
								printError(GUICookie,RstrA(IDS_E_IMPORTDATA));
							}
#if (0)
                            strcat(g_szAsmCodeIndent,"//  ");
                            sprintf(szString,"%sCORHeader.Resources: RVA=0x%X, Size=0x%X (%d)",g_szAsmCodeIndent,
                                 g_CORHeader->Resources.VirtualAddress,g_CORHeader->Resources.Size,
                                    g_CORHeader->Resources.Size);
                            printLine(GUICookie,szString);
                            sprintf(szString,"%s bytes = (",g_szAsmCodeIndent);
                            DumpByteArray(szString,pRes,g_CORHeader->Resources.Size,GUICookie);
                            printLine(GUICookie,szString);
                            g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-4] = 0;	
#endif
                        }
						if(pRes)
						{
							FILE  *pF;
							sprintf(szString,"%s// WARNING: managed resource file %s created",g_szAsmCodeIndent,ProperName(sz));
							if(g_fOnUnicode) pF = _wfopen(wzFileName,L"wb");
							else 
							{
								memset(sz,0,L);
								WszWideCharToMultiByte(CP_ACP,0,wzFileName,-1,sz,L,NULL,NULL);
								pF = fopen(sz,"wb");
							}
							if(pF)
							{
								printError(GUICookie,szString);
								DWORD L = *((DWORD*)(pRes+dwOffset));
								fwrite((pRes+dwOffset+sizeof(DWORD)),L,1,pF);
								fclose(pF);
#if (0)
                                strcat(g_szAsmCodeIndent,"//  ");
                                sprintf(szString,"%sOffset: %d, length: %d",g_szAsmCodeIndent,dwOffset,L);
                                printLine(GUICookie,szString);
                                sprintf(szString,"%s bytes = (",g_szAsmCodeIndent);
                                DumpByteArray(szString,pRes+dwOffset,L+sizeof(DWORD),GUICookie);
                                printLine(GUICookie,szString);
                                g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-4] = 0;
#endif
							}
						}
					}
                    else DumpImplementation(tkImplementation,dwOffset,szString,GUICookie);
					delete [] sz;
                    g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-2] = 0;
                    sprintf(szString,"%s}",g_szAsmCodeIndent);
                    printLine(GUICookie,szString);
                } //end if(OK(GetManifestResourceProps))
            }//end for(all manifest resources)
        }//end if(nManRes)
        g_pAssemblyImport->CloseEnum(hEnum);
    }//end if OK(EnumManifestResources)
    else nManRes=0;
}

IMetaDataAssemblyImport* GetAssemblyImport(void* GUICookie)
{
    IMetaDataAssemblyImport* pAssemblyImport = NULL;
    IMDInternalImport*       pImport = NULL;
    mdToken                 tkManifest;
    HRESULT                 hr;

    hr=g_pPubImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**) &pAssemblyImport);
    if(SUCCEEDED(hr))
    {
        mdAssemblyRef       rAsmRefTok[4096];
        HCORENUM    hEnum=NULL;
        ULONG   nAsmRefs = 0;   
        if(SUCCEEDED(pAssemblyImport->GetAssemblyFromScope(&tkManifest))) return pAssemblyImport;
        if(SUCCEEDED(pAssemblyImport->EnumAssemblyRefs(&hEnum,rAsmRefTok,4096,&nAsmRefs)))
        {
            pAssemblyImport->CloseEnum(hEnum);
            if(nAsmRefs) return pAssemblyImport;
        }
        pAssemblyImport->Release();
    }
    else
    {
        char szStr[256];
        sprintf(szStr,RstrA(IDS_E_MDAIMPORT),hr);
        printLine(GUICookie,szStr);
    }
    pAssemblyImport = NULL;
    // OK, let's do it hard way: check if the manifest is hidden somewhere else
    try
    {
        if(g_CORHeader->Resources.Size)
        {
            DWORD*  pdwSize = NULL;
            BYTE*   pbManifest = NULL;

            pbManifest = (BYTE*)(g_pPELoader->base() + (DWORD)g_CORHeader->Resources.VirtualAddress);
            pdwSize = (DWORD*)pbManifest;
            if(pdwSize && *pdwSize)
            {
                pbManifest += sizeof(DWORD);
                if (SUCCEEDED(hr = GetMetaDataInternalInterface(
                                    pbManifest, 
                                    *pdwSize, 
                                    ofRead, 
                                    IID_IMDInternalImport,
                                    (void **)&pImport)))
                {
                    if(FAILED(hr = GetMetaDataPublicInterfaceFromInternal(pImport, IID_IMetaDataAssemblyImport, 
                                                                    (void**)&pAssemblyImport)))
                    {
                        char szStr[256];
                        sprintf(szStr,Rstr(IDS_E_MDAFROMMDI),hr);
                        printLine(GUICookie,szStr);
                        pAssemblyImport = NULL;
                    }
                    else
                    {
                        mdAssemblyRef       rAsmRefTok[4096];
                        HCORENUM    hEnum=NULL;
                        ULONG   nAsmRefs = 0;   
                        if(FAILED(pAssemblyImport->GetAssemblyFromScope(&tkManifest))
                            && (FAILED(pAssemblyImport->EnumAssemblyRefs(&hEnum,rAsmRefTok,4096,&nAsmRefs))
                                || (nAsmRefs ==0))) 
                        {
                            pAssemblyImport->CloseEnum(hEnum);
                            pAssemblyImport->Release();
                            pAssemblyImport = NULL;
                        }
                    }
                    pImport->Release();
                }
                else
                {
                    char szStr[256];
                    sprintf(szStr,RstrA(IDS_E_MDIIMPORT),hr);
                    printLine(GUICookie,szStr);
                }
            }
        }
    } // end try
    catch(...) // if exception, it's screwed
    {
        if(pAssemblyImport) pAssemblyImport->Release();
        pAssemblyImport = NULL;
        if(pImport) pImport->Release();
    }
    return pAssemblyImport;
}

void DumpManifest(void* GUICookie)
{
    DumpModuleRefs(GUICookie);
    if(g_pAssemblyImport==NULL) g_pAssemblyImport = GetAssemblyImport(GUICookie);
    if(g_pAssemblyImport)
    {
        DumpAssemblyRefs(GUICookie);
        DumpAssembly(GUICookie,TRUE);
        DumpFiles(GUICookie);
        DumpComTypes(GUICookie);
        DumpManifestResources(GUICookie);
        //g_pAssemblyImport->Release();
    }
    else printLine(GUICookie,RstrA(IDS_E_NOMANIFEST));
    DumpScope(GUICookie);
	DumpVtable(GUICookie);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dres.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// dres.cpp
// 
// Win32 Resource extractor
//
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <utilcode.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "dasmenum.hpp"
#include "dasmgui.h"
#include "formatType.h"
#include "dis.h"
#include "resource.h"
#include "ILFormatter.h"
#include "OutString.h"
#include "utilcode.h" // for CQuickByte

#include "ceeload.h"
#include "DynamicArray.h"
extern IMAGE_COR20_HEADER *    g_CORHeader;
extern IMDInternalImport*      g_pImport;
extern PELoader * g_pPELoader;
extern IMetaDataImport*        g_pPubImport;
extern char g_szAsmCodeIndent[];

struct ResourceHeader
{
	DWORD	dwDataSize;
	DWORD	dwHeaderSize;
	DWORD	dwTypeID;
	DWORD	dwNameID;
	DWORD	dwDataVersion;
	WORD	wMemFlags;
	WORD	wLangID;
	DWORD	dwVersion;
	DWORD	dwCharacteristics;
	ResourceHeader() 
	{ 
		memset(this,0,sizeof(ResourceHeader)); 
		dwHeaderSize = sizeof(ResourceHeader);
		dwTypeID = dwNameID = 0xFFFF;
	};
};

struct ResourceNode
{
	ResourceHeader	ResHdr;
	IMAGE_RESOURCE_DATA_ENTRY DataEntry;
	ResourceNode(DWORD tid, DWORD nid, DWORD lid, PVOID ptr)
	{
		ResHdr.dwTypeID = (tid & 0x80000000) ? tid : (0xFFFF |((tid & 0xFFFF)<<16));
		ResHdr.dwNameID = (nid & 0x80000000) ? nid : (0xFFFF |((nid & 0xFFFF)<<16));
		ResHdr.wLangID = (WORD)lid;
		if(ptr) memcpy(&DataEntry,ptr,sizeof(IMAGE_RESOURCE_DATA_ENTRY));
		ResHdr.dwDataSize = DataEntry.Size;
	};
};

unsigned ulNumResNodes=0;
DynamicArray<ResourceNode*> rResNodePtr;

#define RES_FILE_DUMP_ENABLED

DWORD	DumpResourceToFile(WCHAR*	wzFileName)
{
    IMAGE_NT_HEADERS *pNTHeader = g_pPELoader->ntHeaders();
    IMAGE_OPTIONAL_HEADER *pOptHeader = &pNTHeader->OptionalHeader;
	DWORD	dwResDirRVA = pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
	DWORD	dwResDirSize = pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
	BYTE*	pbResBase;
	FILE*	pF = NULL;
	DWORD ret = 0;

	if(dwResDirRVA && dwResDirSize)
	{
#ifdef RES_FILE_DUMP_ENABLED
		ULONG L = wcslen(wzFileName)*3+3;
		char* szFileNameANSI = new char[L];
		memset(szFileNameANSI,0,L);
		WszWideCharToMultiByte(CP_ACP,0,wzFileName,-1,szFileNameANSI,L,NULL,NULL);
		pF = fopen(szFileNameANSI,"wb");
		delete [] szFileNameANSI;
 		if(pF)
#else
		if(TRUE)
#endif
		{
			if(g_pPELoader->getVAforRVA(dwResDirRVA, (void **) &pbResBase))
			{
				// First, pull out all resource nodes (tree leaves), see ResourceNode struct
				PIMAGE_RESOURCE_DIRECTORY pirdType = (PIMAGE_RESOURCE_DIRECTORY)pbResBase;
				PIMAGE_RESOURCE_DIRECTORY_ENTRY pirdeType = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pbResBase+sizeof(IMAGE_RESOURCE_DIRECTORY));
				DWORD	dwTypeID;
				unsigned short i,N = pirdType->NumberOfNamedEntries+pirdType->NumberOfIdEntries;
				
				for(i=0; i < N; i++, pirdeType++)
				{
					dwTypeID = pirdeType->Name;
					if(pirdeType->DataIsDirectory)
					{
						BYTE*	pbNameBase = pbResBase+pirdeType->OffsetToDirectory;
						PIMAGE_RESOURCE_DIRECTORY pirdName = (PIMAGE_RESOURCE_DIRECTORY)pbNameBase;
						PIMAGE_RESOURCE_DIRECTORY_ENTRY pirdeName = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pbNameBase+sizeof(IMAGE_RESOURCE_DIRECTORY));
						DWORD	dwNameID;
						unsigned short i,N = pirdName->NumberOfNamedEntries+pirdName->NumberOfIdEntries;
						
						for(i=0; i < N; i++, pirdeName++)
						{
							dwNameID = pirdeName->Name;
							if(pirdeName->DataIsDirectory)
							{
								BYTE*	pbLangBase = pbResBase+pirdeName->OffsetToDirectory;
								PIMAGE_RESOURCE_DIRECTORY pirdLang = (PIMAGE_RESOURCE_DIRECTORY)pbLangBase;
								PIMAGE_RESOURCE_DIRECTORY_ENTRY pirdeLang = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pbLangBase+sizeof(IMAGE_RESOURCE_DIRECTORY));
								DWORD	dwLangID;
								unsigned short i,N = pirdLang->NumberOfNamedEntries+pirdLang->NumberOfIdEntries;
								
								for(i=0; i < N; i++, pirdeLang++)
								{
									dwLangID = pirdeLang->Name;
									if(pirdeLang->DataIsDirectory)
									{
										_ASSERTE(!"Resource hierarchy exceeds three levels");
									}
									else rResNodePtr[ulNumResNodes++] = new ResourceNode(dwTypeID,dwNameID,dwLangID,pbResBase+pirdeLang->OffsetToData);
								}
							}
							else rResNodePtr[ulNumResNodes++] = new ResourceNode(dwTypeID,dwNameID,0,pbResBase+pirdeName->OffsetToData);					
						}
					}
					else rResNodePtr[ulNumResNodes++] = new ResourceNode(dwTypeID,0,0,pbResBase+pirdeType->OffsetToData);
				}
				// OK, all tree leaves are in ResourceNode structs, and ulNumResNodes ptrs are in rResNodePtr
#ifdef RES_FILE_DUMP_ENABLED
				// Dump them to pF
				if(ulNumResNodes)
				{
					BYTE* pbData;
					// Write dummy header
					ResourceHeader	*pRH = new ResourceHeader();
					fwrite(pRH,sizeof(ResourceHeader),1,pF);
					delete pRH;
					DWORD	dwFiller;
					BYTE	bNil[3] = {0,0,0};
					// For each resource write header and data
					for(i=0; i < ulNumResNodes; i++)
					{
						if(g_pPELoader->getVAforRVA(rResNodePtr[i]->DataEntry.OffsetToData, (void **) &pbData))
						{
							fwrite(&(rResNodePtr[i]->ResHdr),sizeof(ResourceHeader),1,pF);
							fwrite(pbData,rResNodePtr[i]->DataEntry.Size,1,pF);
							dwFiller = rResNodePtr[i]->DataEntry.Size & 3;
							if(dwFiller)
							{
								dwFiller = 4 - dwFiller;
								fwrite(bNil,dwFiller,1,pF);
							}
						}
						delete rResNodePtr[i];
					}
				}
#else
				// Dump to text, using wzFileName as GUICookie
				char szString[4096];
				void* GUICookie = (void*)wzFileName;
				BYTE* pbData;
				printLine(GUICookie,"");
				sprintf(szString,"// ========== Win32 Resource Entries (%d) ========",ulNumResNodes);
				for(i=0; i < ulNumResNodes; i++)
				{
					printLine(GUICookie,"");
					sprintf(szString,"// Res.# %d Type=0x%X Name=0x%X Lang=0x%X DataOffset=0x%X DataLength=%d",
						i+1,
						rResNodePtr[i]->ResHdr.dwTypeID,
						rResNodePtr[i]->ResHdr.dwNameID,
						rResNodePtr[i]->ResHdr.wLangID,
						rResNodePtr[i]->DataEntry.OffsetToData,
						rResNodePtr[i]->DataEntry.Size);
					printLine(GUICookie,szString);
					if(g_pPELoader->getVAforRVA(rResNodePtr[i]->DataEntry.OffsetToData, (void **) &pbData))
					{
						strcat(g_szAsmCodeIndent,"//  ");
						strcpy(szString,g_szAsmCodeIndent);
						DumpByteArray(szString,pbData,rResNodePtr[i]->DataEntry.Size,GUICookie);
						printLine(GUICookie,szString);
						g_szAsmCodeIndent[strlen(g_szAsmCodeIndent)-4] = 0;
					}
					delete rResNodePtr[i];
				}
#endif
				ulNumResNodes = 0;
				ret = 1;
			}// end if got ptr to resource
			else ret = 0xFFFFFFFF;
			if(pF) fclose(pF);
		}// end if file opened
		else ret = 0xEFFFFFFF;
	} // end if there is resource
	else ret = 0;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\dynamicarray.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// DynamicArray.h


#include "memory.h"

const int START_SIZE = 24 ;
const int MIN_SIZE = 8 ;

template <class T>
class DynamicArray
{
	public:
		DynamicArray(int iSize = START_SIZE) ;
		~DynamicArray() ;
		T& operator[](int i) ;
		bool Error() ;
	private:
		T* m_pArray ;
		int m_iMemSize ;
		int m_iArraySize ;
		bool m_bError ;
};

/************************************************************************
 *																		*
 *	Default constructor. User has option to pass in the size of the		*
 *	initial array.														*
 *																		*
 ************************************************************************/
template<class T> DynamicArray<T>::DynamicArray(int iSize)
{
	if( iSize < MIN_SIZE )
	{
		iSize = MIN_SIZE ;
	}
	m_pArray = new T[iSize] ;
	m_iMemSize = iSize ;
	m_iArraySize = 0 ;
	m_bError = false ;
}

/************************************************************************
 *																		*
 *	Destructor. All it really has to do is delete the array.			*
 *																		*
 ************************************************************************/
template<class T> DynamicArray<T>::~DynamicArray()
{
	if( m_pArray )
	{
		delete [] m_pArray ;
	}
}

/************************************************************************
 *																		*
 *	operator [] to work on the left or right side of the equation.		*
 *																		*
 ************************************************************************/
template<class T> T& DynamicArray<T>::operator [](int iIndex)
{
	if( iIndex < 0 )
	{
		// Error, set error value to true and return the first element of the array
		m_bError = true ;
		return m_pArray[0] ;
	}
	else if ( iIndex >= m_iArraySize )
	{
		if( iIndex >= m_iMemSize )
		{
			int iNewSize ;
			if( iIndex >= m_iMemSize * 2 )
			{
				iNewSize = iIndex + 1 ;
			}
			else
			{
				iNewSize = m_iMemSize * 2 ;
			}

			// We need to allocate more memory
			T* pTmp = new T[iNewSize] ;
			memcpy(pTmp, m_pArray, m_iMemSize * sizeof(T)) ;
			delete [] m_pArray ;
			m_pArray = pTmp ;
			// Record the new memory size
			m_iMemSize = iNewSize ;
		}

		//ZeroMemory(&m_pArray[iIndex], sizeof(T)) ;

		++m_iArraySize ;
	}

	return m_pArray[iIndex] ;
}

template<class T> bool DynamicArray<T>::Error()
{
	return m_bError ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\formattype.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef _formatType_h
#define _formatType_h

#include "cor.h"			
#include "corpriv.h"					// for IMDInternalImport

struct ParamDescriptor
{
	char*	name;
	mdToken tok;
	DWORD	attr;
};

char* DumpMarshaling(IMDInternalImport* pImport, char* szString, mdToken tok);
char* DumpParamAttr(char* szString, DWORD dwAttr);

void appendStr(CQuickBytes *out, const char* str);
void insertStr(CQuickBytes *out, const char* str);

const char* PrettyPrintSig(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
	unsigned typeLen,					// the lenght of 'typePtr' 
    const char* name,                   // can be "", the name of the method for this sig 0 means local var sig 
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI,           // ptr to IMDInternalImport class with ComSig
	const char* inlabel);					// prefix for names (NULL if no names required)

const char* PrettyPrintClass(
    CQuickBytes *out,                   // where to put the pretty printed string   
	mdToken tk,					 		// The class token to look up 
    IMDInternalImport *pIMDI);          // ptr to IMDInternalImport class with ComSig

bool IsNameToQuote(const char *name);
char* ProperName(char* name);
//-------------------------------------------------------------------------------
// Protection against null names
extern char* szStdNamePrefix[]; //declared in formatType.cpp
#define MAKE_NAME_IF_NONE(psz, tk) { if(!(psz && *psz)) { char* sz = (char*)_alloca(16); \
sprintf(sz,"$%s$%X",szStdNamePrefix[tk>>24],tk&0x00FFFFFF); psz = sz; } }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\formattype.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/******************************************************************************/
/*                                 formatType.cpp	                          */
/******************************************************************************/

#include "formatType.h"
#include "utilcode.h"					// for CQuickBytes 

BOOL					g_fQuoteAllNames = FALSE; // used by ILDASM
BOOL                    g_fDumpTokens = FALSE;	  // used by ILDASM
BOOL                    g_fUseProperName = FALSE; // used by ILDASM
LPCSTR					*rAsmRefName = NULL;	  // used by ILDASM
ULONG					ulNumAsmRefs = 0;		  // used by ILDASM

// Protection against null names, used by ILDASM
char* szStdNamePrefix[] = {"MO","TR","TD","","FD","","MD","","PA","II","MR","","CA","","PE","","","SG","","","EV",
"","","PR","","","MOR","TS","","","","","AS","","","AR","","","FL","ET","MAR"};

static PCCOR_SIGNATURE PrettyPrintType(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI);          // ptr to IMDInternal class with ComSig

const PCCOR_SIGNATURE PrettyPrintSignature(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
	unsigned typeLen,					// the lenght of 'typePtr' 
    const char* name,                   // can be "", the name of the method for this sig 0 means local var sig 
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI,           // ptr to IMDInternalImport class with ComSig
	const char* inlabel);				// prefix for names (NULL if no names required)

//*****************************************************************************
// Parse a length, return the length, size of the length.
//*****************************************************************************
ULONG GetLength(			// Length or -1 on error.
	void const	*pData, 				// First byte of length.
	int			*pSizeLen)				// Put size of length here, if not 0.
{
	BYTE const	*pBytes = reinterpret_cast<BYTE const*>(pData);

	if(pBytes)
	{
		if ((*pBytes & 0x80) == 0x00)		// 0??? ????
		{
			if (pSizeLen) *pSizeLen = 1;
			return (*pBytes & 0x7f);
		}

		if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
		{
			if (pSizeLen) *pSizeLen = 2;
			return ((*pBytes & 0x3f) << 8 | *(pBytes+1));
		}

		if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
		{
			if (pSizeLen) *pSizeLen = 4;
			return ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
		}
	}
	if(pSizeLen) *pSizeLen = 0;
	return 0;
}


/******************************************************************************/
static char* asString(CQuickBytes *out) {
    SIZE_T oldSize = out->Size();
    out->ReSize(oldSize + 1);   
    char* cur = &((char*) out->Ptr())[oldSize]; 
    *cur = 0;   
    out->ReSize(oldSize);   		// Don't count the null character
    return((char*) out->Ptr()); 
}

void appendStr(CQuickBytes *out, const char* str) {
    unsigned len = (unsigned)strlen(str); 
    SIZE_T oldSize = out->Size();
    out->ReSize(oldSize + len); 
    char* cur = &((char*) out->Ptr())[oldSize]; 
    memcpy(cur, str, len);  
        // Note no trailing null!   
}

void appendChar(CQuickBytes *out, char chr) {
    SIZE_T oldSize = out->Size();
    out->ReSize(oldSize + 1); 
    ((char*) out->Ptr())[oldSize] = chr; 
        // Note no trailing null!   
}

void insertStr(CQuickBytes *out, const char* str) {
    unsigned len = (unsigned)strlen(str); 
    SIZE_T oldSize = out->Size();
    out->ReSize(oldSize + len); 
    char* cur = &((char*) out->Ptr())[len];
	memmove(cur,out->Ptr(),oldSize);
    memcpy(out->Ptr(), str, len);  
        // Note no trailing null!   
}

static void appendStrNum(CQuickBytes *out, int num) {
    char buff[16];  
    sprintf(buff, "%d", num);   
    appendStr(out, buff);   
}

/******************************************************************************/
// Function: convert spec.symbols to esc sequences and single-quote if necessary
char* ProperName(char* name)
{
	static CQuickBytes buff;
    if(g_fUseProperName)
    {
    	char *pcn,*ret;
        BOOL fQuoted;
    	if(name)
    	{
    		if(*name)
    		{
    			pcn = name;
                buff.ReSize(0);
                fQuoted = IsNameToQuote(name);
    			if(fQuoted) appendChar(&buff,'\'');
    			for(pcn=name; *pcn; pcn++) 
                {
    				switch(*pcn)
    				{
    					case '\t': appendChar(&buff,'\\'); appendChar(&buff,'t'); break;
    					case '\n': appendChar(&buff,'\\'); appendChar(&buff,'n'); break;
    					case '\b': appendChar(&buff,'\\'); appendChar(&buff,'b'); break;
    					case '\r': appendChar(&buff,'\\'); appendChar(&buff,'r'); break;
    					case '\f': appendChar(&buff,'\\'); appendChar(&buff,'f'); break;
    					case '\v': appendChar(&buff,'\\'); appendChar(&buff,'v'); break;
    					case '\a': appendChar(&buff,'\\'); appendChar(&buff,'a'); break;
    					case '\\': appendChar(&buff,'\\'); appendChar(&buff,'\\'); break;
    					case '\'': appendChar(&buff,'\\'); appendChar(&buff,'\''); break;
    					case '\"': appendChar(&buff,'\\'); appendChar(&buff,'\"'); break;
    					default: appendChar(&buff,*pcn);
    				}
    			}
    			if(fQuoted) appendChar(&buff,'\'');
    			ret = asString(&buff);
    		}
    		else ret = "";
    	}
    	else ret = NULL;
        return ret;
    }
    return name;
}
/******************************************************************************/
const char* PrettyPrintSig(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
	unsigned typeLen,					// the lenght of 'typePtr' 
    const char* name,                   // can be "", the name of the method for this sig 0 means local var sig 
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI,           // ptr to IMDInternalImport class with ComSig
	const char* inlabel)				// prefix for names (NULL if no names required)
{
	PrettyPrintSignature(typePtr, typeLen, name, out, pIMDI, inlabel);
    return(asString(out));  
}

/********************************************************************************/
// Converts a com signature to a printable signature.
// Note that return value is pointing at the CQuickBytes buffer, 

const PCCOR_SIGNATURE PrettyPrintSignature(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
	unsigned typeLen,					// the lenght of 'typePtr' 
    const char* name,                   // can be "", the name of the method for this sig 0 means local var sig 
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI,           // ptr to IMDInternalImport class with ComSig
	const char* inlabel)				// prefix for names (NULL if no names required)
{
    unsigned numArgs;   
    PCCOR_SIGNATURE typeEnd = typePtr + typeLen;
	unsigned ixArg= 0; //arg index
	char argname[1024];
	char label[16];
	ParamDescriptor* pszArgName = NULL; // ptr to array of names (if provided by debug info)

	if(inlabel && *inlabel) // check for *inlabel is totally unnecessary, added to pacify the PREFIX
	{
		strcpy(label,inlabel);
		ixArg = label[strlen(label)-1] - '0';
		label[strlen(label)-1] = 0;
		if(label[0] == '@') // it's pointer!
		{
#ifdef _WIN64
			pszArgName = (ParamDescriptor*)atoi64(&label[1]);
#else // !_WIN64
			pszArgName = (ParamDescriptor*)(size_t)atoi(&label[1]);
#endif // _WIN64
		}
	}

    if (name != 0)        // 0 means a local var sig  
    {
            // get the calling convention out   
        unsigned callConv = CorSigUncompressData(typePtr);  

        if (isCallConv(callConv, IMAGE_CEE_CS_CALLCONV_FIELD))
        {
            typePtr = PrettyPrintType(typePtr, out, pIMDI);   
            if (*name)    
            {   
                appendStr(out, " ");
				appendStr(out, name);   
            }   
            return(typePtr);  
        }

        if (callConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)   
            appendStr(out, "explicit ");    

        if (callConv & IMAGE_CEE_CS_CALLCONV_HASTHIS)   
            appendStr(out, "instance ");    

        static char* callConvNames[8] = {   
            "", 
            "unmanaged cdecl ", 
            "unmanaged stdcall ",   
            "unmanaged thiscall ",  
            "unmanaged fastcall ",  
            "vararg ",   
            "<error> "   
            "<error> "   
            };  
        appendStr(out, callConvNames[callConv & 7]);    

        numArgs = CorSigUncompressData(typePtr);    
            // do return type   
		if(pszArgName)
		{
			argname[0] = 0;
			DumpParamAttr(argname,pszArgName[ixArg+numArgs].attr);
			appendStr(out,argname);
		}
        typePtr = PrettyPrintType(typePtr, out, pIMDI); 

		if(pszArgName)
		{
			argname[0] = ' '; argname[1] = 0;
			DumpMarshaling(pIMDI,argname,pszArgName[ixArg+numArgs].tok);
			appendStr(out,argname);
		}
		if(*name != 0)
		{
			appendChar(out, ' ');    
			appendStr(out, name);   
		}
    }
    else    
        numArgs = CorSigUncompressData(typePtr);    

    appendChar(out, '(');    

	bool needComma = false;
	while(typePtr < typeEnd) 
	{
		if(name) // printing the arguments
		{
			if (*typePtr == ELEMENT_TYPE_SENTINEL) 
			{
				if (needComma)
					appendChar(out, ',');    
				appendStr(out, "...");    
				typePtr++;
			}
			else 
			{
				if (numArgs <= 0)
					break;
				if (needComma)
					appendChar(out, ',');    
				if(pszArgName)
				{
					argname[0] = 0;
					DumpParamAttr(argname,pszArgName[ixArg].attr);
					appendStr(out,argname);
				}
				typePtr = PrettyPrintType(typePtr, out, pIMDI); 
				if(inlabel)
				{
					if(pszArgName)
					{
						argname[0] = ' '; argname[1] = 0;
						DumpMarshaling(pIMDI,argname,pszArgName[ixArg].tok);
						strcat(argname, ProperName(pszArgName[ixArg++].name));
					}
					else sprintf(argname," %s_%d",label,ixArg++);
					appendStr(out,argname);
				}
				--numArgs;  
			}
		}
		else // printing local vars
		{
			if (numArgs <= 0)
				break;
			if(pszArgName)
			{
				if(pszArgName[ixArg].attr == 0xFFFFFFFF)
				{
					CQuickBytes fake_out;
					typePtr = PrettyPrintType(typePtr, &fake_out, pIMDI); 
					ixArg++;
					numArgs--;
					continue;
				}
			}
			if (needComma)
                appendChar(out, ',');    
			if(pszArgName)
			{
				sprintf(argname,"[%d] ",pszArgName[ixArg].attr);
				appendStr(out,argname);
			}
			typePtr = PrettyPrintType(typePtr, out, pIMDI); 
			if(inlabel)
			{
				if(pszArgName)
				{
					sprintf(argname," %s",ProperName(pszArgName[ixArg++].name));
				}
				else sprintf(argname," %s_%d",label,ixArg++);
				appendStr(out,argname);
			}
			--numArgs;  
		}
		needComma = true;
    }
		// Have we finished printing all the arguments?
	if (numArgs > 0) {
		appendStr(out, " <SIG ENDED PREMATURELY>");    
	}
		
    appendChar(out, ')');    
	return(typePtr);
}

/******************************************************************************/
// pretty prints 'type' to the buffer 'out' returns a poitner to the next type, 
// or 0 on a format failure 

static PCCOR_SIGNATURE PrettyPrintType(
    PCCOR_SIGNATURE typePtr,            // type to convert,     
    CQuickBytes *out,                   // where to put the pretty printed string   
    IMDInternalImport *pIMDI)           // ptr to IMDInternal class with ComSig
{
    mdToken  tk;    
    const char* str;    
	//bool isValueArray;
	int typ;
	CQuickBytes tmp;
	CQuickBytes Appendix;
	BOOL Reiterate;

	do {
		Reiterate = FALSE;
		switch(typ = *typePtr++) {    
			case ELEMENT_TYPE_VOID          :   
				str = "void"; goto APPEND;  
			case ELEMENT_TYPE_BOOLEAN       :   
				str = "bool"; goto APPEND;  
			case ELEMENT_TYPE_CHAR          :   
				str = "char"; goto APPEND; 
			case ELEMENT_TYPE_I1            :   
				str = "int8"; goto APPEND;  
			case ELEMENT_TYPE_U1            :   
				str = "unsigned int8"; goto APPEND; 
			case ELEMENT_TYPE_I2            :   
				str = "int16"; goto APPEND; 
			case ELEMENT_TYPE_U2            :   
				str = "unsigned int16"; goto APPEND;    
			case ELEMENT_TYPE_I4            :   
				str = "int32"; goto APPEND; 
			case ELEMENT_TYPE_U4            :   
				str = "unsigned int32"; goto APPEND;    
			case ELEMENT_TYPE_I8            :   
				str = "int64"; goto APPEND; 
			case ELEMENT_TYPE_U8            :   
				str = "unsigned int64"; goto APPEND;    
			case ELEMENT_TYPE_R4            :   
				str = "float32"; goto APPEND;   
			case ELEMENT_TYPE_R8            :   
				str = "float64"; goto APPEND;   
			case ELEMENT_TYPE_U             :   
				str = "native unsigned int"; goto APPEND;   
			case ELEMENT_TYPE_I             :   
				str = "native int"; goto APPEND;    
			case ELEMENT_TYPE_R             :   
				str = "native float"; goto APPEND;  
			case ELEMENT_TYPE_OBJECT        :   
				str = "object"; goto APPEND;    
			case ELEMENT_TYPE_STRING        :   
				str = "string"; goto APPEND;    
			case ELEMENT_TYPE_TYPEDBYREF        :   
				str = "typedref"; goto APPEND;    
			APPEND: 
				appendStr(out, str);    
				break;  

			case ELEMENT_TYPE_VALUETYPE    :   
				str = "valuetype ";   
				goto DO_CLASS;  
			case ELEMENT_TYPE_CLASS         :   
				str = "class "; 
				goto DO_CLASS;  

			DO_CLASS:
				appendStr(out, str);
				typePtr += CorSigUncompressToken(typePtr, &tk); 
                _ASSERTE(!IsNilToken(tk) && "Nil token in signature");
				PrettyPrintClass(out, tk, pIMDI);
				break;  

			case ELEMENT_TYPE_SZARRAY    :   
				insertStr(&Appendix,"[]");
				Reiterate = TRUE;
				break;

			/* uncomment when and if this type is supported by the Runtime
			case ELEMENT_TYPE_VALUEARRAY    :   
				isValueArray = true; goto DO_ARRAY;
			DO_ARRAY:
				{   
				unsigned bound = CorSigUncompressData(typePtr); 

				if (isValueArray)
					insertStr(&Appendix," value");
					
				char buff[32];  
				sprintf(buff, "[%d]", bound);   
				insertStr(&Appendix,buff);
				Reiterate = TRUE;
				} break;
			*/
			case ELEMENT_TYPE_ARRAY       :   
				{   
				typePtr = PrettyPrintType(typePtr, out, pIMDI); 
				unsigned rank = CorSigUncompressData(typePtr);  
					// TODO what is the syntax for the rank 0 case? 
				if (rank == 0) {
					appendStr(out, "[BAD: RANK == 0!]");
				}
				else {
					_ASSERTE(rank != 0);    
					int* lowerBounds = (int*) _alloca(sizeof(int)*2*rank);  
					int* sizes       = &lowerBounds[rank];  
					memset(lowerBounds, 0, sizeof(int)*2*rank); 
					
					unsigned numSizes = CorSigUncompressData(typePtr);  
					_ASSERTE(numSizes <= rank); 
					for(unsigned i =0; i < numSizes; i++)   
						sizes[i] = CorSigUncompressData(typePtr);   
					
					unsigned numLowBounds = CorSigUncompressData(typePtr);  
					_ASSERTE(numLowBounds <= rank); 
					for(i = 0; i < numLowBounds; i++)   
						typePtr+=CorSigUncompressSignedInt(typePtr,&lowerBounds[i]); 
					
					appendChar(out, '[');    
					if (rank == 1 && numSizes == 0 && numLowBounds == 0)
						appendStr(out, "...");  
					else {
						for(i = 0; i < rank; i++)   
						{   
							//if (sizes[i] != 0 || lowerBounds[i] != 0)   
							{   
								if (lowerBounds[i] == 0 && i < numSizes)    
									appendStrNum(out, sizes[i]);    
								else    
								{   
									if(i < numLowBounds)
									{
										appendStrNum(out, lowerBounds[i]);  
										appendStr(out, "...");  
										if (/*sizes[i] != 0 && */i < numSizes)  
											appendStrNum(out, lowerBounds[i] + sizes[i] - 1);   
									}
								}   
							}   
							if (i < rank-1) 
                                appendChar(out, ',');    
						}   
					}
					appendChar(out, ']');    
				}
				} break;    

			case ELEMENT_TYPE_VAR        :   
                appendChar(out, '!');    
				appendStrNum(out, CorSigUncompressData(typePtr));
				break;

			case ELEMENT_TYPE_FNPTR :   
				appendStr(out, "method ");  
				typePtr = PrettyPrintSignature(typePtr, 0x7FFFFFFF, "*", out, pIMDI, NULL);
				break;

				// Modifiers or depedant types  
			case ELEMENT_TYPE_CMOD_OPT	:
				str = " modopt("; goto ADDCLASSTOCMOD;	
			case ELEMENT_TYPE_CMOD_REQD	:
				str = " modreq(";
			ADDCLASSTOCMOD:
				typePtr += CorSigUncompressToken(typePtr, &tk); 
                _ASSERTE(!IsNilToken(tk) && "Nil token in custom modifier");
				tmp.ReSize(0);
				appendStr(&tmp, str);
				PrettyPrintClass(&tmp, tk, pIMDI);
                appendChar(&tmp, ')');    
				str = (const char *) asString(&tmp);
				goto MODIFIER;	
			case ELEMENT_TYPE_PINNED	:
				str = " pinned"; goto MODIFIER;	
			case ELEMENT_TYPE_PTR           :   
				str = "*"; goto MODIFIER;   
			case ELEMENT_TYPE_BYREF         :   
				str = "&"; goto MODIFIER;   
			MODIFIER:
				insertStr(&Appendix, str);    
				Reiterate = TRUE;
				break;  

			default:    
			case ELEMENT_TYPE_SENTINEL      :   
			case ELEMENT_TYPE_END           :   
				//_ASSERTE(!"Unknown Type");
				if(typ)
				{
					char sz[64];
					sprintf(sz,"/* UNKNOWN TYPE (0x%X)*/",typ);
					appendStr(out, sz);
				}
				break;  
		} // end switch
	} while(Reiterate);
	appendStr(out,asString(&Appendix));
    return(typePtr);    
}

/******************************************************************/
const char* PrettyPrintClass(
    CQuickBytes *out,                   // where to put the pretty printed string   
	mdToken tk,					 		// The class token to look up 
    IMDInternalImport *pIMDI)           // ptr to IMDInternalImport class with ComSig
{
	switch(TypeFromToken(tk))
	{
		case mdtTypeRef:
		case mdtTypeDef:
			{
				const char *nameSpace = 0;  
				const char *name = 0;
				mdToken tkEncloser;
				
				if (TypeFromToken(tk) == mdtTypeRef)
				{
					tkEncloser = pIMDI->GetResolutionScopeOfTypeRef(tk);
					pIMDI->GetNameOfTypeRef(tk, &nameSpace, &name);
				}
				else 
				{
					if(FAILED(pIMDI->GetNestedClassProps(tk,&tkEncloser))) tkEncloser = 0;
					pIMDI->GetNameOfTypeDef(tk, &name, &nameSpace);
				}
				MAKE_NAME_IF_NONE(name,tk);
				if(RidFromToken(tkEncloser))
				{
					PrettyPrintClass(out,tkEncloser,pIMDI);
					if (TypeFromToken(tkEncloser) == mdtTypeRef || TypeFromToken(tkEncloser) == mdtTypeDef)
					{
                        appendChar(out, '/');    
						nameSpace = ""; //don't print namespaces for nested classes!
					}
				}
				if (nameSpace && *nameSpace) {
					appendStr(out, ProperName((char*)nameSpace));  
					appendChar(out, '.');    
				}

				appendStr(out, ProperName((char*)name));   
				if(g_fDumpTokens)
				{
					char tmp[16];
					sprintf(tmp,"/* %08X */",tk);
					appendStr(out,tmp);
				}
			}
			break;

		case mdtAssemblyRef:
			{
				LPCSTR	szName = NULL;
				if(rAsmRefName && (RidFromToken(tk) <= ulNumAsmRefs)) szName = rAsmRefName[RidFromToken(tk)-1];
				else pIMDI->GetAssemblyRefProps(tk,NULL,NULL,&szName,NULL,NULL,NULL,NULL);
				if(szName && *szName)
				{
					appendChar(out, '[');    
					appendStr(out,ProperName((char*)szName));
					if(g_fDumpTokens)
					{
						char tmp[16];
						sprintf(tmp,"/* %08X */",tk);
						appendStr(out,tmp);
					}
					appendChar(out, ']');    
				}
			}
			break;
		case mdtAssembly:
			{
				LPCSTR	szName = NULL;
				pIMDI->GetAssemblyProps(tk,NULL,NULL,NULL,&szName,NULL,NULL);
				if(szName && *szName)
				{
					appendChar(out, '[');    
					appendStr(out,ProperName((char*)szName));
					if(g_fDumpTokens)
					{
						char tmp[16];
						sprintf(tmp,"/* %08X */",tk);
						appendStr(out,tmp);
					}
					appendChar(out, ']');    
				}
			}
			break;
		case mdtModuleRef:
			{
				LPCSTR	szName = NULL;
				pIMDI->GetModuleRefProps(tk,&szName);
				if(szName && *szName)
				{
					appendStr(out,"[.module ");
					appendStr(out,ProperName((char*)szName));
					if(g_fDumpTokens)
					{
						char tmp[16];
						sprintf(tmp,"/* %08X */",tk);
						appendStr(out,tmp);
					}
					appendChar(out, ']');    
				}
			}
			break;

		case mdtTypeSpec:
			{
				ULONG cSig;
				PCCOR_SIGNATURE sig = pIMDI->GetSigFromToken(tk, &cSig);
				PrettyPrintType(sig, out, pIMDI);
			}
			break;
	}
	return(asString(out));
}

char* DumpMarshaling(IMDInternalImport* pImport, char* szString, mdToken tok)
{
	PCCOR_SIGNATURE pSigNativeType;
	ULONG			cbNativeType;
	char*			szptr = &szString[strlen(szString)];
	if(RidFromToken(tok) && SUCCEEDED(pImport->GetFieldMarshal(				// return error if no native type associate with the token
											tok,						// [IN] given fielddef
											&pSigNativeType,	// [OUT] the native type signature
											&cbNativeType)))	// [OUT] the count of bytes of *ppvNativeType
	{
        ULONG cbCur = 0;
        ULONG ulData;
		char*	sz;
		BOOL  fAddAsterisk = FALSE, fAddBrackets = FALSE;

		szptr+=sprintf(szptr," marshal(");
        while (cbCur < cbNativeType)
        {
			ulData = NATIVE_TYPE_MAX;
            cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
            switch (ulData)
            {
			case NATIVE_TYPE_VOID:		sz = " void"; break;
			case NATIVE_TYPE_BOOLEAN:	sz = " bool"; break;
			case NATIVE_TYPE_I1:		sz = " int8"; break;
			case NATIVE_TYPE_U1:		sz = " unsigned int8"; break;
			case NATIVE_TYPE_I2:		sz = " int16"; break;
			case NATIVE_TYPE_U2:		sz = " unsigned int16"; break;
			case NATIVE_TYPE_I4:		sz = " int32"; break;
			case NATIVE_TYPE_U4:		sz = " unsigned int32"; break;
			case NATIVE_TYPE_I8:		sz = " int64"; break;
			case NATIVE_TYPE_U8:		sz = " unsigned int64"; break;
			case NATIVE_TYPE_R4:		sz = " float32"; break;
			case NATIVE_TYPE_R8:		sz = " float64"; break;
			case NATIVE_TYPE_SYSCHAR:	sz = " syschar"; break;
			case NATIVE_TYPE_VARIANT:	sz = " variant"; break;
			case NATIVE_TYPE_CURRENCY:	sz = " currency"; break;
			case NATIVE_TYPE_PTR:		sz = ""; fAddAsterisk = TRUE; break;
			case NATIVE_TYPE_DECIMAL:	sz = " decimal"; break;
			case NATIVE_TYPE_DATE:		sz = " date"; break;
			case NATIVE_TYPE_BSTR:		sz = " bstr"; break;
			case NATIVE_TYPE_LPSTR:		sz = " lpstr"; break;
			case NATIVE_TYPE_LPWSTR:	sz = " lpwstr"; break;
			case NATIVE_TYPE_LPTSTR:	sz = " lptstr"; break;
			case NATIVE_TYPE_OBJECTREF: sz = " objectref"; break;
			case NATIVE_TYPE_IUNKNOWN:	sz = " iunknown"; break;
			case NATIVE_TYPE_IDISPATCH: sz = " idispatch"; break;
			case NATIVE_TYPE_STRUCT:	sz = " struct"; break;
			case NATIVE_TYPE_INTF:		sz = " interface"; break;
			case NATIVE_TYPE_ERROR:		sz = " error"; break;
			case NATIVE_TYPE_SAFEARRAY: 
				sz = "";
				szptr+=sprintf(szptr," safearray");
				ulData = VT_EMPTY;
				if (cbCur < cbNativeType)
				{
					cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
				}
				switch(ulData & VT_TYPEMASK)
				{
					case VT_EMPTY:				sz=""; break;
					case VT_NULL:				sz=" null"; break;
					case VT_VARIANT:			sz=" variant"; break;
					case VT_CY:					sz=" currency"; break;
					case VT_VOID:				sz=" void"; break;
					case VT_BOOL:				sz=" bool"; break;
					case VT_I1:					sz=" int8"; break;
					case VT_I2:					sz=" int16"; break;
					case VT_I4:					sz=" int32"; break;
					case VT_I8:					sz=" int64"; break;
					case VT_R4:					sz=" float32"; break;
					case VT_R8:					sz=" float64"; break;
					case VT_UI1:				sz=" unsigned int8"; break;
					case VT_UI2:				sz=" unsigned int16"; break;
					case VT_UI4:				sz=" unsigned int32"; break;
					case VT_UI8:				sz=" unsigned int64"; break;
					case VT_PTR:				sz=" *"; break;
					case VT_DECIMAL:			sz=" decimal"; break;
					case VT_DATE:				sz=" date"; break;
					case VT_BSTR:				sz=" bstr"; break;
					case VT_LPSTR:				sz=" lpstr"; break;
					case VT_LPWSTR:				sz=" lpwstr"; break;
					case VT_UNKNOWN:			sz=" iunknown"; break;
					case VT_DISPATCH:			sz=" idispatch"; break;
					case VT_SAFEARRAY:			sz=" safearray"; break;
					case VT_INT:				sz=" int"; break;
					case VT_UINT:				sz=" unsigned int"; break;
					case VT_ERROR:				sz=" error"; break;
					case VT_HRESULT:			sz=" hresult"; break;
					case VT_CARRAY:				sz=" carray"; break;
					case VT_USERDEFINED:		sz=" userdefined"; break;
					case VT_RECORD:				sz=" record"; break;
					case VT_FILETIME:			sz=" filetime"; break;
					case VT_BLOB:				sz=" blob"; break;
					case VT_STREAM:				sz=" stream"; break;
					case VT_STORAGE:			sz=" storage"; break;
					case VT_STREAMED_OBJECT:	sz=" streamed_object"; break;
					case VT_STORED_OBJECT:		sz=" stored_object"; break;
					case VT_BLOB_OBJECT:		sz=" blob_object"; break;
					case VT_CF:					sz=" cf"; break;
					case VT_CLSID:				sz=" clsid"; break;
					default:					sz=NULL; break;
				}
				if(sz) szptr+=sprintf(szptr,sz);
				else szptr+=sprintf(szptr," <ILLEGAL VARIANT TYPE 0x%X>",ulData & VT_TYPEMASK);
				sz="";
				switch(ulData & (~VT_TYPEMASK))
				{
					case VT_ARRAY: sz = "[]"; break;
					case VT_VECTOR: sz = " vector"; break;
					case VT_BYREF: sz = "&"; break; 
					case VT_BYREF|VT_ARRAY: sz = "&[]"; break; 
					case VT_BYREF|VT_VECTOR: sz = "& vector"; break; 
					case VT_ARRAY|VT_VECTOR: sz = "[] vector"; break; 
					case VT_BYREF|VT_ARRAY|VT_VECTOR: sz = "&[] vector"; break; 
				}
				szptr+=sprintf(szptr,sz);
				sz="";

				// Extract the user	defined	sub	type name.
                if (cbCur < cbNativeType)
                {
					LPUTF8 strTemp = NULL;
					int	strLen = 0;
					int	ByteCountLength	= 0;
					strLen = GetLength(&pSigNativeType[cbCur], &ByteCountLength);
					cbCur += ByteCountLength;
					if(strLen)
					{
						strTemp	= (LPUTF8)_alloca(strLen + 1);
						memcpy(strTemp,	(LPUTF8)&pSigNativeType[cbCur],	strLen);
						strTemp[strLen]	= 0;
						szptr+=sprintf(szptr, ", \"%s\"", strTemp);
						cbCur += strLen;
					}
                }
				break;
			
			case NATIVE_TYPE_INT:		sz = " int"; break;
			case NATIVE_TYPE_UINT:		sz = " unsigned int"; break;
			case NATIVE_TYPE_NESTEDSTRUCT: sz = " nested struct"; break;
			case NATIVE_TYPE_BYVALSTR:	sz = " byvalstr"; break;
			case NATIVE_TYPE_ANSIBSTR:	sz = " ansi bstr"; break;
			case NATIVE_TYPE_TBSTR:		sz = " tbstr"; break;
			case NATIVE_TYPE_VARIANTBOOL: sz = " variant bool"; break;
			case NATIVE_TYPE_FUNC:		sz = " method"; break;
			case NATIVE_TYPE_ASANY:		sz = " as any"; break;
			case NATIVE_TYPE_ARRAY:		sz = ""; fAddBrackets = TRUE; break;
			case NATIVE_TYPE_LPSTRUCT:	sz = " lpstruct"; break;

            case NATIVE_TYPE_FIXEDSYSSTRING:
                {
					sz = "";
					szptr+=sprintf(szptr," fixed sysstring [");
					if (cbCur < cbNativeType)
					{
						cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
						szptr+=sprintf(szptr,"%d",ulData);
					}
					szptr+=sprintf(szptr,"]");
                }
                break;
            case NATIVE_TYPE_FIXEDARRAY:
                {
					sz = "";
					szptr+=sprintf(szptr," fixed array [");
					if (cbCur < cbNativeType)
					{
						cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
						szptr+=sprintf(szptr,"%d",ulData);
					}
					szptr+=sprintf(szptr,"]");
                }
                break;
            case NATIVE_TYPE_CUSTOMMARSHALER:
				{
                    LPUTF8 strTemp = NULL;
					int strLen = 0;
					int ByteCountLength = 0;
					BOOL fFourStrings = FALSE;

					sz = "";
					szptr+=sprintf(szptr," custom (");
                    // Extract the typelib GUID.
					strLen = GetLength(&pSigNativeType[cbCur], &ByteCountLength);
					cbCur += ByteCountLength;
					if(strLen)
					{
						fFourStrings = TRUE;
						strTemp = (LPUTF8)_alloca(strLen + 1);
						memcpy(strTemp, (LPUTF8)&pSigNativeType[cbCur], strLen);
						strTemp[strLen] = 0;
						szptr+=sprintf(szptr,"\"%s\",",strTemp);
						cbCur += strLen;
					}
					if(cbCur >= cbNativeType)
						szptr+=sprintf(szptr,"/* INCOMPLETE MARSHALER INFO */");
					else
					{
						//_ASSERTE(cbCur < cbNativeType);

						// Extract the name of the native type.
						strLen = GetLength(&pSigNativeType[cbCur], &ByteCountLength);
						cbCur += ByteCountLength;
						if(fFourStrings)
						{
							if(strLen)
							{
								strTemp = (LPUTF8)_alloca(strLen + 1);
								memcpy(strTemp, (LPUTF8)&pSigNativeType[cbCur], strLen);
								strTemp[strLen] = 0;
								szptr+=sprintf(szptr,"\"%s\",",strTemp);
								cbCur += strLen;
							}
							else szptr+=sprintf(szptr,"\"\",");
						}
						if(cbCur >= cbNativeType)
							szptr+=sprintf(szptr,"/* INCOMPLETE MARSHALER INFO */");
						else
						{
							//_ASSERTE(cbCur < cbNativeType);

							// Extract the name of the custom marshaler.
							strLen = GetLength(&pSigNativeType[cbCur], &ByteCountLength);
							cbCur += ByteCountLength;
							if(strLen)
							{
								strTemp = (LPUTF8)_alloca(strLen + 1);
								memcpy(strTemp, (LPUTF8)&pSigNativeType[cbCur], strLen);
								strTemp[strLen] = 0;
								szptr+=sprintf(szptr,"\"%s\",",strTemp);
								cbCur += strLen;
							}
							else szptr+=sprintf(szptr,"\"\",");
							if(cbCur >= cbNativeType)
								szptr+=sprintf(szptr,"/* INCOMPLETE MARSHALER INFO */");
							else
							{
								// Extract the cookie string.
								strLen = GetLength(&pSigNativeType[cbCur], &ByteCountLength);
								cbCur += ByteCountLength;
								if(cbCur+strLen > cbNativeType)
									szptr+=sprintf(szptr,"/* INCOMPLETE MARSHALER INFO */");
								else
								{
									if(strLen)
									{
										strTemp = (LPUTF8)_alloca(strLen + 1);
										memcpy(strTemp, (LPUTF8)&pSigNativeType[cbCur], strLen);
										strTemp[strLen] = 0;

										szptr+=sprintf(szptr,"\"");
										// Copy the cookie string and transform the embedded nulls into \0's.
										for (int i = 0; i < strLen - 1; i++, cbCur++)
										{
											if (strTemp[i] == 0)
												szptr += sprintf(szptr, "\\0");
											else
											{
												*szptr = strTemp[i];
												szptr++;
											}
										}
										*szptr = strTemp[strLen - 1];
										szptr++;
										szptr+=sprintf(szptr,"\"");
										cbCur++;
									}
									else
										szptr+=sprintf(szptr,"\"\"");
									//_ASSERTE(cbCur <= cbNativeType);
								}
							}
						}
					}
					szptr+=sprintf(szptr,")");
				}
				break;
            default:
                {
                    sz = "";
                }
            } // end switch
			szptr+=sprintf(szptr,sz);
			if(strlen(sz))
			{
				if(fAddAsterisk)
				{
					szptr+=sprintf(szptr,"*");
					fAddAsterisk = FALSE;
				}
				if(fAddBrackets)
				{
					ULONG ulSizeParam=-1,ulSizeConst=-1;
					szptr += sprintf(szptr,"[");
					fAddBrackets = FALSE;
                    if (cbCur < cbNativeType)
                    {
                        cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
						ulSizeParam = ulData;
                        if (cbCur < cbNativeType)
                        {
                            cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
							ulSizeConst = ulData;
                        }
                    }
					if(ulSizeConst != 0xFFFFFFFF)
					{
						szptr+=sprintf(szptr,"%d",ulSizeConst);
						if(ulSizeParam == 0) ulSizeParam = 0xFFFFFFFF; // don't need +0
					}
					if(ulSizeParam != 0xFFFFFFFF)
					{
						szptr+=sprintf(szptr," + %d",ulSizeParam);
					}
					szptr+=sprintf(szptr,"]");
 				}

			}

			if (ulData >= NATIVE_TYPE_MAX)
				break;
        } // end while (cbCur < cbNativeType)
		// still can have outstanding asterisk or brackets
		if(fAddAsterisk)
		{
			szptr+=sprintf(szptr,"*");
			fAddAsterisk = FALSE;
		}
		if(fAddBrackets)
		{
			ULONG ulSizeParam=-1,ulSizeConst=-1;
			szptr += sprintf(szptr,"[");
			fAddBrackets = FALSE;
            if (cbCur < cbNativeType)
            {
                cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
				ulSizeParam = ulData;
                if (cbCur < cbNativeType)
                {
                    cbCur += CorSigUncompressData(&pSigNativeType[cbCur], &ulData);
					ulSizeConst = ulData;
                }
            }
			if(ulSizeConst != 0xFFFFFFFF)
			{
				szptr+=sprintf(szptr,"%d",ulSizeConst);
				if(ulSizeParam == 0) ulSizeParam = 0xFFFFFFFF; // don't need +0
			}
			if(ulSizeParam != 0xFFFFFFFF)
			{
				szptr+=sprintf(szptr," + %d",ulSizeParam);
			}
			szptr+=sprintf(szptr,"]");
 		}
		szptr+=sprintf(szptr,") ");
	}// end if(SUCCEEDED
	return szptr;
}

char* DumpParamAttr(char* szString, DWORD dwAttr)
{
	char*			szptr = &szString[strlen(szString)];
	char*			was_szptr = szptr;
	if(IsPdIn(dwAttr))			szptr+=sprintf(szptr,"[in]");
	if(IsPdOut(dwAttr))			szptr+=sprintf(szptr,"[out]");
	if(IsPdOptional(dwAttr))	szptr+=sprintf(szptr,"[opt]");
	if(szptr != was_szptr)		szptr+=sprintf(szptr," ");
	return szptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\gui.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// gui.h
//

#include "DynamicArray.h"

#define BITMAP_WIDTH    15
#define BITMAP_HEIGHT   15

#define DISASSEMBLY_CLASS_NAME  "disassembly"
#define MAIN_WINDOW_CLASS       "dasm"
#define MAIN_WINDOW_CAPTION     "IL DASM"

#define DISASSEMBLY_CLASS_NAMEW  L"disassembly"
#define MAIN_WINDOW_CLASSW       L"dasm"
#define MAIN_WINDOW_CAPTIONW     L"IL DASM"

#define PHDC    (pDIS->hDC)
#define PRC     (pDIS->rcItem)

#define PADDING         28

#define ID_TREEVIEW     1
#define ID_LISTBOX      2

typedef struct
{
    const char *pszNamespace;
    HTREEITEM   hRoot;
} Namespace_t;


//
// Menu info
//
enum
{
	IDM_PROGRESS,
    IDM_OPEN,
	IDM_DUMP,
	IDM_DUMP_TREE,
    IDM_EXIT,
    IDM_SORT_BY_NAME,
	IDM_SHOW_PUB,
	IDM_SHOW_PRIV,
	IDM_SHOW_FAM,
	IDM_SHOW_ASM,
	IDM_SHOW_FAA,
	IDM_SHOW_FOA,
	IDM_SHOW_PSCOPE,
    IDM_FULL_INFO,
	IDM_BYTES,
	IDM_TOKENS,
	IDM_SOURCELINES,
	IDM_EXPANDTRY,
	IDM_QUOTEALLNAMES,
	IDM_SHOW_HEADER,
	IDM_SHOW_STAT,
	IDM_SHOW_METAINFO,
	IDM_MI_DEBUG,
	IDM_MI_HEADER,
	IDM_MI_HEX,
	IDM_MI_CSV,
	IDM_MI_UNREX,
	IDM_MI_SCHEMA,
	IDM_MI_RAW,
	IDM_MI_HEAPS,
	IDM_MI_VALIDATE,
	IDM_HELP,
	IDM_ABOUT,
	IDM_FONT_TREE,
	IDM_FONT_DASM
};


//
// Bitmaps - keep in same order as in dasm.rc file
//
enum
{
    CLASS_IMAGE_INDEX,
	EVENT_IMAGE_INDEX,
    METHOD_IMAGE_INDEX,
	NAMESPACE_IMAGE_INDEX,
    FIELD_IMAGE_INDEX,
	PROP_IMAGE_INDEX,
    STATIC_METHOD_IMAGE_INDEX,
    STATIC_FIELD_IMAGE_INDEX,
    RED_ARROW_IMAGE_INDEX,
	CLASSENUM_IMAGE_INDEX,
	CLASSINT_IMAGE_INDEX,
	CLASSVAL_IMAGE_INDEX,
    LAST_IMAGE_INDEX
};

#define TREEITEM_TYPE_MEMBER    1
#define TREEITEM_TYPE_INFO      2

// Member items and info items (under classes)
typedef struct
{
    HTREEITEM       hItem;
    union
    {
        mdToken			mbMember;
        char *          pszText; // if an info item (extends or implements some class)
    };
    BYTE            Discriminator;
} TreeItem_t;

// Class items (under the root)
typedef struct
{
    HTREEITEM   hItem;
    mdTypeDef   cl;
    TreeItem_t *pMembers;       // List of subitems
    DWORD       SubItems;       // Number of subitems
    DWORD       CurMember;      // Used when building member list
} ClassItem_t;

typedef struct
{
    HWND        hwndContainer;
    HWND        hwndChild;
	mdToken		tkClass;
	mdToken		tkMember;
} DisasmBox_t;



// For accessing metadata
extern IMDInternalImport*	g_pImport;
extern PELoader *           g_pPELoader;
extern IMetaDataImport*     g_pPubImport;

//extern DynamicArray<mdToken>	g_cl_list;
extern mdToken *				g_cl_list;
//extern DynamicArray<mdToken>    g_cl_enclosing;
extern mdToken *				g_cl_enclosing;
extern mdTypeDef				g_cl_module;
extern DWORD					g_NumClasses;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\makefile.inc ===
!if "$(LINKONLY)" == "1"

SetExeConsole: 
	editbin /subsystem:console $(TARGETCORBIN)\i386\$(DDKBUILDENV)\ildasm.exe
	editbin /subsystem:console $(TARGETCOMPLUSSDK)\bin\ildasm.exe

!else

SetExeConsole: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\gui.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define OEMRESOURCE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winuser.h>
#include <commctrl.h>
#include <commdlg.h>
#include <malloc.h>
#include <crtdbg.h>
//#include <richedit.h>
#include <shellapi.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "ceeload.h"
#include "dasmgui.h"
#include "dasmenum.hpp"
#include "dis.h"
#include "resource.h"
#include "gui.h"
#include "utilcode.h"
#include "formatType.h"
#include "..\tools\metainfo\mdinfo.h"
#include "__file__.ver"
#include "corver.h"

struct MemberInfo {
    const char *pszMemberName;
    DWORD dwAttrs;
    ULONG           cComSig;   
    PCCOR_SIGNATURE pComSig;    
    mdToken token;
};

int __cdecl memberCmp(const void *elem1, const void *elem2 ) {
    MemberInfo* mem1 = (MemberInfo*) elem1;
    MemberInfo* mem2 = (MemberInfo*) elem2;
    return(strcmp(mem1->pszMemberName, mem2->pszMemberName));
}

//
// Global buffer, filled by AddOPCode
//
//char *GlobalBuffer = new char[65535];
char *GlobalBuffer = (char*)malloc(65535);
ULONG GlobalBufferLen = 65535;
ULONG InGlobalBuffer;

//
// Global HINSTANCE 
//
HINSTANCE   g_hInstance;

//
// Main window
//
HWND        g_hwndMain;

//
// Treeview for main window
//
HWND        g_hwndTreeView;

//
// Assembly info window (child of main)
//
HWND		g_hwndAsmInfo;
extern IMetaDataAssemblyImport*    g_pAssemblyImport;
void DumpAssembly(void* GUICookie, BOOL fFullDump);
IMetaDataAssemblyImport* GetAssemblyImport(void* GUICookie);

//
// Global image list
//
HIMAGELIST  g_hImageList;

//
// Menu for main window
//
HMENU       g_hMenu, g_hMetaInfoMenu, g_hFileMenu, g_hViewMenu, g_hFontMenu;

//
// Flags
//
BOOL        g_fFullMemberInfo = FALSE; // Show member type? (method, field, event, prop)
BOOL        g_fSortByName = TRUE; // Sort members in tree?
BOOL		g_fOnUnicode;
//
// Module name of loaded DLL/EXE
//
char *      g_pszModule;

//
// Interlocked variable for setting char dimensions once
//
long        g_SetCharDimensions = 0;


//
// Bitmap handles
//
HBITMAP g_hBitmaps[LAST_IMAGE_INDEX];

// 
// Root item for listview
//
HTREEITEM   g_hRoot;

// Global graphics
HBRUSH      g_hWhiteBrush;
HFONT       g_hFixedFont;
HFONT		g_hSmallFont;
HBITMAP     g_hMethodBmp, g_hFieldBmp, g_hClassBmp, g_hStaticMethodBmp, g_hStaticFieldBmp, g_hQuestionBmp;
LOGFONT		g_strLogFontTree, g_strLogFontDasm;
CHOOSEFONT	g_strChFontTree, g_strChFontDasm;

// Text info
long        g_Height;
long        g_MaxCharWidth;

// Currently selected treeview item
HTREEITEM   g_CurSelItem;

extern IMAGE_COR20_HEADER * g_CORHeader;
extern BOOL                 g_fDumpTokens;
extern BOOL                 g_fShowBytes;
extern BOOL                 g_fShowSource;
extern BOOL                 g_fTryInCode;
extern BOOL					g_fQuoteAllNames;
extern BOOL					g_fShowProgressBar;
extern BOOL                 g_fDumpHeader;
extern BOOL                 g_fDumpAsmCode;
extern BOOL                 g_fDumpTokens;
extern BOOL                 g_fDumpStats;
extern BOOL                 g_fDumpMetaInfo;
extern BOOL                 g_fDumpClassList;
extern BOOL                 g_fInsertSourceLines;

extern BOOL					g_fLimitedVisibility;
extern BOOL					g_fHidePub;
extern BOOL					g_fHidePriv;
extern BOOL					g_fHideFam;
extern BOOL					g_fHideAsm;
extern BOOL					g_fHideFAA;
extern BOOL					g_fHideFOA;
extern BOOL					g_fHidePrivScope;
extern BOOL					g_fTDC;

extern char					g_szInputFile[]; // in UTF-8
extern ULONG                g_ulMetaInfoFilter;
extern char					g_szOutputFile[]; // in UTF-8
extern DWORD                g_Mode;
extern FILE*                g_pFile;
extern HINSTANCE            g_hAppInstance;

extern unsigned				g_uCodePage;
DWORD	DumpResourceToFile(WCHAR*	wzFileName); // see DRES.CPP
//
// Functions
//
BOOL            RegisterWindowClasses();
void            GetObjectName(const char *pszNamespace, const char **ppszPtr, char *pszResult);
HWND            CreateTreeView(HINSTANCE hInst, HWND hwndParent);
HTREEITEM       AddOneItem(HTREEITEM hParent, const char *pszText, HTREEITEM hInsAfter, int iImage, HWND hwndTree, BOOL fExpanded);
HWND            GUIDisassemble(mdTypeDef cl, mdToken mbMember, char *pszWindowTitle);
HTREEITEM       AddClassToTreeView(HTREEITEM hParent, mdTypeDef cl);
void            AddGlobalFunctions();
void            CreateMenus();
Namespace_t*    FindNamespace(const char *pszNamespace);
void            GUICleanupClassItems();
void            SelectClassByName(char *pszFQName);
void            SelectClassByToken(mdToken tk);
void            DumpTreeItemA(HTREEITEM hItem, FILE* pFile, char* szIndent);
void            DumpTreeItemW(HTREEITEM hItem, FILE* pFile, WCHAR* szIndent);
HTREEITEM       FindCreateNamespaceRoot(const char *pszNamespace);
FILE*			OpenOutput(char* szFileName);

#undef SendMessageW
#undef CreateWindowExW
#undef DefWindowProcW
#undef RegisterClassExW
#undef RegisterClassW
#undef SetWindowTextW
#undef GetWindowTextW
#undef MessageBoxW

LRESULT CALLBACK DisassemblyWndProc(  
    HWND    hwnd,      
    UINT    uMsg,      
    WPARAM  wParam,  
    LPARAM  lParam   
);

LRESULT CALLBACK MainWndProc(  
    HWND    hwnd,      
    UINT    uMsg,      
    WPARAM  wParam,  
    LPARAM  lParam   
);

ClassItem_t *AddClassToGUI(mdTypeDef cl,    UINT        uImageIndex,
        const char *pszNamespace, const char *pszClassName, DWORD cSubItems, HTREEITEM *phRoot);

void AddMethodToGUI(
    mdTypeDef   cl,
    ClassItem_t * pClassItem,
    const char *pszNamespace,
    const char *pszClassName,
    const char *pszMethodName, 
    PCCOR_SIGNATURE pComSig,    
    unsigned cComSig,
    mdMethodDef mbMethod,
    DWORD       dwAttrs
);

void AddFieldToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    const char  *pszFieldName, 
    const char  *pszSignature,
    mdFieldDef  mbField,
    DWORD       dwAttrs
);

void AddEventToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    DWORD       dwClassAttrs,
    mdEvent     mbEvent
);

void AddPropToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    DWORD       dwClassAttrs,
    mdProperty  mbProp
);

DynamicArray<DisasmBox_t> g_DisasmBox;
DWORD       g_NumDisasmBoxes=0;

DynamicArray<ClassItem_t> g_ClassItemList;
DWORD       g_NumClassItems=0;

DynamicArray<Namespace_t> g_NamespaceList;
DWORD       g_NumNamespaces=0;


ClassItem_t *FindClassItem(HTREEITEM hItem);
ClassItem_t *FindClassItem(mdTypeDef cl);
ClassItem_t *FindClassItem(char *pszNamespace, char *pszName);


// Helper
static DWORD FourBytesToU4(const BYTE *pBytes)
{
    return pBytes[0] | (pBytes[1] << 8) | (pBytes[2] << 16) | (pBytes[3] << 24);
}

// Find disasm box among opened by class and member tokens
DisasmBox_t* FindDisasmBox(mdToken tkClass, mdToken tkMember)
{
    for (DWORD i = 0; i < g_NumDisasmBoxes; i++)
    {
        if ((g_DisasmBox[i].tkClass == tkClass)
            &&(g_DisasmBox[i].tkMember == tkMember))
            return &g_DisasmBox[i];
    }
    return NULL;
}
//
// Add a new disassembly box to the global list of them
//
// hwndContainer - parent window
// hwndChild     - listview
//
void AddDisasmBox(HWND hwndContainer, HWND hwndChild, mdToken tkClass, mdToken tkMember)
{
    g_DisasmBox[g_NumDisasmBoxes].hwndContainer = hwndContainer;
    g_DisasmBox[g_NumDisasmBoxes].hwndChild = hwndChild;
    g_DisasmBox[g_NumDisasmBoxes].tkClass = tkClass;
    g_DisasmBox[g_NumDisasmBoxes].tkMember = tkMember;
    g_NumDisasmBoxes++;
}


//
// Given a container window, find the associated disassembly window
//
HWND FindAssociatedDisassemblyListBox(HWND hwndContainer)
{
    DWORD i;

    for (i = 0; i < g_NumDisasmBoxes; i++)
    {
        if (g_DisasmBox[i].hwndContainer == hwndContainer)
            return g_DisasmBox[i].hwndChild;
    }

    return NULL;
}


void RemoveDisasmBox(HWND hwndContainer)
{
    DWORD i;

    for (i = 0; i < g_NumDisasmBoxes; i++)
    {
        if (g_DisasmBox[i].hwndContainer == hwndContainer)
        {
            memcpy(&g_DisasmBox[i], &g_DisasmBox[i+1], (g_NumDisasmBoxes-i-1)*sizeof(DisasmBox_t));
            g_NumDisasmBoxes--;
            break;
        }
    }
}


void RemoveItemsFromList()
{
    TreeView_DeleteAllItems(g_hwndTreeView);
}


BOOL RefreshList()
{
    GUICleanupClassItems();
    return GUIAddItemsToList();
}


void GUISetModule(char *pszModule)
{
    g_pszModule = pszModule;
}


TreeItem_t *FindClassMemberByName(ClassItem_t *pClassItem, char *pszFindName, char *pszFindSig)
{
    DWORD i;

    // do in two passes, fields first
    for (i = 0; i < pClassItem->SubItems; i++)
    {
        TreeItem_t *pItem;
        const char *pszMemberName;
        const char *pszMemberSig;
        DWORD   dwAttrs;

        CQuickBytes     qbMemberSig;    

        PCCOR_SIGNATURE pComSig;    
        ULONG           cComSig;    


        pItem = &pClassItem->pMembers[i];
        if (pItem->Discriminator != TREEITEM_TYPE_MEMBER)
            continue;

        if (TypeFromToken(pItem->mbMember) == mdtMethodDef) 
        {   
            dwAttrs = g_pImport->GetMethodDefProps(pItem->mbMember);

            pszMemberName = g_pImport->GetNameOfMethodDef( pItem->mbMember );

            pComSig = g_pImport->GetSigOfMethodDef(  
                pItem->mbMember,    
                &cComSig    
            );  
        }   
        else    
        {   
            dwAttrs = g_pImport->GetFieldDefProps( pItem->mbMember );

            pszMemberName = g_pImport->GetNameOfFieldDef( pItem->mbMember ); 
            pComSig = g_pImport->GetSigOfFieldDef(   
                pItem->mbMember,    
                &cComSig    
            );  
        }   
		MAKE_NAME_IF_NONE(pszMemberName,pItem->mbMember);
        qbMemberSig.ReSize(0);
        pszMemberSig = PrettyPrintSig(pComSig, cComSig, "", &qbMemberSig, g_pImport,NULL);

    // @todo: GUI IL is so that NDView can call into DASM with/GUI; NDView uses Reflection API  
    // which doesn't let us get a valid signature.  
    // If GUI IL only, then ignore signature if it's NULL   
        if (IsGuiILOnly()) {    
            if (!strcmp(pszMemberName, pszFindName)) {  
                if ((pszFindSig != NULL) && strcmp(pszMemberSig, pszFindSig)) continue; 
                return pItem;   
            }   
        } else {    
            if (!strcmp(pszMemberName, pszFindName) && !strcmp(pszMemberSig, pszFindSig))   
                return pItem;   
        }   
    }

    return NULL;
}

// Kick of a disassembly window
// Return TRUE if window opened ok, and FALSE if there's an error
BOOL DisassembleMemberByName(char *pszClassName, char *pszMemberName, char *pszSig)
{
    char szClassName[512];
    char szClassNamespace[512];
    char *pszClassNamespace;
    char *p;

    p = ns::FindSep(pszClassName);
    if (p == NULL)
    {
        strcpy(szClassName, pszClassName);
        pszClassNamespace = NULL;
    }
    else
    {
        strncpy(szClassNamespace, pszClassName, p - pszClassName);
        szClassNamespace[ p - pszClassName ] = '\0';
        pszClassNamespace = szClassNamespace;

        strcpy(szClassName, p+1);
    }

    ClassItem_t *pClassItem = FindClassItem(pszClassNamespace, szClassName);

    if (pClassItem != NULL)
    {
        TreeItem_t *pTreeItem;

        pTreeItem = FindClassMemberByName(pClassItem, pszMemberName, pszSig);

        if (pTreeItem != NULL)
        {
            DWORD   dwAttrs;
            DWORD   dwImplAttrs;

            // What is this member?

            if (TypeFromToken(pTreeItem->mbMember) == mdtMethodDef)
            {
				char* szText;
                dwAttrs = g_pImport->GetMethodDefProps( pTreeItem->mbMember );   
                g_pImport->GetMethodImplProps( pTreeItem->mbMember, NULL, &dwImplAttrs );

                // Can't be abstract or native  
                if (IsMdAbstract(dwAttrs) || IsMiInternalCall(dwImplAttrs))
                    return FALSE;

                szText = (char*)malloc(4096);
                TVITEM SelItem;

                // Get the name of this item so that we can title the disassembly window
                memset(&SelItem, 0, sizeof(SelItem));
                SelItem.mask = TVIF_TEXT;
                SelItem.pszText = szText;
                SelItem.hItem = pTreeItem->hItem;
                SelItem.cchTextMax = 4095;

				if(g_fOnUnicode)
				{
					WCHAR* wzText = (WCHAR*)szText;
					SendMessageW(g_hwndTreeView, TVM_GETITEMW, 0, (LPARAM) (LPTVITEMW) &SelItem);
					unsigned L = ((unsigned)wcslen(wzText)+1)*3;
					char*	szUTFText = (char*)malloc(L);
					memset(szUTFText,0,L);
					WszWideCharToMultiByte(CP_UTF8,0,wzText,-1,szUTFText,L,NULL,NULL);
					free(wzText);
					szText = szUTFText;
				}
				else SendMessageA(g_hwndTreeView, TVM_GETITEMA, 0, (LPARAM) (LPTVITEMA) &SelItem);

                HWND fOK = GUIDisassemble(pClassItem->cl, pTreeItem->mbMember, szText);
				free(szText);
                if (fOK == NULL) { 
                    goto ErrorHere; 
                }   
            }
        } // endif (pTreeItem != NULL)
        else {  
            goto ErrorHere; 
        }   

    } else {
        goto ErrorHere; 
    }   

    return TRUE;    

ErrorHere:
    char pzText[300];   
    sprintf(pzText, "Can't view %s::%s(%s)", pszClassName, pszMemberName, pszSig);  

    MessageBox(g_hwndMain, pzText, "Can't View IL", MB_OK | MB_ICONERROR);  


    return FALSE;   
}

//HTREEITEM AddInfoItemToClass(HTREEITEM hParent, ClassItem_t *pClassItem, const char *pszText, const char *pszStoredInfoText)
HTREEITEM AddInfoItemToClass(HTREEITEM hParent, ClassItem_t *pClassItem, const char *pszText, mdToken tk)
{
    _ASSERTE(pClassItem->CurMember < pClassItem->SubItems);
    pClassItem->pMembers[pClassItem->CurMember].hItem = AddOneItem(
        pClassItem->hItem, pszText, hParent, RED_ARROW_IMAGE_INDEX, g_hwndTreeView, FALSE
    );
    pClassItem->pMembers[pClassItem->CurMember].Discriminator = TREEITEM_TYPE_INFO;
    //pClassItem->pMembers[pClassItem->CurMember].pszText = (char *) pszStoredInfoText;
    pClassItem->pMembers[pClassItem->CurMember].mbMember = tk;
    pClassItem->CurMember++;

    return pClassItem->pMembers[pClassItem->CurMember-1].hItem;
}

struct ClassDescr
{
	mdToken	tk;
	const char*	szName;
};
static int __cdecl classDescrCmp(const void *op1, const void *op2)
{
    return  strcmp(((ClassDescr*)op1)->szName,((ClassDescr*)op2)->szName);
}

unsigned AddClassesWithEncloser(mdToken tkEncloser, HTREEITEM hParent)
{
	unsigned i, N=0;
	for (i = 0; i < g_NumClasses; i++)
	{
		if(g_cl_enclosing[i] == tkEncloser) N++;
	}

	if(N)
	{
//		ClassDescr* rClassDescr = new ClassDescr[N];
		ClassDescr* rClassDescr = (ClassDescr*)malloc(sizeof(ClassDescr)*N);
		const char	*pszClassName,*pszNamespace; 
		for (i = 0, N = 0; i < g_NumClasses; i++)
		{
			if(g_cl_enclosing[i] == tkEncloser)
			{
				rClassDescr[N].tk = g_cl_list[i];
				g_pImport->GetNameOfTypeDef(g_cl_list[i],&pszClassName,&pszNamespace);
				MAKE_NAME_IF_NONE(pszClassName,g_cl_list[i]);
				rClassDescr[N].szName = pszClassName;
				N++;
			}
		}
		if(g_fSortByName) qsort(&rClassDescr[0],N,sizeof(ClassDescr),classDescrCmp);
		for(i = 0; i < N; i++) AddClassToTreeView(hParent,rClassDescr[i].tk);
//		delete [] rClassDescr;
		free(rClassDescr);
	}
	return N;
}

static int __cdecl stringCmp(const void *op1, const void *op2)
{
    return  strcmp(*((char**)op1), *((char**)op2));
	//return(strlen(*((char**)op1)) - strlen(*((char**)op2)));
}

BOOL GUIAddItemsToList()
{
    DWORD i,NumGlobals=0;
    HENUMInternal   hEnumMethod;

    RemoveItemsFromList();
    g_NumClassItems = 0;
    g_NumNamespaces = 0;

    g_hRoot = AddOneItem(
        (HTREEITEM)NULL, 
        g_pszModule, 
        (HTREEITEM)TVI_ROOT, 
        FIELD_IMAGE_INDEX, 
        g_hwndTreeView, 
        TRUE
    );

    if (SUCCEEDED(g_pImport->EnumGlobalFunctionsInit(&hEnumMethod)))
    {
        NumGlobals = g_pImport->EnumGetCount(&hEnumMethod);
        g_pImport->EnumClose(&hEnumMethod);
    }
    if (SUCCEEDED(g_pImport->EnumGlobalFieldsInit(&hEnumMethod)))
    {
        NumGlobals += g_pImport->EnumGetCount(&hEnumMethod);
        g_pImport->EnumClose(&hEnumMethod);
    }
    g_ClassItemList[0].hItem = g_hRoot;
    g_ClassItemList[0].cl = 0;
    g_ClassItemList[0].SubItems = NumGlobals+1;
    g_ClassItemList[0].CurMember = 0;
//    g_ClassItemList[0].pMembers = new TreeItem_t[NumGlobals+1];
    g_ClassItemList[0].pMembers = (TreeItem_t*)malloc(sizeof(TreeItem_t)*(NumGlobals+1));
    g_NumClassItems++;

    //AddInfoItemToClass((HTREEITEM)TVI_ROOT, &g_ClassItemList[0], " M A N I F E S T", "__MANIFEST__");
    AddInfoItemToClass((HTREEITEM)TVI_ROOT, &g_ClassItemList[0], " M A N I F E S T", 0xFFFFFFFF);

	if(g_NumClasses)
	{
		//create root namespaces
		{
//			char**  rszNamespace = new char*[g_NumClasses];
			char**  rszNamespace = (char**)malloc(sizeof(char*)*g_NumClasses);
			ULONG				ulNamespaces=0;
			for (i = 0; i < g_NumClasses; i++)
			{
				if(g_cl_enclosing[i] == mdTypeDefNil) // nested classes don't have separate namespaces
				{
					const char *pszClassName, *pszNameSpace;
					g_pImport->GetNameOfTypeDef(
						g_cl_list[i],
						&pszClassName,
						&pszNameSpace);
					if(pszNameSpace && *pszNameSpace) rszNamespace[ulNamespaces++] = (char*)pszNameSpace;
				}
			}
			if(ulNamespaces)
			{
				qsort(&rszNamespace[0],ulNamespaces,sizeof(char*),stringCmp);
				for(i = 0; i < ulNamespaces; i++) FindCreateNamespaceRoot(rszNamespace[i]);
			}
//			delete rszNamespace;
			free(rszNamespace);
		}
		AddClassesWithEncloser(mdTypeDefNil,NULL);
	}// end if (g_NumClasses)
    AddGlobalFunctions();

    SendMessageA(g_hwndTreeView, TVM_EXPAND, TVE_EXPAND, (LPARAM)g_hRoot);
    EnableMenuItem(g_hMenu,(UINT)g_hViewMenu, MF_ENABLED);
    EnableMenuItem(g_hFileMenu,IDM_DUMP,MF_ENABLED);
    EnableMenuItem(g_hFileMenu,IDM_DUMP_TREE,MF_ENABLED);
	DrawMenuBar(g_hwndMain);

	{
		int L = strlen(g_szInputFile)+20;
//		WCHAR* wz = new WCHAR[L+20];
		WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L));
		memset(wz,0,sizeof(WCHAR)*L);
		WszMultiByteToWideChar(CP_UTF8,0,g_szInputFile,-1,wz,L);
		wcscat(wz,L" - IL DASM");
		if(g_fOnUnicode)
			SetWindowTextW(g_hwndMain,wz);
		else
		{
			L *= 3;
			char* sz = (char*)malloc(L);
			memset(sz,0,L);
			WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,L,NULL,NULL);
		    SetWindowTextA(g_hwndMain,sz);
			free(sz);
		}
//		delete [] wz;
		free(wz);
	}

    if (IsGuiILOnly()) {    
        ShowWindow(g_hwndMain, SW_HIDE);    
    } else {    
        ShowWindow(g_hwndMain, SW_SHOW);    
    }   
    UpdateWindow(g_hwndMain);
	//GUIDisassemble(0,0,"MANIFEST");
	g_Mode &= ~MODE_GUI;
	DumpManifest(NULL);
	g_Mode |= MODE_GUI;

    memset(GlobalBuffer,0,GlobalBufferLen);
    InGlobalBuffer = 0;
    if(g_pAssemblyImport==NULL) g_pAssemblyImport = GetAssemblyImport((void*)g_hwndAsmInfo);
	if(g_pAssemblyImport)
	{
		DumpAssembly((void *)g_hwndAsmInfo,FALSE);
	}
    //SendMessageA(g_hwndAsmInfo,EM_LIMITTEXT,0, 0);

	if(g_uCodePage == 0xFFFFFFFF)
		SendMessageW((HWND)g_hwndAsmInfo,WM_SETTEXT,0, (LPARAM)GlobalBuffer);
	else
	{
		int L = strlen(GlobalBuffer);
		WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L+4));
		memset(wz,0,sizeof(WCHAR)*(L+2));
		WszMultiByteToWideChar(CP_UTF8,0,GlobalBuffer,-1,wz,L+2);
		if(g_fOnUnicode)
			SendMessageW((HWND)g_hwndAsmInfo,WM_SETTEXT,0, (LPARAM)wz);
		else
		{
			L *= 3;
			char* sz = (char*)malloc(L);
			memset(sz,0,L);
			WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,L,NULL,NULL);
		    SendMessageA(g_hwndAsmInfo,WM_SETTEXT,0, (LPARAM)sz);
			free(sz);
		}
		free(wz);
	}

	TreeView_SelectItem(g_hwndTreeView,g_hRoot);
	SetFocus(g_hwndTreeView);
	return TRUE;
}


//
// Find class item by class token
//
ClassItem_t* ClassItemByToken(mdTypeDef cl)
{
    for(ULONG i=0; i < g_NumClassItems; i++)
    {
        if(g_ClassItemList[i].cl == cl) return &g_ClassItemList[i];
    }
    return NULL;
}


//
// Add a class and its members
//
HTREEITEM AddClassToTreeView(HTREEITEM hParent, mdTypeDef cl)
{
    HRESULT         hr;
    ClassItem_t     *pClassItem;
    HTREEITEM       hClassRoot;
    HTREEITEM       hNamespaceRoot = hParent;
    HTREEITEM       hPrimaryInfo;
    HTREEITEM       hLast;
    mdToken         *pMemberList = NULL;
    HENUMInternal   hEnumMethod;        // enumerator for method defs    
    HENUMInternal   hEnumField;         // enumerator for fields    
    HENUMInternal   hEnumEvent;         // enumerator for events    
    HENUMInternal   hEnumProp;          // enumerator for properties    
    DWORD           NumMembers;
    const char      *pszClassName; // name associated with this CL
    const char      *pszNamespace;
    DWORD           dwClassAttrs;
    mdTypeRef       crExtends;
    mdInterfaceImpl ii;
    DWORD           NumInterfaces;
    DWORD           i;
    char            *szPrimaryInfo; // public class foo extends bar
//	char			*szFullClassName;
    DWORD           SubItems;
    const char      *pszSuperName = NULL;
    HENUMInternal   hEnumII;            // enumerator for interface impl    
    mdCustomAttribute *rCA;
    ULONG           ulCAs;
    UINT            uImageIndex = CLASS_IMAGE_INDEX;
	BOOL			bIsEnum = FALSE;
    BOOL            bIsValueType = FALSE;
	BOOL			bExtendsSysObject=FALSE;

    g_pImport->GetNameOfTypeDef(
        cl,
        &pszClassName,
        &pszNamespace
    );
	MAKE_NAME_IF_NONE(pszClassName,cl);
    g_pImport->GetTypeDefProps(
        cl,
        &dwClassAttrs,
        &crExtends
    );
	if(g_fLimitedVisibility)
	{
		if(g_fHidePub && (IsTdPublic(dwClassAttrs)||IsTdNestedPublic(dwClassAttrs))) return NULL;
		if(g_fHidePriv && (IsTdNotPublic(dwClassAttrs)||IsTdNestedPrivate(dwClassAttrs))) return NULL;
		if(g_fHideFam && IsTdNestedFamily(dwClassAttrs)) return NULL;
		if(g_fHideAsm && IsTdNestedAssembly(dwClassAttrs)) return NULL;
		if(g_fHideFOA && IsTdNestedFamORAssem(dwClassAttrs)) return NULL;
		if(g_fHideFAA && IsTdNestedFamANDAssem(dwClassAttrs)) return NULL;
	}
    hr = g_pImport->EnumInit(   
        mdtInterfaceImpl,   
        cl,     
        &hEnumII);  
    if (FAILED(hr))
        return FALSE;

    NumInterfaces = g_pImport->EnumGetCount(&hEnumII);  
    hr = g_pImport->EnumInit(mdtMethodDef, cl, &hEnumMethod);  
    if (FAILED(hr)) 
    {   
        printf("Unable to enum methods\n"); 
        return FALSE;   
    }   
    NumMembers = g_pImport->EnumGetCount(&hEnumMethod); 

    hr = g_pImport->EnumInit(mdtFieldDef, cl, &hEnumField);    
    if (FAILED(hr)) 
    {   
        g_pImport->EnumClose(&hEnumMethod); 
        printf("Unable to enum fields\n");  
        return FALSE;   
    }   
    NumMembers += g_pImport->EnumGetCount(&hEnumField); 

    hr = g_pImport->EnumInit(mdtEvent, cl, &hEnumEvent);    
    if (FAILED(hr)) 
    {   
        g_pImport->EnumClose(&hEnumMethod); 
        g_pImport->EnumClose(&hEnumField); 
        printf("Unable to enum events\n");  
        return FALSE;   
    }   
    NumMembers += g_pImport->EnumGetCount(&hEnumEvent); 

    hr = g_pImport->EnumInit(mdtProperty, cl, &hEnumProp);    
    if (FAILED(hr)) 
    {   
        g_pImport->EnumClose(&hEnumMethod); 
        g_pImport->EnumClose(&hEnumField); 
        g_pImport->EnumClose(&hEnumEvent); 
        printf("Unable to enum properties\n");  
        return FALSE;   
    }   
    NumMembers += g_pImport->EnumGetCount(&hEnumProp); 
    if (NumMembers > 0)
    {
//        pMemberList = new mdToken[NumMembers];
        pMemberList = (mdToken*)malloc(sizeof(mdToken)*NumMembers);
        if (pMemberList == NULL)
        {   
            // close enum before return 
            g_pImport->EnumClose(&hEnumMethod); 
            g_pImport->EnumClose(&hEnumField);  
            g_pImport->EnumClose(&hEnumEvent); 
            g_pImport->EnumClose(&hEnumProp); 
            return FALSE;
        }   
        
        for (i = 0; g_pImport->EnumNext(&hEnumField, &pMemberList[i]); i++);   
        for (; g_pImport->EnumNext(&hEnumMethod, &pMemberList[i]); i++); 
        for (; g_pImport->EnumNext(&hEnumEvent, &pMemberList[i]); i++); 
        for (; g_pImport->EnumNext(&hEnumProp, &pMemberList[i]); i++); 
        _ASSERTE(i == NumMembers);  
        
    }
    else
    {
        pMemberList = NULL;
    }

    // Add class root to treeview
    SubItems = NumMembers + NumInterfaces + 3;
    if (!IsNilToken(crExtends))
    {
        LPCSTR szClassName="";
        LPCSTR szNameSpace="";
		SubItems++;
        if(TypeFromToken(crExtends)==mdtTypeRef) 
		{
            g_pImport->GetNameOfTypeRef(crExtends, &szNameSpace, &szClassName);
	        if(!(strcmp(szNameSpace,"System") || strcmp(szClassName, "Object")))
			{
				SubItems--;
				bExtendsSysObject = TRUE;
			}
		}
        else if(TypeFromToken(crExtends)==mdtTypeDef)
            g_pImport->GetNameOfTypeDef(crExtends, &szClassName, &szNameSpace);

		bIsEnum = (!strcmp(szNameSpace,"System"))&&(!strcmp(szClassName,"Enum"));

		bIsValueType = (!strcmp(szNameSpace,"System"))&&(!strcmp(szClassName,"ValueType"))
			&& (strcmp(pszNamespace,"System") || strcmp(pszClassName,"Enum"));
    }
    {
        HCORENUM        hEnum = NULL;
		rCA = (mdCustomAttribute*)malloc(sizeof(mdCustomAttribute)*4096);
        g_pPubImport->EnumCustomAttributes(&hEnum, cl, 0, rCA, 4096, &ulCAs);
        SubItems += ulCAs;
        g_pPubImport->CloseEnum( hEnum);
    }
	for (i = 0; i < g_NumClasses; i++)
	{
		if(g_cl_enclosing[i] == cl) SubItems++;
	}

    if(IsTdInterface(dwClassAttrs)) uImageIndex = CLASSINT_IMAGE_INDEX;
    if(bIsValueType) uImageIndex = CLASSVAL_IMAGE_INDEX;
    if(bIsEnum)      uImageIndex = CLASSENUM_IMAGE_INDEX;
    pClassItem = AddClassToGUI(cl, uImageIndex, pszNamespace, pszClassName, SubItems, &hNamespaceRoot);
    if (pClassItem == NULL)
        return FALSE;

    hClassRoot = pClassItem->hItem;

	szPrimaryInfo = (char*)malloc(2048);
    strcpy(szPrimaryInfo, ".class ");

    if (IsTdInterface(dwClassAttrs))        strcat(szPrimaryInfo, "interface ");
    //else if (IsTdUnmanagedValueType(dwClassAttrs)) strcat(szPrimaryInfo, "not_in_gc_heap value ");
    else if (bIsValueType)                  strcat(szPrimaryInfo, "value ");

    if (IsTdPublic(dwClassAttrs))           strcat(szPrimaryInfo, "public ");
    if (IsTdNotPublic(dwClassAttrs))        strcat(szPrimaryInfo, "private ");
    if (IsTdNestedPublic(dwClassAttrs))     strcat(szPrimaryInfo, "nested public ");
    if (IsTdNestedPrivate(dwClassAttrs))    strcat(szPrimaryInfo, "nested private ");
    if (IsTdNestedFamily(dwClassAttrs))     strcat(szPrimaryInfo, "nested family ");
    if (IsTdNestedAssembly(dwClassAttrs))   strcat(szPrimaryInfo, "nested assembly ");
    if (IsTdNestedFamANDAssem(dwClassAttrs))   strcat(szPrimaryInfo, "nested famandassem ");
    if (IsTdNestedFamORAssem(dwClassAttrs))    strcat(szPrimaryInfo, "nested famorassem ");
    if (IsTdAbstract(dwClassAttrs))         strcat(szPrimaryInfo, "abstract ");
    if (IsTdAutoLayout(dwClassAttrs))       strcat(szPrimaryInfo, "auto ");
    if (IsTdSequentialLayout(dwClassAttrs)) strcat(szPrimaryInfo, "sequential ");
    if (IsTdExplicitLayout(dwClassAttrs))   strcat(szPrimaryInfo, "explicit ");
    if (IsTdAnsiClass(dwClassAttrs))        strcat(szPrimaryInfo, "ansi ");
    if (IsTdUnicodeClass(dwClassAttrs))     strcat(szPrimaryInfo, "unicode ");
    if (IsTdAutoClass(dwClassAttrs))        strcat(szPrimaryInfo, "autochar ");
    if (IsTdImport(dwClassAttrs))           strcat(szPrimaryInfo, "import ");
    if (IsTdSerializable(dwClassAttrs))     strcat(szPrimaryInfo, "serializable ");
//    if (IsTdEnum(dwClassAttrs))             strcat(szPrimaryInfo, "enum ");
    if (IsTdSealed(dwClassAttrs))           strcat(szPrimaryInfo, "sealed ");
    if (IsTdBeforeFieldInit(dwClassAttrs))  strcat(szPrimaryInfo, "beforefieldinit ");
    if (IsTdSpecialName(dwClassAttrs))      strcat(szPrimaryInfo, "specialname ");
    if (IsTdRTSpecialName(dwClassAttrs))    strcat(szPrimaryInfo, "rtspecialname ");

    if(g_fDumpTokens) sprintf(&szPrimaryInfo[strlen(szPrimaryInfo)]," /*%08X*/",cl);
    hPrimaryInfo = AddInfoItemToClass(hClassRoot, pClassItem, szPrimaryInfo, NULL);
    hLast = hPrimaryInfo;
    // Now add nodes for extends, implements
    if (!IsNilToken(crExtends))
    {
		if(!bExtendsSysObject)
		{  
			CQuickBytes out;
			sprintf(szPrimaryInfo, " extends %s ",PrettyPrintClass(&out, crExtends, g_pImport));
            hLast = AddInfoItemToClass(hLast, pClassItem, szPrimaryInfo, crExtends);
		}
    }
	free(szPrimaryInfo);

    if (NumInterfaces > 0)
    {
        for (i=0; g_pImport->EnumNext(&hEnumII, &ii); i++)  
        {
            mdTypeRef crInterface;
//            const char *pszInterfaceName;
            const char *    pszNamespace = NULL; // dummy, to avoid NULL dereferencing
            char    szInterfaceInfo[2048];

            crInterface = g_pImport->GetTypeOfInterfaceImpl(
                ii
            );
			{  
				CQuickBytes out;
				sprintf(szInterfaceInfo, " implements %s ",PrettyPrintClass(&out, crInterface, g_pImport));
				hLast = AddInfoItemToClass(hLast, pClassItem, szInterfaceInfo, crInterface);
			}
        }

        // The assertion will fire if the enumerator is bad 
        _ASSERTE(NumInterfaces == i);   

        // close the enumerator 
        g_pImport->EnumClose(&hEnumII);
    }
    // add info entries for custom attributes
    for(i = 0; i < ulCAs; i++)
    {
        char* pc;
        memset(GlobalBuffer,0,GlobalBufferLen);
        InGlobalBuffer = 0;
        DumpCustomAttribute(rCA[i],(void *)g_hwndTreeView,false);
        if(pc = strchr(GlobalBuffer,'\r')) strcpy(pc," ..."); // until the first <CR> only
        //hLast = AddInfoItemToClass(hLast, pClassItem, GlobalBuffer, "#####"); // this "name" is guaranteed to be unique!
        hLast = AddInfoItemToClass(hLast, pClassItem, GlobalBuffer, rCA[i]);
    }
	free(rCA);

    // Re-fetch the current class item ptr, dynamic array may have shifted
    pClassItem = ClassItemByToken(cl);
	
	// Add nested classes
	AddClassesWithEncloser(cl,pClassItem->hItem);
    pClassItem = ClassItemByToken(cl);


    MemberInfo* members = NULL;
    if(NumMembers)
    {
//        members = new MemberInfo[NumMembers];
        members = (MemberInfo*)malloc(sizeof(MemberInfo)*NumMembers);
        if(members == NULL)
        {
//            if(pMemberList) delete pMemberList;
            if(pMemberList) free(pMemberList);
            return FALSE;
        }
    }

    // do in four passes, fields first
    MemberInfo* curMem = members;
    for (i = 0; i < NumMembers; i++) 
    {
        if (TypeFromToken(pMemberList[i]) == mdtFieldDef)
        {
            curMem->token = pMemberList[i];
            curMem->dwAttrs = g_pImport->GetFieldDefProps(pMemberList[i]);
            curMem->pszMemberName = g_pImport->GetNameOfFieldDef(pMemberList[i]);
			MAKE_NAME_IF_NONE(curMem->pszMemberName,pMemberList[i]);
            curMem->pComSig = g_pImport->GetSigOfFieldDef(pMemberList[i], &curMem->cComSig);
            curMem++;
        }
        else break;
    }

    MemberInfo* endMem = curMem;
    if(g_fSortByName) qsort(members, endMem - members, sizeof MemberInfo, memberCmp);
    
    for(curMem = members; curMem < endMem;curMem++) 
    {
		if(g_fLimitedVisibility)
		{
			if(g_fHidePub && IsFdPublic(curMem->dwAttrs)) continue;
			if(g_fHidePriv && IsFdPrivate(curMem->dwAttrs)) continue;
			if(g_fHideFam && IsFdFamily(curMem->dwAttrs)) continue;
			if(g_fHideAsm && IsFdAssembly(curMem->dwAttrs)) continue;
			if(g_fHideFOA && IsFdFamORAssem(curMem->dwAttrs)) continue;
			if(g_fHideFAA && IsFdFamANDAssem(curMem->dwAttrs)) continue;
			if(g_fHidePrivScope && IsFdPrivateScope(curMem->dwAttrs)) continue;
		}
	    AddFieldToGUI(cl, pClassItem, pszNamespace, pszClassName, curMem->pszMemberName, NULL, curMem->token, curMem->dwAttrs);
    }

    // methods second
    curMem = members;
    for (; i < NumMembers; i++) 
    {
        if (TypeFromToken(pMemberList[i]) == mdtMethodDef)
        {
            curMem->token = pMemberList[i];
            curMem->dwAttrs = g_pImport->GetMethodDefProps(pMemberList[i]);
            curMem->pszMemberName = g_pImport->GetNameOfMethodDef(pMemberList[i]);
			MAKE_NAME_IF_NONE(curMem->pszMemberName,pMemberList[i]);
            curMem->pComSig = g_pImport->GetSigOfMethodDef(pMemberList[i], &curMem->cComSig);
            curMem++;
        }
        else break;
    }

    endMem = curMem;
    if(g_fSortByName) qsort(members, endMem - members, sizeof MemberInfo, memberCmp);

    for(curMem = members; curMem < endMem;curMem++) 
    {
		if(g_fLimitedVisibility)
		{
			if(g_fHidePub && IsMdPublic(curMem->dwAttrs)) continue;
			if(g_fHidePriv && IsMdPrivate(curMem->dwAttrs)) continue;
			if(g_fHideFam && IsMdFamily(curMem->dwAttrs)) continue;
			if(g_fHideAsm && IsMdAssem(curMem->dwAttrs)) continue;
			if(g_fHideAsm && g_fHideFam && IsMdFamORAssem(curMem->dwAttrs)) continue;
			if(g_fHideFAA && IsMdFamANDAssem(curMem->dwAttrs)) continue;
			if(g_fHidePrivScope && IsMdPrivateScope(curMem->dwAttrs)) continue;
		}
        AddMethodToGUI(cl, pClassItem, pszNamespace, pszClassName, curMem->pszMemberName, curMem->pComSig, curMem->cComSig, curMem->token, curMem->dwAttrs);
    }
    // events third
    curMem = members;
    for (; i < NumMembers; i++) 
    {
        if (TypeFromToken(pMemberList[i]) == mdtEvent)
        {
            curMem->token = pMemberList[i];
            g_pImport->GetEventProps(curMem->token,&curMem->pszMemberName,&curMem->dwAttrs,(mdToken*)&curMem->pComSig);
			MAKE_NAME_IF_NONE(curMem->pszMemberName,pMemberList[i]);
            curMem++;
        }
        else break;
    }

    endMem = curMem;
    if(g_fSortByName) qsort(members, endMem - members, sizeof MemberInfo, memberCmp);
    curMem = members;
    while(curMem < endMem) 
    {
		if(g_fLimitedVisibility)
		{
			HENUMInternal   hAssoc;
			ASSOCIATE_RECORD rAssoc[1024];
			unsigned nAssoc;
			g_pImport->EnumAssociateInit(curMem->token,&hAssoc);
			if(nAssoc = hAssoc.m_ulCount)
			{
				memset(rAssoc,0,sizeof(rAssoc));
				g_pImport->GetAllAssociates(&hAssoc,rAssoc,nAssoc);

				for(unsigned i=0; i < nAssoc;i++)
				{
					if(TypeFromToken(rAssoc[i].m_memberdef)==mdtMethodDef)
					{
						DWORD dwAttrs = g_pImport->GetMethodDefProps(rAssoc[i].m_memberdef);
						if(g_fHidePub && IsMdPublic(dwAttrs)) continue;
						if(g_fHidePriv && IsMdPrivate(dwAttrs)) continue;
						if(g_fHideFam && IsMdFamily(dwAttrs)) continue;
						if(g_fHideAsm && IsMdAssem(dwAttrs)) continue;
						if(g_fHideFOA && IsMdFamORAssem(dwAttrs)) continue;
						if(g_fHideFAA && IsMdFamANDAssem(dwAttrs)) continue;
						if(g_fHidePrivScope && IsMdPrivateScope(dwAttrs)) continue;
					}
					AddEventToGUI(cl, pClassItem, pszNamespace, pszClassName, dwClassAttrs, curMem->token);
					break;
				}
			}
			g_pImport->EnumClose(&hAssoc);
		}
        else AddEventToGUI(cl, pClassItem, pszNamespace, pszClassName, dwClassAttrs, curMem->token);
        curMem++;
    }
    // properties fourth
    curMem = members;
    for (; i < NumMembers; i++) 
    {
        if (TypeFromToken(pMemberList[i]) == mdtProperty)
        {
            curMem->token = pMemberList[i];
            g_pImport->GetPropertyProps(curMem->token,&curMem->pszMemberName,
                &curMem->dwAttrs,&curMem->pComSig,&curMem->cComSig);
			MAKE_NAME_IF_NONE(curMem->pszMemberName,pMemberList[i]);
            curMem++;
        }
    }

    endMem = curMem;
    if(g_fSortByName) qsort(members, endMem - members, sizeof MemberInfo, memberCmp);
    curMem = members;
    while(curMem < endMem) 
    {
		if(g_fLimitedVisibility)
		{
			HENUMInternal   hAssoc;
			ASSOCIATE_RECORD rAssoc[1024];
			unsigned nAssoc;
			g_pImport->EnumAssociateInit(curMem->token,&hAssoc);
			if(nAssoc = hAssoc.m_ulCount)
			{
				memset(rAssoc,0,sizeof(rAssoc));
				g_pImport->GetAllAssociates(&hAssoc,rAssoc,nAssoc);

				for(unsigned i=0; i < nAssoc;i++)
				{
					if(TypeFromToken(rAssoc[i].m_memberdef)==mdtMethodDef)
					{
						DWORD dwAttrs = g_pImport->GetMethodDefProps(rAssoc[i].m_memberdef);
						if(g_fHidePub && IsMdPublic(dwAttrs)) continue;
						if(g_fHidePriv && IsMdPrivate(dwAttrs)) continue;
						if(g_fHideFam && IsMdFamily(dwAttrs)) continue;
						if(g_fHideAsm && IsMdAssem(dwAttrs)) continue;
						if(g_fHideFOA && IsMdFamORAssem(dwAttrs)) continue;
						if(g_fHideFAA && IsMdFamANDAssem(dwAttrs)) continue;
						if(g_fHidePrivScope && IsMdPrivateScope(dwAttrs)) continue;
					}
					AddPropToGUI(cl, pClassItem, pszNamespace, pszClassName, dwClassAttrs, curMem->token);
					break;
				}
			}
			g_pImport->EnumClose(&hAssoc);
		}
        else AddPropToGUI(cl, pClassItem, pszNamespace, pszClassName, dwClassAttrs, curMem->token);
        curMem++;
    }
//    if(pMemberList) delete pMemberList;
//    if(members) delete members;
    if(pMemberList) free(pMemberList);
    if(members) free(members);
    return hClassRoot;
}

_TCHAR* Rstr(unsigned id)
{
	static _TCHAR buff[2048];
	if(!LoadString(g_hInstance,id,buff,sizeof(buff)/sizeof(_TCHAR))) buff[0] = 0;
	return buff;
}

void CreateMenus()
{
    HMENU   hMenuPopup;

    g_hMenu = CreateMenu();

    hMenuPopup = CreateMenu();
    AppendMenu(hMenuPopup, MF_STRING, IDM_OPEN, Rstr(IDS_OPEN));
    AppendMenu(hMenuPopup, MF_STRING|MF_GRAYED, IDM_DUMP, Rstr(IDS_DUMP));
    AppendMenu(hMenuPopup, MF_STRING|MF_GRAYED, IDM_DUMP_TREE, Rstr(IDS_DUMPTREE));
    AppendMenu(hMenuPopup, MF_STRING, IDM_EXIT, Rstr(IDS_EXIT));
    AppendMenu(g_hMenu, MF_POPUP, (UINT) hMenuPopup, Rstr(IDS_FILE));
    g_hFileMenu = hMenuPopup;

    hMenuPopup = CreateMenu();
	g_hFontMenu = CreateMenu();
	AppendMenu(hMenuPopup,MF_POPUP,(UINT)g_hFontMenu,Rstr(IDS_FONTS));
	AppendMenu(g_hFontMenu,MF_STRING,IDM_FONT_TREE,Rstr(IDS_FONT_TREE));
	AppendMenu(g_hFontMenu,MF_STRING,IDM_FONT_DASM,Rstr(IDS_FONT_DASM));
    AppendMenu(hMenuPopup, MF_STRING|(g_fSortByName ? MF_CHECKED : MF_UNCHECKED), IDM_SORT_BY_NAME, Rstr(IDS_SORT_BY_NAME));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHidePub&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_PUB, Rstr(IDS_SHOW_PUB));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHidePriv&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_PRIV, Rstr(IDS_SHOW_PRIV));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHideFam&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_FAM, Rstr(IDS_SHOW_FAM));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHideAsm&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_ASM, Rstr(IDS_SHOW_ASM));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHideFAA&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_FAA, Rstr(IDS_SHOW_FAA));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHideFOA&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_FOA, Rstr(IDS_SHOW_FOA));
    AppendMenu(hMenuPopup, MF_STRING|(g_fHidePrivScope&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED), IDM_SHOW_PSCOPE, Rstr(IDS_SHOW_PSCOPE));
    AppendMenu(hMenuPopup, MF_STRING|(g_fFullMemberInfo ? MF_CHECKED : MF_UNCHECKED), IDM_FULL_INFO, Rstr(IDS_FULL_INFO));
    AppendMenu(hMenuPopup, MF_STRING|(g_fShowBytes ? MF_CHECKED : MF_UNCHECKED), IDM_BYTES, Rstr(IDS_BYTES));
    AppendMenu(hMenuPopup, MF_STRING|(g_fDumpTokens ? MF_CHECKED : MF_UNCHECKED), IDM_TOKENS, Rstr(IDS_TOKENS));
    AppendMenu(hMenuPopup, MF_STRING|(g_fShowSource ? MF_CHECKED : MF_UNCHECKED), IDM_SOURCELINES, Rstr(IDS_SOURCELINES));
    AppendMenu(hMenuPopup, MF_STRING|(g_fQuoteAllNames ? MF_CHECKED : MF_UNCHECKED), IDM_QUOTEALLNAMES, Rstr(IDS_QUOTEALLNAMES));
	AppendMenu(hMenuPopup, MF_STRING|(g_fTryInCode ? MF_CHECKED : MF_UNCHECKED), IDM_EXPANDTRY, Rstr(IDS_EXPANDTRY));
	if(g_fTDC)
	{
    
		AppendMenu(hMenuPopup, MF_STRING, IDM_SHOW_HEADER, Rstr(IDS_SHOW_HEADER));
		AppendMenu(hMenuPopup, MF_STRING, IDM_SHOW_STAT, Rstr(IDS_SHOW_STAT));
		g_hMetaInfoMenu = CreateMenu();
		AppendMenu(hMenuPopup, MF_POPUP, (UINT)g_hMetaInfoMenu, Rstr(IDS_METAINFO));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpHeader ?   MF_CHECKED : MF_UNCHECKED),IDM_MI_HEADER,Rstr(IDS_MI_HEADER));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpMoreHex ? MF_CHECKED : MF_UNCHECKED),IDM_MI_HEX,Rstr(IDS_MI_HEX));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpCSV ? MF_CHECKED : MF_UNCHECKED),IDM_MI_CSV,Rstr(IDS_MI_CSV));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpUnsat ? MF_CHECKED : MF_UNCHECKED),IDM_MI_UNREX,Rstr(IDS_MI_UNREX));
#ifdef _DEBUG
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpSchema ? MF_CHECKED : MF_UNCHECKED),IDM_MI_SCHEMA,Rstr(IDS_MI_SCHEMA));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpRaw ? MF_CHECKED : MF_UNCHECKED),IDM_MI_RAW,Rstr(IDS_MI_RAW));
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpRawHeaps ? MF_CHECKED : MF_UNCHECKED),IDM_MI_HEAPS,Rstr(IDS_MI_HEAPS));
#endif
		AppendMenu(g_hMetaInfoMenu,MF_STRING|(g_ulMetaInfoFilter & MDInfo::dumpValidate ? MF_CHECKED : MF_UNCHECKED),IDM_MI_VALIDATE,Rstr(IDS_MI_VALIDATE));
		AppendMenu(g_hMetaInfoMenu,MF_STRING,IDM_SHOW_METAINFO,Rstr(IDS_SHOW_METAINFO));
	}
    AppendMenu(g_hMenu, MF_POPUP|MF_GRAYED, (UINT) hMenuPopup, Rstr(IDS_VIEW));
    g_hViewMenu = hMenuPopup;
    hMenuPopup = CreateMenu();
	AppendMenu(hMenuPopup, MF_STRING, IDM_HELP,Rstr(IDS_HELP));
	AppendMenu(hMenuPopup, MF_STRING, IDM_ABOUT,Rstr(IDS_ABOUT));
    AppendMenu(g_hMenu, MF_POPUP, (UINT) hMenuPopup, Rstr(IDS_HELP));
}


BOOL LoadImages()
{
    int i;

    g_hImageList = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_COLOR8, LAST_IMAGE_INDEX, 1);
    if (g_hImageList == NULL)
        return FALSE;

    for (i = 0; i < LAST_IMAGE_INDEX; i++)
    {
        g_hBitmaps[i] = (HBITMAP) LoadImage(
            g_hInstance,
            MAKEINTRESOURCE(i + IDB_CLASS),
            IMAGE_BITMAP,
            15,
            15,
            LR_LOADTRANSPARENT	//LR_DEFAULTCOLOR
        );
        if (g_hBitmaps[i] == NULL)
            return FALSE;
        int index = ImageList_Add(g_hImageList, g_hBitmaps[i], NULL);
        if (index != i)
            return FALSE;
    }

    return TRUE;
}
// Local functions for font persistence:
char* FontSaveFileName()
{
	static char	szFileName[MAX_PATH];
	static BOOL bInit = TRUE;
	if(bInit)
	{
		GetWindowsDirectoryA(szFileName,MAX_PATH);
		if(szFileName[strlen(szFileName)-1]!='\\') strcat(szFileName,"\\");
		strcat(szFileName,"ildasmfnt.bin");
		bInit = FALSE;
	}
	return szFileName;
}
BOOL LoadGUIFonts(LOGFONT* pLogFontDasm, LOGFONT* pLogFontTree)
{
	FILE*	pF;
	BOOL ret = FALSE;
	if(pF = fopen(FontSaveFileName(),"rb"))
	{
		ret = (fread(pLogFontDasm,sizeof(LOGFONT),1,pF) && fread(pLogFontTree,sizeof(LOGFONT),1,pF));
		fclose(pF);
	}
	return ret;
}
BOOL SaveGUIFonts(LOGFONT* pLogFontDasm, LOGFONT* pLogFontTree)
{
	FILE*	pF;
	BOOL ret = FALSE;
	if(pF = fopen(FontSaveFileName(),"wb"))
	{
		ret = (fwrite(pLogFontDasm,sizeof(LOGFONT),1,pF) && fwrite(pLogFontTree,sizeof(LOGFONT),1,pF));
		fclose(pF);
	}
	return ret;
}

// Init various GUI variables, get handles
BOOL InitGUI()
{
    INITCOMMONCONTROLSEX    InitInfo;
#if (0)
	LOGFONT	strDefaultLogFontDasm = {-14,0,0,0,FW_REGULAR,0,0,0,ANSI_CHARSET,
		OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY,FIXED_PITCH | FF_MODERN,"Courier New"};
	LOGFONT	strDefaultLogFontTree = {-12,0,0,0,FW_REGULAR,0,0,0,ANSI_CHARSET,
		OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY,VARIABLE_PITCH | FF_SWISS,"Arial"};
#endif

    InitInfo.dwSize = sizeof(InitInfo);
    InitInfo.dwICC = ICC_LISTVIEW_CLASSES; 

    if (InitCommonControlsEx(&InitInfo) == FALSE)
        return FALSE;

    g_hInstance = GetModuleHandle(NULL);

	//--------- get logical fonts 
	if(LoadGUIFonts(&g_strLogFontDasm,&g_strLogFontTree))
	{
		// -------- create font for disassembly window
		g_hFixedFont = CreateFontIndirect(&g_strLogFontDasm);
		// -------- create font for tree view 
		g_hSmallFont = CreateFontIndirect(&g_strLogFontTree);
	}
	else
	{
		g_hFixedFont = (HFONT)GetStockObject(SYSTEM_FIXED_FONT);
		g_hSmallFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
	}
    if (g_hFixedFont == NULL) return FALSE;
    if (g_hSmallFont == NULL) return FALSE;

	memset(&g_strChFontDasm,0,sizeof(CHOOSEFONT));
	g_strChFontDasm.lStructSize = sizeof(CHOOSEFONT);
	g_strChFontDasm.lpLogFont = &g_strLogFontDasm;
	g_strChFontDasm.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |CF_SHOWHELP | CF_EFFECTS;
	g_strChFontDasm.rgbColors = GetSysColor(COLOR_INFOTEXT);

	memset(&g_strChFontTree,0,sizeof(CHOOSEFONT));
	g_strChFontTree.lStructSize = sizeof(CHOOSEFONT);
	g_strChFontTree.lpLogFont = &g_strLogFontTree;
	g_strChFontTree.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |CF_SHOWHELP /*| CF_EFFECTS*/;
	g_strChFontTree.rgbColors = GetSysColor(COLOR_WINDOWTEXT);

    g_hWhiteBrush = (HBRUSH) GetStockObject(WHITE_BRUSH);
    if (g_hWhiteBrush == NULL)
        return FALSE;

    if (LoadImages() == FALSE)
        return FALSE;

    if (RegisterWindowClasses() == FALSE)
        return FALSE;

    CreateMenus();

    return TRUE;
}


//
// Set the font of a particular window to the global fixed size font
//
void SetWindowFontFixed(HWND hwnd)
{
    SendMessageA(
        hwnd,
        WM_SETFONT,
        (LPARAM) g_hFixedFont,
        FALSE
    );
}


//
// Set the char dimensions variables
//
void SetCharDimensions(HWND hwnd)
{
    if (InterlockedIncrement(&g_SetCharDimensions) == 1)
    {
        HDC         hdc;
        TEXTMETRIC  tm;

        hdc = GetDC(hwnd);

        GetTextMetrics(hdc, &tm);

        g_MaxCharWidth  = tm.tmAveCharWidth;
        g_Height        = tm.tmHeight;

        ReleaseDC(hwnd, hdc);
    }
    else
    {
        // Already set
        InterlockedDecrement(&g_SetCharDimensions);
    }
}


//
// Given a member handle and a class item, find the TreeItem for that member
//
TreeItem_t *FindMemberInClass(ClassItem_t *pClassItem, HTREEITEM hMember)
{
    DWORD i;

    for (i = 0; i < pClassItem->SubItems; i++)
    {
        if (pClassItem->pMembers[i].hItem == hMember)
            return &pClassItem->pMembers[i];
    }

    return NULL;
}


//
// Register the window classes
//
BOOL RegisterWindowClasses()
{
    WNDCLASSEX   wndClass;

    wndClass.cbSize         = sizeof(wndClass);
    wndClass.style          = CS_DBLCLKS|CS_HREDRAW|CS_VREDRAW;
    wndClass.lpfnWndProc    = DisassemblyWndProc;
    wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = 0;
    wndClass.hInstance      = g_hInstance;
    wndClass.hIcon          = LoadIcon(g_hAppInstance,MAKEINTRESOURCE(IDI_ICON2));
    wndClass.hCursor        = NULL;
    wndClass.hbrBackground  = g_hWhiteBrush;
    wndClass.lpszMenuName   = NULL; 
    wndClass.hIconSm        = NULL;
	if(g_fOnUnicode)
	{
		wndClass.lpszClassName  = (char*)DISASSEMBLY_CLASS_NAMEW;
		if (RegisterClassExW((WNDCLASSEXW*)(&wndClass)) == 0)
			return FALSE;
	}
	else
	{
	    wndClass.lpszClassName  = DISASSEMBLY_CLASS_NAME;
		if (RegisterClassExA(&wndClass) == 0)
			return FALSE;
	}

    wndClass.cbSize         = sizeof(wndClass);
    wndClass.style          = CS_DBLCLKS|CS_HREDRAW|CS_VREDRAW;
    wndClass.lpfnWndProc    = MainWndProc;
    wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = 0;
    wndClass.hInstance      = g_hInstance;
    wndClass.hIcon          = LoadIcon(g_hAppInstance,MAKEINTRESOURCE(IDI_ICON2));
    wndClass.hCursor        = NULL;
    wndClass.hbrBackground  = g_hWhiteBrush;
    wndClass.lpszMenuName   = NULL; 
    wndClass.hIconSm        = NULL;

	if(g_fOnUnicode)
	{
		wndClass.lpszClassName  = (char*)MAIN_WINDOW_CLASSW;
		if (RegisterClassExW((WNDCLASSEXW*)(&wndClass)) == 0)
			return FALSE;
	}
	else
	{
	    wndClass.lpszClassName  = MAIN_WINDOW_CLASS;
		if (RegisterClassExA(&wndClass) == 0)
			return FALSE;
	}

    return TRUE;
}


//
// Disassemble the given method in a new window
//

HWND GUIDisassemble(mdTypeDef cl, mdToken mbMember, char *pszNiceMemberName)
{
    HWND            hwndDisassemblyMain;
    HWND            hwndDisassemblyListBox;
    const char *    pszClassName;
    const char *    pszNamespace;
    char*           szTemp=NULL;
    RECT            rcl;

    //before we even try, check if this member's disasm box is already opened
    DisasmBox_t* pDisasmBox = FindDisasmBox(cl, mbMember);
    if(pDisasmBox)
    {
        PostMessageA(pDisasmBox->hwndContainer,WM_ACTIVATE,WA_CLICKACTIVE,0);
        PostMessageA(pDisasmBox->hwndContainer,WM_SETFOCUS,0,0);
        return pDisasmBox->hwndContainer;
    }

    // Prepend class name to nicely formatted member name
    if(mbMember)
    {
        if (cl != mdTokenNil)
        {
            g_pImport->GetNameOfTypeDef(
                cl,
                &pszClassName,
                &pszNamespace
            );
			MAKE_NAME_IF_NONE(pszClassName,cl);
        }
        else
        {
            pszClassName = (TypeFromToken(mbMember) == mdtMethodDef) ? "Global Functions" : "Global Fields";
        }
		if(!g_fOnUnicode) // ClassName: UTF8->ANSI
		{
			int L = strlen(pszClassName);
			WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L+4));
			if(wz)
			{
				memset(wz,0,sizeof(WCHAR)*(L+2));
				WszMultiByteToWideChar(CP_UTF8,0,pszClassName,-1,wz,L+2);
				L = L*3+3;
				char* sz = (char*)malloc(L);
				if(sz)
				{
					memset(sz,0,L);
					WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,L,NULL,NULL);
					szTemp = (char*)malloc(strlen(sz)+strlen(pszNiceMemberName)+4);
					if(szTemp) sprintf(szTemp, "%s::%s", sz, pszNiceMemberName);
					free(sz);
				}
				free(wz);
			}
		}
		else // no conversion, everything UTF8
		{
			szTemp = (char*)malloc(strlen(pszClassName)+strlen(pszNiceMemberName)+4);
			if(szTemp) sprintf(szTemp, "%s::%s", pszClassName, pszNiceMemberName);
		}
        _ASSERTE(TypeFromToken(mbMember) & (mdtMethodDef|mdtEvent|mdtProperty|mdtTypeDef|mdtFieldDef)); 
    }
	if(!szTemp)	szTemp = pszNiceMemberName;
	_ASSERTE(szTemp);
	if(g_fOnUnicode)
	{
		int L = strlen(szTemp);
		WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L+4));
		if(wz)
		{
			memset(wz,0,sizeof(WCHAR)*(L+2));
			WszMultiByteToWideChar(CP_UTF8,0,szTemp,-1,wz,L+2);
		}
		hwndDisassemblyMain = CreateWindowExW(
			WS_EX_CLIENTEDGE,
			DISASSEMBLY_CLASS_NAMEW,
			wz ? wz : L"<NAME ALLOC FAIL>",
			WS_OVERLAPPEDWINDOW | WS_SIZEBOX,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			640,
			400,
			NULL,
			NULL, // menu
			g_hInstance, // hinst
			NULL
		); 
		free(wz);
	}
	else
	{
		hwndDisassemblyMain = CreateWindowExA(
			WS_EX_CLIENTEDGE,
			DISASSEMBLY_CLASS_NAME,
			szTemp,
			WS_OVERLAPPEDWINDOW | WS_SIZEBOX,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			640,
			400,
			NULL,
			NULL, // menu
			g_hInstance, // hinst
			NULL
		); 
	}
	if(szTemp &&(szTemp != pszNiceMemberName)) free(szTemp);
    if (hwndDisassemblyMain == NULL)
        return NULL;
    GetClientRect(hwndDisassemblyMain, &rcl);

	if(g_fOnUnicode)
	{

		hwndDisassemblyListBox = CreateWindowExW(
			0,
			L"EDIT", //RICHEDIT_CLASSW,
			L"Disassembly",
			WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE 
			| ES_MULTILINE | ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_NOHIDESEL,
			rcl.left,
			rcl.top,
			rcl.right - rcl.left,
			rcl.bottom - rcl.top,
			hwndDisassemblyMain,
			(HMENU) ID_LISTBOX,
			g_hInstance, // hinst
			NULL
		); 
	}
	else
	{
		hwndDisassemblyListBox = CreateWindowA(
			"EDIT",
			"Text too large for GUI. Use File/Dump menu entry to disassemble to file.",
			WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE 
			| ES_MULTILINE | ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_NOHIDESEL,
			rcl.left,
			rcl.top,
			rcl.right - rcl.left,
			rcl.bottom - rcl.top,
			hwndDisassemblyMain,
			(HMENU) ID_LISTBOX,
			g_hInstance, // hinst
			NULL
		); 
	}
	if (hwndDisassemblyListBox == NULL)
    {
        DestroyWindow(hwndDisassemblyMain);
        return NULL;
    }

    AddDisasmBox(hwndDisassemblyMain, hwndDisassemblyListBox, cl, mbMember);

    SetWindowFontFixed(hwndDisassemblyListBox);
    SetCharDimensions(hwndDisassemblyListBox);

    void * pvDLB = (void *)hwndDisassemblyListBox;

    memset(GlobalBuffer,0,GlobalBufferLen);
    InGlobalBuffer = 0;

    mdTypeRef       crExtends;
    DWORD           dwClassAttrs;
    if(TypeFromToken(mbMember) && cl && (cl != mdTypeDefNil)) 
        g_pImport->GetTypeDefProps(
                                    cl,
                                    &dwClassAttrs,
                                    &crExtends
                                );
	g_Mode |= MODE_GUI;
    switch (TypeFromToken(mbMember))
    {
        case 0:
            switch(cl)
            {
                case 0:
                    DumpManifest(pvDLB);
                    break;
                case IDM_SHOW_HEADER:
                    DumpHeader(g_CORHeader,pvDLB);
                    DumpHeaderDetails(g_CORHeader,pvDLB);
//					DumpResourceToFile((WCHAR*)	pvDLB);
                    break;
                case IDM_SHOW_METAINFO:
                    DumpMetaInfo(g_szInputFile,NULL,pvDLB);
                    break;
                case IDM_SHOW_STAT:
                    DumpStatistics(g_CORHeader,pvDLB);
                    break;
            }
            break;

        case mdtTypeDef:
            DumpClass(mbMember,g_CORHeader->EntryPointToken, pvDLB, 1); //1 = title+size+pack+custom attributes
            break;
        case mdtFieldDef:
            {
                ULONG ul1,ul2;
                GetClassLayout(cl,&ul1,&ul2);
                DumpField(mbMember,pszClassName, pvDLB, TRUE);
            }
            break;
        case mdtMethodDef:
            DumpMethod(mbMember,pszClassName,g_CORHeader->EntryPointToken, pvDLB, TRUE);
            break;
        case mdtEvent:
            DumpEvent(mbMember,pszClassName, dwClassAttrs, pvDLB, TRUE);
            break;
        case mdtProperty:
            DumpProp(mbMember,pszClassName, dwClassAttrs, pvDLB, TRUE);
            break;
    }
    //SendMessageA(hwndDisassemblyListBox,EM_LIMITTEXT,0, 0);
	if(g_uCodePage==0xFFFFFFFF)
		SendMessageW((HWND)pvDLB,WM_SETTEXT,0, (LPARAM)GlobalBuffer);
	else
	{
		int L = strlen(GlobalBuffer);
		WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(L+4));
		if(wz) 
		{
			memset(wz,0,sizeof(WCHAR)*(L+2));
			int x = WszMultiByteToWideChar(CP_UTF8,0,GlobalBuffer,-1,wz,L+2);
			L = wcslen(wz);
			if(g_fOnUnicode)
			{
				x = (int)SendMessageW(hwndDisassemblyListBox,WM_SETTEXT,0, (LPARAM)wz);
				//if(!x) x = (int)GetLastError();
			}
			else
			{
				L *= 3;
				char* sz = (char*)malloc(L);
				_ASSERTE(sz);
				if(sz)
				{
					memset(sz,0,L);
					WszWideCharToMultiByte(CP_ACP,0,wz,-1,sz,L,NULL,NULL);
					x = SendMessageA((HWND)pvDLB,WM_SETTEXT,0, (LPARAM)sz);
					free(sz);
				}
			}
			free(wz);
		}
	}

    ShowWindow(hwndDisassemblyMain, SW_SHOWNORMAL);
    UpdateWindow(hwndDisassemblyMain);

    return hwndDisassemblyMain;
}


//
// Callback by the disassembler to add another entry to the disassembly window
//
void GUIAddOpcode(char *pszString, void *GUICookie)
{
	if(pszString)
	{
		ULONG L = (g_uCodePage == 0xFFFFFFFF) ? wcslen((WCHAR*)pszString)*sizeof(WCHAR) : strlen(pszString);
		if(InGlobalBuffer+L >= GlobalBufferLen-4)
		{
			ULONG LL = ((L >> 12)+1)<<12;
			char *pch = (char*)malloc(GlobalBufferLen + LL);
			if(pch)
			{
				memcpy(pch,GlobalBuffer,InGlobalBuffer+1);
				free(GlobalBuffer);
				GlobalBuffer = pch;
				GlobalBufferLen += LL;
			}
		}
		if(g_uCodePage == 0xFFFFFFFF)
		{
			swprintf((WCHAR*)&GlobalBuffer[InGlobalBuffer],L"%s\r\n",(WCHAR*)pszString);
			InGlobalBuffer += L+4;
		}
		else
		{
			sprintf(&GlobalBuffer[InGlobalBuffer],"%s\r\n",pszString);
			InGlobalBuffer += L+2;
		}
	}
	else
	{
		free(GlobalBuffer);
		GlobalBufferLen = 0;
		InGlobalBuffer = 0;
	}
}


//
// Someone has double clicked on an item
// 
// It could be a method (diassemble it), or a field (ignore it), or an "extends" or "implements"
// component, in which case we select that component if available.
//
HWND DoubleClickSelectedMember(HTREEITEM hItem)
{
    HTREEITEM hClass;   
    ClassItem_t *pClassItem;
    static HCURSOR hWaitCursor = LoadCursor(NULL,IDC_WAIT);
    //
    // It could be any item, but assume it's a member item or class info and find its parent
    //
    hClass = TreeView_GetParent(g_hwndTreeView, hItem);
    if (hClass == NULL) 
        return NULL; 

    //
    // Find the class item given the HTREEITEM
    // (will return NULL if hClass is not really a class item)
    //
    pClassItem = FindClassItem(hClass);
    if (pClassItem != NULL)
    {
        // Which subitem was it?
        TreeItem_t *pItem = FindMemberInClass(pClassItem, hItem);

        if (pItem == NULL)
            return NULL;

        if (pItem->Discriminator == TREEITEM_TYPE_MEMBER)
        {
            TVITEM      SelItem;
            char*        szText;
            // Must be a method, event or property
            switch (TypeFromToken(pItem->mbMember))
            {
                case mdtMethodDef:
                case mdtEvent:
                case mdtProperty:
                case mdtFieldDef:
                    break;
                default:
                    return NULL;
            }
                    

            // Get the name of this item so that we can title the disassembly window
			szText = (char*)malloc(8192);
			if(szText)
			{
				memset(&SelItem, 0, sizeof(SelItem));
				SelItem.mask = TVIF_TEXT;
				SelItem.pszText = szText;
				SelItem.hItem = pItem->hItem;
				SelItem.cchTextMax = 8192;

				if(g_fOnUnicode)
				{
					WCHAR* wzText = (WCHAR*)szText;
					SelItem.cchTextMax /= sizeof(WCHAR);
					SendMessageW(g_hwndTreeView, TVM_GETITEMW, 0, (LPARAM) (LPTVITEMW) &SelItem);
					unsigned L = ((unsigned)wcslen(wzText)+1)*3;
					char*	szUTFText = (char*)malloc(L);
					memset(szUTFText,0,L);
					WszWideCharToMultiByte(CP_UTF8,0,wzText,-1,szUTFText,L,NULL,NULL);
					free(wzText);
					szText = szUTFText;
				}
				else SendMessageA(g_hwndTreeView, TVM_GETITEMA, 0, (LPARAM) (LPTVITEMA) &SelItem);
			}
			HCURSOR hWasCursor = SetCursor(hWaitCursor);
    
			HWND hRet = GUIDisassemble(pClassItem->cl, pItem->mbMember, szText? szText : "");
			if(szText) free(szText);

			SetCursor(hWasCursor);
			
            return hRet;
        }
        else if (pItem->Discriminator == TREEITEM_TYPE_INFO)
        {
            if(pItem->mbMember)
            {
                if(pItem->mbMember != 0xFFFFFFFF)
                {
                    // We've clicked on an "extends X" or "implements Y", so select that class
                    SelectClassByToken(pItem->mbMember);
                }
                else
                {
                    HCURSOR hWasCursor = SetCursor(hWaitCursor);
                    
                    HWND hRet = GUIDisassemble(0, 0, "MANIFEST");

                    SetCursor(hWasCursor);
                    return hRet;
                }
            }
            else
            {
                TVITEM      SelItem;
                char*       szText = (char*)malloc(8192);
				if(szText)
				{
					// Get the name of this item so that we can title the disassembly window
					memset(&SelItem, 0, sizeof(SelItem));
					SelItem.mask = TVIF_TEXT;
					SelItem.pszText = szText;
					SelItem.hItem = pItem->hItem;
					SelItem.cchTextMax = 8192;

					if(g_fOnUnicode)
					{
						WCHAR* wzText = (WCHAR*)szText;
						SelItem.cchTextMax /= sizeof(WCHAR);
						SendMessageW(g_hwndTreeView, TVM_GETITEMW, 0, (LPARAM) (LPTVITEMW) &SelItem);
						unsigned L = ((unsigned)wcslen(wzText)+1)*3;
						char*	szUTFText = (char*)malloc(L);
						memset(szUTFText,0,L);
						WszWideCharToMultiByte(CP_UTF8,0,wzText,-1,szUTFText,L,NULL,NULL);
						free(wzText);
						szText = szUTFText;
					}
					else SendMessageA(g_hwndTreeView, TVM_GETITEMA, 0, (LPARAM) (LPTVITEMA) &SelItem);
				}
                HCURSOR hWasCursor = SetCursor(hWaitCursor);
                
                HWND hRet = GUIDisassemble(pClassItem->cl, pClassItem->cl, szText ? szText : "");
				if(szText) free(szText);

                SetCursor(hWasCursor);

                return hRet;
            }
        }
    }
    return NULL;
}


void SelectClassByName(char *pszFQName)
{
    ClassItem_t *pDestItem;

    // Find namespace
    char *p = ns::FindSep(pszFQName);
    if (p == NULL)
    {
        pDestItem = FindClassItem(NULL, pszFQName);
    }
    else
    {
        char szBuffer[512];
        strncpy(szBuffer, pszFQName, p - pszFQName);
        szBuffer[ p - pszFQName ] = '\0';
        pDestItem = FindClassItem(szBuffer, p+1);
    }

    if (pDestItem != NULL)
    {
        SendMessageA(g_hwndTreeView, TVM_SELECTITEM, TVGN_CARET, (LPARAM) (LPTVITEM) pDestItem->hItem);
    }
}

void SelectClassByToken(mdToken tk)
{
	if(TypeFromToken(tk)==mdtTypeDef)
	{
	    ClassItem_t *pDestItem;
		if(pDestItem = FindClassItem(tk))
		{
			SendMessageA(g_hwndTreeView, TVM_SELECTITEM, TVGN_CARET, (LPARAM) (LPTVITEM) pDestItem->hItem);
		}
	}
}


//
// Disassembly window(s) WndProc
//
LRESULT CALLBACK DisassemblyWndProc(  
    HWND    hwnd,      
    UINT    uMsg,      
    WPARAM  wParam,  
    LPARAM  lParam   
)
{
    static HBRUSH hBrush=NULL;
	COLORREF	crBackGr;

    switch (uMsg)
    {
        case WM_CREATE:
            hBrush = CreateSolidBrush(RGB(255,255,255));  
            break;

        //===== Sent by Static (label) and Read-Only Edit field =====
        case WM_CTLCOLORSTATIC:
            if(hBrush) DeleteObject(hBrush);
			crBackGr = GetSysColor(COLOR_INFOBK);
            hBrush = CreateSolidBrush(crBackGr); 
            SetBkColor((HDC) wParam, crBackGr);
			g_strChFontDasm.rgbColors = GetSysColor(COLOR_INFOTEXT);
            SetTextColor((HDC) wParam, g_strChFontDasm.rgbColors);
            return (LRESULT) hBrush; 

        //====== Sent by active Edit field ============
        case WM_CTLCOLOREDIT:  
            if(hBrush) DeleteObject(hBrush);
            hBrush = CreateSolidBrush(RGB(255,255,255)); 
            SetBkColor((HDC) wParam, RGB(255,255,255)); 
            return (LRESULT) hBrush; 

        // Ownerdraw stuff
        case WM_MEASUREITEM:
        {
            ((MEASUREITEMSTRUCT *) (lParam))->itemHeight = g_Height;
            break;
        }

        // Ownerdraw stuff
        case WM_DRAWITEM:
        {
            DRAWITEMSTRUCT *pDIS;
            char            szBuf[1024];
            int             ItemID;

            pDIS =  (DRAWITEMSTRUCT *) lParam;
            ItemID = (int) pDIS->itemID;

            if (ItemID < 0)
            {
                switch (pDIS->CtlType)
                {
                    case ODT_LISTBOX:
                    {
                        if ((pDIS->itemAction) & (ODA_FOCUS))
                            DrawFocusRect (PHDC, &PRC);
                        break;
                    }

                    case ODT_COMBOBOX:
                    {
                        if ((pDIS->itemAction) & ODS_FOCUS)
                            DrawFocusRect(PHDC, &PRC);
                        break;
                    }
                }

                return TRUE;
            }

            switch (pDIS->CtlType)
            {
                case ODT_LISTBOX:
                    SendMessageA(pDIS->hwndItem, LB_GETTEXT, pDIS->itemID, (LPARAM)(LPSTR) szBuf);
                    break;

                case ODT_COMBOBOX:
                    SendMessageA(pDIS->hwndItem, CB_GETLBTEXT, pDIS->itemID, (LPARAM)(LPSTR) szBuf);
                    break;
            }

            int crBack,crText;
            HBRUSH hbrBack;

            if ((pDIS->itemState) & (ODS_SELECTED))
            {
                crBack = GetSysColor(COLOR_HIGHLIGHT);
                crText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            }
            else
            {
                crBack = GetSysColor(COLOR_WINDOW);
                crText = GetSysColor(COLOR_WINDOWTEXT);
            }

            hbrBack = CreateSolidBrush(crBack);
            FillRect(PHDC, &PRC, hbrBack);
            DeleteObject(hbrBack);

            // 0x00bbggrr 
            SetBkColor(PHDC, crBack);

            // Instruction counter
            if (strlen(szBuf) >= PADDING && isdigit(*szBuf))
            {
                SetTextColor(PHDC, 0x00FF0000);
                TextOutA(PHDC, PRC.left, PRC.top, szBuf, 5);

                SetTextColor(PHDC, 0x00005500);
                TextOutA(PHDC, PRC.left + (5*g_MaxCharWidth), PRC.top, &szBuf[5], PADDING-5);

                SetTextColor(PHDC, crText);
                TextOutA(PHDC, PRC.left + (PADDING*g_MaxCharWidth), PRC.top, &szBuf[PADDING], strlen(&szBuf[PADDING]));
            }
            else    
                TextOutA(PHDC, PRC.left, PRC.top, szBuf, strlen(szBuf));

            if ((pDIS->itemState) & (ODS_FOCUS))
                DrawFocusRect(PHDC, &PRC);

            break;
        }

        case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
                case LBN_DBLCLK:
                {
                    //char szBuffer[512];
                    char* szBuffer;

                    HWND hwndListBox = (HWND) lParam; 
                    
                    DWORD dwStart,dwEnd;

                    //DWORD CurSel = SendMessageA(hwndListBox, LB_GETCURSEL, 0, 0);
                    //DWORD TextLen = SendMessageA(hwndListBox, LB_GETTEXTLEN, CurSel, 0);
                    SendMessageA(hwndListBox, EM_GETSEL,(WPARAM)&dwStart, (LPARAM)&dwEnd); 
                    DWORD TextLen = dwEnd - dwStart;
                    //szBuffer = new char[dwEnd+1];
                    szBuffer = (char*)malloc(dwEnd+1);
                    memset(szBuffer,0, dwEnd+1);
                    //if (TextLen >= PADDING && TextLen < sizeof(szBuffer))
                    {
                        char *p,*q,*r;

                        //SendMessageA(hwndListBox, LB_GETTEXT, CurSel, (LPARAM) szBuffer);
                        SendMessageA(hwndListBox, WM_GETTEXT, dwEnd, (LPARAM) szBuffer);
                        strcpy(szBuffer, &szBuffer[dwStart]);
                        // Look for classname::method(sig)
                        //p = &szBuffer[PADDING];
                        p = szBuffer;

                        while (isspace(*p))
                            p++;

                        q = strchr(p, ':');
                        if (q != NULL)
                        {
                            char *pszClassName;
                            char *pszSig;
                            char *pszMemberName;
                            char *f;

                            f = q;
                            while (!isspace(*f))
                                f--;

                            pszClassName = f+1;

                            *q = '\0';

                            q += 2;
                            pszMemberName = q;

                            r = strchr(q, '(');

                            if (r != NULL)
                            {
                                *(r-1) = '\0';
                                pszSig = r;

                                DisassembleMemberByName(pszClassName, pszMemberName, pszSig);
                            }
                        }
                        else
                        {
                            if (!strncmp(p, "newobj", 6))
                            {
                                p += 6;
                                while (isspace(*p))
                                    p++;

                                SelectClassByName(p);
                            }
                        }
                    }
//                    delete szBuffer;
                    free(szBuffer);
                    break;
                }
            }

            break;
        }

		case WM_SETFOCUS:
			SetFocus(FindAssociatedDisassemblyListBox(hwnd));
			break;

        case WM_SIZE:
        {
            DWORD   cxClient = LOWORD(lParam);
            DWORD   cyClient = HIWORD(lParam);
            HWND    hListView;

            // We have to size the listview also

            // Will be NULL if we are ourselves a listview
            hListView = FindAssociatedDisassemblyListBox(hwnd);

            if (hListView != NULL)
            {
                // Resize listview window
                MoveWindow(
                    hListView,
                    0,
                    0,
                    cxClient,
                    cyClient,
                    TRUE // repaint
                );
            }

            break;
        }

        case WM_CLOSE:
            if(hBrush) DeleteObject(hBrush);
            RemoveDisasmBox(hwnd);
            DestroyWindow(hwnd);        // Generates the WM_DESTROY message 

        // Shutdown everything if we're just viewing GUI IL and close all our boxes 
            if (IsGuiILOnly() && (g_NumDisasmBoxes == 0)) {     
                    PostQuitMessage(0); 
            }   

            break;          
        
        default : 
            return (g_fOnUnicode ? DefWindowProcW(hwnd, uMsg, wParam, lParam)
				: DefWindowProcA(hwnd, uMsg, wParam, lParam));     
    }  

    return 0;
}

BOOL CALLBACK AboutBoxProc(HWND hwndDlg,  // handle to dialog box
                              UINT uMsg,     // message
                              WPARAM wParam, // first message parameter
                              LPARAM lParam) // second message parameter
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
			{
				char str[1024];
				SendDlgItemMessage(hwndDlg,IDC_ABOUT_LINE1,WM_SETTEXT,0,
					(LPARAM)RstrANSI(IDS_ILDASM_TITLE)); //"Microsoft (R) .NET Framework IL Disassembler");
				sprintf(str,RstrANSI(IDS_VERSION), VER_FILEVERSION_STR);
				SendDlgItemMessage(hwndDlg,IDC_ABOUT_LINE2,WM_SETTEXT,0,(LPARAM)str);
				strcpy(str,RstrANSI(IDS_COPYRIGHT));//VER_LEGALCOPYRIGHT_DOS_STR);
				SendDlgItemMessage(hwndDlg,IDC_ABOUT_LINE3,WM_SETTEXT,0,(LPARAM)str);
			}
            return TRUE;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case ID_ABOUT_OK:
                    EndDialog(hwndDlg,0);
                    return TRUE;
            }
            break;

    }
    return FALSE;
}

BOOL CALLBACK DumpOptionsProc(HWND hwndDlg,  // handle to dialog box
                              UINT uMsg,     // message
                              WPARAM wParam, // first message parameter
                              LPARAM lParam) // second message parameter
{
    static BOOL fAsmChecked;
    static BOOL fMetaChecked;
    switch(uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwndDlg,IDC_RADIO1,BM_SETCHECK,(g_uCodePage==CP_ACP ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_RADIO2,BM_SETCHECK,(g_uCodePage==CP_UTF8 ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_RADIO3,BM_SETCHECK,(g_uCodePage==0xFFFFFFFF ? BST_CHECKED : BST_UNCHECKED),0);


            SendDlgItemMessage(hwndDlg,IDC_CHECK18,BM_SETCHECK,(g_fShowProgressBar ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK1, BM_SETCHECK,(g_fDumpHeader ? BST_CHECKED : BST_UNCHECKED),0);
            if(g_fTDC)
			{
				SendDlgItemMessage(hwndDlg,IDC_CHECK2, BM_SETCHECK,(g_fDumpStats  ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK19, BM_SETCHECK,(g_fDumpClassList  ? BST_CHECKED : BST_UNCHECKED),0);
			}
			else
			{
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK2),  SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK19),  SW_HIDE);
			}
            SendDlgItemMessage(hwndDlg,IDC_CHECK3, BM_SETCHECK,(g_fDumpAsmCode ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK4, BM_SETCHECK,(g_fDumpTokens ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK5, BM_SETCHECK,(g_fShowBytes ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK6, BM_SETCHECK,(g_fShowSource ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK20, BM_SETCHECK,(g_fInsertSourceLines ? BST_CHECKED : BST_UNCHECKED),0);
            SendDlgItemMessage(hwndDlg,IDC_CHECK7, BM_SETCHECK,(g_fTryInCode ? BST_CHECKED : BST_UNCHECKED),0);
            if(!(fAsmChecked = g_fDumpAsmCode))
            {
                EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK4), FALSE);
                EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK5), FALSE);
                EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK6), FALSE);
                EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK7), FALSE);
            }
			if(g_fTDC)
			{
				SendDlgItemMessage(hwndDlg,IDC_CHECK8, BM_SETCHECK,(g_fDumpMetaInfo ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK10,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpHeader ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK11,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpMoreHex ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK12,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpCSV ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK13,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpUnsat ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK16,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpValidate ? BST_CHECKED : BST_UNCHECKED),0);
#ifdef _DEBUG
				SendDlgItemMessage(hwndDlg,IDC_CHECK14,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpSchema ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK15,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpRaw ? BST_CHECKED : BST_UNCHECKED),0);
				SendDlgItemMessage(hwndDlg,IDC_CHECK17,BM_SETCHECK,(g_ulMetaInfoFilter & MDInfo::dumpRawHeaps ? BST_CHECKED : BST_UNCHECKED),0);
#else
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK9),  SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK14),  SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK15), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK17), SW_HIDE);
#endif
				if(!(fMetaChecked = g_fDumpMetaInfo))
				{
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK9), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK10), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK11), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK12), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK13), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK14), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK15), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK16), FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK17), FALSE);
				}
            }
			else
			{
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK8),  SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK9),  SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK10), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK11), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK12), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK13), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK14), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK15), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK16), SW_HIDE);
				ShowWindow(GetDlgItem(hwndDlg,IDC_CHECK17), SW_HIDE);
			}
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CHECK3:
                    fAsmChecked = !fAsmChecked;
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK4), fAsmChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK5), fAsmChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK6), fAsmChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK7), fAsmChecked);
                    return TRUE;

                case IDC_CHECK8:
                    fMetaChecked = !fMetaChecked;
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK9), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK10), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK11), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK12), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK13), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK14), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK15), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK16), fMetaChecked);
                    EnableWindow(GetDlgItem(hwndDlg,IDC_CHECK17), fMetaChecked);
                    return TRUE;

                case IDOK:
					if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_RADIO1, BM_GETCHECK,0,0)) g_uCodePage = CP_ACP;
					if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_RADIO2, BM_GETCHECK,0,0)) g_uCodePage = CP_UTF8;
					if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_RADIO3, BM_GETCHECK,0,0)) g_uCodePage = 0xFFFFFFFF;

					g_fShowProgressBar = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK18, BM_GETCHECK,0,0));
                    g_fDumpHeader = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK1, BM_GETCHECK,0,0));
					if(g_fTDC)
					{
						g_fDumpStats = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK2, BM_GETCHECK,0,0));
						g_fDumpClassList = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK19, BM_GETCHECK,0,0));
					}
					g_fDumpAsmCode = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK3, BM_GETCHECK,0,0));
                    g_fDumpTokens = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK4, BM_GETCHECK,0,0));
                    g_fShowBytes = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK5, BM_GETCHECK,0,0));
                    g_fShowSource = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK6, BM_GETCHECK,0,0));
                    g_fInsertSourceLines = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK20, BM_GETCHECK,0,0));
                    g_fTryInCode = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK7, BM_GETCHECK,0,0));
					if(g_fTDC)
					{
						g_fDumpMetaInfo = (BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK8, BM_GETCHECK,0,0));
						g_ulMetaInfoFilter = 0;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK10, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpHeader;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK11, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpMoreHex;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK12, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpCSV;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK13, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpUnsat;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK16, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpValidate;
#ifdef _DEBUG
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK14, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpSchema;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK15, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpRaw;
						if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHECK17, BM_GETCHECK,0,0)) g_ulMetaInfoFilter |= MDInfo::dumpRawHeaps;
#endif
					}
					EndDialog(hwndDlg,1);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hwndDlg,0);
                    return TRUE;
            }
            break;

    }
    return FALSE;
}
//
// Main window WndProc
//
#define CHECK_UNCHECK(x)  { x=!x; CheckMenuItem(g_hMenu, LOWORD(wParam), (x ? MF_CHECKED : MF_UNCHECKED)); }

LRESULT CALLBACK MainWndProc(  
    HWND    hwnd,      
    UINT    uMsg, 
    WPARAM  wParam,
    LPARAM  lParam   
)
{
    HWND hwndDasm;
    static HCURSOR hWaitCursor = LoadCursor(NULL,IDC_WAIT);

    switch (uMsg)
    {
		case WM_DROPFILES:
		{
			if(g_fOnUnicode)
			{
				WCHAR	wzFileName[512];
				DragQueryFileW((HDROP)wParam,0,wzFileName,512);
				memset(g_szInputFile,0,512);
				WszWideCharToMultiByte(CP_UTF8,0,wzFileName,-1,g_szInputFile,512,NULL,NULL);
			}
			else
			{
				DragQueryFileA((HDROP)wParam,1,g_szInputFile,512);
			}
            {
                HCURSOR hWasCursor = SetCursor(hWaitCursor);
                GUICleanupClassItems();
                TreeView_DeleteAllItems(g_hwndTreeView);
                Cleanup();
                GUISetModule(g_szInputFile);
                DumpFile(g_szInputFile);
                SetCursor(hWasCursor);
            }
			DragFinish((HDROP)wParam);
		}
		break;

        case WM_COMMAND:
        {
			if(HIWORD(wParam) > 1) break; // we are interested in commands from menu only
            switch (LOWORD(wParam))
            {
                case IDM_OPEN:
                {
					WCHAR wzInputFile[512];
					memset(wzInputFile,0,sizeof(wzInputFile));
					if(strlen(g_szInputFile))
					{
						WszMultiByteToWideChar(CP_UTF8,0,g_szInputFile,-1,wzInputFile,511);
					}
					if(g_fOnUnicode)
					{
						OPENFILENAMEW ofn;
						WCHAR* wzFilter = RstrW(IDS_FILTER_IN); //L"PE file (*.exe,*.dll,*.mod,*.mdl)\0*.exe;*.dll;*.mod;*.mdl\0Any type (*.*)\0*.*\0\0";
						const WCHAR* wzDefltExt = L"exe";
                        for(WCHAR* pwc = wzFilter; pwc = wcschr(pwc,'\t'); pwc++) *pwc = 0;
						memset(&ofn,0,sizeof(OPENFILENAMEW));
						ofn.lStructSize = sizeof(OPENFILENAMEW);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = wzFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = wzInputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_FILEMUSTEXIST;
						ofn.lpstrDefExt = wzDefltExt;
						if(GetOpenFileNameW(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							GUICleanupClassItems();
							TreeView_DeleteAllItems(g_hwndTreeView);
							Cleanup();
							memset(g_szInputFile,0,512);
							WszWideCharToMultiByte(CP_UTF8,0,wzInputFile,-1,g_szInputFile,511,NULL,NULL);
							GUISetModule(g_szInputFile);
							DumpFile(g_szInputFile);
							SetCursor(hWasCursor);
						}
					}
					else
					{
						OPENFILENAMEA ofn;
						char* szFilter = RstrANSI(IDS_FILTER_IN); //"PE file (*.exe,*.dll,*.mod,*.mdl)\0*.exe;*.dll;*.mod;*.mdl\0Any type (*.*)\0*.*\0\0";
						const char* szDefltExt = "exe";
						char szInputFile[2048];
                        for(char* pc = szFilter; pc = strchr(pc,'\t'); pc++) *pc = 0;
						memset(&ofn,0,sizeof(OPENFILENAMEA));
						memset(szInputFile,0,2048);
						if(wzInputFile[0])
						{
							WszWideCharToMultiByte(CP_ACP,0,wzInputFile,-1,szInputFile,2048,NULL,NULL);
						}

						ofn.lStructSize = sizeof(OPENFILENAMEA);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = szFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = szInputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_FILEMUSTEXIST;
						ofn.lpstrDefExt = szDefltExt;
						if(GetOpenFileNameA(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							GUICleanupClassItems();
							TreeView_DeleteAllItems(g_hwndTreeView);
							Cleanup();
							memset(wzInputFile,0,sizeof(wzInputFile));
							WszMultiByteToWideChar(CP_ACP,0,szInputFile,-1,wzInputFile,511);
							memset(g_szInputFile,0,512);
							WszWideCharToMultiByte(CP_UTF8,0,wzInputFile,-1,g_szInputFile,511,NULL,NULL);
							GUISetModule(g_szInputFile);
							DumpFile(g_szInputFile);
							SetCursor(hWasCursor);
						}
					}
                    break;
                }
                case IDM_ABOUT:
				{
					DialogBox(g_hAppInstance,MAKEINTRESOURCE(IDD_ABOUT),hwnd,AboutBoxProc);
					break;
				}
                case IDM_DUMP:
                //case IDM_DUMP_TREE:
				if(g_pImport)
                {
					unsigned	uWasCodePage = g_uCodePage;
					WCHAR wzOutputFile[2048];
					memset(wzOutputFile,0,sizeof(wzOutputFile));
					if(strlen(g_szOutputFile))
					{
						WszMultiByteToWideChar(CP_UTF8,0,g_szOutputFile,-1,wzOutputFile,511);
					}
					if(g_fOnUnicode)
					{
						OPENFILENAMEW ofn;
						WCHAR* wzFilter = RstrW(IDS_FILTER_OUT);//L"IL file (*.il)\0*.il\0Text file (*.txt) \0*.txt\0Any type (*.*)\0*.*\0\0";
						const WCHAR* wzDefltExt = L"il";
                        for(WCHAR* pwc = wzFilter; pwc = wcschr(pwc,'\t'); pwc++) *pwc = 0;
						memset(&ofn,0,sizeof(OPENFILENAMEW));
						ofn.lStructSize = sizeof(OPENFILENAMEW);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = wzFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = wzOutputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_OVERWRITEPROMPT;
						ofn.lpstrDefExt = wzDefltExt;
						if(DialogBox(g_hAppInstance,MAKEINTRESOURCE(IDD_DIALOG1),hwnd,DumpOptionsProc) &&
							GetSaveFileNameW(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							g_Mode &= ~MODE_GUI;
							memset(g_szOutputFile,0,512);
							WszWideCharToMultiByte(CP_UTF8,0,wzOutputFile,-1,g_szOutputFile,511,NULL,NULL);
							g_pFile = OpenOutput(g_szOutputFile);
							if(g_pFile) 
							{
								DumpFile(g_szInputFile); // closes g_pFile upon completion
								SetCursor(hWasCursor);
							}
							else 
							{
								SetCursor(hWasCursor);
								MessageBoxW(hwnd,wzOutputFile,L"Cannot open file",MB_OK|MB_ICONERROR);
							}
							g_szOutputFile[0] = 0;
							g_Mode |= MODE_GUI;
							//g_fShowSource = FALSE; // flag could have been changed for dump
						}
					}
					else
					{
						OPENFILENAMEA ofn;
						char* szFilter = RstrANSI(IDS_FILTER_OUT); //"IL file (*.il)\0*.il\0Text file (*.txt) \0*.txt\0Any type (*.*)\0*.*\0\0";
						const char* szDefltExt = "il";
						char szOutputFile[2048];
                        for(char* pc = szFilter; pc = strchr(pc,'\t'); pc++) *pc = 0;
						memset(&ofn,0,sizeof(OPENFILENAMEA));
						memset(szOutputFile,0,2048);
						if(wzOutputFile[0])
						{
							WszWideCharToMultiByte(CP_ACP,0,wzOutputFile,-1,szOutputFile,2048,NULL,NULL);
						}
						ofn.lStructSize = sizeof(OPENFILENAMEA);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = szFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = szOutputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_OVERWRITEPROMPT;
						ofn.lpstrDefExt = szDefltExt;
						if(DialogBox(g_hAppInstance,MAKEINTRESOURCE(IDD_DIALOG1),hwnd,DumpOptionsProc) &&
							GetSaveFileNameA(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							g_Mode &= ~MODE_GUI;
							memset(wzOutputFile,0,sizeof(wzOutputFile));
							WszMultiByteToWideChar(CP_ACP,0,szOutputFile,-1,wzOutputFile,511);
							memset(g_szOutputFile,0,512);
							WszWideCharToMultiByte(CP_UTF8,0,wzOutputFile,-1,g_szOutputFile,511,NULL,NULL);
							g_pFile = OpenOutput(g_szOutputFile);
							if(g_pFile) 
							{
								DumpFile(g_szInputFile); // closes g_pFile upon completion
								SetCursor(hWasCursor);
							}
							else 
							{
								SetCursor(hWasCursor);
								MessageBoxA(hwnd,szOutputFile,"Cannot open file",MB_OK|MB_ICONERROR);
							}
							g_szOutputFile[0] = 0;
							g_Mode |= MODE_GUI;
							//g_fShowSource = FALSE; // flag could have been changed for dump
						}
					}
					g_uCodePage = uWasCodePage; // g_uCodePage is changed in DumpOptionsProc
                }
                break;

                case IDM_DUMP_TREE:
				if(g_pImport)
                {
                   // Dump the tree view(fully expanded, with current sorting) to a text file
					if(g_fOnUnicode)
					{
						OPENFILENAMEW ofn;
						WCHAR* wzFilter = RstrW(IDS_FILTER_OUT2); //L"Text file (*.txt) \0*.txt\0Any type (*.*)\0*.*\0\0";
						const WCHAR* wzDefltExt = L"txt";
						WCHAR    szIndent[2048];
						FILE*   pFile;
						WCHAR wzOutputFile[2048];
                        for(WCHAR* pwc = wzFilter; pwc = wcschr(pwc,'\t'); pwc++) *pwc = 0;
						memset(wzOutputFile,0,sizeof(wzOutputFile));
						memset(&ofn,0,sizeof(OPENFILENAMEW));
						ofn.lStructSize = sizeof(OPENFILENAMEW);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = wzFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = wzOutputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_OVERWRITEPROMPT;
						ofn.lpstrDefExt = wzDefltExt;
						if(GetSaveFileNameW(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							pFile = _wfopen(wzOutputFile,L"wt");
							szIndent[0] = 0;
							if(pFile)
							{
								DumpTreeItemW(g_hRoot,pFile,szIndent);
								fclose(pFile);
								SetCursor(hWasCursor);
							}
							else 
							{
								SetCursor(hWasCursor);
								MessageBoxW(hwnd,wzOutputFile,L"Cannot open file",MB_OK|MB_ICONERROR);
							}
						}
					}
					else
					{
						OPENFILENAMEA ofn;
						char* szFilter = RstrANSI(IDS_FILTER_OUT2); //"Text file (*.txt) \0*.txt\0Any type (*.*)\0*.*\0\0";
						const char* szDefltExt = "txt";
						char    szIndent[1024];
						FILE*   pFile;
						char szOutputFile[2048];
                        for(char* pc = szFilter; pc = strchr(pc,'\t'); pc++) *pc = 0;
						memset(szOutputFile,0,sizeof(szOutputFile));
						memset(&ofn,0,sizeof(OPENFILENAMEA));
						ofn.lStructSize = sizeof(OPENFILENAMEA);
						ofn.hwndOwner = hwnd;
						ofn.lpstrFilter = szFilter;
						ofn.nFilterIndex = 0;
						ofn.lpstrFile = szOutputFile;
						ofn.nMaxFile = 511;
						ofn.Flags = OFN_OVERWRITEPROMPT;
						ofn.lpstrDefExt = szDefltExt;
						if(GetSaveFileNameA(&ofn))
						{
							HCURSOR hWasCursor = SetCursor(hWaitCursor);
							pFile = fopen(szOutputFile,"wt");
							szIndent[0] = 0;
							if(pFile)
							{
								DumpTreeItemA(g_hRoot,pFile,szIndent);
								fclose(pFile);
								SetCursor(hWasCursor);
							}
							else 
							{
								SetCursor(hWasCursor);
								MessageBoxA(hwnd,szOutputFile,"Cannot open file",MB_OK|MB_ICONERROR);
							}
						}
					}
				}
                break;

                case IDM_EXIT:
                {
                    DestroyWindow(hwnd);        // Generates the WM_DESTROY message 
                    break;
                }

                case IDM_FONT_TREE:
                {
					g_strChFontTree.hwndOwner = g_hwndMain;
					if(ChooseFont(&g_strChFontTree))
					{
						DeleteObject((HGDIOBJ)g_hSmallFont);
						g_hSmallFont = CreateFontIndirect(&g_strLogFontTree);
						SendMessageA(g_hwndTreeView,WM_SETFONT,(LPARAM) g_hSmallFont,FALSE);
						SetWindowPos(g_hwndMain,NULL,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);
						if(g_hwndAsmInfo)
						{
							SendMessageA(g_hwndAsmInfo,WM_SETFONT,(LPARAM) g_hSmallFont,FALSE);
							InvalidateRect(g_hwndAsmInfo,NULL,TRUE);
						}
						SaveGUIFonts(&g_strLogFontDasm,&g_strLogFontTree);
					}
                    break;
                }

                case IDM_FONT_DASM:
                {
					g_strChFontDasm.hwndOwner = g_hwndMain;
					if(ChooseFont(&g_strChFontDasm))
					{
						DeleteObject((HGDIOBJ)g_hFixedFont);
						g_hFixedFont = CreateFontIndirect(&g_strLogFontDasm);

						for (DWORD i = 0; i < g_NumDisasmBoxes; i++)
						{
							SendMessageA(g_DisasmBox[i].hwndChild,WM_SETFONT,(LPARAM)g_hFixedFont,FALSE);
							InvalidateRect(g_DisasmBox[i].hwndChild,NULL,TRUE);
						}
						SaveGUIFonts(&g_strLogFontDasm,&g_strLogFontTree);
					}
                    break;
                }

                case IDM_SORT_BY_NAME:
                {
					CHECK_UNCHECK(g_fSortByName);
					if(g_pImport)
					{
						if(!RefreshList())	DestroyWindow(hwnd);
					}
                    break;
                }

                case IDM_SHOW_PUB:
                {
                    g_fHidePub = !g_fHidePub;
UpdateVisibilityOptions:
					g_fLimitedVisibility = g_fHidePub || g_fHidePriv || g_fHideFam || g_fHideFAA || g_fHideFOA || g_fHidePrivScope;

                    CheckMenuItem(g_hMenu, IDM_SHOW_PUB, (g_fHidePub&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_PRIV, (g_fHidePriv&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_FAM, (g_fHideFam&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_ASM, (g_fHideAsm&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_FAA, (g_fHideFAA&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_FOA, (g_fHideFOA&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));
                    CheckMenuItem(g_hMenu, IDM_SHOW_PSCOPE, (g_fHidePrivScope&&g_fLimitedVisibility ? MF_UNCHECKED : MF_CHECKED));

					if(g_pImport)
					{
						if(!RefreshList())	DestroyWindow(hwnd);
					}
                    break;
                }
                case IDM_SHOW_PRIV:
                {
                    g_fHidePriv = !g_fHidePriv;
					goto UpdateVisibilityOptions;
                }
                case IDM_SHOW_FAM:
                {
                    g_fHideFam = !g_fHideFam;
					goto UpdateVisibilityOptions;
                }
                case IDM_SHOW_ASM:
                {
                    g_fHideAsm = !g_fHideAsm;
					goto UpdateVisibilityOptions;
                }
                case IDM_SHOW_FAA:
                {
                    g_fHideFAA = !g_fHideFAA;
					goto UpdateVisibilityOptions;
                }
                case IDM_SHOW_FOA:
                {
                    g_fHideFOA = !g_fHideFOA;
					goto UpdateVisibilityOptions;
                }
                case IDM_SHOW_PSCOPE:
                {
                    g_fHidePrivScope = !g_fHidePrivScope;
					goto UpdateVisibilityOptions;
                }
                case IDM_FULL_INFO:
                {
					CHECK_UNCHECK(g_fFullMemberInfo);
					if(g_pImport)
					{
						if(!RefreshList())	DestroyWindow(hwnd);
					}
                    break;
                }
                case IDM_BYTES:
                {
					CHECK_UNCHECK(g_fShowBytes);
                    break;
                }
                case IDM_TOKENS:
                {
					CHECK_UNCHECK(g_fDumpTokens);
                    break;
                }
                case IDM_SOURCELINES:
                {
					CHECK_UNCHECK(g_fShowSource);
                    break;
                }
                case IDM_EXPANDTRY:
                {
					CHECK_UNCHECK(g_fTryInCode);
                    break;
                }
                case IDM_QUOTEALLNAMES:
                {
					CHECK_UNCHECK(g_fQuoteAllNames);
                    break;
                }
                case IDM_SHOW_HEADER:
                {
                    GUIDisassemble(IDM_SHOW_HEADER,0,"COR Header");
                    break;
                }
                case IDM_SHOW_STAT:
                {
                    GUIDisassemble(IDM_SHOW_STAT,0,"Statistics");
                    break;
                }
                case IDM_HELP:
                {
					WinHelp(hwnd,"dasmhlp.hlp",HELP_FINDER,0);
                    break;
                }
                case IDM_SHOW_METAINFO:
                {
					if(g_pImport)
		                GUIDisassemble(IDM_SHOW_METAINFO,0,"MetaInfo");
                    break;
                }
                case IDM_MI_HEADER:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpHeader) g_ulMetaInfoFilter &= ~MDInfo::dumpHeader;
                    else g_ulMetaInfoFilter |= MDInfo::dumpHeader;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpHeader ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_HEX:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpMoreHex) g_ulMetaInfoFilter &= ~MDInfo::dumpMoreHex;
                    else g_ulMetaInfoFilter |= MDInfo::dumpMoreHex;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpMoreHex ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_CSV:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpCSV) g_ulMetaInfoFilter &= ~MDInfo::dumpCSV;
                    else g_ulMetaInfoFilter |= MDInfo::dumpCSV;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpCSV ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_UNREX:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpUnsat) g_ulMetaInfoFilter &= ~MDInfo::dumpUnsat;
                    else g_ulMetaInfoFilter |= MDInfo::dumpUnsat;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpUnsat ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_SCHEMA:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpSchema) g_ulMetaInfoFilter &= ~MDInfo::dumpSchema;
                    else g_ulMetaInfoFilter |= MDInfo::dumpSchema;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpSchema ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_RAW:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpRaw) g_ulMetaInfoFilter &= ~MDInfo::dumpRaw;
                    else g_ulMetaInfoFilter |= MDInfo::dumpRaw;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpRaw ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_HEAPS:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpRawHeaps) g_ulMetaInfoFilter &= ~MDInfo::dumpRawHeaps;
                    else g_ulMetaInfoFilter |= MDInfo::dumpRawHeaps;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpRawHeaps ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
                case IDM_MI_VALIDATE:
                {
                    WORD iSelection = LOWORD(wParam);
                    if(g_ulMetaInfoFilter & MDInfo::dumpValidate) g_ulMetaInfoFilter &= ~MDInfo::dumpValidate;
                    else g_ulMetaInfoFilter |= MDInfo::dumpValidate;
                    CheckMenuItem(g_hMetaInfoMenu, iSelection, (g_ulMetaInfoFilter & MDInfo::dumpValidate ? MF_CHECKED : MF_UNCHECKED));
                    break;
                }
            }

            break;
        }

		case WM_SETFOCUS:
			SetFocus(g_hwndTreeView);
			break;

        case WM_SIZE:
        {
            DWORD cxClient = LOWORD(lParam);
            DWORD cyClient = HIWORD(lParam);
			DWORD dy;

			dy = cyClient >> 3;
			if(dy < 50) dy = 50;
			if(cyClient < dy+4) cyClient = dy+4;

            // Resize listview window
            MoveWindow(
                g_hwndTreeView,
                0,
                0,
                cxClient,
                cyClient-dy-2,
                TRUE // repaint
            );
            // Resize AsmInfo window
            MoveWindow(
                g_hwndAsmInfo,
                0,
                cyClient-dy-1,
                cxClient,
                dy,
                TRUE // repaint
            );

            break;
        }

        case WM_NOTIFY:
        {
            if (wParam == ID_TREEVIEW)
            {
                NMHDR *  pNMHDR = (NMHDR*) lParam;
                switch (pNMHDR->code)
                {
                    case TVN_KEYDOWN:
                    {
                        NMTVKEYDOWN *pKeyDown = (NMTVKEYDOWN *) pNMHDR;

                        if (pKeyDown->wVKey == '\r')
						{
                            if(DoubleClickSelectedMember(g_CurSelItem) == NULL)
								TreeView_Expand(g_hwndTreeView,g_CurSelItem,TVE_TOGGLE);
						}
                        break;
                    }

                    case NM_DBLCLK:
                    {
                        hwndDasm = DoubleClickSelectedMember(g_CurSelItem);
                        if(hwndDasm)
                        {
                            PostMessageA(hwndDasm,WM_ACTIVATE,WA_CLICKACTIVE,0);
                            PostMessageA(hwndDasm,WM_SETFOCUS,0,0);
                        }
                        break;
                    }

                    case TVN_SELCHANGEDW:
                    case TVN_SELCHANGEDA:
                    {
                        NMTREEVIEW *pTV = (NMTREEVIEW *) pNMHDR;
						/*
                        TVITEM      SelItem;
                        char        szText[256];

                        memset(&SelItem, 0, sizeof(SelItem));
                        SelItem.mask = TVIF_TEXT;
                        SelItem.pszText = szText;
                        SelItem.cchTextMax = sizeof(szText)-1;
                        SelItem.hItem = pTV->itemNew.hItem;

                        g_CurSelItem = SelItem.hItem; 
                        SendMessageA(g_hwndTreeView, TVM_GETITEM, 0, (LPARAM)&SelItem);
						*/
						g_CurSelItem = pTV->itemNew.hItem;
                        break;
                    }
                }
            }

            break;
        }

        case WM_CLOSE:
			WinHelp(hwnd,"dasmhlp.hlp",HELP_QUIT,0);
            DestroyWindow(hwnd);        // Generates the WM_DESTROY message 
            break;          
        
        case WM_DESTROY : 
            PostQuitMessage(0);         // Puts a WM_QUIT in the queue 
            break;

        default :    
            return (g_fOnUnicode ? DefWindowProcW(hwnd, uMsg, wParam, lParam)
				: DefWindowProcA(hwnd, uMsg, wParam, lParam));     
    }  

    return 0;
}


//
// Create the treeview in the main window
//
HWND CreateTreeView(HWND hwndParent)
{
	HWND		hwndTree;
    RECT        rcl;
	DWORD		tvs =
						TVS_HASLINES
						|TVS_HASBUTTONS
						|TVS_LINESATROOT
						|TVS_SHOWSELALWAYS
						// |TVS_TRACKSELECT
						// |TVS_SINGLEEXPAND
						|TVS_DISABLEDRAGDROP
						;
	unsigned	cy,dy;

    GetClientRect(hwndParent, &rcl);
	cy = rcl.bottom - rcl.top;
	dy = cy >> 3;
	if(g_fOnUnicode)
	{
		hwndTree = CreateWindowExW(
			0,
			WC_TREEVIEWW,
			NULL,
			WS_VISIBLE|WS_CHILD|WS_BORDER|tvs,
			0,
			0,
			rcl.right - rcl.left,
			cy-dy-2,	//rcl.bottom - rcl.top,
			hwndParent,
			(HMENU) ID_TREEVIEW,
			g_hInstance,
			NULL
		);
	}
	else
	{
		hwndTree = CreateWindowExA(
			0,
			WC_TREEVIEWA,
			NULL,
			WS_VISIBLE|WS_CHILD|WS_BORDER|tvs,
			0,
			0,
			rcl.right - rcl.left,
			cy-dy-2,	//rcl.bottom - rcl.top,
			hwndParent,
			(HMENU) ID_TREEVIEW,
			g_hInstance,
			NULL
		);
	}
	g_hwndAsmInfo = NULL;
    if (hwndTree == NULL)
        return NULL;

	SendMessageA(hwndTree,WM_SETFONT,(LPARAM) g_hSmallFont,FALSE);

	TreeView_SetBkColor(hwndTree,-1);
    TreeView_SetImageList(hwndTree, g_hImageList, TVSIL_NORMAL);

	if(g_fOnUnicode)
	{
		g_hwndAsmInfo = CreateWindowExW(
			0, //WS_EX_TOOLWINDOW,
			L"EDIT",
			NULL,
			WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE | WS_BORDER //| WS_CAPTION | WS_OVERLAPPEDWINDOW
			| ES_MULTILINE | ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_NOHIDESEL,
			0,
			cy-dy-1,
			rcl.right - rcl.left,
			dy,
			hwndParent,
			(HMENU) ID_LISTBOX,
			g_hInstance, // hinst
			NULL
		); 
	}
	else
	{
		g_hwndAsmInfo = CreateWindowExA(
			0, //WS_EX_TOOLWINDOW,
			"EDIT",
			NULL,
			WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE | WS_BORDER //| WS_CAPTION | WS_OVERLAPPEDWINDOW
			| ES_MULTILINE | ES_READONLY | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_NOHIDESEL,
			0,
			cy-dy-1,
			rcl.right - rcl.left,
			dy,
			hwndParent,
			(HMENU) ID_LISTBOX,
			g_hInstance, // hinst
			NULL
		); 
	}
	if(g_hwndAsmInfo)
	{
		SendMessageA(g_hwndAsmInfo,WM_SETFONT,(LPARAM) g_hSmallFont,FALSE);
	}

    return hwndTree;
}


//
// Add one item to a treeview
//
HTREEITEM AddOneItem(HTREEITEM hParent, const char *pszText, HTREEITEM hInsAfter, int iImage, HWND hwndTree, BOOL fExpanded)
{
    HTREEITEM       hItem;
    ULONG           lLen = (pszText ? strlen(pszText) : 0);

	WCHAR* wz = (WCHAR*)malloc(sizeof(WCHAR)*(lLen+4));
	memset(wz,0,sizeof(WCHAR)*(lLen+4));
	if(pszText) WszMultiByteToWideChar(CP_UTF8,0,pszText,-1,wz,lLen+2);

	if(g_fOnUnicode)
	{
		TVINSERTSTRUCTW tvIns;
		memset(&tvIns, 0, sizeof(tvIns));

		tvIns.item.mask            = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
		tvIns.item.pszText         = wz;
		tvIns.item.cchTextMax      = lLen;
		tvIns.item.iImage          = iImage;
		tvIns.item.iSelectedImage  = iImage;

		tvIns.hInsertAfter  = hInsAfter;
		tvIns.hParent       = hParent;

		hItem = (HTREEITEM)SendMessageW(hwndTree, TVM_INSERTITEMW, 0, (LPARAM)(&tvIns));
	}
	else
	{
		TV_INSERTSTRUCT tvIns;
		TV_ITEM         tvI;
		char*			szText;

		lLen = lLen*3+3;
		szText = (char*)malloc(lLen);
		memset(szText,0,lLen);
		if(pszText) WszWideCharToMultiByte(CP_ACP,0,wz,-1,szText,lLen,NULL,NULL);
		else szText[0] = 0;
		lLen = strlen(pszText);

		memset(&tvI, 0, sizeof(tvI));

		tvI.mask            = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
		tvI.pszText         = (char *) szText;
		tvI.cchTextMax      = lLen;
		tvI.iImage          = iImage;
		tvI.iSelectedImage  = iImage;

		tvIns.item          = tvI;
		tvIns.hInsertAfter  = hInsAfter;
		tvIns.hParent       = hParent;

		hItem = (HTREEITEM)SendMessageA(hwndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);
		free(szText);
	}
	free(wz);

    return hItem;
}


//
// Converts from long form to short form if same namespace
// e.g. System/String --> String
//
// Also converts / to .
//
void TypeToString(const char *pszNamespace, const char **ppszSignature, char *pszType)
{
    DWORD       Dimensions      = 0;
    bool        byref           = false;
    const char  *pszSignature   = *ppszSignature;

    if (*pszSignature == '&')
    {   
        byref = true;   
        pszSignature++;
    }   

    while (*pszSignature == '[')
    {
        pszSignature++;
        Dimensions++;
    }

    switch (*pszSignature++)
    {
        default:
        {
            _ASSERTE(0);
            break;
        }

        case 'R':
            strcpy(pszType, "typedref");
            break;

        case 'B':
            strcpy(pszType, "byte");
            break;

        case 'b':
            strcpy(pszType, "unsigned byte");
            break;

        case 'C':
            strcpy(pszType, "char");
            break;

        case 'D':
            strcpy(pszType, "double");
            break;

        case 'F':
            strcpy(pszType, "float");
            break;

        case 'I':
            strcpy(pszType, "int");
            break;

        case 'J':
            strcpy(pszType, "long");
            break;

        case 'l':
        case 'L':
        {
            GetObjectName(pszNamespace, &pszSignature, pszType);
            break;
        }

        case 'S':
            strcpy(pszType, "short");
            break;

        case 'V':
            strcpy(pszType, "void");
            break;

        case 'Z':
            strcpy(pszType, "bool");
            break;
    }

    while (Dimensions > 0)
    {
        strcat(pszType, "[]");
        Dimensions--;
    }

    if (byref)  
        strcat(pszType, "&");

    *ppszSignature = pszSignature;
}


void AddMethodToGUI(
    mdTypeDef   cl,
    ClassItem_t * pClassItem,
    const char *pszNamespace,
    const char *pszClassName,
    const char *pszMethodName, 
    PCCOR_SIGNATURE pComSig,    
    unsigned    cComSig,
    mdMethodDef mbMethod,
    DWORD       dwAttrs
)
{
    HTREEITEM       hParent;
    char* szName;
    ULONG   ulLen;

    memset(GlobalBuffer,0,GlobalBufferLen);
    sprintf(GlobalBuffer, g_fFullMemberInfo ? "method %s : ": "%s : ",pszMethodName);
    InGlobalBuffer = strlen(GlobalBuffer);
    ulLen = InGlobalBuffer;
    DumpMethod(mbMethod, pszClassName,g_CORHeader->EntryPointToken,(void *)g_hwndTreeView,FALSE);
    GlobalBuffer[InGlobalBuffer-2] = 0; // get rid of \r\n
    
    szName = &GlobalBuffer[ulLen];
    if(strstr(szName,"instance ") == szName) strcpy(szName,szName+9);

    szName = GlobalBuffer;

    hParent = pClassItem->hItem;

    _ASSERTE(pClassItem->CurMember < pClassItem->SubItems);

    pClassItem->pMembers[pClassItem->CurMember].hItem = AddOneItem(
        hParent, szName, TVI_LAST, IsMdStatic(dwAttrs) ? STATIC_METHOD_IMAGE_INDEX : METHOD_IMAGE_INDEX, g_hwndTreeView, FALSE
    );
    pClassItem->pMembers[pClassItem->CurMember].Discriminator = TREEITEM_TYPE_MEMBER;
    pClassItem->pMembers[pClassItem->CurMember].mbMember = mbMethod;
    pClassItem->CurMember++;
}

BOOL NamespaceMatch(const char *pszNamespace, char *pszString)
{
    if (strncmp(pszNamespace, pszString, strlen(pszNamespace)) == 0)
    {
        if (pszString[ strlen(pszNamespace) ] == NAMESPACE_SEPARATOR_CHAR)
            return TRUE;
    }

    return FALSE;
}

//
// *ppszPtr points to right after the L part of the object name
//
// Namespace is provided so that we can truncate the object name if necessary.
//
void GetObjectName(const char *pszNamespace, const char **ppszPtr, char *pszResult)
{
    const char  *p = *ppszPtr;
    char        *q;
    char        szTemp[512];
    char        *pszTemp;
    DWORD       Dimensions = 0;
    DWORD       Skip = 0;

    if (pszNamespace == NULL)
        pszNamespace = "";

    q = strchr(p, ';');
    _ASSERTE(q != NULL);

    strncpy(szTemp, p, q-p);
    szTemp[ q-p ] = 0;

    pszTemp = szTemp;
    while (*pszTemp == '[')
    {
        pszTemp++;
        Dimensions++;
    }

    // match as much of the namespace as possible
    const char *pN1 = pszNamespace;
    const char *pN2 = pszTemp;
    while (*pN1 == *pN2)
    {
        if (*pN1 == '\0')
            break;

        if (*pN1 == NAMESPACE_SEPARATOR_CHAR)
            Skip = (pN1 - pszNamespace)+1;

        pN1++;
        pN2++;
    }

    if (*pN1 == '\0')
        Skip = (pN1 - pszNamespace) +1;

    if (Skip > 1)
    {
        // truncate namespace
        strcpy(pszResult, &pszTemp[Skip]);
    }
    else
    {
       strcpy(pszResult, pszTemp);
    }

    *ppszPtr = q + 1;
}


void AddFieldToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    const char  *pszFieldName, 
    const char  *pszSignature,
    mdFieldDef  mbField,    
    DWORD       dwAttrs
)
{
    DWORD   Dimensions;
    ULONG   ul1,ul2;

    HTREEITEM hParent = pClassItem->hItem;
    
    Dimensions = 0;

    memset(GlobalBuffer,0,GlobalBufferLen);
    sprintf(GlobalBuffer,g_fFullMemberInfo ? "field %s : " : "%s : ",pszFieldName);
    InGlobalBuffer = strlen(GlobalBuffer);
    GetClassLayout(cl,&ul1,&ul2);
    DumpField(mbField, pszClassName,(void *)g_hwndTreeView,FALSE);
    GlobalBuffer[InGlobalBuffer-2] = 0; // get rid of \r\n
    char* pch = strchr(GlobalBuffer,'\r');
    if(pch) strcpy(pch," ...");
    _ASSERTE(pClassItem->CurMember < pClassItem->SubItems);

    pClassItem->pMembers[pClassItem->CurMember].mbMember = mbField;
    pClassItem->pMembers[pClassItem->CurMember].Discriminator = TREEITEM_TYPE_MEMBER;
    pClassItem->pMembers[pClassItem->CurMember++].hItem = AddOneItem(
        hParent, 
        GlobalBuffer, //szType, 
        TVI_LAST, 
        (dwAttrs & mdStatic) ? STATIC_FIELD_IMAGE_INDEX : FIELD_IMAGE_INDEX,
        g_hwndTreeView,
        FALSE
    );
}

void AddEventToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    DWORD       dwClassAttrs,
    mdEvent     mbEvent
)
{
    DWORD   Dimensions;

    HTREEITEM hParent = pClassItem->hItem;
    
    Dimensions = 0;

    memset(GlobalBuffer,0,GlobalBufferLen);
    if(g_fFullMemberInfo) strcpy(GlobalBuffer,"event ");
    InGlobalBuffer = strlen(GlobalBuffer);
    DumpEvent(mbEvent, pszClassName, dwClassAttrs, (void *)g_hwndTreeView, FALSE); //FALSE=don't dump the body
    GlobalBuffer[InGlobalBuffer-2] = 0; // get rid of \r\n

    _ASSERTE(pClassItem->CurMember < pClassItem->SubItems);

    pClassItem->pMembers[pClassItem->CurMember].mbMember = mbEvent;
    pClassItem->pMembers[pClassItem->CurMember].Discriminator = TREEITEM_TYPE_MEMBER;
    pClassItem->pMembers[pClassItem->CurMember++].hItem = AddOneItem(
        hParent, 
        GlobalBuffer, //szType, 
        TVI_LAST, 
        EVENT_IMAGE_INDEX,
        g_hwndTreeView,
        FALSE
    );
}

void AddPropToGUI(
    mdTypeDef   cl, 
    ClassItem_t *pClassItem,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    DWORD       dwClassAttrs,
    mdProperty  mbProp
)
{
    DWORD   Dimensions;

    HTREEITEM hParent = pClassItem->hItem;
    
    Dimensions = 0;

    memset(GlobalBuffer,0,GlobalBufferLen);
    if(g_fFullMemberInfo) strcpy(GlobalBuffer,"prop ");
    InGlobalBuffer = strlen(GlobalBuffer);
    DumpProp(mbProp, pszClassName, dwClassAttrs, (void *)g_hwndTreeView, FALSE); //FALSE=don't dump the body
    GlobalBuffer[InGlobalBuffer-2] = 0; // get rid of \r\n

    _ASSERTE(pClassItem->CurMember < pClassItem->SubItems);

    pClassItem->pMembers[pClassItem->CurMember].mbMember = mbProp;
    pClassItem->pMembers[pClassItem->CurMember].Discriminator = TREEITEM_TYPE_MEMBER;
    pClassItem->pMembers[pClassItem->CurMember++].hItem = AddOneItem(
        hParent, 
        GlobalBuffer, //szType, 
        TVI_LAST, 
        PROP_IMAGE_INDEX,
        g_hwndTreeView,
        FALSE
    );
}



HTREEITEM FindCreateNamespaceRoot(const char *pszNamespace)
{
    DWORD       i;
    HTREEITEM   hRoot;
    DWORD l = 0,ll;

    if (!pszNamespace || !*pszNamespace)
        return g_hRoot; // not in a namespace, use tree root

    hRoot = g_hRoot;
    for (i = 0; i < g_NumNamespaces; i++)
    {
        if (!strcmp(pszNamespace, g_NamespaceList[i].pszNamespace))
            return g_NamespaceList[i].hRoot;
	}
    for (i = 0; i < g_NumNamespaces; i++)
    {
        if(strstr(pszNamespace,g_NamespaceList[i].pszNamespace) == pszNamespace)
        {
			ll = strlen(g_NamespaceList[i].pszNamespace);
			if((ll > l)&&(pszNamespace[ll] == '.'))
			{
				hRoot = g_NamespaceList[i].hRoot;
				l = ll;
			}
        }
    }

    hRoot = AddOneItem(hRoot, pszNamespace, TVI_LAST, NAMESPACE_IMAGE_INDEX, g_hwndTreeView, TRUE);
    g_NamespaceList[g_NumNamespaces].pszNamespace = pszNamespace;
    g_NamespaceList[g_NumNamespaces].hRoot = hRoot;
    g_NumNamespaces++;

    return hRoot;
}


Namespace_t *FindNamespace(const char *pszNamespace)
{
    DWORD i;

    for (i = 0; i < g_NumNamespaces; i++)
    {
        if (!strcmp(pszNamespace, g_NamespaceList[i].pszNamespace))
            return &g_NamespaceList[i];
    }

    return NULL;
}


void GUICleanupClassItems()
{
    DWORD i;
	char* sz="\0\0";

    for (i = 0; i < g_NumClassItems; i++)
    {
//        delete[] g_ClassItemList[i].pMembers;
		if(g_ClassItemList[i].pMembers)
		{
			free(g_ClassItemList[i].pMembers);
			g_ClassItemList[i].pMembers = NULL;
		}
    }
    for (i = 0; i < g_NumDisasmBoxes; i++)
    {
        PostMessageA(g_DisasmBox[i].hwndContainer,WM_CLOSE,0,0);
    }
	SendMessageA(g_hwndAsmInfo,WM_SETTEXT,0,(LPARAM)sz);
    EnableMenuItem(g_hMenu,(UINT)g_hViewMenu, MF_GRAYED);
    EnableMenuItem(g_hFileMenu,IDM_DUMP,MF_GRAYED);
    EnableMenuItem(g_hFileMenu,IDM_DUMP_TREE,MF_GRAYED);
}

//
// Add a new class tree node
//
ClassItem_t *AddClassToGUI(
    mdTypeDef   cl,
    UINT        uImageIndex,
    const char  *pszNamespace, 
    const char  *pszClassName, 
    DWORD       cSubItems, 
    HTREEITEM   *phRoot  // Returns the namespace root (NOT the class root)
)
{
    HTREEITEM   hRoot;

    if(*phRoot)
        hRoot = *phRoot;
    else
    {
        hRoot = FindCreateNamespaceRoot(pszNamespace);
        _ASSERTE(hRoot != NULL);

        *phRoot = hRoot;
    }

    g_ClassItemList[g_NumClassItems].hItem = AddOneItem(hRoot, pszClassName, TVI_LAST, uImageIndex, g_hwndTreeView, FALSE);
    g_ClassItemList[g_NumClassItems].cl = cl;
    g_ClassItemList[g_NumClassItems].SubItems = cSubItems;
    g_ClassItemList[g_NumClassItems].CurMember = 0;
//    g_ClassItemList[g_NumClassItems].pMembers = new TreeItem_t[cSubItems];
    g_ClassItemList[g_NumClassItems].pMembers = (TreeItem_t*)malloc(sizeof(TreeItem_t)*cSubItems);
    _ASSERTE(g_ClassItemList[g_NumClassItems].pMembers);
    g_NumClassItems++;

    return &g_ClassItemList[g_NumClassItems-1];
}


void AddGlobalFunctions()
{
    HRESULT         hr = S_OK;
    HENUMInternal   hEnumMethod;
    mdToken         FuncToken;
    DWORD           i;
    HTREEITEM       hNamespaceRoot = NULL;
    DWORD           NumGlobals;
        
    ClassItem_t* pClassItem =  &g_ClassItemList[0];

    if(SUCCEEDED(g_pImport->EnumGlobalFieldsInit(&hEnumMethod)))
    {
        NumGlobals = g_pImport->EnumGetCount(&hEnumMethod);
//        MemberInfo* fields = new MemberInfo[NumGlobals];
        MemberInfo* fields = (MemberInfo*)malloc(sizeof(MemberInfo)*NumGlobals);
        MemberInfo* curField = fields;

        for (i = 0; g_pImport->EnumNext(&hEnumMethod, &FuncToken); i++)
        {
            curField->token = FuncToken;
            curField->dwAttrs = g_pImport->GetFieldDefProps(FuncToken);
            curField->pszMemberName = g_pImport->GetNameOfFieldDef(FuncToken);
			MAKE_NAME_IF_NONE(curField->pszMemberName,FuncToken);
            //curField->pComSig = g_pImport->GetSigOfFieldDef(FuncToken, &curMethod->cComSig);
            curField++;
        }
        g_pImport->EnumClose(&hEnumMethod);

        _ASSERTE(curField - fields == (int) NumGlobals);

        if(g_fSortByName) qsort(fields, NumGlobals, sizeof MemberInfo, memberCmp);

		for(curField = fields; curField < &fields[NumGlobals];curField++) 
		{
			if(g_fLimitedVisibility)
			{
				if(g_fHidePub && IsFdPublic(curField->dwAttrs)) continue;
				if(g_fHidePriv && IsFdPrivate(curField->dwAttrs)) continue;
				if(g_fHideFam && IsFdFamily(curField->dwAttrs)) continue;
				if(g_fHideAsm && IsFdAssembly(curField->dwAttrs)) continue;
				if(g_fHideFOA && IsFdFamORAssem(curField->dwAttrs)) continue;
				if(g_fHideFAA && IsFdFamANDAssem(curField->dwAttrs)) continue;
				if(g_fHidePrivScope && IsFdPrivateScope(curField->dwAttrs)) continue;
			}
			AddFieldToGUI(NULL, pClassItem, NULL, "Global Fields", curField->pszMemberName, NULL, curField->token, curField->dwAttrs);
		}
//		delete [] fields;
		free(fields);
    }
    if (FAILED(g_pImport->EnumGlobalFunctionsInit(&hEnumMethod)))
        return;

    NumGlobals = g_pImport->EnumGetCount(&hEnumMethod);

//    MemberInfo* methods = new MemberInfo[NumGlobals];
    MemberInfo* methods = (MemberInfo*)malloc(sizeof(MemberInfo)*NumGlobals);
    MemberInfo* curMethod = methods;

    for (i = 0; g_pImport->EnumNext(&hEnumMethod, &FuncToken); i++)
    {
        curMethod->token = FuncToken;
        curMethod->dwAttrs = g_pImport->GetMethodDefProps(FuncToken);
        curMethod->pszMemberName = g_pImport->GetNameOfMethodDef(FuncToken);
		MAKE_NAME_IF_NONE(curMethod->pszMemberName,FuncToken);
        curMethod->pComSig = g_pImport->GetSigOfMethodDef(FuncToken, &curMethod->cComSig);
        curMethod++;
    }
    g_pImport->EnumClose(&hEnumMethod);

    _ASSERTE(curMethod - methods == (int) NumGlobals);

    if(g_fSortByName) qsort(methods, NumGlobals, sizeof MemberInfo, memberCmp);

    for(curMethod = methods; curMethod < &methods[NumGlobals];curMethod++) 
    {
		if(g_fLimitedVisibility)
		{
			if(g_fHidePub && IsMdPublic(curMethod->dwAttrs)) continue;
			if(g_fHidePriv && IsMdPrivate(curMethod->dwAttrs)) continue;
			if(g_fHideFam && IsMdFamily(curMethod->dwAttrs)) continue;
			if(g_fHideAsm && IsMdAssem(curMethod->dwAttrs)) continue;
			if(g_fHideFOA && IsMdFamORAssem(curMethod->dwAttrs)) continue;
			if(g_fHideFAA && IsMdFamANDAssem(curMethod->dwAttrs)) continue;
			if(g_fHidePrivScope && IsMdPrivateScope(curMethod->dwAttrs)) continue;
		}
		AddMethodToGUI(NULL, pClassItem, NULL, "Global Functions", curMethod->pszMemberName, curMethod->pComSig, curMethod->cComSig, curMethod->token, curMethod->dwAttrs);
    }
//	delete [] methods;
	free(methods);
    return;
}


BOOL CreateMainWindow()
{
    DWORD dwStyle, dwStyleEx;
    
// If only showing GUI's IL window, than we don't want to see the main window
// However, main window still manages our data, so we have to still create it. :(
// But we can "pretend" it's not there by hiding it (no WS_VISIBLE, and add WS_EX_TOOLWINDOW)
    if (IsGuiILOnly()) {    
        dwStyle = WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_POPUP | WS_SIZEBOX; 
        dwStyleEx = WS_EX_TOOLWINDOW;   
    } else {    
        dwStyle = WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CAPTION | WS_POPUP | WS_SIZEBOX;    
        dwStyleEx = WS_EX_CLIENTEDGE;  
    }   

	if(g_fOnUnicode)
	{
		g_hwndMain = CreateWindowExW(dwStyleEx,
			MAIN_WINDOW_CLASSW,
			MAIN_WINDOW_CAPTIONW,
			dwStyle,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			400,
			600,
			NULL,
			g_hMenu, // menu
			g_hInstance, // hinst
			NULL
		);
	}
	else
	{
		g_hwndMain = CreateWindowExA(dwStyleEx,
			MAIN_WINDOW_CLASS,
			MAIN_WINDOW_CAPTION,
			dwStyle,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			400,
			600,
			NULL,
			g_hMenu, // menu
			g_hInstance, // hinst
			NULL
		); 
	}
    if (g_hwndMain == NULL)
        return FALSE;
	DragAcceptFiles(g_hwndMain,TRUE);
    return TRUE;
}


//
// Given a CL token, find the classitem for it
//
ClassItem_t *FindClassItem(mdTypeDef cl)
{
    DWORD i;

    for (i = 0; i < g_NumClassItems; i++)
    {
        if (g_ClassItemList[i].cl == cl)
            return &g_ClassItemList[i];
    }

    return NULL;
}


//
// Given a class name, find the classitem for it (may fail)
//
ClassItem_t *FindClassItem(char *pszFindNamespace, char *pszFindName)
{
    DWORD i;

    for (i = 0; i < g_NumClassItems; i++)
    {
        const char *pszClassName;
        const char *pszNamespace;

        if(g_ClassItemList[i].cl)
        {

            g_pImport->GetNameOfTypeDef(
                g_ClassItemList[i].cl,
                &pszClassName,
                &pszNamespace
            );
			MAKE_NAME_IF_NONE(pszClassName,g_ClassItemList[i].cl);

            if (!strcmp(pszFindName, pszClassName))
            {
                if ((((pszFindNamespace == NULL)||(*pszFindNamespace == 0))
					&&((pszNamespace == NULL)||(*pszNamespace == 0))) 
					||(!strcmp(pszFindNamespace, pszNamespace)))
                    return &g_ClassItemList[i];
            }
        }
    }
	//MessageBox(NULL,pszFindName,"Class Not Found",MB_OK);
    return NULL;
}


ClassItem_t *FindClassItem(HTREEITEM hItem)
{
    DWORD i;

    for (i = 0; i < g_NumClassItems; i++)
    {
        if (g_ClassItemList[i].hItem == hItem)
            return &g_ClassItemList[i];
    }

    return NULL;
}


//
// Init GUI components
//
BOOL CreateGUI()
{

    if (InitGUI() == FALSE)
        return FALSE;

    // Register the window class for the main window.      
    if (CreateMainWindow() == FALSE)
        return FALSE;

    g_hwndTreeView = CreateTreeView(g_hwndMain);
    if (g_hwndTreeView == NULL)
        return FALSE;

    return 0;
}


//
// This is the main loop which the disassembler sits in when in GUI mode
//
void GUIMainLoop()
{    
    MSG msg;     
	HACCEL	hAccel = NULL;

	hAccel = LoadAccelerators(g_hInstance,"FileAccel");
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) 
    { 
        // Dispatch message to appropriate window
		if(hAccel && TranslateAccelerator(g_hwndMain,hAccel,&msg));
		else
		{
			TranslateMessage(&msg); 
	        DispatchMessage(&msg); 
		}
    } 
    GUICleanupClassItems();
}

// Dump one tree item to a text file (calls itself recursively)
void DumpTreeItemA(HTREEITEM hSelf, FILE* pFile, char* szIndent)
{
    HTREEITEM   hNext;
    TVITEMEXA    tvi;
    static char       szText[1024];
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_TEXT;
    tvi.hItem = hSelf;
    tvi.pszText = szText;
    tvi.cchTextMax = 1023;
	if(SendMessageA(g_hwndTreeView,TVM_GETITEMA,0,(LPARAM)(&tvi)))
    {
        char* szType = NULL;
        if(hSelf == g_hRoot) szType = "MOD";
        else
        {
            switch(tvi.iImage)
            {
                case CLASS_IMAGE_INDEX:         szType = "CLS"; break;
                case EVENT_IMAGE_INDEX:         szType = "EVT"; break;
                case FIELD_IMAGE_INDEX:         szType = "FLD"; break;
                case NAMESPACE_IMAGE_INDEX:     szType = "NSP"; break;
                case METHOD_IMAGE_INDEX:        szType = "MET"; break;
                case PROP_IMAGE_INDEX:          szType = "PTY"; break;
                case STATIC_FIELD_IMAGE_INDEX:  szType = "STF"; break;
                case STATIC_METHOD_IMAGE_INDEX: szType = "STM"; break;
                case CLASSENUM_IMAGE_INDEX:     szType = "ENU"; break;
                case CLASSINT_IMAGE_INDEX:      szType = "INT"; break;
                case CLASSVAL_IMAGE_INDEX:      szType = "VCL"; break;
            }
        }
        if(szType) fprintf(pFile,"%s___[%s] %s\n",szIndent,szType,szText);
        else       fprintf(pFile,"%s     %s\n",szIndent,szText);
    }
    else fprintf(pFile,"%sGetItemA failed\n",szIndent);
    if(hNext = TreeView_GetChild(g_hwndTreeView,hSelf))
    {
        strcat(szIndent,"   |");
        DumpTreeItemA(hNext,pFile,szIndent);
        szIndent[strlen(szIndent)-4] = 0;
        fprintf(pFile,"%s\n",szIndent);
    }
    if(hNext = TreeView_GetNextSibling(g_hwndTreeView,hSelf))
    {
        DumpTreeItemA(hNext,pFile,szIndent);
    }
}

void DumpTreeItemW(HTREEITEM hSelf, FILE* pFile, WCHAR* szIndent)
{
    HTREEITEM   hNext;
    TVITEMEXW    tvi;
    static WCHAR       szText[2048];
	static char	szTxt[4096];
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_TEXT;
    tvi.hItem = hSelf;
    tvi.pszText = szText;
    tvi.cchTextMax = 2047;
	if(SendMessageW(g_hwndTreeView,TVM_GETITEMW,0,(LPARAM)(&tvi)))
    {
        WCHAR* szType = NULL;
        if(hSelf == g_hRoot) szType = L"MOD";
        else
        {
            switch(tvi.iImage)
            {
                case CLASS_IMAGE_INDEX:         szType = L"CLS"; break;
                case EVENT_IMAGE_INDEX:         szType = L"EVT"; break;
                case FIELD_IMAGE_INDEX:         szType = L"FLD"; break;
                case NAMESPACE_IMAGE_INDEX:     szType = L"NSP"; break;
                case METHOD_IMAGE_INDEX:        szType = L"MET"; break;
                case PROP_IMAGE_INDEX:          szType = L"PTY"; break;
                case STATIC_FIELD_IMAGE_INDEX:  szType = L"STF"; break;
                case STATIC_METHOD_IMAGE_INDEX: szType = L"STM"; break;
                case CLASSENUM_IMAGE_INDEX:     szType = L"ENU"; break;
                case CLASSINT_IMAGE_INDEX:      szType = L"INT"; break;
                case CLASSVAL_IMAGE_INDEX:      szType = L"VCL"; break;
            }
        }
		memset(szTxt,0,sizeof(szTxt));
		WszWideCharToMultiByte(CP_ACP,0,szText,-1,szTxt,sizeof(szTxt),NULL,NULL);

        if(szType) fprintf(pFile,"%lS___[%lS] %s\n",szIndent,szType,szTxt);
        else       fprintf(pFile,"%lS     %s\n",szIndent,szTxt);
    }
    else fwprintf(pFile,L"%sGetItemW failed\n",szIndent);
    if(hNext = TreeView_GetChild(g_hwndTreeView,hSelf))
    {
        wcscat(szIndent,L"   |");
        DumpTreeItemW(hNext,pFile,szIndent);
        szIndent[wcslen(szIndent)-4] = 0;
        fwprintf(pFile,L"%s\n",szIndent);
    }
    if(hNext = TreeView_GetNextSibling(g_hwndTreeView,hSelf))
    {
        DumpTreeItemW(hNext,pFile,szIndent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ILDASM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework IL disassembler\0"
#define VER_ORIGFILENAME_STR    "ildasm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\accountinginfostore.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Accounting information in persisted store
 *
 * Author: Shajan Dasan
 * Date:  Feb 17, 2000
 *
 ===========================================================*/

#pragma once

#include "PersistedStore.h"

#pragma pack(push, 1)

// Application data of persisted store header will point to this structure.
typedef struct
{
    PS_HANDLE hTypeTable;       // The Type table
    PS_HANDLE hAccounting;      // The Accounting table
    PS_HANDLE hTypeBlobPool;    // Blob Pool for serialized type objects
    PS_HANDLE hInstanceBlobPool;// Blob Pool for serialized instances
    PS_HANDLE hAppData;         // Application Specific
    PS_HANDLE hReserved[10];    // Reserved for applications
} AIS_HEADER, *PAIS_HEADER;

// One Record in a type table
typedef struct
{
    PS_HANDLE hTypeBlob;        // handle to the blob of serialized type
    PS_HANDLE hInstanceTable;   // handle to the instance table
    DWORD     dwTypeID;         // A unique id for the type
    WORD      wTypeBlobSize;    // Number of bytes in the type blob
    WORD      wReserved;        // Must be 0
} AIS_TYPE, *PAIS_TYPE;

// One Record in an instance table
typedef struct
{
    PS_HANDLE hInstanceBlob;    // Serialized Instance
    PS_HANDLE hAccounting;      // Accounting information record
    DWORD     dwInstanceID;     // Unique in this table
    WORD      wInstanceBlobSize;// Size of the serialized instance
    WORD      wReserved;        // Must be 0
} AIS_INSTANCE, *PAIS_INSTANCE;

// One Record in the Accounting table
typedef struct
{
    QWORD   qwUsage;            // The amount of resource used
    DWORD   dwLastUsed;         // Last time the entry was used
    DWORD   dwReserved[9];      // For future use, set to 0
} AIS_ACCOUNT, *PAIS_ACCOUNT;

#pragma pack(pop)

#define AIS_TYPE_BUCKETS         7  // buckets in the type hash table
#define AIS_TYPE_RECS_IN_ROW     8  // records in one row of a bucket

#define AIS_INST_BUCKETS        503 // buckets in the instance hash table
#define AIS_INST_RECS_IN_ROW    20  // records in one row of a bucket

#define AIS_ROWS_IN_ACC_TABLE_BLOCK 1024    // Rows in one block

#define AIS_TYPE_BLOB_POOL_SIZE 1024*10     // Initial type blob pool size
#define AIS_INST_BLOB_POOL_SIZE 1024*100    // Initial instance bloob pool size

/*
    Structure of Accounts Info Store

    Each type has a unique cookie, and an instance table.
    An Instance table will have different instances, each instance having a 
    cookie, which is unique within that table.

    Eg : (FileStore).

        StoreHeader.ApplicationData ->
            Type Table handle : 100
            Accounting Table  : 200


        Type Table (at 100)
        ..........................

        --------------------------------------------------------------------
        Type                            Cookie      InstanceTable handle
        --------------------------------------------------------------------
        System.Security.Policy.Zone     1           850
        System.Security.Policy.Site     2           900
        ...
        ...
        User.CustomIdentity             100         930
        ---------------------------------------------------------------------


        Instance table for Type 2 (at 900)
        .........................................
        
        --------------------------------------------------------------
        Instance                        Cookie  Accounting Info handle
        --------------------------------------------------------------
        www.microsoft.com               1       240
        www.msn.com                     2       360
        ....
        www.yahoo.com                   100
        --------------------------------------------------------------

        ..
        ..


        Accounting Table (at handle 200)
        ................................

        ---------------------------
        Used space      Last Access
        ---------------------------
        ...
        ...
        (h 240) 100   1/3/2000
        ...
        ...
        ...
        (h 360) 260   11/4/1971
        ...
        ...
        ---------------------------
 */

// Predefined IDs for known identity types
typedef enum 
{
    ePS_Zone        = 1,
    ePS_Site        = 2,
    ePS_URL         = 3,
    ePS_Publisher   = 4,
    ePS_StrongName  = 5,
    ePS_CustomIdentityStart = 16
} ePSIdentityType;

class AccountingInfoStore
{
public:
    AccountingInfoStore(PersistedStore *ps);

    ~AccountingInfoStore();

    HRESULT Init();

    // Get the Type cookie and Instance table 
    HRESULT GetType(
		PBYTE      pbType,      // Type Signature
		WORD       cbType,      // nBytes in Type Sig
		DWORD      dwHash,      // Hash of Type [Sig]
		DWORD     *pdwTypeID,   // [out] Type cookie
        PS_HANDLE *phInstTable);// [out] Instance table

    // Get the Instance cookie and Accounting record
    HRESULT GetInstance(
		PS_HANDLE  hInstTable,  // Instance table
		PBYTE      pbInst,      // Instance Signature
		WORD       cbInst,      // nBytes in Instance Sig
		DWORD      dwHash,      // Hash of Instance [Sig]
		DWORD     *pdwInstID,   // [out] instance cookie
        PS_HANDLE *phAccRec);   // [out] Accounting Record

    // Reserves space (Increments qwQuota)
    // This method is synchrinized. If quota + request > limit, method fails
    HRESULT Reserve(
        PS_HANDLE  hAccInfoRec, // Accounting info record    
        QWORD      qwLimit,     // The max allowed
        QWORD      qwRequest,   // amount of space (request / free)
        BOOL       fFree);      // TRUE will free, FALSE will reserve

    // Method is not synchronized. So the information may not be current.
    // This implies "Pass if (Request + GetUsage() < Limit)" is an Error!
    // Use Reserve() method instead.
    HRESULT GetUsage(
        PS_HANDLE   hAccInfoRec,// Accounting info record    
        QWORD      *pqwUsage);  // Returns the amount of space / resource used

    // Returns the underlying persisted store instance
    PersistedStore* GetPS();

    // Given a Type & Instance ID, get the Instance blob and AccountingInfo
    // Return S_FALSE if no such entry is found.
    HRESULT ReverseLookup(
        DWORD       dwTypeID,   // Type cookie
        DWORD       dwInstID,   // Instance cookie
        PS_HANDLE   *phAccRec,  // [out] Accounting Record
        PS_HANDLE   *pInstance, // [out] Instance Sig
        WORD        *pcbInst);  // [out] nBytes in Instance Sig

private:

    PersistedStore *m_ps;       // The Persisted Store
    AIS_HEADER      m_aish;     // copy of the header
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\allocacheck.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*********************************************************************/
/*                           AllocaCheck                             */
/*********************************************************************/

/* check for alloca overruns (which otherwise are hard to track down
   and often only repro on optimized builds).  

   USAGE:

		void foo() {	
			ALLOCA_CHECK();				// Declare at function level scope

			....
			void* mem = ALLOCA(size);	// does an alloca, 

		}	// destructor of ALLOCA_CHECK for buffer overruns.  
*/

/* Author: Vance Morrison */
/*********************************************************************/

#ifndef AllocaCheck_h
#define AllocaCheck_h
#include <malloc.h>			// for alloca itself

#if defined(assert) && !defined(_ASSERTE)
#define _ASSERTE assert
#endif

#if defined(_DEBUG) || defined(DEBUG)

/*********************************************************************/
class AllocaCheck {
public:
	enum { CheckBytes = 0xCCCDCECF,
		 };

	struct AllocaSentinal {
		int check;
		AllocaSentinal* next;
	};

public:
	/***************************************************/
	AllocaCheck() { 
		sentinals = 0; 
	}

	~AllocaCheck() { 
		AllocaSentinal* ptr = sentinals;
		while (ptr != 0) {
			if (ptr->check != CheckBytes)
				_ASSERTE(!"alloca buffer overrun");
			ptr = ptr->next;
		}
	}

	void* add(void* allocaBuff, unsigned size) {
		AllocaSentinal* newSentinal = (AllocaSentinal*) ((char*) allocaBuff + size);
		newSentinal->check = CheckBytes;
		newSentinal->next = sentinals;
		sentinals = newSentinal;
        memset(allocaBuff, 0xDD, size);
		return allocaBuff;
	}

private:
	AllocaSentinal* sentinals;
};

#define ALLOCA_CHECK() AllocaCheck __allocaChecker
#define ALLOCA(size)  __allocaChecker.add(_alloca(size+sizeof(AllocaCheck::AllocaSentinal)), size);

#else

#define ALLOCA_CHECK() 
#define ALLOCA(size)  _alloca(size)

#endif
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\util.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// util.hpp
//
// Miscellaneous useful functions
//
#ifndef _H_UTIL
#define _H_UTIL

#include <objbase.h>

#ifdef _DEBUG
#include <crtdbg.h>
#undef _ASSERTE    // utilcode defines a custom _ASSERTE
#endif

#include "utilcode.h"

#endif /* _H_UTIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dasm.rc
//
#define IDS_FILE                        1
#define IDS_VIEW                        2
#define IDS_HELP                        3
#define IDS_OPEN                        4
#define IDS_DUMP                        5
#define IDS_DUMPTREE                    6
#define IDS_EXIT                        7
#define IDS_FONTS                       8
#define IDS_FONT_TREE                   9
#define IDS_FONT_DASM                   10
#define IDS_SORT_BY_NAME                11
#define IDS_SHOW_PUB                    12
#define IDS_SHOW_PRIV                   13
#define IDS_SHOW_FAM                    14
#define IDS_SHOW_ASM                    15
#define IDS_SHOW_FAA                    16
#define IDS_SHOW_FOA                    17
#define IDS_SHOW_PSCOPE                 18
#define IDS_FULL_INFO                   19
#define IDS_BYTES                       20
#define IDS_TOKENS                      21
#define IDS_SOURCELINES                 22
#define IDS_QUOTEALLNAMES               23
#define IDS_EXPANDTRY                   24
#define IDS_SHOW_HEADER                 25
#define IDS_SHOW_STAT                   26
#define IDS_METAINFO                    27
#define IDS_MI_HEADER                   28
#define IDS_MI_HEX                      29
#define IDS_MI_CSV                      30
#define IDS_MI_UNREX                    31
#define IDS_MI_DEBUG                    32
#define IDS_MI_SCHEMA                   33
#define IDS_MI_RAW                      34
#define IDS_MI_HEAPS                    35
#define IDS_MI_VALIDATE                 36
#define IDS_SHOW_METAINFO               37
#define IDS_ABOUT                       38
#define IDS_ABOUT_COPYRIGHTINFO         39
#define IDS_PRODUCTNAME                 40
#define IDS_MAINWINDOWCAPTION           41
#define IDS_MAINWINDOWCAPTIONAPPEND     42
#define IDS_NETHEADER                   43
#define IDS_STATISTICS                  44
#define IDS_METAINFOTEXT                45
#define IDS_FILTER_IN                   46
#define IDS_FILTER_OUT                  47
#define IDS_VERSION                     48
#define IDS_COPYRIGHT                   49
#define IDS_PBAR_FILE1                  50
#define IDS_PBAR_FILE2                  51
#define IDS_PBAR_TOFILE                 52
#define IDS_PBAR_STAGE1                 53
#define IDS_PBAR_STAGE2                 54
#define IDS_PBAR_STAGE3                 55
#define IDS_PBAR_TITLE                  56
#define IDS_FILTER_OUT2                 57
#define IDS_ILDASM_TITLE                58

#define IDI_ICON2                       136
#define IDD_DIALOG1                     137
#define IDD_ABOUT                       149
#define IDR_MAINMENU                    149
#define IDI_ICON1                       150

#define IDS_USAGE_TITLE                 200
#define IDS_USAGE_01                    IDS_USAGE_TITLE + 1
#define IDS_USAGE_02                    IDS_USAGE_01 + 1
#define IDS_USAGE_03                    IDS_USAGE_02 + 1
#define IDS_USAGE_04                    IDS_USAGE_03 + 1
#define IDS_USAGE_05                    IDS_USAGE_04 + 1
#ifdef OWNER_OPTION_ENABLED
#define IDS_USAGE_06                    IDS_USAGE_05 + 1
#else
#define IDS_USAGE_06                    IDS_USAGE_05
#endif
#define IDS_USAGE_07                    IDS_USAGE_06 + 1
#define IDS_USAGE_08                    IDS_USAGE_07 + 1
#define IDS_USAGE_09                    IDS_USAGE_08 + 1
#define IDS_USAGE_10                    IDS_USAGE_09 + 1
#ifdef _DEBUG
#define IDS_USAGE_10A                   IDS_USAGE_10 + 1
#else
#define IDS_USAGE_10A                   IDS_USAGE_10
#endif
#define IDS_USAGE_11                    IDS_USAGE_10A + 1
#define IDS_USAGE_12                    IDS_USAGE_11 + 1
#define IDS_USAGE_13                    IDS_USAGE_12 + 1
#define IDS_USAGE_14                    IDS_USAGE_13 + 1
#define IDS_USAGE_15                    IDS_USAGE_14 + 1
#define IDS_USAGE_16                    IDS_USAGE_15 + 1
#define IDS_USAGE_17                    IDS_USAGE_16 + 1
#define IDS_USAGE_18                    IDS_USAGE_17 + 1
#define IDS_USAGE_19                    IDS_USAGE_18 + 1
#define IDS_USAGE_20					IDS_USAGE_19 + 1
#define IDS_USAGE_21                    IDS_USAGE_20 + 1
#define IDS_USAGE_22                    IDS_USAGE_21 + 1
#define IDS_USAGE_23                    IDS_USAGE_22 + 1
#define IDS_USAGE_24                    IDS_USAGE_23 + 1
#define IDS_USAGE_25                    IDS_USAGE_24 + 1
#define IDS_USAGE_26                    IDS_USAGE_25 + 1
#define IDS_USAGE_27                    IDS_USAGE_26 + 1
#define IDS_USAGE_28                    IDS_USAGE_27 + 1
#define IDS_USAGE_29                    IDS_USAGE_28 + 1
#define IDS_USAGE_30                    IDS_USAGE_29 + 1
#define IDS_USAGE_31                    IDS_USAGE_30 + 1
#define IDS_USAGE_32                    IDS_USAGE_31 + 1
#define IDS_USAGE_33                    IDS_USAGE_32 + 1
#define IDS_USAGE_34                    IDS_USAGE_33 + 1
#define IDS_USAGE_35                    IDS_USAGE_34 + 1
#define IDS_USAGE_36                    IDS_USAGE_35 + 1
#define IDS_USAGE_37                    IDS_USAGE_36 + 1
#define IDS_USAGE_38                    IDS_USAGE_37 + 1
#define IDS_USAGE_39                    IDS_USAGE_38 + 1
#define IDS_USAGE_40                    IDS_USAGE_39 + 1
#define IDS_USAGE_41                    IDS_USAGE_40 + 1
#define IDS_USAGE_42                    IDS_USAGE_41 + 1
#define IDS_USAGE_43                    IDS_USAGE_42 + 1

#define IDB_CLASS                       300
#define IDB_EVENT                       301
#define IDB_METHOD                      302
#define IDB_NAMESPACE                   303
#define IDB_FIELD                       304
#define IDB_PROP                        305
#define IDB_STATICMETHOD                306
#define IDB_STATICFIELD                 307
#define IDB_REDARROW                    308
#define IDB_CLASSENUM                   309
#define IDB_CLASSINT                    310
#define IDB_CLASSVAL                    311
#define IDS_E_INITLDR                   401
#define IDS_E_FILEOPEN                  402
#define IDS_E_NOCORHDR                  403
#define IDS_E_BADCORHDR                 404
#define IDS_E_OPENMD                    405
#define IDS_E_COPYRIGHT                 406
#define IDS_E_DASMABORT                 407
#define IDS_E_DASMOK                    408
#define IDS_E_PARTDASM                  409
#define IDS_E_INSTRDT                   410
#define IDS_E_NOCOMPR                   411
#define IDS_E_CLSENUM                   412
#define IDS_E_SELFNSTD                  413
#define IDS_E_NOENCLOS                  414
#define IDS_E_INVALIDTK                 415
#define IDS_E_UNEXPTYPE                 416
#define IDS_E_AUTOCA                    417
#define IDS_E_PARAMSEQNO                418
#define IDS_E_METHBEG                   419
#define IDS_E_DASMERR                   420
#define IDS_E_DASMNATIVE                421
#define IDS_E_METHODRT                  422
#define IDS_E_NORVA                     423
#define IDS_E_MEMBRENUM                 424
#define IDS_E_ODDMEMBER                 425
#define IDS_E_ENUMINIT                  426
#define IDS_E_NODATA                    427
#define IDS_E_VTFUTABLE                 428
#define IDS_E_BOGUSRVA                  429
#define IDS_E_EATJTABLE                 430
#define IDS_E_EATJSIZE                  431
#define IDS_E_RESFLAGS                  432
#define IDS_E_MIHENTRY                  433
#define IDS_E_CODEMGRTBL                434
#define IDS_E_IMPORTDATA                435
#define IDS_E_COMIMAGE                  436
#define IDS_E_MDDETAILS                 437
#define IDS_E_MISTART                   438
#define IDS_E_MIEND                     439
#define IDS_E_ONLYITEMS                 440
#define IDS_E_ROGUEPTR                  441
#define IDS_E_DECOMPRESS                442
#define IDS_E_COMPRESSED                443
#define IDS_E_CODESIZE                  444
#define IDS_E_BOGUSLVSIG                445
#define IDS_E_INSTRDECOD                446
#define IDS_E_INSTRTYPE                 447
#define IDS_E_ARGINDEX                  448
#define IDS_E_LVINDEX                   449
#define IDS_E_DEPRECINSTR               450
#define IDS_E_SECTHEADER                451
#define IDS_E_BADTOKENTYPE              452
#define IDS_E_DEPRDIR                   453
#define IDS_E_MDAIMPORT                 454
#define IDS_E_MDAFROMMDI                455
#define IDS_E_MDIIMPORT                 456
#define IDS_E_NOMANIFEST                457
#define IDC_CHECK1                      1000
#define IDC_CHECK2                      1001
#define IDC_CHECK3                      1002
#define IDC_CHECK4                      1003
#define IDC_CHECK5                      1004
#define IDC_CHECK6                      1005
#define IDC_CHECK7                      1006
#define IDC_CHECK8                      1007
#define IDC_CHECK9                      1008
#define IDC_CHECK10                     1009
#define IDC_CHECK11                     1010
#define IDC_CHECK12                     1011
#define IDC_CHECK13                     1012
#define IDC_CHECK14                     1013
#define IDC_CHECK15                     1014
#define IDC_CHECK16                     1015
#define IDC_CHECK17                     1016
#define IDC_CHECK18                     1017
#define IDC_CHECK19                     1018
#define IDC_CHECK20                     1019
#define IDC_RADIO1                      1020
#define IDC_RADIO2                      1021
#define IDC_ABOUT_LINE1                 1021
#define ID_ABOUT_COPYRIGHTINFO          1021
#define IDC_ABOUT_COPYRIGHTINFO         1021
#define IDC_RADIO3                      1022
#define ID_ABOUT_OK                     1022
#define IDC_ABOUT_LINE2                 1023
#define IDC_ABOUT_PRODUCTNAME           1023
#define IDC_ABOUT_LINE3                 1024
#define IDC_ABOUT_VERSION               1024
#define IDC_ABOUT_LEGALCOPYRIGHT        1025
#define ID_EXPORT                       32771
#define ID_HELP_ABOUT                   32772
#define ID_HELP_CONTENTS                32773
#define ID_FILE_DUMP                    32774
#define ID_FILE_DUMP_TREEVIEW           32775
#define ID_FILE_EXIT                    32776
#define ID_VIEW_SORTBYNAME              32778
#define ID_VIEW_SHOWPUBLIC              32779
#define ID_VIEW_SHOWPRIVATE             32780
#define ID_VIEW_SHOWFAMILY              32781
#define ID_VIEW_SHOWASSEMBLY            32782
#define ID_VIEW_SHOWFAMANDASSEM         32783
#define ID_VIEW_SHOWFAMORASSEM          32784
#define ID_VIEW_SHOWPRIVATESCOPE        32785
#define ID_VIEW_SHOWMEMBERTYPES         32786
#define ID_VIEW_SHOWBYTES               32787
#define ID_VIEW_SHOWTOKENVALUES         32788
#define ID_VIEW_SHOWSOURCELINES         32789
#define ID_VIEW_QUOTEALLNAMES           32790
#define ID_VIEW_EXPANDTRYCATCH          32791
#define ID_VIEW_NETRUNTIMEHEADER        32792
#define ID_VIEW_STATISTICS              32793
#define ID_VIEW_SETFONTS_TREEVIEW       32795
#define ID_VIEW_SETFONTS_DISASSEMBLY    32796
#define ID_VIEW_METAINFO_HEADER         32797
#define ID_VIEW_METAINFO_MOREHEX        32798
#define ID_VIEW_METAINFO_CSV            32799
#define ID_VIEW_METAINFO_UNRESOLVEDEXT  32800
#define ID_VIEW_METAINFO_DEBUG          32801
#define ID_VIEW_METAINFO_SCHEMA         32802
#define ID_VIEW_METAINFO_RAW            32803
#define ID_VIEW_METAINFO_HEAPS          32804
#define ID_VIEW_METAINFO_VALIDATE       32805
#define ID_VIEW_METAINFO_SHOW           32806

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        151
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\arraylist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef ARRAYLIST_H_
#define ARRAYLIST_H_

#include <member-offset-info.h>

//
// ArrayList is a simple class which is used to contain a growable
// list of pointers, stored in chunks.  Modification is by appending
// only currently.  Access is by index (efficient if the number of
// elements stays small) and iteration (efficient in all cases).
// 
// An important property of an ArrayList is that the list remains
// coherent while it is being modified. This means that readers
// never need to lock when accessing it.
//

#pragma warning(push)
#pragma warning(disable : 4200) // Disable zero-sized array warning

class ArrayList
{
    friend struct MEMBER_OFFSET_INFO(ArrayList);

 public:

    enum
    {
        ARRAY_BLOCK_SIZE_START = 15,
    };

  private:

    struct ArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[0];
    };

    struct FirstArrayListBlock
    {
        struct ArrayListBlock   *m_next;
        DWORD                   m_blockSize;
        void                    *m_array[ARRAY_BLOCK_SIZE_START];
    };

    DWORD               m_count;
    union
    {
          ArrayListBlock        m_block;
          FirstArrayListBlock   m_firstBlock;
    };

  public:

    ArrayList() : m_count(0) 
      { 
          m_block.m_next = NULL; 
          m_block.m_blockSize = ARRAY_BLOCK_SIZE_START; 
      }
    ~ArrayList() { Clear(); }

    void **GetPtr(DWORD index);
    void *Get(DWORD index) { return *GetPtr(index); }
    void Set(DWORD index, void *element) { *GetPtr(index) = element; }

    DWORD GetCount() { return m_count; }

    HRESULT Append(void *element);

    enum { NOT_FOUND = -1 };
    DWORD FindElement(DWORD start, void *element);

    void Clear();

    class Iterator 
    {
        friend ArrayList;

      public:
        BOOL Next();

        void *GetElement() { return m_block->m_array[m_index]; }
        DWORD GetIndex() { return m_index + m_total; }

      private:
        ArrayListBlock      *m_block;
        DWORD               m_index;
        DWORD               m_remaining;
        DWORD               m_total;
        static Iterator Create(ArrayListBlock *block, DWORD remaining)
          { 
              Iterator i; 
              i.m_block = block; 
              i.m_index = -1; 
              i.m_remaining = remaining; 
              i.m_total = 0;
              return i;
          }
    };

    Iterator Iterate() { return Iterator::Create(&m_block, m_count); }
};

#pragma warning(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ildasm\windasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/************************************************************************************************
 *                                                                                              *
 *  File:    winmain.cpp                                                                        *
 *  Creator: Serge Lidin                                                                        *
 *  Purpose: Main program for graphic COM+ 2.0 disassembler ILDASM.exe                          *
 *                                                                                              *
 ************************************************************************************************/


#define INITGUID

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <crtdbg.h>
#include <utilcode.h>
#include <malloc.h>
#include <string.h>

#include "DynamicArray.h"

#define DO_DASM_GUI
#include "dasmgui.h"
#include "dasmenum.hpp"
#include "dis.h"
#include "__file__.ver"
#include "corver.h"
#include <shellapi.h>
#include "resource.h"

#define MODE_DUMP_ALL               0
#define MODE_DUMP_CLASS             1
#define MODE_DUMP_CLASS_METHOD      2
#define MODE_DUMP_CLASS_METHOD_SIG  3
#define MODE_GUI                    4

// All externs are defined in DASM.CPP
extern BOOL                    g_fDumpIL;
extern BOOL                    g_fDumpHeader;
extern BOOL                    g_fDumpAsmCode;
extern BOOL                    g_fDumpTokens;
extern BOOL                    g_fDumpStats;
extern BOOL                    g_fDumpClassList;
extern BOOL                    g_fDumpSummary;
extern BOOL                    g_fDecompile; // still in progress

extern BOOL                    g_fDumpToPerfWriter;

extern BOOL                    g_fShowBytes;
extern BOOL                    g_fShowSource;
extern BOOL                    g_fInsertSourceLines;
extern BOOL                    g_fTryInCode;
extern BOOL                    g_fQuoteAllNames;
extern BOOL                    g_fShowProgressBar;
extern BOOL                    g_fTDC;
extern BOOL                    g_fShowCA;

extern BOOL                    g_AddContextfulAttrib;
extern DynamicArray<char*>     g_ContextfulClasses;
extern int                     g_cContextfulClasses;
extern BOOL                    g_AddMarshaledByRefAttrib;
extern DynamicArray<char*>     g_MarshaledByRefClasses;
extern int                     g_cMarshaledByRefClasses;

extern char                    g_pszClassToDump[];
extern char                    g_pszMethodToDump[];
extern char                    g_pszSigToDump[];

extern char                    g_szAsmCodeIndent[];

extern DWORD                   g_Mode;

extern char						g_szInputFile[]; // in UTF-8
extern char						g_szOutputFile[]; // in UTF-8
extern char*					g_pszObjFileName;
extern FILE*                    g_pFile;
extern BOOL                     g_fCheckOwnership;
extern char*                    g_pszOwner;

extern BOOL                 g_fLimitedVisibility;
extern BOOL                 g_fHidePub;
extern BOOL                 g_fHidePriv;
extern BOOL                 g_fHideFam;
extern BOOL                 g_fHideAsm;
extern BOOL                 g_fHideFAA;
extern BOOL                 g_fHideFOA;
extern BOOL                 g_fHidePrivScope;
extern unsigned				g_uCodePage;
extern BOOL					g_fOnUnicode;
extern BOOL                 g_fUseProperName;


#include "..\tools\metainfo\mdinfo.h"
extern BOOL                 g_fDumpMetaInfo;
extern ULONG                g_ulMetaInfoFilter;
HINSTANCE                   g_hAppInstance;
HANDLE						hConsoleOut=NULL;
HANDLE						hConsoleErr=NULL;
// These are implemented in DASM.CPP:
BOOL Init();
void Uninit();
void Cleanup();
void DumpMetaInfo(char* pszFileName, char* pszObjFileName, void* GUICookie);

// Do we only view an IL-dasm window in GUI mode?
// TRUE when we're in GUI mode and we specified a particular method from the cmd line
BOOL IsGuiILOnly()
{
    return (g_Mode & MODE_GUI) && (g_pszMethodToDump[0] != 0);
}
void PrintLogo()
{
    printf("Microsoft (R) .NET Framework IL Disassembler.  Version " VER_FILEVERSION_STR);
    printf("\n%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);
}
void SyntaxCon()
{
	DWORD l;

	for(l=IDS_USAGE_01; l<= IDS_USAGE_23; l++) printf(Rstr(l));
	if(g_fTDC)
	{
		for(l=IDS_USAGE_24; l<= IDS_USAGE_32; l++) printf(Rstr(l));
#ifdef _DEBUG
		for(l=IDS_USAGE_34; l<= IDS_USAGE_36; l++) printf(Rstr(l));
#endif
		for(l=IDS_USAGE_37; l<= IDS_USAGE_39; l++) printf(Rstr(l));
	}
	else printf(Rstr(IDS_USAGE_40));
	for(l=IDS_USAGE_41; l<= IDS_USAGE_42; l++) printf(Rstr(l));

}

char* CheckForDQuotes(char* sz)
{
	char* ret = sz;
	if(*sz == '"')
	{
		ret++;
		sz[strlen(sz)-1] = 0;
	}
	return ret;
}

char* EqualOrColon(char* szArg)
{
	char* pchE = strchr(szArg,'=');
	char* pchC = strchr(szArg,':');
	char* ret;
	if(pchE == NULL) ret = pchC;
	else if(pchC == NULL) ret = pchE;
	else ret = (pchE < pchC)? pchE : pchC;
	return ret;
}

int ProcessOneArg(char* szArg, char** ppszObjFileName)
{
    char		szOpt[128];
	if(strlen(szArg) == 0) return 0;
    if ((strcmp(szArg, "/?") == 0) || (strcmp(szArg, "-?") == 0)) return 1;

	if((szArg[0] == '/') || (szArg[0] == '-'))
    {
        strncpy(szOpt, &szArg[1],10);
        szOpt[3] = 0;
        if (_stricmp(szOpt, "dec") == 0)
        {
            g_fDecompile = TRUE;
        }
        else if (_stricmp(szOpt, "hea") == 0)
        {
            g_fDumpHeader = TRUE;
        }
        else if (_stricmp(szOpt, "adv") == 0)
        {
            g_fTDC = TRUE;
        }
        else if (_stricmp(szOpt, "tok") == 0)
        {
            g_fDumpTokens = TRUE;
        }
        else if (_stricmp(szOpt, "noi") == 0)
        {
            g_fDumpAsmCode = FALSE;
        }
        else if (_stricmp(szOpt, "noc") == 0)
        {
            g_fShowCA = FALSE;
        }
        else if (_stricmp(szOpt, "not") == 0)
        {
            g_fTryInCode = FALSE;
        }
        else if (_stricmp(szOpt, "raw") == 0)
        {
            g_fTryInCode = FALSE;
        }
        else if (_stricmp(szOpt, "byt") == 0)
        {
            g_fShowBytes = TRUE;
        }
        else if (_stricmp(szOpt, "sou") == 0)
        {
            g_fShowSource = TRUE;
        }
        else if (_stricmp(szOpt, "lin") == 0)
        {
            g_fInsertSourceLines = TRUE;
        }
        else if ((_stricmp(szOpt, "sta") == 0)&&g_fTDC)
        {
            g_fDumpStats = g_fTDC;
        }
        else if ((_stricmp(szOpt, "cla") == 0)&&g_fTDC)
        {
            g_fDumpClassList = g_fTDC;
        }
        else if (_stricmp(szOpt, "sum") == 0)
        {
            g_fDumpSummary = TRUE;
        }
        else if (_stricmp(szOpt, "per") == 0) 
        {
            g_fDumpToPerfWriter = TRUE;
        }
        else if (_stricmp(szOpt, "pub") == 0)
        {
            g_fLimitedVisibility = TRUE;
            g_fHidePub = FALSE;
        }
#ifdef _DEBUG
        else if (_stricmp(szOpt, "pre") == 0)
        {
            g_fPrettyPrint = TRUE;
        }
#endif
        else if (_stricmp(szOpt, "vis") == 0)
        {
            char *pc = EqualOrColon(szArg);
            char *pStr;
            if(pc == NULL) return -1;
            do {
                pStr = pc+1;
				pStr = CheckForDQuotes(pStr);
                if(pc = strchr(pStr,'+')) *pc=0;
                if     (!_stricmp(pStr,"pub")) g_fHidePub = FALSE;
                else if(!_stricmp(pStr,"pri")) g_fHidePriv = FALSE;
                else if(!_stricmp(pStr,"fam")) g_fHideFam = FALSE;
                else if(!_stricmp(pStr,"asm")) g_fHideAsm = FALSE;
                else if(!_stricmp(pStr,"faa")) g_fHideFAA = FALSE;
                else if(!_stricmp(pStr,"foa")) g_fHideFOA = FALSE;
                else if(!_stricmp(pStr,"psc")) g_fHidePrivScope = FALSE;
            } while(pc);
            g_fLimitedVisibility = g_fHidePub || g_fHidePriv || g_fHideFam || g_fHideFAA 
                                                || g_fHideFOA || g_fHidePrivScope;
        }
        else if (_stricmp(szOpt, "nob") == 0)
        {
            g_fShowProgressBar = FALSE;
        }
        else if (_stricmp(szOpt, "quo") == 0)
        {
            g_fQuoteAllNames = TRUE;
        }
        else if (_stricmp(szOpt, "utf") == 0)
        {
            g_uCodePage = CP_UTF8;
        }
        else if (_stricmp(szOpt, "uni") == 0)
        {
            g_uCodePage = 0xFFFFFFFF;
        }
#ifdef _DEBUG
        else if (_stricmp(szOpt, "@#$") == 0)
        {
            g_fCheckOwnership = FALSE;
        }
#endif
        else if (_stricmp(szOpt, "all") == 0)
        {
            g_fDumpStats = g_fTDC;
            g_fDumpHeader = TRUE;
            g_fShowBytes = TRUE;
            g_fDumpClassList = g_fTDC;
            g_fDumpTokens = TRUE;
        }
        else if (_stricmp(szOpt, "ite") == 0)
        {
            char *pStr = EqualOrColon(szArg);
            char *p, *q;
            if(pStr == NULL) return -1;
            pStr++;
			pStr = CheckForDQuotes(pStr);
            // treat it as meaning "dump only class X" or "class X method Y"
            p = strchr(pStr, ':');

            if (p == NULL)
            {
                // dump one class
                g_Mode = MODE_DUMP_CLASS;
                strcpy(g_pszClassToDump, pStr);
            }
            else
            {
                *p++ = '\0';
                if (*p != ':') return -1;

                strcpy(g_pszClassToDump, pStr);

                p++;

                q = strchr(p, '(');
                if (q == NULL)
                {
                    // dump class::method
                    g_Mode = MODE_DUMP_CLASS_METHOD;
                    strcpy(g_pszMethodToDump, p);
                }
                else
                {
                    // dump class::method(sig)
                    g_Mode = MODE_DUMP_CLASS_METHOD_SIG;
                    *q = '\0';
                    strcpy(g_pszMethodToDump, p);
                    // get rid of external parentheses:
					q++;
                    strcpy(g_pszSigToDump, q);
					g_pszSigToDump[strlen(g_pszSigToDump)-1]=0;
                }
            }
        }
        else if ((_stricmp(szOpt, "met") == 0)&&g_fTDC)
        {
            if(g_fTDC)
            {
                char *pStr = EqualOrColon(szArg);
                g_fDumpMetaInfo = TRUE;
                if(pStr)
                {
                    char szOptn[64];
                    strncpy(szOptn, pStr+1,10);
                    szOptn[3] = 0; // recognize metainfo specifier by first 3 chars
                    if	   (_stricmp(szOptn, "hex") == 0) g_ulMetaInfoFilter |= MDInfo::dumpMoreHex;
                    else if(_stricmp(szOptn, "csv") == 0) g_ulMetaInfoFilter |= MDInfo::dumpCSV;
                    else if(_stricmp(szOptn, "mdh") == 0) g_ulMetaInfoFilter |= MDInfo::dumpHeader;
#ifdef _DEBUG
                    else if(_stricmp(szOptn, "raw") == 0) g_ulMetaInfoFilter |= MDInfo::dumpRaw;
                    else if(_stricmp(szOptn, "hea") == 0) g_ulMetaInfoFilter |= MDInfo::dumpRawHeaps;
                    else if(_stricmp(szOptn, "sch") == 0) g_ulMetaInfoFilter |= MDInfo::dumpSchema;
#endif
                    else if(_stricmp(szOptn, "unr") == 0) g_ulMetaInfoFilter |= MDInfo::dumpUnsat;
                    else if(_stricmp(szOptn, "val") == 0) g_ulMetaInfoFilter |= MDInfo::dumpValidate;
                    else if(_stricmp(szOptn, "sta") == 0) g_ulMetaInfoFilter |= MDInfo::dumpStats;
                    else return -1;
                }
            }
        }
        else if (_stricmp(szOpt, "obj") == 0)
        {
            char *pStr = EqualOrColon(szArg);
            if(pStr == NULL) return -1;
            pStr++;
			pStr = CheckForDQuotes(pStr);
            *ppszObjFileName = new char[strlen(pStr)+1];
            strcpy(*ppszObjFileName,pStr);
        }
        else if (_stricmp(szOpt, "out") == 0)
        {
            char *pStr = EqualOrColon(szArg);
            if(pStr == NULL) return -1;
            pStr++;
			pStr = CheckForDQuotes(pStr);
            if(*pStr == 0) return -1;
            if(_stricmp(pStr,"con"))
            {
                strncpy(g_szOutputFile, pStr,511);
                g_szOutputFile[511] = 0;
            }
            else
                g_fShowProgressBar = FALSE;
            g_Mode &= ~MODE_GUI;
        }
#ifdef OWNER_OPTION_ENABLED
        else if (_stricmp(szOpt, "own") == 0)
        {
            char *pStr = EqualOrColon(szArg);
            if(pStr)
            {
                pStr++;
				pStr = CheckForDQuotes(pStr);
                if(*pStr) 
                {
                    unsigned L = strlen(pStr);
                    g_pszOwner = new char[L+1];
                    BYTE* pb = (BYTE*)g_pszOwner;;
                    *pb = (BYTE)(*pStr);
                    for(unsigned jj=1; jj<L; jj++) pb[jj] = (pb[jj-1]+(BYTE)pStr[jj])&0xFF;
                    pb[jj] = 0;
                    //strcpy(g_pszOwner,pStr);
                }
            }
        }
#endif
        else if (_stricmp(szOpt, "tex") == 0)
        {
            g_Mode &= ~MODE_GUI;
            g_fShowProgressBar = FALSE;
        }
        else
		{
			PrintLogo();
			printf("INVALID COMMAND LINE OPTION: %s\n\n",szArg);
			return -1;
		}
    }
    else
    {
        if(g_szInputFile[0])
		{
			PrintLogo();
			printf("MULTIPLE INPUT FILES SPECIFIED\n\n");
			return -1; // check if it was already specified
		}
		szArg = CheckForDQuotes(szArg);
        strncpy(g_szInputFile, szArg,511);
        g_szInputFile[511] = 0;
    }
    return 0;
}
int ParseCmdLineW(WCHAR* wzCmdLine, char** ppszObjFileName)
{
	int		argc,ret=0;
	LPWSTR* argv= CommandLineToArgvW(wzCmdLine,&argc);
	char*	szArg = new char[2048];
	for(int i=1; i < argc; i++)
	{
		memset(szArg,0,2048);
		WszWideCharToMultiByte(CP_UTF8,0,argv[i],-1,szArg,2048,NULL,NULL);
		if(ret = ProcessOneArg(szArg,ppszObjFileName)) break;
	}
	delete [] szArg;
	return ret;
}

int ParseCmdLineA(char* szCmdLine, char** ppszObjFileName)
{
    if((szCmdLine == NULL)||(*szCmdLine == 0)) return 0;

	// ANSI to Unicode
	int L = strlen(szCmdLine)+16;
	WCHAR* wzCmdLine = new WCHAR[L];
	memset(wzCmdLine,0,sizeof(WCHAR)*L);
	WszMultiByteToWideChar(CP_ACP,0,szCmdLine,-1,wzCmdLine,L);
	
	// Unicode to UTF-8
	char*       szCmdLineUTF = new char[L*3];
	memset(szCmdLineUTF,0,L*3);
	WszWideCharToMultiByte(CP_UTF8,0,wzCmdLine,-1,szCmdLineUTF,L*3,NULL,NULL);
	delete [] wzCmdLine;
    
    // Split into argv[]
	int argc=0, ret = 0;
    DynamicArray<char*> argv;
	char*       pch;
    char*       pchend;
    bool        bUnquoted = true;
    
    pch = szCmdLineUTF;
    pchend = pch+strlen(szCmdLineUTF);
    while(pch)
    {
        for(; *pch == ' '; pch++); // skip the blanks
        argv[argc++] = pch;
        for(; pch < pchend; pch++) 
        { 
            if(*pch == '"') bUnquoted = !bUnquoted;
            else if((*pch == ' ')&&bUnquoted) break;
        }

        if(pch < pchend) *pch++ = 0;
        else break;
    }

	for(int i=1; i < argc; i++)
	{
		if(ret = ProcessOneArg(argv[i],ppszObjFileName)) break;
	}
	delete [] szCmdLineUTF;
	return ret;
}
FILE* OpenOutput(char* szFileName)
{
	FILE*	pFile = NULL;
	int L = strlen(szFileName)+16;
	WCHAR* wzFileName = new WCHAR[L];
	memset(wzFileName,0,L*sizeof(WCHAR));
	WszMultiByteToWideChar(CP_UTF8,0,szFileName,-1,wzFileName,L);
	if(g_fOnUnicode)
	{
		if(g_uCodePage == 0xFFFFFFFF) pFile = _wfopen(wzFileName,L"wb");
        else pFile = _wfopen(wzFileName,L"wt");
	}
	else
	{
		char* szFileNameANSI = new char[L*2];
		memset(szFileNameANSI,0,L*2);
		WszWideCharToMultiByte(CP_ACP,0,wzFileName,-1,szFileNameANSI,L*2,NULL,NULL);

		if(g_uCodePage == 0xFFFFFFFF) pFile = fopen(szFileNameANSI,"wb");
        else pFile = fopen(szFileNameANSI,"wt");
		delete [] szFileNameANSI;
	}
	delete [] wzFileName;
	return pFile;
}
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	int		iCommandLineParsed;
	WCHAR*	wzCommandLine = NULL;
	char*	szCommandLine = NULL;
    g_fOnUnicode = OnUnicodeSystem();
    g_fUseProperName = TRUE;
    
    g_hAppInstance = hInstance;
    g_Mode = MODE_GUI;
    g_pszClassToDump[0]=0;
    g_pszMethodToDump[0]=0;
    g_pszSigToDump[0]=0;
    memset(g_szInputFile,0,512);
    memset(g_szOutputFile,0,512);
#ifdef _DEBUG
    g_fTDC = TRUE;
#endif

#undef GetCommandLineW
#undef CreateProcessW
    g_pszObjFileName = NULL;
	
    g_szAsmCodeIndent[0] = 0;
	hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);
	hConsoleErr = GetStdHandle(STD_ERROR_HANDLE);

	iCommandLineParsed = g_fOnUnicode ? ParseCmdLineW((wzCommandLine = GetCommandLineW()),&g_pszObjFileName)
									:	ParseCmdLineA((szCommandLine = GetCommandLineA()),&g_pszObjFileName);
	if(hConsoleOut != INVALID_HANDLE_VALUE) //First pass: console
	{
		if(iCommandLineParsed)
		{
			if(iCommandLineParsed > 0) PrintLogo();
			SyntaxCon();
			exit((iCommandLineParsed == 1) ? 0 : 1);
		}
		if(!(g_Mode & MODE_GUI))
		{
			DWORD	exitCode = 1;
			if(g_szInputFile[0] == 0) 
			{
				SyntaxCon();
				exit(1);
			}
			g_pFile = NULL;
			if(g_szOutputFile[0])
			{
				g_pFile = OpenOutput(g_szOutputFile);
				if(g_pFile == NULL)
				{
					char sz[1024];
					sprintf(sz,"Unable to open '%s' for output.",	g_szOutputFile);
					g_uCodePage = CP_ACP;
					printError(NULL,sz);
					exit(1);
				}
			}
			else // console output -- force the code page to ANSI
			{
				g_uCodePage = CP_ACP;
			}
			if (Init() == TRUE)
			{
				exitCode = DumpFile(g_szInputFile) ? 0 : 1;
				Cleanup();
			}
			Uninit();
			exit(exitCode);
		}
		else // if GUI ordered, restart as WinApp
		{
			PROCESS_INFORMATION pi; 
			STARTUPINFO			si; 
			memset(&pi, 0, sizeof(PROCESS_INFORMATION) );
			memset(&si, 0, sizeof(STARTUPINFO) );
			si.cb = sizeof(STARTUPINFO); 
			si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
			si.wShowWindow = SW_SHOW;
			si.hStdOutput = INVALID_HANDLE_VALUE;
			si.hStdInput  = INVALID_HANDLE_VALUE;
			si.hStdError  = INVALID_HANDLE_VALUE;
			if(g_fOnUnicode)
			{
				// Create the child process. 
				if(CreateProcessW(NULL, 
									wzCommandLine,						// command line 
									NULL,								// process security attributes 
									NULL,								// primary thread security attributes 
									TRUE,								// handles are inherited 
									DETACHED_PROCESS,					// creation flags 
									NULL,								// use parent's environment 
									NULL,								// use parent's current directory 
									(LPSTARTUPINFOW)&si,				// STARTUPINFO pointer 
									&pi)==0)							// receives PROCESS_INFORMATION 
				{
					printf("Failed to CreateProcess\n\n");
					exit(1);
				}
			}
			else
			{
				// Create the child process. 
				if(CreateProcessA(NULL, 
									szCommandLine,						// command line 
									NULL,								// process security attributes 
									NULL,								// primary thread security attributes 
									TRUE,								// handles are inherited 
									DETACHED_PROCESS,					// creation flags 
									NULL,								// use parent's environment 
									NULL,								// use parent's current directory 
									(LPSTARTUPINFOA)&si,				// STARTUPINFO pointer 
									&pi)==0)							// receives PROCESS_INFORMATION 
				{
					printf("Failed to CreateProcess\n\n");
					exit(1);
				}
			}// end if g_fOnUnicode
			exit(0); 
		}
	}
    else //Second pass: WinApp
    {
		//g_uCodePage = g_fOnUnicode ? 0xFFFFFFFF : CP_ACP;
		g_uCodePage = CP_UTF8;
		g_Mode = MODE_GUI;
		//g_fShowSource = FALSE; // Show Source - for file/console dump only

        if(g_szInputFile[0])
        {
            char* pch = strrchr(g_szInputFile,'.');
            if(pch && (!_strcmpi(pch+1,"lib") || !_strcmpi(pch+1,"obj")))
            {
                MessageBox(NULL,"ILDASM supports only PE files in graphic mode","Invalid File Type",MB_OK|MB_ICONERROR);
                return 0;
            }
        }
		if (Init() == TRUE)
		{
			CreateGUI();
			if(g_szInputFile[0])
			{
				GUISetModule(g_szInputFile);
				DumpFile(g_szInputFile);
			}
			GUIMainLoop();
			Cleanup();
		}
		Uninit();
		return 0 ;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\assemblyfilehash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef __ASSEMBLYHASH_H__
#define __ASSEMBLYHASH_H__

#include "wincrypt.h"

struct DigestBlock
{
    DigestBlock( PBYTE data, DWORD size, DigestBlock* next )
        : pData( new BYTE[size] ), cbData( size ), pNext( next )
    {
        memcpy( pData, data, size );    
    };

    ~DigestBlock( void )
    {
        delete [] pData;
		delete pNext;
    }

    PBYTE pData;
    DWORD cbData;
    DigestBlock* pNext;
};


struct DigestContext
{
    DigestContext( void ) : cbTotalData( 0 ), pHead( NULL ) {};

    DWORD cbTotalData;
    DigestBlock* pHead;
};

class AssemblyFileHash
{
    LPCWSTR m_FileName;  
    DigestContext m_Context;
    PBYTE m_pbHash;
    DWORD m_cbHash;

    HRESULT HashData(HCRYPTHASH);
    
public:
    HRESULT SetFileName(LPCWSTR fileName) // Owned by owners context. Will not be deleted
    { 
        m_FileName = fileName; 
        return S_OK;
    } 

    HRESULT GenerateDigest();
    DWORD   MemorySize() 
    {
        return m_Context.cbTotalData; 
    }

    PBYTE GetHash() { return m_pbHash; }
    DWORD GetHashSize() { return m_cbHash; }

    HRESULT CalculateHash(DWORD algid);

    HRESULT CopyData(PBYTE pData, DWORD cbData);
        
    AssemblyFileHash() :
        m_FileName(NULL),
        m_pbHash(NULL),
        m_cbHash(0)
    {}

    ~AssemblyFileHash()
    {
        if(m_Context.pHead)
            delete m_Context.pHead;
        if(m_pbHash)
            delete [] m_pbHash;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\blobfetcher.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CBlobFetcher - it fetches binary chunks, similar to new, but more controlled
//
// Fast, dynamic, memory management which doesn't relocate blocks
// m_pIndex has array of pillars, where each pillar starts off empty and has
// just-in-time allocation. As each pillar fills up, we move to the next pillar
// If the entire array of pillars fill up, we need to allocate a new array and 
// copy the pillars over. But the actual data returned from GetBlock() never
// gets moved. So everyone's happy.
//
//*****************************************************************************

#pragma once
#include <windows.h>


class  CBlobFetcher
{
protected:

    class CPillar {
    public:
        CPillar();
        ~CPillar();

        void SetAllocateSize(unsigned nSize);
        unsigned GetAllocateSize() const;

        char* MakeNewBlock(unsigned len, unsigned pad);
        void StealDataFrom(CPillar & src);
        unsigned GetDataLen() const;
        char* GetRawDataStart();
        BOOL Contains(char *ptr);
        ULONG32 GetOffset(char *ptr);

    protected:
        unsigned m_nTargetSize; // when we allocate, make it this large

    // Make these public so CBlobFetcher can do easy manipulation
    public:
        char* m_dataAlloc;
        char* m_dataStart;
        char* m_dataCur;
        char* m_dataEnd;
    };


    CPillar * m_pIndex; // array of pillars

    unsigned m_nIndexMax;   // actual size of m_ppIndex
    unsigned m_nIndexUsed;  // current pillar, so start at 0

    unsigned m_nDataLen;    // sum of all pillars' lengths

// Don't allow these because they'll mess up the ownership
    CBlobFetcher(const CBlobFetcher & src);
    operator=(const CBlobFetcher & src);

public:
    enum { maxAlign = 32 }; // maximum alignment we suport 
    CBlobFetcher();
    ~CBlobFetcher();

// get a block to write on (use instead of write to avoid copy)
    char * MakeNewBlock(unsigned int nSize, unsigned align=1);

// Index segment as if this were linear
    char * ComputePointer(unsigned offset) const;

// Determine if pointer came from this fetcher
    BOOL ContainsPointer(char *ptr) const;

// Find an offset as if this were linear
    unsigned ComputeOffset(char *ptr) const;

// Write out the section to the stream
    HRESULT Write(FILE* file);

// Write out the section to the stream
    HRESULT Verify(FILE* file);

// Write out the section to memory
    HRESULT WriteMem(void ** pMem);

// Get the total length of all our data (sum of all the pillar's data length's) 
// cached value, so light weight & no computations
    unsigned GetDataLen() const;

    HRESULT Truncate(unsigned newLen);

    HRESULT Merge(CBlobFetcher *destination);

};


//*****************************************************************************
// Inlines
//*****************************************************************************

// Set the size that the Pillar will allocate if we call getBlock()
inline void CBlobFetcher::CPillar::SetAllocateSize(unsigned nSize)
{
    m_nTargetSize = nSize;
}

// Get the size we will allocate so we can decide if we need to change it
// This is not the same as the GetDataLen() and is only useful
// before we do the allocation
inline unsigned CBlobFetcher::CPillar::GetAllocateSize() const
{
    return m_nTargetSize;
}

inline char* CBlobFetcher::CPillar::GetRawDataStart()
{
    return m_dataStart;
}

inline BOOL CBlobFetcher::CPillar::Contains(char *ptr)
{
    return ptr >= m_dataStart && ptr < m_dataCur;
}

inline ULONG32 CBlobFetcher::CPillar::GetOffset(char *ptr)
{
    _ASSERTE(Contains(ptr));
    
    return (ULONG32)(ptr - m_dataStart);
}

//-----------------------------------------------------------------------------
// Calculate the length of data being used, (not the length allocated)
//-----------------------------------------------------------------------------
inline unsigned CBlobFetcher::CPillar::GetDataLen() const
{
    _ASSERTE((m_dataCur >= m_dataStart) && (m_dataCur <= m_dataEnd));

    return (unsigned)(m_dataCur - m_dataStart);
}

inline unsigned CBlobFetcher::GetDataLen() const
{
    return m_nDataLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ceegen.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEEGEN.H
// 
// ===========================================================================
#ifndef _CEEGEN_H_
#define _CEEGEN_H_

#include "cor.h"
#include "iceefilegen.h"
#include "CeeGenTokenMapper.h"

class CeeSection;
class CeeSectionString;
class CCeeGen;
class PESectionMan;
class PESection;

typedef DWORD StringRef;

// ***** CeeSection classes

class CeeSectionImpl {
  public:
    virtual unsigned dataLen() = 0;     
    virtual char* getBlock(unsigned len, unsigned align=1) = 0;              
    virtual HRESULT truncate(unsigned len) = 0;              
    virtual HRESULT addSectReloc(
            unsigned offset, CeeSection& relativeTo, CeeSectionRelocType reloc = srRelocAbsolute, CeeSectionRelocExtra *extra = 0) = 0;
    virtual HRESULT addBaseReloc(unsigned offset, CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra = 0) = 0;
    virtual HRESULT directoryEntry(unsigned num) = 0;
    virtual unsigned char *name() = 0;
	virtual char* computePointer(unsigned offset) const = 0;
	virtual BOOL containsPointer(char *ptr) const = 0;
	virtual unsigned computeOffset(char *ptr) const = 0;
	virtual unsigned getBaseRVA() = 0;
};

class CeeSection {
	// m_ceeFile allows inter-section communication
    CCeeGen &m_ceeFile;

    // abstract away implementation to allow inheritance from CeeSection
    CeeSectionImpl &m_impl;

  public:
    enum RelocFlags {
        RELOC_NONE = 0,        

        // address should be fixed up to be a RVA not a normal address
        RELOC_RVA = 1 
    };

    CeeSection(CCeeGen &ceeFile, CeeSectionImpl &impl) 
        : m_ceeFile(ceeFile), m_impl(impl) {}

    virtual ~CeeSection() { }

    // bytes in this section at present
    unsigned dataLen();     

    // section base, after linking
    unsigned getBaseRVA();     

    // get a block to write on (use instead of write to avoid copy)
    char* getBlock(unsigned len, unsigned align=1);              

    // make the section the min of the curren len and 'newLen' 
    HRESULT truncate(unsigned len);              

    // Indicates that the DWORD at 'offset' in the current section should 
    // have the base of section 'relativeTo added to it
    HRESULT addSectReloc(unsigned offset, CeeSection& relativeTo, 
                         CeeSectionRelocType = srRelocAbsolute, CeeSectionRelocExtra *extra = 0);        
    // Add a base reloc for the given offset in the current section 
    virtual HRESULT addBaseReloc(unsigned offset, CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra = 0);
    

    // this section will be directory entry 'num'
    HRESULT directoryEntry(unsigned num);

    // return section name
    unsigned char *name();

	// simulate the base + offset with a more complex data storage
	char * computePointer(unsigned offset) const;
	BOOL containsPointer(char *ptr) const;
	unsigned computeOffset(char *ptr) const;

    CeeSectionImpl &getImpl();
    CCeeGen &ceeFile();
};

// ***** CCeeGen class
// Only handles in memory stuff
// Base class for CeeFileGenWriter (which actually generates PEFiles)

class CCeeGen : public ICeeGen {
	long m_cRefs;
    BOOL m_encMode;
  protected:
    short m_textIdx;
    short m_metaIdx;
	short m_corHdrIdx;
    short m_stringIdx;
    short m_ilIdx;
    bool m_objSwitch;

	CeeGenTokenMapper *m_pTokenMap;
	BOOLEAN m_fTokenMapSupported;	// temporary to support both models
    IMapToken *m_pRemapHandler;

    CeeSection **m_sections;
    short m_numSections;
    short m_allocSections;

    PESectionMan * m_peSectionMan;

    IMAGE_COR20_HEADER *m_corHeader;
	DWORD m_corHeaderOffset;

    HRESULT allocateCorHeader();

    HRESULT addSection(CeeSection *section, short *sectionIdx);

    HRESULT setEnCMode();

// Init process: Call static CreateNewInstance() , not operator new
  protected:
    HRESULT Init();
    CCeeGen();

  public:
    static HRESULT CreateNewInstance(CCeeGen* & pCeeFileGen); // call this to instantiate
    
    virtual HRESULT Cleanup();

	// ICeeGen interfaces

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(
		REFIID riid, 
		void **ppInterface);

   	STDMETHODIMP EmitString ( 		 
		LPWSTR lpString,					// [IN] String to emit
		ULONG *RVA);
	
   	STDMETHODIMP GetString ( 		 
		ULONG RVA,							
		LPWSTR *lpString);
	
	STDMETHODIMP AllocateMethodBuffer ( 		 
		ULONG cchBuffer,					// [IN] Length of string to emit
		UCHAR **lpBuffer,					// [OUT] Returned buffer
		ULONG *RVA);

	STDMETHODIMP GetMethodBuffer ( 		 
		ULONG RVA,							
		UCHAR **lpBuffer);

	STDMETHODIMP GetIMapTokenIface (  
		IUnknown **pIMapToken);

    STDMETHODIMP GenerateCeeFile ();

    STDMETHODIMP GetIlSection ( 
		HCEESECTION *section);

    STDMETHODIMP GetStringSection ( 
		HCEESECTION *section);

    STDMETHODIMP AddSectionReloc ( 
		HCEESECTION section, 
		ULONG offset, 
		HCEESECTION relativeTo, 
		CeeSectionRelocType relocType);

    STDMETHODIMP GetSectionCreate ( 
		const char *name, 
		DWORD flags, 
		HCEESECTION *section);

    STDMETHODIMP GetSectionDataLen ( 
		HCEESECTION section, 
		ULONG *dataLen);

    STDMETHODIMP GetSectionBlock ( 
		HCEESECTION section, 
		ULONG len, 
		ULONG align=1, 
		void **ppBytes=0);

    STDMETHODIMP TruncateSection ( 
		HCEESECTION section, 
		ULONG len);

    STDMETHODIMP GenerateCeeMemoryImage (void **ppImage);

    STDMETHODIMP ComputePointer (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer);                  // [OUT] Returned buffer    


    STDMETHODIMP AddNotificationHandler(IUnknown *pHandler);

	virtual HRESULT CCeeGen::emitMetaData(IMetaDataEmit *emitter, CeeSection* section=0, DWORD offset=0, BYTE* buffer=0, unsigned buffLen=0);
    virtual HRESULT getMethodRVA(ULONG codeOffset, ULONG *codeRVA);

    CeeSection &getTextSection();
    CeeSection &getMetaSection();
    CeeSection &getCorHeaderSection();
    CeeSectionString &getStringSection();
    CeeSection &getIlSection();
    
    virtual HRESULT getSectionCreate (const char *name, DWORD flags, CeeSection **section=NULL, short *sectionIdx = NULL);
 
	virtual void applyRelocs();

	PESectionMan* getPESectionMan() {
		return m_peSectionMan;
	}

	virtual HRESULT getMapTokenIface(IUnknown **pIMapToken, IMetaDataEmit *emitter=0);

	CeeGenTokenMapper *getTokenMapper() {
		return m_pTokenMap;
	}

    virtual HRESULT addNotificationHandler(IUnknown *pHandler);

    //Clone is actually a misnomer here.  This method will copy all of the 
    //instance variables and then do a deep copy (as necessary) of the sections.
    //Section data will be appended onto any information already in the section.
    //This is done to support the DynamicIL -> PersistedIL transform.
    virtual HRESULT cloneInstance(CCeeGen *destination);
};

// ***** CeeSection inline methods

inline unsigned CeeSection::dataLen() {
    return m_impl.dataLen(); }

inline unsigned CeeSection::getBaseRVA() {
    return m_impl.getBaseRVA(); }

inline char *CeeSection::getBlock(unsigned len, unsigned align) {
    return m_impl.getBlock(len, align); }

inline HRESULT CeeSection::truncate(unsigned len) {
    return m_impl.truncate(len); }

inline HRESULT CeeSection::addSectReloc(
                unsigned offset, CeeSection& relativeTo, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra) {
    return(m_impl.addSectReloc(offset, relativeTo, reloc, extra));
}

inline HRESULT CeeSection::addBaseReloc(unsigned offset, CeeSectionRelocType reloc, CeeSectionRelocExtra *extra) {
    return(m_impl.addBaseReloc(offset, reloc, extra));
}


inline HRESULT CeeSection::directoryEntry(unsigned num) { 
    TESTANDRETURN(num < IMAGE_NUMBEROF_DIRECTORY_ENTRIES, E_INVALIDARG); 
    m_impl.directoryEntry(num);
    return S_OK;
}

inline CCeeGen &CeeSection::ceeFile() {
    return m_ceeFile; }

inline CeeSectionImpl &CeeSection::getImpl() {
    return m_impl; }

inline unsigned char *CeeSection::name() { 
    return m_impl.name();
}

inline char * CeeSection::computePointer(unsigned offset) const
{
	return m_impl.computePointer(offset);
}

inline BOOL CeeSection::containsPointer(char *ptr) const
{
	return m_impl.containsPointer(ptr);
}

inline unsigned CeeSection::computeOffset(char *ptr) const
{
	return m_impl.computeOffset(ptr);
}

// ***** CCeeGen inline methods

inline CeeSection &CCeeGen::getTextSection() {
    return *m_sections[m_textIdx]; }

inline CeeSection &CCeeGen::getMetaSection() {
    return *m_sections[m_metaIdx]; }

inline CeeSection &CCeeGen::getCorHeaderSection() {
	_ASSERTE(m_corHdrIdx >= 0);
    return *m_sections[m_corHdrIdx]; }

inline CeeSectionString &CCeeGen::getStringSection() {
    return *(CeeSectionString*)m_sections[m_stringIdx]; }

inline CeeSection &CCeeGen::getIlSection() {
    return *m_sections[m_ilIdx]; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ceegentokenmapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CeeGenTokenMapper.h
//
// This helper class tracks mapped tokens from their old value to the new value
// which can happen when the data is optimized on save.
//
//*****************************************************************************
#ifndef __CeeGenTokenMapper_h__
#define __CeeGenTokenMapper_h__

#include "utilcode.h"

typedef CDynArray<mdToken> TOKENMAP;

#define INDEX_OF_TYPE(type) ((type) >> 24)
#define INDEX_FROM_TYPE(type) case INDEX_OF_TYPE(mdt ## type): return (tkix ## type)

class CCeeGen;

class CeeGenTokenMapper : public IMapToken
{
friend class CCeeGen;
friend class PESectionMan;
public:
    enum
    {
        tkixTypeDef,
        tkixInterfaceImpl,
        tkixMethodDef,
        tkixTypeRef,
        tkixMemberRef,
        tkixMethodImpl,
        tkixCustomAttribute,
        tkixFieldDef,
        tkixParamDef,
        tkixFile,
        MAX_TOKENMAP
    };

    static int IndexForType(mdToken tk);
    
    CeeGenTokenMapper() : m_pIImport(0), m_cRefs(1), m_pIMapToken(NULL)  {}

//*****************************************************************************
// IUnknown implementation.  
//*****************************************************************************
    virtual ULONG __stdcall AddRef()
    { return ++m_cRefs; }

    virtual ULONG __stdcall Release()
    {   
        ULONG cRefs = --m_cRefs;
        if (m_cRefs == 0)
        {
            if (m_pIMapToken)
            {
                m_pIMapToken->Release();
                m_pIMapToken = NULL;
            }
            
            delete this;
        }
        return cRefs;
    }

    virtual HRESULT __stdcall QueryInterface(REFIID iid, PVOID *ppIUnk);

//*****************************************************************************
// Called by the meta data engine when a token is remapped to a new location.
// This value is recorded in the m_rgMap array based on type and rid of the
// from token value.
//*****************************************************************************
    virtual HRESULT __stdcall Map(mdToken tkImp, mdToken tkEmit);

//*****************************************************************************
// Check the given token to see if it has moved to a new location.  If so,
// return true and give back the new token.
//*****************************************************************************
    virtual int HasTokenMoved(mdToken tkFrom, mdToken &tkTo);

    int GetMaxMapSize() const
    { return (MAX_TOKENMAP); }

    IUnknown *GetMapTokenIface() const
    { return ((IUnknown *) this); }

    
//*****************************************************************************
// Hand out a copy of the meta data information.
//*****************************************************************************
    virtual HRESULT GetMetaData(IMetaDataImport **ppIImport);

//*****************************************************************************
// Add another token mapper.
//*****************************************************************************
    virtual HRESULT AddTokenMapper(IMapToken *pIMapToken)
    {
        // Add the token mapper, if there isn't already one.
        if (m_pIMapToken == NULL)
        {
            m_pIMapToken = pIMapToken;
            m_pIMapToken->AddRef();
            return S_OK;
        }
        else
        {
            _ASSERTE(!"Token mapper already set!");
            return E_FAIL;
        }
    }

protected:
// m_rgMap is an array indexed by token type.  For each type, an array of
// tokens is kept, indexed by from rid.  To see if a token has been moved,
// do a lookup by type to get the right array, then use the from rid to
// find the to rid.
    TOKENMAP    m_rgMap[MAX_TOKENMAP];
    IMetaDataImport *m_pIImport;
    ULONG       m_cRefs;                // Ref count.
    IMapToken  *m_pIMapToken;
    
};

#endif // __CeeGenTokenMapper_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\classfac.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_CLASSFAC_
#define _H_CLASSFAC_

// ===========================================================================
// Copied from COR.
// 
class CClassFactory : public IClassFactory
    {
    ULONG    m_cbRefCount;
    LPVOID   m_pvReserved;
  public:

      CClassFactory() 
      {
          m_pvReserved = NULL;
          m_cbRefCount = 1;
      }

      CClassFactory(LPVOID pv) 
      {
          m_pvReserved = pv;
          m_cbRefCount = 1;
      }

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)   
    {
        ULONG cbRef = (ULONG)InterlockedIncrement((LONG*)&m_cbRefCount);
        return cbRef; 
    }
    STDMETHODIMP_(ULONG) Release(void)  
    {
        ULONG cbRef = (ULONG)InterlockedDecrement((LONG*)&m_cbRefCount);
        if ( cbRef == 0)
            delete this;
        return cbRef;
    }

    // *** IClassFactory methods ***
    STDMETHODIMP    CreateInstance(LPUNKNOWN punkOuter, REFIID iid, LPVOID FAR *ppv);
    STDMETHODIMP    LockServer(BOOL fLock);
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ceefilegenwriter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CeeFileGenWriter.h
// 
// ===========================================================================
#ifndef _CEEFILEGENWRITER_H_
#define _CEEFILEGENWRITER_H_
//

// CeeFileGenWriter contains all the code necessary to actually write an exe
// while CCeeGen contains everything else. This lets CeeGen.exe and the VM
// share more code without forcing the VM to carry the extra code to write an
// exe.
#include <windows.h>
#include "CeeGen.h"
#include "ICeeFileGen.h"

class PEWriter;
class CeeFileGenWriter;

// default setting for PE file
const int CEE_IMAGE_BASE = 0x00400000;
const int CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION = 4;
const int CEE_IMAGE_SUBSYSTEM_MINOR_VERSION = 0;

class CeeFileGenWriter : public CCeeGen
{
    mdToken m_entryPoint;       // token for entry point
    DWORD m_comImageFlags;    

    LPWSTR m_outputFileName;
    LPWSTR m_resourceFileName;
    LPWSTR m_libraryName;
    GUID   m_libraryGuid;
    bool m_dllSwitch;

    ULONG m_iatOffset;
    DWORD m_dwMacroDefinitionRVA;
    DWORD m_dwMacroDefinitionSize;

    DWORD m_dwManifestRVA;
    DWORD m_dwManifestSize;

    DWORD m_dwStrongNameRVA;
    DWORD m_dwStrongNameSize;

    DWORD m_dwVTableRVA;
    DWORD m_dwVTableSize;

	bool m_linked;
	bool m_fixed;
	
    HRESULT checkForErrors();

    struct IDataDllInfo {
        char *m_name;
        int m_numMethods;
        char **m_methodName;
        int m_iltOffset;
        int m_ibnOffset;
        int m_iatOffset;
        int m_nameOffset;
    } *m_iDataDlls;
    int m_dllCount;
 
    CeeSection *m_iDataSectionIAT;
    int m_iDataOffsetIAT;
    char *m_iDataIAT;

    HRESULT allocateIAT();
public: 
// Create with this method, not operator new
    static HRESULT CreateNewInstance(CCeeGen *pCeeFileGenFrom, CeeFileGenWriter* & pGenWriter);

    virtual HRESULT Cleanup();

    PEWriter &getPEWriter();

    HRESULT link();
    HRESULT fixup();
    HRESULT generateImage(void **ppImage);
    
    HRESULT setImageBase(size_t imageBase);
    HRESULT setFileAlignment(ULONG fileAlignment);
    HRESULT setSubsystem(DWORD subsystem, DWORD major, DWORD minor);

    HRESULT getMethodRVA(ULONG codeOffset, ULONG *codeRVA); 

    HRESULT setEntryPoint(mdMethodDef method);
    mdMethodDef getEntryPoint();

    HRESULT setComImageFlags(DWORD mask);
    HRESULT clearComImageFlags(DWORD mask);
    DWORD getComImageFlags();

    HRESULT setOutputFileName(LPWSTR outputFileName);
    LPWSTR getOutputFileName();

    HRESULT setResourceFileName(LPWSTR resourceFileName);
    LPWSTR getResourceFileName();

    HRESULT setLibraryName(LPWSTR libraryName);
    LPWSTR getLibraryName();

    HRESULT setDirectoryEntry(CeeSection &section, ULONG entry, ULONG size, ULONG offset=0);
	HRESULT computeSectionOffset(CeeSection &section, char *ptr,
											   unsigned *offset);
	HRESULT computeOffset(char *ptr, CeeSection **pSection, 
						  unsigned *offset);
	HRESULT getCorHeader(IMAGE_COR20_HEADER **ppHeader);

    HRESULT getFileTimeStamp(time_t *pTimeStamp);

//@FUTURE: this entry point is only here so that down level clients of this interface
// can import the method by name in the exports table using the original name.
// These things really ought to be exported through a v-table so there is no
// name mangling issues.  It would make the export table much smaller as well.
    HRESULT emitLibraryName(IMetaDataEmit *emitter);
    HRESULT setLibraryGuid(LPWSTR libraryGuid);

    HRESULT setDllSwitch(bool dllSwitch);
    bool getDllSwitch();
    HRESULT setObjSwitch(bool objSwitch);
    bool getObjSwitch();
    HRESULT EmitMacroDefinitions(void *pData, DWORD cData);
    HRESULT setManifestEntry(ULONG size, ULONG offset);
    HRESULT setStrongNameEntry(ULONG size, ULONG offset);
    HRESULT setEnCRvaBase(ULONG dataBase, ULONG rdataBase);
    HRESULT setVTableEntry(ULONG size, ULONG offset);

protected:
    CeeFileGenWriter(); // ctor is protected

    HRESULT emitResourceSection();
    HRESULT emitExeMain();

    HRESULT setAddrReloc(UCHAR *instrAddr, DWORD value);
    HRESULT addAddrReloc(CeeSection &thisSection, UCHAR *instrAddr, DWORD offset, CeeSection *targetSection);

    HRESULT MapTokens(CeeGenTokenMapper *pMapper, IMetaDataImport *pImport);
    HRESULT MapTokensForMethod(CeeGenTokenMapper *pMapper,BYTE *pCode, LPCWSTR szMethodName);
};


inline PEWriter &CeeFileGenWriter::getPEWriter()
{
    return (PEWriter &) *m_peSectionMan;
}

inline LPWSTR CeeFileGenWriter::getOutputFileName() {
    return m_outputFileName; 
}

inline LPWSTR CeeFileGenWriter::getResourceFileName() {
    return m_resourceFileName; 
}

inline HRESULT CeeFileGenWriter::setDllSwitch(bool dllSwitch) {
    if(m_dllSwitch = dllSwitch) m_objSwitch = FALSE; return S_OK; 
}

inline bool CeeFileGenWriter::getDllSwitch() {
    return m_dllSwitch; 
}

inline HRESULT CeeFileGenWriter::setObjSwitch(bool objSwitch) {
    if(m_objSwitch = objSwitch) m_dllSwitch = FALSE; return S_OK; 
}

inline bool CeeFileGenWriter::getObjSwitch() {
    return m_objSwitch; 
}

inline LPWSTR CeeFileGenWriter::getLibraryName() {
    return m_libraryName; 
}

inline mdMethodDef CeeFileGenWriter::getEntryPoint() { 
    return m_entryPoint; 
}

inline HRESULT CeeFileGenWriter::setEntryPoint(mdMethodDef method) { 
    m_entryPoint = method; 
    return S_OK; 
}

inline HRESULT CeeFileGenWriter::setComImageFlags(DWORD mask) { 
    m_comImageFlags |= mask; return S_OK; 
}

inline HRESULT CeeFileGenWriter::clearComImageFlags(DWORD mask) { 
    m_comImageFlags &= ~mask; return S_OK; 
}

inline DWORD CeeFileGenWriter::getComImageFlags() {
    return m_comImageFlags; 
}


//
// AlexisCa: 
//	8K section alignment is required for portability across
//		all supported platforms.
//	One can still select 4k alignment if needed by defining
//		_IMAGE_FILE_4K_SECTION_ALIGNMENT_
//
#if defined(_IMAGE_FILE_4K_SECTION_ALIGNMENT_) 
#define IMAGE_NT_OPTIONAL_HDR_SECTION_ALIGNMENT 0x1000
#else
#define IMAGE_NT_OPTIONAL_HDR_SECTION_ALIGNMENT 0x2000
#endif

// The stub is always x86 so we always mark the image as x86
#define IMAGE_FILE_MACHINE IMAGE_FILE_MACHINE_I386


#endif	// _CEEFILEGENWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cahlpr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CAHLPR.H
//
// This file contains a set of "as is" code that may be used by developers
// writing compilers and tools against the Common Language Runtime.  The code 
// is not officially supported, but is code being used by the Runtime itself.
//
//*****************************************************************************
#ifndef __CAHLPR_H__
#define __CAHLPR_H__

//*****************************************************************************
// This class assists in the parsing of CustomAttribute blobs.
//*****************************************************************************
#pragma warning(push)
#pragma warning(disable : 4700)

struct CaValue
{
    union
    {
        signed __int8       i1;   
        unsigned __int8     u1;
        signed __int16      i2;
        unsigned __int16    u2;
        signed __int32      i4;
        unsigned __int32    u4;
        signed __int64      i8;
        unsigned __int64    u8;
        float               r4;
        double              r8;
        struct
        {
            LPCUTF8         pStr;
            ULONG           cbStr;
        };
    };
    unsigned __int8         tag;
};


class CustomAttributeParser {
public:
	CustomAttributeParser(				// Constructor for CustomAttributeParser.
		const void *pvBlob, 			// Pointer to the CustomAttribute blob.
		ULONG 	cbBlob) 				// Size of the CustomAttribute blob.
	 :  m_pbBlob(reinterpret_cast<const BYTE*>(pvBlob)),
		m_pbCur(reinterpret_cast<const BYTE*>(pvBlob)),
		m_cbBlob(cbBlob)
	{ }
	

	signed __int8 	 GetI1() {signed __int8    tmp=0; return GetValue(tmp); }
	unsigned __int8  GetU1() {unsigned __int8  tmp=0; return GetValue(tmp); }
		 
	signed __int16 	 GetI2() {signed __int16   tmp=0; return GetValue(tmp); }
	unsigned __int16 GetU2() {unsigned __int16 tmp=0; return GetValue(tmp); }
		 
	signed __int32 	 GetI4() {signed __int32   tmp=0; return GetValue(tmp); }
	unsigned __int32 GetU4() {unsigned __int32 tmp=0; return GetValue(tmp); }
		 
	signed __int64 	 GetI8() {signed __int64   tmp=0; return GetValue(tmp); }
	unsigned __int64 GetU8() {unsigned __int64 tmp=0; return GetValue(tmp); }
		 
	float        	 GetR4() {float            tmp=0; return GetValue(tmp); }
	double 			 GetR8() {double           tmp=0; return GetValue(tmp); }
		 
	
	HRESULT GetI1(signed __int8 *pVal)      {return GetValue2(pVal);}
	HRESULT GetU1(unsigned __int8 *pVal)    {return GetValue2(pVal);}
		 
	HRESULT GetI2(signed __int16 *pVal)     {return GetValue2(pVal);}
	HRESULT GetU2(unsigned __int16 *pVal)   {return GetValue2(pVal);}
		 
	HRESULT GetI4(signed __int32 *pVal)     {return GetValue2(pVal);}
	HRESULT GetU4(unsigned __int32 *pVal)   {return GetValue2(pVal);}
		 
	HRESULT GetI8(signed __int64 *pVal)     {return GetValue2(pVal);}
	HRESULT GetU8(unsigned __int64 *pVal)   {return GetValue2(pVal);}
		 
	HRESULT GetR4(float *pVal)              {return GetValue2(pVal);}
	HRESULT GetR8(double *pVal)             {return GetValue2(pVal);}
		 
	
	short GetProlog() {m_pbCur = m_pbBlob; return GetI2(); }

	int GetTagType ( )	{return GetU1();}
    
	ULONG PeekStringLength() {ULONG cb; UnpackValue(m_pbCur, &cb); return cb;}
	LPCUTF8 GetString(ULONG *pcbString) 
	{
		// Get the length, pointer to data following the length.
		const BYTE *pb = UnpackValue(m_pbCur, pcbString); 
		m_pbCur = pb;
		// If null pointer is coded, no data follows length.
		if (*pcbString == -1)
			return (0);
		// Adjust current pointer for string data.
		m_pbCur += *pcbString;
		// Return pointer to string data.
		return (reinterpret_cast<LPCUTF8>(pb));
	}

	ULONG GetArraySize () 
	{
		ULONG cb;
		m_pbCur = UnpackValue(m_pbCur, &cb);
		return cb;
	}

    int BytesLeft() {return (int)(m_cbBlob - (m_pbCur - m_pbBlob));}
    
private:
	const BYTE 	*m_pbCur;
	const BYTE	*m_pbBlob;
	ULONG		m_cbBlob;

	template<class type>
		type GetValue(type tmp) 
	{	// Cheating just a bit -- using the parameter to declare a temporary.
		//  works as the template specialization, though.
		tmp = *reinterpret_cast<const type*>(m_pbCur); 
		m_pbCur += sizeof(type); 
		return tmp; 
	}

	template<class type>
		HRESULT GetValue2(type *pval) 
	{	// Check bytes remaining.
        if (BytesLeft() < sizeof(type)) 
            return META_E_CA_INVALID_BLOB;
        // Get the value.
		*pval = *reinterpret_cast<const type*>(m_pbCur); 
		m_pbCur += sizeof(type); 
		return S_OK; 
	}

	const BYTE *UnpackValue(				// Uppack a coded integer.
		const BYTE	*pBytes, 				// First byte of length.
		ULONG 		*pcb)					// Put the value here.
	{
        int iLeft = BytesLeft();
        if (iLeft < 1)
        {
            *pcb = -1;
            return 0;
        }
		if ((*pBytes & 0x80) == 0x00)		// 0??? ????
		{
			*pcb = (*pBytes & 0x7f);
			return pBytes + 1;
		}
	
		if ((*pBytes & 0xC0) == 0x80)		// 10?? ????
		{
            if (iLeft < 2)
            {
                *pcb = -1;
                return 0;
            }
			*pcb = ((*pBytes & 0x3f) << 8 | *(pBytes+1));
			return pBytes + 2;
		}
	
		if ((*pBytes & 0xE0) == 0xC0)		// 110? ????
		{
            if (iLeft < 4)
            {
                *pcb = -1;
                return 0;
            }
			*pcb = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));
			return pBytes + 4;
		}
	
		if (*pBytes == 0xff)				// Special value for "NULL pointer"
		{
			*pcb = (-1);
			return pBytes + 1;
		}

		_ASSERTE(!"Unexpected packed value");
		*pcb = -1;
		return pBytes + 1;
	} // ULONG UnpackValue()
};
#pragma warning(pop)

#endif // __CAHLPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ceesectionstring.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CeeSectionString.h
// 
// ===========================================================================
#ifndef CeeSectionString_H
#define CeeSectionString_H

#include <ole2.h>
#include "CeeGen.h"

// This class is responsible for managing all the strings that have
// been emitted for the PE file.

// This class manages the strings that are added to the .rdata section.
// It keeps track of each string that has been added using a hashtable.
// The hash table is effectively 2-dimensional. There is a large "virtual
// hash space" that is used to get a wide hash code distribution. The
// virtual hash space is mapped into a real hash table where each n
// hash values in the virtual space fall into a given hash bucket for
// real hash table size n. Within the bucket, elements are stored in a linked
// list in-order. When an virtual hash entry corresponds to a given bucket,
// that bucket is searched for the matching hash id. If not found, it is
// inserted, otherwise, the value is returned. The idea is that for smaller
// apps, there won't be a large number of strings, so that collisions are
// minimal and the length of each bucket's chain is small. For larger
// numbers of strings, having a large hash space also reduces numbers
// of collisions, avoiding string compares unless the hash codes match.

struct StringTableEntry;

class CeeSectionString : public CeeSection {
	enum { MaxRealEntries = 100, MaxVirtualEntries = 10000 };
	StringTableEntry *stringTable[MaxRealEntries];

	StringTableEntry *createEntry(LPWSTR target, ULONG hashId);
	StringTableEntry *findStringInsert(
				StringTableEntry *&entry, LPWSTR targetValue, ULONG hashId);
	void deleteEntries(StringTableEntry *e);
#ifdef RDATA_STATS
	int dumpEntries(StringTableEntry *e);
	void dumpTable();
#endif

  public:
	~CeeSectionString();
	CeeSectionString(CCeeGen &ceeFile, CeeSectionImpl &impl);
	virtual HRESULT getEmittedStringRef(LPWSTR targetValue, StringRef *ref);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\clear-class-dump-defs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifdef BEGIN_CLASS_DUMP_INFO
#undef BEGIN_CLASS_DUMP_INFO
#endif

#ifdef BEGIN_CLASS_DUMP_INFO_DERIVED
#undef BEGIN_CLASS_DUMP_INFO_DERIVED
#endif

#ifdef BEGIN_ABSTRACT_CLASS_DUMP_INFO
#undef BEGIN_ABSTRACT_CLASS_DUMP_INFO
#endif

#ifdef BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#undef BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#endif

#ifdef CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS
#undef CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS
#endif

#ifdef CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL
#undef CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL
#endif

#ifdef CDI_CLASS_INJECT
#undef CDI_CLASS_INJECT
#endif

#ifdef CDI_CLASS_MEMBER_OFFSET
#undef CDI_CLASS_MEMBER_OFFSET
#endif

#ifdef CDI_CLASS_MEMBER_OFFSET_BITFIELD
#undef CDI_CLASS_MEMBER_OFFSET_BITFIELD
#endif

#ifdef CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY
#undef CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY
#endif

#ifdef CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY
#undef CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY
#endif

#ifdef CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY
#undef CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY
#endif

#ifdef CDI_CLASS_STATIC_ADDRESS
#undef CDI_CLASS_STATIC_ADDRESS
#endif

#ifdef CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY
#undef CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY
#endif

#ifdef CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY
#undef CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY
#endif

#ifdef CDI_GLOBAL_ADDRESS
#undef CDI_GLOBAL_ADDRESS
#endif

#ifdef CDI_GLOBAL_ADDRESS_DEBUG_ONLY
#undef CDI_GLOBAL_ADDRESS_DEBUG_ONLY
#endif

#ifdef END_CLASS_DUMP_INFO
#undef END_CLASS_DUMP_INFO
#endif

#ifdef END_CLASS_DUMP_INFO_DERIVED
#undef END_CLASS_DUMP_INFO_DERIVED
#endif

#ifdef END_ABSTRACT_CLASS_DUMP_INFO
#undef END_ABSTRACT_CLASS_DUMP_INFO
#endif

#ifdef END_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#undef END_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#endif

#ifdef BEGIN_CLASS_DUMP_TABLE
#undef BEGIN_CLASS_DUMP_TABLE
#endif

#ifdef CDT_CLASS_ENTRY
#undef CDT_CLASS_ENTRY
#endif

#ifdef END_CLASS_DUMP_TABLE
#undef END_CLASS_DUMP_TABLE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\codeproc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:13 2003
 */
/* Compiler settings for codeproc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICodeProcess,0x3196269D,0x7B67,0x11d2,0x87,0x11,0x00,0xC0,0x4F,0x79,0xED,0x0D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\clrnt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NTPSAPI_

#ifndef _NTDEF_
#include <subauth.h>
#endif

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;


//
// Gdi command batching
//

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG Offset;
    ULONG HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;


//
// Wx86 thread state information
//

typedef struct _Wx86ThreadState {
    PULONG  CallBx86Eip;
    PVOID   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD, *PWX86THREAD;

//
//  TEB - The thread environment block
//

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62
#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID  EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    LPVOID ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    PVOID WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
#ifdef _IA64_
    ULONGLONG Gdt[GDT_ENTRIES];         // Provide Gdt table entries
    ULONGLONG GdtDescriptor;
    ULONGLONG LdtDescriptor;
    ULONGLONG FsDescriptor;
#else  // _IA64_
    PVOID SystemReserved1[54];      // Used by FP emulator
#endif // _IA64_
    NTSTATUS ExceptionCode;         // for RaiseUserException
    UCHAR SpareBytes1[44];
    GDI_TEB_BATCH GdiTebBatch;      // Gdi batching
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH];    // User32 Client Info
    PVOID glDispatchTable[233];     // OpenGL
    ULONG glReserved1[29];          // OpenGL
    PVOID glReserved2;              // OpenGL
    PVOID glSectionInfo;            // OpenGL
    PVOID glSection;                // OpenGL
    PVOID glTable;                  // OpenGL
    PVOID glCurrentRC;              // OpenGL
    PVOID glContext;                // OpenGL
    ULONG LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
#ifdef  _IA64_
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    PVOID DeallocationStack;
    PVOID TlsSlots[TLS_MINIMUM_AVAILABLE];
    LIST_ENTRY TlsLinks;
    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];
    ULONG HardErrorsAreDisabled;
    PVOID Instrumentation[16];
    PVOID WinSockData;              // WinSock
    ULONG GdiBatchCount;
    ULONG Spare2;
    ULONG Spare3;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WX86THREAD Wx86Thread;
    PVOID *TlsExpansionSlots;
} TEB;
typedef TEB *PTEB;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB_FREE_BLOCK {
    struct _PEB_FREE_BLOCK *Next;
    ULONG Size;
} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;

#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_IA64_) && !defined(_AXP64_)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef
VOID
(*PPS_POST_PROCESS_INIT_ROUTINE) (
    VOID
    );

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    HANDLE Mutant;                      // INITIAL_PEB structure is also updated.

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID FastPebLockRoutine;
    PVOID FastPebUnlockRoutine;
    ULONG EnvironmentUpdateCount;
    PVOID KernelCallbackTable;
    ULONG SystemReserved[2];
    PPEB_FREE_BLOCK FreeList;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];         // relates to TLS_MINIMUM_AVAILABLE
    PVOID ReadOnlySharedMemoryBase;
    PVOID ReadOnlySharedMemoryHeap;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    //
    // Useful information for LdrpInitialize
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    //
    // Passed up from MmCreatePeb from Session Manager registry key
    //

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    //
    // Where heap manager keeps track of all heaps created for a process
    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
    // is computed from the page size used to hold the PEB, less the fixed
    // size of this data structure.
    //

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    //
    //
    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;
    PVOID LoaderLock;

    //
    // Following fields filled in by MmCreatePeb from system values and/or
    // image header.
    //

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ImageProcessAffinityMask;
    ULONG GdiHandleBuffer[GDI_HANDLE_BUFFER_SIZE];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];   // relates to TLS_EXPANSION_SLOTS

    //
    // Id of the Hydra session in which this process is running
    //
    ULONG SessionId;

    //
    // Filled in by LdrQueryImageFileExecutionOptions
    //
    PVOID AppCompatInfo;

    //
    // Used by GetVersionExW as the szCSDVersion string
    // 
    UNICODE_STRING CSDVersion;


} PEB, *PPEB;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\columnbinding.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//****************************************************************************
//  File: ColBind.CPP
//  Notes:
//   Column binding macros for internal use in mscoree.
//****************************************************************************

#ifndef lengthof
#define lengthof(x) (sizeof(x)/sizeof(x[0]))
#endif

// Binding info for SetColumns
#define DECLARE_COLUMN_BINDING__(n, prefix) \
	DBTYPE		prefix##_bind_rType[n];				/* The types				*/	\
	const void	*prefix##_bind_rpvData[n];			/* The data.				*/	\
	ULONG		prefix##_bind_rcbData[n];			/* Size of the data.		*/	\
	ULONG		prefix##_bind_rcbActual[n];			/* If truncation.			*/	\
	HRESULT		prefix##_bind_rhr[n];				/* Column-wise results.		*/	\
	int			prefix##_bind_cColumns=0;			/* Count of the columns.	*/	\
	int			prefix##_bind_iColumn=0;			/* Most recent column.		*/	\
	ULONG		prefix##_bind_fMask=0; 				/* Bit mask of columns.		*/

#define DECLARE_VARIABLE_BYREF__(prefix) \
	ULONG		prefix##_bind_fVariableByref=0;		/* Bit mask of byref-flips  */

#define BIND_COLUMN__(column, type, addr, size, prefix)								\
{																					\
	_ASSERTE(prefix##_bind_cColumns < lengthof(prefix##_bind_rType));				\
	_ASSERTE(column> prefix##_bind_iColumn);										\
	prefix##_bind_rType[prefix##_bind_cColumns] = type;								\
	prefix##_bind_rpvData[prefix##_bind_cColumns] = addr;							\
	prefix##_bind_rcbData[prefix##_bind_cColumns] = size;							\
	prefix##_bind_rhr[prefix##_bind_cColumns] = 0;									\
	prefix##_bind_fMask |= 1 << column;												\
	prefix##_bind_iColumn = column;													\
	++prefix##_bind_cColumns;														\
}
#define REBIND_COLUMN__(ix, addr, prefix)											\
	prefix##_bind_rpvData[ix] = addr

// Get the index of the just-bound column.
#define BOUND_COLUMN_INDEX__(prefix) (prefix##_bind_cColumns - 1)

// Retrieve the value of a data pointer.  Useful after fetching a by-ref
//  string.
#define BOUND_COLUMN_POINTER__(n,prefix) (prefix##_bind_rpvData[n])

#define VARIABLE_BYREF_COLUMN__(n,prefix)											\
	prefix##_bind_fVariableByref |= (1 << n)

#define APPLY_BYREF__(prefix)														\
	{ for (int n=0; n<prefix##_bind_cColumns; ++n)									\
	      if (prefix##_bind_fVariableByref & (1 << n))								\
               prefix##_bind_rType[n] |= DBTYPE_BYREF;								\
	}

#define REMOVE_BYREF__(prefix)														\
	{ for (int n=0; n<prefix##_bind_cColumns; ++n)									\
	      if (prefix##_bind_fVariableByref & (1 << n))								\
               prefix##_bind_rType[n] &= ~DBTYPE_BYREF;								\
	}

#define NUM_BOUND_COLUMNS__(prefix) prefix##_bind_cColumns

#define UNBIND_COLUMNS__(prefix)													\
	prefix##_bind_iColumn = -1;														\
	prefix##_bind_fMask = 0;														\
	prefix##_bind_cColumns = 0;

#define SET_BOUND_COLUMNS__(table, row, prefix)										\
	SetColumns(table, row, prefix##_bind_cColumns, 									\
			prefix##_bind_rType, prefix##_bind_rpvData, prefix##_bind_rcbData,		\
			prefix##_bind_rcbActual, prefix##_bind_rhr, &prefix##_bind_fMask)

#define GET_BOUND_COLUMNS__(table, row, prefix)										\
	GetColumns(table, row, prefix##_bind_cColumns, 									\
			prefix##_bind_rType, prefix##_bind_rpvData, prefix##_bind_rcbData,		\
			prefix##_bind_rcbActual, prefix##_bind_rhr, &prefix##_bind_fMask)

#define COLUMN_STATUS__(n,prefix) prefix##_bind_rhr[n]
#define COLUMN_DATA__(n,prefix) prefix##_bind_rpvData[n]
#define COLUMN_DATA_CB__(n,prefix) prefix##_bind_rcbData[n]
#define COLUMN_DATA_CBACTUAL__(n, prefix) prefix##_bind_rcbActual[n]

#define DECLARE_COLUMN_BINDING(n) DECLARE_COLUMN_BINDING__(n,def)
#define DECLARE_VARIABLE_BYREF() DECLARE_VARIABLE_BYREF__(def)
#define BIND_COLUMN(c,t,a,s) BIND_COLUMN__(c,t,a,s,def)
#define BOUND_COLUMN_INDEX() BOUND_COLUMN_INDEX__(def)
#define APPLY_BYREF() APPLY_BYREF__(def)
#define REMOVE_BYREF() REMOVE_BYREF__(def)
#define VARIABLE_BYREF_COLUMN(n) VARIABLE_BYREF_COLUMN__(n,def)
#define BOUND_COLUMN_POINTER(n) BOUND_COLUMN_POINTER__(n,def)
#define REBIND_COLUMN(n,a) REBIND_COLUMN__(n,a,def)
#define NUM_BOUND_COLUMNS() NUM_BOUND_COLUMNS__(def)
#define UNBIND_COLUMNS() UNBIND_COLUMNS__(def)
#define SET_BOUND_COLUMNS(t,r) SET_BOUND_COLUMNS__(t,r,def)
#define GET_BOUND_COLUMNS(t,r) GET_BOUND_COLUMNS__(t,r,def)
#define COLUMN_STATUS(n) COLUMN_STATUS__(n,def)
#define COLUMN_DATA(n) COLUMN_DATA__(n,def)
#define COLUMN_DATA_CB(n) COLUMN_DATA_CB__(n,def)
#define COLUMN_DATA_CBACTUAL(n) COLUMN_DATA_CBACTUAL__(n,def)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\compressionformat.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CompressionFormat.h
//
//*****************************************************************************

// Describes the on-disk compression format for encoding/decoding tables for
// compressed opcodes

#ifndef _COMPRESSIONFORMAT_H
#define _COMPRESSIONFORMAT_H

#pragma pack(push,1)
typedef struct
{
    // Number of macros defined in the table
    // Macro opcodes start at 1
    DWORD  dwNumMacros;

    // Cumulative number of instructions from all macros - used to help the
    // decoder determine decoding table size
    DWORD  dwNumMacroComponents;
} CompressionMacroHeader;
#pragma pack(pop)

#endif /* _COMPRESSIONFORMAT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\codeproc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:13 2003
 */
/* Compiler settings for codeproc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "codeproc.h"

#define TYPE_FORMAT_STRING_SIZE   109                               
#define PROC_FORMAT_STRING_SIZE   129                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICodeProcess_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICodeProcess_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CodeUse */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 10 */	NdrFcShort( 0x18 ),	/* 24 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xc,		/* 12 */

	/* Parameter pBSC */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter pBC */

/* 22 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pIBind */

/* 28 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pSink */

/* 34 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pClient */

/* 40 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 42 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 44 */	NdrFcShort( 0x4a ),	/* Type Offset=74 */

	/* Parameter lpCacheName */

/* 46 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 50 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */

	/* Parameter lpRawURL */

/* 52 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 54 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 56 */	NdrFcShort( 0x62 ),	/* Type Offset=98 */

	/* Parameter lpCodeBase */

/* 58 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 60 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 62 */	NdrFcShort( 0x66 ),	/* Type Offset=102 */

	/* Parameter fObjectTag */

/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 66 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwContextFlags */

/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 72 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwReserved */

/* 76 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 78 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 80 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 84 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadComplete */

/* 88 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x4 ),	/* 4 */
/* 96 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 98 */	NdrFcShort( 0x10 ),	/* 16 */
/* 100 */	NdrFcShort( 0x8 ),	/* 8 */
/* 102 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter hrResult */

/* 104 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 106 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwError */

/* 110 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 112 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 114 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter wzResult */

/* 116 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 118 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 120 */	NdrFcShort( 0x6a ),	/* Type Offset=106 */

	/* Return value */

/* 122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 124 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x79eac9c1 ),	/* 2045430209 */
/*  8 */	NdrFcShort( 0xbaf9 ),	/* -17671 */
/* 10 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 12 */	0x8c,		/* 140 */
			0x82,		/* 130 */
/* 14 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 16 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 18 */	0xa9,		/* 169 */
			0xb,		/* 11 */
/* 20 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 22 */	NdrFcLong( 0xe ),	/* 14 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 32 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 34 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 36 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 38 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 40 */	NdrFcLong( 0x79eac9e1 ),	/* 2045430241 */
/* 44 */	NdrFcShort( 0xbaf9 ),	/* -17671 */
/* 46 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 48 */	0x8c,		/* 140 */
			0x82,		/* 130 */
/* 50 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 52 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 54 */	0xa9,		/* 169 */
			0xb,		/* 11 */
/* 56 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 58 */	NdrFcLong( 0x79eac9e5 ),	/* 2045430245 */
/* 62 */	NdrFcShort( 0xbaf9 ),	/* -17671 */
/* 64 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 66 */	0x8c,		/* 140 */
			0x82,		/* 130 */
/* 68 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 70 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 72 */	0xa9,		/* 169 */
			0xb,		/* 11 */
/* 74 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 76 */	NdrFcLong( 0x79eac9e4 ),	/* 2045430244 */
/* 80 */	NdrFcShort( 0xbaf9 ),	/* -17671 */
/* 82 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 84 */	0x8c,		/* 140 */
			0x82,		/* 130 */
/* 86 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 88 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 90 */	0xa9,		/* 169 */
			0xb,		/* 11 */
/* 92 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 94 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 96 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 98 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 100 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 102 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 104 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 106 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_codeproc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICodeProcess, ver. 0.0,
   GUID={0x3196269D,0x7B67,0x11d2,{0x87,0x11,0x00,0xC0,0x4F,0x79,0xED,0x0D}} */

#pragma code_seg(".orpc")
static const unsigned short ICodeProcess_FormatStringOffsetTable[] =
    {
    0,
    88
    };

static const MIDL_STUBLESS_PROXY_INFO ICodeProcess_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICodeProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICodeProcess_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICodeProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICodeProcessProxyVtbl = 
{
    &ICodeProcess_ProxyInfo,
    &IID_ICodeProcess,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICodeProcess::CodeUse */ ,
    (void *) (INT_PTR) -1 /* ICodeProcess::LoadComplete */
};

const CInterfaceStubVtbl _ICodeProcessStubVtbl =
{
    &IID_ICodeProcess,
    &ICodeProcess_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_codeproc_0208, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _codeproc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICodeProcessProxyVtbl,
    0
};

const CInterfaceStubVtbl * _codeproc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICodeProcessStubVtbl,
    0
};

PCInterfaceName const _codeproc_InterfaceNamesList[] = 
{
    "ICodeProcess",
    0
};


#define _codeproc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _codeproc, pIID, n)

int __stdcall _codeproc_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_codeproc_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo codeproc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _codeproc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _codeproc_StubVtblList,
    (const PCInterfaceName * ) & _codeproc_InterfaceNamesList,
    0, // no delegation
    & _codeproc_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\contxt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon May 01 14:39:38 2000
 */
/* Compiler settings for contxt.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contxt_h__
#define __contxt_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumContextProps_FWD_DEFINED__
#define __IEnumContextProps_FWD_DEFINED__
typedef interface IEnumContextProps IEnumContextProps;
#endif 	/* __IEnumContextProps_FWD_DEFINED__ */


#ifndef __IContext_FWD_DEFINED__
#define __IContext_FWD_DEFINED__
typedef interface IContext IContext;
#endif 	/* __IContext_FWD_DEFINED__ */


#ifndef __IContextMarshaler_FWD_DEFINED__
#define __IContextMarshaler_FWD_DEFINED__
typedef interface IContextMarshaler IContextMarshaler;
#endif 	/* __IContextMarshaler_FWD_DEFINED__ */


#ifndef __IObjContext_FWD_DEFINED__
#define __IObjContext_FWD_DEFINED__
typedef interface IObjContext IObjContext;
#endif 	/* __IObjContext_FWD_DEFINED__ */


#ifndef __IGetContextId_FWD_DEFINED__
#define __IGetContextId_FWD_DEFINED__
typedef interface IGetContextId IGetContextId;
#endif 	/* __IGetContextId_FWD_DEFINED__ */


#ifndef __IAggregator_FWD_DEFINED__
#define __IAggregator_FWD_DEFINED__
typedef interface IAggregator IAggregator;
#endif 	/* __IAggregator_FWD_DEFINED__ */


#ifndef __ICall_FWD_DEFINED__
#define __ICall_FWD_DEFINED__
typedef interface ICall ICall;
#endif 	/* __ICall_FWD_DEFINED__ */


#ifndef __IRpcCall_FWD_DEFINED__
#define __IRpcCall_FWD_DEFINED__
typedef interface IRpcCall IRpcCall;
#endif 	/* __IRpcCall_FWD_DEFINED__ */


#ifndef __ICallInfo_FWD_DEFINED__
#define __ICallInfo_FWD_DEFINED__
typedef interface ICallInfo ICallInfo;
#endif 	/* __ICallInfo_FWD_DEFINED__ */


#ifndef __IPolicy_FWD_DEFINED__
#define __IPolicy_FWD_DEFINED__
typedef interface IPolicy IPolicy;
#endif 	/* __IPolicy_FWD_DEFINED__ */


#ifndef __IPolicyAsync_FWD_DEFINED__
#define __IPolicyAsync_FWD_DEFINED__
typedef interface IPolicyAsync IPolicyAsync;
#endif 	/* __IPolicyAsync_FWD_DEFINED__ */


#ifndef __IPolicySet_FWD_DEFINED__
#define __IPolicySet_FWD_DEFINED__
typedef interface IPolicySet IPolicySet;
#endif 	/* __IPolicySet_FWD_DEFINED__ */


#ifndef __IComObjIdentity_FWD_DEFINED__
#define __IComObjIdentity_FWD_DEFINED__
typedef interface IComObjIdentity IComObjIdentity;
#endif 	/* __IComObjIdentity_FWD_DEFINED__ */


#ifndef __IPolicyMaker_FWD_DEFINED__
#define __IPolicyMaker_FWD_DEFINED__
typedef interface IPolicyMaker IPolicyMaker;
#endif 	/* __IPolicyMaker_FWD_DEFINED__ */


#ifndef __IExceptionNotification_FWD_DEFINED__
#define __IExceptionNotification_FWD_DEFINED__
typedef interface IExceptionNotification IExceptionNotification;
#endif 	/* __IExceptionNotification_FWD_DEFINED__ */


#ifndef __IMarshalEnvoy_FWD_DEFINED__
#define __IMarshalEnvoy_FWD_DEFINED__
typedef interface IMarshalEnvoy IMarshalEnvoy;
#endif 	/* __IMarshalEnvoy_FWD_DEFINED__ */


#ifndef __IWrapperInfo_FWD_DEFINED__
#define __IWrapperInfo_FWD_DEFINED__
typedef interface IWrapperInfo IWrapperInfo;
#endif 	/* __IWrapperInfo_FWD_DEFINED__ */


#ifndef __IComThreadingInfo_FWD_DEFINED__
#define __IComThreadingInfo_FWD_DEFINED__
typedef interface IComThreadingInfo IComThreadingInfo;
#endif 	/* __IComThreadingInfo_FWD_DEFINED__ */


#ifndef __IComDispatchInfo_FWD_DEFINED__
#define __IComDispatchInfo_FWD_DEFINED__
typedef interface IComDispatchInfo IComDispatchInfo;
#endif 	/* __IComDispatchInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_contxt_0000 */
/* [local] */ 

enum tagCONTEXTEVENT
    {	CONTEXTEVENT_NONE	= 0,
	CONTEXTEVENT_CALL	= 0x1,
	CONTEXTEVENT_ENTER	= 0x2,
	CONTEXTEVENT_LEAVE	= 0x4,
	CONTEXTEVENT_RETURN	= 0x8,
	CONTEXTEVENT_CALLFILLBUFFER	= 0x10,
	CONTEXTEVENT_ENTERWITHBUFFER	= 0x20,
	CONTEXTEVENT_LEAVEFILLBUFFER	= 0x40,
	CONTEXTEVENT_RETURNWITHBUFFER	= 0x80,
	CONTEXTEVENT_BEGINCALL	= 0x100,
	CONTEXTEVENT_BEGINENTER	= 0x200,
	CONTEXTEVENT_BEGINLEAVE	= 0x400,
	CONTEXTEVENT_BEGINRETURN	= 0x800,
	CONTEXTEVENT_FINISHCALL	= 0x1000,
	CONTEXTEVENT_FINISHENTER	= 0x2000,
	CONTEXTEVENT_FINISHLEAVE	= 0x4000,
	CONTEXTEVENT_FINISHRETURN	= 0x8000,
	CONTEXTEVENT_BEGINCALLFILLBUFFER	= 0x10000,
	CONTEXTEVENT_BEGINENTERWITHBUFFER	= 0x20000,
	CONTEXTEVENT_FINISHLEAVEFILLBUFFER	= 0x40000,
	CONTEXTEVENT_FINISHRETURNWITHBUFFER	= 0x80000,
	CONTEXTEVENT_LEAVEEXCEPTION	= 0x100000,
	CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER	= 0x200000,
	CONTEXTEVENT_RETURNEXCEPTION	= 0x400000,
	CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER	= 0x800000,
	CONTEXTEVENT_ADDREFPOLICY	= 0x10000000,
	CONTEXTEVENT_RELEASEPOLICY	= 0x20000000
    };
typedef DWORD ContextEvent;


enum tagCPFLAGS
    {	CPFLAG_NONE	= 0,
	CPFLAG_PROPAGATE	= 0x1,
	CPFLAG_EXPOSE	= 0x2,
	CPFLAG_ENVOY	= 0x4,
	CPFLAG_MONITORSTUB	= 0x8,
	CPFLAG_MONITORPROXY	= 0x10,
	CPFLAG_DONTCOMPARE	= 0x20
    };
typedef DWORD CPFLAGS;

typedef struct  tagContextProperty
    {
    GUID policyId;
    CPFLAGS flags;
    /* [unique] */ IUnknown __RPC_FAR *pUnk;
    }	ContextProperty;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_v0_0_s_ifspec;

#ifndef __IEnumContextProps_INTERFACE_DEFINED__
#define __IEnumContextProps_INTERFACE_DEFINED__

/* interface IEnumContextProps */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumContextProps __RPC_FAR *LPENUMCONTEXTPROPS;


EXTERN_C const IID IID_IEnumContextProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c1-0000-0000-C000-000000000046")
    IEnumContextProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ContextProperty __RPC_FAR *pContextProperties,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumContextPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumContextProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumContextProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumContextProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumContextProps __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ContextProperty __RPC_FAR *pContextProperties,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumContextProps __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumContextProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumContextProps __RPC_FAR * This,
            /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IEnumContextProps __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumContextPropsVtbl;

    interface IEnumContextProps
    {
        CONST_VTBL struct IEnumContextPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumContextProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumContextProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumContextProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumContextProps_Next(This,celt,pContextProperties,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pContextProperties,pceltFetched)

#define IEnumContextProps_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumContextProps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumContextProps_Clone(This,ppEnumContextProps)	\
    (This)->lpVtbl -> Clone(This,ppEnumContextProps)

#define IEnumContextProps_Count(This,pcelt)	\
    (This)->lpVtbl -> Count(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumContextProps_Next_Proxy( 
    IEnumContextProps __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ContextProperty __RPC_FAR *pContextProperties,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumContextProps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Skip_Proxy( 
    IEnumContextProps __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumContextProps_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Reset_Proxy( 
    IEnumContextProps __RPC_FAR * This);


void __RPC_STUB IEnumContextProps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Clone_Proxy( 
    IEnumContextProps __RPC_FAR * This,
    /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps);


void __RPC_STUB IEnumContextProps_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Count_Proxy( 
    IEnumContextProps __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumContextProps_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumContextProps_INTERFACE_DEFINED__ */


#ifndef __IContext_INTERFACE_DEFINED__
#define __IContext_INTERFACE_DEFINED__

/* interface IContext */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c0-0000-0000-C000-000000000046")
    IContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ REFGUID rPolicyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS __RPC_FAR *pFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContextProps( 
            /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IContext __RPC_FAR * This,
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IContext __RPC_FAR * This,
            /* [in] */ REFGUID rPolicyId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IContext __RPC_FAR * This,
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS __RPC_FAR *pFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumContextProps )( 
            IContext __RPC_FAR * This,
            /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps);
        
        END_INTERFACE
    } IContextVtbl;

    interface IContext
    {
        CONST_VTBL struct IContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContext_SetProperty_Proxy( 
    IContext __RPC_FAR * This,
    /* [in] */ REFGUID rpolicyId,
    /* [in] */ CPFLAGS flags,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB IContext_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_RemoveProperty_Proxy( 
    IContext __RPC_FAR * This,
    /* [in] */ REFGUID rPolicyId);


void __RPC_STUB IContext_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_GetProperty_Proxy( 
    IContext __RPC_FAR * This,
    /* [in] */ REFGUID rGuid,
    /* [out] */ CPFLAGS __RPC_FAR *pFlags,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IContext_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_EnumContextProps_Proxy( 
    IContext __RPC_FAR * This,
    /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps);


void __RPC_STUB IContext_EnumContextProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContext_INTERFACE_DEFINED__ */


#ifndef __IContextMarshaler_INTERFACE_DEFINED__
#define __IContextMarshaler_INTERFACE_DEFINED__

/* interface IContextMarshaler */
/* [uuid][object][local] */ 

typedef /* [unique] */ IContextMarshaler __RPC_FAR *LPCTXMARSHALER;


EXTERN_C const IID IID_IContextMarshaler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001D8-0000-0000-C000-000000000046")
    IContextMarshaler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMarshalerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMarshaler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMarshaler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMarshaler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarshalSizeMax )( 
            IContextMarshaler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MarshalInterface )( 
            IContextMarshaler __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        END_INTERFACE
    } IContextMarshalerVtbl;

    interface IContextMarshaler
    {
        CONST_VTBL struct IContextMarshalerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMarshaler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMarshaler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMarshaler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMarshaler_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IContextMarshaler_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextMarshaler_GetMarshalSizeMax_Proxy( 
    IContextMarshaler __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize);


void __RPC_STUB IContextMarshaler_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextMarshaler_MarshalInterface_Proxy( 
    IContextMarshaler __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IContextMarshaler_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMarshaler_INTERFACE_DEFINED__ */


#ifndef __IObjContext_INTERFACE_DEFINED__
#define __IObjContext_INTERFACE_DEFINED__

/* interface IObjContext */
/* [unique][uuid][object][local] */ 

typedef /* [ref] */ HRESULT ( __stdcall __RPC_FAR *PFNCTXCALLBACK )( 
    void __RPC_FAR *pParam);


EXTERN_C const IID IID_IObjContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c6-0000-0000-C000-000000000046")
    IObjContext : public IContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Freeze( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoCallback( 
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void __RPC_FAR *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextMarshaler( 
            /* [in] */ IContextMarshaler __RPC_FAR *pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextMarshaler( 
            /* [out] */ IContextMarshaler __RPC_FAR *__RPC_FAR *pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ REFGUID rPolicyId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS __RPC_FAR *pFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumContextProps )( 
            IObjContext __RPC_FAR * This,
            /* [out] */ IEnumContextProps __RPC_FAR *__RPC_FAR *ppEnumContextProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            IObjContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoCallback )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void __RPC_FAR *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextMarshaler )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ IContextMarshaler __RPC_FAR *pICM);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextMarshaler )( 
            IObjContext __RPC_FAR * This,
            /* [out] */ IContextMarshaler __RPC_FAR *__RPC_FAR *pICM);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextFlags )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearContextFlags )( 
            IObjContext __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextFlags )( 
            IObjContext __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IObjContextVtbl;

    interface IObjContext
    {
        CONST_VTBL struct IObjContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IObjContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IObjContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IObjContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)


#define IObjContext_Freeze(This)	\
    (This)->lpVtbl -> Freeze(This)

#define IObjContext_DoCallback(This,pfnCallback,pParam,riid,iMethod)	\
    (This)->lpVtbl -> DoCallback(This,pfnCallback,pParam,riid,iMethod)

#define IObjContext_SetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> SetContextMarshaler(This,pICM)

#define IObjContext_GetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> GetContextMarshaler(This,pICM)

#define IObjContext_SetContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetContextFlags(This,dwFlags)

#define IObjContext_ClearContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> ClearContextFlags(This,dwFlags)

#define IObjContext_GetContextFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetContextFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjContext_Freeze_Proxy( 
    IObjContext __RPC_FAR * This);


void __RPC_STUB IObjContext_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_DoCallback_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [in] */ PFNCTXCALLBACK pfnCallback,
    /* [in] */ void __RPC_FAR *pParam,
    /* [in] */ REFIID riid,
    /* [in] */ unsigned int iMethod);


void __RPC_STUB IObjContext_DoCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextMarshaler_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [in] */ IContextMarshaler __RPC_FAR *pICM);


void __RPC_STUB IObjContext_SetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextMarshaler_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [out] */ IContextMarshaler __RPC_FAR *__RPC_FAR *pICM);


void __RPC_STUB IObjContext_GetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextFlags_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_SetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_ClearContextFlags_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_ClearContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextFlags_Proxy( 
    IObjContext __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IObjContext_GetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjContext_INTERFACE_DEFINED__ */


#ifndef __IGetContextId_INTERFACE_DEFINED__
#define __IGetContextId_INTERFACE_DEFINED__

/* interface IGetContextId */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGetContextId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dd-0000-0000-C000-000000000046")
    IGetContextId : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContextId( 
            /* [out] */ GUID __RPC_FAR *pguidCtxtId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetContextId __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetContextId __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetContextId __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextId )( 
            IGetContextId __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidCtxtId);
        
        END_INTERFACE
    } IGetContextIdVtbl;

    interface IGetContextId
    {
        CONST_VTBL struct IGetContextIdVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetContextId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetContextId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetContextId_GetContextId(This,pguidCtxtId)	\
    (This)->lpVtbl -> GetContextId(This,pguidCtxtId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetContextId_GetContextId_Proxy( 
    IGetContextId __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidCtxtId);


void __RPC_STUB IGetContextId_GetContextId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetContextId_INTERFACE_DEFINED__ */


#ifndef __IAggregator_INTERFACE_DEFINED__
#define __IAggregator_INTERFACE_DEFINED__

/* interface IAggregator */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAggregator __RPC_FAR *IAGGREGATOR;


EXTERN_C const IID IID_IAggregator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d8-0000-0000-C000-000000000046")
    IAggregator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Aggregate( 
            /* [in] */ IUnknown __RPC_FAR *pInnerUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAggregatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAggregator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAggregator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAggregator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Aggregate )( 
            IAggregator __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pInnerUnk);
        
        END_INTERFACE
    } IAggregatorVtbl;

    interface IAggregator
    {
        CONST_VTBL struct IAggregatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAggregator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAggregator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAggregator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAggregator_Aggregate(This,pInnerUnk)	\
    (This)->lpVtbl -> Aggregate(This,pInnerUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAggregator_Aggregate_Proxy( 
    IAggregator __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pInnerUnk);


void __RPC_STUB IAggregator_Aggregate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAggregator_INTERFACE_DEFINED__ */


#ifndef __ICall_INTERFACE_DEFINED__
#define __ICall_INTERFACE_DEFINED__

/* interface ICall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICall __RPC_FAR *LPCALL;


EXTERN_C const IID IID_ICall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d6-0000-0000-C000-000000000046")
    ICall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallInfo( 
            /* [out] */ const void __RPC_FAR *__RPC_FAR *ppIdentity,
            /* [out] */ IID __RPC_FAR *piid,
            /* [out] */ DWORD __RPC_FAR *pdwMethod,
            /* [out] */ HRESULT __RPC_FAR *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Nullify( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerHR( 
            /* [out] */ HRESULT __RPC_FAR *phr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallInfo )( 
            ICall __RPC_FAR * This,
            /* [out] */ const void __RPC_FAR *__RPC_FAR *ppIdentity,
            /* [out] */ IID __RPC_FAR *piid,
            /* [out] */ DWORD __RPC_FAR *pdwMethod,
            /* [out] */ HRESULT __RPC_FAR *phr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Nullify )( 
            ICall __RPC_FAR * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerHR )( 
            ICall __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phr);
        
        END_INTERFACE
    } ICallVtbl;

    interface ICall
    {
        CONST_VTBL struct ICallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICall_GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)	\
    (This)->lpVtbl -> GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)

#define ICall_Nullify(This,hr)	\
    (This)->lpVtbl -> Nullify(This,hr)

#define ICall_GetServerHR(This,phr)	\
    (This)->lpVtbl -> GetServerHR(This,phr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICall_GetCallInfo_Proxy( 
    ICall __RPC_FAR * This,
    /* [out] */ const void __RPC_FAR *__RPC_FAR *ppIdentity,
    /* [out] */ IID __RPC_FAR *piid,
    /* [out] */ DWORD __RPC_FAR *pdwMethod,
    /* [out] */ HRESULT __RPC_FAR *phr);


void __RPC_STUB ICall_GetCallInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_Nullify_Proxy( 
    ICall __RPC_FAR * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB ICall_Nullify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_GetServerHR_Proxy( 
    ICall __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phr);


void __RPC_STUB ICall_GetServerHR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICall_INTERFACE_DEFINED__ */


#ifndef __IRpcCall_INTERFACE_DEFINED__
#define __IRpcCall_INTERFACE_DEFINED__

/* interface IRpcCall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IRpcCall __RPC_FAR *LPRPCCALL;


EXTERN_C const IID IID_IRpcCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c5-0000-0000-C000-000000000046")
    IRpcCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRpcOleMessage( 
            /* [out] */ RPCOLEMESSAGE __RPC_FAR *__RPC_FAR *ppMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRpcCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRpcCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRpcCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRpcOleMessage )( 
            IRpcCall __RPC_FAR * This,
            /* [out] */ RPCOLEMESSAGE __RPC_FAR *__RPC_FAR *ppMessage);
        
        END_INTERFACE
    } IRpcCallVtbl;

    interface IRpcCall
    {
        CONST_VTBL struct IRpcCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcCall_GetRpcOleMessage(This,ppMessage)	\
    (This)->lpVtbl -> GetRpcOleMessage(This,ppMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRpcCall_GetRpcOleMessage_Proxy( 
    IRpcCall __RPC_FAR * This,
    /* [out] */ RPCOLEMESSAGE __RPC_FAR *__RPC_FAR *ppMessage);


void __RPC_STUB IRpcCall_GetRpcOleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcCall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0083 */
/* [local] */ 

typedef 
enum _CALLSOURCE
    {	CALLSOURCE_CROSSAPT	= 0,
	CALLSOURCE_CROSSCTX	= 1
    }	CALLSOURCE;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0083_v0_0_s_ifspec;

#ifndef __ICallInfo_INTERFACE_DEFINED__
#define __ICallInfo_INTERFACE_DEFINED__

/* interface ICallInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ICallInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dc-0000-0000-C000-000000000046")
    ICallInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallSource( 
            /* [out] */ CALLSOURCE __RPC_FAR *pCallSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICallInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICallInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICallInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallSource )( 
            ICallInfo __RPC_FAR * This,
            /* [out] */ CALLSOURCE __RPC_FAR *pCallSource);
        
        END_INTERFACE
    } ICallInfoVtbl;

    interface ICallInfo
    {
        CONST_VTBL struct ICallInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICallInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICallInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICallInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICallInfo_GetCallSource(This,pCallSource)	\
    (This)->lpVtbl -> GetCallSource(This,pCallSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICallInfo_GetCallSource_Proxy( 
    ICallInfo __RPC_FAR * This,
    /* [out] */ CALLSOURCE __RPC_FAR *pCallSource);


void __RPC_STUB ICallInfo_GetCallSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICallInfo_INTERFACE_DEFINED__ */


#ifndef __IPolicy_INTERFACE_DEFINED__
#define __IPolicy_INTERFACE_DEFINED__

/* interface IPolicy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c2-0000-0000-C000-000000000046")
    IPolicy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Call( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enter( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Return( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallGetSize( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallFillBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterWithBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveGetSize( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFillBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnWithBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRefPolicy( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleasePolicy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPolicy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPolicy __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Call )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enter )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Leave )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Return )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallGetSize )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallFillBuffer )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnterWithBuffer )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LeaveGetSize )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LeaveFillBuffer )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReturnWithBuffer )( 
            IPolicy __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRefPolicy )( 
            IPolicy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *ReleasePolicy )( 
            IPolicy __RPC_FAR * This);
        
        END_INTERFACE
    } IPolicyVtbl;

    interface IPolicy
    {
        CONST_VTBL struct IPolicyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicy_Call(This,pCall)	\
    (This)->lpVtbl -> Call(This,pCall)

#define IPolicy_Enter(This,pCall)	\
    (This)->lpVtbl -> Enter(This,pCall)

#define IPolicy_Leave(This,pCall)	\
    (This)->lpVtbl -> Leave(This,pCall)

#define IPolicy_Return(This,pCall)	\
    (This)->lpVtbl -> Return(This,pCall)

#define IPolicy_CallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> CallGetSize(This,pCall,pcb)

#define IPolicy_CallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> CallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_EnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> EnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_LeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> LeaveGetSize(This,pCall,pcb)

#define IPolicy_LeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> LeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_ReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> ReturnWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_AddRefPolicy(This)	\
    (This)->lpVtbl -> AddRefPolicy(This)

#define IPolicy_ReleasePolicy(This)	\
    (This)->lpVtbl -> ReleasePolicy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicy_Call_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicy_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Enter_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicy_Enter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Leave_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicy_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Return_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicy_Return_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallGetSize_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicy_CallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallFillBuffer_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicy_CallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_EnterWithBuffer_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_EnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveGetSize_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicy_LeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveFillBuffer_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicy_LeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_ReturnWithBuffer_Proxy( 
    IPolicy __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_ReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_AddRefPolicy_Proxy( 
    IPolicy __RPC_FAR * This);


void __RPC_STUB IPolicy_AddRefPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_ReleasePolicy_Proxy( 
    IPolicy __RPC_FAR * This);


void __RPC_STUB IPolicy_ReleasePolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicy_INTERFACE_DEFINED__ */


#ifndef __IPolicyAsync_INTERFACE_DEFINED__
#define __IPolicyAsync_INTERFACE_DEFINED__

/* interface IPolicyAsync */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001cd-0000-0000-C000-000000000046")
    IPolicyAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginCallGetSize( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCall( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCallFillBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnter( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnterWithBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginLeave( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginReturn( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishCall( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishEnter( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveGetSize( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeave( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveFillBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturn( 
            /* [in] */ ICall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturnWithBuffer( 
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPolicyAsync __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPolicyAsync __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginCallGetSize )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginCall )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginCallFillBuffer )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnter )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnterWithBuffer )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginLeave )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginReturn )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishCall )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishEnter )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishLeaveGetSize )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishLeave )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishLeaveFillBuffer )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishReturn )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinishReturnWithBuffer )( 
            IPolicyAsync __RPC_FAR * This,
            /* [in] */ ICall __RPC_FAR *pCall,
            /* [in] */ void __RPC_FAR *pvBuf,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IPolicyAsyncVtbl;

    interface IPolicyAsync
    {
        CONST_VTBL struct IPolicyAsyncVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyAsync_BeginCallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> BeginCallGetSize(This,pCall,pcb)

#define IPolicyAsync_BeginCall(This,pCall)	\
    (This)->lpVtbl -> BeginCall(This,pCall)

#define IPolicyAsync_BeginCallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> BeginCallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_BeginEnter(This,pCall)	\
    (This)->lpVtbl -> BeginEnter(This,pCall)

#define IPolicyAsync_BeginEnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> BeginEnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicyAsync_BeginLeave(This,pCall)	\
    (This)->lpVtbl -> BeginLeave(This,pCall)

#define IPolicyAsync_BeginReturn(This,pCall)	\
    (This)->lpVtbl -> BeginReturn(This,pCall)

#define IPolicyAsync_FinishCall(This,pCall)	\
    (This)->lpVtbl -> FinishCall(This,pCall)

#define IPolicyAsync_FinishEnter(This,pCall)	\
    (This)->lpVtbl -> FinishEnter(This,pCall)

#define IPolicyAsync_FinishLeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> FinishLeaveGetSize(This,pCall,pcb)

#define IPolicyAsync_FinishLeave(This,pCall)	\
    (This)->lpVtbl -> FinishLeave(This,pCall)

#define IPolicyAsync_FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_FinishReturn(This,pCall)	\
    (This)->lpVtbl -> FinishReturn(This,pCall)

#define IPolicyAsync_FinishReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> FinishReturnWithBuffer(This,pCall,pvBuf,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallGetSize_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicyAsync_BeginCallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCall_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_BeginCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallFillBuffer_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicyAsync_BeginCallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnter_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_BeginEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnterWithBuffer_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_BeginEnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginLeave_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_BeginLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginReturn_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_BeginReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishCall_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_FinishCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishEnter_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_FinishEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveGetSize_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeave_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_FinishLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveFillBuffer_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturn_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall);


void __RPC_STUB IPolicyAsync_FinishReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturnWithBuffer_Proxy( 
    IPolicyAsync __RPC_FAR * This,
    /* [in] */ ICall __RPC_FAR *pCall,
    /* [in] */ void __RPC_FAR *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_FinishReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyAsync_INTERFACE_DEFINED__ */


#ifndef __IPolicySet_INTERFACE_DEFINED__
#define __IPolicySet_INTERFACE_DEFINED__

/* interface IPolicySet */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c3-0000-0000-C000-000000000046")
    IPolicySet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPolicy( 
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy __RPC_FAR *pPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPolicySet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPolicySet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPolicySet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPolicy )( 
            IPolicySet __RPC_FAR * This,
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy __RPC_FAR *pPolicy);
        
        END_INTERFACE
    } IPolicySetVtbl;

    interface IPolicySet
    {
        CONST_VTBL struct IPolicySetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicySet_AddPolicy(This,ctxEvent,rguid,pPolicy)	\
    (This)->lpVtbl -> AddPolicy(This,ctxEvent,rguid,pPolicy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicySet_AddPolicy_Proxy( 
    IPolicySet __RPC_FAR * This,
    /* [in] */ ContextEvent ctxEvent,
    /* [in] */ REFGUID rguid,
    /* [in] */ IPolicy __RPC_FAR *pPolicy);


void __RPC_STUB IPolicySet_AddPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicySet_INTERFACE_DEFINED__ */


#ifndef __IComObjIdentity_INTERFACE_DEFINED__
#define __IComObjIdentity_INTERFACE_DEFINED__

/* interface IComObjIdentity */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComObjIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d7-0000-0000-C000-000000000046")
    IComObjIdentity : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsServer( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDeactivated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComObjIdentity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComObjIdentity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComObjIdentity __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsServer )( 
            IComObjIdentity __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsDeactivated )( 
            IComObjIdentity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIdentity )( 
            IComObjIdentity __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        END_INTERFACE
    } IComObjIdentityVtbl;

    interface IComObjIdentity
    {
        CONST_VTBL struct IComObjIdentityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComObjIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComObjIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComObjIdentity_IsServer(This)	\
    (This)->lpVtbl -> IsServer(This)

#define IComObjIdentity_IsDeactivated(This)	\
    (This)->lpVtbl -> IsDeactivated(This)

#define IComObjIdentity_GetIdentity(This,ppUnk)	\
    (This)->lpVtbl -> GetIdentity(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



BOOL STDMETHODCALLTYPE IComObjIdentity_IsServer_Proxy( 
    IComObjIdentity __RPC_FAR * This);


void __RPC_STUB IComObjIdentity_IsServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IComObjIdentity_IsDeactivated_Proxy( 
    IComObjIdentity __RPC_FAR * This);


void __RPC_STUB IComObjIdentity_IsDeactivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComObjIdentity_GetIdentity_Proxy( 
    IComObjIdentity __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IComObjIdentity_GetIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComObjIdentity_INTERFACE_DEFINED__ */


#ifndef __IPolicyMaker_INTERFACE_DEFINED__
#define __IPolicyMaker_INTERFACE_DEFINED__

/* interface IPolicyMaker */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyMaker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c4-0000-0000-C000-000000000046")
    IPolicyMaker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddClientPoliciesToSet( 
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvoyPoliciesToSet( 
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddServerPoliciesToSet( 
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Freeze( 
            /* [in] */ IObjContext __RPC_FAR *pObjContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStub( 
            /* [in] */ IComObjIdentity __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyStub( 
            /* [in] */ IComObjIdentity __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProxy( 
            /* [in] */ IComObjIdentity __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyProxy( 
            /* [in] */ IComObjIdentity __RPC_FAR *pID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyMakerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPolicyMaker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPolicyMaker __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddClientPoliciesToSet )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEnvoyPoliciesToSet )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddServerPoliciesToSet )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IPolicySet __RPC_FAR *pPS,
            /* [in] */ IContext __RPC_FAR *pClientContext,
            /* [in] */ IContext __RPC_FAR *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IObjContext __RPC_FAR *pObjContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStub )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IComObjIdentity __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyStub )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IComObjIdentity __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProxy )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IComObjIdentity __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyProxy )( 
            IPolicyMaker __RPC_FAR * This,
            /* [in] */ IComObjIdentity __RPC_FAR *pID);
        
        END_INTERFACE
    } IPolicyMakerVtbl;

    interface IPolicyMaker
    {
        CONST_VTBL struct IPolicyMakerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyMaker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyMaker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyMaker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyMaker_AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_Freeze(This,pObjContext)	\
    (This)->lpVtbl -> Freeze(This,pObjContext)

#define IPolicyMaker_CreateStub(This,pID)	\
    (This)->lpVtbl -> CreateStub(This,pID)

#define IPolicyMaker_DestroyStub(This,pID)	\
    (This)->lpVtbl -> DestroyStub(This,pID)

#define IPolicyMaker_CreateProxy(This,pID)	\
    (This)->lpVtbl -> CreateProxy(This,pID)

#define IPolicyMaker_DestroyProxy(This,pID)	\
    (This)->lpVtbl -> DestroyProxy(This,pID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyMaker_AddClientPoliciesToSet_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IPolicySet __RPC_FAR *pPS,
    /* [in] */ IContext __RPC_FAR *pClientContext,
    /* [in] */ IContext __RPC_FAR *pServerContext);


void __RPC_STUB IPolicyMaker_AddClientPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddEnvoyPoliciesToSet_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IPolicySet __RPC_FAR *pPS,
    /* [in] */ IContext __RPC_FAR *pClientContext,
    /* [in] */ IContext __RPC_FAR *pServerContext);


void __RPC_STUB IPolicyMaker_AddEnvoyPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddServerPoliciesToSet_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IPolicySet __RPC_FAR *pPS,
    /* [in] */ IContext __RPC_FAR *pClientContext,
    /* [in] */ IContext __RPC_FAR *pServerContext);


void __RPC_STUB IPolicyMaker_AddServerPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_Freeze_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IObjContext __RPC_FAR *pObjContext);


void __RPC_STUB IPolicyMaker_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateStub_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IComObjIdentity __RPC_FAR *pID);


void __RPC_STUB IPolicyMaker_CreateStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyStub_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IComObjIdentity __RPC_FAR *pID);


void __RPC_STUB IPolicyMaker_DestroyStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateProxy_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IComObjIdentity __RPC_FAR *pID);


void __RPC_STUB IPolicyMaker_CreateProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyProxy_Proxy( 
    IPolicyMaker __RPC_FAR * This,
    /* [in] */ IComObjIdentity __RPC_FAR *pID);


void __RPC_STUB IPolicyMaker_DestroyProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyMaker_INTERFACE_DEFINED__ */


#ifndef __IExceptionNotification_INTERFACE_DEFINED__
#define __IExceptionNotification_INTERFACE_DEFINED__

/* interface IExceptionNotification */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IExceptionNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001db-0000-0000-C000-000000000046")
    IExceptionNotification : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE ServerException( 
            /* [in] */ void __RPC_FAR *pExcepPtrs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExceptionNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExceptionNotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExceptionNotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExceptionNotification __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *ServerException )( 
            IExceptionNotification __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pExcepPtrs);
        
        END_INTERFACE
    } IExceptionNotificationVtbl;

    interface IExceptionNotification
    {
        CONST_VTBL struct IExceptionNotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExceptionNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExceptionNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExceptionNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExceptionNotification_ServerException(This,pExcepPtrs)	\
    (This)->lpVtbl -> ServerException(This,pExcepPtrs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IExceptionNotification_ServerException_Proxy( 
    IExceptionNotification __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pExcepPtrs);


void __RPC_STUB IExceptionNotification_ServerException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExceptionNotification_INTERFACE_DEFINED__ */


#ifndef __IMarshalEnvoy_INTERFACE_DEFINED__
#define __IMarshalEnvoy_INTERFACE_DEFINED__

/* interface IMarshalEnvoy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMarshalEnvoy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c8-0000-0000-C000-000000000046")
    IMarshalEnvoy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnvoyUnmarshalClass( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnvoySizeMax( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalEnvoy( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ DWORD dwDestContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalEnvoy( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalEnvoyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMarshalEnvoy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMarshalEnvoy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMarshalEnvoy __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnvoyUnmarshalClass )( 
            IMarshalEnvoy __RPC_FAR * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnvoySizeMax )( 
            IMarshalEnvoy __RPC_FAR * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MarshalEnvoy )( 
            IMarshalEnvoy __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ DWORD dwDestContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnmarshalEnvoy )( 
            IMarshalEnvoy __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } IMarshalEnvoyVtbl;

    interface IMarshalEnvoy
    {
        CONST_VTBL struct IMarshalEnvoyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshalEnvoy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshalEnvoy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshalEnvoy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshalEnvoy_GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)	\
    (This)->lpVtbl -> GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)

#define IMarshalEnvoy_GetEnvoySizeMax(This,dwDestContext,pcb)	\
    (This)->lpVtbl -> GetEnvoySizeMax(This,dwDestContext,pcb)

#define IMarshalEnvoy_MarshalEnvoy(This,pStream,dwDestContext)	\
    (This)->lpVtbl -> MarshalEnvoy(This,pStream,dwDestContext)

#define IMarshalEnvoy_UnmarshalEnvoy(This,pStream,riid,ppunk)	\
    (This)->lpVtbl -> UnmarshalEnvoy(This,pStream,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoyUnmarshalClass_Proxy( 
    IMarshalEnvoy __RPC_FAR * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ CLSID __RPC_FAR *pClsid);


void __RPC_STUB IMarshalEnvoy_GetEnvoyUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoySizeMax_Proxy( 
    IMarshalEnvoy __RPC_FAR * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ DWORD __RPC_FAR *pcb);


void __RPC_STUB IMarshalEnvoy_GetEnvoySizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_MarshalEnvoy_Proxy( 
    IMarshalEnvoy __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ DWORD dwDestContext);


void __RPC_STUB IMarshalEnvoy_MarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_UnmarshalEnvoy_Proxy( 
    IMarshalEnvoy __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IMarshalEnvoy_UnmarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshalEnvoy_INTERFACE_DEFINED__ */


#ifndef __IWrapperInfo_INTERFACE_DEFINED__
#define __IWrapperInfo_INTERFACE_DEFINED__

/* interface IWrapperInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IWrapperInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5052f924-7ab8-11d3-b93f-00c04f990176")
    IWrapperInfo : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE SetMapping( 
            void __RPC_FAR *pv) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE GetMapping( void) = 0;
        
        virtual IObjContext __RPC_FAR *STDMETHODCALLTYPE GetServerObjectContext( void) = 0;
        
        virtual IUnknown __RPC_FAR *STDMETHODCALLTYPE GetServerObject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapperInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWrapperInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWrapperInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWrapperInfo __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *SetMapping )( 
            IWrapperInfo __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetMapping )( 
            IWrapperInfo __RPC_FAR * This);
        
        IObjContext __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetServerObjectContext )( 
            IWrapperInfo __RPC_FAR * This);
        
        IUnknown __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetServerObject )( 
            IWrapperInfo __RPC_FAR * This);
        
        END_INTERFACE
    } IWrapperInfoVtbl;

    interface IWrapperInfo
    {
        CONST_VTBL struct IWrapperInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapperInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapperInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapperInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapperInfo_SetMapping(This,pv)	\
    (This)->lpVtbl -> SetMapping(This,pv)

#define IWrapperInfo_GetMapping(This)	\
    (This)->lpVtbl -> GetMapping(This)

#define IWrapperInfo_GetServerObjectContext(This)	\
    (This)->lpVtbl -> GetServerObjectContext(This)

#define IWrapperInfo_GetServerObject(This)	\
    (This)->lpVtbl -> GetServerObject(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWrapperInfo_SetMapping_Proxy( 
    IWrapperInfo __RPC_FAR * This,
    void __RPC_FAR *pv);


void __RPC_STUB IWrapperInfo_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IWrapperInfo_GetMapping_Proxy( 
    IWrapperInfo __RPC_FAR * This);


void __RPC_STUB IWrapperInfo_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IObjContext __RPC_FAR *STDMETHODCALLTYPE IWrapperInfo_GetServerObjectContext_Proxy( 
    IWrapperInfo __RPC_FAR * This);


void __RPC_STUB IWrapperInfo_GetServerObjectContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IUnknown __RPC_FAR *STDMETHODCALLTYPE IWrapperInfo_GetServerObject_Proxy( 
    IWrapperInfo __RPC_FAR * This);


void __RPC_STUB IWrapperInfo_GetServerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapperInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0092 */
/* [local] */ 


typedef DWORD APARTMENTID;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0092_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0092_v0_0_s_ifspec;

#ifndef __IComThreadingInfo_INTERFACE_DEFINED__
#define __IComThreadingInfo_INTERFACE_DEFINED__

/* interface IComThreadingInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComThreadingInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001ce-0000-0000-C000-000000000046")
    IComThreadingInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentApartmentType( 
            /* [out] */ APTTYPE __RPC_FAR *pAptType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadType( 
            /* [out] */ THDTYPE __RPC_FAR *pThreadType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLogicalThreadId( 
            /* [out] */ GUID __RPC_FAR *pguidLogicalThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentLogicalThreadId( 
            /* [in] */ REFGUID rguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComThreadingInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComThreadingInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComThreadingInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComThreadingInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentApartmentType )( 
            IComThreadingInfo __RPC_FAR * This,
            /* [out] */ APTTYPE __RPC_FAR *pAptType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentThreadType )( 
            IComThreadingInfo __RPC_FAR * This,
            /* [out] */ THDTYPE __RPC_FAR *pThreadType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentLogicalThreadId )( 
            IComThreadingInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidLogicalThreadId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentLogicalThreadId )( 
            IComThreadingInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid);
        
        END_INTERFACE
    } IComThreadingInfoVtbl;

    interface IComThreadingInfo
    {
        CONST_VTBL struct IComThreadingInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComThreadingInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComThreadingInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComThreadingInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComThreadingInfo_GetCurrentApartmentType(This,pAptType)	\
    (This)->lpVtbl -> GetCurrentApartmentType(This,pAptType)

#define IComThreadingInfo_GetCurrentThreadType(This,pThreadType)	\
    (This)->lpVtbl -> GetCurrentThreadType(This,pThreadType)

#define IComThreadingInfo_GetCurrentLogicalThreadId(This,pguidLogicalThreadId)	\
    (This)->lpVtbl -> GetCurrentLogicalThreadId(This,pguidLogicalThreadId)

#define IComThreadingInfo_SetCurrentLogicalThreadId(This,rguid)	\
    (This)->lpVtbl -> SetCurrentLogicalThreadId(This,rguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentApartmentType_Proxy( 
    IComThreadingInfo __RPC_FAR * This,
    /* [out] */ APTTYPE __RPC_FAR *pAptType);


void __RPC_STUB IComThreadingInfo_GetCurrentApartmentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentThreadType_Proxy( 
    IComThreadingInfo __RPC_FAR * This,
    /* [out] */ THDTYPE __RPC_FAR *pThreadType);


void __RPC_STUB IComThreadingInfo_GetCurrentThreadType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentLogicalThreadId_Proxy( 
    IComThreadingInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidLogicalThreadId);


void __RPC_STUB IComThreadingInfo_GetCurrentLogicalThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComThreadingInfo_SetCurrentLogicalThreadId_Proxy( 
    IComThreadingInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB IComThreadingInfo_SetCurrentLogicalThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComThreadingInfo_INTERFACE_DEFINED__ */


#ifndef __IComDispatchInfo_INTERFACE_DEFINED__
#define __IComDispatchInfo_INTERFACE_DEFINED__

/* interface IComDispatchInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComDispatchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d9-0000-0000-C000-000000000046")
    IComDispatchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableComInits( 
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableComInits( 
            /* [in] */ void __RPC_FAR *pvCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComDispatchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComDispatchInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComDispatchInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComDispatchInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableComInits )( 
            IComDispatchInfo __RPC_FAR * This,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableComInits )( 
            IComDispatchInfo __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pvCookie);
        
        END_INTERFACE
    } IComDispatchInfoVtbl;

    interface IComDispatchInfo
    {
        CONST_VTBL struct IComDispatchInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComDispatchInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComDispatchInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComDispatchInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComDispatchInfo_EnableComInits(This,ppvCookie)	\
    (This)->lpVtbl -> EnableComInits(This,ppvCookie)

#define IComDispatchInfo_DisableComInits(This,pvCookie)	\
    (This)->lpVtbl -> DisableComInits(This,pvCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComDispatchInfo_EnableComInits_Proxy( 
    IComDispatchInfo __RPC_FAR * This,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvCookie);


void __RPC_STUB IComDispatchInfo_EnableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComDispatchInfo_DisableComInits_Proxy( 
    IComDispatchInfo __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pvCookie);


void __RPC_STUB IComDispatchInfo_DisableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComDispatchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0094 */
/* [local] */ 

typedef DWORD HActivator;

STDAPI CoCreateObjectInContext(IUnknown *pUnk, IObjContext *pObjectCtx, REFIID riid, void **ppv);
STDAPI CoGetApartmentID(APTTYPE dAptType, HActivator* pAptID);
STDAPI CoDeactivateObject(IUnknown *pUnk, IUnknown **ppCookie);
STDAPI CoReactivateObject(IUnknown *pUnk, IUnknown *pCookie);
#define MSHLFLAGS_NO_IEC      0x8  // don't use IExternalConnextion
#define MSHLFLAGS_NO_IMARSHAL 0x10 // don't use IMarshal
#define CONTEXTFLAGS_FROZEN         0x01 // Frozen context
#define CONTEXTFLAGS_ALLOWUNAUTH    0x02 // Allow unauthenticated calls
#define CONTEXTFLAGS_ENVOYCONTEXT   0x04 // Envoy context
#define CONTEXTFLAGS_DEFAULTCONTEXT 0x08 // Default context
#define CONTEXTFLAGS_STATICCONTEXT  0x10 // Static context
#define CONTEXTFLAGS_INPROPTABLE    0x20 // Is in property table
#define CONTEXTFLAGS_INDESTRUCTOR   0x40 // Is in destructor
#define CONTEXTFLAGS_URTPROPPRESENT 0x80 // CLR property added


extern RPC_IF_HANDLE __MIDL_itf_contxt_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0094_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\codeproc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:13 2003
 */
/* Compiler settings for codeproc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __codeproc_h__
#define __codeproc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICodeProcess_FWD_DEFINED__
#define __ICodeProcess_FWD_DEFINED__
typedef interface ICodeProcess ICodeProcess;
#endif 	/* __ICodeProcess_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_codeproc_0000 */
/* [local] */ 

extern const GUID  __declspec(selectany) CLSID_CodeProcessor = { 0xdc5da001, 0x7cd4, 0x11d2, { 0x8e, 0xd9, 0xd8, 0xc8, 0x57, 0xf9, 0x8f, 0xe3 } };
extern const GUID  __declspec(selectany) IID_ICodeProcess = { 0x3196269D, 0x7B67, 0x11d2, { 0x87, 0x11, 0x00, 0xC0, 0x4F, 0x79, 0xED, 0x0D } };
#ifndef _LPCODEPROCESS_DEFINED
#define _LPCODEPROCESS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_codeproc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_codeproc_0000_v0_0_s_ifspec;

#ifndef __ICodeProcess_INTERFACE_DEFINED__
#define __ICodeProcess_INTERFACE_DEFINED__

/* interface ICodeProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICodeProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3196269D-7B67-11d2-8711-00C04F79ED0D")
    ICodeProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CodeUse( 
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IInternetBindInfo *pIBind,
            /* [in] */ IInternetProtocolSink *pSink,
            /* [in] */ IInternetProtocol *pClient,
            /* [in] */ LPCWSTR lpCacheName,
            /* [in] */ LPCWSTR lpRawURL,
            /* [in] */ LPCWSTR lpCodeBase,
            /* [in] */ BOOL fObjectTag,
            /* [in] */ DWORD dwContextFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadComplete( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR wzResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *CodeUse )( 
            ICodeProcess * This,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IInternetBindInfo *pIBind,
            /* [in] */ IInternetProtocolSink *pSink,
            /* [in] */ IInternetProtocol *pClient,
            /* [in] */ LPCWSTR lpCacheName,
            /* [in] */ LPCWSTR lpRawURL,
            /* [in] */ LPCWSTR lpCodeBase,
            /* [in] */ BOOL fObjectTag,
            /* [in] */ DWORD dwContextFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *LoadComplete )( 
            ICodeProcess * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR wzResult);
        
        END_INTERFACE
    } ICodeProcessVtbl;

    interface ICodeProcess
    {
        CONST_VTBL struct ICodeProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeProcess_CodeUse(This,pBSC,pBC,pIBind,pSink,pClient,lpCacheName,lpRawURL,lpCodeBase,fObjectTag,dwContextFlags,dwReserved)	\
    (This)->lpVtbl -> CodeUse(This,pBSC,pBC,pIBind,pSink,pClient,lpCacheName,lpRawURL,lpCodeBase,fObjectTag,dwContextFlags,dwReserved)

#define ICodeProcess_LoadComplete(This,hrResult,dwError,wzResult)	\
    (This)->lpVtbl -> LoadComplete(This,hrResult,dwError,wzResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeProcess_CodeUse_Proxy( 
    ICodeProcess * This,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IInternetBindInfo *pIBind,
    /* [in] */ IInternetProtocolSink *pSink,
    /* [in] */ IInternetProtocol *pClient,
    /* [in] */ LPCWSTR lpCacheName,
    /* [in] */ LPCWSTR lpRawURL,
    /* [in] */ LPCWSTR lpCodeBase,
    /* [in] */ BOOL fObjectTag,
    /* [in] */ DWORD dwContextFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB ICodeProcess_CodeUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeProcess_LoadComplete_Proxy( 
    ICodeProcess * This,
    /* [in] */ HRESULT hrResult,
    /* [in] */ DWORD dwError,
    /* [in] */ LPCWSTR wzResult);


void __RPC_STUB ICodeProcess_LoadComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeProcess_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_codeproc_0208 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_codeproc_0208_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_codeproc_0208_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 *****************************************************************************/


#ifndef _COR_H_
#define _COR_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.    
//*****************************************************************************

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY LIBID_ComPlusRuntime = 
{ 0xbed7f4ea, 0x1a96, 0x11d2, { 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ExportedFromComPlus = 
{ 0x90883f05, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {0F21F359-AB84-41e8-9A78-36D110E6D2F9}
extern const GUID DECLSPEC_SELECT_ANY GUID_ManagedName = 
{ 0xf21f359, 0xab84, 0x41e8, { 0x9a, 0x78, 0x36, 0xd1, 0x10, 0xe6, 0xd2, 0xf9 } };

// {54FC8F55-38DE-4703-9C4E-250351302B1C}
extern const GUID DECLSPEC_SELECT_ANY GUID_Function2Getter = 
{ 0x54fc8f55, 0x38de, 0x4703, { 0x9c, 0x4e, 0x25, 0x3, 0x51, 0x30, 0x2b, 0x1c } };

// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind  
//  to CLSID_MetaDataDispenser. 
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserRuntime = 
{ 0x1ec2de53, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// {CD2BC5C9-F452-4326-B714-F9C539D4DA58}
extern const GUID DECLSPEC_SELECT_ANY GUID_DispIdOverride =
{ 0xcd2bc5c9, 0xf452, 0x4326, { 0xb7, 0x14, 0xf9, 0xc5, 0x39, 0xd4, 0xda, 0x58 } };

// {B64784EB-D8D4-4d9b-9ACD-0E30806426F7}
extern const GUID DECLSPEC_SELECT_ANY GUID_ForceIEnumerable =
{ 0xb64784eb, 0xd8d4, 0x4d9b, { 0x9a, 0xcd, 0x0e, 0x30, 0x80, 0x64, 0x26, 0xf7 } };

// {2941FF83-88D8-4F73-B6A9-BDF8712D000D}
extern const GUID DECLSPEC_SELECT_ANY GUID_PropGetCA =
{ 0x2941ff83, 0x88d8, 0x4f73, { 0xb6, 0xa9, 0xbd, 0xf8, 0x71, 0x2d, 0x00, 0x0d } };

// {29533527-3683-4364-ABC0-DB1ADD822FA2}
extern const GUID DECLSPEC_SELECT_ANY GUID_PropPutCA =
{ 0x29533527, 0x3683, 0x4364, { 0xab, 0xc0, 0xdb, 0x1a, 0xdd, 0x82, 0x2f, 0xa2 } };


// CLSID_CorMetaDataRuntime: {005023CA-72B1-11D3-9FC4-00C04F79A0A3}
//  For Common Language Runtime Meta Data, managed program meta data.  
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime = 
{ 0x005023ca, 0x72b1, 0x11d3, { 0x9f, 0xc4, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {90883F06-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ImportedToComPlus = 
{ 0x90883f06, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
extern const char DECLSPEC_SELECT_ANY szGUID_ImportedToComPlus[] = "{90883F06-3D28-11D2-8F17-00A0C9A6186D}";
extern const WCHAR DECLSPEC_SELECT_ANY wzGUID_ImportedToComPlus[] = L"{90883F06-3D28-11D2-8F17-00A0C9A6186D}";

// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataCheckDuplicatesFor =
{ 0x30fe7be8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRefToDefCheck =
{ 0xde3856f8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataNotificationForTokenMovement = 
{ 0xe5d71a4c, 0xd7da, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataSetUpdate = 
{ 0x2eee315c, 0xd7db, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over 
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
extern const GUID DECLSPEC_SELECT_ANY MetaDataImportOption = 
{ 0x79700f36, 0x4aac, 0x11d3, { 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1 } };


// Use this guid in the SetOption if compiler wants to have MetaData API to take reader/writer lock
// CorThreadSafetyOptions.
// {F7559806-F266-42ea-8C63-0ADB45E8B234}
extern const GUID DECLSPEC_SELECT_ANY MetaDataThreadSafetyOptions = 
{ 0xf7559806, 0xf266, 0x42ea, { 0x8c, 0x63, 0xa, 0xdb, 0x45, 0xe8, 0xb2, 0x34 } };


// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY MetaDataErrorIfEmitOutOfOrder = 
{ 0x1547872d, 0xdc03, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataGenerateTCEAdapters = 
{ 0xdcc9de90, 0x4151, 0x11d3, { 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a } };


// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataTypeLibImportNamespace = 
{ 0xf17ff889, 0x5a63, 0x11d3, { 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

// Use this guid in the SetOption to specify the behavior of UnmarkAll. See CorLinkerOptions. 
// {47E099B6-AE7C-4797-8317-B48AA645B8F9}
extern const GUID DECLSPEC_SELECT_ANY MetaDataLinkerOptions = 
{ 0x47e099b6, 0xae7c, 0x4797, {0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9 } };

// Use this guid in the SetOption to specify the runtime version stored in the CLR metadata.
// {47E099B7-AE7C-4797-8317-B48AA645B8F9}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRuntimeVersion = 
{ 0x47e099b7, 0xae7c, 0x4797, {0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9 } };


interface IMetaDataImport;
interface IMetaDataAssemblyEmit;
interface IMetaDataAssemblyImport;
interface IMetaDataEmit;
interface ICeeGen;


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************

BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine);                  // -> Command Line

STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName);
STDAPI_(VOID) _CorImageUnloading(PVOID ImageBase);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  
STDAPI_(void)   CoEEShutDownCOM(void);

//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1,          // Initialization mode for loading DLL. 
    COINITEE_MAIN           = 0x2           // Initialize prior to entering the main routine 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.
#ifndef _WINDOWS_UDPATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI          CoInitializeCor(DWORD fFlags);
STDAPI_(void)   CoUninitializeCor(void);

typedef void (* TDestructorCallback)(EXCEPTION_RECORD*);
STDAPI_(void) AddDestructorCallback(int code, TDestructorCallback callback);


#include <pshpack1.h>

#include <poppack.h>

//
//*****************************************************************************
//*****************************************************************************

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//  This is the "Master Dispenser", always guaranteed to be the most recent
//  dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//  Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//  to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {39EE28B3-0181-4d48-B53C-2FFAFFD5FEC1}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x39ee28b3, 0x181, 0x4d48, { 0xb5, 0x3c, 0x2f, 0xfa, 0xff, 0xd5, 0xfe, 0xc1 } };

interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef  INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
    STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef  INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
    STDMETHOD(Map)(mdToken tkImp, mdToken tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(DefineScope)(                 // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------

// {BA3FEE4C-ECB9-4e41-83B7-183FA41CD859}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmit =
{ 0xba3fee4c, 0xecb9, 0x4e41, { 0x83, 0xb7, 0x18, 0x3f, 0xa4, 0x1c, 0xd8, 0x59 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName) PURE;           // [IN] If not NULL, the GUID to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(DefineNestedType)(            // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.

    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here     

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body - MethodDef or MethodRef
        mdToken     tkDecl) PURE;           // [IN] Method declaration - MethodDef or MethodRef

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(        // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in import scope.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkParent,               // [IN] Classref or classdef in emit scope.    
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout) (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(DeleteClassLayout) (
        mdTypeDef   td) PURE;               // [IN] typedef whose layout is to be deleted.

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DeleteFieldMarshal) (
        mdToken     tk) PURE;               // [IN] given a fieldDef or paramDef token

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetRVA)(                      // S_OK or error.   
        mdMethodDef md,                     // [IN] Method for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // @FUTURE:  This should go away once everyone starts using SetMemberRefProps.
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DeleteToken)(                 // Return code.
        mdToken     tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] Impl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]) PURE;  // [IN] Implemented interfaces.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(DeletePinvokeMap)(            // Return code.
        mdToken     tk) PURE;               // [IN] FieldDef or MethodDef.

    // New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomAttribute (TypeRef/TypeDef).
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute,          // [IN] The custom value data length.
        mdCustomAttribute *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(     // Return code.
        mdCustomAttribute pcv,                  // [IN] The custom value token whose value to replace.
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefineProperty)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods.

    STDMETHOD(SetParamProps)(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized Custom Attributes for security.
    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;     // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.


};      // IMetaDataEmit


//-------------------------------------
//--- IMetaDataImport
//-------------------------------------
// {7DAC8207-D3AE-4c75-9B67-92801A497D44}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImport = 
{ 0x7dac8207, 0xd3ae, 0x4c75, { 0x9b, 0x67, 0x92, 0x80, 0x1a, 0x49, 0x7d, 0x44 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.              

    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // Not Recommended! May be removed!
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomAttribute cv,               // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this property  

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

    STDMETHOD(IsGlobal)(                    // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal) PURE;        // [OUT] Put 1 if global, 0 otherwise.

};      // IMetaDataImport


//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------

// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataFilter = 
{0xd0e80dd1, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------

// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IHostFilter = 
{0xd0e80dd3, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataConverter = 
{ 0xd9debd79, 0x2992, 0x11d3, { 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;

// Notice "cbLocale" field in ASSEMBLYMETADATA actually means size of the
// buffer in wide chars. Use it with caution since the name is misleading.
typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usBuildNumber;          // Build Number.
    USHORT      usRevisionNumber;       // Revision Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
} ASSEMBLYMETADATA;


// {211EF15B-5317-4438-B196-DEC87B887693}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyEmit = 
{ 0x211ef15b, 0x5317, 0x4438, { 0xb1, 0x96, 0xde, 0xc8, 0x7b, 0x88, 0x76, 0x93 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags,     // [IN] Flags.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineExportedType)(          // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags,    // [IN] Flags.
        mdExportedType   *pmdct) PURE;      // [OUT] Returned ExportedType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(SetAssemblyProps)(            // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags) PURE;  // [IN] Flags.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetExportedTypeProps)(        // S_OK or error.
        mdExportedType   ct,                // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {EE62470B-E94B-424e-9B7C-2F00C9249F93}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyImport = 
{ 0xee62470b, 0xe94b, 0x424e, { 0x9b, 0x7c, 0x2f, 0x0, 0xc9, 0x24, 0x9f, 0x93 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetExportedTypeProps)(             // S_OK or error.
        mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExportedTypes)(           // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindExportedTypeByName)(      // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
        mdExportedType   *ptkExportedType) PURE; // [OUT] Put the ExportedType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport

//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataValidate = 
{ 0x4709c9c6, 0x81ff, 0x11d3, { 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenserEx =
{ 0x31bcfce2, 0xdafb, 0x11d2, { 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory Common Language Runtime files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,
    // generate a .reloc for the top 16-bits of a 32 bit number
    srRelocHigh,
    // generate a .reloc for the bottom 16-bits of a 32 bit number
    srRelocLow,
    // generate a .reloc for a 32 bit number
    srRelocHighLow,
    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,
    // legal enums which include the Ptr flag
    srRelocAbsolutePtr = srRelocAbsolute + srRelocPtr,
    srRelocHighLowPtr = srRelocHighLow + srRelocPtr,
    srRelocRelativePtr = srRelocRelative + srRelocPtr,


/*
    // these are for compatibility and should not be used by new code

    // address should be added to the .reloc section
    srRelocNone = srRelocHighLow,
    // address should be not go into .reloc section
    srRelocRVA = srRelocAbsolute
*/
} CeeSectionRelocType;

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICeeGen = 
{ 0x7ed1bdff, 0x8e36, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
        LPWSTR lpString,                    // [IN] String to emit  
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
        LPWSTR *lpString) PURE;             // [OUT] Returned string    

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorModule = 
{ 0x2629f8e1, 0x95e5, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (    
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with  
    
    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator  

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// {D8F579AB-402D-4b8e-82D9-5D63B1065C68}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataTables = 
{ 0xd8f579ab, 0x402d, 0x4b8e, { 0x82, 0xd9, 0x5d, 0x63, 0xb1, 0x6, 0x5c, 0x68 } };

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

    STDMETHOD (GetNextString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next string here.

    STDMETHOD (GetNextBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the netxt blob here.

    STDMETHOD (GetNextGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next guid here.

    STDMETHOD (GetNextUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next user string here.

};

#ifdef _DEFINE_META_DATA_META_CONSTANTS
#ifndef _META_DATA_META_CONSTANTS_DEFINED
#define _META_DATA_META_CONSTANTS_DEFINED
const unsigned int iRidMax          = 63;
const unsigned int iCodedToken      = 64;   // base of coded tokens.
const unsigned int iCodedTokenMax   = 95;
const unsigned int iSHORT           = 96;   // fixed types.
const unsigned int iUSHORT          = 97;
const unsigned int iLONG            = 98;
const unsigned int iULONG           = 99;
const unsigned int iBYTE            = 100;
const unsigned int iSTRING          = 101;  // pool types.
const unsigned int iGUID            = 102;
const unsigned int iBLOB            = 103;

inline int IsRidType(ULONG ix) { return ix <= iRidMax; }
inline int IsCodedTokenType(ULONG ix) { return (ix >= iCodedToken) && (ix <= iCodedTokenMax); }
inline int IsRidOrToken(ULONG ix) { return ix <= iCodedTokenMax; }
inline int IsHeapType(ULONG ix) { return ix >= iSTRING; }
inline int IsFixedType(ULONG ix) { return (ix < iSTRING) && (ix > iCodedTokenMax); }
#endif
#endif

//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
//**********************************************************************

//**********************************************************************
//
// Predefined CustomAttribute and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone     = 1,    // none of the keywords are specified   
    nltAnsi     = 2,    // ansi keyword specified   
    nltUnicode  = 3,    // unicode keyword specified    
    nltAuto     = 4,    // auto keyword specified   
    nltOle      = 5,    // ole keyword specified    
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
//@future: BIGENDIAN work here.
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;  

    // 1 byte data is handled in CorSigUncompressData   
    //  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = 0;    
        ((BYTE *) &res)[1] = *pData++ & 0x3f;   
        ((BYTE *) &res)[0] = *pData++;  
    }   
    else // 110? ???? 
    {   
        ((BYTE *) &res)[3] = *pData++ & 0x1f;   
        ((BYTE *) &res)[2] = *pData++;  
        ((BYTE *) &res)[1] = *pData++;  
        ((BYTE *) &res)[0] = *pData++;  
    }   
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}


inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   
    ULONG       cb = (ULONG) -1;    
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        *pDataOut = *pBytes;    
        cb = 1; 
    }   
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        *pDataOut = ((*pBytes & 0x3f) << 8 | *(pBytes+1));  
        cb = 2; 
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        *pDataOut = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));  
        cb = 4; 
    }   
    return cb;  

}

const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}


inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == -1) return cb;    
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}

inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen);  
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE(iLen >> 16);  
        *(pBytes+2) = BYTE(iLen >> 8);  
        *(pBytes+3) = BYTE(iLen);  
        return 4;   
    }   
    return (ULONG) -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return (ULONG) -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return (ULONG) -1;  
    }   
    iData = iData << 1 | isSigned;  
    return CorSigCompressData(iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

// Compress a pointer (used for internal element types only, never for persisted
// signatures).
inline ULONG CorSigCompressPointer(     // return number of bytes of that compressed data occupied
    void        *pvPointer,             // [IN] given uncompressed data 
    void        *pData)                 // [OUT] buffer where iLen will be compressed and stored.   
{   
    *((void**)pData) = pvPointer;
    return sizeof(void*);
}

// Uncompress a pointer (see above for comments).
inline ULONG CorSigUncompressPointer(   // return number of bytes of that compressed data occupied
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    void            **ppvPointer)       // [OUT] the expanded *pData    
{   
    *ppvPointer = *(void**)pData;
    return sizeof(void*);
}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corcompile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
*                                                                             *
* CorCompile.h -    EE / Compiler interface                                   *
*                                                                             *
*               Version 1.0                                                   *
*******************************************************************************
*                                                                             *
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY      *
*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE        *
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR      *
*  PURPOSE.                                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef _COR_COMPILE_H_
#define _COR_COMPILE_H_

#include <cor.h>
#include <corzap.h>
#include <corinfo.h>

enum CorCompileTokenTable
{
    CORCOMPILE_HANDLE_TABLE,
    CORCOMPILE_CLASS_CONSTRUCTOR_TABLE,
    CORCOMPILE_CLASS_LOAD_TABLE,
    CORCOMPILE_FUNCTION_POINTER_TABLE,
    CORCOMPILE_STATIC_FIELD_ADDRESS_TABLE,
    CORCOMPILE_INTERFACE_TABLE_OFFSET_TABLE,
    CORCOMPILE_CLASS_DOMAIN_ID_TABLE,
    CORCOMPILE_ENTRY_POINT_TABLE,
    CORCOMPILE_SYNC_LOCK_TABLE,
    CORCOMPILE_PINVOKE_TARGET_TABLE,
    CORCOMPILE_INDIRECT_PINVOKE_TARGET_TABLE,
    CORCOMPILE_PROFILING_HANDLE_TABLE,
    CORCOMPILE_VARARGS_TABLE,
    
    CORCOMPILE_TABLE_COUNT
};

enum CorCompileBuild
{
    CORCOMPILE_BUILD_CHECKED,
    CORCOMPILE_BUILD_FREE
};

enum CorCompileCodegen
{
    CORCOMPILE_CODEGEN_PROFILING        = 0x0001,
    CORCOMPILE_CODEGEN_DEBUGGING        = 0x0002,
    CORCOMPILE_CODEGEN_OPT_DEBUGGING    = 0x0004,
    CORCOMPILE_CODEGEN_SHAREABLE        = 0x0008
};

enum
{
    // Currently 43
    CORCOMPILE_MAX_ZAP_STRING_SIZE 
    // ZAPxxx- W/Nxxx.yyy-  8/I/A   C/F     DOPS    -#.#                -XXXXXXXX   \0
    = (7       + 9          + 1     + 1     + 4     + 1 + 5 + 1 + 5     + 1 + 8     + 1) 
};

enum
{
    CORCOMPILE_LDO_MAGIC                = 0xa1d0f11e
};

struct CORCOMPILE_HEADER
{
    IMAGE_DATA_DIRECTORY    EEInfoTable;
    IMAGE_DATA_DIRECTORY    HelperTable;
    IMAGE_DATA_DIRECTORY    DelayLoadInfo;
    IMAGE_DATA_DIRECTORY    ImportTable;
    IMAGE_DATA_DIRECTORY    VersionInfo;
    IMAGE_DATA_DIRECTORY    DebugMap;
    IMAGE_DATA_DIRECTORY    ModuleImage;
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
};

struct CORCOMPILE_LDO_HEADER
{
    ULONG                   Magic;
    ULONG                   Version; 
    GUID                    MVID;
    mdToken                 Tokens[0];
};

struct CORCOMPILE_IMPORT_TABLE_ENTRY
{
    USHORT                  wAssemblyRid;
    USHORT                  wModuleRid;
    IMAGE_DATA_DIRECTORY    Imports;
};

struct CORCOMPILE_EE_INFO_TABLE
{
    DWORD                   threadTlsIndex;
    const void              *inlinedCallFrameVptr;
    LONG                    *addrOfCaptureThreadGlobal;
    CORINFO_MODULE_HANDLE   module;
    DWORD                   rvaStaticTlsIndex;
};

struct CORCOMPILE_DEBUG_ENTRY
{
    IMAGE_DATA_DIRECTORY    boundaries;
    IMAGE_DATA_DIRECTORY    vars;
};

struct CORCOMPILE_CODE_MANAGER_ENTRY
{
    IMAGE_DATA_DIRECTORY    Code;
    IMAGE_DATA_DIRECTORY    Table;
    // add code mgr ID here eventually 
};

struct CORCOMPILE_METHOD_HEADER
{
    BYTE                        *gcInfo;
    COR_ILMETHOD_SECT_EH_FAT    *exceptionInfo;
    void                        *methodDesc;
    BYTE                        *fixupList;
};

// {DB15CD8C-1378-4963-9DF3-14D97E95D1A1}
extern GUID __declspec(selectany) STRUCT_CONTAINS_HASH = { 0xdb15cd8c, 0x1378, 0x4963, { 0x9d, 0xf3, 0x14, 0xd9, 0x7e, 0x95, 0xd1, 0xa1 } };
static const DWORD MAX_SNHASH_SIZE = 128;
struct CORCOMPILE_VERSION_INFO
{
    // Metadata MVID of source assembly 
    GUID                    mvid;

    // OS
    WORD                    wOSPlatformID;
    WORD                    wOSMajorVersion;
    WORD                    wOSMinorVersion;

    // Processor
    WORD                    wMachine;

    // EE Version
    WORD                    wVersionMajor;
    WORD                    wVersionMinor;
    WORD                    wVersionBuildNumber;
    WORD                    wVersionPrivateBuildNumber;

    // Codegen flags
    WORD                    wCodegenFlags;
    WORD                    wBuild;
    DWORD                   dwSpecificProcessor;

    // List of dependencies
    IMAGE_DATA_DIRECTORY    Dependencies;

    // Hash signature for the assembly
    WORD                    wcbSNHash;
    BYTE                    rgbSNHash[MAX_SNHASH_SIZE];
};

struct CORCOMPILE_DEPENDENCY
{
    // Ref
    mdAssemblyRef           dwAssemblyRef;

    // Metadata MVID bound to
    GUID                    mvid;

    // Strong name hash signature for the assembly
    WORD                    wcbSNHash;
    BYTE                    rgbSNHash[MAX_SNHASH_SIZE];
};

struct CORCOMPILE_DOMAIN_TRANSITION_FRAME
{
    // Opaque structure allowing transition into compilation domain
    BYTE data[32];
};

/*********************************************************************************
 * ICorCompilePreloader is used to query preloaded EE data structures
 *********************************************************************************/

class ICorCompilePreloader
{
 public:
    //
    // When compiling & preloading at the same time, these methods can
    // be used to avoid making entries in the various info tables.
    // 
    // Map methods are available as soon as the preloader is created
    // (which will cause it to allocate its data.) Note that returned
    // results are offsets into the preload data store.
    //
    // 0 will be returned if a value has not been preloaded into
    // the module the preloader was created from./
    // Note that it still may be in other preloaded modules - make
    // sure you ask the right preloader.  
    //

    virtual SIZE_T __stdcall MapMethodEntryPoint(
            void *methodEntryPoint
            ) = 0;                                          

    virtual SIZE_T __stdcall MapModuleHandle(
            CORINFO_MODULE_HANDLE handle
            ) = 0;

    virtual SIZE_T __stdcall MapClassHandle(
            CORINFO_CLASS_HANDLE handle
            ) = 0;

    virtual SIZE_T __stdcall MapMethodHandle(
            CORINFO_METHOD_HANDLE handle
            ) = 0;

    virtual SIZE_T __stdcall MapFieldHandle(
            CORINFO_FIELD_HANDLE handle
            ) = 0;

    virtual SIZE_T __stdcall MapAddressOfPInvokeFixup(
            void *addressOfPInvokeFixup
            ) = 0;

    virtual SIZE_T __stdcall MapFieldAddress(
            void *staticFieldAddress
            ) = 0;

    virtual SIZE_T __stdcall MapVarArgsHandle(
            CORINFO_VARARGS_HANDLE handle
            ) = 0;

    //
    // Call Link when you want all the fixups 
    // to be applied.  You may call this e.g. after
    // compiling all the code for the module.
    //

    virtual HRESULT Link(DWORD *pRidToCodeRVAMap) = 0;

    //
    // Release frees the preloader
    //

    virtual ULONG Release() = 0;
};

/*********************************************************************************
 * A compiler must supply an instance of ICorCompileInfo in order to do class
 * preloading.
 *********************************************************************************/

enum CorCompileReferenceDest
{
    CORCOMPILE_REFERENCE_IMAGE,
    CORCOMPILE_REFERENCE_FUNCTION,
    CORCOMPILE_REFERENCE_STORE,
    CORCOMPILE_REFERENCE_METADATA,
};

enum CorCompileFixup
{
    CORCOMPILE_FIXUP_VA,
    CORCOMPILE_FIXUP_RVA,
    CORCOMPILE_FIXUP_RELATIVE,
};

enum Description
{
    CORCOMPILE_DESCRIPTION_MODULE,
    CORCOMPILE_DESCRIPTION_METHOD_TABLE,
    CORCOMPILE_DESCRIPTION_CLASS,
    CORCOMPILE_DESCRIPTION_METHOD_DESC,
    CORCOMPILE_DESCRIPTION_FIELD_DESC,
    CORCOMPILE_DESCRIPTION_FIXUPS,
    CORCOMPILE_DESCRIPTION_DEBUG,
    CORCOMPILE_DESCRIPTION_OTHER,

    CORCOMPILE_DESCRIPTION_COUNT
};


class ICorCompileDataStore
{
 public:
    // Called when total size is known - should allocate memory 
    // & return both pointer & base address in image.
    // (Note that addresses can be remembered & fixed up later if
    //  bases are not yet known.)
    virtual HRESULT __stdcall Allocate(ULONG size, 
                                       ULONG *sizesByDescription,
                                       void **baseMemory) = 0;

    // Called when data contains an internal reference.  
    virtual HRESULT __stdcall AddFixup(ULONG offset,
                                       CorCompileReferenceDest dest,
                                       CorCompileFixup type) = 0;
    
    // Called when data contains an internal reference.  
    virtual HRESULT __stdcall AddTokenFixup(ULONG offset,
                                            mdToken tokenType,
                                            CORINFO_MODULE_HANDLE module) = 0;
    
    // Called when data contains a function address.  The data store
    // can return a fixed compiled code address if it is compiling
    // code for the module. 
    virtual HRESULT __stdcall GetFunctionAddress(CORINFO_METHOD_HANDLE method,
                                                 void **pResult) = 0;

    // Called so the data store can keep track of how much space is attributed
    // to each token.  By default all allocated space is unattributed - this adjusts
    // that state. (Note that it may be called with a negative value sometimes
    // as the space is reattributed.)
    virtual HRESULT __stdcall AdjustAttribution(mdToken token, LONG adjustment) = 0;

    // Reports an error during preloading.  Return the error code to propagate, 
    // or S_OK to ignore the error
    virtual HRESULT __stdcall Error(mdToken token, HRESULT hr, LPCWSTR description) = 0;
};


/*********************************************************************************
 * ICorAssemblyBinder is the interface for a compiler
 *********************************************************************************/

class ICorCompilationDomain
{
 public:

    // Sets the application context for fusion 
    // to use when binding.
    virtual HRESULT __stdcall SetApplicationContext(
            IApplicationContext     *pContext
            ) = 0;

    // Sets the application context for fusion 
    // to use when binding, using a shell exe file path
    virtual HRESULT __stdcall SetContextInfo(
            LPCWSTR                 path,
            BOOL                    isExe
            ) = 0;

    // Sets explicit bindings to use instead of fusion.
    // Any bindings not listed will fail.
    virtual HRESULT __stdcall SetExplicitBindings(
            ICorZapBinding          **ppBindings,
            DWORD                   cBindings
            ) = 0;

    // Sets emitter to use when generating tokens for
    // the dependency list.  If this is not called,
    // dependencies won't be computed.
    virtual HRESULT __stdcall SetDependencyEmitter(
            IMetaDataAssemblyEmit   *pEmitter
            ) = 0;

    // Retrieves the dependencies of the code which
    // has been compiled
    virtual HRESULT __stdcall GetDependencies(
            CORCOMPILE_DEPENDENCY   **ppDependencies,
            DWORD                   *cDependencies
            ) = 0;
};

/*********************************************************************************
 * ICorCompileInfo is the interface for a compiler
 *********************************************************************************/

class ICorCompileInfo : public virtual ICorDynamicInfo
{
  public:

    //
    // In a standalone app, call Startup before compiling
    // any code, and Shutdown after finishing.
    //      

    virtual HRESULT __stdcall Startup() = 0;
    virtual HRESULT __stdcall Shutdown() = 0;

    // Creates a new compilation domain
    virtual HRESULT __stdcall CreateDomain(
            ICorCompilationDomain **ppDomain,
            BOOL shared, 
            CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame // Must be on stack 
            ) = 0;

    // Destroys a compilation domain
    virtual HRESULT __stdcall DestroyDomain(
            ICorCompilationDomain *pDomain,
            CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame
            ) = 0;

    // Loads an assembly manifest module into the EE
    // and returns a handle to it.
    virtual HRESULT __stdcall LoadAssembly(
            LPCWSTR                 path,
            CORINFO_ASSEMBLY_HANDLE *pHandle
            ) = 0;

    // Loads an assembly via fusion into the EE
    // and returns a handle to it.
    virtual HRESULT __stdcall LoadAssemblyFusion(
            IAssemblyName           *pFusionName,
            CORINFO_ASSEMBLY_HANDLE *pHandle
            ) = 0;

    // Loads an assembly via ref into the EE
    // and returns a handle to it.
    virtual HRESULT __stdcall LoadAssemblyRef(
            IMetaDataAssemblyImport *pImport,
            mdAssemblyRef           ref,
            CORINFO_ASSEMBLY_HANDLE *pHandle
            ) = 0;

    // Loads an assembly manifest module into the EE
    // and returns a handle to it.
    virtual HRESULT __stdcall LoadAssemblyModule(
            CORINFO_ASSEMBLY_HANDLE assembly,
            mdFile                  file,       
            CORINFO_MODULE_HANDLE   *pHandle
            ) = 0;

    // Checks to see if an up to date zap exists for the
    // assembly
    virtual BOOL __stdcall CheckAssemblyZap(
            CORINFO_ASSEMBLY_HANDLE assembly,
            BOOL                    fForceDebug,
            BOOL                    fForceDebugOpt,
            BOOL                    fForceProfiling
            ) = 0;

    // Check metadata & admin prefs on sharing
    virtual HRESULT __stdcall GetAssemblyShared(
            CORINFO_ASSEMBLY_HANDLE assembly,
            BOOL                    *pShare
            ) = 0;

    // Check metadata & admin prefs on debuggable code
    virtual HRESULT __stdcall GetAssemblyDebuggableCode(
            CORINFO_ASSEMBLY_HANDLE assembly,
            BOOL                    *pDebug,
            BOOL                    *pDebugOpt
            ) = 0;

    // Returns the manifest metadata for an assembly
    virtual IMetaDataAssemblyImport * __stdcall GetAssemblyMetaDataImport(
            CORINFO_ASSEMBLY_HANDLE assembly
            ) = 0;

    // Returns an interface to query the metadata for a loaded module
    virtual IMetaDataImport * __stdcall GetModuleMetaDataImport(
            CORINFO_MODULE_HANDLE   module
            ) = 0;

    // Returns the module of the assembly which contains the manifest,
    // or NULL if the manifest is standalone.
    virtual CORINFO_MODULE_HANDLE __stdcall GetAssemblyModule(
            CORINFO_ASSEMBLY_HANDLE assembly
            ) = 0;

    // Returns the assembly of a loaded module
    virtual CORINFO_ASSEMBLY_HANDLE __stdcall GetModuleAssembly(
            CORINFO_MODULE_HANDLE   module
            ) = 0;

    // Returns the module handle of a loaded module
    virtual BYTE * __stdcall GetModuleBaseAddress(
            CORINFO_MODULE_HANDLE   module
            ) = 0;

    // Returns the module handle of a loaded module
    virtual DWORD  __stdcall GetModuleFileName(
            CORINFO_MODULE_HANDLE   module,
            LPWSTR                  lpwszFilename, 
            DWORD                   nSize
            ) = 0;

    // Get a class def token
    virtual HRESULT __stdcall GetTypeDef(
            CORINFO_CLASS_HANDLE    classHandle,
            mdTypeDef              *token
            ) = 0;
    
    // Get a method def token
    virtual HRESULT __stdcall GetMethodDef(
            CORINFO_METHOD_HANDLE   methodHandle,
            mdMethodDef            *token
            ) = 0;
    
    // Get a field def token
    virtual HRESULT __stdcall GetFieldDef(
            CORINFO_FIELD_HANDLE    fieldHandle,
            mdFieldDef             *token
            ) = 0;

    // Encode a module for the imports table
    virtual HRESULT __stdcall EncodeModule(CORINFO_MODULE_HANDLE fromHandle,
                                           CORINFO_MODULE_HANDLE handle,
                                           DWORD *pAssemblyIndex,
                                           DWORD *pModuleIndex,
                                           IMetaDataAssemblyEmit *pAssemblyEmit) = 0; 

    // Encode a class into the given space. Note cBuffer is in/out
    virtual HRESULT __stdcall EncodeClass(CORINFO_CLASS_HANDLE classHandle,
                                          BYTE *pBuffer,
                                          DWORD *cBuffer) = 0;

    // Encode a method into the given space. Note cBuffer is in/out.
    virtual HRESULT __stdcall EncodeMethod(CORINFO_METHOD_HANDLE handle,
                                           BYTE *pBuffer,
                                           DWORD *cBuffer) = 0;

    // Encode a field into the given space. Note cBuffer is in/out.
    virtual HRESULT __stdcall EncodeField(CORINFO_FIELD_HANDLE handle,
                                          BYTE *pBuffer,
                                          DWORD *cBuffer) = 0;

    // Encode a token defined string into the given space. Note cBuffer is in/out.
    virtual HRESULT __stdcall EncodeString(mdString token,
                                           BYTE *pBuffer,
                                           DWORD *cBuffer) = 0;

    // Encode a token defined sig into the given space. Note cBuffer is in/out.
    virtual HRESULT __stdcall EncodeSig(mdToken sigOrMemberRefToken,
                                        BYTE *pBuffer,
                                        DWORD *cBuffer) = 0;

    // Preload a modules' EE data structures 
    // directly into an executable image
    virtual HRESULT __stdcall PreloadModule(
            CORINFO_MODULE_HANDLE   moduleHandle,
            ICorCompileDataStore    *pData,
            mdToken                 *pSaveOrderArray,
            DWORD                   cSaveOrderArray,                    
            ICorCompilePreloader    **ppPreloader /* [out] */
            ) = 0;

    // Returns the "zap string" used by fusion as a key to store
    // zap modules for the given version info
    // bufffer should be at least CORCOMPILE_MAX_ZAP_STRING_SIZE long
    virtual HRESULT __stdcall GetZapString(
            CORCOMPILE_VERSION_INFO *pVersionInfo,
            LPWSTR                  buffer
            ) = 0;

    // Writes runtime security information into the metadata so that, at load
    // time, it can be verified that the security environment is the same. This
    // is important since prejitting may involve linktime security checks.
    virtual HRESULT __stdcall EmitSecurityInfo(
            CORINFO_ASSEMBLY_HANDLE assembly,
            IMetaDataEmit *pEmitScope
            ) = 0;

    virtual HRESULT __stdcall GetEnvironmentVersionInfo(
            CORCOMPILE_VERSION_INFO     *pInfo                                 
            ) = 0;

    virtual HRESULT __stdcall GetAssemblyStrongNameHash(
            CORINFO_ASSEMBLY_HANDLE hAssembly,
            PBYTE                   pbSNHash,
            DWORD                  *pcbSNHash) = 0;

#ifdef _DEBUG
    virtual HRESULT __stdcall DisableSecurity() = 0;
#endif
};


//
// This entry point is exported in mscoree.dll
//

extern "C" ICorCompileInfo * __stdcall GetCompileInfo();

#endif /* COR_COMPILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corcompress.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorCompress.h
//
// This code was an early prototype for compression of the file format.  It
// is not longer applicable to the current project and has bit rotted.  But
// it is being kept under version control in case we dust it off.
//
//*****************************************************************************
#ifndef __CorCompress_h__
#define __CorCompress_h__

#ifdef COMPRESSION_SUPPORTED

// This stuff reuqires a Compression directory entry in the COM+ header
// which was deleted for the publishing of the final file format for v1.

#define COMIMAGE_FLAGS_COMPRESSIONDATA      0x00000004

typedef enum  CorCompressionType 
{
    COR_COMPRESS_MACROS = 1,        // compress using macro instructions

        // The rest of these are not used at present
    COR_COMPRESS_BY_GUID = 2,       // what follows is a GUID that tell us what to do
    COR_COMPRESS_BY_URL = 3,        // what follows a null terminated UNICODE string
                                    // that tells us what to do.
} CorCompressionType;

// The 'CompressedData' directory entry points to this header
// The only thing we know about the compression data is that it 
// starts with a byte that tells us what the compression type is
// and another one that indicates the version.  All other fields
// depend on the Compression type.  
#define IMAGE_COR20_COMPRESSION_HEADER_SIZE 2

typedef struct IMAGE_COR20_COMPRESSION_HEADER
{
    CorCompressionType      CompressionType : 8;
    unsigned                Version         : 8;
    unsigned                Available       : 16;   // Logically part of data that follows
        // data follows.  
} IMAGE_COR20_COMPRESSION_HEADER;


#endif // COMPRESSION_SUPPORTED



#endif // __CorCompress_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cordebug.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:08 2003
 */
/* Compiler settings for cordebug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cordebug_h__
#define __cordebug_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __CorDebug_FWD_DEFINED__
#define __CorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorDebug CorDebug;
#else
typedef struct CorDebug CorDebug;
#endif /* __cplusplus */

#endif 	/* __CorDebug_FWD_DEFINED__ */


#ifndef __EmbeddedCLRCorDebug_FWD_DEFINED__
#define __EmbeddedCLRCorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#else
typedef struct EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#endif /* __cplusplus */

#endif 	/* __EmbeddedCLRCorDebug_FWD_DEFINED__ */


#ifndef __ICorDebugManagedCallback_FWD_DEFINED__
#define __ICorDebugManagedCallback_FWD_DEFINED__
typedef interface ICorDebugManagedCallback ICorDebugManagedCallback;
#endif 	/* __ICorDebugManagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_FWD_DEFINED__
#define __ICorDebugUnmanagedCallback_FWD_DEFINED__
typedef interface ICorDebugUnmanagedCallback ICorDebugUnmanagedCallback;
#endif 	/* __ICorDebugUnmanagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebug_FWD_DEFINED__
#define __ICorDebug_FWD_DEFINED__
typedef interface ICorDebug ICorDebug;
#endif 	/* __ICorDebug_FWD_DEFINED__ */


#ifndef __ICorDebugController_FWD_DEFINED__
#define __ICorDebugController_FWD_DEFINED__
typedef interface ICorDebugController ICorDebugController;
#endif 	/* __ICorDebugController_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain_FWD_DEFINED__
#define __ICorDebugAppDomain_FWD_DEFINED__
typedef interface ICorDebugAppDomain ICorDebugAppDomain;
#endif 	/* __ICorDebugAppDomain_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly_FWD_DEFINED__
#define __ICorDebugAssembly_FWD_DEFINED__
typedef interface ICorDebugAssembly ICorDebugAssembly;
#endif 	/* __ICorDebugAssembly_FWD_DEFINED__ */


#ifndef __ICorDebugProcess_FWD_DEFINED__
#define __ICorDebugProcess_FWD_DEFINED__
typedef interface ICorDebugProcess ICorDebugProcess;
#endif 	/* __ICorDebugProcess_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpoint_FWD_DEFINED__
#define __ICorDebugBreakpoint_FWD_DEFINED__
typedef interface ICorDebugBreakpoint ICorDebugBreakpoint;
#endif 	/* __ICorDebugBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_FWD_DEFINED__
#define __ICorDebugFunctionBreakpoint_FWD_DEFINED__
typedef interface ICorDebugFunctionBreakpoint ICorDebugFunctionBreakpoint;
#endif 	/* __ICorDebugFunctionBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_FWD_DEFINED__
#define __ICorDebugModuleBreakpoint_FWD_DEFINED__
typedef interface ICorDebugModuleBreakpoint ICorDebugModuleBreakpoint;
#endif 	/* __ICorDebugModuleBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_FWD_DEFINED__
#define __ICorDebugValueBreakpoint_FWD_DEFINED__
typedef interface ICorDebugValueBreakpoint ICorDebugValueBreakpoint;
#endif 	/* __ICorDebugValueBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugStepper_FWD_DEFINED__
#define __ICorDebugStepper_FWD_DEFINED__
typedef interface ICorDebugStepper ICorDebugStepper;
#endif 	/* __ICorDebugStepper_FWD_DEFINED__ */


#ifndef __ICorDebugRegisterSet_FWD_DEFINED__
#define __ICorDebugRegisterSet_FWD_DEFINED__
typedef interface ICorDebugRegisterSet ICorDebugRegisterSet;
#endif 	/* __ICorDebugRegisterSet_FWD_DEFINED__ */


#ifndef __ICorDebugThread_FWD_DEFINED__
#define __ICorDebugThread_FWD_DEFINED__
typedef interface ICorDebugThread ICorDebugThread;
#endif 	/* __ICorDebugThread_FWD_DEFINED__ */


#ifndef __ICorDebugChain_FWD_DEFINED__
#define __ICorDebugChain_FWD_DEFINED__
typedef interface ICorDebugChain ICorDebugChain;
#endif 	/* __ICorDebugChain_FWD_DEFINED__ */


#ifndef __ICorDebugFrame_FWD_DEFINED__
#define __ICorDebugFrame_FWD_DEFINED__
typedef interface ICorDebugFrame ICorDebugFrame;
#endif 	/* __ICorDebugFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame_FWD_DEFINED__
#define __ICorDebugILFrame_FWD_DEFINED__
typedef interface ICorDebugILFrame ICorDebugILFrame;
#endif 	/* __ICorDebugILFrame_FWD_DEFINED__ */


#ifndef __ICorDebugNativeFrame_FWD_DEFINED__
#define __ICorDebugNativeFrame_FWD_DEFINED__
typedef interface ICorDebugNativeFrame ICorDebugNativeFrame;
#endif 	/* __ICorDebugNativeFrame_FWD_DEFINED__ */


#ifndef __ICorDebugModule_FWD_DEFINED__
#define __ICorDebugModule_FWD_DEFINED__
typedef interface ICorDebugModule ICorDebugModule;
#endif 	/* __ICorDebugModule_FWD_DEFINED__ */


#ifndef __ICorDebugFunction_FWD_DEFINED__
#define __ICorDebugFunction_FWD_DEFINED__
typedef interface ICorDebugFunction ICorDebugFunction;
#endif 	/* __ICorDebugFunction_FWD_DEFINED__ */


#ifndef __ICorDebugCode_FWD_DEFINED__
#define __ICorDebugCode_FWD_DEFINED__
typedef interface ICorDebugCode ICorDebugCode;
#endif 	/* __ICorDebugCode_FWD_DEFINED__ */


#ifndef __ICorDebugClass_FWD_DEFINED__
#define __ICorDebugClass_FWD_DEFINED__
typedef interface ICorDebugClass ICorDebugClass;
#endif 	/* __ICorDebugClass_FWD_DEFINED__ */


#ifndef __ICorDebugEval_FWD_DEFINED__
#define __ICorDebugEval_FWD_DEFINED__
typedef interface ICorDebugEval ICorDebugEval;
#endif 	/* __ICorDebugEval_FWD_DEFINED__ */


#ifndef __ICorDebugValue_FWD_DEFINED__
#define __ICorDebugValue_FWD_DEFINED__
typedef interface ICorDebugValue ICorDebugValue;
#endif 	/* __ICorDebugValue_FWD_DEFINED__ */


#ifndef __ICorDebugGenericValue_FWD_DEFINED__
#define __ICorDebugGenericValue_FWD_DEFINED__
typedef interface ICorDebugGenericValue ICorDebugGenericValue;
#endif 	/* __ICorDebugGenericValue_FWD_DEFINED__ */


#ifndef __ICorDebugReferenceValue_FWD_DEFINED__
#define __ICorDebugReferenceValue_FWD_DEFINED__
typedef interface ICorDebugReferenceValue ICorDebugReferenceValue;
#endif 	/* __ICorDebugReferenceValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue_FWD_DEFINED__
#define __ICorDebugHeapValue_FWD_DEFINED__
typedef interface ICorDebugHeapValue ICorDebugHeapValue;
#endif 	/* __ICorDebugHeapValue_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue_FWD_DEFINED__
#define __ICorDebugObjectValue_FWD_DEFINED__
typedef interface ICorDebugObjectValue ICorDebugObjectValue;
#endif 	/* __ICorDebugObjectValue_FWD_DEFINED__ */


#ifndef __ICorDebugBoxValue_FWD_DEFINED__
#define __ICorDebugBoxValue_FWD_DEFINED__
typedef interface ICorDebugBoxValue ICorDebugBoxValue;
#endif 	/* __ICorDebugBoxValue_FWD_DEFINED__ */


#ifndef __ICorDebugStringValue_FWD_DEFINED__
#define __ICorDebugStringValue_FWD_DEFINED__
typedef interface ICorDebugStringValue ICorDebugStringValue;
#endif 	/* __ICorDebugStringValue_FWD_DEFINED__ */


#ifndef __ICorDebugArrayValue_FWD_DEFINED__
#define __ICorDebugArrayValue_FWD_DEFINED__
typedef interface ICorDebugArrayValue ICorDebugArrayValue;
#endif 	/* __ICorDebugArrayValue_FWD_DEFINED__ */


#ifndef __ICorDebugContext_FWD_DEFINED__
#define __ICorDebugContext_FWD_DEFINED__
typedef interface ICorDebugContext ICorDebugContext;
#endif 	/* __ICorDebugContext_FWD_DEFINED__ */


#ifndef __ICorDebugEnum_FWD_DEFINED__
#define __ICorDebugEnum_FWD_DEFINED__
typedef interface ICorDebugEnum ICorDebugEnum;
#endif 	/* __ICorDebugEnum_FWD_DEFINED__ */


#ifndef __ICorDebugObjectEnum_FWD_DEFINED__
#define __ICorDebugObjectEnum_FWD_DEFINED__
typedef interface ICorDebugObjectEnum ICorDebugObjectEnum;
#endif 	/* __ICorDebugObjectEnum_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_FWD_DEFINED__
#define __ICorDebugBreakpointEnum_FWD_DEFINED__
typedef interface ICorDebugBreakpointEnum ICorDebugBreakpointEnum;
#endif 	/* __ICorDebugBreakpointEnum_FWD_DEFINED__ */


#ifndef __ICorDebugStepperEnum_FWD_DEFINED__
#define __ICorDebugStepperEnum_FWD_DEFINED__
typedef interface ICorDebugStepperEnum ICorDebugStepperEnum;
#endif 	/* __ICorDebugStepperEnum_FWD_DEFINED__ */


#ifndef __ICorDebugProcessEnum_FWD_DEFINED__
#define __ICorDebugProcessEnum_FWD_DEFINED__
typedef interface ICorDebugProcessEnum ICorDebugProcessEnum;
#endif 	/* __ICorDebugProcessEnum_FWD_DEFINED__ */


#ifndef __ICorDebugThreadEnum_FWD_DEFINED__
#define __ICorDebugThreadEnum_FWD_DEFINED__
typedef interface ICorDebugThreadEnum ICorDebugThreadEnum;
#endif 	/* __ICorDebugThreadEnum_FWD_DEFINED__ */


#ifndef __ICorDebugFrameEnum_FWD_DEFINED__
#define __ICorDebugFrameEnum_FWD_DEFINED__
typedef interface ICorDebugFrameEnum ICorDebugFrameEnum;
#endif 	/* __ICorDebugFrameEnum_FWD_DEFINED__ */


#ifndef __ICorDebugChainEnum_FWD_DEFINED__
#define __ICorDebugChainEnum_FWD_DEFINED__
typedef interface ICorDebugChainEnum ICorDebugChainEnum;
#endif 	/* __ICorDebugChainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugModuleEnum_FWD_DEFINED__
#define __ICorDebugModuleEnum_FWD_DEFINED__
typedef interface ICorDebugModuleEnum ICorDebugModuleEnum;
#endif 	/* __ICorDebugModuleEnum_FWD_DEFINED__ */


#ifndef __ICorDebugValueEnum_FWD_DEFINED__
#define __ICorDebugValueEnum_FWD_DEFINED__
typedef interface ICorDebugValueEnum ICorDebugValueEnum;
#endif 	/* __ICorDebugValueEnum_FWD_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_FWD_DEFINED__
#define __ICorDebugErrorInfoEnum_FWD_DEFINED__
typedef interface ICorDebugErrorInfoEnum ICorDebugErrorInfoEnum;
#endif 	/* __ICorDebugErrorInfoEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_FWD_DEFINED__
#define __ICorDebugAppDomainEnum_FWD_DEFINED__
typedef interface ICorDebugAppDomainEnum ICorDebugAppDomainEnum;
#endif 	/* __ICorDebugAppDomainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_FWD_DEFINED__
#define __ICorDebugAssemblyEnum_FWD_DEFINED__
typedef interface ICorDebugAssemblyEnum ICorDebugAssemblyEnum;
#endif 	/* __ICorDebugAssemblyEnum_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueErrorInfo ICorDebugEditAndContinueErrorInfo;
#endif 	/* __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueSnapshot ICorDebugEditAndContinueSnapshot;
#endif 	/* __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cordebug_0000 */
/* [local] */ 

#define CorDB_CONTROL_REMOTE_DEBUGGING   "Cor_Enable_Remote_Debugging"
#define CorDB_CONTROL_REMOTE_DEBUGGINGL L"Cor_Enable_Remote_Debugging"
#if 0
typedef UINT32 mdToken;

typedef mdToken mdModule;

typedef SIZE_T mdScope;

typedef mdToken mdTypeDef;

typedef mdToken mdSourceFile;

typedef mdToken mdMemberRef;

typedef mdToken mdMethodDef;

typedef mdToken mdFieldDef;

typedef mdToken mdSignature;

typedef ULONG CorElementType;

typedef SIZE_T PCCOR_SIGNATURE;

typedef SIZE_T LPDEBUG_EVENT;

typedef SIZE_T LPSTARTUPINFOW;

typedef SIZE_T LPPROCESS_INFORMATION;

#endif
typedef /* [wire_marshal] */ void *HPROCESS;

typedef /* [wire_marshal] */ void *HTHREAD;

#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
#define REMOTE_DEBUGGING_DLL_ENTRY L"Software\\Microsoft\\.NETFramework\\Debugger\\ActivateRemoteDebugging"











































typedef ULONG64 CORDB_ADDRESS;

typedef ULONG64 CORDB_REGISTER;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_s_ifspec;


#ifndef __CORDBLib_LIBRARY_DEFINED__
#define __CORDBLib_LIBRARY_DEFINED__

/* library CORDBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CORDBLib;

EXTERN_C const CLSID CLSID_CorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("6fef44d0-39e7-4c77-be8e-c9f8cf988630")
CorDebug;
#endif

EXTERN_C const CLSID CLSID_EmbeddedCLRCorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("211f1254-bc7e-4af5-b9aa-067308d83dd1")
EmbeddedCLRCorDebug;
#endif
#endif /* __CORDBLib_LIBRARY_DEFINED__ */

#ifndef __ICorDebugManagedCallback_INTERFACE_DEFINED__
#define __ICorDebugManagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugManagedCallback */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugStepReason
    {	STEP_NORMAL	= 0,
	STEP_RETURN	= STEP_NORMAL + 1,
	STEP_CALL	= STEP_RETURN + 1,
	STEP_EXCEPTION_FILTER	= STEP_CALL + 1,
	STEP_EXCEPTION_HANDLER	= STEP_EXCEPTION_FILTER + 1,
	STEP_INTERCEPT	= STEP_EXCEPTION_HANDLER + 1,
	STEP_EXIT	= STEP_INTERCEPT + 1
    } 	CorDebugStepReason;

typedef 
enum LoggingLevelEnum
    {	LTraceLevel0	= 0,
	LTraceLevel1	= LTraceLevel0 + 1,
	LTraceLevel2	= LTraceLevel1 + 1,
	LTraceLevel3	= LTraceLevel2 + 1,
	LTraceLevel4	= LTraceLevel3 + 1,
	LStatusLevel0	= 20,
	LStatusLevel1	= LStatusLevel0 + 1,
	LStatusLevel2	= LStatusLevel1 + 1,
	LStatusLevel3	= LStatusLevel2 + 1,
	LStatusLevel4	= LStatusLevel3 + 1,
	LWarningLevel	= 40,
	LErrorLevel	= 50,
	LPanicLevel	= 100
    } 	LoggingLevelEnum;

typedef 
enum LogSwitchCallReason
    {	SWITCH_CREATE	= 0,
	SWITCH_MODIFY	= SWITCH_CREATE + 1,
	SWITCH_DELETE	= SWITCH_MODIFY + 1
    } 	LogSwitchCallReason;


EXTERN_C const IID IID_ICorDebugManagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f60-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugManagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Breakpoint( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exception( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalException( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebuggerError( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogMessage( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogSwitch( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlCTrap( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NameChange( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateModuleSymbols( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditAndContinueRemap( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakpointSetError( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugManagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugManagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugManagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugManagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Breakpoint )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *StepComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason);
        
        HRESULT ( STDMETHODCALLTYPE *Break )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *Exception )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled);
        
        HRESULT ( STDMETHODCALLTYPE *EvalComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *EvalException )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CreateThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *ExitThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *LoadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *LoadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *DebuggerError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode);
        
        HRESULT ( STDMETHODCALLTYPE *LogMessage )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage);
        
        HRESULT ( STDMETHODCALLTYPE *LogSwitch )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *ExitAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *LoadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *ControlCTrap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *NameChange )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateModuleSymbols )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream);
        
        HRESULT ( STDMETHODCALLTYPE *EditAndContinueRemap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate);
        
        HRESULT ( STDMETHODCALLTYPE *BreakpointSetError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError);
        
        END_INTERFACE
    } ICorDebugManagedCallbackVtbl;

    interface ICorDebugManagedCallback
    {
        CONST_VTBL struct ICorDebugManagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugManagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugManagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugManagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugManagedCallback_Breakpoint(This,pAppDomain,pThread,pBreakpoint)	\
    (This)->lpVtbl -> Breakpoint(This,pAppDomain,pThread,pBreakpoint)

#define ICorDebugManagedCallback_StepComplete(This,pAppDomain,pThread,pStepper,reason)	\
    (This)->lpVtbl -> StepComplete(This,pAppDomain,pThread,pStepper,reason)

#define ICorDebugManagedCallback_Break(This,pAppDomain,thread)	\
    (This)->lpVtbl -> Break(This,pAppDomain,thread)

#define ICorDebugManagedCallback_Exception(This,pAppDomain,pThread,unhandled)	\
    (This)->lpVtbl -> Exception(This,pAppDomain,pThread,unhandled)

#define ICorDebugManagedCallback_EvalComplete(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalComplete(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_EvalException(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalException(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_CreateProcess(This,pProcess)	\
    (This)->lpVtbl -> CreateProcess(This,pProcess)

#define ICorDebugManagedCallback_ExitProcess(This,pProcess)	\
    (This)->lpVtbl -> ExitProcess(This,pProcess)

#define ICorDebugManagedCallback_CreateThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> CreateThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_ExitThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> ExitThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_LoadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> LoadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_UnloadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> UnloadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_LoadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> LoadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_UnloadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> UnloadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_DebuggerError(This,pProcess,errorHR,errorCode)	\
    (This)->lpVtbl -> DebuggerError(This,pProcess,errorHR,errorCode)

#define ICorDebugManagedCallback_LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)	\
    (This)->lpVtbl -> LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)

#define ICorDebugManagedCallback_LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)	\
    (This)->lpVtbl -> LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)

#define ICorDebugManagedCallback_CreateAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> CreateAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_ExitAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> ExitAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_LoadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> LoadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_UnloadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> UnloadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_ControlCTrap(This,pProcess)	\
    (This)->lpVtbl -> ControlCTrap(This,pProcess)

#define ICorDebugManagedCallback_NameChange(This,pAppDomain,pThread)	\
    (This)->lpVtbl -> NameChange(This,pAppDomain,pThread)

#define ICorDebugManagedCallback_UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)	\
    (This)->lpVtbl -> UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)

#define ICorDebugManagedCallback_EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)	\
    (This)->lpVtbl -> EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)

#define ICorDebugManagedCallback_BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)	\
    (This)->lpVtbl -> BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Breakpoint_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint);


void __RPC_STUB ICorDebugManagedCallback_Breakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_StepComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugStepper *pStepper,
    /* [in] */ CorDebugStepReason reason);


void __RPC_STUB ICorDebugManagedCallback_StepComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Break_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Exception_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ BOOL unhandled);


void __RPC_STUB ICorDebugManagedCallback_Exception_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalException_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ExitProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_CreateThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_ExitThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_LoadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_UnloadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_LoadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_UnloadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_DebuggerError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ HRESULT errorHR,
    /* [in] */ DWORD errorCode);


void __RPC_STUB ICorDebugManagedCallback_DebuggerError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogMessage_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pMessage);


void __RPC_STUB ICorDebugManagedCallback_LogMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogSwitch_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ ULONG ulReason,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pParentName);


void __RPC_STUB ICorDebugManagedCallback_LogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_CreateAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_ExitAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_LoadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_UnloadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ControlCTrap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ControlCTrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_NameChange_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread);


void __RPC_STUB ICorDebugManagedCallback_NameChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UpdateModuleSymbols_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule,
    /* [in] */ IStream *pSymbolStream);


void __RPC_STUB ICorDebugManagedCallback_UpdateModuleSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EditAndContinueRemap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ BOOL fAccurate);


void __RPC_STUB ICorDebugManagedCallback_EditAndContinueRemap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_BreakpointSetError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint,
    /* [in] */ DWORD dwError);


void __RPC_STUB ICorDebugManagedCallback_BreakpointSetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugManagedCallback_INTERFACE_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__
#define __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugUnmanagedCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugUnmanagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5263E909-8CB5-11d3-BD2F-0000F80849BD")
    ICorDebugUnmanagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DebugEvent( 
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugUnmanagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugUnmanagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugUnmanagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *DebugEvent )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand);
        
        END_INTERFACE
    } ICorDebugUnmanagedCallbackVtbl;

    interface ICorDebugUnmanagedCallback
    {
        CONST_VTBL struct ICorDebugUnmanagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugUnmanagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugUnmanagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugUnmanagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugUnmanagedCallback_DebugEvent(This,pDebugEvent,fOutOfBand)	\
    (This)->lpVtbl -> DebugEvent(This,pDebugEvent,fOutOfBand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugUnmanagedCallback_DebugEvent_Proxy( 
    ICorDebugUnmanagedCallback * This,
    /* [in] */ LPDEBUG_EVENT pDebugEvent,
    /* [in] */ BOOL fOutOfBand);


void __RPC_STUB ICorDebugUnmanagedCallback_DebugEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0112 */
/* [local] */ 

typedef 
enum CorDebugCreateProcessFlags
    {	DEBUG_NO_SPECIAL_OPTIONS	= 0
    } 	CorDebugCreateProcessFlags;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0112_v0_0_s_ifspec;

#ifndef __ICorDebug_INTERFACE_DEFINED__
#define __ICorDebug_INTERFACE_DEFINED__

/* interface ICorDebug */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f61-7538-11d3-8d5b-00104b35e7ef")
    ICorDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManagedHandler( 
            /* [in] */ ICorDebugManagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmanagedHandler( 
            /* [in] */ ICorDebugUnmanagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugActiveProcess( 
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateProcesses( 
            /* [out] */ ICorDebugProcessEnum **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanLaunchOrAttach( 
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetManagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugManagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmanagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugUnmanagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebug * This,
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *DebugActiveProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateProcesses )( 
            ICorDebug * This,
            /* [out] */ ICorDebugProcessEnum **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CanLaunchOrAttach )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled);
        
        END_INTERFACE
    } ICorDebugVtbl;

    interface ICorDebug
    {
        CONST_VTBL struct ICorDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebug_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define ICorDebug_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define ICorDebug_SetManagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetManagedHandler(This,pCallback)

#define ICorDebug_SetUnmanagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetUnmanagedHandler(This,pCallback)

#define ICorDebug_CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)	\
    (This)->lpVtbl -> CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)

#define ICorDebug_DebugActiveProcess(This,id,win32Attach,ppProcess)	\
    (This)->lpVtbl -> DebugActiveProcess(This,id,win32Attach,ppProcess)

#define ICorDebug_EnumerateProcesses(This,ppProcess)	\
    (This)->lpVtbl -> EnumerateProcesses(This,ppProcess)

#define ICorDebug_GetProcess(This,dwProcessId,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,dwProcessId,ppProcess)

#define ICorDebug_CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)	\
    (This)->lpVtbl -> CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebug_Initialize_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_Terminate_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetManagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugManagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetManagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetUnmanagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugUnmanagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetUnmanagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CreateProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ LPCWSTR lpApplicationName,
    /* [in] */ LPWSTR lpCommandLine,
    /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    /* [in] */ BOOL bInheritHandles,
    /* [in] */ DWORD dwCreationFlags,
    /* [in] */ PVOID lpEnvironment,
    /* [in] */ LPCWSTR lpCurrentDirectory,
    /* [in] */ LPSTARTUPINFOW lpStartupInfo,
    /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
    /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_DebugActiveProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD id,
    /* [in] */ BOOL win32Attach,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_DebugActiveProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_EnumerateProcesses_Proxy( 
    ICorDebug * This,
    /* [out] */ ICorDebugProcessEnum **ppProcess);


void __RPC_STUB ICorDebug_EnumerateProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_GetProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CanLaunchOrAttach_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [in] */ BOOL win32DebuggingEnabled);


void __RPC_STUB ICorDebug_CanLaunchOrAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebug_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0113 */
/* [local] */ 

typedef 
enum CorDebugThreadState
    {	THREAD_RUN	= 0,
	THREAD_SUSPEND	= THREAD_RUN + 1
    } 	CorDebugThreadState;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0113_v0_0_s_ifspec;

#ifndef __ICorDebugController_INTERFACE_DEFINED__
#define __ICorDebugController_INTERFACE_DEFINED__

/* interface ICorDebugController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f62-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ BOOL fIsOutOfBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRunning( 
            /* [out] */ BOOL *pbRunning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasQueuedCallbacks( 
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateThreads( 
            /* [out] */ ICorDebugThreadEnum **ppThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllThreadsDebugState( 
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ UINT exitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanCommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugController * This,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugController * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugController * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugController * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugController * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugController * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugController * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        END_INTERFACE
    } ICorDebugControllerVtbl;

    interface ICorDebugController
    {
        CONST_VTBL struct ICorDebugControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugController_Stop(This,dwTimeout)	\
    (This)->lpVtbl -> Stop(This,dwTimeout)

#define ICorDebugController_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugController_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugController_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugController_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugController_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugController_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugController_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugController_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugController_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugController_Stop_Proxy( 
    ICorDebugController * This,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB ICorDebugController_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Continue_Proxy( 
    ICorDebugController * This,
    /* [in] */ BOOL fIsOutOfBand);


void __RPC_STUB ICorDebugController_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_IsRunning_Proxy( 
    ICorDebugController * This,
    /* [out] */ BOOL *pbRunning);


void __RPC_STUB ICorDebugController_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_HasQueuedCallbacks_Proxy( 
    ICorDebugController * This,
    /* [in] */ ICorDebugThread *pThread,
    /* [out] */ BOOL *pbQueued);


void __RPC_STUB ICorDebugController_HasQueuedCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_EnumerateThreads_Proxy( 
    ICorDebugController * This,
    /* [out] */ ICorDebugThreadEnum **ppThreads);


void __RPC_STUB ICorDebugController_EnumerateThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_SetAllThreadsDebugState_Proxy( 
    ICorDebugController * This,
    /* [in] */ CorDebugThreadState state,
    /* [in] */ ICorDebugThread *pExceptThisThread);


void __RPC_STUB ICorDebugController_SetAllThreadsDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Detach_Proxy( 
    ICorDebugController * This);


void __RPC_STUB ICorDebugController_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Terminate_Proxy( 
    ICorDebugController * This,
    /* [in] */ UINT exitCode);


void __RPC_STUB ICorDebugController_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CanCommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CanCommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugController_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomain_INTERFACE_DEFINED__
#define __ICorDebugAppDomain_INTERFACE_DEFINED__

/* interface ICorDebugAppDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f63-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugAppDomain : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAssemblies( 
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleFromMetaDataInterface( 
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateBreakpoints( 
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateSteppers( 
            /* [out] */ ICorDebugStepperEnum **ppSteppers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG32 *pId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugAppDomain * This,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugAppDomain * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugAppDomain * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugAppDomain * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugAppDomain * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAssemblies )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleFromMetaDataInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateBreakpoints )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateSteppers )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugStepperEnum **ppSteppers);
        
        HRESULT ( STDMETHODCALLTYPE *IsAttached )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbAttached);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugAppDomain * This,
            /* [out] */ ULONG32 *pId);
        
        END_INTERFACE
    } ICorDebugAppDomainVtbl;

    interface ICorDebugAppDomain
    {
        CONST_VTBL struct ICorDebugAppDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomain_Stop(This,dwTimeout)	\
    (This)->lpVtbl -> Stop(This,dwTimeout)

#define ICorDebugAppDomain_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugAppDomain_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugAppDomain_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugAppDomain_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugAppDomain_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugAppDomain_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugAppDomain_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugAppDomain_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugAppDomain_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugAppDomain_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAppDomain_EnumerateAssemblies(This,ppAssemblies)	\
    (This)->lpVtbl -> EnumerateAssemblies(This,ppAssemblies)

#define ICorDebugAppDomain_GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)	\
    (This)->lpVtbl -> GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)

#define ICorDebugAppDomain_EnumerateBreakpoints(This,ppBreakpoints)	\
    (This)->lpVtbl -> EnumerateBreakpoints(This,ppBreakpoints)

#define ICorDebugAppDomain_EnumerateSteppers(This,ppSteppers)	\
    (This)->lpVtbl -> EnumerateSteppers(This,ppSteppers)

#define ICorDebugAppDomain_IsAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsAttached(This,pbAttached)

#define ICorDebugAppDomain_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugAppDomain_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugAppDomain_Attach(This)	\
    (This)->lpVtbl -> Attach(This)

#define ICorDebugAppDomain_GetID(This,pId)	\
    (This)->lpVtbl -> GetID(This,pId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetProcess_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAppDomain_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateAssemblies_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);


void __RPC_STUB ICorDebugAppDomain_EnumerateAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetModuleFromMetaDataInterface_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ IUnknown *pIMetaData,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugAppDomain_GetModuleFromMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateBreakpoints_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);


void __RPC_STUB ICorDebugAppDomain_EnumerateBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateSteppers_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugStepperEnum **ppSteppers);


void __RPC_STUB ICorDebugAppDomain_EnumerateSteppers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_IsAttached_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB ICorDebugAppDomain_IsAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetName_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAppDomain_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetObject_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugAppDomain_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_Attach_Proxy( 
    ICorDebugAppDomain * This);


void __RPC_STUB ICorDebugAppDomain_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetID_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ULONG32 *pId);


void __RPC_STUB ICorDebugAppDomain_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssembly_INTERFACE_DEFINED__
#define __ICorDebugAssembly_INTERFACE_DEFINED__

/* interface ICorDebugAssembly */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("df59507c-d47a-459e-bce2-6427eac8fd06")
    ICorDebugAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateModules( 
            /* [out] */ ICorDebugModuleEnum **ppModules) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeBase( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateModules )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugModuleEnum **ppModules);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeBase )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        END_INTERFACE
    } ICorDebugAssemblyVtbl;

    interface ICorDebugAssembly
    {
        CONST_VTBL struct ICorDebugAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssembly_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAssembly_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugAssembly_EnumerateModules(This,ppModules)	\
    (This)->lpVtbl -> EnumerateModules(This,ppModules)

#define ICorDebugAssembly_GetCodeBase(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetCodeBase(This,cchName,pcchName,szName)

#define ICorDebugAssembly_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetProcess_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAssembly_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetAppDomain_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugAssembly_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_EnumerateModules_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugModuleEnum **ppModules);


void __RPC_STUB ICorDebugAssembly_EnumerateModules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetCodeBase_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetCodeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetName_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssembly_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcess_INTERFACE_DEFINED__
#define __ICorDebugProcess_INTERFACE_DEFINED__

/* interface ICorDebugProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f64-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugProcess : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HPROCESS *phProcessHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateObjects( 
            /* [out] */ ICorDebugObjectEnum **ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTransitionStub( 
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsOSSuspended( 
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ DWORD *read) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ DWORD *written) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( 
            /* [in] */ DWORD threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLogMessages( 
            /* [in] */ BOOL fOnOff) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyLogSwitch( 
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAppDomains( 
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadForFiberCookie( 
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelperThreadID( 
            /* [out] */ DWORD *pThreadID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugProcess * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugProcess * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugProcess * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugProcess * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pdwProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugProcess * This,
            /* [out] */ HPROCESS *phProcessHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateObjects )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugObjectEnum **ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE *IsTransitionStub )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub);
        
        HRESULT ( STDMETHODCALLTYPE *IsOSSuspended )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ DWORD *read);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ DWORD *written);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLogMessages )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fOnOff);
        
        HRESULT ( STDMETHODCALLTYPE *ModifyLogSwitch )( 
            ICorDebugProcess * This,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAppDomains )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadForFiberCookie )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelperThreadID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pThreadID);
        
        END_INTERFACE
    } ICorDebugProcessVtbl;

    interface ICorDebugProcess
    {
        CONST_VTBL struct ICorDebugProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcess_Stop(This,dwTimeout)	\
    (This)->lpVtbl -> Stop(This,dwTimeout)

#define ICorDebugProcess_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugProcess_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugProcess_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugProcess_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugProcess_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugProcess_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugProcess_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugProcess_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugProcess_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugProcess_GetID(This,pdwProcessId)	\
    (This)->lpVtbl -> GetID(This,pdwProcessId)

#define ICorDebugProcess_GetHandle(This,phProcessHandle)	\
    (This)->lpVtbl -> GetHandle(This,phProcessHandle)

#define ICorDebugProcess_GetThread(This,dwThreadId,ppThread)	\
    (This)->lpVtbl -> GetThread(This,dwThreadId,ppThread)

#define ICorDebugProcess_EnumerateObjects(This,ppObjects)	\
    (This)->lpVtbl -> EnumerateObjects(This,ppObjects)

#define ICorDebugProcess_IsTransitionStub(This,address,pbTransitionStub)	\
    (This)->lpVtbl -> IsTransitionStub(This,address,pbTransitionStub)

#define ICorDebugProcess_IsOSSuspended(This,threadID,pbSuspended)	\
    (This)->lpVtbl -> IsOSSuspended(This,threadID,pbSuspended)

#define ICorDebugProcess_GetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_ReadMemory(This,address,size,buffer,read)	\
    (This)->lpVtbl -> ReadMemory(This,address,size,buffer,read)

#define ICorDebugProcess_WriteMemory(This,address,size,buffer,written)	\
    (This)->lpVtbl -> WriteMemory(This,address,size,buffer,written)

#define ICorDebugProcess_ClearCurrentException(This,threadID)	\
    (This)->lpVtbl -> ClearCurrentException(This,threadID)

#define ICorDebugProcess_EnableLogMessages(This,fOnOff)	\
    (This)->lpVtbl -> EnableLogMessages(This,fOnOff)

#define ICorDebugProcess_ModifyLogSwitch(This,pLogSwitchName,lLevel)	\
    (This)->lpVtbl -> ModifyLogSwitch(This,pLogSwitchName,lLevel)

#define ICorDebugProcess_EnumerateAppDomains(This,ppAppDomains)	\
    (This)->lpVtbl -> EnumerateAppDomains(This,ppAppDomains)

#define ICorDebugProcess_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugProcess_ThreadForFiberCookie(This,fiberCookie,ppThread)	\
    (This)->lpVtbl -> ThreadForFiberCookie(This,fiberCookie,ppThread)

#define ICorDebugProcess_GetHelperThreadID(This,pThreadID)	\
    (This)->lpVtbl -> GetHelperThreadID(This,pThreadID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pdwProcessId);


void __RPC_STUB ICorDebugProcess_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHandle_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ HPROCESS *phProcessHandle);


void __RPC_STUB ICorDebugProcess_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThread_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateObjects_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugObjectEnum **ppObjects);


void __RPC_STUB ICorDebugProcess_EnumerateObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsTransitionStub_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [out] */ BOOL *pbTransitionStub);


void __RPC_STUB ICorDebugProcess_IsTransitionStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsOSSuspended_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [out] */ BOOL *pbSuspended);


void __RPC_STUB ICorDebugProcess_IsOSSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_SetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ReadMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ DWORD *read);


void __RPC_STUB ICorDebugProcess_ReadMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_WriteMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [size_is][in] */ BYTE buffer[  ],
    /* [out] */ DWORD *written);


void __RPC_STUB ICorDebugProcess_WriteMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ClearCurrentException_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID);


void __RPC_STUB ICorDebugProcess_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnableLogMessages_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ BOOL fOnOff);


void __RPC_STUB ICorDebugProcess_EnableLogMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ModifyLogSwitch_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ LONG lLevel);


void __RPC_STUB ICorDebugProcess_ModifyLogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateAppDomains_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);


void __RPC_STUB ICorDebugProcess_EnumerateAppDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetObject_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugProcess_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ThreadForFiberCookie_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD fiberCookie,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_ThreadForFiberCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHelperThreadID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pThreadID);


void __RPC_STUB ICorDebugProcess_GetHelperThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcess_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE8-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL bActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        END_INTERFACE
    } ICorDebugBreakpointVtbl;

    interface ICorDebugBreakpoint
    {
        CONST_VTBL struct ICorDebugBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_Activate_Proxy( 
    ICorDebugBreakpoint * This,
    /* [in] */ BOOL bActive);


void __RPC_STUB ICorDebugBreakpoint_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_IsActive_Proxy( 
    ICorDebugBreakpoint * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugBreakpoint_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugFunctionBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunctionBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE9-8A68-11d2-983C-0000F808342D")
    ICorDebugFunctionBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunctionBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunctionBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ULONG32 *pnOffset);
        
        END_INTERFACE
    } ICorDebugFunctionBreakpointVtbl;

    interface ICorDebugFunctionBreakpoint
    {
        CONST_VTBL struct ICorDebugFunctionBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunctionBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunctionBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunctionBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunctionBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugFunctionBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugFunctionBreakpoint_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFunctionBreakpoint_GetOffset(This,pnOffset)	\
    (This)->lpVtbl -> GetOffset(This,pnOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetFunction_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetOffset_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugModuleBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEA-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        END_INTERFACE
    } ICorDebugModuleBreakpointVtbl;

    interface ICorDebugModuleBreakpoint
    {
        CONST_VTBL struct ICorDebugModuleBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugModuleBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugModuleBreakpoint_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleBreakpoint_GetModule_Proxy( 
    ICorDebugModuleBreakpoint * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugModuleBreakpoint_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugValueBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugValueBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEB-8A68-11d2-983C-0000F808342D")
    ICorDebugValueBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugValueBreakpointVtbl;

    interface ICorDebugValueBreakpoint
    {
        CONST_VTBL struct ICorDebugValueBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugValueBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugValueBreakpoint_GetValue(This,ppValue)	\
    (This)->lpVtbl -> GetValue(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueBreakpoint_GetValue_Proxy( 
    ICorDebugValueBreakpoint * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugValueBreakpoint_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepper_INTERFACE_DEFINED__
#define __ICorDebugStepper_INTERFACE_DEFINED__

/* interface ICorDebugStepper */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugIntercept
    {	INTERCEPT_NONE	= 0,
	INTERCEPT_CLASS_INIT	= 0x1,
	INTERCEPT_EXCEPTION_FILTER	= 0x2,
	INTERCEPT_SECURITY	= 0x4,
	INTERCEPT_CONTEXT_POLICY	= 0x8,
	INTERCEPT_INTERCEPTION	= 0x10,
	INTERCEPT_ALL	= 0xffff
    } 	CorDebugIntercept;

typedef 
enum CorDebugUnmappedStop
    {	STOP_NONE	= 0,
	STOP_PROLOG	= 0x1,
	STOP_EPILOG	= 0x2,
	STOP_NO_MAPPING_INFO	= 0x4,
	STOP_OTHER_UNMAPPED	= 0x8,
	STOP_UNMANAGED	= 0x10,
	STOP_ALL	= 0xffff
    } 	CorDebugUnmappedStop;

typedef struct COR_DEBUG_STEP_RANGE
    {
    ULONG32 startOffset;
    ULONG32 endOffset;
    } 	COR_DEBUG_STEP_RANGE;


EXTERN_C const IID IID_ICorDebugStepper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEC-8A68-11d2-983C-0000F808342D")
    ICorDebugStepper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterceptMask( 
            /* [in] */ CorDebugIntercept mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmappedStopMask( 
            /* [in] */ CorDebugUnmappedStop mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( 
            /* [in] */ BOOL bStepIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepRange( 
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRangeIL( 
            /* [in] */ BOOL bIL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugStepper * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterceptMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugIntercept mask);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmappedStopMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugUnmappedStop mask);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn);
        
        HRESULT ( STDMETHODCALLTYPE *StepRange )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount);
        
        HRESULT ( STDMETHODCALLTYPE *StepOut )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRangeIL )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bIL);
        
        END_INTERFACE
    } ICorDebugStepperVtbl;

    interface ICorDebugStepper
    {
        CONST_VTBL struct ICorDebugStepperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepper_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugStepper_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ICorDebugStepper_SetInterceptMask(This,mask)	\
    (This)->lpVtbl -> SetInterceptMask(This,mask)

#define ICorDebugStepper_SetUnmappedStopMask(This,mask)	\
    (This)->lpVtbl -> SetUnmappedStopMask(This,mask)

#define ICorDebugStepper_Step(This,bStepIn)	\
    (This)->lpVtbl -> Step(This,bStepIn)

#define ICorDebugStepper_StepRange(This,bStepIn,ranges,cRangeCount)	\
    (This)->lpVtbl -> StepRange(This,bStepIn,ranges,cRangeCount)

#define ICorDebugStepper_StepOut(This)	\
    (This)->lpVtbl -> StepOut(This)

#define ICorDebugStepper_SetRangeIL(This,bIL)	\
    (This)->lpVtbl -> SetRangeIL(This,bIL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepper_IsActive_Proxy( 
    ICorDebugStepper * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugStepper_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Deactivate_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetInterceptMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugIntercept mask);


void __RPC_STUB ICorDebugStepper_SetInterceptMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetUnmappedStopMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugUnmappedStop mask);


void __RPC_STUB ICorDebugStepper_SetUnmappedStopMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Step_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn);


void __RPC_STUB ICorDebugStepper_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepRange_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn,
    /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
    /* [in] */ ULONG32 cRangeCount);


void __RPC_STUB ICorDebugStepper_StepRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepOut_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_StepOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetRangeIL_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bIL);


void __RPC_STUB ICorDebugStepper_SetRangeIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepper_INTERFACE_DEFINED__ */


#ifndef __ICorDebugRegisterSet_INTERFACE_DEFINED__
#define __ICorDebugRegisterSet_INTERFACE_DEFINED__

/* interface ICorDebugRegisterSet */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugRegister
    {	REGISTER_INSTRUCTION_POINTER	= 0,
	REGISTER_STACK_POINTER	= REGISTER_INSTRUCTION_POINTER + 1,
	REGISTER_FRAME_POINTER	= REGISTER_STACK_POINTER + 1,
	REGISTER_X86_EIP	= 0,
	REGISTER_X86_ESP	= REGISTER_X86_EIP + 1,
	REGISTER_X86_EBP	= REGISTER_X86_ESP + 1,
	REGISTER_X86_EAX	= REGISTER_X86_EBP + 1,
	REGISTER_X86_ECX	= REGISTER_X86_EAX + 1,
	REGISTER_X86_EDX	= REGISTER_X86_ECX + 1,
	REGISTER_X86_EBX	= REGISTER_X86_EDX + 1,
	REGISTER_X86_ESI	= REGISTER_X86_EBX + 1,
	REGISTER_X86_EDI	= REGISTER_X86_ESI + 1,
	REGISTER_X86_FPSTACK_0	= REGISTER_X86_EDI + 1,
	REGISTER_X86_FPSTACK_1	= REGISTER_X86_FPSTACK_0 + 1,
	REGISTER_X86_FPSTACK_2	= REGISTER_X86_FPSTACK_1 + 1,
	REGISTER_X86_FPSTACK_3	= REGISTER_X86_FPSTACK_2 + 1,
	REGISTER_X86_FPSTACK_4	= REGISTER_X86_FPSTACK_3 + 1,
	REGISTER_X86_FPSTACK_5	= REGISTER_X86_FPSTACK_4 + 1,
	REGISTER_X86_FPSTACK_6	= REGISTER_X86_FPSTACK_5 + 1,
	REGISTER_X86_FPSTACK_7	= REGISTER_X86_FPSTACK_6 + 1
    } 	CorDebugRegister;


EXTERN_C const IID IID_ICorDebugRegisterSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0B-8A68-11d2-983C-0000F808342D")
    ICorDebugRegisterSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRegistersAvailable( 
            /* [out] */ ULONG64 *pAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugRegisterSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugRegisterSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugRegisterSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugRegisterSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegistersAvailable )( 
            ICorDebugRegisterSet * This,
            /* [out] */ ULONG64 *pAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        END_INTERFACE
    } ICorDebugRegisterSetVtbl;

    interface ICorDebugRegisterSet
    {
        CONST_VTBL struct ICorDebugRegisterSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugRegisterSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugRegisterSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugRegisterSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugRegisterSet_GetRegistersAvailable(This,pAvailable)	\
    (This)->lpVtbl -> GetRegistersAvailable(This,pAvailable)

#define ICorDebugRegisterSet_GetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> GetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_SetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> SetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_GetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,contextSize,context)

#define ICorDebugRegisterSet_SetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,contextSize,context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegistersAvailable_Proxy( 
    ICorDebugRegisterSet * This,
    /* [out] */ ULONG64 *pAvailable);


void __RPC_STUB ICorDebugRegisterSet_GetRegistersAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugRegisterSet_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThread_INTERFACE_DEFINED__
#define __ICorDebugThread_INTERFACE_DEFINED__

/* interface ICorDebugThread */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugUserState
    {	USER_STOP_REQUESTED	= 0x1,
	USER_SUSPEND_REQUESTED	= 0x2,
	USER_BACKGROUND	= 0x4,
	USER_UNSTARTED	= 0x8,
	USER_STOPPED	= 0x10,
	USER_WAIT_SLEEP_JOIN	= 0x20,
	USER_SUSPENDED	= 0x40
    } 	CorDebugUserState;


EXTERN_C const IID IID_ICorDebugThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("938c6d66-7fb6-4f69-b389-425b8987329b")
    ICorDebugThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HTHREAD *phThreadHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugState( 
            /* [in] */ CorDebugThreadState state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugState( 
            /* [out] */ CorDebugThreadState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserState( 
            /* [out] */ CorDebugUserState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentException( 
            /* [out] */ ICorDebugValue **ppExceptionObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateChains( 
            /* [out] */ ICorDebugChainEnum **ppChains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEval( 
            /* [out] */ ICorDebugEval **ppEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThread * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThread * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugThread * This,
            /* [out] */ DWORD *pdwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugThread * This,
            /* [out] */ HTHREAD *phThreadHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugState )( 
            ICorDebugThread * This,
            /* [in] */ CorDebugThreadState state);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugThreadState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugUserState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentException )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppExceptionObject);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateChains )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChainEnum **ppChains);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveChain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEval )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugEval **ppEval);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        END_INTERFACE
    } ICorDebugThreadVtbl;

    interface ICorDebugThread
    {
        CONST_VTBL struct ICorDebugThreadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThread_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugThread_GetID(This,pdwThreadId)	\
    (This)->lpVtbl -> GetID(This,pdwThreadId)

#define ICorDebugThread_GetHandle(This,phThreadHandle)	\
    (This)->lpVtbl -> GetHandle(This,phThreadHandle)

#define ICorDebugThread_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugThread_SetDebugState(This,state)	\
    (This)->lpVtbl -> SetDebugState(This,state)

#define ICorDebugThread_GetDebugState(This,pState)	\
    (This)->lpVtbl -> GetDebugState(This,pState)

#define ICorDebugThread_GetUserState(This,pState)	\
    (This)->lpVtbl -> GetUserState(This,pState)

#define ICorDebugThread_GetCurrentException(This,ppExceptionObject)	\
    (This)->lpVtbl -> GetCurrentException(This,ppExceptionObject)

#define ICorDebugThread_ClearCurrentException(This)	\
    (This)->lpVtbl -> ClearCurrentException(This)

#define ICorDebugThread_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#define ICorDebugThread_EnumerateChains(This,ppChains)	\
    (This)->lpVtbl -> EnumerateChains(This,ppChains)

#define ICorDebugThread_GetActiveChain(This,ppChain)	\
    (This)->lpVtbl -> GetActiveChain(This,ppChain)

#define ICorDebugThread_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugThread_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugThread_CreateEval(This,ppEval)	\
    (This)->lpVtbl -> CreateEval(This,ppEval)

#define ICorDebugThread_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThread_GetProcess_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugThread_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetID_Proxy( 
    ICorDebugThread * This,
    /* [out] */ DWORD *pdwThreadId);


void __RPC_STUB ICorDebugThread_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetHandle_Proxy( 
    ICorDebugThread * This,
    /* [out] */ HTHREAD *phThreadHandle);


void __RPC_STUB ICorDebugThread_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetAppDomain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugThread_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_SetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [in] */ CorDebugThreadState state);


void __RPC_STUB ICorDebugThread_SetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugThreadState *pState);


void __RPC_STUB ICorDebugThread_GetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetUserState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugUserState *pState);


void __RPC_STUB ICorDebugThread_GetUserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetCurrentException_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppExceptionObject);


void __RPC_STUB ICorDebugThread_GetCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_ClearCurrentException_Proxy( 
    ICorDebugThread * This);


void __RPC_STUB ICorDebugThread_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateStepper_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugThread_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_EnumerateChains_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChainEnum **ppChains);


void __RPC_STUB ICorDebugThread_EnumerateChains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveChain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugThread_GetActiveChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveFrame_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugThread_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetRegisterSet_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugThread_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateEval_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugEval **ppEval);


void __RPC_STUB ICorDebugThread_CreateEval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetObject_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugThread_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThread_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChain_INTERFACE_DEFINED__
#define __ICorDebugChain_INTERFACE_DEFINED__

/* interface ICorDebugChain */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugChainReason
    {	CHAIN_NONE	= 0,
	CHAIN_CLASS_INIT	= 0x1,
	CHAIN_EXCEPTION_FILTER	= 0x2,
	CHAIN_SECURITY	= 0x4,
	CHAIN_CONTEXT_POLICY	= 0x8,
	CHAIN_INTERCEPTION	= 0x10,
	CHAIN_PROCESS_START	= 0x20,
	CHAIN_THREAD_START	= 0x40,
	CHAIN_ENTER_MANAGED	= 0x80,
	CHAIN_ENTER_UNMANAGED	= 0x100,
	CHAIN_DEBUGGER_EVAL	= 0x200,
	CHAIN_CONTEXT_SWITCH	= 0x400,
	CHAIN_FUNC_EVAL	= 0x800
    } 	CorDebugChainReason;


EXTERN_C const IID IID_ICorDebugChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEE-8A68-11d2-983C-0000F808342D")
    ICorDebugChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrevious( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsManaged( 
            /* [out] */ BOOL *pManaged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateFrames( 
            /* [out] */ ICorDebugFrameEnum **ppFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReason( 
            /* [out] */ CorDebugChainReason *pReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugChain * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevious )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *IsManaged )( 
            ICorDebugChain * This,
            /* [out] */ BOOL *pManaged);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateFrames )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrameEnum **ppFrames);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetReason )( 
            ICorDebugChain * This,
            /* [out] */ CorDebugChainReason *pReason);
        
        END_INTERFACE
    } ICorDebugChainVtbl;

    interface ICorDebugChain
    {
        CONST_VTBL struct ICorDebugChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChain_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugChain_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugChain_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugChain_GetCaller(This,ppChain)	\
    (This)->lpVtbl -> GetCaller(This,ppChain)

#define ICorDebugChain_GetCallee(This,ppChain)	\
    (This)->lpVtbl -> GetCallee(This,ppChain)

#define ICorDebugChain_GetPrevious(This,ppChain)	\
    (This)->lpVtbl -> GetPrevious(This,ppChain)

#define ICorDebugChain_GetNext(This,ppChain)	\
    (This)->lpVtbl -> GetNext(This,ppChain)

#define ICorDebugChain_IsManaged(This,pManaged)	\
    (This)->lpVtbl -> IsManaged(This,pManaged)

#define ICorDebugChain_EnumerateFrames(This,ppFrames)	\
    (This)->lpVtbl -> EnumerateFrames(This,ppFrames)

#define ICorDebugChain_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugChain_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugChain_GetReason(This,pReason)	\
    (This)->lpVtbl -> GetReason(This,pReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChain_GetThread_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugChain_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetStackRange_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugChain_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetContext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugChain_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCaller_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCallee_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetPrevious_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetPrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetNext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_IsManaged_Proxy( 
    ICorDebugChain * This,
    /* [out] */ BOOL *pManaged);


void __RPC_STUB ICorDebugChain_IsManaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_EnumerateFrames_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrameEnum **ppFrames);


void __RPC_STUB ICorDebugChain_EnumerateFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetActiveFrame_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugChain_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetRegisterSet_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugChain_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetReason_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CorDebugChainReason *pReason);


void __RPC_STUB ICorDebugChain_GetReason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrame_INTERFACE_DEFINED__
#define __ICorDebugFrame_INTERFACE_DEFINED__

/* interface ICorDebugFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEF-8A68-11d2-983C-0000F808342D")
    ICorDebugFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionToken( 
            /* [out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        END_INTERFACE
    } ICorDebugFrameVtbl;

    interface ICorDebugFrame
    {
        CONST_VTBL struct ICorDebugFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetChain_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugFrame_GetChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCode_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFrame_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunction_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFrame_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunctionToken_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ mdMethodDef *pToken);


void __RPC_STUB ICorDebugFrame_GetFunctionToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetStackRange_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugFrame_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCaller_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCallee_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_CreateStepper_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugFrame_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugILFrame_INTERFACE_DEFINED__
#define __ICorDebugILFrame_INTERFACE_DEFINED__

/* interface ICorDebugILFrame */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugMappingResult
    {	MAPPING_PROLOG	= 0x1,
	MAPPING_EPILOG	= 0x2,
	MAPPING_NO_INFO	= 0x4,
	MAPPING_UNMAPPED_ADDRESS	= 0x8,
	MAPPING_EXACT	= 0x10,
	MAPPING_APPROXIMATE	= 0x20
    } 	CorDebugMappingResult;


EXTERN_C const IID IID_ICorDebugILFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26311-4F76-11d3-88C6-006097945418")
    ICorDebugILFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateLocalVariables( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVariable( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateArguments( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArgument( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackDepth( 
            /* [out] */ ULONG32 *pDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackValue( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugILFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugILFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugILFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugILFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugILFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugILFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateLocalVariables )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVariable )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateArguments )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetArgument )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackDepth )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pDepth);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackValue )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugILFrameVtbl;

    interface ICorDebugILFrame
    {
        CONST_VTBL struct ICorDebugILFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugILFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugILFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugILFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugILFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugILFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugILFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugILFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugILFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugILFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugILFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugILFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugILFrame_GetIP(This,pnOffset,pMappingResult)	\
    (This)->lpVtbl -> GetIP(This,pnOffset,pMappingResult)

#define ICorDebugILFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugILFrame_EnumerateLocalVariables(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateLocalVariables(This,ppValueEnum)

#define ICorDebugILFrame_GetLocalVariable(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetLocalVariable(This,dwIndex,ppValue)

#define ICorDebugILFrame_EnumerateArguments(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateArguments(This,ppValueEnum)

#define ICorDebugILFrame_GetArgument(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetArgument(This,dwIndex,ppValue)

#define ICorDebugILFrame_GetStackDepth(This,pDepth)	\
    (This)->lpVtbl -> GetStackDepth(This,pDepth)

#define ICorDebugILFrame_GetStackValue(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetStackValue(This,dwIndex,ppValue)

#define ICorDebugILFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pnOffset,
    /* [out] */ CorDebugMappingResult *pMappingResult);


void __RPC_STUB ICorDebugILFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_SetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateLocalVariables_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateLocalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetLocalVariable_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetLocalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateArguments_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetArgument_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetArgument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackDepth_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pDepth);


void __RPC_STUB ICorDebugILFrame_GetStackDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackValue_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetStackValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_CanSetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugILFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugNativeFrame_INTERFACE_DEFINED__
#define __ICorDebugNativeFrame_INTERFACE_DEFINED__

/* interface ICorDebugNativeFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugNativeFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26314-4F76-11d3-88C6-006097945418")
    ICorDebugNativeFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterValue( 
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalDoubleRegisterValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryValue( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterMemoryValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryRegisterValue( 
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugNativeFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugNativeFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugNativeFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugNativeFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugNativeFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugNativeFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ULONG32 *pnOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalDoubleRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugNativeFrameVtbl;

    interface ICorDebugNativeFrame
    {
        CONST_VTBL struct ICorDebugNativeFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugNativeFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugNativeFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugNativeFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugNativeFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugNativeFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugNativeFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugNativeFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugNativeFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugNativeFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugNativeFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugNativeFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugNativeFrame_GetIP(This,pnOffset)	\
    (This)->lpVtbl -> GetIP(This,pnOffset)

#define ICorDebugNativeFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugNativeFrame_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugNativeFrame_GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugNativeFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_SetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetRegisterSet_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugNativeFrame_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister reg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CorDebugRegister lowWordReg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CORDB_ADDRESS lowWordAddress,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS highWordAddress,
    /* [in] */ CorDebugRegister lowWordRegister,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_CanSetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugNativeFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModule_INTERFACE_DEFINED__
#define __ICorDebugModule_INTERFACE_DEFINED__

/* interface ICorDebugModule */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dba2d8c1-e5c5-4069-8c13-10a7c6abf43d")
    ICorDebugModule : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssembly( 
            /* [out] */ ICorDebugAssembly **ppAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableJITDebugging( 
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableClassLoadCallbacks( 
            /* [in] */ BOOL bClassLoadCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromRVA( 
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditAndContinueSnapshot( 
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdModule *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDynamic( 
            /* [out] */ BOOL *pDynamic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalVariableValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInMemory( 
            /* [out] */ BOOL *pInMemory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseAddress )( 
            ICorDebugModule * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssembly )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugAssembly **ppAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugModule * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *EnableJITDebugging )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts);
        
        HRESULT ( STDMETHODCALLTYPE *EnableClassLoadCallbacks )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bClassLoadCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromRVA )( 
            ICorDebugModule * This,
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditAndContinueSnapshot )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetaDataInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugModule * This,
            /* [out] */ mdModule *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *IsDynamic )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pDynamic);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariableValue )( 
            ICorDebugModule * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugModule * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *IsInMemory )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pInMemory);
        
        END_INTERFACE
    } ICorDebugModuleVtbl;

    interface ICorDebugModule
    {
        CONST_VTBL struct ICorDebugModuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModule_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugModule_GetBaseAddress(This,pAddress)	\
    (This)->lpVtbl -> GetBaseAddress(This,pAddress)

#define ICorDebugModule_GetAssembly(This,ppAssembly)	\
    (This)->lpVtbl -> GetAssembly(This,ppAssembly)

#define ICorDebugModule_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugModule_EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)	\
    (This)->lpVtbl -> EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)

#define ICorDebugModule_EnableClassLoadCallbacks(This,bClassLoadCallbacks)	\
    (This)->lpVtbl -> EnableClassLoadCallbacks(This,bClassLoadCallbacks)

#define ICorDebugModule_GetFunctionFromToken(This,methodDef,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,methodDef,ppFunction)

#define ICorDebugModule_GetFunctionFromRVA(This,rva,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromRVA(This,rva,ppFunction)

#define ICorDebugModule_GetClassFromToken(This,typeDef,ppClass)	\
    (This)->lpVtbl -> GetClassFromToken(This,typeDef,ppClass)

#define ICorDebugModule_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugModule_GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)	\
    (This)->lpVtbl -> GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)

#define ICorDebugModule_GetMetaDataInterface(This,riid,ppObj)	\
    (This)->lpVtbl -> GetMetaDataInterface(This,riid,ppObj)

#define ICorDebugModule_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugModule_IsDynamic(This,pDynamic)	\
    (This)->lpVtbl -> IsDynamic(This,pDynamic)

#define ICorDebugModule_GetGlobalVariableValue(This,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetGlobalVariableValue(This,fieldDef,ppValue)

#define ICorDebugModule_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugModule_IsInMemory(This,pInMemory)	\
    (This)->lpVtbl -> IsInMemory(This,pInMemory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModule_GetProcess_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugModule_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetBaseAddress_Proxy( 
    ICorDebugModule * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugModule_GetBaseAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetAssembly_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugAssembly **ppAssembly);


void __RPC_STUB ICorDebugModule_GetAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetName_Proxy( 
    ICorDebugModule * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugModule_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableJITDebugging_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bTrackJITInfo,
    /* [in] */ BOOL bAllowJitOpts);


void __RPC_STUB ICorDebugModule_EnableJITDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableClassLoadCallbacks_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bClassLoadCallbacks);


void __RPC_STUB ICorDebugModule_EnableClassLoadCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdMethodDef methodDef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromRVA_Proxy( 
    ICorDebugModule * This,
    /* [in] */ CORDB_ADDRESS rva,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetClassFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugModule_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_CreateBreakpoint_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugModule_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetEditAndContinueSnapshot_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);


void __RPC_STUB ICorDebugModule_GetEditAndContinueSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetMetaDataInterface_Proxy( 
    ICorDebugModule * This,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppObj);


void __RPC_STUB ICorDebugModule_GetMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetToken_Proxy( 
    ICorDebugModule * This,
    /* [out] */ mdModule *pToken);


void __RPC_STUB ICorDebugModule_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsDynamic_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pDynamic);


void __RPC_STUB ICorDebugModule_IsDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetGlobalVariableValue_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugModule_GetGlobalVariableValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetSize_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugModule_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsInMemory_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pInMemory);


void __RPC_STUB ICorDebugModule_IsInMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModule_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunction_INTERFACE_DEFINED__
#define __ICorDebugFunction_INTERFACE_DEFINED__

/* interface ICorDebugFunction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF3-8A68-11d2-983C-0000F808342D")
    ICorDebugFunction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdMethodDef *pMethodDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVarSigToken( 
            /* [out] */ mdSignature *pmdSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVersionNumber( 
            /* [out] */ ULONG32 *pnCurrentVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdMethodDef *pMethodDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetILCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVarSigToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdSignature *pmdSig);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVersionNumber )( 
            ICorDebugFunction * This,
            /* [out] */ ULONG32 *pnCurrentVersion);
        
        END_INTERFACE
    } ICorDebugFunctionVtbl;

    interface ICorDebugFunction
    {
        CONST_VTBL struct ICorDebugFunctionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunction_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugFunction_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugFunction_GetToken(This,pMethodDef)	\
    (This)->lpVtbl -> GetToken(This,pMethodDef)

#define ICorDebugFunction_GetILCode(This,ppCode)	\
    (This)->lpVtbl -> GetILCode(This,ppCode)

#define ICorDebugFunction_GetNativeCode(This,ppCode)	\
    (This)->lpVtbl -> GetNativeCode(This,ppCode)

#define ICorDebugFunction_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugFunction_GetLocalVarSigToken(This,pmdSig)	\
    (This)->lpVtbl -> GetLocalVarSigToken(This,pmdSig)

#define ICorDebugFunction_GetCurrentVersionNumber(This,pnCurrentVersion)	\
    (This)->lpVtbl -> GetCurrentVersionNumber(This,pnCurrentVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetModule_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugFunction_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetClass_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugFunction_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdMethodDef *pMethodDef);


void __RPC_STUB ICorDebugFunction_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetILCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetILCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetNativeCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetNativeCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_CreateBreakpoint_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugFunction_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetLocalVarSigToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdSignature *pmdSig);


void __RPC_STUB ICorDebugFunction_GetLocalVarSigToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetCurrentVersionNumber_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ULONG32 *pnCurrentVersion);


void __RPC_STUB ICorDebugFunction_GetCurrentVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunction_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCode_INTERFACE_DEFINED__
#define __ICorDebugCode_INTERFACE_DEFINED__

/* interface ICorDebugCode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugCode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF4-8A68-11d2-983C-0000F808342D")
    ICorDebugCode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIL( 
            /* [out] */ BOOL *pbIL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ ULONG32 *nVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnCRemapSequencePoints( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCode * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsIL )( 
            ICorDebugCode * This,
            /* [out] */ BOOL *pbIL);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugCode * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugCode * This,
            /* [out] */ CORDB_ADDRESS *pStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *nVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnCRemapSequencePoints )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]);
        
        END_INTERFACE
    } ICorDebugCodeVtbl;

    interface ICorDebugCode
    {
        CONST_VTBL struct ICorDebugCodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCode_IsIL(This,pbIL)	\
    (This)->lpVtbl -> IsIL(This,pbIL)

#define ICorDebugCode_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugCode_GetAddress(This,pStart)	\
    (This)->lpVtbl -> GetAddress(This,pStart)

#define ICorDebugCode_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugCode_CreateBreakpoint(This,offset,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,offset,ppBreakpoint)

#define ICorDebugCode_GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)	\
    (This)->lpVtbl -> GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)

#define ICorDebugCode_GetVersionNumber(This,nVersion)	\
    (This)->lpVtbl -> GetVersionNumber(This,nVersion)

#define ICorDebugCode_GetILToNativeMapping(This,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,cMap,pcMap,map)

#define ICorDebugCode_GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)	\
    (This)->lpVtbl -> GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCode_IsIL_Proxy( 
    ICorDebugCode * This,
    /* [out] */ BOOL *pbIL);


void __RPC_STUB ICorDebugCode_IsIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetFunction_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugCode_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetAddress_Proxy( 
    ICorDebugCode * This,
    /* [out] */ CORDB_ADDRESS *pStart);


void __RPC_STUB ICorDebugCode_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetSize_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugCode_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_CreateBreakpoint_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 offset,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugCode_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetCode_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset,
    /* [in] */ ULONG32 cBufferAlloc,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ ULONG32 *pcBufferSize);


void __RPC_STUB ICorDebugCode_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetVersionNumber_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *nVersion);


void __RPC_STUB ICorDebugCode_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetILToNativeMapping_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorDebugCode_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetEnCRemapSequencePoints_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ ULONG32 offsets[  ]);


void __RPC_STUB ICorDebugCode_GetEnCRemapSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCode_INTERFACE_DEFINED__ */


#ifndef __ICorDebugClass_INTERFACE_DEFINED__
#define __ICorDebugClass_INTERFACE_DEFINED__

/* interface ICorDebugClass */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF5-8A68-11d2-983C-0000F808342D")
    ICorDebugClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdTypeDef *pTypeDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugClass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugClass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugClass * This,
            /* [out] */ ICorDebugModule **pModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugClass * This,
            /* [out] */ mdTypeDef *pTypeDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldValue )( 
            ICorDebugClass * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugClassVtbl;

    interface ICorDebugClass
    {
        CONST_VTBL struct ICorDebugClassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugClass_GetModule(This,pModule)	\
    (This)->lpVtbl -> GetModule(This,pModule)

#define ICorDebugClass_GetToken(This,pTypeDef)	\
    (This)->lpVtbl -> GetToken(This,pTypeDef)

#define ICorDebugClass_GetStaticFieldValue(This,fieldDef,pFrame,ppValue)	\
    (This)->lpVtbl -> GetStaticFieldValue(This,fieldDef,pFrame,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugClass_GetModule_Proxy( 
    ICorDebugClass * This,
    /* [out] */ ICorDebugModule **pModule);


void __RPC_STUB ICorDebugClass_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetToken_Proxy( 
    ICorDebugClass * This,
    /* [out] */ mdTypeDef *pTypeDef);


void __RPC_STUB ICorDebugClass_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetStaticFieldValue_Proxy( 
    ICorDebugClass * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugClass_GetStaticFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugClass_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEval_INTERFACE_DEFINED__
#define __ICorDebugEval_INTERFACE_DEFINED__

/* interface ICorDebugEval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF6-8A68-11d2-983C-0000F808342D")
    ICorDebugEval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallFunction( 
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObject( 
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObjectNoConstructor( 
            /* [in] */ ICorDebugClass *pClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewString( 
            /* [in] */ LPCWSTR string) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewArray( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ ICorDebugValue **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValue( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEvalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEval * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallFunction )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObject )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObjectNoConstructor )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugClass *pClass);
        
        HRESULT ( STDMETHODCALLTYPE *NewString )( 
            ICorDebugEval * This,
            /* [in] */ LPCWSTR string);
        
        HRESULT ( STDMETHODCALLTYPE *NewArray )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugEval * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugValue **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValue )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugEvalVtbl;

    interface ICorDebugEval
    {
        CONST_VTBL struct ICorDebugEvalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEval_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEval_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEval_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEval_CallFunction(This,pFunction,nArgs,ppArgs)	\
    (This)->lpVtbl -> CallFunction(This,pFunction,nArgs,ppArgs)

#define ICorDebugEval_NewObject(This,pConstructor,nArgs,ppArgs)	\
    (This)->lpVtbl -> NewObject(This,pConstructor,nArgs,ppArgs)

#define ICorDebugEval_NewObjectNoConstructor(This,pClass)	\
    (This)->lpVtbl -> NewObjectNoConstructor(This,pClass)

#define ICorDebugEval_NewString(This,string)	\
    (This)->lpVtbl -> NewString(This,string)

#define ICorDebugEval_NewArray(This,elementType,pElementClass,rank,dims,lowBounds)	\
    (This)->lpVtbl -> NewArray(This,elementType,pElementClass,rank,dims,lowBounds)

#define ICorDebugEval_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugEval_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define ICorDebugEval_GetResult(This,ppResult)	\
    (This)->lpVtbl -> GetResult(This,ppResult)

#define ICorDebugEval_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugEval_CreateValue(This,elementType,pElementClass,ppValue)	\
    (This)->lpVtbl -> CreateValue(This,elementType,pElementClass,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEval_CallFunction_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_CallFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObject_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pConstructor,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_NewObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObjectNoConstructor_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugClass *pClass);


void __RPC_STUB ICorDebugEval_NewObjectNoConstructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewString_Proxy( 
    ICorDebugEval * This,
    /* [in] */ LPCWSTR string);


void __RPC_STUB ICorDebugEval_NewString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewArray_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [in] */ ULONG32 rank,
    /* [size_is][in] */ ULONG32 dims[  ],
    /* [size_is][in] */ ULONG32 lowBounds[  ]);


void __RPC_STUB ICorDebugEval_NewArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_IsActive_Proxy( 
    ICorDebugEval * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugEval_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_Abort_Proxy( 
    ICorDebugEval * This);


void __RPC_STUB ICorDebugEval_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetResult_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugValue **ppResult);


void __RPC_STUB ICorDebugEval_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetThread_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugEval_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_CreateValue_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugEval_CreateValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEval_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValue_INTERFACE_DEFINED__
#define __ICorDebugValue_INTERFACE_DEFINED__

/* interface ICorDebugValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF7-8A68-11d2-983C-0000F808342D")
    ICorDebugValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugValueVtbl;

    interface ICorDebugValue
    {
        CONST_VTBL struct ICorDebugValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValue_GetType_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugValue_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetSize_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ULONG32 *pSize);


void __RPC_STUB ICorDebugValue_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetAddress_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugValue_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_CreateBreakpoint_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugValue_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugGenericValue_INTERFACE_DEFINED__
#define __ICorDebugGenericValue_INTERFACE_DEFINED__

/* interface ICorDebugGenericValue */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebugGenericValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF8-8A68-11d2-983C-0000F808342D")
    ICorDebugGenericValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ void *pTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ void *pFrom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugGenericValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugGenericValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugGenericValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugGenericValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugGenericValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugGenericValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugGenericValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugGenericValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugGenericValue * This,
            /* [out] */ void *pTo);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugGenericValue * This,
            /* [in] */ void *pFrom);
        
        END_INTERFACE
    } ICorDebugGenericValueVtbl;

    interface ICorDebugGenericValue
    {
        CONST_VTBL struct ICorDebugGenericValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugGenericValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugGenericValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugGenericValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugGenericValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugGenericValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugGenericValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugGenericValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugGenericValue_GetValue(This,pTo)	\
    (This)->lpVtbl -> GetValue(This,pTo)

#define ICorDebugGenericValue_SetValue(This,pFrom)	\
    (This)->lpVtbl -> SetValue(This,pFrom)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_GetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [out] */ void *pTo);


void __RPC_STUB ICorDebugGenericValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_SetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [in] */ void *pFrom);


void __RPC_STUB ICorDebugGenericValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugGenericValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugReferenceValue_INTERFACE_DEFINED__
#define __ICorDebugReferenceValue_INTERFACE_DEFINED__

/* interface ICorDebugReferenceValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugReferenceValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF9-8A68-11d2-983C-0000F808342D")
    ICorDebugReferenceValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsNull( 
            /* [out] */ BOOL *pbNull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ CORDB_ADDRESS *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ CORDB_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dereference( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DereferenceStrong( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugReferenceValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugReferenceValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugReferenceValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugReferenceValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsNull )( 
            ICorDebugReferenceValue * This,
            /* [out] */ BOOL *pbNull);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugReferenceValue * This,
            /* [in] */ CORDB_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *Dereference )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *DereferenceStrong )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugReferenceValueVtbl;

    interface ICorDebugReferenceValue
    {
        CONST_VTBL struct ICorDebugReferenceValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugReferenceValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugReferenceValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugReferenceValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugReferenceValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugReferenceValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugReferenceValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugReferenceValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugReferenceValue_IsNull(This,pbNull)	\
    (This)->lpVtbl -> IsNull(This,pbNull)

#define ICorDebugReferenceValue_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ICorDebugReferenceValue_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#define ICorDebugReferenceValue_Dereference(This,ppValue)	\
    (This)->lpVtbl -> Dereference(This,ppValue)

#define ICorDebugReferenceValue_DereferenceStrong(This,ppValue)	\
    (This)->lpVtbl -> DereferenceStrong(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_IsNull_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ BOOL *pbNull);


void __RPC_STUB ICorDebugReferenceValue_IsNull_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_GetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ CORDB_ADDRESS *pValue);


void __RPC_STUB ICorDebugReferenceValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_SetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [in] */ CORDB_ADDRESS value);


void __RPC_STUB ICorDebugReferenceValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_Dereference_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_Dereference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_DereferenceStrong_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_DereferenceStrong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugReferenceValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHeapValue_INTERFACE_DEFINED__
#define __ICorDebugHeapValue_INTERFACE_DEFINED__

/* interface ICorDebugHeapValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHeapValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFA-8A68-11d2-983C-0000F808342D")
    ICorDebugHeapValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsValid( 
            /* [out] */ BOOL *pbValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRelocBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHeapValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHeapValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHeapValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHeapValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugHeapValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugHeapValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugHeapValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugHeapValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugHeapValueVtbl;

    interface ICorDebugHeapValue
    {
        CONST_VTBL struct ICorDebugHeapValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHeapValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHeapValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHeapValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHeapValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugHeapValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugHeapValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugHeapValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugHeapValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugHeapValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_IsValid_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ BOOL *pbValid);


void __RPC_STUB ICorDebugHeapValue_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_CreateRelocBreakpoint_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugHeapValue_CreateRelocBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHeapValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectValue_INTERFACE_DEFINED__
#define __ICorDebugObjectValue_INTERFACE_DEFINED__

/* interface ICorDebugObjectValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18AD3D6E-B7D2-11d2-BD04-0000F80849BD")
    ICorDebugObjectValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldValue( 
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualMethod( 
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueClass( 
            /* [out] */ BOOL *pbIsValueClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManagedCopy( 
            /* [out] */ IUnknown **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFromManagedCopy( 
            /* [in] */ IUnknown *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugObjectValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugObjectValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugObjectValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugObjectValue * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugObjectValue * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugObjectValueVtbl;

    interface ICorDebugObjectValue
    {
        CONST_VTBL struct ICorDebugObjectValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugObjectValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugObjectValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugObjectValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugObjectValue_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugObjectValue_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugObjectValue_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugObjectValue_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugObjectValue_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugObjectValue_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugObjectValue_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugObjectValue_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetFieldValue_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ ICorDebugClass *pClass,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugObjectValue_GetFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetVirtualMethod_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ mdMemberRef memberRef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugObjectValue_GetVirtualMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetContext_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugObjectValue_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_IsValueClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ BOOL *pbIsValueClass);


void __RPC_STUB ICorDebugObjectValue_IsValueClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ IUnknown **ppObject);


void __RPC_STUB ICorDebugObjectValue_GetManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_SetFromManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ IUnknown *pObject);


void __RPC_STUB ICorDebugObjectValue_SetFromManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBoxValue_INTERFACE_DEFINED__
#define __ICorDebugBoxValue_INTERFACE_DEFINED__

/* interface ICorDebugBoxValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBoxValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFC-8A68-11d2-983C-0000F808342D")
    ICorDebugBoxValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugObjectValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBoxValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBoxValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBoxValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBoxValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugBoxValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugBoxValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugBoxValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugBoxValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugObjectValue **ppObject);
        
        END_INTERFACE
    } ICorDebugBoxValueVtbl;

    interface ICorDebugBoxValue
    {
        CONST_VTBL struct ICorDebugBoxValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBoxValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBoxValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBoxValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBoxValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugBoxValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugBoxValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugBoxValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugBoxValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBoxValue_GetObject_Proxy( 
    ICorDebugBoxValue * This,
    /* [out] */ ICorDebugObjectValue **ppObject);


void __RPC_STUB ICorDebugBoxValue_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBoxValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStringValue_INTERFACE_DEFINED__
#define __ICorDebugStringValue_INTERFACE_DEFINED__

/* interface ICorDebugStringValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStringValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFD-8A68-11d2-983C-0000F808342D")
    ICorDebugStringValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ ULONG32 *pcchString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStringValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStringValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStringValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStringValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugStringValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugStringValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugStringValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pcchString);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugStringValue * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugStringValueVtbl;

    interface ICorDebugStringValue
    {
        CONST_VTBL struct ICorDebugStringValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStringValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStringValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStringValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStringValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugStringValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugStringValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugStringValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugStringValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_GetLength(This,pcchString)	\
    (This)->lpVtbl -> GetLength(This,pcchString)

#define ICorDebugStringValue_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetLength_Proxy( 
    ICorDebugStringValue * This,
    /* [out] */ ULONG32 *pcchString);


void __RPC_STUB ICorDebugStringValue_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetString_Proxy( 
    ICorDebugStringValue * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugStringValue_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStringValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugArrayValue_INTERFACE_DEFINED__
#define __ICorDebugArrayValue_INTERFACE_DEFINED__

/* interface ICorDebugArrayValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugArrayValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0405B0DF-A660-11d2-BD02-0000F80849BD")
    ICorDebugArrayValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElementType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRank( 
            /* [out] */ ULONG32 *pnRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG32 *pnCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDimensions( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasBaseIndicies( 
            /* [out] */ BOOL *pbHasBaseIndicies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseIndicies( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementAtPosition( 
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugArrayValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugArrayValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugArrayValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugArrayValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugArrayValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRank )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDimensions )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *HasBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbHasBaseIndicies);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementAtPosition )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugArrayValueVtbl;

    interface ICorDebugArrayValue
    {
        CONST_VTBL struct ICorDebugArrayValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugArrayValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugArrayValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugArrayValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugArrayValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugArrayValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugArrayValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugArrayValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugArrayValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_GetElementType(This,pType)	\
    (This)->lpVtbl -> GetElementType(This,pType)

#define ICorDebugArrayValue_GetRank(This,pnRank)	\
    (This)->lpVtbl -> GetRank(This,pnRank)

#define ICorDebugArrayValue_GetCount(This,pnCount)	\
    (This)->lpVtbl -> GetCount(This,pnCount)

#define ICorDebugArrayValue_GetDimensions(This,cdim,dims)	\
    (This)->lpVtbl -> GetDimensions(This,cdim,dims)

#define ICorDebugArrayValue_HasBaseIndicies(This,pbHasBaseIndicies)	\
    (This)->lpVtbl -> HasBaseIndicies(This,pbHasBaseIndicies)

#define ICorDebugArrayValue_GetBaseIndicies(This,cdim,indicies)	\
    (This)->lpVtbl -> GetBaseIndicies(This,cdim,indicies)

#define ICorDebugArrayValue_GetElement(This,cdim,indices,ppValue)	\
    (This)->lpVtbl -> GetElement(This,cdim,indices,ppValue)

#define ICorDebugArrayValue_GetElementAtPosition(This,nPosition,ppValue)	\
    (This)->lpVtbl -> GetElementAtPosition(This,nPosition,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementType_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugArrayValue_GetElementType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetRank_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnRank);


void __RPC_STUB ICorDebugArrayValue_GetRank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetCount_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnCount);


void __RPC_STUB ICorDebugArrayValue_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetDimensions_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 dims[  ]);


void __RPC_STUB ICorDebugArrayValue_GetDimensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_HasBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ BOOL *pbHasBaseIndicies);


void __RPC_STUB ICorDebugArrayValue_HasBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 indicies[  ]);


void __RPC_STUB ICorDebugArrayValue_GetBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElement_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][in] */ ULONG32 indices[  ],
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementAtPosition_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 nPosition,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElementAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugArrayValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugContext_INTERFACE_DEFINED__
#define __ICorDebugContext_INTERFACE_DEFINED__

/* interface ICorDebugContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB00-8A68-11d2-983C-0000F808342D")
    ICorDebugContext : public ICorDebugObjectValue
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugContext * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugContext * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugContext * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugContext * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugContext * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugContext * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugContext * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugContext * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugContextVtbl;

    interface ICorDebugContext
    {
        CONST_VTBL struct ICorDebugContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugContext_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugContext_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugContext_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugContext_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugContext_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugContext_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugContext_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugContext_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugContext_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugContext_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugContext_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICorDebugContext_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEnum_INTERFACE_DEFINED__
#define __ICorDebugEnum_INTERFACE_DEFINED__

/* interface ICorDebugEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB01-8A68-11d2-983C-0000F808342D")
    ICorDebugEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorDebugEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugEnum * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } ICorDebugEnumVtbl;

    interface ICorDebugEnum
    {
        CONST_VTBL struct ICorDebugEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEnum_Skip_Proxy( 
    ICorDebugEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorDebugEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Reset_Proxy( 
    ICorDebugEnum * This);


void __RPC_STUB ICorDebugEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Clone_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ICorDebugEnum **ppEnum);


void __RPC_STUB ICorDebugEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_GetCount_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorDebugEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectEnum_INTERFACE_DEFINED__
#define __ICorDebugObjectEnum_INTERFACE_DEFINED__

/* interface ICorDebugObjectEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB02-8A68-11d2-983C-0000F808342D")
    ICorDebugObjectEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugObjectEnumVtbl;

    interface ICorDebugObjectEnum
    {
        CONST_VTBL struct ICorDebugObjectEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugObjectEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugObjectEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugObjectEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugObjectEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectEnum_Next_Proxy( 
    ICorDebugObjectEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugObjectEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_INTERFACE_DEFINED__
#define __ICorDebugBreakpointEnum_INTERFACE_DEFINED__

/* interface ICorDebugBreakpointEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpointEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB03-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpointEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpointEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugBreakpointEnumVtbl;

    interface ICorDebugBreakpointEnum
    {
        CONST_VTBL struct ICorDebugBreakpointEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpointEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpointEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpointEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpointEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugBreakpointEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugBreakpointEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugBreakpointEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugBreakpointEnum_Next(This,celt,breakpoints,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,breakpoints,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpointEnum_Next_Proxy( 
    ICorDebugBreakpointEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugBreakpointEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpointEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepperEnum_INTERFACE_DEFINED__
#define __ICorDebugStepperEnum_INTERFACE_DEFINED__

/* interface ICorDebugStepperEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStepperEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB04-8A68-11d2-983C-0000F808342D")
    ICorDebugStepperEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepperEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepperEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugStepperEnumVtbl;

    interface ICorDebugStepperEnum
    {
        CONST_VTBL struct ICorDebugStepperEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepperEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepperEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepperEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepperEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugStepperEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugStepperEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugStepperEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define 