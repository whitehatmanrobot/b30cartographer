N_HEADERS[MAX_COLUMNS] =
{
    IDS_OPTCFG_NAME,
    IDS_OPTCFG_COMMENT
};

int COLUMN_WIDTHS[MAX_COLUMNS] =
{
    150, 175
};

const DWORD * OPTION_CONTROL_HELP_ARRAYS[] =
{
    g_aHelpIDs_IDD_DATA_ENTRY_DWORD,
    g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS,
    g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS_ARRAY,
    g_aHelpIDs_IDD_DATA_ENTRY_BINARY,
    g_aHelpIDs_IDD_DATA_ENTRY_BINARY_ARRAY,
    g_aHelpIDs_IDD_DATA_ENTRY_STRING,
    g_aHelpIDs_IDD_DATA_ENTRY_ROUTE_ARRAY,
    g_aHelpIDs_IDD_DATA_ENTRY_STRING_ARRAY
};


// class CHelpMap
CHelpMap::CHelpMap()
{
    m_pdwHelpMap = NULL;
}

CHelpMap::~CHelpMap()
{
    ResetMap();
}

void
CHelpMap::BuildMap(DWORD pdwParentHelpMap[])
{
    int i, j, nPos;
    int nSize = 0;
    int nCurSize;

    ResetMap();

    // calculate the size of the map
    // subtract off the terminators
    nSize += CountMap(pdwParentHelpMap); 

    for (i = 0; i < ARRAYLEN(OPTION_CONTROL_HELP_ARRAYS); i++)
    {
        nSize += CountMap(OPTION_CONTROL_HELP_ARRAYS[i]);
    }

    nSize += 2; // for terminator

    m_pdwHelpMap = new DWORD[nSize];
    memset(m_pdwHelpMap, 0, sizeof(*m_pdwHelpMap));

    // fill in the parent help map
    nPos = 0;
    nCurSize = CountMap(pdwParentHelpMap);
    for (i = 0; i < nCurSize; i++)
    {
        m_pdwHelpMap[nPos++] = pdwParentHelpMap[i++];
        m_pdwHelpMap[nPos++] = pdwParentHelpMap[i];
    }

    // now add all of the possible option control help maps
    for (i = 0; i < ARRAYLEN(OPTION_CONTROL_HELP_ARRAYS); i++)
    {
        nCurSize = CountMap(OPTION_CONTROL_HELP_ARRAYS[i]);
        for (j = 0; j < nCurSize; j++)
        {
            m_pdwHelpMap[nPos++] = (OPTION_CONTROL_HELP_ARRAYS[i])[j++];
            m_pdwHelpMap[nPos++] = (OPTION_CONTROL_HELP_ARRAYS[i])[j];
        }
    }
}

DWORD * CHelpMap::GetMap()
{
    return m_pdwHelpMap;
}

int CHelpMap::CountMap(const DWORD * pdwHelpMap)
{
    int i = 0;

    while (pdwHelpMap[i] != 0)
    {
        i++;
    }

    return i++;
}

void CHelpMap::ResetMap()
{
    if (m_pdwHelpMap)
    {
        delete m_pdwHelpMap;
        m_pdwHelpMap = NULL;
    }
}

DEBUG_DECLARE_INSTANCE_COUNTER(COptionsConfig);

/////////////////////////////////////////////////////////////////////////////
//
// COptionsConfig holder
//
/////////////////////////////////////////////////////////////////////////////
COptionsConfig::COptionsConfig
(
   ITFSNode *              pNode,
   ITFSNode *              pServerNode,
   IComponentData *        pComponentData,
   ITFSComponentData *        pTFSCompData,
   COptionValueEnum *          pOptionValueEnum,
   LPCTSTR                 pszSheetName,
    CDhcpOptionItem *           pSelOption
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(COptionsConfig);

    //ASSERT(pFolderNode == GetContainerNode());

   m_bAutoDeletePages = FALSE; // we have the pages as embedded members

   AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    LARGE_INTEGER liServerVersion;
    CDhcpServer * pServer = GETHANDLER(CDhcpServer, pServerNode);
    
    pServer->GetVersion(m_liServerVersion);
    if (m_liServerVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        AddPageToList((CPropertyPageBase*) &m_pageAdvanced);
    }

   Assert(pTFSCompData != NULL);
   m_spTFSCompData.Set(pTFSCompData);
   m_spServerNode.Set(pServerNode);

   // get all of the active options for this node
   SPITFSNode spNode;
   spNode = GetNode();

   m_bInitialized = FALSE;

    m_pOptionValueEnum = pOptionValueEnum;

    if (pSelOption)
    {
        m_strStartVendor = pSelOption->GetVendor();
        m_strStartClass = pSelOption->GetClassName();
        m_dhcpStartId = pSelOption->GetOptionId();
    }
    else
    {
        m_dhcpStartId = 0xffffffff;
    }
}

COptionsConfig::~COptionsConfig()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(COptionsConfig);

   RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
   RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}

DWORD
COptionsConfig::InitData()
{
   DWORD dwErr = NO_ERROR;

   if (m_bInitialized)
      return dwErr;

    CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spServerNode);
    CClassInfoArray ClassInfoArray;

    pServer->GetClassInfoArray(ClassInfoArray);

    // create a standard DHCP options vendor tracker and a set of default class options
    CVendorTracker * pVendorTracker = AddVendorTracker(_T(""));
    AddClassTracker(pVendorTracker, _T(""));

    // walk the list of classes.  For each vendor class, add a default user class.
    for (int i = 0; i < ClassInfoArray.GetSize(); i++)
    {
        if (ClassInfoArray[i].bIsVendor)
        {
            // create a vendor tracker and a set of default class options
            pVendorTracker = AddVendorTracker(ClassInfoArray[i].strName);
            AddClassTracker(pVendorTracker, _T(""));
        }
    }

    // now walk the list of vendor classes and add User class option lists 
    POSITION pos = m_listVendorClasses.GetHeadPosition();
    while (pos)
    {
        pVendorTracker = m_listVendorClasses.GetNext(pos);

        // now build option sets for each user class in each vendor
        for (int j = 0; j < ClassInfoArray.GetSize(); j++)
        {
            if (!ClassInfoArray[j].bIsVendor)
                AddClassTracker(pVendorTracker, ClassInfoArray[j].strName);
        }
    }

    // now we need to update any active options with their current values
    UpdateActiveOptions();

    m_bInitialized = TRUE;

    return dwErr;
}

void
COptionsConfig::SetTitle()
{
    HWND hSheet = GetSheetWindow();
    ::SetWindowText(hSheet, m_stSheetTitle);
}

LPWSTR COptionsConfig::GetServerAddress()
{
    CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spServerNode);
    return (LPWSTR) pServer->GetIpAddress();
}

CVendorTracker *
COptionsConfig::AddVendorTracker(LPCTSTR pClassName)
{
    CVendorTracker * pVendorTracker = new CVendorTracker();
    pVendorTracker->SetClassName(pClassName);

    m_listVendorClasses.AddTail(pVendorTracker);

    return pVendorTracker;
}

void COptionsConfig::AddClassTracker(CVendorTracker * pVendorTracker, LPCTSTR pClassName)
{
    SPITFSNode spServerNode;
    
    spServerNode = GetServerNode();
    CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);
    
    CClassTracker * pClassTracker = new CClassTracker();
    pClassTracker->SetClassName(pClassName);
    
    // add the new class tracker to the list.
    pVendorTracker->m_listUserClasses.AddTail(pClassTracker);
    
    // Get a pointer to the list of options on the server.  We use this
    // to build our list of available options for this class
    CDhcpOption * pCurOption;
    CDhcpDefaultOptionsOnServer * pDefOptions = pServer->GetDefaultOptionsList();
    
    CString strVendor = pVendorTracker->GetClassName();
    CString strUserClass = pClassName;
    
    pCurOption = pDefOptions->First();
    while (pCurOption) {
   DHCP_OPTION_ID id = pCurOption->QueryId();
   
        // we filter out some options:
        // 1 - standard options with no user class call FilterOption
        // 2 - standard options with a user class call FilterUserClassOptions
        if ( (strVendor.IsEmpty() && !FilterOption(id) && !pCurOption->IsVendor()) ||
             (strVendor.IsEmpty() && !pCurOption->IsVendor() &&
         !strUserClass.IsEmpty() && !FilterUserClassOption(id)) ||
             (pCurOption->GetVendor() && strVendor.Compare(pCurOption->GetVendor()) == 0) )
       {
         // create an option item for this entry. We do this because 
      // these options are stored in the server node, but since this is a modeless
      // dialog the values could change, so we'll take a snapshot of the data
      // we can just use the copy constructor of the CDhcpOption
      COptionTracker * pOptionTracker = new COptionTracker;
      CDhcpOption * pNewOption = new CDhcpOption(*pCurOption);
      
      pOptionTracker->m_pOption = pNewOption;
      
      // add the option to the class tracker
      pClassTracker->m_listOptions.AddTail(pOptionTracker);
       }
   
   pCurOption = pDefOptions->Next();
    }
}

void COptionsConfig::UpdateActiveOptions()
{
    // Now the known options are in the correct locations.  We need to see
    // what options are enabled for this node.  We querried the server to make
    // sure we have the latest information about active options.
    m_pOptionValueEnum->Reset();
    CDhcpOption * pOption;
    
    while (pOption = m_pOptionValueEnum->Next()) {
   DHCP_OPTION_ID optionId = pOption->QueryId();
   
   // search all vendors options
   POSITION pos = m_listVendorClasses.GetHeadPosition();
   while (pos) {
       // search all vendor classes
       CVendorTracker * pVendorTracker = m_listVendorClasses.GetNext(pos);
       CString strVendor = pOption->GetVendor();
       
       if (pVendorTracker->m_strClassName.Compare(strVendor) == 0)   {
      // ok, the vendor class matches so lets check user classes
      POSITION pos2 = pVendorTracker->m_listUserClasses.GetHeadPosition();
      while (pos2) {
          CClassTracker * pClassTracker = pVendorTracker->m_listUserClasses.GetNext(pos2);
          
          // check to see if this option belongs to this class
          if ( (pClassTracker->m_strClassName.IsEmpty()) &&
          (!pOption->IsClassOption()) ) {
                        // both are empty... match.
                    }
                    else if (( pClassTracker->m_strClassName.IsEmpty() && pOption->IsClassOption()) ||
              ( !pClassTracker->m_strClassName.IsEmpty() && !pOption->IsClassOption())) {
                        // either the current option or the current class is null...
                        continue;
                    }
                    else if (pClassTracker->m_strClassName.CompareNoCase(pOption->GetClassName()) != 0) {
                        // both names are non-null and they don't match... keep looking
                        continue;
                    }
          
                    // Ok, the class the option belong to is the same as the one we are currently
                    // looking at.  Loop through the default options for this class and update it's 
                    // state and value.
                    POSITION posOption = pClassTracker->m_listOptions.GetHeadPosition();
          while (posOption) {
         COptionTracker * pCurOptTracker = pClassTracker->m_listOptions.GetNext(posOption);
         CDhcpOption * pCurOption = pCurOptTracker->m_pOption;
         
         if (( pCurOption->QueryId() == pOption->QueryId()) &&
                             (( pCurOption->IsVendor() && pOption->IsVendor()) ||
               ( !pCurOption->IsVendor() && !pOption->IsVendor()))) {
             // update this option
             CDhcpOptionValue OptValue = pOption->QueryValue();
             pCurOption->Update(OptValue);
             pCurOptTracker->SetInitialState(OPTION_STATE_ACTIVE);
             pCurOptTracker->SetCurrentState(OPTION_STATE_ACTIVE);
             
                            break;
         } // if
                    } // while option list
                } // while User class list
            } // endif vendor class name compre
        } // while list of vendor classes
    } // while

} // COptionsConfig::UpdateActiveOptions()

void COptionsConfig::FillOptions(LPCTSTR pVendorName, LPCTSTR pUserClassName, CMyListCtrl & ListCtrl)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // look for the requested class and fill in the listbox
   // with all options for that class
    CString strVendorStandard, strClassStandard, strTargetVendor, strTargetClass;
    CString strTypeVendor, strTypeStandard;
    strVendorStandard.LoadString(IDS_INFO_NAME_DHCP_DEFAULT);
   strClassStandard.LoadString(IDS_USER_STANDARD);

    if (strVendorStandard.Compare(pVendorName) != 0)
        strTargetVendor = pVendorName;

    if (strClassStandard.Compare(pUserClassName) != 0)
        strTargetClass = pUserClassName;

   POSITION posv = m_listVendorClasses.GetHeadPosition();
    while (posv)
    {
        // find the right vendor
        CVendorTracker * pVendorTracker = m_listVendorClasses.GetNext(posv);
        if (pVendorTracker->m_strClassName.Compare(strTargetVendor) == 0)
        {
            POSITION pos = NULL;
           pos = pVendorTracker->m_listUserClasses.GetHeadPosition();
           while (pos)
           {
              // now find the right user class
                CClassTracker * pClassTracker = pVendorTracker->m_listUserClasses.GetNext(pos);
              if (pClassTracker->m_strClassName.Compare(strTargetClass) == 0)
              {
                 // this is the class, add all of the options to the listbox
                 CString strDisplay, strType, strComment;

                 POSITION posOption = NULL;
                 posOption = pClassTracker->m_listOptions.GetHeadPosition();
                 while (posOption)
                 {
                    COptionTracker * pOptionTracker = pClassTracker->m_listOptions.GetNext(posOption);

                    pOptionTracker->m_pOption->QueryDisplayName(strDisplay);
                    strComment = pOptionTracker->m_pOption->QueryComment();
                    strType = pOptionTracker->m_pOption->IsVendor() ? strTypeVendor : strTypeStandard;

                    int nIndex = ListCtrl.AddItem(strDisplay, strComment, LISTVIEWEX_NOT_CHECKED);

                    ListCtrl.SetItemData(nIndex, (LPARAM) pOptionTracker);

                    if (pOptionTracker->GetCurrentState() == OPTION_STATE_ACTIVE)
                       ListCtrl.CheckItem(nIndex);
                 }

                 break;
              }
      } // while
   } // if 
    } // while

    // Finally, Set the column widths so that all items are visible.
    // Set the default column widths to the width of the widest column
    int aColWidth[ MAX_COLUMNS];

    int nRow, nCol;
    CString strTemp;
    
    ZeroMemory(aColWidth, MAX_COLUMNS * sizeof(int));
    CopyMemory(aColWidth, &COLUMN_WIDTHS, sizeof(MAX_COLUMNS * sizeof(int)));

    // for each item, loop through each column and calculate the correct width
    for (nRow = 0; nRow < ListCtrl.GetItemCount(); nRow++)
    {
        for (nCol = 0; nCol < MAX_COLUMNS; nCol++)
        {
            strTemp = ListCtrl.GetItemText(nRow, nCol);
            if (aColWidth[nCol] < ListCtrl.GetStringWidth(strTemp))
                aColWidth[nCol] = ListCtrl.GetStringWidth(strTemp);
        }
    }
    
    // now update the column widths based on what we calculated
    for (nCol = 0; nCol < MAX_COLUMNS; nCol++)
    {
        // GetStringWidth doesn't seem to report the right thing,
        // so we have to add a fudge factor of 15.... oh well.
        if (aColWidth[nCol] > 0)
            ListCtrl.SetColumnWidth(nCol, aColWidth[nCol] + 15);
    }

} // COptionsConfig::FillOptions()

/////////////////////////////////////////////////////////////////////////////
// COptionsCfgBasic property page

IMPLEMENT_DYNCREATE(COptionsCfgPropPage, CPropertyPageBase)

COptionsCfgPropPage::COptionsCfgPropPage() : 
   CPropertyPageBase(COptionsCfgPropPage::IDD),
   m_bInitialized(FALSE)
{
    LoadBitmaps();

    m_helpMap.BuildMap(DhcpGetHelpMap(COptionsCfgPropPage::IDD));
}

COptionsCfgPropPage::COptionsCfgPropPage(UINT nIDTemplate, UINT nIDCaption) : 
   CPropertyPageBase(nIDTemplate, nIDCaption),
   m_bInitialized(FALSE)
{
   //{{AFX_DATA_INIT(COptionsCfgPropPage)
   //}}AFX_DATA_INIT
    
    LoadBitmaps();

    m_helpMap.BuildMap(DhcpGetHelpMap(COptionsCfgPropPage::IDD));
}

COptionsCfgPropPage::~COptionsCfgPropPage()
{
}

void
COptionsCfgPropPage::LoadBitmaps()
{
}

void COptionsCfgPropPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COptionsCfgPropPage)
    DDX_Control(pDX, IDC_LIST_OPTIONS, m_listctrlOptions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsCfgPropPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(COptionsCfgPropPage)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_OPTIONS, OnItemchangedListOptions)
    //}}AFX_MSG_MAP
    
    ON_MESSAGE(WM_SELECTOPTION, OnSelectOption)
    
    // Binary array controls
    ON_EN_CHANGE(IDC_EDIT_VALUE, OnChangeEditValue)
    ON_BN_CLICKED(IDC_BUTTON_VALUE_UP, OnButtonValueUp)
    ON_BN_CLICKED(IDC_BUTTON_VALUE_DOWN, OnButtonValueDown)
    ON_BN_CLICKED(IDC_BUTTON_VALUE_ADD, OnButtonValueAdd)
    ON_BN_CLICKED(IDC_BUTTON_VALUE_DELETE, OnButtonValueDelete)
    ON_BN_CLICKED(IDC_RADIO_DECIMAL, OnClickedRadioDecimal)
    ON_BN_CLICKED(IDC_RADIO_HEX, OnClickedRadioHex)
    ON_LBN_SELCHANGE(IDC_LIST_VALUES, OnSelchangeListValues)
    
    // Byte, WORD and Long edit control
    ON_EN_CHANGE(IDC_EDIT_DWORD, OnChangeEditDword)
    
    // string edit control
    ON_EN_CHANGE(IDC_EDIT_STRING_VALUE, OnChangeEditString)
    
    // IP Address control
    ON_EN_CHANGE(IDC_IPADDR_ADDRESS, OnChangeIpAddress)
    
    // IP Address array controls
    ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
    ON_EN_CHANGE(IDC_IPADDR_SERVER_ADDRESS, OnChangeIpAddressArray)
    ON_BN_CLICKED(IDC_BUTTON_RESOLVE, OnButtonResolve)
    ON_BN_CLICKED(IDC_BUTTON_IPADDR_UP, OnButtonIpAddrUp)
    ON_BN_CLICKED(IDC_BUTTON_IPADDR_DOWN, OnButtonIpAddrDown)
    ON_BN_CLICKED(IDC_BUTTON_IPADDR_ADD, OnButtonIpAddrAdd)
    ON_BN_CLICKED(IDC_BUTTON_IPADDR_DELETE, OnButtonIpAddrDelete)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRS, OnSelchangeListIpAddrs)
    
    // binary and encapsulated data
    ON_EN_CHANGE(IDC_VALUEDATA, OnChangeValueData)
    
    // route array controls
    ON_BN_CLICKED(IDC_BUTTON_ROUTE_ADD, OnButtonAddRoute)
    ON_BN_CLICKED(IDC_BUTTON_ROUTE_DEL, OnButtonDelRoute)

    // string array controls
    ON_EN_CHANGE(IDC_EDIT_STRING, OnChangeStringArrayValue)
    ON_LBN_SELCHANGE(IDC_LIST_STRING_ARRAY, OnSelChangeStringArrayList)
    ON_BN_CLICKED(IDC_BUTTON_STRING_ARRAY_ADD, OnButtonStringArrayAdd)
    ON_BN_CLICKED(IDC_BUTTON_STRING_ARRAY_REMOVE, OnButtonStringArrayRemove)
    ON_BN_CLICKED(IDC_BUTTON_STRING_ARRAY_UP, OnButtonStringArrayUp)
    ON_BN_CLICKED(IDC_BUTTON_STRING_ARRAY_DOWN, OnButtonStringArrayDown)
    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionsCfgPropPage message handlers
afx_msg long COptionsCfgPropPage::OnSelectOption(UINT wParam, LONG lParam) 
{
    COptionsConfig * pOptionsConfig = (COptionsConfig *) GetHolder();

    if (wParam != NULL)
    {
        CDhcpOptionItem * pOptItem = (CDhcpOptionItem *) ULongToPtr(wParam);
        HWND hWnd = NULL;

        pOptionsConfig->m_strStartVendor = pOptItem->GetVendor();
        pOptionsConfig->m_strStartClass = pOptItem->GetClassName();
        pOptionsConfig->m_dhcpStartId = pOptItem->GetOptionId();

        if ( (!pOptionsConfig->m_strStartVendor.IsEmpty() ||
              !pOptionsConfig->m_strStartClass.IsEmpty()) &&
              GetWindowLongPtr(GetSafeHwnd(), GWLP_ID) != IDP_OPTION_ADVANCED)
        {
            // we're on the basic page, need to switch to advanced
            ::PostMessage(pOptionsConfig->GetSheetWindow(), PSM_SETCURSEL, (WPARAM)1, NULL);
            hWnd = pOptionsConfig->m_pageAdvanced.GetSafeHwnd();
            ::PostMessage(hWnd, WM_SELECTCLASSES, (WPARAM) &pOptionsConfig->m_strStartVendor, (LPARAM) &pOptionsConfig->m_strStartClass);
        }
        else
        if ( (pOptionsConfig->m_strStartVendor.IsEmpty() &&
              pOptionsConfig->m_strStartClass.IsEmpty()) &&
              GetWindowLongPtr(GetSafeHwnd(), GWLP_ID) != IDP_OPTION_BASIC)
        {
            // we're on the advanced page, need to switch to basic
            ::PostMessage(pOptionsConfig->GetSheetWindow(), PSM_SETCURSEL, (WPARAM)0, NULL);
            hWnd = pOptionsConfig->m_pageGeneral.GetSafeHwnd();
        }

        ::PostMessage(hWnd, WM_SELECTOPTION, 0, 0);
        return 0;
    }
    
    for (int i = 0; i < m_listctrlOptions.GetItemCount(); i++)
    {
      COptionTracker * pCurOptTracker = 
         reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(i));
        if (pCurOptTracker->m_pOption->QueryId() == pOptionsConfig->m_dhcpStartId)
        {
            BOOL bDirty = IsDirty();

            m_listctrlOptions.SelectItem(i);
            m_listctrlOptions.EnsureVisible(i, FALSE);
            
            SetDirty(bDirty);

            break;
        }
    }

    // reset this variable since we don't need it anymore
    pOptionsConfig->m_dhcpStartId = -1;

    return 0;
}


/*---------------------------------------------------------------------------
   Handlers for the IP Array controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnButtonIpAddrAdd() 
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CWndIpAddress * pIpAddr = reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_SERVER_ADDRESS));

   DWORD dwIpAddress;

   pIpAddr->GetAddress(&dwIpAddress);
   if (dwIpAddress)
   {
      int nSelectedItem = m_listctrlOptions.GetSelectedItem();
      // make sure that sometime is selected
      Assert(nSelectedItem > -1);

      if (nSelectedItem > -1)
      {
         CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_IP_ADDRS));
         CEdit * pServerName = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_SERVER_NAME));
      
         COptionTracker * pOptTracker = 
            reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedItem));

         // fill in the information in the option struct
         CDhcpOption * pOption = pOptTracker->m_pOption;
         CDhcpOptionValue & optValue = pOption->QueryValue();
         
         // check to see if we need to grow the array or not
         int nOldUpperBound = optValue.QueryUpperBound();

         if ((nOldUpperBound == 1) &&
            (optValue.QueryIpAddr() == 0))
         {
            // this array is empty.  Don't need to grow it
            nOldUpperBound -= 1;
         }
         else
         {
            // Set that the array is growing by 1
            optValue.SetUpperBound(nOldUpperBound + 1);
         }

         optValue.SetIpAddr((DHCP_IP_ADDRESS) dwIpAddress, nOldUpperBound);

         pOptTracker->SetDirty(TRUE);

         // add to the list box
         CString strAddress;
         ::UtilCvtIpAddrToWstr(dwIpAddress, &strAddress);

         pListBox->AddString(strAddress);

         // clear the server edit field and ip address
         pServerName->SetWindowText(_T(""));
         pIpAddr->ClearAddress();
            pIpAddr->SetFocusField(0);

         // finally, mark the page as dirty
         SetDirty(TRUE);
      }
   }
   else
   {
      ::DhcpMessageBox(IDS_ERR_DLL_INVALID_ADDRESS);
   }
}

void COptionsCfgPropPage::OnButtonIpAddrDelete() 
{
   int nSelectedOption = m_listctrlOptions.GetSelectedItem();

   CEdit * pServerName = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_SERVER_NAME));
   CWndIpAddress * pIpAddr = reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_SERVER_ADDRESS));
   CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_IP_ADDRS));

   DWORD dwIpAddress;
   CString strIpAddress;
   int nSelectedIndex = pListBox->GetCurSel();

   // get the currently selected item
   pListBox->GetText(nSelectedIndex, strIpAddress);
   dwIpAddress = UtilCvtWstrToIpAddr(strIpAddress);

   // remove from the option
   COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedOption));

   // pOptTracker can be null when the context moves to another option.
   // However, this is not disabled, so the user can still try to delete
   // an IP since it is active. 
   //
   // Add a null check

   if (0 != pOptTracker ) {
       // fill in the information in the option struct
       CDhcpOption * pOption = pOptTracker->m_pOption;
       CDhcpOptionValue & optValue = pOption->QueryValue();
       
       // the listbox should match our array, so we'll remove the same index
       optValue.RemoveIpAddr(nSelectedIndex);
       optValue.SetUpperBound(optValue.QueryUpperBound() - 1);
       
       // remove from list box
       pListBox->DeleteString(nSelectedIndex);
       pIpAddr->SetAddress(dwIpAddress);
       
       pServerName->SetWindowText(_T(""));
       
       // mark the option and the page as dirty
       pOptTracker->SetDirty(TRUE);
       SetDirty(TRUE);
       
       HandleActivationIpArray();
   } // if 
} // COptionsCfgPropPage::OnButtonIpAddrDelete()

void COptionsCfgPropPage::OnSelchangeListIpAddrs() 
{
   HandleActivationIpArray();
}

void COptionsCfgPropPage::OnChangeIpAddressArray() 
{
   HandleActivationIpArray();
}

void COptionsCfgPropPage::OnButtonResolve() 
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CEdit * pServerName = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_SERVER_NAME));

   CString strServer;
   DHCP_IP_ADDRESS dhipa = 0;
   DWORD err = 0;

   pServerName->GetWindowText(strServer);

    //
    //  See what type of name it is.
    //
    switch (UtilCategorizeName(strServer))
    {
        case HNM_TYPE_IP:
            dhipa = ::UtilCvtWstrToIpAddr( strServer ) ;
            break ;

        case HNM_TYPE_NB:
        case HNM_TYPE_DNS:
            err = ::UtilGetHostAddress( strServer, & dhipa ) ;
         if (!err)
            UtilCvtIpAddrToWstr(dhipa, &strServer);
         break ;

        default:
            err = IDS_ERR_BAD_HOST_NAME ;
            break ;
    }

   if (err)
   {
      ::DhcpMessageBox(err);
   }
   else
   {
      CWndIpAddress * pIpAddr = reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_SERVER_ADDRESS));
      pIpAddr->SetAddress(dhipa);   
   }
}
void COptionsCfgPropPage::OnChangeEditServerName() 
{
   HandleActivationIpArray();
}

void COptionsCfgPropPage::OnButtonIpAddrDown() 
{
    CButton * pIpAddrDown = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_DOWN));
    CButton * pIpAddrUp = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_UP));

   MoveValue(FALSE, FALSE);
    if (pIpAddrDown->IsWindowEnabled())
        pIpAddrDown->SetFocus();
    else
        pIpAddrUp->SetFocus();
}

void COptionsCfgPropPage::OnButtonIpAddrUp() 
{
    CButton * pIpAddrDown = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_DOWN));
    CButton * pIpAddrUp = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_UP));

    MoveValue(FALSE, TRUE);
    if (pIpAddrUp->IsWindowEnabled())
        pIpAddrUp->SetFocus();
    else
        pIpAddrDown->SetFocus();
}

/*---------------------------------------------------------------------------
   Handlers for the number array controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnButtonValueAdd() 
{
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   COptionTracker * pOptTracker = 
   reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));
   CEdit * pValue = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_VALUE));
   CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));

   // Get the OptionValue object
   CDhcpOption * pOption = pOptTracker->m_pOption;
   CDhcpOptionValue & optValue = pOption->QueryValue();

   DWORD       dwValue;
   DWORD_DWORD dwdwValue;
   DWORD       dwMask = 0xFFFFFFFF ;

   switch ( optValue.QueryDataType()) 
   {
   case DhcpBinaryDataOption :
   case DhcpByteOption:
      dwMask = 0xFF ;
      break ;
   
   case DhcpWordOption:
      dwMask = 0xFFFF ;
      break ;
    } // switch
    
   if (optValue.QueryDataType() == DhcpDWordDWordOption) 
   {
      CString strValue;
      pValue->GetWindowText(strValue);
      UtilConvertStringToDwordDword(strValue, &dwdwValue);
   }
   else 
   {
      if (!FGetCtrlDWordValue(pValue->GetSafeHwnd(), &dwValue, 0, dwMask))
         return;
   }

   DWORD err = 0 ;

   CATCH_MEM_EXCEPTION 
   {
      // Set that the array is growing by 1
      int nOldUpperBound = optValue.QueryUpperBound();
      optValue.SetUpperBound(nOldUpperBound + 1);  

      // now insert the new item as the last item in the array
      (optValue.QueryDataType() == DhcpDWordDWordOption)
         ? optValue.SetDwordDword(dwdwValue, nOldUpperBound)
         : optValue.SetNumber(dwValue, nOldUpperBound);
   }
   END_MEM_EXCEPTION(err)

   if ( err ) 
   {
      ::DhcpMessageBox( err ) ;
   }
   else 
   {
      pOptTracker->SetDirty(TRUE);
      SetDirty(TRUE);
   }

   //
   // update controls. clear the edit control
   //
   pValue->SetWindowText(_T(""));
   pValue->SetFocus();
   FillDataEntry(pOption);
   HandleActivationValueArray();
} // COptionsCfgPropPage::OnButtonValueAdd()
 
void COptionsCfgPropPage::OnButtonValueDelete() 
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
        
    COptionTracker * pOptTracker = 
   reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));
    CEdit * pValue = reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_VALUE ));
    CListBox * pListBox = 
   reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_VALUES ));

    // Get the OptionValue object
    CDhcpOption * pOption = pOptTracker->m_pOption;
    CDhcpOptionValue & optValue = pOption->QueryValue();

    CString strValue;
    int nListBoxIndex = pListBox->GetCurSel();

    // get the currently selected item
    pListBox->GetText(nListBoxIndex, strValue);

    //if (!FGetCtrlDWordValue(pValue->GetSafeHwnd(), &dwValue, 0, dwMask))
    //    return;

    // the listbox should match our array, so we'll remove the same index
    (optValue.QueryDataType() == DhcpDWordDWordOption) ?
        optValue.RemoveDwordDword(nListBoxIndex) : optValue.RemoveNumber(nListBoxIndex);
        
    optValue.SetUpperBound(optValue.QueryUpperBound() - 1);

    // remove from list box
    pListBox->DeleteString( nListBoxIndex );
    nListBoxIndex--;
    if ( nListBoxIndex < 0 ) {
   nListBoxIndex = 0;
    }
    pListBox->SetCurSel( nListBoxIndex );
    pValue->SetWindowText(strValue);

    // mark the option and the page as dirty
    pOptTracker->SetDirty(TRUE);
    SetDirty(TRUE);

    HandleActivationValueArray();
}

void COptionsCfgPropPage::OnButtonValueDown() 
{
    CButton * pValueDown = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_DOWN));
    CButton * pValueUp = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_UP));

    MoveValue(TRUE, FALSE);
    if (pValueDown->IsWindowEnabled())
        pValueDown->SetFocus();
    else
        pValueUp->SetFocus();
}

void COptionsCfgPropPage::OnButtonValueUp() 
{
    CButton * pValueDown = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_DOWN));
    CButton * pValueUp = 
        reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_UP));

    MoveValue(TRUE, TRUE);
    if (pValueUp->IsWindowEnabled())
        pValueUp->SetFocus();
    else
        pValueDown->SetFocus();
}

void COptionsCfgPropPage::MoveValue(BOOL bValues, BOOL bUp)
{
    int nSelectedOption = m_listctrlOptions.GetSelectedItem();

    // Get the option that describes this
    COptionTracker * pOptTracker = 
        reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedOption));
    if ( 0 == pOptTracker ) {
        return;
    }
    CDhcpOption * pOption = pOptTracker->m_pOption;
    if ( 0 == pOption ) {
        return;
    }

    CDhcpOptionValue & optValue = pOption->QueryValue();

    // Get the correct listbox
    CListBox * pListBox;
    if (bValues)
    {
        // this is for values
        pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));
    }
    else
    {
        // this is for IpAddrs
        pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_IP_ADDRS));
    }

    if ( 0 == pListBox ) {
        return;
    }

    // now get which item is selected in the listbox
    int cFocus = pListBox->GetCurSel();

    // make sure it's valid for this operation
    if ( (bUp && cFocus <= 0) ||
         (!bUp && cFocus >= pListBox->GetCount()) )
    {
        return;
    }

    DWORD       dwValue;
    DWORD_DWORD dwdwValue;
    DWORD       err = 0 ;

    // move the value up/down
    CATCH_MEM_EXCEPTION
    {
        if (optValue.QueryDataType() == DhcpDWordDWordOption)
        {
            DWORD_DWORD dwUpValue;
            DWORD_DWORD dwDownValue;

            if (bUp)
            {
                dwdwValue = dwUpValue = optValue.QueryDwordDword(cFocus);
                dwDownValue = optValue.QueryDwordDword(cFocus - 1);

                optValue.SetDwordDword(dwUpValue, cFocus - 1);
                optValue.SetDwordDword(dwDownValue, cFocus);
            }
            else
            {
                dwdwValue = dwDownValue = optValue.QueryDwordDword(cFocus);
                dwUpValue = optValue.QueryDwordDword(cFocus + 1);

                optValue.SetDwordDword(dwDownValue, cFocus + 1);
                optValue.SetDwordDword(dwUpValue, cFocus);
            }
        }
        else
        {
            DWORD dwUpValue;
            DWORD dwDownValue;

            if (bUp)
            {
                dwValue = dwUpValue = optValue.QueryNumber(cFocus);
                dwDownValue = optValue.QueryNumber(cFocus - 1);

                optValue.SetNumber(dwUpValue, cFocus - 1);
                optValue.SetNumber(dwDownValue, cFocus);
            }
            else
            {
                dwValue = dwDownValue = optValue.QueryNumber(cFocus);
                dwUpValue = optValue.QueryNumber(cFocus + 1);

                optValue.SetNumber(dwDownValue, cFocus + 1);
                optValue.SetNumber(dwUpValue, cFocus);
            }
        }
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
    }
    else
    {
        // everything is ok, mark this option and the prop sheet
        pOptTracker->SetDirty(TRUE);
        SetDirty(TRUE);
    }

    // update the data.
    FillDataEntry(pOption);

    // Set the selection correctly
    pListBox->SetCurSel( bUp ? cFocus - 1 : cFocus + 1 );

    // update the controls
    if (bValues)
    {
        HandleActivationValueArray();
    }
    else
    {
        HandleActivationIpArray();
    }
} // COptionsCfgPropPage::MoveValue()

void COptionsCfgPropPage::OnChangeEditValue() 
{
   HandleActivationValueArray();
}

void COptionsCfgPropPage::OnClickedRadioDecimal() 
{
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   
   COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));

   CDhcpOption * pOption = pOptTracker->m_pOption;

   FillDataEntry(pOption);
}

void COptionsCfgPropPage::OnClickedRadioHex() 
{
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   
   COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));

   CDhcpOption * pOption = pOptTracker->m_pOption;

   FillDataEntry(pOption);
}

void COptionsCfgPropPage::OnSelchangeListValues() 
{
   HandleActivationValueArray();
}

/*---------------------------------------------------------------------------
   Handlers for the binary and encapsulated data
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnChangeValueData() 
{
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   
   COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));
   CEdit * pValue = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_VALUE));
   CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));

   // Get the OptionValue object
   CDhcpOption * pOption = pOptTracker->m_pOption;
   CDhcpOptionValue & optValue = pOption->QueryValue();

    // get the info from the control
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(IDC_VALUEDATA)->GetSafeHwnd(), GWLP_USERDATA);

    DWORD err = 0;

    CATCH_MEM_EXCEPTION
    {
        // size we don't know what changed, we just have to copy all of the data
        optValue.RemoveAll();
        for (int i = 0; i < pHexEditData->cbBuffer; i++)
        {   
            DWORD dwValue = (BYTE) pHexEditData->pBuffer[i];
            optValue.SetNumber(dwValue, i);
        }
    }
    END_MEM_EXCEPTION(err)

    // mark the option and the page as dirty
   pOptTracker->SetDirty(TRUE);
   SetDirty(TRUE);
}

/*---------------------------------------------------------------------------
   Handlers for the single number entry controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnChangeEditDword() 
{
   HandleValueEdit();
}

/*---------------------------------------------------------------------------
   Handlers for the single IP Address entry controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnChangeIpAddress() 
{
   HandleValueEdit();
}

/*---------------------------------------------------------------------------
   Handlers for the string entry controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnChangeEditString() 
{
   HandleValueEdit();
}

/////////////////////////////////////////////////////////////////////////////
// CAddRoute dialog

CAddRoute::CAddRoute( CWnd *pParent)
    : CBaseDialog( CAddRoute::IDD, pParent )
{
    m_ipaDest.ClearAddress();
    m_ipaMask.ClearAddress();
    m_ipaRouter.ClearAddress();
    m_bChange = FALSE;
}

void CAddRoute::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAddRoute)
   //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_ADDRESS, m_ipaDest);
    DDX_Control(pDX, IDC_IPADDR_ADDRESS2, m_ipaMask);
    DDX_Control(pDX, IDC_IPADDR_ADDRESS3, m_ipaRouter);
}

BEGIN_MESSAGE_MAP(CAddRoute, CBaseDialog)
   //{{AFX_MSG_MAP(CAddRoute)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddReservation message handlers

BOOL CAddRoute::OnInitDialog() 
{
   CBaseDialog::OnInitDialog();

    // set focus on the destination..
    CWnd *pWnd = GetDlgItem(IDC_IPADDR_ADDRESS);
    if( NULL != pWnd )
    {
        pWnd->SetFocus();
        return FALSE;
    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddRoute::OnOK() 
{
   DWORD err = 0;
    
    UpdateData();

    m_ipaDest.GetAddress( &Dest );
    m_ipaMask.GetAddress( &Mask );
    m_ipaRouter.GetAddress( &Router );

    // validate the ip addresses
    if( 0 == Router || (0 != Mask && 0 == Dest) ||
        0 != ((~Mask) & Dest) ||
        (0 != ((~Mask) & ((~Mask)+1)) ) )
    {
        ::DhcpMessageBox( IDS_ERR_INVALID_ROUTE_ENTRY );
    }
    else
    {
        m_bChange = TRUE;
        
        CBaseDialog::OnOK();
    }
   //CBaseDialog::OnOK();
}
    
/*--------------------------------------------------------------------------
        Handlers for String Array Editor
 ---------------------------------------------------------------------------*/

void COptionsCfgPropPage::OnSelChangeStringArrayList()
{
    HandleActivationStringArray();
} // COptionsCfgPropPage::OnSelChangeStringArrayList()

void COptionsCfgPropPage::OnChangeStringArrayValue()
{
    // Get the string edit box control
    CEdit *pEdit = reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_STRING ));
    
    CString str;

    pEdit->GetWindowText( str );
    if ( !str.IsEmpty()) 
    {
      CButton *pAdd = reinterpret_cast<CButton *>( GetDlgItem( IDC_BUTTON_STRING_ARRAY_ADD ));
      pAdd->EnableWindow( TRUE );
    }
    HandleActivationStringArray();
} // COptionsCfgPropPage::OnChangeStringArrayValue()

void COptionsCfgPropPage::OnButtonStringArrayAdd()
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));

    // Get the OptionValue object
    CDhcpOption * pOption = pOptTracker->m_pOption;
    CDhcpOptionValue & optValue = pOption->QueryValue();

    // Get the strings list control
    CListBox *pList = reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
    
    // Get the string edit box control
    CEdit *pEdit = reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_STRING ));

    CString strValue;
    pEdit->GetWindowText( strValue );

    // Do not add empty strings
    if ( !strValue.IsEmpty()) 
    {
      pList->InsertString( 0, strValue );
      pList->SetCurSel( 0 );
      pEdit->SetWindowText( L"" );
    } // if

    HandleActivationStringArray();

    // set the focus back to the edit box
    pEdit->SetFocus();
    pOptTracker->SetDirty( TRUE );
    SetDirty( TRUE );

} // COptionsCfgPropPage::OnButtonStringArrayAdd()
    
void COptionsCfgPropPage::OnButtonStringArrayRemove()
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));

    // Get the OptionValue object
    CDhcpOption * pOption = pOptTracker->m_pOption;
    CDhcpOptionValue & optValue = pOption->QueryValue();


    // Get the strings list control
    CListBox *pList = reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
    CEdit *pEdit = reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_STRING ));

    CString str;
    int nItem = pList->GetCurSel();

    pList->GetText( nItem, str );
    pEdit->SetWindowText( str );

    optValue.RemoveString( nItem );
    pList->DeleteString( nItem );

    nItem--;
    if ( nItem < 0 ) 
    {
      nItem = 0;
    }
    pList->SetCurSel( nItem );
    pList->SetFocus();
    HandleActivationStringArray();

    pOptTracker->SetDirty( TRUE );
    SetDirty( TRUE );

} // COptionsCfgPropPage::OnButtonStringArrayRemove()
    
void COptionsCfgPropPage::OnButtonStringArrayUp()
{

    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    COptionTracker * pOptTracker = 
   reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));

    // Get the strings list control
    CListBox *pList = reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
    
    int nItem = pList->GetCurSel();
    CString str; 

    if ( nItem > 0 ) 
    {
      pList->GetText( nItem, str );
      pList->DeleteString( nItem );
      pList->InsertString( nItem - 1, str );

      pList->SetCurSel( nItem - 1 );
      pOptTracker->SetDirty( TRUE );
      SetDirty( TRUE );
    } // if
    HandleActivationStringArray();
} // COptionsCfgPropPage::OnButtonStringArrayUp()
    
void COptionsCfgPropPage::OnButtonStringArrayDown()
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));

    // Get the strings list control
    CListBox *pList = reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
    
    int nItem = pList->GetCurSel();
    CString str; 
    int nCount = pList->GetCount();
    if ( nItem < nCount - 1 ) 
    {
      pList->GetText( nItem, str );
      pList->DeleteString( nItem );
      if ( nItem <  nCount - 1 ) 
      {
         nItem++;
      }
      pList->InsertString( nItem, str );
      pList->SetCurSel( nItem );
      pOptTracker->SetDirty( TRUE );
      SetDirty( TRUE );
    } // ifs 

    HandleActivationStringArray();
} // COptionsCfgPropPage::OnButtonStringArrayDown()
    
/*---------------------------------------------------------------------------
   Handlers for the route add data entry controls
 ---------------------------------------------------------------------------*/
void COptionsCfgPropPage::OnButtonAddRoute()
{
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   
   COptionTracker * pOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));

   // Get the OptionValue object
   CDhcpOption * pOption = pOptTracker->m_pOption;
   CDhcpOptionValue & optValue = pOption->QueryValue();

    // get the routes list control
    CListCtrl *pList = reinterpret_cast<CListCtrl *>(
        GetDlgItem( IDC_LIST_OF_ROUTES ) );

    // get the add and remove buttons
    CButton *pAdd = reinterpret_cast<CButton *>(
        GetDlgItem(IDC_BUTTON_ROUTE_ADD) );
    CButton *pRemove = reinterpret_cast<CButton *>(
            GetDlgItem(IDC_BUTTON_ROUTE_DEL) );
    

    // throw the add route UI
    CAddRoute NewRoute(NULL);

    NewRoute.DoModal();

    if( NewRoute.m_bChange ) {
   CString strDest, strMask, strRouter;
   
   // obtain the three strings..
   ::UtilCvtIpAddrToWstr(NewRoute.Dest, &strDest);
   ::UtilCvtIpAddrToWstr(NewRoute.Mask, &strMask);
   ::UtilCvtIpAddrToWstr(NewRoute.Router, &strRouter);
        
   LV_ITEM lvi;
        
   lvi.mask = LVIF_TEXT;
   lvi.iItem = pList->GetItemCount();
   lvi.iSubItem = 0;
   lvi.pszText = (LPTSTR)(LPCTSTR)strDest;
   lvi.iImage = 0;
   lvi.stateMask = 0;
   int nItem = pList->InsertItem(&lvi);
   pList->SetItemText(nItem, 1, strMask);
   pList->SetItemText(nItem, 2, strRouter);

   // Unselect other items
   for ( int i = 0; i < pList->GetItemCount(); i++ ) {
       pList->SetItemState( i, 0, LVIS_SELECTED );
   }
   
   // Select this item 
   pList->SetItemState( nItem, LVIS_SELECTED, LVIS_SELECTED );
   
   pOptTracker->SetDirty(TRUE);
   SetDirty(TRUE);
    } // if
    
    // now walk through the list control and get the values and
    // put them back onto the optValue    

    HandleActivationRouteArray( &optValue );
} // COptionsCfgPropPage::OnButtonAddRoute()

void COptionsCfgPropPage::OnButtonDelRoute()
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    int nDelItem = 0;
    int nItems;

    COptionTracker * pOptTracker = 
   reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));

    // Get the OptionValue object
    CDhcpOption * pOption = pOptTracker->m_pOption;
    CDhcpOptionValue & optValue = pOption->QueryValue();

    // get the routes list control
    CListCtrl *pList = reinterpret_cast<CListCtrl *>
   ( GetDlgItem( IDC_LIST_OF_ROUTES ));

    // get the add and remove buttons
    CButton *pAdd = reinterpret_cast<CButton *>
   ( GetDlgItem( IDC_BUTTON_ROUTE_ADD ));
    CButton *pRemove = reinterpret_cast<CButton *>
   ( GetDlgItem( IDC_BUTTON_ROUTE_DEL ));
    
    // get the selected column and delete it
    int nItem = pList->GetNextItem(-1, LVNI_SELECTED);
    while( nItem != -1 ) {
        pList->DeleteItem( nItem ) ;
   nDelItem = nItem;

        nItem = pList->GetNextItem(-1, LVNI_SELECTED);

        pOptTracker->SetDirty(TRUE);
        SetDirty(TRUE);        
    } // while
    
    // Select an item
    nItems = pList->GetItemCount();
    if ( nItems > 0 ) {
   if ( nDelItem >= nItems ) {
       nDelItem = nItems - 1;
   }
   pList->SetItemState( nDelItem, LVIS_SELECTED, LVIS_SELECTED );
    } // if

    // now walk through the list control and get the values and
    // put them back onto the optValue

    HandleActivationRouteArray( &optValue );
} // COptionsCfgPropPage::OnButtonDelRoute()


BOOL COptionsCfgPropPage::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // set the title   
    ((COptionsConfig *) GetHolder())->SetTitle();
    
    // initialize the list control
    InitListCtrl();
    
    // initialize the option data
    DWORD dwErr = ((COptionsConfig *) GetHolder())->InitData();
    if (dwErr != ERROR_SUCCESS)  {
   // CODEWORK:  need to exit gracefull if this happens     
   ::DhcpMessageBox(dwErr);
    }
    else {
   // Fill the options for this page type - basic, advanced, custom
   ((COptionsConfig *) GetHolder())->FillOptions(_T(""), _T(""), m_listctrlOptions);
    }
    
    // Create the type control switcher
    m_cgsTypes.Create(this,IDC_DATA_ENTRY_ANCHOR,cgsPreCreateAll);
    
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_NONE, IDD_DATA_ENTRY_NONE, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_DWORD, IDD_DATA_ENTRY_DWORD,  NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_IPADDRESS, IDD_DATA_ENTRY_IPADDRESS,   NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_IPADDRESS_ARRAY, IDD_DATA_ENTRY_IPADDRESS_ARRAY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_STRING, IDD_DATA_ENTRY_STRING, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_BINARY_ARRAY, IDD_DATA_ENTRY_BINARY_ARRAY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_BINARY, IDD_DATA_ENTRY_BINARY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_ROUTE_ARRAY, IDD_DATA_ENTRY_ROUTE_ARRAY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_STRING_ARRAY, IDD_DATA_ENTRY_STRING_ARRAY, NULL);
    
    m_hexData.SubclassDlgItem(IDC_VALUEDATA, this);
    
    SwitchDataEntry(-1, -1, 0, TRUE);
    
    SetDirty(FALSE);
    
    m_bInitialized = TRUE;
    
    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
} // COptionsCfgPropPage::OnInitDialog()

void COptionsCfgPropPage::SelectOption(CDhcpOption * pOption)
{
    for (int i = 0; i < m_listctrlOptions.GetItemCount(); i++)
   {
       COptionTracker * pCurOptTracker = 
      reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(i));
        
       if (pOption->QueryId() == pCurOptTracker->m_pOption->QueryId())
      {
          m_listctrlOptions.SelectItem(i);
          m_listctrlOptions.EnsureVisible(i, FALSE);
      }
   }
}


void COptionsCfgPropPage::SwitchDataEntry(
    int datatype,
    int optiontype,
    BOOL fRouteArray,
    BOOL bEnable
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strType;
   
    if( fRouteArray )
   {
       // ignore any other types passed and use route_array type
       m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_ROUTE_ARRAY);
   }
    else {
   switch(datatype) {
   case DhcpByteOption:
   case DhcpWordOption:
   case DhcpDWordOption:
   case DhcpDWordDWordOption:
       {
      // build our string for the type of data
      if ( (datatype == DhcpByteOption) || 
           (datatype == DhcpEncapsulatedDataOption) )
          {
         strType.LoadString(IDS_INFO_TYPOPT_BYTE);
          }
      else
          if (datatype == DhcpWordOption)
         {
             strType.LoadString(IDS_INFO_TYPOPT_WORD);
         }
          else
         if (datatype == DhcpDWordOption)
             {
            strType.LoadString(IDS_INFO_TYPOPT_DWORD);
             }
         else
             {
            strType.LoadString(IDS_INFO_TYPOPT_DWDW);
             }

      if (optiontype == DhcpArrayTypeOption)
          {
         m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_BINARY_ARRAY);
         CButton * pRadioDecimal = 
             reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO_DECIMAL));
         CButton * pRadioHex = 
             reinterpret_cast<CButton *>( GetDlgItem( IDC_RADIO_HEX ));

         if ( !( pRadioHex->GetCheck() ^ pRadioDecimal->GetCheck())) {
             pRadioDecimal->SetCheck( 1 );
         }

         // set some information text
         CString strFrameText;
         strFrameText.LoadString(IDS_DATA_ENTRY_FRAME);
         strFrameText += _T(" ") + strType;

         CWnd * pWnd = GetDlgItem(IDC_STATIC_BINARY_ARRAY_FRAME);
         pWnd->SetWindowText(strFrameText);
          }
      else
          {
         m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_DWORD);
         CWnd * pWnd = GetDlgItem(IDC_STATIC_TYPE);

         pWnd->SetWindowText(strType);
          }
       }
       break;

   case DhcpBinaryDataOption:
   case DhcpEncapsulatedDataOption:
       {
      m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_BINARY);
       }
            break;

        case DhcpIpAddressOption:
       if (optiontype == DhcpArrayTypeOption)
      {
          strType.LoadString(IDS_INFO_TYPOPT_BYTE);
          m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_IPADDRESS_ARRAY);

          CButton * pRadioDecimal = 
         reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO_DECIMAL));

          pRadioDecimal->SetCheck(1);

          // set some information text
          CString strFrameText;
          strFrameText.LoadString(IDS_DATA_ENTRY_FRAME);
          strFrameText += _T(" ") + strType;

          CWnd * pWnd = GetDlgItem(IDC_STATIC_BINARY_ARRAY_FRAME);
          pWnd->SetWindowText(strFrameText);
      }
       else
      m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_IPADDRESS);
       break;

   case DhcpStringDataOption:
       if (optiontype == DhcpArrayTypeOption)
      m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_STRING_ARRAY);
       else
      m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_STRING);
       break;

   default:

       m_cgsTypes.ShowGroup(IDC_DATA_ENTRY_NONE);
       break;
   } // switch 
    } // else

    // enable/disable the current group
    m_cgsTypes.EnableGroup(-1, bEnable);

} // COptionsCfgPropPage::SwitchDataEntry()

const int ROUTE_LIST_COL_WIDTHS[3] = {
    100, 100, 100
};

const int ROUTE_LIST_COL_HEADERS[3] = {
    IDS_ROUTE_LIST_COL_DEST,
    IDS_ROUTE_LIST_COL_MASK,
    IDS_ROUTE_LIST_COL_ROUTER
};

void COptionsCfgPropPage::FillDataEntry(CDhcpOption * pOption)
{
   CDhcpOptionValue & optValue = pOption->QueryValue();

   int datatype = pOption->QueryDataType();
   int optiontype = pOption->QueryOptType();
   BOOL fRouteArray = ( !pOption->IsClassOption() &&
         (DHCP_OPTION_ID_CSR == pOption->QueryId()) &&
         optiontype == DhcpUnaryElementTypeOption &&
         datatype == DhcpBinaryDataOption
         );
   CButton * pRadioHex = 
      reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO_HEX));
   BOOL bUseHex = pRadioHex->GetCheck();

   if( fRouteArray ) 
   {
      const CByteArray * pbaData = optValue.QueryBinaryArray();
      int nDataSize = (int)pbaData->GetSize();
      LPBYTE pData = (LPBYTE) pbaData->GetData();
      
      // initialize the list control view with data
           
      CListCtrl *pList =
         reinterpret_cast<CListCtrl *>(GetDlgItem(IDC_LIST_OF_ROUTES));
      Assert(pList);
      pList->DeleteAllItems();
      pList->SetExtendedStyle(LVS_EX_FULLROWSELECT);
      pList->DeleteColumn(2);
      pList->DeleteColumn(1);
      pList->DeleteColumn(0);
      
      LV_COLUMN lvc;
      CString strColHeader;
           
      for( int i = 0; i < 3; i ++ ) 
      {
         lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH ;
         lvc.iSubItem = i;
         lvc.fmt = LVCFMT_LEFT;
         lvc.cx = ROUTE_LIST_COL_WIDTHS[i];
         strColHeader.LoadString(ROUTE_LIST_COL_HEADERS[i]);
         lvc.pszText = (LPTSTR)(LPCTSTR)strColHeader;
          
         pList->InsertColumn( i, &lvc );
      } // for 
      
      // convert pData to list of ip addresses as per RFC
      while( nDataSize > sizeof(DWORD) ) 
      {
         // first 1 byte contains the # of bits in subnetmask
         nDataSize --;
         BYTE nBitsMask = *pData ++;
         DWORD Mask = (~0);
         if( nBitsMask < 32 ) Mask <<= (32-nBitsMask);
          
         // based on the # of bits, the next few bytes contain
         // the subnet address for the 1-bits of subnet mask
         int nBytesDest = (nBitsMask+7)/8;
         if( nBytesDest > 4 ) nBytesDest = 4;
          
         DWORD Dest = 0;
         memcpy( &Dest, pData, nBytesDest );
         pData += nBytesDest;
         nDataSize -= nBytesDest;
               
         // subnet address is obviously in network order.
         Dest = ntohl(Dest);
          
         // now the four bytes would be the router address
         DWORD Router = 0;
         if( nDataSize < sizeof(DWORD) ) 
         {
            Assert( FALSE ); break;
         }
          
         memcpy(&Router, pData, sizeof(DWORD));
         Router = ntohl( Router );
          
         pData += sizeof(DWORD);
         nDataSize -= sizeof(DWORD);
          
         // now fill the list box..
         CString strDest, strMask, strRouter;
          
         ::UtilCvtIpAddrToWstr(Dest, &strDest);
         ::UtilCvtIpAddrToWstr(Mask, &strMask);
         ::UtilCvtIpAddrToWstr(Router, &strRouter);
          
         LV_ITEM lvi;
               
         lvi.mask = LVIF_TEXT;
         lvi.iItem = pList->GetItemCount();
         lvi.iSubItem = 0;
         lvi.pszText = (LPTSTR)(LPCTSTR) strDest;
         lvi.iImage = 0;
         lvi.stateMask = 0;
         int nItem = pList->InsertItem(&lvi);
         pList->SetItemText(nItem, 1, strMask);
         pList->SetItemText(nItem, 2, strRouter);

      } // while 

      // select the first item
      if ( pList->GetItemCount() > 0 ) 
      {
         pList->SetItemState( 0, LVIS_SELECTED, LVIS_SELECTED );
      }
           
      HandleActivationRouteArray();
   } // if route array 
   else 
   {
      switch(datatype) 
      {
      case DhcpByteOption:
      case DhcpWordOption:
      case DhcpDWordOption:
         {
            if (optiontype == DhcpArrayTypeOption) 
            {
               CListBox * pListBox = 
                  reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));

               CEdit *pValue = reinterpret_cast<CEdit *>
                  ( GetDlgItem( IDC_EDIT_VALUE ));
               CString strValue;
               long lValue;

               Assert(pListBox);
               pListBox->ResetContent();

               for (int i = 0; i < optValue.QueryUpperBound(); i++) {
                  lValue = optValue.QueryNumber(i);
                  if (bUseHex) 
                  {
                     strValue.Format(_T("0x%x"), lValue);
                  }
                  else 
                  {
                     strValue.Format(_T("%lu"), lValue);
                  }

                  pListBox->AddString(strValue);
               } // for 

               if ( pListBox->GetCount() > 0 ) 
               {
                  pListBox->SetCurSel( 0 );
               }

               // Convert the number in the edit box

               pValue->GetWindowText( strValue );
               if ( !strValue.IsEmpty()) 
               {
                  DWORD maxVal;

                  if ( DhcpByteOption == datatype ) 
                  {
                     maxVal = 0xff;
                  }
                  else  if ( DhcpWordOption == datatype ) 
                  {
                     maxVal = 0xffff;
                  }
                  else 
                  {
                     maxVal = 0xffffffff;
                  }

                  FGetCtrlDWordValue( pValue->GetSafeHwnd(),
                        ( DWORD * )&lValue, 0, maxVal );
                     
                  if ( bUseHex ) 
                  {
                     strValue.Format( _T("0x%x"), lValue );
                  }
                  else 
                  {
                     strValue.Format( _T("%lu"), lValue );
                  }
                  pValue->SetWindowText( strValue );
               } // if 
               HandleActivationValueArray();
         } // if array type
         else 
         {
            CString strValue;
            optValue.QueryDisplayString(strValue);
            CWnd * pWnd = GetDlgItem(IDC_EDIT_DWORD);
            Assert(pWnd);
            pWnd->SetWindowText(strValue);
         } // else single valued

         break;
      }
          
      case DhcpIpAddressOption:
         {
            if (optiontype == DhcpArrayTypeOption) 
            {
               CListBox * pListBox = 
                  reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_IP_ADDRS));

               Assert(pListBox);
               pListBox->ResetContent();

               for (int i = 0; i < optValue.QueryUpperBound(); i++) 
               {
                  CString strValue;
                  DHCP_IP_ADDRESS ipAddress = optValue.QueryIpAddr(i);
                              
                  if (ipAddress) 
                  {
                     ::UtilCvtIpAddrToWstr(ipAddress, &strValue);
                     pListBox->AddString(strValue);
                  }
               } // for

               HandleActivationIpArray();
            } // if array type
            else 
            {
               CWndIpAddress * pIpAddr = 
                  reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_ADDRESS));
               
               DHCP_IP_ADDRESS ipAddress = optValue.QueryIpAddr();
               if (ipAddress)
                  pIpAddr->SetAddress(ipAddress);
               else
                  pIpAddr->ClearAddress();
            } // else single valued
          
            break;
         }  

      case DhcpStringDataOption:
         {
         if (optiontype == DhcpArrayTypeOption) 
         {
            CListBox * pListBox = 
            reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
             
            Assert(pListBox);
            pListBox->ResetContent();
            CString str;
            for (int i = 0; i < optValue.QueryUpperBound(); i++) 
            {
               str = optValue.QueryString( i );
               if ( !str.IsEmpty()) 
               {
                  pListBox->AddString( optValue.QueryString( i ));
               }
               str = L"";
            } // for 

            if ( pListBox->GetCount() > 0 ) 
            {
               pListBox->SetCurSel( 0 );
            }
            HandleActivationStringArray();
         } // if array type
         else 
         {
            CWnd * pWnd = GetDlgItem(IDC_EDIT_STRING_VALUE);
            pWnd->SetWindowText(optValue.QueryString());
         } // else single valued
         break;
      }

      case DhcpDWordDWordOption:
         {
            if (optiontype == DhcpArrayTypeOption) 
            {
               CListBox * pListBox = 
                  reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));
               CEdit *pValue = 
                  reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_VALUE ));
               CString strValue;
               DWORD_DWORD value;
               ULARGE_INTEGER ulValue;

               Assert(pListBox);
               pListBox->ResetContent();

               for (int i = 0; i < optValue.QueryUpperBound(); i++) 
               {
                  DWORD_DWORD dwdwValue = optValue.QueryDwordDword(i);
                  ::UtilConvertDwordDwordToString(&dwdwValue, &strValue, !bUseHex);
                  pListBox->AddString(strValue);
               } // for 

               if ( pListBox->GetCount() > 0 ) 
               {
                  pListBox->SetCurSel( 0 );
               }

               pValue->GetWindowText( strValue );
               if ( !strValue.IsEmpty()) 
               {
                  UtilConvertStringToDwordDword( strValue, &value );
                  UtilConvertDwordDwordToString( &value, &strValue, !bUseHex );
                  pValue->SetWindowText( strValue );
               } // if

               HandleActivationValueArray();
            } // if array type 
            else  
            {
               CString strValue;
               optValue.QueryDisplayString(strValue);
                
               CWnd * pWnd = GetDlgItem(IDC_EDIT_DWORD);
                
               Assert(pWnd);
               pWnd->SetWindowText(strValue);
            } // else single valued
            break;
         }
         
      case DhcpBinaryDataOption:
      case DhcpEncapsulatedDataOption: 
         {
            const CByteArray * pbaData = optValue.QueryBinaryArray();
            int nDataSize = (int)pbaData->GetSize();
            LPBYTE pData = (LPBYTE) pbaData->GetData();

            memset(m_BinaryBuffer, 0, sizeof(m_BinaryBuffer));

            if (pData) 
            {
               memcpy(m_BinaryBuffer, pData, nDataSize);
            }

            SendDlgItemMessage(IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
               nDataSize, (LPARAM) m_BinaryBuffer);

            break;
      } // case ..
          
      default:
         {
            Assert(FALSE);
            break;
         }
      } // switch
   }
} // COptionsCfgPropPage::FillDataEntry()

void COptionsCfgPropPage::InitListCtrl()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // set image lists
   m_StateImageList.Create(IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));

   m_listctrlOptions.SetImageList(NULL, LVSIL_NORMAL);
   m_listctrlOptions.SetImageList(NULL, LVSIL_SMALL);
   m_listctrlOptions.SetImageList(&m_StateImageList, LVSIL_STATE);

   // insert a column so we can see the items
   LV_COLUMN lvc;
    CString strColumnHeader;

    for (int i = 0; i < MAX_COLUMNS; i++)
    {
        lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        lvc.iSubItem = i;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = COLUMN_WIDTHS[i];
        strColumnHeader.LoadString(COLUMN_HEADERS[i]);
        lvc.pszText = (LPTSTR) (LPCTSTR) strColumnHeader;

        m_listctrlOptions.InsertColumn(i, &lvc);
    }

    m_listctrlOptions.SetFullRowSel(TRUE);
}

void COptionsCfgPropPage::OnDestroy() 
{
   CImageList * pStateImageList = NULL;

   // if the control has been initialized, we need to cleanup
   if (m_listctrlOptions.GetSafeHwnd() != NULL)
   {
      pStateImageList = m_listctrlOptions.SetImageList(NULL, LVSIL_STATE);

      if (pStateImageList) {
                    //pStateImageList->DeleteImageList();
                }

      // The OptionTrackers get delete in the destructor
      m_listctrlOptions.DeleteAllItems();
   }
   m_listctrlOptions.DestroyWindow();

   CPropertyPageBase::OnDestroy();
}

void COptionsCfgPropPage::OnItemchangedListOptions(NMHDR* pNMHDR, LRESULT* pResult) 
{
   NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

   if (pNMListView->uChanged & LVIF_STATE)
   {
      BOOL bUpdate = FALSE, bEnable = FALSE;
      UINT uFlags = pNMListView->uOldState ^ pNMListView->uNewState;

      COptionTracker* pCurOptTracker = 
         reinterpret_cast<COptionTracker *>
         (m_listctrlOptions.GetItemData(pNMListView->iItem));
      CDhcpOption* pCurOption = pCurOptTracker->m_pOption;

      BOOL bOldSelected = pNMListView->uOldState & LVIS_SELECTED;
      BOOL bNewSelected = pNMListView->uNewState & LVIS_SELECTED;

      BOOL bStateImageChanged =
         (pNMListView->uOldState & LVIS_STATEIMAGEMASK) !=
         (pNMListView->uNewState & LVIS_STATEIMAGEMASK);

      BOOL bIsSelected = m_listctrlOptions.IsSelected(pNMListView->iItem);

      // has this item been selected?
      if (!bOldSelected && bNewSelected)
      {
         // check to see if this item is checked
         bEnable = m_listctrlOptions.GetCheck(pNMListView->iItem);
         bUpdate = TRUE;
      }

      // has item been checked/unchecked?
      if (bStateImageChanged && m_bInitialized)
      {
         // mark this as dirty and enable apply button
         pCurOptTracker->SetDirty(TRUE);
         SetDirty(TRUE);

         // update the state in the option tracker
         UINT uCurrentState = m_listctrlOptions.GetCheck(pNMListView->iItem)
            ? OPTION_STATE_ACTIVE
            : OPTION_STATE_INACTIVE;
         pCurOptTracker->SetCurrentState(uCurrentState);

         // we force the the selection of an item if the user changes it's checkbox state
         if (!bIsSelected) 
         {
            m_listctrlOptions.SelectItem(pNMListView->iItem);
         }
      } // if 

      // if we are changing the check box on a selected item, then update
      if ((bStateImageChanged && bIsSelected))
      {
         bEnable = (pNMListView->uNewState & 
               INDEXTOSTATEIMAGEMASK(LISTVIEWEX_CHECKED)) > 0;
         bUpdate = TRUE;
      }

      // item needs to be updated
      if (bUpdate)
      {
         BOOL fRouteArray = ( !pCurOption->IsClassOption() &&
               (DHCP_OPTION_ID_CSR == pCurOption->QueryId()) &&
               DhcpUnaryElementTypeOption == pCurOption->QueryOptType() &&
               DhcpBinaryDataOption == pCurOption->QueryDataType());

         SwitchDataEntry( pCurOption->QueryDataType(),
               pCurOption->QueryOptType(), fRouteArray, bEnable); 
         FillDataEntry(pCurOption);
      } // if

   } // if 

   *pResult = 0;
} // COptionsCfgPropPage::OnItemchangedListOptions()

BOOL COptionsCfgPropPage::OnSetActive() 
{
   return CPropertyPageBase::OnSetActive();
}

void COptionsCfgPropPage::HandleActivationStringArray()
{
    int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
    if (nSelectedIndex == -1)
    {
       // Nothing selected
       return;
    }
    
    COptionTracker* pOptTracker = 
      reinterpret_cast<COptionTracker *>( m_listctrlOptions.GetItemData( nSelectedIndex ));
    _ASSERT(pOptTracker);

    // Get the OptionValue object
    CDhcpOption * pOption = pOptTracker->m_pOption;
    CDhcpOptionValue & optValue = pOption->QueryValue();

    CListBox *pList = reinterpret_cast<CListBox *>( GetDlgItem( IDC_LIST_STRING_ARRAY ));
    CButton *pAdd = reinterpret_cast<CButton *>( GetDlgItem( IDC_BUTTON_STRING_ARRAY_ADD ));
    CButton *pRemove = reinterpret_cast<CButton *>( GetDlgItem( IDC_BUTTON_STRING_ARRAY_REMOVE ));
    CButton *pUp = reinterpret_cast<CButton *>( GetDlgItem( IDC_BUTTON_STRING_ARRAY_UP ));
    CButton *pDown = reinterpret_cast<CButton *>( GetDlgItem( IDC_BUTTON_STRING_ARRAY_DOWN ));
    CEdit *pEdit = reinterpret_cast<CEdit *>( GetDlgItem( IDC_EDIT_STRING ));

    bool enableAllowed = (pList->IsWindowEnabled() == TRUE)?true:false;

    CString strValue;
    pEdit->GetWindowText( strValue );
    pAdd->EnableWindow( (!strValue.IsEmpty()) && enableAllowed);

    // Fill optionvalue with list entries.

    optValue.SetUpperBound( pList->GetCount());
    
    CString str;
    for ( int i = 0; i < pList->GetCount(); i++ ) 
    {
      pList->GetText( i, str );
      optValue.SetString( str, i );
    } // for 

    if ( pList->GetCount() == 0 ) 
    {
      pRemove->EnableWindow( FALSE );
      pUp->EnableWindow( FALSE );
      pDown->EnableWindow( FALSE );
      return;
    }
    int nSel = pList->GetCurSel();
    if ( LB_ERR != nSel ) 
    {
      pRemove->EnableWindow(enableAllowed);
      pUp->EnableWindow( (nSel > 0) && enableAllowed);
      pDown->EnableWindow( (pList->GetCount() > ( nSel + 1 )) && enableAllowed);
    } // if

    // check if the focus in on a disabled control
    // If yes, put the focus back to list box
    if ( !::IsWindowEnabled( ::GetFocus())) {
        pList->SetFocus();
    }

} // COptionsCfgPropPage::HandleActivationStringArray()

void COptionsCfgPropPage::HandleActivationIpArray()
{
   CString strServerName;
   CWndIpAddress * pIpAddr = reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_SERVER_ADDRESS));
   CButton * pResolve = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_RESOLVE));
   CButton * pAdd = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_ADD));
   CButton * pRemove = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_DELETE));
   CButton * pUp = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_UP));
   CButton * pDown = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_IPADDR_DOWN));
   CEdit * pServerName = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_SERVER_NAME));
   CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_IP_ADDRS));

   bool enableAllowed = (pListBox->IsWindowEnabled() == TRUE)?true:false;

   // set the resolve button
   pServerName->GetWindowText(strServerName);
   pResolve->EnableWindow((strServerName.GetLength() > 0) && enableAllowed);

   // the add button
   DWORD dwIpAddr = 0;
   pIpAddr->GetAddress(&dwIpAddr);

   if (GetFocus() == pAdd &&
      dwIpAddr == 0)
   {
      pIpAddr->SetFocus();
      SetDefID(IDOK);
   }
   pAdd->EnableWindow((dwIpAddr != 0) && enableAllowed);

   // Make sure something in listbox is selected
   if ( pListBox->GetCount() > 0 ) {
       if ( LB_ERR == pListBox->GetCurSel()) {
           pListBox->SetCurSel( 0 ); // select the first one
       }
   }

   // the remove button
   if (GetFocus() == pRemove &&
      pListBox->GetCurSel() < 0)
   {
      pIpAddr->SetFocus();
      SetDefID(IDOK);
   }
   pRemove->EnableWindow((pListBox->GetCurSel() >= 0) && enableAllowed);

   // up and down buttons
   BOOL bEnableUp = (pListBox->GetCurSel() >= 0) && (pListBox->GetCurSel() != 0);
   pUp->EnableWindow(bEnableUp && enableAllowed);

   BOOL bEnableDown = (pListBox->GetCurSel() >= 0) && (pListBox->GetCurSel() < pListBox->GetCount() - 1);
   pDown->EnableWindow(bEnableDown && enableAllowed);

} // COptionsCfgPropPage::HandleActivationIpArray()

void COptionsCfgPropPage::HandleActivationValueArray()
{
   CButton * pAdd = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_ADD));
   CButton * pRemove = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_DELETE));
   CButton * pUp = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_UP));
   CButton * pDown = reinterpret_cast<CButton *>(GetDlgItem(IDC_BUTTON_VALUE_DOWN));
   CButton * pRadioDecimal = reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO_DECIMAL));
   CEdit * pValue = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_VALUE));
   CListBox * pListBox = reinterpret_cast<CListBox *>(GetDlgItem(IDC_LIST_VALUES));
   
   bool enableAllowed = (pListBox->IsWindowEnabled() == TRUE)?true:false;

   CString strValue;
      
   pValue->GetWindowText( strValue );
   pAdd->EnableWindow( !strValue.IsEmpty() && enableAllowed);

   if ( pListBox->GetCount() == 0 ) 
   {
      pRemove->EnableWindow( FALSE );
      pUp->EnableWindow( FALSE );
      pDown->EnableWindow( FALSE );
      return;
   }

   int nSel = pListBox->GetCurSel();
   if ( LB_ERR != nSel ) 
   {
      pRemove->EnableWindow( enableAllowed );
      pUp->EnableWindow( (nSel > 0) && enableAllowed );
      pDown->EnableWindow( (pListBox->GetCount() > ( nSel + 1 ))
                           && enableAllowed);
   }
} // COptionsCfgPropPage::HandleActivationValueArray()

void COptionsCfgPropPage::HandleActivationRouteArray(
    CDhcpOptionValue *optValue
    )
{
   // this route will enable the right dialog items and also set
   // focus correctly.

   // get the routes list control
   CListCtrl *pList = reinterpret_cast<CListCtrl *>(
      GetDlgItem( IDC_LIST_OF_ROUTES ) );

   bool enableAllowed = (pList->IsWindowEnabled() == TRUE)?true:false;

   // get the add and remove buttons
   CButton *pAdd = reinterpret_cast<CButton *>(
      GetDlgItem(IDC_BUTTON_ROUTE_ADD) );
   CButton *pRemove = reinterpret_cast<CButton *>(
         GetDlgItem(IDC_BUTTON_ROUTE_DEL) );
   
   if( optValue )
   {
      // also, format the whole list of ip addresses into
      // binary type..  allocate large enough buffer

      int nItems = pList->GetItemCount();
      LPBYTE Buffer = new BYTE [sizeof(DWORD)*4 * nItems];
      if( NULL != Buffer )
      {
         int BufSize = 0;
         for( int i = 0 ; i < nItems ; i ++ )
         {
               DHCP_IP_ADDRESS Dest, Mask, Router;
               Dest = UtilCvtWstrToIpAddr(pList->GetItemText(i, 0));
               Mask = UtilCvtWstrToIpAddr(pList->GetItemText(i, 1));
               Router = UtilCvtWstrToIpAddr(pList->GetItemText(i, 2));

               Dest = htonl(Dest);
               Router = htonl(Router);

               int nBitsInMask = 0;
               while( Mask != 0 ) {
                  nBitsInMask ++; Mask = (Mask << 1);
               }

               // first add destination descriptor
               // first byte contains # of bits in mask
               // next few bytes contain the dest address for only
               // the significant octets
               Buffer[BufSize++] = (BYTE)nBitsInMask;
               memcpy(&Buffer[BufSize], &Dest, (nBitsInMask+7)/8);
               BufSize += (nBitsInMask+7)/8;

               // now just copy the router address
               memcpy(&Buffer[BufSize], &Router, sizeof(Router));
               BufSize += sizeof(Router);
         } // for

         // now write back the option value
         DHCP_OPTION_DATA_ELEMENT DataElement = {DhcpBinaryDataOption };
         DHCP_OPTION_DATA Data = { 1, &DataElement };
         DataElement.Element.BinaryDataOption.DataLength = BufSize;
         DataElement.Element.BinaryDataOption.Data = Buffer;
         
         optValue->SetData( &Data );
         delete[] Buffer;
      } // if
   } // if 
   
   // enable the remove button only if there are any
   // elements at all
   pRemove->EnableWindow( (pList->GetItemCount() > 0) && enableAllowed );

   // Set the focus on Add
   pAdd->SetFocus();

} // COptionsCfgPropPage::HandleActivationRouteArray()

BOOL COptionsCfgPropPage::OnApply() 
{
    BOOL bErrors = FALSE;
    DWORD err = 0;
    LPCTSTR pClassName;
    COptionsConfig * pOptConfig = reinterpret_cast<COptionsConfig *>(GetHolder());
    
    LPWSTR pszServerAddr = pOptConfig->GetServerAddress();
    
    if (IsDirty()) {
        BEGIN_WAIT_CURSOR;
   
        // loop through all vendors first
        POSITION posv = ((COptionsConfig *)
          GetHolder())->m_listVendorClasses.GetHeadPosition();
        while (posv) {
            CVendorTracker * pVendorTracker =
      ((COptionsConfig *) GetHolder())->m_listVendorClasses.GetNext(posv);
       
            // loop through all classes and see if we have any options we need to update
            POSITION pos = pVendorTracker->m_listUserClasses.GetHeadPosition();
            while (pos) {
      CClassTracker * pClassTracker =
          pVendorTracker->m_listUserClasses.GetNext(pos);
      
                pClassName = pClassTracker->m_strClassName.IsEmpty() 
          ? NULL
          : (LPCTSTR) pClassTracker->m_strClassName;
      
                POSITION posOption = pClassTracker->m_listOptions.GetHeadPosition();
                while (posOption) {
                    COptionTracker * pCurOptTracker = 
         pClassTracker->m_listOptions.GetNext(posOption);
          
                    if (pCurOptTracker->IsDirty()) {
         // we need to update this option
         CDhcpOption * pCurOption = pCurOptTracker->m_pOption;
         CDhcpOptionValue & optValue = pCurOption->QueryValue();

         // check to see if the option has changed
                        if ((pCurOptTracker->GetInitialState() == OPTION_STATE_INACTIVE) &&
             (pCurOptTracker->GetCurrentState() == OPTION_STATE_INACTIVE)) {
             // the state hasn't changed, the user must have changed the
             // state and then restored it to its original value
             err = ERROR_SUCCESS;
         }
         else if ((pCurOptTracker->GetInitialState() == OPTION_STATE_ACTIVE) &&
             (pCurOptTracker->GetCurrentState() == OPTION_STATE_INACTIVE)) {
                            // if it is a vendor specific or class ID option, call the V5 api
                            if ( pOptConfig->m_liServerVersion.QuadPart >= DHCP_NT5_VERSION) {
            err = ::DhcpRemoveOptionValueV5(pszServerAddr,
                                                                pCurOption->IsVendor() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                        pCurOption->QueryId(),
                                                                (LPTSTR) pClassName,
                                                                (LPTSTR) pCurOption->GetVendor(),
                        &pOptConfig->m_pOptionValueEnum->m_dhcpOptionScopeInfo ) ;
                            }
                            else {
                                // need to remove this option for either global, scope or res client
            err = ::DhcpRemoveOptionValue(pszServerAddr,
                           pCurOption->QueryId(),
                           &pOptConfig->m_pOptionValueEnum->m_dhcpOptionScopeInfo ) ;
                            }
         } // elseif 
         else {
                            // check option 33
                            if ((pCurOption->QueryId() == 33 || pCurOption->QueryId() == 21) &&
                                ( !pCurOption->IsVendor()) &&
                                (pCurOption->QueryValue().QueryUpperBound()) % 2 != 0) {
                                // special case for option 33 & 21.  Make sure it is a set of IP addres pairs
                                // and make sure we pick the right page to select
                                int nId = pClassName ? 1 : 0;
                                PropSheet_SetCurSel(GetHolder()->GetSheetWindow(), GetSafeHwnd(), nId);
                                SelectOption(pCurOption);

                                ::DhcpMessageBox(IDS_ERR_OPTION_ADDR_PAIRS);
                                m_listctrlOptions.SetFocus();
                                return 0;
                            } // if 

             // we are just updating this option
             DHCP_OPTION_DATA * pOptData;
             err = optValue.CreateOptionDataStruct(&pOptData);
             if (err) {
            ::DhcpMessageBox(err);
                                RESTORE_WAIT_CURSOR;

            bErrors = TRUE;
            continue;
             }

                            // if it is a vendor specific or class ID option, call the V5 api
                            if ( ((COptionsConfig *)GetHolder())->m_liServerVersion.QuadPart >= DHCP_NT5_VERSION ) {
            err = ::DhcpSetOptionValueV5(pszServerAddr,
                                                             pCurOption->IsVendor() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                                             pCurOption->QueryId(),
                                                             (LPTSTR) pClassName,
                                                             (LPTSTR) pCurOption->GetVendor(),
                          &pOptConfig->m_pOptionValueEnum->m_dhcpOptionScopeInfo,
                          pOptData);
                            }
                            else {
            err = ::DhcpSetOptionValue(pszServerAddr,
                        pCurOption->QueryId(),
                        &pOptConfig->m_pOptionValueEnum->m_dhcpOptionScopeInfo,
                        pOptData);
                            }
         } // else

         if (err) {
             ::DhcpMessageBox(err);
                            RESTORE_WAIT_CURSOR;
             
             bErrors = TRUE;
         }
         else {
             // all done with this option.  Mark as clean and update
                            // the new initial state to the current state.
                            pCurOptTracker->SetDirty(FALSE);
             pCurOptTracker->SetInitialState(pCurOptTracker->GetCurrentState());
             
         }
                    } // endif option->IsDirty()
                } // while user class options
            } // while User class loop
        } // while Vendor loop
   
        END_WAIT_CURSOR;
    }// endif IsDirty()

    if (bErrors) {
        return 0;
    }
    else {
        BOOL bRet = CPropertyPageBase::OnApply();
   
   if (bRet == FALSE) {
       // Something bad happened... grab the error code
       AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
       ::DhcpMessageBox(GetHolder()->GetError());
   }
   
        return bRet;
    } // else
} // COptionsCfgPropPage::OnApply()

// need to refresh the UI on the main app thread...
BOOL COptionsCfgPropPage::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode spNode;
    spNode = GetHolder()->GetNode();
    
    CMTDhcpHandler * pMTHandler = GETHANDLER(CMTDhcpHandler, spNode);
    
    pMTHandler->OnRefresh(spNode, NULL, 0, 0, 0);
    
    return FALSE;
}

//
//  See if any of the edit fields have been changed and perform the alteration.
//  Return TRUE if the value was changed.
//
BOOL COptionsCfgPropPage::HandleValueEdit()
{
   LONG err = 0;
   int nSelectedIndex = m_listctrlOptions.GetSelectedItem();
   
   if (nSelectedIndex > -1)
   {
      COptionTracker * pOptTracker = 
         reinterpret_cast<COptionTracker *>(m_listctrlOptions.GetItemData(nSelectedIndex));
      CEdit * pDwordEdit = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_DWORD));
      CWndIpAddress * pIpAddr = reinterpret_cast<CWndIpAddress *>(GetDlgItem(IDC_IPADDR_ADDRESS));
      CEdit * pString = reinterpret_cast<CEdit *>(GetDlgItem(IDC_EDIT_STRING_VALUE));

      CDhcpOptionValue & dhcValue = pOptTracker->m_pOption->QueryValue();
      DHCP_OPTION_DATA_TYPE dhcType = dhcValue.QueryDataType();
      DHCP_IP_ADDRESS dhipa ;
      CString strEdit;
      BOOL bModified = FALSE;

      switch ( dhcType )
      {
      case DhcpByteOption:
      case DhcpWordOption:
      case DhcpDWordOption:
      case DhcpBinaryDataOption:
         {
            DWORD dwResult;
            DWORD dwMask = 0xFFFFFFFF;
            if (dhcType == DhcpByteOption)
            {
               dwMask = 0xFF;
            }
            else if (dhcType == DhcpWordOption)
            {
               dwMask = 0xFFFF;
            }
            
            if (!FGetCtrlDWordValue(pDwordEdit->GetSafeHwnd(), &dwResult, 0, dwMask))
            {
               return FALSE;
            }
            
            // only mark this dirty if the value has changed as we may just
            // be updating the UI
            if (dwResult != (DWORD) dhcValue.QueryNumber(0))
            {
               bModified = TRUE ;
               (void)dhcValue.SetNumber(dwResult, 0); 
               ASSERT(err == FALSE);
            }
            break;
         }

      case DhcpDWordDWordOption: 
         {
            DWORD_DWORD     dwdw;
            CString         strValue;
         
            pDwordEdit->GetWindowText(strValue);
      
            UtilConvertStringToDwordDword(strValue, &dwdw);
                  
            // only mark this dirty if the value has changed as we may just
            // be updating the UI
            if (( dwdw.DWord1 != dhcValue.QueryDwordDword(0).DWord1 ) ||
                ( dwdw.DWord2 != dhcValue.QueryDwordDword(0).DWord2 )) 
            {
               bModified = TRUE;
               dhcValue.SetDwordDword(dwdw, 0);
            }
            break;
         }

      case DhcpStringDataOption:
         {
            pString->GetWindowText( strEdit );

            // only mark this dirty if the value has changed as we may just
            // be updating the UI
            if (strEdit.Compare(dhcValue.QueryString(0)) != 0)
            {
               bModified = TRUE;
               err = dhcValue.SetString( strEdit, 0 );
            }

            break ;
         }

      case DhcpIpAddressOption:
         {
            if (!pIpAddr->GetModify()) 
            {
               break ;
            }
            
            if ( !pIpAddr->IsBlank() )
            {
               if ( !pIpAddr->GetAddress(&dhipa) )
               {
                  err = ERROR_INVALID_PARAMETER;
                  break; 
               }

               // only mark this dirty if the value has changed as we may just
               // be updating the UI
               if (dhipa != dhcValue.QueryIpAddr(0))
               {
               bModified = TRUE ;
               err = dhcValue.SetIpAddr( dhipa, 0 ); 
               }
            }
            break;
         }

      default:
         {
            Trace0("invalid value type in HandleValueEdit");
            Assert( FALSE );
            err = ERROR_INVALID_PARAMETER;
            break;
         }
      }

      if (err)
      {
         ::DhcpMessageBox(err);
      }
      else if (bModified)
      {
         pOptTracker->SetDirty(TRUE);
         SetDirty(TRUE);
      }
   }

    return err == 0 ;
}


/////////////////////////////////////////////////////////////////////////////
//
// COptionCfgGeneral page
//
/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(COptionCfgGeneral, COptionsCfgPropPage)
   //{{AFX_MSG_MAP(COptionCfgGeneral)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNCREATE(COptionCfgGeneral, COptionsCfgPropPage)

COptionCfgGeneral::COptionCfgGeneral() 
    : COptionsCfgPropPage(IDP_OPTION_BASIC) 
{
   //{{AFX_DATA_INIT(COptionCfgGeneral)
   //}}AFX_DATA_INIT
}

COptionCfgGeneral::COptionCfgGeneral(UINT nIDTemplate, UINT nIDCaption) 
    : COptionsCfgPropPage(nIDTemplate, nIDCaption) 
{
}

COptionCfgGeneral::~COptionCfgGeneral()
{
}

void COptionCfgGeneral::DoDataExchange(CDataExchange* pDX)
{
   COptionsCfgPropPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(COptionCfgGeneral)
   //}}AFX_DATA_MAP
}

BOOL COptionCfgGeneral::OnInitDialog() 
{
   COptionsCfgPropPage::OnInitDialog();
   
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // check to see if we should focus on a particular option
    COptionsConfig * pOptionsConfig = (COptionsConfig *) GetHolder();
   if (pOptionsConfig->m_dhcpStartId != 0xffffffff)
    {
        // check to see if this option is on the advanced page
        if (!pOptionsConfig->m_strStartVendor.IsEmpty() ||
            !pOptionsConfig->m_strStartClass.IsEmpty()) 
        {
            // this option is on the advanced page
            ::PostMessage(pOptionsConfig->GetSheetWindow(), PSM_SETCURSEL, (WPARAM)1, NULL);
            return TRUE;
        }

        // find the option to select
        OnSelectOption(0,0);
    }

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
//
// COptionCfgAdvanced page
//
/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(COptionCfgAdvanced, COptionsCfgPropPage)
   //{{AFX_MSG_MAP(COptionCfgAdvanced)
   ON_CBN_SELENDOK(IDC_COMBO_USER_CLASS, OnSelendokComboUserClass)
   ON_CBN_SELENDOK(IDC_COMBO_VENDOR_CLASS, OnSelendokComboVendorClass)
   //}}AFX_MSG_MAP

    ON_MESSAGE(WM_SELECTCLASSES, OnSelectClasses)

END_MESSAGE_MAP()

IMPLEMENT_DYNCREATE(COptionCfgAdvanced, COptionsCfgPropPage)

COptionCfgAdvanced::COptionCfgAdvanced() 
    : COptionsCfgPropPage(IDP_OPTION_ADVANCED) 
{
   //{{AFX_DATA_INIT(COptionCfgAdvanced)
   //}}AFX_DATA_INIT

    m_helpMap.BuildMap(DhcpGetHelpMap(IDP_OPTION_ADVANCED));
}

COptionCfgAdvanced::COptionCfgAdvanced(UINT nIDTemplate, UINT nIDCaption) 
    : COptionsCfgPropPage(nIDTemplate, nIDCaption) 
{
    m_helpMap.BuildMap(DhcpGetHelpMap(IDP_OPTION_ADVANCED));
}

COptionCfgAdvanced::~COptionCfgAdvanced()
{
}

void COptionCfgAdvanced::DoDataExchange(CDataExchange* pDX)
{
   COptionsCfgPropPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(COptionCfgAdvanced)
   DDX_Control(pDX, IDC_COMBO_USER_CLASS, m_comboUserClasses);
   DDX_Control(pDX, IDC_COMBO_VENDOR_CLASS, m_comboVendorClasses);
   //}}AFX_DATA_MAP
}

BOOL COptionCfgAdvanced::OnInitDialog() 
{
   CPropertyPageBase::OnInitDialog();
   
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // initialize the list control
   InitListCtrl();

   // initialize the option data
    // this gets done in the general page init, only needs 
    // to be done once
    /*
   DWORD dwErr = ((COptionsConfig *) GetHolder())->InitData();
   if (dwErr != ERROR_SUCCESS)
   {
      // CODEWORK:  need to exit gracefull if this happens     
      ::DhcpMessageBox(dwErr);
   }
    */
    
    // add the standard vendor class name
    int nSel;
    CString strVendor, strClass;
    
    strVendor.LoadString(IDS_INFO_NAME_DHCP_DEFAULT);
    nSel = m_comboVendorClasses.AddString(strVendor);
    m_comboVendorClasses.SetCurSel(nSel);

    // add the default user class name
    strClass.LoadString(IDS_USER_STANDARD);
    nSel = m_comboUserClasses.AddString(strClass);
    m_comboUserClasses.SetCurSel(nSel);

    // now add all the other classes
    SPITFSNode spNode;
    spNode = ((COptionsConfig *) GetHolder())->GetServerNode();

    CDhcpServer * pServer = GETHANDLER(CDhcpServer, spNode);
    CClassInfoArray ClassInfoArray;

    // add all the classes to the appropriate classes to the dropdown
    pServer->GetClassInfoArray(ClassInfoArray);
    for (int i = 0; i < ClassInfoArray.GetSize(); i++)
    {
        if (!ClassInfoArray[i].bIsVendor)
            m_comboUserClasses.AddString(ClassInfoArray[i].strName);
        else
            m_comboVendorClasses.AddString(ClassInfoArray[i].strName);
    }

    // now fill the options listbox with whatever class is selected
    ((COptionsConfig *) GetHolder())->FillOptions(strVendor, strClass, m_listctrlOptions);
    m_bNoClasses = FALSE;

    // Create the type control switcher
    m_cgsTypes.Create(this,IDC_DATA_ENTRY_ANCHOR,cgsPreCreateAll);
    
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_NONE, IDD_DATA_ENTRY_NONE, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_DWORD, IDD_DATA_ENTRY_DWORD, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_IPADDRESS, IDD_DATA_ENTRY_IPADDRESS, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_IPADDRESS_ARRAY, IDD_DATA_ENTRY_IPADDRESS_ARRAY,   NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_STRING, IDD_DATA_ENTRY_STRING, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_BINARY_ARRAY, IDD_DATA_ENTRY_BINARY_ARRAY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_BINARY, IDD_DATA_ENTRY_BINARY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_ROUTE_ARRAY, IDD_DATA_ENTRY_ROUTE_ARRAY, NULL);
    m_cgsTypes.AddGroup(IDC_DATA_ENTRY_STRING_ARRAY, IDD_DATA_ENTRY_STRING_ARRAY, NULL);
    
    SwitchDataEntry(-1, -1, 0, TRUE);
    
    m_bInitialized = TRUE;

    // check to see if we should focus on a particular option
    COptionsConfig * pOptionsConfig = (COptionsConfig *) GetHolder();
   if (pOptionsConfig->m_dhcpStartId != 0xffffffff)
    {
        // yes, first select the appropriate vendor/ user class
        Assert(!pOptionsConfig->m_strStartVendor.IsEmpty() ||
               !pOptionsConfig->m_strStartClass.IsEmpty());

        if (!pOptionsConfig->m_strStartVendor.IsEmpty())
            m_comboVendorClasses.SelectString(-1, pOptionsConfig->m_strStartVendor);

        if (!pOptionsConfig->m_strStartClass.IsEmpty())
            m_comboUserClasses.SelectString(-1, pOptionsConfig->m_strStartClass);

        // update the list of options
        OnSelendokComboVendorClass();

        // now find the option
        OnSelectOption(0,0);
    }

    SetDirty(FALSE); 

    return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void COptionCfgAdvanced::OnSelendokComboUserClass() 
{
    OnSelendokComboVendorClass();
}

void COptionCfgAdvanced::OnSelendokComboVendorClass() 
{
    // If we have classes defined then its time to switch up the list ctrl
    if (m_bNoClasses == FALSE)
    {
        CString strSelectedVendor, strSelectedClass;
        int nSelVendorIndex = m_comboVendorClasses.GetCurSel();
        int nSelClassIndex = m_comboUserClasses.GetCurSel();

        m_comboVendorClasses.GetLBText(nSelVendorIndex, strSelectedVendor);
        m_comboUserClasses.GetLBText(nSelClassIndex, strSelectedClass);

        // mark the page as not initiailzed while we redo the options
        m_bInitialized = FALSE;

        m_listctrlOptions.DeleteAllItems();
        ((COptionsConfig *) GetHolder())->FillOptions(strSelectedVendor, strSelectedClass, m_listctrlOptions);

        m_bInitialized = TRUE;

        SwitchDataEntry( -1, -1, 0, TRUE );
    }
}

long COptionCfgAdvanced::OnSelectClasses(UINT wParam, LONG lParam)
{
    CString * pstrVendor = (CString *) ULongToPtr(wParam);
    CString * pstrClass = (CString *) ULongToPtr(lParam);

    if (pstrVendor->IsEmpty())
        pstrVendor->LoadString(IDS_INFO_NAME_DHCP_DEFAULT);

    if (pstrClass->IsEmpty())
       pstrClass->LoadString(IDS_USER_STANDARD);

    m_comboVendorClasses.SelectString(-1, *pstrVendor);
    m_comboUserClasses.SelectString(-1, *pstrClass);

    // update the list of options
    OnSelendokComboVendorClass();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\helparr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
    helparr.h
        The help ID mappings
        
    FILE HISTORY:
        
*/
#ifndef HELPARR_H
#define HELPARR_H

#define IDH_LIST_SUPERSCOPES    200000002
#define IDH_EDIT_VALUE    200000034
#define IDH_BUTN_ADD    200000035
#define IDH_BUTN_DELETE    200000036
#define IDH_LIST_VALUES    200000038
#define IDH_RADIO_DECIMAL    200000040
#define IDH_RADIO_HEX    200000041
#define IDH_EDIT_BOOTP_IMAGE_NAME    200000051
#define IDH_EDIT_BOOTP_FILE_NAME    200000053
#define IDH_EDIT_BOOTP_FILE_SERVER    200000055
#define IDH_LIST_VALID_SERVERS    200000076
#define IDH_BUTTON_AUTHORIZE    200000077
#define IDH_BUTTON_REMOVE    200000078
#define IDH_BUTTON_REFRESH    200000079
#define IDH_LIST_CLASSES    200000101
#define IDH_BUTTON_NEW    200000102
#define IDH_BUTTON_DELETE    200000103
#define IDH_BUTTON_EDIT    200000104
#define IDH_VALUENAME    200000126
#define IDH_VALUECOMMENT    200000128
#define IDH_VALUEDATA    200000132
#define IDH_VALUEDATA2    200000154
#define IDH_EDIT_DWORD    200000202
#define IDH_IPADDR_ADDRESS    200000227
#define IDH_IPADDR_SERVER_ADDRESS    200000252
#define IDH_BUTTON_IPADDR_ADD    200000253
#define IDH_BUTTON_IPADDR_DELETE    200000254
#define IDH_LIST_IP_ADDRS    200000256
#define IDH_EDIT_SERVER_NAME    200000258
#define IDH_BUTTON_RESOLVE    200000259
#define IDH_EDIT_STRING_VALUE    200000277
#define IDH_COMBO_OPTION_CLASS    200000301
#define IDH_COMBO_OPTION_NAME    200000303
#define IDH_BUTN_NEW_OPTION    200000304
#define IDH_BUTN_DELETE2    200000305
#define IDH_BUTN_OPTION_PRO    200000306
#define IDH_EDIT_COMMENT    200000308
#define IDH_EDIT_VALUE_ARRAY    200000311
#define IDH_BUTN_VALUE    200000312
#define IDH_EDIT_NAME    200000328
#define IDH_COMBO_DATA_TYPE    200000330
#define IDH_CHECK_ARRAY    200000331
#define IDH_EDIT_TYPE_ID    200000333
#define IDH_EDIT_TYPE_COMMENT    200000335
#define IDH_IPADDR_EXCLUSION_FROM    200000352
#define IDH_IPADDR_EXCLUSION_TO    200000354
#define IDH_EDIT_SERVER_NAME_IP    200000377
#define IDH_IPADDR_NEW    200000407
#define IDH_BUTN_DELETE3    200000409
#define IDH_BUTN_RESOLVE    200000412
#define IDH_LIST_RECONCILE_IP_ADDRESSES    200000426
#define IDH_IPADDR_RESERVATION_IP    200000451
#define IDH_EDIT_CLIENT_UID    200000453
#define IDH_EDIT_CLIENT_NAME    200000455
#define IDH_EDIT_CLIENT_COMMENT    200000457
#define IDH_RADIO_TYPE_DHCP    200000459
#define IDH_RADIO_TYPE_BOOTP    200000460
#define IDH_RADIO_TYPE_BOTH    200000461
#define IDH_IPADDR_CLIENT_ADDRESS    200000502
#define IDH_IPADDR_CLIENT_SUBNET_MASK    200000504
#define IDH_EDIT_CLIENT_NAME2    200000508
#define IDH_EDIT_CLIENT_COMMENT2    200000510
#define IDH_EDIT_LEASE_EXPIRES    200000512
#define IDH_EDIT_CLIENT_TYPE    200000514
#define IDH_CHECK_ENABLE_DYN_DNS    200000525
#define IDH_RADIO_CLIENT    200000527
#define IDH_RADIO_ALWAYS    200000528
#define IDH_CHECK_GARBAGE_COLLECT    200000530
#define IDH_CHECK_UPDATE_DOWNLEVEL    200000531
#define IDH_EDIT_SCOPE_NAME    200000552
#define IDH_IPADDR_START    200000555
#define IDH_IPADDR_END    200000557
#define IDH_EDIT_SCOPEID    200000559
#define IDH_EDIT_TTL    200000561
#define IDH_CHECK_DEFAULT    200000562
#define IDH_RADIO_LEASE_UNLIMITED    200000564
#define IDH_RADIO_LEASE_LIMITED    200000565
#define IDH_EDIT_LEASE_DAYS    200000566
#define IDH_EDIT_LEASE_HOURS    200000568
#define IDH_EDIT_LEASE_MINUTES    200000570
#define IDH_EDIT_SCOPE_COMMENT    200000573
#define IDH_COMBO_VENDOR_CLASS    200000576
#define IDH_COMBO_USER_CLASS    200000578
#define IDH_LIST_OPTIONS    200000580
#define IDH_LIST_OPTIONS2    200000601
#define IDH_EDIT_OPTION_NAME    200000627
#define IDH_EDIT_OPTION_CLASS    200000629
#define IDH_EDIT_OPTION_TYPE    200000631
#define IDH_EDIT_OPTION_COMMENT    200000633
#define IDH_IPADDR_IP_ADDRESS    200000636
#define IDH_BUTN_ADD2    200000637
#define IDH_BUTN_DELETE4    200000638
#define IDH_LIST_IP_ADDRS2    200000640
#define IDH_IPADDR_RES_CLIENT_ADDRESS    200000652
#define IDH_EDIT_UNIQUE_IDENTIFIER    200000654
#define IDH_EDIT_NAME2    200000656
#define IDH_EDIT_COMMENT2    200000658
#define IDH_RADIO_DHCP_ONLY    200000676
#define IDH_RADIO_DHCP_BOOTP    200000677
#define IDH_RADIO_BOOTP_ONLY    200000678
#define IDH_EDIT_SCOPE_NAME2    200000702
#define IDH_IPADDR_START2    200000705
#define IDH_IPADDR_END2    200000707
#define IDH_IPADDR_MASK    200000709
#define IDH_EDIT_SUBNET_MASK_LENGTH    200000711
#define IDH_EDIT_SCOPE_COMMENT2    200000722
#define IDH_EDIT_CONFLICT_ATTEMPTS    200000727
#define IDH_EDIT_LOG_PATH    200000729
#define IDH_EDIT_DATABASE_PATH    200000731
#define IDH_BUTTON_BROWSE_LOG    200000732
#define IDH_BUTTON_BROWSE_DATABASE     200000733
#define IDH_CHECK_AUTO_REFRESH    200000752
#define IDH_EDIT_REFRESH_HOURS    200000754
#define IDH_EDIT_REFRESH_MINUTES    200000755
#define IDH_CHECK_AUDIT_LOGGING    200000757
#define IDH_CHECK_SHOW_BOOTP    200000759
#define IDH_CHECK_SHOW_ROGUE    200000760
#define IDH_EDIT_SERVER_GROUP_NAME    200000778
#define IDH_EDIT_SUPERSCOPE_NAME    200000803
#define IDH_BUTTON_VALUE_DOWN    200000042
#define IDH_BUTTON_VALUE_UP    200000043
#define IDH_STATIC_MODIFY_BINDINGS_STRING 200000734
#define IDH_BUTTON_BINDINGS 200000735
#define IDH_LIST_BINDINGS 200000850
#define IDH_RADIO_MSCOPE_INFINITE 200000860
#define IDH_RADIO_MSCOPE_FINITE 200000861
#define IDH_DATETIMEPICKER_DATE 200000862
#define IDH_DATETIMEPICKER_TIME 200000863
#define IDH_EDIT_VALUE_STRING 200000864
#define IDH_EDIT_VALUE_NUM 200000865
#define IDH_IPADDR_VALUE 200000866
#define IDH_RADIO_ANY_SERVER 200000867
#define IDH_RADIO_AUTHORIZED_SERVERS 200000868
#define IDH_EDIT_ADD_SERVER_NAME 200000869
#define IDH_BUTTON_BROWSE_SERVERS 200000870
#define IDH_LIST_AUTHORIZED_SERVERS 200000871
#define IDH_BUTTON_BROWSE_BACKUP 200000872
#define IDH_EDIT_BACKUP 200000873
#define IDH_BUTTON_CREDENTIALS 200000874
#define IDH_EDIT_CRED_USERNAME 200000875
#define IDH_EDIT_CRED_DOMAIN 200000876
#define IDH_EDIT_CRED_PASSWORD 200000877
#define IDH_EDIT_CRED_PASSWORD2 200000878
#define IDH_EDIT_AUTH_NAME 200000879
#define IDH_IPADDR_AUTH 200000880
#define IDH_LIST_OF_ROUTES 200000881
#define IDH_BUTTON_ROUTE_ADD 200000882
#define IDH_BUTTON_ROUTE_DEL 200000883
#define IDH_BUTTON_STRING_ARRAY_ADD 200000884
#define IDH_BUTTON_STRING_ARRAY_REMOVE 200000885
#define IDH_BUTTON_STRING_ARRAY_UP  200000886
#define IDH_BUTTON_STRING_ARRAY_DOWN 200000887
#define IDH_LIST_STRING_ARRAY 200000888
#define IDH_STATIC_BACKUP_PATH 200000889
#define IDH_STATIC_CREDENTIALS 200000890

#define IDH_STATIC_CRED_USER_NAME 200000891
#define IDH_STATIC_CRED_DOMAIN    200000892
#define IDH_STATIC_CRED_PASSWORD  200000893
#define IDH_STATIC_CRED_CONFIRM_PASSWORD 200000894
#define IDH_EDIT_STRING_ARRAY_VALUE 200000895
#define IDH_STATIC_APPLICATION 200000896
#define IDH_STATIC_OPTION_NAME 200000897
#define IDH_BUTN_ROUTE_ADD 200000898
#define IDH_BUTN_ROUTE_DELETE 200000899
#define IDH_STRING_ARRAY_CUR_VALUE 200000900
#define IDH_STRING_ARRAY_NEW_VALUE 200000901

#define IDH_STATIC_DESTINATION 200000902
#define IDH_STATIC_NETWORK_MASK 200000903
#define IDH_STATIC_ROUTER       200000904
#define IDH_IPADDR_ADDRESS2     200000905
#define IDH_IPADDR_ADDRESS3     200000906
#define IDH_BUTTON_TRING_ARRAY_ADD 200000907

#define IDH_DISABLEHELP    ((DWORD)-1)

const DWORD g_aHelpIDs_IDD_ADD_TO_SUPERSCOPE[]=
{
    IDC_LIST_SUPERSCOPES, IDH_LIST_SUPERSCOPES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_BINARY_EDITOR[]=
{
    IDC_EDIT_VALUE, IDH_EDIT_VALUE,
    IDC_BUTN_ADD, IDH_BUTN_ADD,
    IDC_BUTN_DELETE, IDH_BUTN_DELETE,
    IDC_LIST_VALUES, IDH_LIST_VALUES,
    IDC_RADIO_DECIMAL, IDH_RADIO_DECIMAL,
    IDC_RADIO_HEX, IDH_RADIO_HEX,
    IDC_BUTN_DOWN, IDH_BUTTON_VALUE_DOWN,
    IDC_BUTN_UP, IDH_BUTTON_VALUE_UP,
    IDC_STATIC_APPLICATION, IDH_DISABLEHELP,
    IDC_STATIC_OPTION_NAME, IDH_DISABLEHELP,
    IDC_STATIC_UNIT_SIZE, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_BOOTP_NEW[]=
{
    IDC_EDIT_BOOTP_IMAGE_NAME, IDH_EDIT_BOOTP_IMAGE_NAME,    
    IDC_EDIT_BOOTP_FILE_NAME, IDH_EDIT_BOOTP_FILE_NAME,
    IDC_EDIT_BOOTP_FILE_SERVER, IDH_EDIT_BOOTP_FILE_SERVER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_BROWSE_SERVERS[]=
{
    IDC_LIST_VALID_SERVERS, IDH_LIST_VALID_SERVERS,    
    IDC_BUTTON_AUTHORIZE, IDH_BUTTON_AUTHORIZE,
    IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE,
    IDC_BUTTON_REFRESH, IDH_BUTTON_REFRESH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_CLASSES[]=
{
    IDC_LIST_CLASSES, IDH_LIST_CLASSES,
    IDC_BUTTON_NEW, IDH_BUTTON_NEW,
    IDC_BUTTON_DELETE, IDH_BUTTON_DELETE,
    IDC_BUTTON_EDIT, IDH_BUTTON_EDIT,
    0, 0
};

const DWORD g_aHelpIDs_IDD_CLASSID_NEW[]=
{
    IDC_VALUENAME, IDH_VALUENAME,
    IDC_VALUECOMMENT, IDH_VALUECOMMENT,
    IDC_VALUEDATA, IDH_VALUEDATA,
    0, 0
};

const DWORD g_aHelpIDs_IDD_CREDENTIALS[]=
{
    IDC_EDIT_CRED_USERNAME, IDH_EDIT_CRED_USERNAME,
    IDC_EDIT_CRED_DOMAIN, IDH_EDIT_CRED_DOMAIN,
    IDC_EDIT_CRED_PASSWORD, IDH_EDIT_CRED_PASSWORD,
    IDC_EDIT_CRED_PASSWORD2, IDH_EDIT_CRED_PASSWORD2,
    IDC_STATIC_CRED_USER_NAME, IDH_STATIC_CRED_USER_NAME,
    IDC_STATIC_CRED_DOMAIN, IDH_STATIC_CRED_DOMAIN,
    IDC_STATIC_CRED_PASSWORD, IDH_STATIC_CRED_PASSWORD,
    IDC_STATIC_CRED_CONFIRM_PASSWORD, IDH_STATIC_CRED_CONFIRM_PASSWORD,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_ROUTE_ARRAY[] =
{
    IDC_LIST_OF_ROUTES, IDH_LIST_OF_ROUTES,
    IDC_BUTTON_ROUTE_ADD, IDH_BUTTON_ROUTE_ADD,
    IDC_BUTTON_ROUTE_DEL, IDH_BUTTON_ROUTE_DEL,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_STRING_ARRAY[] =
{
    IDC_LIST_STRING_ARRAY, IDH_LIST_STRING_ARRAY,
    IDC_EDIT_STRING, IDH_EDIT_STRING_ARRAY_VALUE,
    IDC_BUTTON_STRING_ARRAY_ADD, IDH_BUTTON_STRING_ARRAY_ADD,
    IDC_BUTTON_STRING_ARRAY_REMOVE, IDH_BUTTON_STRING_ARRAY_REMOVE,
    IDC_BUTTON_STRING_ARRAY_UP, IDH_BUTTON_STRING_ARRAY_UP,
    IDC_BUTTON_STRING_ARRAY_DOWN, IDH_BUTTON_STRING_ARRAY_DOWN,
    IDC_STRING_ARRAY_CUR_VALUE, IDH_STRING_ARRAY_CUR_VALUE,
    IDC_STRING_ARRAY_NEW_VALUE, IDH_STRING_ARRAY_NEW_VALUE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_BINARY[]=
{
    IDC_VALUEDATA, IDH_VALUEDATA2,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_BINARY_ARRAY[]=
{
    IDC_EDIT_VALUE, IDH_EDIT_VALUE,
    IDC_BUTTON_VALUE_ADD, IDH_BUTN_ADD,
    IDC_BUTTON_VALUE_DELETE, IDH_BUTN_DELETE,
    IDC_LIST_VALUES, IDH_LIST_VALUES,
    IDC_RADIO_DECIMAL, IDH_RADIO_DECIMAL,
    IDC_RADIO_HEX, IDH_RADIO_HEX,
    IDC_BUTTON_VALUE_DOWN, IDH_BUTTON_VALUE_DOWN,
    IDC_BUTTON_VALUE_UP, IDH_BUTTON_VALUE_UP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_DWORD[]=
{
    IDC_EDIT_DWORD, IDH_EDIT_DWORD,
    IDC_STATIC_TYPE, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS[]=
{
    IDC_IPADDR_ADDRESS, IDH_IPADDR_ADDRESS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS_ARRAY[]=
{
    IDC_IPADDR_SERVER_ADDRESS, IDH_IPADDR_SERVER_ADDRESS,
    IDC_BUTTON_IPADDR_ADD, IDH_BUTTON_IPADDR_ADD,    
    IDC_BUTTON_IPADDR_DELETE, IDH_BUTTON_IPADDR_DELETE,
    IDC_BUTTON_IPADDR_UP, IDH_BUTTON_VALUE_UP,
    IDC_BUTTON_IPADDR_DOWN, IDH_BUTTON_VALUE_DOWN,
    IDC_LIST_IP_ADDRS, IDH_LIST_IP_ADDRS2,
    IDC_EDIT_SERVER_NAME, IDH_EDIT_SERVER_NAME,
    IDC_BUTTON_RESOLVE, IDH_BUTTON_RESOLVE,    
    0, 0
};

const DWORD g_aHelpIDs_IDD_DATA_ENTRY_STRING[]=
{
    IDC_EDIT_STRING_VALUE, IDH_EDIT_STRING_VALUE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DEFAULT_VALUE[]=
{
    IDC_COMBO_OPTION_CLASS, IDH_COMBO_OPTION_CLASS,
    IDC_COMBO_OPTION_NAME,IDH_COMBO_OPTION_NAME,
    IDC_BUTN_NEW_OPTION, IDH_BUTN_NEW_OPTION,
    IDC_BUTN_DELETE, IDH_BUTN_DELETE2,
    IDC_BUTN_OPTION_PRO, IDH_BUTN_OPTION_PRO,
    IDC_EDIT_COMMENT, IDH_EDIT_COMMENT,
    IDC_EDIT_VALUE_ARRAY, IDH_EDIT_VALUE_ARRAY,
    IDC_BUTN_VALUE, IDH_BUTN_VALUE,
    IDC_EDIT_VALUE_STRING, IDH_EDIT_VALUE_STRING,
    IDC_EDIT_VALUE_NUM, IDH_EDIT_VALUE_NUM,
    IDC_IPADDR_VALUE, IDH_IPADDR_VALUE,
    IDC_STATIC_VALUE_DESC, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_DEFINE_PARAM[]=
{
    IDC_EDIT_NAME, IDH_EDIT_NAME,
    IDC_COMBO_DATA_TYPE, IDH_COMBO_DATA_TYPE,
    IDC_CHECK_ARRAY, IDH_CHECK_ARRAY,
    IDC_EDIT_TYPE_ID, IDH_EDIT_TYPE_ID,
    IDC_EDIT_TYPE_COMMENT, IDH_EDIT_TYPE_COMMENT,
    IDC_STATIC_CLASS_NAME, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_EXCLUSION_NEW[]=
{
    IDC_IPADDR_EXCLUSION_FROM, IDH_IPADDR_EXCLUSION_FROM,
    IDC_IPADDR_EXCLUSION_TO, IDH_IPADDR_EXCLUSION_TO,
    0, 0
};

const DWORD g_aHelpIDs_IDD_GET_SERVER[]=
{
    IDC_EDIT_SERVER_NAME_IP, IDH_EDIT_SERVER_NAME_IP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_GET_SERVER_CONFIRM[]=
{
    IDC_EDIT_AUTH_NAME, IDH_EDIT_AUTH_NAME,
    IDC_IPADDR_AUTH, IDH_IPADDR_AUTH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_IP_ARRAY_EDIT[]=
{
    IDC_STATIC_APPLICATION, IDH_DISABLEHELP,
    IDC_STATIC_OPTION_NAME, IDH_DISABLEHELP,
    IDC_IPADDR_NEW, IDH_IPADDR_NEW,
    IDC_BUTN_ADD, IDH_BUTN_ADD,
    IDC_BUTN_DELETE, IDH_BUTN_DELETE3,
    IDC_LIST_IP_ADDRS, IDH_LIST_IP_ADDRS,
    IDC_EDIT_SERVER_NAME, IDH_EDIT_SERVER_NAME, 
    IDC_BUTN_RESOLVE, IDH_BUTN_RESOLVE,
    IDC_BUTN_DOWN, IDH_BUTTON_VALUE_DOWN,
    IDC_BUTN_UP, IDH_BUTTON_VALUE_UP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_RECONCILIATION[]=
{
    IDC_LIST_RECONCILE_IP_ADDRESSES, IDH_LIST_RECONCILE_IP_ADDRESSES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_RESERVATION_NEW[]=
{
    IDC_IPADDR_RESERVATION_IP, IDH_IPADDR_RESERVATION_IP,
    IDC_STATIC_IP_ADDRESS, IDH_IPADDR_RESERVATION_IP,
    IDC_EDIT_CLIENT_UID, IDH_EDIT_CLIENT_UID,    
    IDC_STATIC_UID, IDH_EDIT_CLIENT_UID,
    IDC_EDIT_CLIENT_NAME, IDH_EDIT_CLIENT_NAME,
    IDC_STATIC_CLIENT_NAME, IDH_EDIT_CLIENT_NAME,
    IDC_EDIT_CLIENT_COMMENT, IDH_EDIT_CLIENT_COMMENT,
    IDC_STATIC_COMMENT, IDH_EDIT_CLIENT_COMMENT,
    IDC_RADIO_TYPE_DHCP, IDH_RADIO_TYPE_DHCP,
    IDC_RADIO_TYPE_BOOTP, IDH_RADIO_TYPE_BOOTP,
    IDC_RADIO_TYPE_BOTH, IDH_RADIO_TYPE_BOTH,
    IDC_STATIC_CLIENT_TYPE, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ROUTE_ARRAY_EDIT[] =
{
    IDC_STATIC_APPLICATION, IDH_DISABLEHELP,
    IDC_STATIC_OPTION_NAME, IDH_DISABLEHELP,
    IDC_LIST_OF_ROUTES, IDH_LIST_OF_ROUTES,
    IDC_BUTN_ROUTE_ADD, IDH_BUTN_ROUTE_ADD,
    IDC_BUTN_ROUTE_DELETE, IDH_BUTN_ROUTE_DELETE,
    0, 0
};
const DWORD g_aHelpIDs_IDD_SERVER_BINDINGS[]=
{
    IDC_STATIC_BINDINGS_EXPLANATION, IDH_DISABLEHELP,
    IDC_LIST_BINDINGS, IDH_LIST_BINDINGS,
    0, 0
};

const DWORD g_aHelpIDs_IDP_BOOTP_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_EDIT_BOOTP_IMAGE_NAME, IDH_EDIT_BOOTP_IMAGE_NAME,    
    IDC_EDIT_BOOTP_FILE_NAME, IDH_EDIT_BOOTP_FILE_NAME,
    IDC_EDIT_BOOTP_FILE_SERVER, IDH_EDIT_BOOTP_FILE_SERVER,
    0, 0
};

const DWORD g_aHelpIDs_IDP_DNS_INFORMATION[]=
{
    IDC_CHECK_ENABLE_DYN_DNS, IDH_CHECK_ENABLE_DYN_DNS,    
    IDC_RADIO_CLIENT, IDH_RADIO_CLIENT,
    IDC_RADIO_ALWAYS, IDH_RADIO_ALWAYS,
    IDC_CHECK_GARBAGE_COLLECT, IDH_CHECK_GARBAGE_COLLECT,
    IDC_CHECK_UPDATE_DOWNLEVEL, IDH_CHECK_UPDATE_DOWNLEVEL,
    0, 0
};

const DWORD g_aHelpIDs_IDP_MSCOPE_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_EDIT_SCOPE_NAME, IDH_EDIT_SCOPE_NAME,
    IDC_IPADDR_START, IDH_IPADDR_START,
    IDC_IPADDR_END, IDH_IPADDR_END,
    IDC_EDIT_TTL, IDH_EDIT_TTL,
    IDC_SPIN_TTL, IDH_EDIT_TTL,
    IDC_RADIO_LEASE_UNLIMITED, IDH_RADIO_LEASE_UNLIMITED,
    IDC_RADIO_LEASE_LIMITED, IDH_RADIO_LEASE_LIMITED,
    IDC_EDIT_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_SPIN_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_EDIT_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_SPIN_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_EDIT_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_SPIN_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_EDIT_SCOPE_COMMENT, IDH_EDIT_SCOPE_COMMENT,
    0, 0
};

const DWORD g_aHelpIDs_IDP_MSCOPE_LIFETIME[]=
{
    IDC_RADIO_MSCOPE_INFINITE, IDH_RADIO_MSCOPE_INFINITE,
    IDC_RADIO_MSCOPE_FINITE, IDH_RADIO_MSCOPE_FINITE,
    IDC_DATETIMEPICKER_DATE, IDH_DATETIMEPICKER_DATE,
    IDC_DATETIMEPICKER_TIME, IDH_DATETIMEPICKER_TIME,
};

const DWORD g_aHelpIDs_IDP_OPTION_ADVANCED[]=
{
    IDC_COMBO_VENDOR_CLASS, IDH_COMBO_VENDOR_CLASS,
    IDC_STATIC_VENDOR_CLASS_NAME, IDH_COMBO_VENDOR_CLASS,
    IDC_COMBO_USER_CLASS, IDH_COMBO_USER_CLASS,
    IDC_STATIC_USER_CLASS_NAME, IDH_COMBO_USER_CLASS,
    IDC_LIST_OPTIONS, IDH_LIST_OPTIONS,
    IDC_EDIT_BACKUP, IDH_EDIT_BACKUP,
    0, 0
};

const DWORD g_aHelpIDs_IDP_OPTION_BASIC[]=
{
    IDC_LIST_OPTIONS, IDH_LIST_OPTIONS2,
    0, 0
};

const DWORD g_aHelpIDs_IDP_RESERVED_CLIENT_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_IPADDR_RES_CLIENT_ADDRESS, IDH_IPADDR_RES_CLIENT_ADDRESS,
    IDC_EDIT_UNIQUE_IDENTIFIER, IDH_EDIT_UNIQUE_IDENTIFIER,
    IDC_EDIT_NAME, IDH_EDIT_NAME2,
    IDC_EDIT_COMMENT, IDH_EDIT_COMMENT2,
    IDC_RADIO_TYPE_DHCP, IDH_RADIO_TYPE_DHCP,
    IDC_RADIO_TYPE_BOOTP, IDH_RADIO_TYPE_BOOTP,
    IDC_RADIO_TYPE_BOTH, IDH_RADIO_TYPE_BOTH,
    IDC_STATIC_CLIENT_TYPE, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDP_SCOPE_ADVANCED[]=
{
    IDC_RADIO_DHCP_ONLY, IDH_RADIO_DHCP_ONLY,
    IDC_RADIO_DHCP_BOOTP, IDH_RADIO_DHCP_BOOTP,
    IDC_RADIO_BOOTP_ONLY, IDH_RADIO_BOOTP_ONLY,
    IDC_RADIO_LEASE_UNLIMITED, IDH_RADIO_LEASE_UNLIMITED,
    IDC_RADIO_LEASE_LIMITED, IDH_RADIO_LEASE_LIMITED,
    IDC_EDIT_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_SPIN_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_EDIT_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_SPIN_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_EDIT_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_SPIN_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_STATIC_BOOTP_DURATION, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDP_SCOPE_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_EDIT_SCOPE_NAME, IDH_EDIT_SCOPE_NAME2,
    IDC_IPADDR_START, IDH_IPADDR_START2,
    IDC_IPADDR_END, IDH_IPADDR_END2,
    IDC_IPADDR_MASK, IDH_IPADDR_MASK,
    IDC_EDIT_SUBNET_MASK_LENGTH, IDH_EDIT_SUBNET_MASK_LENGTH,
    IDC_SPIN_SUBNET_MASK_LENGTH, IDH_EDIT_SUBNET_MASK_LENGTH,
    IDC_RADIO_LEASE_UNLIMITED, IDH_RADIO_LEASE_UNLIMITED,
    IDC_RADIO_LEASE_LIMITED, IDH_RADIO_LEASE_LIMITED,
    IDC_EDIT_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_SPIN_LEASE_DAYS, IDH_EDIT_LEASE_DAYS,
    IDC_EDIT_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_SPIN_LEASE_HOURS, IDH_EDIT_LEASE_HOURS,
    IDC_EDIT_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_SPIN_LEASE_MINUTES, IDH_EDIT_LEASE_MINUTES,
    IDC_EDIT_SCOPE_COMMENT, IDH_EDIT_SCOPE_COMMENT2,
    IDC_STATIC_DHCP_DURATION, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDP_SERVER_ADVANCED[]=
{
    IDC_EDIT_CONFLICT_ATTEMPTS, IDH_EDIT_CONFLICT_ATTEMPTS,
    IDC_SPIN_CONFLICT_ATTEMPTS, IDH_EDIT_CONFLICT_ATTEMPTS,
    IDC_EDIT_LOG_PATH, IDH_EDIT_LOG_PATH,
    IDC_STATIC_LOGFILE, IDH_EDIT_LOG_PATH,
    IDC_BUTTON_BROWSE_LOG, IDH_BUTTON_BROWSE_LOG,
    IDC_EDIT_DATABASE_PATH, IDH_EDIT_DATABASE_PATH,
    IDC_STATIC_DATABASE, IDH_EDIT_DATABASE_PATH,
    IDC_BUTTON_BROWSE_DATABASE, IDH_BUTTON_BROWSE_DATABASE,
    IDC_STATIC_MODIFY_BINDINGS_STRING, IDH_STATIC_MODIFY_BINDINGS_STRING,
    IDC_BUTTON_BINDINGS, IDH_BUTTON_BINDINGS,
    IDC_BUTTON_BROWSE_BACKUP, IDH_BUTTON_BROWSE_BACKUP,
    IDC_EDIT_BACKUP, IDH_EDIT_BACKUP,
    IDC_STATIC_BACKUP_PATH, IDH_STATIC_BACKUP_PATH,
    IDC_BUTTON_CREDENTIALS, IDH_BUTTON_CREDENTIALS,
    IDC_STATIC_CREDENTIALS, IDH_STATIC_CREDENTIALS,
    0, 0
};

const DWORD g_aHelpIDs_IDP_SERVER_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_CHECK_AUTO_REFRESH, IDH_CHECK_AUTO_REFRESH,
    IDC_EDIT_REFRESH_HOURS, IDH_EDIT_REFRESH_HOURS,
    IDC_SPIN_REFRESH_HOURS, IDH_EDIT_REFRESH_HOURS,
    IDC_EDIT_REFRESH_MINUTES, IDH_EDIT_REFRESH_MINUTES,
    IDC_SPIN_REFRESH_MINUTES, IDH_EDIT_REFRESH_MINUTES,
    IDC_CHECK_AUDIT_LOGGING, IDH_CHECK_AUDIT_LOGGING,
    IDC_CHECK_SHOW_BOOTP, IDH_CHECK_SHOW_BOOTP,
    0, 0
};

const DWORD g_aHelpIDs_IDP_SUPERSCOPE_GENERAL[]=
{
    IDC_STATIC_ICON, IDH_DISABLEHELP,
    IDC_STATIC_ICON_DESC, IDH_DISABLEHELP,
    IDC_EDIT_SUPERSCOPE_NAME, IDH_EDIT_SUPERSCOPE_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADD_SERVER[]=
{
    IDC_RADIO_ANY_SERVER, IDH_RADIO_ANY_SERVER,
    IDC_RADIO_AUTHORIZED_SERVERS, IDH_RADIO_AUTHORIZED_SERVERS,
    IDC_EDIT_ADD_SERVER_NAME, IDH_EDIT_ADD_SERVER_NAME,
    IDC_BUTTON_BROWSE_SERVERS, IDH_BUTTON_BROWSE_SERVERS,
    IDC_LIST_AUTHORIZED_SERVERS, IDH_LIST_AUTHORIZED_SERVERS,
    0,0
};

const DWORD g_aHelpIDs_IDD_ADD_ROUTE_DIALOG[] = 
{
    IDC_STATIC_DESTINATION, IDH_STATIC_DESTINATION,
    IDC_STATIC_NETWORK_MASK, IDH_STATIC_NETWORK_MASK,
    IDC_STATIC_ROUTER, IDH_STATIC_ROUTER,
    IDC_IPADDR_ADDRESS, IDH_STATIC_DESTINATION,
    IDC_IPADDR_ADDRESS2, IDH_STATIC_NETWORK_MASK,
    IDC_IPADDR_ADDRESS3, IDH_STATIC_ROUTER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_STRING_ARRAY_EDIT[] = 
{
    IDC_STATIC_APPLICATION, IDH_DISABLEHELP,
    IDC_STATIC_OPTION_NAME, IDH_DISABLEHELP,
    IDC_BUTN_UP, IDH_BUTTON_STRING_ARRAY_UP,
    IDC_BUTN_DOWN, IDH_BUTTON_STRING_ARRAY_DOWN,
    IDC_BUTN_ADD, IDH_BUTTON_STRING_ARRAY_ADD,
    IDC_BUTN_DELETE, IDH_BUTTON_STRING_ARRAY_REMOVE,
    IDC_LIST_STRING, IDH_LIST_STRING_ARRAY,
    IDC_EDIT_STRING, IDH_EDIT_STRING_ARRAY_VALUE,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\nodes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	nodes.h
		This file contains all of the prototypes for the DHCP
		objects that appear in the result pane of the MMC framework.
		The objects are:

 			CDhcpActiveLease
			CDhcpConflicAddress
			CDhcpAllocationRange
			CDhcpExclusionRange
			CDhcpBootpTableEntry
			CDhcpOption

    FILE HISTORY:
        
*/

#ifndef _DHCPNODE_H
#define _DHCPNODE_H

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

extern const TCHAR g_szClientTypeDhcp[];
extern const TCHAR g_szClientTypeBootp[];
extern const TCHAR g_szClientTypeBoth[];

#define TYPE_FLAG_RESERVATION	0x00000001
#define TYPE_FLAG_ACTIVE		0x00000002
#define TYPE_FLAG_BAD_ADDRESS	0x00000004
#define TYPE_FLAG_RAS			0x00000008
#define TYPE_FLAG_GHOST			0x00000010
// NT5 lease types
#define TYPE_FLAG_DNS_REG		0x00000020
#define TYPE_FLAG_DNS_UNREG		0x00000040
#define TYPE_FLAG_DOOMED		0x00000080

#define RAS_UID		_T("RAS")

/*---------------------------------------------------------------------------
	Class:	CDhcpActiveLease
 ---------------------------------------------------------------------------*/
class CDhcpActiveLease : public CDhcpHandler
{
// Constructor/destructor
public:
	CDhcpActiveLease(ITFSComponentData * pTFSCompData, LPDHCP_CLIENT_INFO_V5 pDhcpClientInfo);
	CDhcpActiveLease(ITFSComponentData * pTFSCompData, LPDHCP_CLIENT_INFO_V4 pDhcpClientInfo);
	CDhcpActiveLease(ITFSComponentData * pTFSCompData, LPDHCP_CLIENT_INFO pDhcpClientInfo);
	CDhcpActiveLease(ITFSComponentData * pTFSCompData, CDhcpClient & pClient);
	~CDhcpActiveLease();

// Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_HasPropertyPages() { return hrFalse; }
    OVERRIDE_ResultHandler_CreatePropertyPages();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_GetString();

    // base result handler overridees
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
    
public:
	DHCP_IP_ADDRESS	GetIpAddress() { return m_dhcpClientIpAddress; };
	void			GetLeaseExpirationTime (CTime & time);
	BOOL			IsReservation(BOOL * pbIsActive, BOOL * pbIsBad);
	BOOL			IsBadAddress() { return m_dwTypeFlags & TYPE_FLAG_BAD_ADDRESS; }
    BOOL            IsGhost() { return m_dwTypeFlags & TYPE_FLAG_GHOST; }
    BOOL            IsUnreg() { return m_dwTypeFlags & TYPE_FLAG_DNS_UNREG; }
    BOOL            IsDoomed() { return m_dwTypeFlags & TYPE_FLAG_DOOMED; }

	LPCTSTR			GetClientLeaseExpires() { return m_strLeaseExpires; }
	LPCTSTR			GetClientType(); 
	LPCTSTR			GetUID() { return m_strUID; }
	LPCTSTR			GetComment() { return m_strComment; }

	HRESULT			DoPropSheet(ITFSNode *				pNode, 
								LPPROPERTYSHEETCALLBACK lpProvider = NULL,
								LONG_PTR				handle = 0);
	
	void            SetReservation(BOOL fIsRes);

    //
	// All of these items are optional info
	//
	LPCTSTR			GetClientName() { return m_strClientName; }
	HRESULT			SetClientName(LPCTSTR pName);
    BYTE            SetClientType(BYTE bClientType) { BYTE bTmp = m_bClientType; m_bClientType = bClientType; return bTmp; }

// Implementation
public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

private:
	void			InitInfo(LPDHCP_CLIENT_INFO pDhcpClientInfo);

// Attributes
private:
	DHCP_IP_ADDRESS		m_dhcpClientIpAddress;
	CString				m_strClientName;
	CString				m_strLeaseExpires;
	CTime				m_timeLeaseExpires;
	DWORD				m_dwTypeFlags;			// Reservation, Active/Inactive, Bad Address
	BYTE				m_bClientType;			// DHCP, BOOTP or both
	CString				m_strUID;
	CString				m_strComment;
    FILETIME            m_leaseExpires;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpAllocationRange
 ---------------------------------------------------------------------------*/
class CDhcpAllocationRange : public CDhcpHandler, public CDhcpIpRange
{
// Constructor/destructor
public:
	CDhcpAllocationRange(ITFSComponentData * pTFSCompData, DHCP_IP_RANGE * pdhcpIpRange);
	CDhcpAllocationRange(ITFSComponentData * pTFSCompData, DHCP_BOOTP_IP_RANGE * pdhcpIpRange);

// Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_GetString();

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

// Implementation
public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

private:

// Attributes
private:
	CString			m_strEndIpAddress;
	CString			m_strDescription;
    ULONG			m_BootpAllocated;
    ULONG			m_MaxBootpAllowed;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpExclusionRange
 ---------------------------------------------------------------------------*/
class CDhcpExclusionRange : public CDhcpHandler, public CDhcpIpRange
{
public:
	CDhcpExclusionRange(ITFSComponentData * pTFSCompData, DHCP_IP_RANGE * pdhcpIpRange);

// Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_GetString();

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

// Implementation
public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

private:

// Attributes
private:
	CString			m_strEndIpAddress;
	CString			m_strDescription;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpBootpEntry
 ---------------------------------------------------------------------------*/
class CDhcpBootpEntry : public CDhcpHandler
{
public:
	CDhcpBootpEntry(ITFSComponentData * pTFSCompData);

//Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_HasPropertyPages() { return hrOK; }
    OVERRIDE_ResultHandler_GetString();

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

//Implementation
public:
	WCHAR * InitData(CONST WCHAR grszwBootTable[], DWORD dwLength);
	int		CchGetDataLength();
	WCHAR * PchStoreData(OUT WCHAR szwBuffer[]);

	void SetBootImage(LPCTSTR szBootImage) { m_strBootImage = szBootImage; }
	void SetFileServer(LPCTSTR szFileServer) { m_strFileServer = szFileServer; }
	void SetFileName(LPCTSTR szFileName) { m_strFileName = szFileName; }
	
	LPCTSTR QueryBootImage() { return m_strBootImage; }
	LPCTSTR QueryFileServer() { return m_strFileServer; }
	LPCTSTR QueryFileName() { return m_strFileName; }

    BOOL operator == (CDhcpBootpEntry & bootpEntry);

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

private:

//Attributes
private:
	CString m_strBootImage;
	CString m_strFileServer;
	CString m_strFileName;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpOptionItem
 ---------------------------------------------------------------------------*/
class CDhcpOptionItem : public CDhcpHandler, public CDhcpOptionValue
{
public:
	CDhcpOptionItem(ITFSComponentData * pTFSCompData,
					LPDHCP_OPTION_VALUE pOptionValue, 
					int					nOptionImage);

    CDhcpOptionItem(ITFSComponentData * pTFSCompData,
					CDhcpOption *       pOption, 
					int					nOptionImage);

    ~CDhcpOptionItem();

    // Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_GetString();
    OVERRIDE_ResultHandler_HasPropertyPages() { return hrOK; }
    OVERRIDE_ResultHandler_CreatePropertyPages();

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

// Implementation
public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

public:
	// helpers
	DHCP_OPTION_ID	GetOptionId() { return m_dhcpOptionId; }
    LPCTSTR         GetVendor() { return m_strVendor.IsEmpty() ? NULL : (LPCTSTR) m_strVendor; }
    LPCTSTR         GetVendorDisplay() { return m_strVendorDisplay; }
    LPCTSTR         GetClassName() { return m_strClassName; }

    BOOL            IsVendorOption() { return m_strVendor.IsEmpty() ? FALSE : TRUE; }
    BOOL            IsClassOption() { return m_strClassName.IsEmpty() ? FALSE : TRUE; }

    void            SetClassName(LPCTSTR pClassName) { m_strClassName = pClassName; }
    void            SetVendor(LPCTSTR pszVendor);

private:
	CDhcpOption * FindOptionDefinition(ITFSComponent * pComponent, ITFSNode * pNode);

// Attributes
private:
	CString			m_strName;
	CString			m_strValue;
	CString			m_strVendor;
    CString         m_strVendorDisplay;
    CString         m_strClassName;
	DHCP_OPTION_ID	m_dhcpOptionId;
	int				m_nOptionImage;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpMCastLease
 ---------------------------------------------------------------------------*/
class CDhcpMCastLease : public CDhcpHandler
{
public:
	CDhcpMCastLease(ITFSComponentData * pTFSCompData);

// Interface
public:
	// Result handler functionality
    OVERRIDE_ResultHandler_GetString();
    OVERRIDE_ResultHandler_HasPropertyPages() { return hrFalse; }

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

// Implementation
public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

public:
	// helpers
    HRESULT         InitMCastInfo(LPDHCP_MCLIENT_INFO pMClientInfo);

	DHCP_IP_ADDRESS	GetIpAddress() { return m_dhcpClientIpAddress; };

    LPCTSTR         GetName() { return m_strName; }
    void            SetName(LPCTSTR pName) { m_strName = pName; }

	LPCTSTR			GetClientId() { return m_strUID; }

	void			GetLeaseStartTime (CTime & time) { time = m_timeStart; }
	void			GetLeaseExpirationTime (CTime & time) { time = m_timeStop; }

private:

// Attributes
private:
	CString			m_strIp;
	CString			m_strName;
    CString         m_strLeaseStart;
    CString         m_strLeaseStop;

	CString			m_strUID;

    CTime           m_timeStart;
    CTime           m_timeStop;

    DHCP_IP_ADDRESS m_dhcpClientIpAddress;

    DWORD           m_dwTypeFlags;
};

#endif _DHCPNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\rclntpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	RClntPP.h
		This file contains all of the prototypes for the 
		reserved client property page.

    FILE HISTORY:
        
*/

#if !defined(AFX_RCLNTPP_H__A1A51387_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_RCLNTPP_H__A1A51387_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if !defined _DNSPROP_H
#include "dnsprop.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CReservedClientPropGeneral dialog

class CReservedClientPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CReservedClientPropGeneral)

// Construction
public:
	CReservedClientPropGeneral();
	~CReservedClientPropGeneral();

// Dialog Data
	//{{AFX_DATA(CReservedClientPropGeneral)
	enum { IDD = IDP_RESERVED_CLIENT_GENERAL };
	CEdit	m_editComment;
	CEdit	m_editName;
	CEdit	m_editUID;
	CString	m_strComment;
	CString	m_strName;
	CString	m_strUID;
	int		m_nClientType;
	//}}AFX_DATA

	CWndIpAddress	m_ipaClientIpAddress;

	DWORD			m_dwClientAddress;
	CDhcpClient		m_dhcpClient;
    BYTE            m_bClientType;

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CReservedClientPropGeneral::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CReservedClientPropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CReservedClientPropGeneral)
	afx_msg void OnChangeEditComment();
	afx_msg void OnChangeEditName();
	afx_msg void OnChangeEditUniqueIdentifier();
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioTypeBootp();
	afx_msg void OnRadioTypeBoth();
	afx_msg void OnRadioTypeDhcp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CReservedClientProperties : public CPropertyPageHolderBase
{
	friend class CReservedClientPropGeneral;

public:
	CReservedClientProperties(ITFSNode *		  pNode,
							  IComponentData *	  pComponentData,
							  ITFSComponentData * pTFSCompData,
							  LPCTSTR			  pszSheetName);
	virtual ~CReservedClientProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetVersion(LARGE_INTEGER & liVersion);
    void SetClientType(BYTE bClientType);
    void SetDnsRegistration(DWORD dnsRegOption, DHCP_OPTION_SCOPE_TYPE dhcpOptionType);

public:
	CReservedClientPropGeneral	m_pageGeneral;
	CDnsPropRegistration		m_pageDns;

protected:
	SPITFSComponentData			m_spTFSCompData;

	LARGE_INTEGER				m_liVersion;
};

#endif // !defined(AFX_RCLNTPP_H__A1A51387_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\optcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	OptCfg.h
		Option configuration pages.  The option configuration pages
		keep lists off all of the default options for a given class ID.
		For the pre-NT5 and default case, the class name is null
		indicating no associated class.  When there is a class defined,
		a CClassTracker object with the class name is created.
		Only the advanced page uses CClassTrackers with non-null names.
		If there are no non-null class names then the advanced page 
		will be disabled.
	
	FILE HISTORY:
        
*/

#ifndef _OPTCFG_H
#define _OPTCFG_H

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

#ifndef _CTRLGRP_H
#include <ctrlgrp.h>
#endif 

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif 

#ifndef _CLASSED_H
#include "classed.h"
#endif

#ifndef _CLASSID_H
#include "classmod.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CDhcpOptionItem;

#define OPTION_STATE_ACTIVE		1
#define OPTION_STATE_INACTIVE	2

#define WM_SELECTOPTION     WM_USER + 200	
#define WM_SELECTCLASSES    WM_USER + 201

// this class builds the correct help map for the given option sheet   
class CHelpMap
{
public:
    CHelpMap();
    ~CHelpMap();

    void    BuildMap(DWORD pdwParentHelpMap[]);
    DWORD * GetMap();

protected:
    int     CountMap(const DWORD * pdwHelpMap);
    void    ResetMap();

    DWORD * m_pdwHelpMap;
};

// This class tracks a given option to see if it has been modified, etc
class COptionTracker 
{
public:
	COptionTracker() 
	{
		m_uInitialState = OPTION_STATE_INACTIVE;
		m_uCurrentState = OPTION_STATE_INACTIVE;
		m_bDirty = FALSE; 
		m_pOption = NULL;
	}

	~COptionTracker()
	{
		if (m_pOption)
			delete m_pOption;
	}

	UINT GetInitialState() { return m_uInitialState; }
	void SetInitialState(UINT uInitialState) { m_uInitialState = uInitialState; }

    UINT GetCurrentState() { return m_uCurrentState; }
    void SetCurrentState(UINT uCurrentState) { m_uCurrentState = uCurrentState; }

	void SetDirty(BOOL bDirty) { m_bDirty = bDirty; }
	BOOL IsDirty() { return m_bDirty; }

	CDhcpOption * m_pOption;

protected:
	UINT	m_uInitialState;
    UINT    m_uCurrentState;
    BOOL	m_bDirty;
};

typedef CList<COptionTracker *, COptionTracker *> COptionTrackerListBase;
class COptionTrackerList : public COptionTrackerListBase
{
public:
    ~COptionTrackerList()
    {
        // cleanup the list 
        while (!IsEmpty())
            delete RemoveHead();
    }
};

// this class tracks the option set for a given User Class ID
class CClassTracker
{
public:
	CClassTracker() {};
	~CClassTracker() {};

	LPCTSTR		GetClassName() { return m_strClassName; }
	void		SetClassName(LPCTSTR pClassName) { m_strClassName = pClassName; }

public:
	CString				m_strClassName;
    BOOL                m_bIsVendor;
	COptionTrackerList	m_listOptions;
};

typedef CList<CClassTracker *, CClassTracker *> CClassTrackerListBase;
class CClassTrackerList : public CClassTrackerListBase
{
public:
    ~CClassTrackerList()
    {
        // cleanup the list 
        while (!IsEmpty())
            delete RemoveHead();
    }
};

// this class tracks the user classes for a vendor option class option set
class CVendorTracker
{
public:
	CVendorTracker() {};
	~CVendorTracker() {};

	LPCTSTR		GetClassName() { return m_strClassName; }
	void		SetClassName(LPCTSTR pClassName) { m_strClassName = pClassName; }

public:
	CString				m_strClassName;
    BOOL                m_bIsVendor;
	CClassTrackerList	m_listUserClasses;
};

typedef CList<CVendorTracker *, CVendorTracker *> CVendorTrackerListBase;
class CVendorTrackerList : public CVendorTrackerListBase
{
public:
    ~CVendorTrackerList()
    {
        // Cleanup the list 
        while (!IsEmpty())
            delete RemoveHead();
    }
};

/////////////////////////////////////////////////////////////////////////////
// COptionsCfgBasic dialog

class COptionsCfgPropPage : public CPropertyPageBase
{
    DECLARE_DYNCREATE(COptionsCfgPropPage)

// Construction
public:
    COptionsCfgPropPage();
    COptionsCfgPropPage(UINT nIDTemplate, UINT nIDCaption = 0);
    ~COptionsCfgPropPage();

// Dialog Data
    //{{AFX_DATA(COptionsCfgPropPage)
    enum { IDD = IDP_OPTION_BASIC };
    CMyListCtrl		m_listctrlOptions;
    //}}AFX_DATA
    
    CImageList            m_StateImageList;
    ControlGroupSwitcher  m_cgsTypes;
    
    CWndHexEdit	          m_hexData;       //  Hex Data
    
    void LoadBitmaps();
    void InitListCtrl();
    void SelectOption(CDhcpOption * pOption);
    void SwitchDataEntry(int datatype, int optiontype, BOOL fRouteArray, BOOL bEnable);
    void FillDataEntry(CDhcpOption * pOption);

    void HandleActivationStringArray();
    void HandleActivationIpArray();
    void HandleActivationValueArray();
    void HandleActivationRouteArray(CDhcpOptionValue *optValue = NULL);

    BOOL HandleValueEdit();
    
    void MoveValue(BOOL bValues, BOOL bUp);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return m_helpMap.GetMap(); }
    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(COptionsCfgPropPage)
public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
    
    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(COptionsCfgPropPage)
    virtual BOOL OnInitDialog();
    /*afx_msg */ virtual void OnDestroy();
    afx_msg void OnItemchangedListOptions(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    
    // IpAddress array controls
    afx_msg void OnButtonIpAddrDown();
    afx_msg void OnButtonIpAddrUp();
    afx_msg void OnButtonIpAddrAdd();
    afx_msg void OnButtonIpAddrDelete();
    afx_msg void OnSelchangeListIpAddrs();
    afx_msg void OnChangeIpAddressArray();
    afx_msg void OnChangeEditServerName();
    afx_msg void OnButtonResolve();
    
    // value array controls
    afx_msg void OnButtonValueDown();
    afx_msg void OnButtonValueUp();
    afx_msg void OnButtonValueAdd();
    afx_msg void OnButtonValueDelete();
    afx_msg void OnChangeEditValue();
    afx_msg void OnClickedRadioDecimal();
    afx_msg void OnClickedRadioHex();
    afx_msg void OnSelchangeListValues();
    
    // single value controls
    afx_msg void OnChangeEditDword();
    
    // string value controls
    afx_msg void OnChangeEditString();
    
    // single ip address controls
    afx_msg void OnChangeIpAddress();
    
    // single string controls
    
    // binary and encapsulated data
    afx_msg void OnChangeValueData();
    
    // route array controls
    afx_msg void OnButtonAddRoute();
    afx_msg void OnButtonDelRoute();
    
    // string array controls
    afx_msg void OnSelChangeStringArrayList();
    afx_msg void OnChangeStringArrayValue();
    afx_msg void OnButtonStringArrayAdd();
    afx_msg void OnButtonStringArrayRemove();
    afx_msg void OnButtonStringArrayUp();
    afx_msg void OnButtonStringArrayDown();
    
    afx_msg long OnSelectOption(UINT wParam, long lParam);
    
    DECLARE_MESSAGE_MAP()
	
    BOOL        m_bInitialized;
    BYTE        m_BinaryBuffer[MAXDATA_LENGTH];
    CHelpMap    m_helpMap;
};

// the general page
class COptionCfgGeneral : public COptionsCfgPropPage
{
	DECLARE_DYNCREATE(COptionCfgGeneral)

public:
    COptionCfgGeneral();
    COptionCfgGeneral(UINT nIDTemplate, UINT nIDCaption = 0);
	~COptionCfgGeneral();

// Dialog Data
	//{{AFX_DATA(COptionCfgGeneral)
	enum { IDD = IDP_OPTION_BASIC };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COptionCfgGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(COptionCfgGeneral)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CAddRoute dialog

class CAddRoute : public CBaseDialog
{
// Construction
public:
	CAddRoute(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddRoute)
	enum { IDD = IDD_ADD_ROUTE_DIALOG };
	//}}AFX_DATA

    //  Ip address for destination, mask and router fields
    CWndIpAddress m_ipaDest, m_ipaMask, m_ipaRouter;
    BOOL m_bChange;
    DHCP_IP_ADDRESS Dest, Mask, Router;

    virtual DWORD * GetHelpMap() {
	return DhcpGetHelpMap( CAddRoute::IDD );
    }
    
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRoute)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRoute)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// the advanced page
class COptionCfgAdvanced : public COptionsCfgPropPage
{
	DECLARE_DYNCREATE(COptionCfgAdvanced)

public:
    COptionCfgAdvanced();
    COptionCfgAdvanced(UINT nIDTemplate, UINT nIDCaption = 0);
	~COptionCfgAdvanced();

// Dialog Data
	//{{AFX_DATA(COptionCfgAdvanced)
	enum { IDD = IDP_OPTION_ADVANCED };
	CComboBox	m_comboUserClasses;
	CComboBox	m_comboVendorClasses;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COptionCfgAdvanced)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(COptionCfgAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelendokComboUserClass();
	afx_msg void OnSelendokComboVendorClass();
	//}}AFX_MSG

    afx_msg long OnSelectClasses(UINT wParam, LONG lParam);

    BOOL    m_bNoClasses;

	DECLARE_MESSAGE_MAP()
};

// the holder class for the pages
class COptionsConfig : public CPropertyPageHolderBase
{
public:
	COptionsConfig(ITFSNode *				pNode,
				   ITFSNode *				pServerNode,
				   IComponentData *			pComponentData,
				   ITFSComponentData *		pTFSCompData,
				   COptionValueEnum *       pOptionValueEnum,
				   LPCTSTR					pszSheetName,
                   CDhcpOptionItem *        pSelOption = NULL);
	virtual ~COptionsConfig();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	ITFSNode * GetServerNode() 
	{
		if (m_spServerNode)
			m_spServerNode->AddRef();
		return m_spServerNode;
	}

    DWORD	InitData();
	void	FillOptions(LPCTSTR pVendorName, LPCTSTR pClassName, CMyListCtrl & ListCtrl);
    void    UpdateActiveOptions();
    void    SetTitle();
    LPWSTR  GetServerAddress();
    void    AddClassTracker(CVendorTracker * pVendorTracker, LPCTSTR pClassName);
    CVendorTracker * AddVendorTracker(LPCTSTR pVendorName);

public:
	COptionCfgGeneral		m_pageGeneral;
	COptionCfgAdvanced		m_pageAdvanced;

    COptionValueEnum *      m_pOptionValueEnum;
    CVendorTrackerList		m_listVendorClasses;

    LARGE_INTEGER           m_liServerVersion;

    // these descibe the option to focus on.
    CString                 m_strStartVendor;
    CString                 m_strStartClass;
    DHCP_OPTION_ID          m_dhcpStartId;

protected:
	SPITFSComponentData			m_spTFSCompData;
	SPITFSNode					m_spServerNode;
	BOOL						m_bInitialized;
};


#endif _OPTCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\routearrayeditor.cpp ===
// DhcpRouteArrayEditor.cpp : implementation file
//

#include "stdafx.h"
#include "RouteArrayEditor.h"
#include "optcfg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpRouteArrayEditor dialog


CDhcpRouteArrayEditor::CDhcpRouteArrayEditor(
    CDhcpOption * pdhcType,
    DHCP_OPTION_SCOPE_TYPE dhcScopeType,
    CWnd *pParent )
    : CBaseDialog(CDhcpRouteArrayEditor::IDD, pParent),
      m_p_type( pdhcType ),
      m_option_type( dhcScopeType )
{
	//{{AFX_DATA_INIT(CDhcpRouteArrayEditor)
	//}}AFX_DATA_INIT
}


void CDhcpRouteArrayEditor::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpRouteArrayEditor)
	DDX_Control(pDX, IDC_STATIC_OPTION_NAME, m_st_option);
	DDX_Control(pDX, IDC_STATIC_APPLICATION, m_st_application);
	DDX_Control(pDX, IDC_LIST_OF_ROUTES, m_lc_routes);
	DDX_Control(pDX, IDC_BUTN_ROUTE_DELETE, m_butn_route_delete);
	DDX_Control(pDX, IDC_BUTN_ROUTE_ADD, m_butn_route_add);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDhcpRouteArrayEditor, CBaseDialog)
	//{{AFX_MSG_MAP(CDhcpRouteArrayEditor)
	ON_BN_CLICKED(IDC_BUTN_ROUTE_ADD, OnButnRouteAdd)
	ON_BN_CLICKED(IDC_BUTN_ROUTE_DELETE, OnButnRouteDelete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpRouteArrayEditor message handlers

void CDhcpRouteArrayEditor::OnButnRouteAdd() 
{
    CAddRoute NewRoute( NULL );
    
    NewRoute.DoModal();

    if ( NewRoute.m_bChange ) {
	
	const int IP_ADDR_LEN = 20;
	WCHAR  strDest[ IP_ADDR_LEN ];
	WCHAR  strMask[ IP_ADDR_LEN ];
	WCHAR  strRouter[ IP_ADDR_LEN ];
	
	// obtain the three strings..
	::UtilCvtIpAddrToWstr( NewRoute.Dest, strDest, IP_ADDR_LEN );
	::UtilCvtIpAddrToWstr( NewRoute.Mask, strMask, IP_ADDR_LEN );
	::UtilCvtIpAddrToWstr( NewRoute.Router, strRouter, IP_ADDR_LEN );
        
	LV_ITEM lvi;
        
	lvi.mask = LVIF_TEXT;
	lvi.iItem = m_lc_routes.GetItemCount();
	lvi.iSubItem = 0;
	lvi.pszText = ( LPTSTR )( LPCTSTR ) strDest;
	lvi.iImage = 0;
	lvi.stateMask = 0;

	int nItem = m_lc_routes.InsertItem( &lvi );
	m_lc_routes.SetItemText( nItem, 1, strMask );
	m_lc_routes.SetItemText( nItem, 2, strRouter );
	
	// unselect others 
	for ( int i = 0; i < m_lc_routes.GetItemCount(); i++ ) {
	    m_lc_routes.SetItemState( i, 0, LVIS_SELECTED );
	} // for 

	// Make this route as selected item
	m_lc_routes.SetItemState( nItem, LVIS_SELECTED, LVIS_SELECTED );
	
	HandleActivation();
    } // if route added

} // CDhcpRouteArrayEditor::OnButnRouteAdd()

void CDhcpRouteArrayEditor::OnButnRouteDelete() 
{
    int nItem = m_lc_routes.GetNextItem( -1, LVNI_SELECTED );
    int nDelItem = 0;


    while ( nItem != -1 ) {
	m_lc_routes.DeleteItem( nItem );
	nDelItem = nItem;

	// Make the next one or the last one as selected
  	nItem = m_lc_routes.GetNextItem( -1, LVNI_SELECTED );
    } // while

    // Select an item 
    int items = m_lc_routes.GetItemCount();
    if ( items > 0 ) {
	if ( nDelItem >= items ) {
	    nDelItem = items - 1;
	}
	m_lc_routes.SetItemState( nDelItem, LVIS_SELECTED, LVIS_SELECTED );
    } // if

    HandleActivation();

} // CDhcpRouteArrayEditor::OnButnRouteDelete()

void CDhcpRouteArrayEditor::OnCancel() 
{
    CBaseDialog::OnCancel();
}

void CDhcpRouteArrayEditor::OnOK() 
{
    DWORD      err = 0;
    int        nItems, BufSize;
    CListCtrl *pList;
    LPBYTE     Buffer;

    
    // The following code is borrowed from 
    // CDhcpOptCfgPropPage::HandleActivationRouteArray()
    nItems = m_lc_routes.GetItemCount();
    Buffer = new BYTE[ sizeof( DWORD ) * 4 * nItems ];
    
    if ( NULL == Buffer ) {
	return;
    }

    BufSize = 0;
    for ( int i = 0; i < nItems; i++ ) {
	DHCP_IP_ADDRESS Dest, Mask, Router;

	Dest = UtilCvtWstrToIpAddr( m_lc_routes.GetItemText( i, 0 ));
	Mask = UtilCvtWstrToIpAddr( m_lc_routes.GetItemText( i, 1 ));
	Router = UtilCvtWstrToIpAddr( m_lc_routes.GetItemText( i, 2 ));
	

	Dest = htonl( Dest );
	Router = htonl( Router );

	int nBitsInMask = 0;
	while ( Mask != 0 ) {
	    nBitsInMask++; 
	    Mask <<= 1;
	}

	// first add destination descriptor
	// first byte contains # of bits in mask
	// next few bytes contain the dest address for only
	// the significant octets
	Buffer[ BufSize++ ] = ( BYTE ) nBitsInMask;
	memcpy( &Buffer[ BufSize ], &Dest, ( nBitsInMask + 7 ) / 8 );
	BufSize += ( nBitsInMask + 7 ) / 8;
	
	// now just copy the router address
	memcpy(& Buffer[ BufSize ], &Router, sizeof( Router ));
	BufSize += sizeof( Router );
	
    } // for 

    // Now write back the option value
    DHCP_OPTION_DATA_ELEMENT DataElement = { DhcpBinaryDataOption };
    DHCP_OPTION_DATA Data = { 1, &DataElement };
    DataElement.Element.BinaryDataOption.DataLength = BufSize;
    DataElement.Element.BinaryDataOption.Data = Buffer;

    err = m_p_type->QueryValue().SetData( &Data ); 

    delete[] Buffer;

    m_p_type->SetDirty();

    if ( err ) {
	::DhcpMessageBox( err );
	OnCancel();
    }
    else {
	CBaseDialog::OnOK();
    }

} // CDhcpRouteArrayEditor::OnOK()

//
// strings and widths used for the list control
//

const int ROUTE_LIST_COL_HEADERS[3] = {
    IDS_ROUTE_LIST_COL_DEST,
    IDS_ROUTE_LIST_COL_MASK,
    IDS_ROUTE_LIST_COL_ROUTER
};

const int ROUTE_COLS =
  sizeof( ROUTE_LIST_COL_HEADERS ) / sizeof( ROUTE_LIST_COL_HEADERS[ 0 ]);



BOOL CDhcpRouteArrayEditor::OnInitDialog() 
{
    CString strColHeader;
    RECT    rect;
    LONG    width;

    CDhcpOptionValue &optValue = m_p_type->QueryValue();
    
    // make sure the option type is set as Binary data type
    ASSERT( DhcpBinaryDataOption == optValue.QueryDataType());


    CBaseDialog::OnInitDialog();
    
    DWORD err = 0;

    int cStrId = ( m_option_type == DhcpDefaultOptions)
	? IDS_INFO_TITLE_DEFAULT_OPTIONS
	: (( m_option_type == DhcpGlobalOptions )
	   ? IDS_INFO_TITLE_GLOBAL_OPTIONS
	   : IDS_INFO_TITLE_SCOPE_OPTIONS );

    // 
    // setup the columns in the list control
    //

    m_lc_routes.GetClientRect( &rect );
    width = ( rect.right - rect.left ) / 3;
    for ( int i =  0; i < ROUTE_COLS; i++ ) {
	
	strColHeader.LoadString( ROUTE_LIST_COL_HEADERS[ i ] );
	m_lc_routes.InsertColumn( i, strColHeader, LVCFMT_LEFT,
				  width, -1 );
    } // for

    // Select a full row
    m_lc_routes.SetExtendedStyle( m_lc_routes.GetExtendedStyle() | 
				  LVS_EX_FULLROWSELECT );

    const CByteArray *pbaData = optValue.QueryBinaryArray();
    ASSERT( pbaData != NULL );

    int nDataSize = ( int ) pbaData->GetSize();
    LPBYTE pData = ( LPBYTE ) pbaData->GetData();

    // 
    // The following loop is copied from optcfg.cpp,
    // COptionsCfgPropPage::FillDataEntry()
    // 

    while ( nDataSize > sizeof( DWORD )) {
	// first 1 byte contains the # of bits in subnetmask
	nDataSize --;
	BYTE nBitsMask = *pData ++;
	DWORD Mask = (~0);
	if( nBitsMask < 32 ) Mask <<= (32-nBitsMask);
	
	// based on the # of bits, the next few bytes contain
	// the subnet address for the 1-bits of subnet mask
	int nBytesDest = (nBitsMask+7)/8;
	if( nBytesDest > 4 ) nBytesDest = 4;
	
	DWORD Dest = 0;
	memcpy( &Dest, pData, nBytesDest );
	pData += nBytesDest;
	nDataSize -= nBytesDest;
	
	// subnet address is obviously in network order.
	Dest = ntohl(Dest);
	
	// now the four bytes would be the router address
	DWORD Router = 0;
	if( nDataSize < sizeof(DWORD) ) {
	    Assert( FALSE ); break;
	}
	
	memcpy(&Router, pData, sizeof(DWORD));
	Router = ntohl( Router );
	
	pData += sizeof(DWORD);
	nDataSize -= sizeof(DWORD);
	
	// now fill the list box..
	const int IP_ADDR_LEN = 20;
	WCHAR strDest[ IP_ADDR_LEN ];
	WCHAR strMask[ IP_ADDR_LEN ];
	WCHAR strRouter[ IP_ADDR_LEN ];
	
	::UtilCvtIpAddrToWstr( Dest, strDest, IP_ADDR_LEN );
	::UtilCvtIpAddrToWstr( Mask, strMask, IP_ADDR_LEN );
	::UtilCvtIpAddrToWstr( Router, strRouter, IP_ADDR_LEN );
	
	LV_ITEM lvi;
	
	lvi.mask = LVIF_TEXT;
	lvi.iItem = m_lc_routes.GetItemCount();
	lvi.iSubItem = 0;
	lvi.pszText = ( LPTSTR )( LPCTSTR ) strDest;
	lvi.iImage = 0;
	lvi.stateMask = 0;
	int nItem = m_lc_routes.InsertItem( &lvi );
	m_lc_routes.SetItemText( nItem, 1, strMask );
	m_lc_routes.SetItemText( nItem, 2, strRouter );
	
    } // while 

    // set the first item as selected if any is added.
    if ( m_lc_routes.GetItemCount() > 0 ) {
	m_lc_routes.SetItemState( 0, LVIS_SELECTED, LVIS_SELECTED );
    }

    CATCH_MEM_EXCEPTION {
	CString str;
	m_st_option.SetWindowText( m_p_type->QueryName());
	str.LoadString( cStrId );
	m_st_application.SetWindowText( str );

	// Set proper button states.
  	HandleActivation();
    }
    END_MEM_EXCEPTION( err );
    
    if ( err ) {
	::DhcpMessageBox( err );
	EndDialog( -1 );
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
} // CDhcpRouteArrayEditor::OnInitDialog()

void CDhcpRouteArrayEditor::HandleActivation()
{

    int cItems = m_lc_routes.GetItemCount();

    // set the focus to Add button
    m_butn_route_add.SetFocus();

    m_butn_route_delete.EnableWindow( 0 != cItems );

    UpdateData( FALSE );
} // CDhcpRouteArrayEditor::HandleActivation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\routearrayeditor.h ===
#if !defined(AFX_DHCPROUTEARRAYEDITOR_H__2FE0FA05_8D0A_4D98_8C18_CBFDB201C4B9__INCLUDED_)
#define AFX_DHCPROUTEARRAYEDITOR_H__2FE0FA05_8D0A_4D98_8C18_CBFDB201C4B9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DhcpRouteArrayEditor.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDhcpRouteArrayEditor dialog

class CDhcpRouteArrayEditor : public CBaseDialog
{
    // Construction
public:
    CDhcpRouteArrayEditor( CDhcpOption *pdhcType,
			   DHCP_OPTION_SCOPE_TYPE dhcScopeType,
			   CWnd *pParent = NULL ); 
    
    // Dialog Data
    //{{AFX_DATA(CDhcpRouteArrayEditor)
    enum { IDD = IDD_ROUTE_ARRAY_EDIT };
    CStatic	m_st_option;
    CStatic	m_st_application;
    CListCtrl	m_lc_routes;
    CButton	m_butn_route_delete;
    CButton	m_butn_route_add;
    //}}AFX_DATA
    
    CDhcpOption *m_p_type;
    DHCP_OPTION_SCOPE_TYPE m_option_type;
    
    void HandleActivation();
    void Fill( INT cFocus = -1,
	       BOOL bToggleRedraw = TRUE );

    virtual DWORD * GetHelpMap() {
	return DhcpGetHelpMap( CDhcpRouteArrayEditor::IDD );
    }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDhcpRouteArrayEditor)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CDhcpRouteArrayEditor)
    afx_msg void OnButnRouteAdd();
    afx_msg void OnButnRouteDelete();
    virtual void OnCancel();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

}; // class CDhcpRouteArrayEditor

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DHCPROUTEARRAYEDITOR_H__2FE0FA05_8D0A_4D98_8C18_CBFDB201C4B9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dhcpsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDI_DHCP_SNAPIN                 2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_ROOT_NODENAME               5
#define IDS_ROOT_NAME                   6
#define IDS_DHCPSERVER_NAME             7
#define IDS_SUPERSCOPE_NAME             8
#define IDS_SCOPE_NAME                  9
#define IDS_START_IP_ADDR               10
#define IDS_END_IP_ADDR                 11
#define IDS_DESCRIPTION                 12
#define IDS_CLIENT_IP_ADDR              13
#define IDS_LEASE                       14
#define IDS_CONFLICT_IP_ADDR            15
#define IDS_SCOPE_OPTIONS               16
#define IDS_GLOBAL_OPTIONS              17
#define IDS_STATUS                      18
#define IDS_COMMENT                     19
#define IDS_CLASS                       20
#define IDS_LEASE_START                 21
#define IDS_NONE                        22
#define IDS_UNKNOWN                     23
#define IDS_UNSPECIFIED                 24
#define IDS_SNAPIN_EXTENSION_DESC       25
#define IDS_ROOT_DESC                   26
#define IDS_BIG_BOLD_FONT_NAME          30
#define IDS_BIG_BOLD_FONT_SIZE          31
#define IDS_ADD_SERVER_LOADING          32
#define IDS_VENDOR                      44
#define IDS_LOOPBACK_IP_ADDR            45
#define IDS_VALUE                       46
#define IDS_BOOTP_TABLE_FOLDER          47
#define IDS_GLOBAL_OPTIONS_FOLDER       48
#define IDS_SUPERSCOPE_FOLDER           49
#define IDS_ADDRESS_POOL_FOLDER         50
#define IDS_ACTIVE_LEASES_FOLDER        51
#define IDS_RESERVATIONS_FOLDER         52
#define IDS_RESERVATIONS_OPTIONS_FOLDER 53
#define IDS_SCOPE_OPTIONS_FOLDER        54
#define IDS_ROOT_FOLDER                 55
#define IDS_SERVER_FOLDER               56
#define IDS_SCOPE_FOLDER                57
#define IDS_LOCAL_MACHINE               58
#define IDS_IP_ADDRESS                  59
#define IDS_RESERVATIONS_OPTIONS        60
#define IDS_DHCP_CLIENT_TYPE_BOTH       61
#define IDS_DHCP_CLIENT_TYPE_DHCP       62
#define IDS_DHCP_CLIENT_TYPE_BOOTP      63
#define IDS_BOOT_IMAGE                  64
#define IDS_FILE_NAME                   65
#define IDS_FILE_SERVER                 66
#define IDS_ALLOCATION_RANGE_DESCRIPTION 67
#define IDS_EXCLUSION_RANGE_DESCRIPTION 68
#define IDS_DHCP_INFINITE_LEASE_ACTIVE  69
#define IDS_DHCP_INFINITE_LEASE_INACTIVE 70
#define IDS_DHCP_LEASE_NOT_APPLICABLE   71
#define IDS_DHCP_BAD_ADDRESS            72
#define IDS_PROP_SHEET_CLIENT_INFO      73
#define IDS_NEW_SERVER_TITLE            74
#define IDS_OPTION_NAME                 75
#define IDS_SCOPE_INACTIVE              76
#define IDS_SCOPE_ACTIVE                77
#define IDS_CLASSID_FOLDER              78
#define IDS_MSCOPE_FOLDER               79
#define IDS_UID                         80
#define IDS_CLIENT_ID                   81
#define IDS_UPTIME_FORMAT               82
#define IDS_INFINTE                     83
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDD_DEFINE_PARAM                103
#define IDC_LIST_EXCLUSION_RANGES       105
#define IDR_SEARCH_AVI                  105
#define IDC_BUTTON_EXCLUSION_ADD        106
#define IDD_IP_ARRAY_EDIT               108
#define IDC_BUTTON_EXCLUSION_DELETE     108
#define IDD_BINARY_EDITOR               109
#define IDD_DEFAULT_VALUE               110
#define IDB_SCPWIZ_BANNER               110
#define IDB_SCPWIZ_WATERMARK            112
#define IDP_CLIENT_GENERAL              113
#define IDD_RECONCILIATION              121
#define IDP_SERVER_GENERAL              122
#define IDW_SUPERSCOPE_SELECT_SCOPES    126
#define IDC_EDIT_TYPE_COMMENT           130
#define IDC_EDIT_TYPE_ID                132
#define IDP_RESERVED_CLIENT_GENERAL     132
#define IDP_SCOPE_GENERAL               133
#define IDP_SUPERSCOPE_GENERAL          134
#define IDP_BOOTP_GENERAL               136
#define IDW_SUPERSCOPE_ERROR            137
#define IDW_SUPERSCOPE_NAME             138
#define IDC_EDIT_SERVER_NAME            139
#define IDW_SUPERSCOPE_CONFIRM          139
#define IDC_COMBO_DATA_TYPE             140
#define IDC_STATIC_COMMENT              141
#define IDC_EDIT_SCOPE_COMMENT          146
#define IDC_EDIT_NAME                   148
#define IDW_SCOPE_NAME                  151
#define IDW_SCOPE_INVALID_NAME          152
#define IDW_SCOPE_SET_SCOPE             153
#define IDW_SCOPE_CREATE_SUPERSCOPE     154
#define IDW_SCOPE_LEASE_TIME            157
#define IDC_IPADDR_VALUE                158
#define IDW_SCOPE_FINISHED              159
#define IDW_SCOPE_SET_EXCLUSIONS        164
#define IDD_RESERVATION_NEW             165
#define IDD_EXCLUSION_NEW               166
#define IDD_BOOTP_NEW                   167
#define IDP_OPTION_BASIC                168
#define IDC_IPADDR_NEW                  177
#define IDC_LIST_RECONCILE_IP_ADDRESSES 178
#define IDC_LIST_VALUES                 178
#define IDC_STATIC_OPTION_NAME          180
#define IDC_BUTN_ADD                    181
#define IDC_BUTN_RESOLVE                183
#define IDC_STATIC_UNIT_SIZE            185
#define IDC_EDIT_VALUE                  186
#define IDC_RADIO_DECIMAL               191
#define IDC_RADIO_HEX                   192
#define IDC_STATIC_APPLICATION          193
#define IDC_BUTN_UP                     194
#define IDC_BUTN_DOWN                   195
#define IDC_BUTN_DELETE                 196
#define IDC_LIST_IP_ADDRS               197
#define IDC_BUTN_VALUE                  200
#define IDS_SUPERSCOPE_WIZ_TITLE        200
#define IDS_SERVER_WIZ_TITLE            201
#define IDS_SCOPE_WIZ_TITLE             202
#define IDC_EDIT_CLIENT_NAME            203
#define IDS_CONFIGURE_OPTIONS_TITLE     203
#define IDS_CONFIGURE_OPTIONS_GLOBAL    204
#define IDS_CONFIGURE_OPTIONS_SCOPE     205
#define IDC_EDIT_VALUE_NUM              206
#define IDS_CONFIGURE_OPTIONS_CLIENT    206
#define IDC_EDIT_VALUE_STRING           207
#define IDS_CONFIGURE_OPTIONS_BASIC     207
#define IDC_EDIT_VALUE_ARRAY            208
#define IDC_STATIC_SUBNET_MASK          208
#define IDS_CONFIGURE_OPTIONS_ADVANCED  208
#define IDC_STATIC_VALUE_DESC           209
#define IDC_STATIC_LEASE_EXPIRES        209
#define IDS_CONFIGURE_OPTIONS_CUSTOM    209
#define IDC_COMBO_OPTION_CLASS          210
#define IDC_EDIT_LEASE_EXPIRES          210
#define IDS_CONFIGURE_OPTIONS_BASIC_TITLE 210
#define IDC_STATIC_CLIENT_TYPE          211
#define IDS_CONFIGURE_OPTIONS_ADVANCED_TITLE 211
#define IDC_EDIT_CLIENT_TYPE            212
#define IDS_CONFIGURE_OPTIONS_CUSTOM_TITLE 212
#define IDS_DATA_ENTRY_FRAME            213
#define IDS_SCOPE_STATS_TITLE           214
#define IDS_SERVER_STATS_TITLE          215
#define IDB_ROOT_SMALL                  216
#define IDS_SUPERSCOPE_STATS_TITLE      216
#define IDC_BUTN_NEW_OPTION             217
#define IDB_ROOT_LARGE                  217
#define IDS_MSCOPE_STATS_TITLE          217
#define IDC_BUTN_OPTION_PRO             218
#define IDB_LIST_STATE                  218
#define IDS_NEW_CLASS_TITLE             218
#define IDC_EDIT_SNAPIN_NAME            219
#define IDS_EDIT_CLASS_TITLE            219
#define IDC_COMBO_OPTION_NAME           220
#define IDC_EDIT_CONFLICT_ATTEMPTS      220
#define IDD_DATA_ENTRY_DWORD            220
#define IDS_USER_CLASSES                220
#define IDC_STATIC_CLASS_NAME           221
#define IDD_DATA_ENTRY_IPADDRESS        221
#define IDS_VENDOR_CLASSES              221
#define IDC_SPIN_CONFLICT_ATTEMPTS      222
#define IDD_DATA_ENTRY_STRING           222
#define IDC_STATIC_USER_CLASS_NAME      222
#define IDS_RECONCILE_ALL_SCOPES_TITLE  222
#define IDC_EDIT_REFRESH_HOURS          223
#define IDD_DATA_ENTRY_IPADDRESS_ARRAY  223
#define IDB_TOOLBAR                     223
#define IDC_SPIN_REFRESH_HOURS          224
#define IDD_DATA_ENTRY_BINARY_ARRAY     224
#define IDC_EDIT_REFRESH_MINUTES        225
#define IDD_DATA_ENTRY_NONE             225
#define IDC_SPIN_REFRESH_MINUTES        226
#define IDD_CLASSID_NEW                 226
#define IDC_EDIT_SCOPE_NAME             227
#define IDC_CHECK_ARRAY                 228
#define IDP_DNS_INFORMATION             228
#define IDD_ADD_TO_SUPERSCOPE           229
#define IDD_BROWSE_SERVERS              230
#define IDC_EDIT_SUBNET_MASK_LENGTH     231
#define IDP_OPTION_ADVANCED             231
#define IDC_SPIN_SUBNET_MASK_LENGTH     232
#define IDC_IPADDR_EXCLUSION_START      232
#define IDW_SCOPE_WELCOME               232
#define IDC_IPADDR_EXCLUSION_END        233
#define IDC_IPADDR_POOL_STOP            233
#define IDC_IPADDR_MASK                 233
#define IDC_IPADDR_EXCLUSION_TO         233
#define IDC_IPADDR_CLIENT_SUBNET_MASK   233
#define IDC_RADIO_LEASE_UNLIMITED       234
#define IDC_IPADDR_SUBNET_MASK          234
#define IDC_IPADDR_SERVER_ADDRESS       234
#define IDW_SUPERSCOPE_WELCOME          234
#define IDP_MSCOPE_GENERAL              235
#define IDC_EDIT_LEASE_DAYS             236
#define IDW_MSCOPE_WELCOME              236
#define IDC_EDIT_CLIENT_COMMENT         237
#define IDC_EDIT_LEASE_HOURS            237
#define IDW_MSCOPE_SET_SCOPE            237
#define IDC_EDIT_LEASE_MINUTES          238
#define IDW_MSCOPE_SET_EXCLUSIONS       238
#define IDC_SPIN_LEASE_DAYS             239
#define IDW_MSCOPE_NAME                 239
#define IDC_SPIN_LEASE_HOURS            240
#define IDW_MSCOPE_LEASE_TIME           240
#define IDC_SPIN_LEASE_MINUTES          241
#define IDW_MSCOPE_INVALID_NAME         241
#define IDW_MSCOPE_FINISHED             242
#define IDC_EDIT_CLIENT_UID             243
#define IDC_EDIT_UNIQUE_IDENTIFIER      243
#define IDC_IPADDR_END                  243
#define IDD_DATA_ENTRY_BINARY           243
#define IDP_SCOPE_ADVANCED              244
#define IDD_CLASSES                     245
#define IDC_EDIT_COMMENT                246
#define IDD_GET_SERVER                  246
#define IDP_SERVER_ADVANCED             247
#define IDI_ICON02                      248
#define IDI_ICON03                      249
#define IDI_ICON04                      250
#define IDC_EDIT_DWORD                  251
#define IDC_EDIT_STRING_VALUE           251
#define IDI_ICON05                      251
#define IDC_EDIT_BOOTP_FILE_NAME        252
#define IDI_ICON06                      252
#define IDC_EDIT_BOOTP_FILE_SERVER      253
#define IDI_ICON07                      253
#define IDI_ICON08                      254
#define IDC_EDIT_BOOTP_IMAGE_NAME       255
#define IDI_ICON09                      255
#define IDI_ICON10                      256
#define IDC_LIST_AVAILABLE_SCOPES       257
#define IDC_LIST_SELECTED_SCOPES        257
#define IDI_ICON11                      257
#define IDI_ICON12                      258
#define IDC_RADIO_YES                   259
#define IDI_ICON13                      259
#define IDC_RADIO_NO                    260
#define IDI_ICON14                      260
#define IDI_ICON15                      261
#define IDI_ICON16                      262
#define IDI_ICON17                      263
#define IDI_ICON18                      264
#define IDI_ICON19                      265
#define IDI_ICON20                      266
#define IDC_STATIC_DATATYPE             267
#define IDI_ICON21                      267
#define IDI_ICON22                      268
#define IDI_ICON23                      269
#define IDI_ICON24                      270
#define IDI_ICON25                      271
#define IDC_STATIC_IP_ADDRESS           272
#define IDI_ICON26                      272
#define IDC_STATIC_UID                  273
#define IDC_CHECK_AUTO_REFRESH          273
#define IDI_ICON27                      273
#define IDC_STATIC_CLIENT_NAME          274
#define IDI_ICON28                      274
#define IDI_ICON29                      275
#define IDI_ICON30                      276
#define IDI_ICON31                      277
#define IDI_ICON32                      278
#define IDI_ICON33                      279
#define IDI_ICON34                      280
#define IDI_ICON35                      281
#define IDI_ICON36                      282
#define IDC_RADIO_LEASE_LIMITED         283
#define IDI_ICON37                      283
#define IDC_SPIN_MASK_LENGTH            284
#define IDI_ICON38                      284
#define IDC_EDIT_MASK_LENGTH            285
#define IDI_ICON39                      285
#define IDI_ICON40                      286
#define IDC_IPADDR_POOL_START           287
#define IDI_ICON41                      287
#define IDC_IPADDR_START                288
#define IDI_ICON42                      288
#define IDC_IPADDR_RESERVATION_IP       289
#define IDI_ICON43                      289
#define IDI_ICON44                      290
#define IDC_IPADDR_EXCLUSION_FROM       291
#define IDI_ICON45                      291
#define IDC_IPADDR_CLIENT_ADDRESS       292
#define IDI_ICON46                      292
#define IDC_IPADDR_RES_CLIENT_ADDRESS   293
#define IDI_ICON47                      293
#define IDC_RADIO_SUPERSCOPE_YES        294
#define IDI_ICON48                      294
#define IDC_CHECK_AUDIT_LOGGING         295
#define IDC_RADIO_SUPERSCOPE_NO         295
#define IDI_ICON49                      295
#define IDI_ICON50                      296
#define IDC_LIST_OPTIONS                297
#define IDI_ICON51                      297
#define IDI_ICON52                      298
#define IDI_ICON53                      299
#define IDI_ICON54                      300
#define IDC_EDIT_SUPERSCOPE_NAME        301
#define IDC_BUTTON_IPADDR_ADD           301
#define IDI_ICON55                      301
#define IDC_BUTTON_IPADDR_DELETE        302
#define IDI_ICON56                      302
#define IDC_BUTTON_RESOLVE              303
#define IDI_ICON57                      303
#define IDC_BUTTON_IPADDR_UP            304
#define IDI_ICON58                      304
#define IDC_BUTTON_IPADDR_DOWN          305
#define IDI_ICON59                      305
#define IDC_IPADDR_ADDRESS              306
#define IDI_ICON60                      306
#define IDC_STATIC_TYPE                 307
#define IDI_ICON61                      307
#define IDC_IPADDR_ADDRESS2             307
#define IDI_ICON62                      308
#define IDC_IPADDR_ADDRESS3             308
#define IDC_BUTTON_VALUE_UP             309
#define IDI_ICON63                      309
#define IDC_BUTTON_VALUE_DOWN           310
#define IDI_ICON64                      310
#define IDC_BUTTON_VALUE_ADD            311
#define IDI_ICON65                      311
#define IDC_BUTTON_VALUE_DELETE         312
#define IDI_ICON66                      312
#define IDC_STATIC_BINARY_ARRAY_FRAME   313
#define IDI_ICON67                      313
#define IDI_ICON68                      314
#define IDI_ICON69                      315
#define IDI_ICON70                      316
#define IDI_ICON71                      317
#define IDI_ICON72                      318
#define IDI_ICON73                      319
#define IDI_ICON74                      320
#define IDI_ICON75                      321
#define IDI_ICON76                      322
#define IDI_ICON77                      323
#define IDI_ICON78                      324
#define IDI_ICON79                      325
#define IDI_ICON80                      326
#define IDI_ICON81                      327
#define IDI_ICON82                      328
#define IDI_ICON83                      329
#define IDC_CHECK_ENABLE_DYN_DNS        330
#define IDI_ICON84                      330
#define IDC_CHECK_GARBAGE_COLLECT       331
#define IDI_ICON85                      331
#define IDC_RADIO_ALWAYS                332
#define IDI_ICON86                      332
#define IDI_ICON01                      333
#define IDC_RADIO_CLIENT                334
#define IDI_ICON87                      334
#define IDC_LIST_SUPERSCOPES            335
#define IDI_ICON88                      335
#define IDC_CHECK_UPDATE_DOWNLEVEL      336
#define IDI_ICON89                      336
#define IDC_RADIO_TYPE_DHCP             337
#define IDI_ICON90                      337
#define IDC_RADIO_TYPE_BOOTP            338
#define IDI_ICON91                      338
#define IDC_RADIO_TYPE_BOTH             339
#define IDI_ICON92                      339
#define IDW_SCOPE_CONFIGURE_OPTIONS     341
#define IDW_SCOPE_CONFIGURE_ACTIVATE    342
#define IDC_COMBO_VENDOR_CLASS          343
#define IDW_SCOPE_CONFIGURE_DNS         343
#define IDB_SRVWIZ_WATERMARK            343
#define IDC_CHECK_SHOW_BOOTP            344
#define IDC_COMBO_USER_CLASS            344
#define IDW_SCOPE_CONFIGURE_WINS        344
#define IDB_SRVWIZ_BANNER               344
#define IDW_SCOPE_CONFIGURE_ROUTER      345
#define IDD_SERVER_BINDINGS             346
#define IDC_VALUENAME                   347
#define IDD_ADD_SERVER                  347
#define IDC_VALUEDATA                   348
#define IDW_MSCOPE_ACTIVATE             348
#define IDC_BUTTON_REFRESH              349
#define IDP_MSCOPE_LIFETIME             349
#define IDC_LIST_VALID_SERVERS          350
#define IDD_CREDENTIALS                 350
#define IDC_BUTTON_REMOVE               351
#define IDD_GET_SERVER_CONFIRM          351
#define IDD_ADD_ROUTE_DIALOG            352
#define IDD_DATA_ENTRY_ROUTE_ARRAY      353
#define IDD_DATA_ENTRY_STRING_ARRAY     354
#define IDC_VALUECOMMENT                355
#define IDD_STRING_ARRAY_EDIT           355
#define IDC_STATIC_STOSS_TEXT           356
#define IDD_ROUTE_ARRAY_EDIT            356
#define IDC_STATIC_AVAILABLE_SUPERSCOPES 357
#define IDC_EDIT_TTL                    358
#define IDC_SPIN_TTL                    359
#define IDC_RADIO_DHCP_ONLY             365
#define IDC_RADIO_DHCP_BOOTP            366
#define IDC_RADIO_BOOTP_ONLY            367
#define IDC_STATIC_BOOTP_DURATION       369
#define IDC_STATIC_DHCP_DURATION        370
#define IDC_STATIC_BINARY               373
#define IDC_STATIC_ASCII                374
#define IDC_LIST_CLASSES                375
#define IDC_BUTTON_NEW                  376
#define IDC_BUTTON_DELETE               377
#define IDC_BUTTON_EDIT                 378
#define IDC_STATIC_VENDOR_CLASS_NAME    382
#define IDC_BUTTON_AUTHORIZE            384
#define IDC_EDIT_SERVER_NAME_IP         385
#define IDC_BUTTON_BROWSE_LOG           386
#define IDC_BUTTON_BROWSE_SERVERS       386
#define IDC_BUTTON_BROWSE_DATABASE      387
#define IDC_EDIT_LOG_PATH               388
#define IDC_EDIT_DOMAIN_NAME            388
#define IDC_EDIT_ADD_SERVER_NAME        388
#define IDC_STATIC_ICON                 389
#define IDC_EDIT_DATABASE_PATH          389
#define IDC_STATIC_LOGFILE              390
#define IDC_STATIC_ID                   391
#define IDC_BUTTON_BROWSE_BACKUP        391
#define IDC_STATIC_DAYS                 392
#define IDC_STATIC_HOURS                393
#define IDC_STATIC_MINUTES              394
#define IDC_STATIC_RECONCILE_DESCRIPTION 395
#define IDC_STATIC_DATABASE             397
#define IDS_RECONCILE_DATABASE          400
#define IDS_CHECK_DATABASE              401
#define IDC_IPADDR_DNS_SERVER           405
#define IDC_BUTTON_DNS_ADD              406
#define IDC_BUTTON_DNS_DELETE           407
#define IDC_LIST_DNS_LIST               408
#define IDC_IPADDR_WINS_SERVER          410
#define IDC_BUTTON_WINS_ADD             411
#define IDC_BUTTON_WINS_DELETE          412
#define IDC_LIST_WINS_LIST              413
#define IDC_STATIC_FINISHED_MORE        416
#define IDC_LIST_DEFAULT_GW_LIST        417
#define IDC_BUTTON_DEFAULT_GW_ADD       418
#define IDC_BUTTON_DEFAULT_GW_DELETE    419
#define IDC_IPADDR_DEFAULT_GW           420
#define IDC_STATIC_FINISHED_TITLE       421
#define IDC_STATIC_WELCOME_TITLE        422
#define IDC_BUTTON_BINDINGS             423
#define IDC_STATIC_MODIFY_BINDINGS_STRING 424
#define IDC_STATIC_BINDINGS_EXPLANATION 425
#define IDC_LIST_BINDINGS               426
#define IDC_RADIO_ANY_SERVER            431
#define IDC_RADIO_AUTHORIZED_SERVERS    432
#define IDC_LIST_AUTHORIZED_SERVERS     433
#define IDC_STATIC_ICON_WARNING         434
#define IDC_STATIC_WARNING_TEXT         435
#define IDC_STATIC_SUPERSCOPE_INFO      438
#define IDC_STATIC_FINISHED_MORE2       439
#define IDC_STATIC_FINISHED_MORE3       440
#define IDC_DATETIMEPICKER_DATE         441
#define IDC_RADIO_MSCOPE_INFINITE       442
#define IDC_RADIO_MSCOPE_FINITE         443
#define IDC_DATETIMEPICKER_TIME         445
#define IDC_STATIC_ICON_DESC            446
#define IDC_EDIT_BACKUP                 447
#define IDC_BUTTON_CREDENTIALS          448
#define IDC_STATIC_CREDENTIALS          449
#define IDC_EDIT_CRED_USERNAME          450
#define IDC_EDIT_CRED_DOMAIN            451
#define IDC_EDIT_CRED_PASSWORD          452
#define IDC_EDIT_CRED_PASSWORD2         453
#define IDC_EDIT_AUTH_NAME              454
#define IDC_IPADDR_AUTH                 455
#define IDC_LIST_OF_ROUTES              456
#define IDC_BUTTON_ROUTE_ADD            457
#define IDC_BUTTON_ROUTE_DEL            458
#define IDC_EDIT_STRING_ARRAY_VALUE     458
#define IDC_BUTTON_STRING_ARRAY_ADD     459
#define IDC_BUTTON_STRING_ARRAY_REMOVE  460
#define IDC_BUTTON_STRING_ARRAY_UP      461
#define IDC_STRING_ARRAY_NEW_VALUE      463
#define IDC_BUTTON_STRING_ARRAY_DOWN    464
#define IDC_LIST_STRING_ARRAY           465
#define IDC_STRING_ARRAY_CUR_VALUE      466
#define IDC_LIST_STRING                 467
#define IDC_EDIT_STRING                 468
#define IDC_LIST_ROUTES                 469
#define IDC_BUTN_ROUTE_ADD              470
#define IDC_BUTN_ROUTE_DELETE           471
#define IDC_STATIC_BACKUP_PATH          473
#define IDC_STATIC_CRED_USER_NAME       474
#define IDC_STATIC_CRED_DOMAIN          475
#define IDC_STATIC_CRED_PASSWORD        476
#define IDC_STATIC_CRED_CONFIRM_PASSWORD 477
#define IDS_MENU_ITEMS                  500
#define IDS_ADD_SERVER                  501
#define IDS_CREATE_NEW_SUPERSCOPE       502
#define IDS_CREATE_NEW_SCOPE            503
#define IDS_CREATE_OPTION_GLOBAL        504
#define IDS_CREATE_OPTION_SCOPE         505
#define IDS_CREATE_NEW_EXCLUSION        506
#define IDS_CREATE_NEW_RESERVATION      507
#define IDS_SHOW_SERVER_STATS           508
#define IDS_SUPERSCOPE_ACTIVATE         509
#define IDS_SUPERSCOPE_SHOW_STATISTICS  510
#define IDS_SUPERSCOPE_DEACTIVATE       511
#define IDS_REFRESH                     512
#define IDS_SCOPE_ACTIVATE              513
#define IDS_SCOPE_DEACTIVATE            514
#define IDS_SET_DEFAULT_OPTIONS         515
#define IDS_SCOPE_SHOW_STATISTICS       516
#define IDS_ADDRESS_POOL_VIEW_ALL       517
#define IDS_ADDRESS_POOL_FREE           518
#define IDS_CONFLICTING_ADDRESSES_REFRESH 519
#define IDS_CONFLICTING_ADDRESSES_CLEAR 520
#define IDS_CREATE_OPTION_RESERVATION   521
#define IDS_CREATE_NEW_DEFAULT_OPTIONS  522
#define IDS_CREATE_NEW_OPTION_TEMPLATE  523
#define IDS_CREATE_NEW_BOOT_IMAGE       524
#define IDS_DELETE                      525
#define IDS_SCOPE_RECONCILE             527
#define IDS_IMPORT_OLD_LIST             528
#define IDS_SCOPE_ADD_SUPERSCOPE        529
#define IDS_SCOPE_REMOVE_SUPERSCOPE     530
#define IDS_ACTIVATE                    531
#define IDS_DEACTIVATE                  532
#define IDS_CREATE_NEW_CLASS            533
#define IDS_CREATE_NEW_MSCOPE           534
#define IDS_VIEW_TASKPAD                535
#define IDS_DEFINE_VENDOR_CLASSES       536
#define IDS_DEFINE_USER_CLASSES         537
#define IDS_BROWSE_SERVERS              538
#define IDS_EXPORT_LEASE_INFO           539
#define IDS_RECONCILE_ALL               540
#define IDS_SERVER_AUTHORIZE            541
#define IDS_SERVER_DEAUTHORIZE          542
#define IDS_SERVER_START_SERVICE        543
#define IDS_SERVER_STOP_SERVICE         544
#define IDS_SERVER_PAUSE_SERVICE        545
#define IDS_SERVER_RESUME_SERVICE       546
#define IDS_SERVER_RESTART_SERVICE      547
#define IDS_MESSAGE_VIEW                548
#define IDS_SERVER_BACKUP               549
#define IDS_SERVER_RESTORE              550
#define IDS_DELETE_ITEMS                700
#define IDS_DELETE_ITEM                 701
#define IDS_DELETE_RESERVATION          702
#define IDS_CANNOT_DELETE_ALLOCATION_RANGE 703
#define IDS_DELETE_SUPERSCOPE           704
#define IDS_SUPERSCOPE_EMPTY            705
#define IDS_ERROR_AUTO_REFRESH_ZERO     706
#define IDS_REMOVE_SCOPE_FROM_SS        707
#define IDS_REMOVE_LAST_SCOPE_FROM_SS   708
#define IDS_ADD_SCOPE_DLG_TITLE         709
#define IDS_SUPERSCOPE_CREATE_STATUS    710
#define IDS_POSSIBLE_ERROR              711
#define IDS_SUPERSCOPE_CREATE_FAILED    712
#define IDS_OPTCFG_NAME                 713
#define IDS_OPTCFG_TYPE                 714
#define IDS_OPTCFG_COMMENT              715
#define IDS_VENDOR_STANDARD             716
#define IDS_USER_STANDARD               717
#define IDS_NO_CLASSES_DEFINED          718
#define IDS_SCOPE_DISABLE_CONFIRM       719
#define IDS_CLASSID_NO_NAME             720
#define IDS_CLASSID_NO_DATA             721
#define IDS_QUERY_DS                    722
#define IDS_INVALID_MSCOPE_ID           723
#define IDS_INVALID_MCAST_ADDRESS       724
#define IDS_MSCOPE_ID_IN_USE            725
#define IDS_SCOPE_CONTAINS_MULTICAST    726
#define IDS_WARNING_SERVER_NOT_VALID    727
#define IDS_CONFIRM_CLASS_DELETE        728
#define IDS_DELETE_LAST_SCOPE_FROM_SS   729
#define IDS_CANNOT_DELETE_OPTION_SCOPE  730
#define IDS_CANNOT_DELETE_OPTION_RES    731
#define IDS_CONNOT_CONFIGURE_OPTION_SCOPE 732
#define IDS_CONNOT_CONFIGURE_OPTION_RES 733
#define IDS_CONFIRM_AUTHORIZATION       734
#define IDS_BROWSE_DATABASE_PATH        735
#define IDS_BROWSE_LOG_PATH             736
#define IDS_PATH_CHANGE_RESTART_SERVICE 737
#define IDS_SERVICE_NAME                738
#define IDS_ERROR_DELETING_RECORD       739
#define IDS_CHECKING_SCOPES             740
#define IDS_FIXING_SCOPES               741
#define IDS_INVALID_TTL                 742
#define IDS_WARNING_DEAUTHORIZE         743
#define IDS_ROGUE_WARNING               744
#define IDS_CREATE_SUPERSCOPE_INFO      745
#define IDS_CREATE_SUPERSCOPE_WARNING   746
#define IDS_BACKUP_HELP                 747
#define IDS_RESTORE_HELP                748
#define IDS_SERVER_STATS_START_TIME     750
#define IDS_SERVER_STATS_DISCOVERS      751
#define IDS_SERVER_STATS_OFFERS         752
#define IDS_SERVER_STATS_REQUESTS       753
#define IDS_SERVER_STATS_ACKS           754
#define IDS_SERVER_STATS_NACKS          755
#define IDS_SERVER_STATS_DECLINES       756
#define IDS_SERVER_STATS_RELEASES       757
#define IDS_SERVER_STATS_UPTIME         758
#define IDS_STATS_TOTAL_SCOPES          760
#define IDS_STATS_TOTAL_ADDRESSES       761
#define IDS_STATS_IN_USE                762
#define IDS_STATS_AVAILABLE             763
#define IDS_FILE_EXTENSION              764
#define IDS_FILE_DEFNAME                765
#define IDS_EXPFILE_TITLE               767
#define IDS_STR_EXPORTFILE_FILTER       768
#define IDS_EXPORT_SUCCESS              769
#define IDS_STATUS_ROGUE                770
#define IDS_STATUS_UNKNOWN              771
#define IDS_STATUS_RUNNING              772
#define IDC_STATIC_ROUTER               773
#define IDC_STATIC_NETWORK_MASK         774
#define IDC_STATIC_DESTINATION          775
#define IDS_TB_TEXT_CREATE_SCOPE        800
#define IDS_TB_TEXT_CREATE_SUPERSCOPE   801
#define IDS_TB_TEXT_REFRESH             802
#define IDS_TB_TEXT_ADD_SERVER          803
#define IDS_TB_TEXT_ACTIVATE            804
#define IDS_TB_TEXT_DEACTIVATE          805
#define IDS_TB_TEXT_OPTION_GLOBAL       806
#define IDS_TB_TEXT_OPTION_SCOPE        807
#define IDS_TB_TEXT_OPTION_RESERVATION  808
#define IDS_TB_TEXT_ADD_BOOTP           809
#define IDS_TB_TEXT_ADD_RESERVATION     810
#define IDS_TB_TEXT_ADD_EXCLUSION       811
#define IDS_TB_TOOLTIP_CREATE_SCOPE     850
#define IDS_TB_TOOLTIP_CREATE_SUPERSCOPE 851
#define IDS_TB_TOOLTIP_REFRESH          852
#define IDS_TB_TOOLTIP_ADD_SERVER       853
#define IDS_TB_TOOLTIP_ACTIVATE         854
#define IDS_TB_TOOLTIP_DEACTIVATE       855
#define IDS_TB_TOOLTIP_OPTION_GLOBAL    856
#define IDS_TB_TOOLTIP_OPTION_SCOPE     857
#define IDS_TB_TOOLTIP_OPTION_RESERVATION 858
#define IDS_TB_TOOLTIP_ADD_BOOTP        859
#define IDS_TB_TOOLTIP_ADD_RESERVATION  860
#define IDS_TB_TOOLTIP_ADD_EXCLUSION    861
#define IDS_RESERVED_STRINGS            999
#define IDS_ROOT_MESSAGE_TITLE          1500
#define IDS_ROOT_MESSAGE_BODY1          1501
#define IDS_ROOT_MESSAGE_BODY2          1502
#define IDS_ROOT_MESSAGE_ADD_SERVER     1503
#define IDS_ROOT_MESSAGE_BODY3          1503
#define IDS_ROOT_MESSAGE_INFO           1504
#define IDS_MESSASGE_NEWLINE            1505
#define IDS_SERVER_MESSAGE_NOT_CONFIGURED_TITLE 1510
#define IDS_SERVER_MESSAGE_NOT_CONFIGURED_BODY1 1511
#define IDS_SERVER_MESSAGE_NOT_CONFIGURED_BODY2 1512
#define IDS_SERVER_MESSAGE_NOT_AUTHORIZED_TITLE 1514
#define IDS_SERVER_MESSAGE_NOT_AUTHORIZED_BODY1 1515
#define IDS_SERVER_MESSAGE_NOT_AUTHORIZED_BODY2 1516
#define IDS_SERVER_MESSAGE_NO_SCOPES_TITLE 1517
#define IDS_SERVER_MESSAGE_NO_SCOPES_BODY1 1518
#define IDS_SERVER_MESSAGE_NO_SCOPES_BODY2 1519
#define IDS_SERVER_MESSAGE_ACCESS_DENIED_TITLE 1520
#define IDS_SERVER_MESSAGE_ACCESS_DENIED_BODY 1521
#define IDS_SERVER_MESSAGE_CONNECT_FAILED_TITLE 1525
#define IDS_SERVER_MESSAGE_CONNECT_FAILED_BODY 1526
#define IDS_SERVER_MESSAGE_CONNECT_FAILED_REFRESH 1527
#define IDS_SERVER_OPTIONS_MESSAGE_TITLE 1530
#define IDS_SERVER_OPTIONS_MESSAGE_BODY 1531
#define IDS_SCOPE_OPTIONS_MESSAGE_TITLE 1532
#define IDS_SCOPE_OPTIONS_MESSAGE_BODY  1533
#define IDS_RES_OPTIONS_MESSAGE_TITLE   1534
#define IDS_RES_OPTIONS_MESSAGE_BODY    1535
#define IDS_RESERVATIONS_MESSAGE_TITLE  1536
#define IDS_RESERVATIONS_MESSAGE_BODY   1537
#define IDS_SERVER_WIZ_NAME_TITLE       2000
#define IDS_SERVER_WIZ_NAME_SUBTITLE    2001
#define IDS_SERVER_WIZ_WAIT_TITLE       2002
#define IDS_SERVER_WIZ_WAIT_SUBTITLE    2003
#define IDS_SERVER_WIZ_NOT_FOUND_TITLE  2004
#define IDS_SERVER_WIZ_NOT_FOUND_SUBTITLE 2005
#define IDS_SERVER_WIZ_NOT_AUTHORIZED_TITLE 2006
#define IDS_SERVER_WIZ_NOT_AUTHORIZED_SUBTITLE 2007
#define IDS_SUPERSCOPE_WIZ_NAME_TITLE   2010
#define IDS_SUPERSCOPE_WIZ_NAME_SUBTITLE 2011
#define IDS_SUPERSCOPE_WIZ_ERROR_TITLE  2012
#define IDS_SUPERSCOPE_WIZ_ERROR_SUBTITLE 2013
#define IDS_SUPERSCOPE_WIZ_SELECT_TITLE 2014
#define IDS_SUPERSCOPE_WIZ_SELECT_SUBTITLE 2015
#define IDS_SCOPE_WIZ_SUPERSCOPE_TITLE  2020
#define IDS_SCOPE_WIZ_SUPERSCOPE_SUBTITLE 2021
#define IDS_SCOPE_WIZ_INVALID_NAME_TITLE 2022
#define IDS_SCOPE_WIZ_INVALID_NAME_SUBTITLE 2023
#define IDS_SCOPE_WIZ_LEASE_TITLE       2024
#define IDS_SCOPE_WIZ_LEASE_SUBTITLE    2025
#define IDS_SCOPE_WIZ_NAME_TITLE        2026
#define IDS_SCOPE_WIZ_NAME_SUBTITLE     2027
#define IDS_SCOPE_WIZ_EXCLUSIONS_TITLE  2028
#define IDS_SCOPE_WIZ_EXCLUSIONS_SUBTITLE 2029
#define IDS_SCOPE_WIZ_SCOPE_TITLE       2030
#define IDS_SCOPE_WIZ_SCOPE_SUBTITLE    2031
#define IDS_SCOPE_WIZ_CONFIG_TITLE      2032
#define IDS_SCOPE_WIZ_CONFIG_SUBTITLE   2033
#define IDS_SCOPE_WIZ_ROUTER_TITLE      2034
#define IDS_SCOPE_WIZ_ROUTER_SUBTITLE   2035
#define IDS_SCOPE_WIZ_DNS_TITLE         2036
#define IDS_SCOPE_WIZ_DNS_SUBTITLE      2037
#define IDS_SCOPE_WIZ_WINS_TITLE        2038
#define IDS_SCOPE_WIZ_WINS_SUBTITLE     2039
#define IDS_SCOPE_WIZ_ACTIVATE_TITLE    2040
#define IDS_SCOPE_WIZ_ACTIVATE_SUBTITLE 2041
#define IDS_MSCOPE_WIZ_INVALID_NAME_TITLE 2050
#define IDS_MSCOPE_WIZ_INVALID_NAME_SUBTITLE 2051
#define IDS_MSCOPE_WIZ_LEASE_TITLE      2052
#define IDS_MSCOPE_WIZ_LEASE_SUBTITLE   2053
#define IDS_MSCOPE_WIZ_NAME_TITLE       2054
#define IDS_MSCOPE_WIZ_NAME_SUBTITLE    2055
#define IDS_MSCOPE_WIZ_EXCLUSIONS_TITLE 2056
#define IDS_MSCOPE_WIZ_EXCLUSIONS_SUBTITLE 2057
#define IDS_MSCOPE_WIZ_SCOPE_TITLE      2058
#define IDS_MSCOPE_WIZ_SCOPE_SUBTITLE   2059
#define IDS_MSCOPE_WIZ_ACTIVATE_TITLE   2060
#define IDS_MSCOPE_WIZ_ACTIVATE_SUBTITLE 2061
#define IDC_DATA_ENTRY_ANCHOR           4592
#define IDS_ERR_BASE                    62000
#define IDS_ERR_NO_MEM                  62001
#define IDS_ERR_BAD_HOST_NAME           62002
#define IDS_ERR_HOST_ALREADY_CONNECTED  62003
#define IDS_ERR_NOT_SUPPORTED           62004
#define IDS_ERR_SCOPE_ALREADY_KNOWN     62005
#define IDS_ERR_CANT_CHANGE_ID          62006
#define IDS_ERR_ID_ALREADY_EXISTS       62007
#define IDS_ERR_IP_RANGE_INV_START      62008
#define IDS_ERR_IP_RANGE_INV_END        62009
#define IDS_ERR_DLG_UPDATE              62010
#define IDS_ERR_IP_RANGE_OVERLAP        62011
#define IDS_ERR_IP_RANGE_NOT_SUBSET     62012
#define IDS_ERR_IP_RANGE_INVALID        62013
#define IDS_ERR_NOTHING_CHANGED         62014
#define IDS_ERR_SOMETHING_CHANGED       62015
#define IDS_ERR_NO_PRIMARY_SELECTED     62016
#define IDS_ERR_INTERNAL_ERROR          62017
#define IDS_INVALID_OPTION_DATA         62018
#define IDS_ERR_SCOPE_NAME_REQUIRED     62019
#define IDS_ERR_SCOPE_COMMENT_REQUIRED  62020
#define IDS_ERR_OPTION_NAME_REQUIRED    62021
#define IDS_ERR_BINARY_DATA_NOT_SUPPORTED 62022
#define IDS_ERR_ARRAY_EDIT_NOT_SUPPORTED 62023
#define IDS_ERR_INVALID_NUMBER          62024
#define IDS_ERR_SUBNET_MASK_INVALID     62025
#define IDS_ERR_OPTION_NOT_FOUND_FOR_DELETE 62026
#define IDS_ERR_MESSAGE_GENERIC         62027
#define IDS_ERR_INVALID_DATE            62028
#define IDS_ERR_INVALID_UID             62029
#define IDS_ERR_INVALID_CLIENT_NAME     62030
#define IDS_ERR_INVALID_CLIENT_IPADDR   62031
#define IDS_ERR_CANT_CHANGE_CLIENT_IPADDR 62032
#define IDS_ERR_OPTION_ADDR_PAIRS       62033
#define IDS_ERR_SUPERSCOPE_NAME_IN_USE  62034
#define IDS_INVALID_MCAST_SCOPED_RANGE  62035
#define IDS_ERR_RESTORE_FAILED          62040
#define IDS_ERR_RESERVED_OPTION_ID      62045
#define IDS_ERR_SCOPE_EXISTS            62046
#define IDS_ERR_DLL_BASE                63000
#define IDS_ERR_DLL_CANT_CONNECT_HOST   63001
#define IDS_ERR_DLL_NO_CONNECTION       63002
#define IDS_ERR_DLL_INVALID_ADDRESS     63003
#define IDS_ERR_DLL_HOST_INFO_UNAVAIL   63004
#define IDS_ERR_DLL_SCOPE_CONFLICT      63005
#define IDS_ERR_CANTUSENETBIOS          63007
#define IDS_MSG_DELETE_SCOPE            63008
#define IDS_CONNECT_ERROR               63009
#define IDS_WRN_DISCONNECT              63010
#define IDS_MSG_ALREADY_DELETED         63011
#define IDS_WRN_WINS_OPTIONS            63012
#define IDS_ERR_DHCP_DOWN               63013
#define IDS_ERR_VALUE_OUT_OF_RANGE      63014
#define IDS_ERR_NO_DURATION_SPECIFIED   63015
#define IDS_MSG_IP_CHANGED              63016
#define IDS_ERR_INVALID_OPTION_ID       63017
#define IDS_MSG_DELETE_SCOPE_FORCE      63018
#define IDS_ERR_NO_LEASE_STATISTICS     63019
#define IDS_MSG_DELETE_ACTIVE           63020
#define IDS_MSG_DELETE_LEASE            63021
#define IDS_ERR_RPC_NO_ENTRY            63022
#define IDS_PASSWORDS_DONT_MATCH        63023
#define IDS_INFO_TYPNAM_DEC             64000
#define IDS_INFO_TYPNAM_HEX             64001
#define IDS_INFO_TYPNAM_STRING          64002
#define IDS_INFO_TYPNAM_IP              64003
#define IDS_INFO_TYPNAM_BOOL            64004
#define IDS_INFO_TYPNAM_FALSE           64005
#define IDS_INFO_TYPNAM_TRUE            64006
#define IDS_INFO_TYPNAM_INVALID         64007
#define IDS_INFO_GLOBAL_PARAMS          64008
#define IDS_INFO_FORMAT_IP_RANGE        64009
#define IDS_INFO_FORMAT_IP_INVALID      64010
#define IDS_INFO_FORMAT_IP_UNITARY      64011
#define IDS_INFO_FORMAT_OPTION_ID       64012
#define IDS_INFO_TITLE_GLOBAL_OPTIONS   64013
#define IDS_INFO_TITLE_SCOPE_OPTIONS    64014
#define IDS_INFO_TITLE_RESV_OPTIONS     64015
#define IDS_INFO_TITLE_SCOPE_PROP       64016
#define IDS_INFO_TITLE_CREATE_SCOPE     64017
#define IDS_INFO_TYPOPT_BYTE            64018
#define IDS_INFO_TYPOPT_WORD            64019
#define IDS_INFO_TYPOPT_DWORD           64020
#define IDS_INFO_TYPOPT_DWDW            64021
#define IDS_INFO_TYPOPT_IP_ADDR         64022
#define IDS_INFO_TYPOPT_STRING          64023
#define IDS_INFO_TYPOPT_BINARY          64024
#define IDS_INFO_TYPOPT_ENCAPS          64025
#define IDS_INFO_TITLE_CHANGE_OPT_TYPE  64026
#define IDS_INFO_TITLE_ADD_OPTION_TYPES 64027
#define IDS_INFO_FORMAT_SCOPE_NAME      64028
#define IDS_INFO_FORMAT_SERVER_NAME     64029
#define IDS_INFO_NAME_SCOPE             64030
#define IDS_INFO_NAME_GLOBAL            64031
#define IDS_INFO_NAME_DHCP_DEFAULT      64032
#define IDS_INFO_NAME_DHCP_VENDOR       64033
#define IDS_INFO_CHAR_SCOPE             64034
#define IDS_INFO_CHAR_GLOBAL            64035
#define IDS_INFO_HEX_TABLE              64036
#define IDS_INFO_TITLE_DEFAULT_OPTIONS  64037
#define IDS_INFO_OPTION_REFERENCE       64038
#define IDS_INFO_EXPIRES_NEVER          64040
#define IDS_INFO_MONTH_TABLE            64041
#define IDS_INFO_TITLE_ADD_CLIENT       64042
#define IDS_INFO_TITLE_CHANGE_CLIENT    64043
#define IDS_INFO_FORMAT_CLIENT_IP       64044
#define IDS_INFO_FORMAT_RESV_IP         64045
#define IDS_INFO_BUTTON_CLOSE           64046
#define IDS_INFO_NAME_RESERVATION       64047
#define IDS_STATUS_GETTING_CLIENT_INFO  64048
#define IDS_STATUS_CLIENT_REVIEW        64049
#define IDS_STATUS_GETTING_HOST_INFO    64050
#define IDS_INFO_UNPAUSE_SERVER         64051
#define IDS_INFO_PAUSE_SERVER           64052
#define IDS_INFO_FORMAT_RESV_IN_USE     64053
#define IDS_INFO_TIME_INFINITE          64054
#define IDS_INFO_SERVER_INDICATOR       64055
#define IDS_STATUS_GETTING_OPTIONS      64056
#define IDS_ACTIVATE_SCOPE_NOW          64057
#define IDS_BUTTON_ADD                  64058
#define IDS_BUTTON_CANCEL               64059
#define IDS_BUTTON_CLOSE                64060
#define IDS_BUTTON_OK                   64061
#define IDS_STATUS_GETTING_LEASES       64062
#define IDS_STATUS_STORING_CLIENT       64063
#define IDS_STATUS_UPDATING_CLIENT      64064
#define IDS_STATUS_DEFAULT_VALUES       64065
#define IDS_STATUS_CREATING_SCOPE       64066
#define IDS_INFO_LEASE_PERCENTAGE       64067
#define IDS_INFO_LOCAL                  64068
#define IDS_INFO_LOCAL2                 64069
#define IDS_STATUS_RECONCILE1           64070
#define IDS_STATUS_RECONCILE2           64071
#define IDS_MSG_NO_RECONCILE            64072
#define IDS_INFO_FORMAT_IP_NONE         64073
#define IDS_ERR_INVALID_INTEGER         64074
#define IDS_STATUS_CONNECTING_TO_SERVER 64075
#define IDS_INFO_TIME_NA                64076
#define IDS_UID_MAY_BE_WRONG            64077
#define IDS_STATUS_GETTING_SUPERSCOPE_INFO 64078
#define IDS_STATUS_UPDATING_SUPERSCOPE_INFO 64079
#define IDS_STATUS_GETTING_SERVER_INFO  64080
#define IDS_STATUS_UPDATING_SERVER_INFO 64081
#define IDS_UID_TOO_LONG                64082
#define IDS_INFO_TYPOPT_BYTE2           64083
#define IDS_INFO_TYPOPT_WORD2           64084
#define IDS_INFO_TYPOPT_DWORD2          64085
#define IDS_INFO_TYPOPT_DWDW2           64086
#define IDS_INFO_TYPOPT_IP_ADDR2        64087
#define IDS_INFO_TYPOPT_STRING2         64088
#define IDS_INFO_TYPOPT_BINARY2         64089
#define IDS_INFO_TYPOPT_ENCAPS2         64090
#define IDS_ERR_INVALID_ROUTE_ENTRY     64091
#define IDS_MESG_MAX                    65000
#define IDS_ROUTE_LIST_COL_DEST         65002
#define IDS_ROUTE_LIST_COL_MASK         65003
#define IDS_ROUTE_LIST_COL_ROUTER       65004
#define IDS_MSG_CLOSE_PROPSHEET         65005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        357
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         478
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopepp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ScopePP.cpp
		This file contains all of the implementation for the 
		scope property page.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "scopepp.h"
#include "scope.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RADIO_SCOPE_TYPE_BOTH  2
#define RADIO_SCOPE_TYPE_DHCP  0
#define RADIO_SCOPE_TYPE_BOOTP 1

/////////////////////////////////////////////////////////////////////////////
//
// CScopeProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CScopeProperties::CScopeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
	m_liVersion.QuadPart = 0;
	m_fSupportsDynBootp = FALSE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CScopeProperties::~CScopeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);

	if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
	{
		RemovePageFromList((CPropertyPageBase*) &m_pageDns, FALSE);
	}

	if (m_fSupportsDynBootp)
	{
		RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
	}
}

void
CScopeProperties::SetVersion
(
	LARGE_INTEGER &	 liVersion
)
{
	m_liVersion = liVersion;

	if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
	{
		AddPageToList((CPropertyPageBase*) &m_pageDns);
	}
}

void
CScopeProperties::SetDnsRegistration
(
	DWORD					dnsRegOption,
	DHCP_OPTION_SCOPE_TYPE	dhcpOptionType
)
{
	m_pageDns.m_dwFlags = dnsRegOption;
	m_pageDns.m_dhcpOptionType = dhcpOptionType;
}

void 
CScopeProperties::SetSupportsDynBootp(BOOL fSupportsDynBootp)
{
	if (fSupportsDynBootp)
	{
    	AddPageToList((CPropertyPageBase*) &m_pageAdvanced);
		m_fSupportsDynBootp = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CScopePropGeneral property page

IMPLEMENT_DYNCREATE(CScopePropGeneral, CPropertyPageBase)

CScopePropGeneral::CScopePropGeneral() : CPropertyPageBase(CScopePropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CScopePropGeneral)
	m_strComment = _T("");
	m_strName = _T("");
	//}}AFX_DATA_INIT

	m_bInitialized = FALSE;
	m_bUpdateName = FALSE;
	m_bUpdateComment = FALSE;
	m_bUpdateLease = FALSE;
	m_bUpdateRange = FALSE;
    m_uImage = 0;
}

CScopePropGeneral::~CScopePropGeneral()
{
}

void CScopePropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScopePropGeneral)
	DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_SCOPE_COMMENT, m_editComment);
	DDX_Control(pDX, IDC_EDIT_SUBNET_MASK_LENGTH, m_editSubnetMaskLength);
	DDX_Control(pDX, IDC_RADIO_LEASE_UNLIMITED, m_radioUnlimited);
	DDX_Control(pDX, IDC_RADIO_LEASE_LIMITED, m_radioLimited);
	DDX_Control(pDX, IDC_EDIT_LEASE_MINUTES, m_editMinutes);
	DDX_Control(pDX, IDC_EDIT_LEASE_HOURS, m_editHours);
	DDX_Control(pDX, IDC_EDIT_LEASE_DAYS, m_editDays);
	DDX_Control(pDX, IDC_SPIN_SUBNET_MASK_LENGTH, m_spinSubnetMaskLength);
	DDX_Control(pDX, IDC_SPIN_LEASE_HOURS, m_spinHours);
	DDX_Control(pDX, IDC_SPIN_LEASE_MINUTES, m_spinMinutes);
	DDX_Control(pDX, IDC_SPIN_LEASE_DAYS, m_spinDays);
	DDX_Text(pDX, IDC_EDIT_SCOPE_COMMENT, m_strComment);
	DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strName);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_END, m_ipaEnd);
    DDX_Control(pDX, IDC_IPADDR_MASK, m_ipaSubnetMask);
}


BEGIN_MESSAGE_MAP(CScopePropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CScopePropGeneral)
	ON_BN_CLICKED(IDC_RADIO_LEASE_LIMITED, OnRadioLeaseLimited)
	ON_BN_CLICKED(IDC_RADIO_LEASE_UNLIMITED, OnRadioLeaseUnlimited)
	ON_EN_CHANGE(IDC_EDIT_LEASE_DAYS, OnChangeEditLeaseDays)
	ON_EN_CHANGE(IDC_EDIT_LEASE_HOURS, OnChangeEditLeaseHours)
	ON_EN_CHANGE(IDC_EDIT_LEASE_MINUTES, OnChangeEditLeaseMinutes)
	ON_EN_CHANGE(IDC_EDIT_SUBNET_MASK_LENGTH, OnChangeEditSubnetMaskLength)
	ON_EN_KILLFOCUS(IDC_IPADDR_MASK, OnKillfocusSubnetMask)
	ON_EN_CHANGE(IDC_EDIT_SCOPE_COMMENT, OnChangeEditScopeComment)
	ON_EN_CHANGE(IDC_EDIT_SCOPE_NAME, OnChangeEditScopeName)
	//}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPADDR_START, OnChangeIpAddrStart)
    ON_EN_CHANGE(IDC_IPADDR_END, OnChangeIpAddrStart)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopePropGeneral message handlers

BOOL CScopePropGeneral::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

    // Limit the name and comment fields to 255 chars
    CEdit *pEditName = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_NAME ));
    if ( 0 != pEditName ) {
        pEditName->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }
    CEdit *pEditComment = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_COMMENT ));
    if ( 0 != pEditComment ) {
        pEditComment->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }

    m_ipaStart.SetAddress(m_dwStartAddress);
    m_ipaEnd.SetAddress(m_dwEndAddress);
    m_ipaSubnetMask.SetAddress(m_dwSubnetMask);
    m_ipaSubnetMask.EnableWindow(FALSE);

    m_spinMinutes.SetRange(0, 59);
    m_spinHours.SetRange(0, 23);
    m_spinDays.SetRange(0, 999);

    m_editMinutes.LimitText(2);
    m_editHours.LimitText(2);
    m_editDays.LimitText(3);

	if (m_dwLeaseTime != DHCP_INFINIT_LEASE)
	{
		int nDays, nHours, nMinutes;

		UtilConvertLeaseTime(m_dwLeaseTime, &nDays, &nHours, &nMinutes);

		m_spinDays.SetPos(nDays);
		m_spinHours.SetPos(nHours);
		m_spinMinutes.SetPos(nMinutes);
	}

    m_radioUnlimited.SetCheck(m_dwLeaseTime == DHCP_INFINIT_LEASE);
	m_radioLimited.SetCheck(m_dwLeaseTime != DHCP_INFINIT_LEASE);

	ActivateDuration (m_dwLeaseTime != DHCP_INFINIT_LEASE);

    m_bInitialized = TRUE;

	m_spinSubnetMaskLength.SetRange(8, 32);
	UpdateMask(FALSE);

	m_spinSubnetMaskLength.EnableWindow(FALSE);
	m_editSubnetMaskLength.EnableWindow(FALSE);
	m_ipaSubnetMask.SetReadOnly(TRUE);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }
    
    SetDirty(FALSE);
    
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CScopePropGeneral::OnSetActive() 
{
	BOOL				fEnable = TRUE;
	CScopeProperties *	pScopeProp = (CScopeProperties *) GetHolder();

	if (pScopeProp->FSupportsDynBootp())
	{
		if (pScopeProp->m_pageAdvanced.m_RangeType == DhcpIpRangesBootpOnly)
		{
			fEnable = FALSE;
		}
	}

	// enable/disable DHCP clients lease time 
    GetDlgItem(IDC_RADIO_LEASE_UNLIMITED)->EnableWindow(fEnable);
    GetDlgItem(IDC_RADIO_LEASE_LIMITED)->EnableWindow(fEnable);

	GetDlgItem(IDC_STATIC_DHCP_DURATION)->EnableWindow(fEnable);

    if (fEnable && IsDlgButtonChecked(IDC_RADIO_LEASE_LIMITED))
    {
        fEnable = TRUE;
    }
    else
    {
        fEnable = FALSE;
    }
    
    ActivateDuration(fEnable);

	return CPropertyPageBase::OnSetActive();
}

void CScopePropGeneral::OnRadioLeaseLimited() 
{
	if (((CButton *) GetDlgItem(IDC_RADIO_LEASE_LIMITED))->GetCheck())
	{
	    ActivateDuration(TRUE);
	    SetDirty(TRUE);
    }
}

void CScopePropGeneral::OnRadioLeaseUnlimited() 
{
	if (((CButton *) GetDlgItem(IDC_RADIO_LEASE_UNLIMITED))->GetCheck())
	{
	    ActivateDuration(FALSE);
	    SetDirty(TRUE);
    }
}

BOOL CScopePropGeneral::OnApply() 
{
	UpdateData();

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DWORD dwLeaseTime;
	if (m_radioUnlimited.GetCheck())
	{
		dwLeaseTime = DHCP_INFINIT_LEASE;
	}
	else
	{
		dwLeaseTime = UtilConvertLeaseTime(m_spinDays.GetPos(), 
										   m_spinHours.GetPos(),
										   m_spinMinutes.GetPos());
	}
	
	if (dwLeaseTime == 0)
	{
		DhcpMessageBox(IDS_ERR_NO_DURATION_SPECIFIED);
		m_editDays.SetFocus();
		
		return FALSE;
	}

	if (dwLeaseTime != m_dwLeaseTime)
	{
		m_bUpdateLease = TRUE;
		m_dwLeaseTime = dwLeaseTime;
	}
	
	m_bUpdateName = m_editName.GetModify();
	m_editName.SetModify(FALSE);

	m_bUpdateComment = m_editComment.GetModify();
	m_editComment.SetModify(FALSE);

	if (m_ipaStart.GetModify() ||
		m_ipaEnd.GetModify() )
	{
        DWORD dwStartAddr, dwEndAddr;

        m_ipaStart.GetAddress(&dwStartAddr);
		m_ipaEnd.GetAddress(&dwEndAddr);

        // make sure that the starting address != subnet address
        if ( ((dwStartAddr & ~m_dwSubnetMask) == (DWORD) 0) ||
             (dwStartAddr > dwEndAddr) )
        {
            Trace0("CScopePropGeneral::OnApply() - starting range is 0 for subnet\n");
            DhcpMessageBox(IDS_ERR_IP_RANGE_INV_START);
            m_ipaStart.SetFocus();
            return FALSE;
        }

        // make sure that the subnet broadcast address is not the ending address
        if ((dwEndAddr & ~m_dwSubnetMask) == ~m_dwSubnetMask)
        {
            Trace0("CScopePropGeneral::OnApply() - ending range is subnet broadcast addr\n");
            DhcpMessageBox(IDS_ERR_IP_RANGE_INV_END);
            m_ipaEnd.SetFocus();
            return FALSE;
        }

        m_bUpdateRange = TRUE;
        m_dwStartAddress = dwStartAddr;
        m_dwEndAddress = dwEndAddr;
    }

	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		// AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

	return bRet;
}

BOOL CScopePropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	CDhcpScope *	pScope;
	SPITFSNode		spNode;
	DWORD			dwError = 0;	

	spNode = GetHolder()->GetNode();
	pScope = GETHANDLER(CDhcpScope, spNode);
	
	BEGIN_WAIT_CURSOR;

    //
	// Check to see if we need to update the least time
	//
	if (m_bUpdateLease)
	{
		// Lease time changed, update on server
		dwError = pScope->SetLeaseTime(m_dwLeaseTime);
		if (dwError != ERROR_SUCCESS)
        {
            GetHolder()->SetError(dwError);
        }

        m_bUpdateLease = FALSE;
	}

	//
	// Now check the allocation range
	//
	if (m_bUpdateRange)
	{
		// need to update the address pool allocation range
		CDhcpIpRange dhcpIpRange;

		dhcpIpRange.SetAddr(m_dwStartAddress, TRUE);
		dhcpIpRange.SetAddr(m_dwEndAddress, FALSE);

		dhcpIpRange.SetRangeType(((CScopeProperties *) GetHolder())->m_pageAdvanced.m_RangeType);

		dwError = pScope->SetIpRange(dhcpIpRange, TRUE);
		if (dwError != ERROR_SUCCESS)
        {
            GetHolder()->SetError(dwError);
        }
	}

	//
	// Update the name and comment if necessary 
	//
	if (m_bUpdateName)
	{
		pScope->SetName(m_strName);
		*ChangeMask = SCOPE_PANE_CHANGE_ITEM_DATA;
	}
	
	if (m_bUpdateComment)
	{
		pScope->SetComment(m_strComment);
	}

	if (m_bUpdateName || m_bUpdateComment)
	{
		dwError = pScope->SetInfo();
		if (dwError != ERROR_SUCCESS)
        {
            GetHolder()->SetError(dwError);
        }
        
        m_bUpdateName = m_bUpdateComment = FALSE;
	}
	
    END_WAIT_CURSOR;

	return FALSE;
}

void CScopePropGeneral::OnChangeEditLeaseDays() 
{
    ValidateLeaseTime();
	SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeEditLeaseHours() 
{
    ValidateLeaseTime();
    SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeEditLeaseMinutes() 
{
    ValidateLeaseTime();
    SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeEditSubnetMaskLength() 
{
	UpdateMask(TRUE);
	SetDirty(TRUE);
}

void CScopePropGeneral::OnKillfocusSubnetMask() 
{
	UpdateMask(FALSE);
	SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeEditScopeComment() 
{
	SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeEditScopeName() 
{
	SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeIpAddrStart() 
{
	SetDirty(TRUE);
}

void CScopePropGeneral::OnChangeIpAddrEnd() 
{
	SetDirty(TRUE);
}


//
// Helpers
//
void 
CScopePropGeneral::ActivateDuration
(
	BOOL fActive
)
{
	m_spinMinutes.EnableWindow(fActive);
    m_spinHours.EnableWindow(fActive);
    m_spinDays.EnableWindow(fActive);

	m_editMinutes.EnableWindow(fActive);
    m_editHours.EnableWindow(fActive);
    m_editDays.EnableWindow(fActive);

	GetDlgItem(IDC_STATIC_DAYS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_HOURS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_MINUTES)->EnableWindow(fActive);
}   

//
// Update the subnet mask field using either the length identifier or 
// the acutal address as the base
//
void
CScopePropGeneral::UpdateMask(BOOL bUseLength)
{
	if (m_bInitialized)
	{
		if (bUseLength)
		{
			DWORD dwAddress = 0xFFFFFFFF;

			dwAddress = dwAddress << (32 - (DWORD) m_spinSubnetMaskLength.GetPos());	
			
			m_ipaSubnetMask.SetAddress(dwAddress);
		}
		else
		{
			DWORD dwAddress, dwTestMask = 0x80000000;
			int nLength = 0;

			m_ipaSubnetMask.GetAddress(&dwAddress);

			while (TRUE)
			{
				if (dwAddress & dwTestMask)
				{
					nLength++;
					dwTestMask = dwTestMask >> 1;
				}
				else
				{
					break;
				}

			}

			m_spinSubnetMaskLength.SetPos(nLength);
		}
	}
}


void
CScopePropGeneral::ValidateLeaseTime()
{
    CString strText;

    if (IsWindow(m_editHours.GetSafeHwnd()))
    {
        m_editHours.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > HOURS_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(HOURS_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editHours.SetWindowText(strText);
            m_spinHours.SetPos(HOURS_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

    if (IsWindow(m_editMinutes.GetSafeHwnd()))
    {
        m_editMinutes.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > MINUTES_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MINUTES_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMinutes.SetWindowText(strText);
            m_spinMinutes.SetPos(MINUTES_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

}

/////////////////////////////////////////////////////////////////////////////
// CScopePropAdvanced property page

IMPLEMENT_DYNCREATE(CScopePropAdvanced, CPropertyPageBase)

CScopePropAdvanced::CScopePropAdvanced() : CPropertyPageBase(CScopePropAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CScopePropAdvanced)
	m_nRangeType = -1;
	//}}AFX_DATA_INIT
}

CScopePropAdvanced::~CScopePropAdvanced()
{
}

void CScopePropAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScopePropAdvanced)
	DDX_Control(pDX, IDC_STATIC_BOOTP_DURATION, m_staticDuration);
	DDX_Control(pDX, IDC_SPIN_LEASE_MINUTES, m_spinMinutes);
	DDX_Control(pDX, IDC_SPIN_LEASE_HOURS, m_spinHours);
	DDX_Control(pDX, IDC_SPIN_LEASE_DAYS, m_spinDays);
	DDX_Control(pDX, IDC_EDIT_LEASE_MINUTES, m_editMinutes);
	DDX_Control(pDX, IDC_EDIT_LEASE_HOURS, m_editHours);
	DDX_Control(pDX, IDC_EDIT_LEASE_DAYS, m_editDays);
	DDX_Radio(pDX, IDC_RADIO_DHCP_ONLY, m_nRangeType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopePropAdvanced, CPropertyPageBase)
	//{{AFX_MSG_MAP(CScopePropAdvanced)
	ON_BN_CLICKED(IDC_RADIO_LEASE_LIMITED, OnRadioLeaseLimited)
	ON_BN_CLICKED(IDC_RADIO_LEASE_UNLIMITED, OnRadioLeaseUnlimited)
	ON_EN_CHANGE(IDC_EDIT_LEASE_DAYS, OnChangeEditLeaseDays)
	ON_EN_CHANGE(IDC_EDIT_LEASE_HOURS, OnChangeEditLeaseHours)
	ON_EN_CHANGE(IDC_EDIT_LEASE_MINUTES, OnChangeEditLeaseMinutes)
	ON_BN_CLICKED(IDC_RADIO_BOOTP_ONLY, OnRadioBootpOnly)
	ON_BN_CLICKED(IDC_RADIO_DHCP_BOOTP, OnRadioDhcpBootp)
	ON_BN_CLICKED(IDC_RADIO_DHCP_ONLY, OnRadioDhcpOnly)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopePropAdvanced message handlers

BOOL CScopePropAdvanced::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	 
	BOOL fActivateLeaseSelection = TRUE;

	switch (m_RangeType)
	{
		case DhcpIpRangesDhcpBootp:
		    ((CButton *) GetDlgItem(IDC_RADIO_DHCP_BOOTP))->SetCheck(TRUE);
			break;

		case DhcpIpRangesBootpOnly:
		    ((CButton *) GetDlgItem(IDC_RADIO_BOOTP_ONLY))->SetCheck(TRUE);
			break;

		case DhcpIpRangesDhcpOnly:
		default:
		    ((CButton *) GetDlgItem(IDC_RADIO_DHCP_ONLY))->SetCheck(TRUE);
			fActivateLeaseSelection = FALSE;
			break;
	}

	BOOL fUnlimited = TRUE;

	if (m_dwLeaseTime != DHCP_INFINIT_LEASE)
	{
		int nDays, nHours, nMinutes;

		UtilConvertLeaseTime(m_dwLeaseTime, &nDays, &nHours, &nMinutes);

		m_spinDays.SetPos(nDays);
		m_spinHours.SetPos(nHours);
		m_spinMinutes.SetPos(nMinutes);

		fUnlimited = FALSE;
	}

	//UINT uControl = fUnlimited ? IDC_RADIO_LEASE_UNLIMITED : IDC_RADIO_LEASE_LIMITED;
	//((CButton *) GetDlgItem(uControl))->SetCheck(TRUE);
    
	//ActivateDuration(m_dwLeaseTime != DHCP_INFINIT_LEASE);

	if (fUnlimited)
	{
		((CButton *) GetDlgItem(IDC_RADIO_LEASE_UNLIMITED))->SetCheck(TRUE);
		((CButton *) GetDlgItem(IDC_RADIO_LEASE_LIMITED))->SetCheck(FALSE);
	}
	else
	{
		((CButton *) GetDlgItem(IDC_RADIO_LEASE_UNLIMITED))->SetCheck(FALSE);
		((CButton *) GetDlgItem(IDC_RADIO_LEASE_LIMITED))->SetCheck(TRUE);
	}

	m_spinMinutes.SetRange(0, 59);
	m_spinHours.SetRange(0, 23);
	m_spinDays.SetRange(0, 999);

	m_editMinutes.LimitText(2);
	m_editHours.LimitText(2);
	m_editDays.LimitText(3);

    ActivateLeaseSelection(fActivateLeaseSelection);

    SetDirty(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CScopePropAdvanced::OnApply() 
{
	UpdateData();

	DWORD dwLeaseTime;
	if (((CButton *)GetDlgItem(IDC_RADIO_LEASE_UNLIMITED))->GetCheck())
	{
		m_dwLeaseTime = DHCP_INFINIT_LEASE;
	}
	else
	{
		m_dwLeaseTime = UtilConvertLeaseTime(m_spinDays.GetPos(), 
										   m_spinHours.GetPos(),
										   m_spinMinutes.GetPos());
	}
	
	if (m_dwLeaseTime == 0)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
		DhcpMessageBox(IDS_ERR_NO_DURATION_SPECIFIED);
		m_editDays.SetFocus();
		
		return FALSE;
	}

	m_RangeType = GetRangeType();

	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

	return bRet;
}

BOOL CScopePropAdvanced::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	CDhcpScope *	pScope;
	SPITFSNode		spNode;
	DWORD			dwError = 0;	

	spNode = GetHolder()->GetNode();
	pScope = GETHANDLER(CDhcpScope, spNode);
	
	BEGIN_WAIT_CURSOR;

	dwError = pScope->SetDynamicBootpInfo(m_RangeType, m_dwLeaseTime);
	if (dwError != ERROR_SUCCESS)
	{
		GetHolder()->SetError(dwError);
	}

	END_WAIT_CURSOR;

	return FALSE;
}

UINT CScopePropAdvanced::GetRangeType() 
{
	UINT uType = DhcpIpRangesDhcpOnly;  // default

	switch (m_nRangeType)
	{
        case RADIO_SCOPE_TYPE_DHCP:
			uType = DhcpIpRangesDhcpOnly;
			break;
		case RADIO_SCOPE_TYPE_BOTH:
			uType = DhcpIpRangesDhcpBootp;
			break;
		case RADIO_SCOPE_TYPE_BOOTP:
			uType = DhcpIpRangesBootpOnly;
			break;
	}

	return uType;
}

void CScopePropAdvanced::OnRadioLeaseLimited() 
{
	if (((CButton *) GetDlgItem(IDC_RADIO_LEASE_LIMITED))->GetCheck())
	{
		ActivateDuration(TRUE);
		SetDirty(TRUE);
	}
}

void CScopePropAdvanced::OnRadioLeaseUnlimited() 
{
	if (((CButton *) GetDlgItem(IDC_RADIO_LEASE_UNLIMITED))->GetCheck())
	{
		ActivateDuration(FALSE);
		SetDirty(TRUE);
	}
}

void CScopePropAdvanced::OnChangeEditLeaseDays() 
{
    ValidateLeaseTime();
    SetDirty(TRUE);
}

void CScopePropAdvanced::OnChangeEditLeaseHours() 
{
    ValidateLeaseTime();
    SetDirty(TRUE);
}

void CScopePropAdvanced::OnChangeEditLeaseMinutes() 
{
    ValidateLeaseTime();
    SetDirty(TRUE);
}

void CScopePropAdvanced::OnRadioBootpOnly() 
{
	UpdateData();

	m_RangeType = GetRangeType();

    ActivateLeaseSelection(TRUE);
    SetDirty(TRUE);	
}

void CScopePropAdvanced::OnRadioDhcpBootp() 
{
	UpdateData();

	m_RangeType = GetRangeType();

    ActivateLeaseSelection(TRUE);
    SetDirty(TRUE);	
}

void CScopePropAdvanced::OnRadioDhcpOnly() 
{
	UpdateData();

	m_RangeType = GetRangeType();

    ActivateLeaseSelection(FALSE);
    SetDirty(TRUE);	
}

void
CScopePropAdvanced::ValidateLeaseTime()
{
    CString strText;

    if (IsWindow(m_editHours.GetSafeHwnd()))
    {
        m_editHours.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > HOURS_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(HOURS_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editHours.SetWindowText(strText);
            m_spinHours.SetPos(HOURS_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

    if (IsWindow(m_editMinutes.GetSafeHwnd()))
    {
        m_editMinutes.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > MINUTES_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MINUTES_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMinutes.SetWindowText(strText);
            m_spinMinutes.SetPos(MINUTES_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

}

void 
CScopePropAdvanced::ActivateDuration
(
	BOOL fActive
)
{
	m_spinMinutes.EnableWindow(fActive);
    m_spinHours.EnableWindow(fActive);
    m_spinDays.EnableWindow(fActive);

	m_editMinutes.EnableWindow(fActive);
    m_editHours.EnableWindow(fActive);
    m_editDays.EnableWindow(fActive);

	GetDlgItem(IDC_STATIC_DAYS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_HOURS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_MINUTES)->EnableWindow(fActive);
}   

void 
CScopePropAdvanced::ActivateLeaseSelection
(
	BOOL fActive
)
{
	BOOL fActivateDuration = FALSE;
	
	if (((CButton *) GetDlgItem(IDC_RADIO_LEASE_LIMITED))->GetCheck() &&
		!((CButton *) GetDlgItem(IDC_RADIO_DHCP_ONLY))->GetCheck())
	{
		fActivateDuration = TRUE;
	}

    m_staticDuration.EnableWindow(fActive);

    GetDlgItem(IDC_RADIO_LEASE_UNLIMITED)->EnableWindow(fActive);
    GetDlgItem(IDC_RADIO_LEASE_LIMITED)->EnableWindow(fActive);
    
    ActivateDuration(fActivateDuration);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopepp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ScopePP.
		This file contains all of the prototypes for the 
		scope property page.

    FILE HISTORY:
        
*/

#if !defined(AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if !defined _DNSPROP_H
#include "dnsprop.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CScopePropGeneral dialog

class CScopePropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CScopePropGeneral)

// Construction
public:
	CScopePropGeneral();
	~CScopePropGeneral();

// Dialog Data
	//{{AFX_DATA(CScopePropGeneral)
	enum { IDD = IDP_SCOPE_GENERAL };
	CEdit	m_editName;
	CEdit	m_editComment;
	CEdit	m_editSubnetMaskLength;
	CButton	m_radioUnlimited;
	CButton	m_radioLimited;
	CEdit	m_editMinutes;
	CEdit	m_editHours;
	CEdit	m_editDays;
	CSpinButtonCtrl	m_spinSubnetMaskLength;
	CSpinButtonCtrl	m_spinHours;
	CSpinButtonCtrl	m_spinMinutes;
	CSpinButtonCtrl	m_spinDays;
	CString	m_strComment;
	CString	m_strName;
	//}}AFX_DATA

    CWndIpAddress	m_ipaStart;       //  Start Address
    CWndIpAddress	m_ipaEnd;         //  End Address
    CWndIpAddress	m_ipaSubnetMask;  //  Subnet Mask

	DWORD			m_dwStartAddress;
	DWORD			m_dwEndAddress;
	DWORD			m_dwSubnetMask;

	DWORD			m_dwLeaseTime;

	BOOL			m_bInitialized;
	BOOL			m_bUpdateName;
	BOOL			m_bUpdateComment;
	BOOL			m_bUpdateLease;
	BOOL			m_bUpdateRange;

    UINT            m_uImage;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CScopePropGeneral::IDD); }

    void ValidateLeaseTime();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CScopePropGeneral)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CScopePropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLeaseLimited();
	afx_msg void OnRadioLeaseUnlimited();
	afx_msg void OnChangeEditLeaseDays();
	afx_msg void OnChangeEditLeaseHours();
	afx_msg void OnChangeEditLeaseMinutes();
	afx_msg void OnChangeEditSubnetMaskLength();
	afx_msg void OnKillfocusSubnetMask();
	afx_msg void OnChangeEditScopeComment();
	afx_msg void OnChangeEditScopeName();
	//}}AFX_MSG

	afx_msg void OnChangeIpAddrStart();
	afx_msg void OnChangeIpAddrEnd();
	
	DECLARE_MESSAGE_MAP()

	void ActivateDuration(BOOL fActive);
	void UpdateMask(BOOL bUseLength);

public:

};

/////////////////////////////////////////////////////////////////////////////
// CScopePropAdvanced dialog

class CScopePropAdvanced : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CScopePropAdvanced)

// Construction
public:
	CScopePropAdvanced();
	~CScopePropAdvanced();

// Dialog Data
	//{{AFX_DATA(CScopePropAdvanced)
	enum { IDD = IDP_SCOPE_ADVANCED };
	CButton	m_staticDuration;
	CSpinButtonCtrl	m_spinMinutes;
	CSpinButtonCtrl	m_spinHours;
	CSpinButtonCtrl	m_spinDays;
	CEdit	m_editMinutes;
	CEdit	m_editHours;
	CEdit	m_editDays;
	int		m_nRangeType;
	//}}AFX_DATA

	UINT	m_RangeType;
	DWORD	m_dwLeaseTime;

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CScopePropAdvanced::IDD); }
	
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CScopePropAdvanced)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

	UINT	GetRangeType();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CScopePropAdvanced)
	afx_msg void OnRadioLeaseLimited();
	afx_msg void OnRadioLeaseUnlimited();
	afx_msg void OnChangeEditLeaseDays();
	afx_msg void OnChangeEditLeaseHours();
	afx_msg void OnChangeEditLeaseMinutes();
	afx_msg void OnRadioBootpOnly();
	afx_msg void OnRadioDhcpBootp();
	afx_msg void OnRadioDhcpOnly();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ActivateDuration(BOOL fActive);
	void ActivateLeaseSelection(BOOL fActive);
    void ValidateLeaseTime();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CScopeProperties : public CPropertyPageHolderBase
{
	friend class CScopePropGeneral;

public:
	CScopeProperties(ITFSNode *			 pNode,
					 IComponentData *	 pComponentData,
					 ITFSComponentData * pTFSCompData,
					 LPCTSTR			 pszSheetName);
	virtual ~CScopeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetVersion(LARGE_INTEGER & liVersion);
	void SetDnsRegistration(DWORD dnsRegOption, DHCP_OPTION_SCOPE_TYPE dhcpOptionType);
	void SetSupportsDynBootp(BOOL fSupportsDynBootp);
	BOOL FSupportsDynBootp() { return m_fSupportsDynBootp; }

public:
	CScopePropGeneral			m_pageGeneral;
    CScopePropAdvanced          m_pageAdvanced;
    CDnsPropRegistration		m_pageDns;

protected:
	SPITFSComponentData			m_spTFSCompData;

	LARGE_INTEGER				m_liVersion;
	BOOL						m_fSupportsDynBootp;
};


#endif // !defined(AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scope.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        scope.cpp
                This file contains all of the implementation for the DHCP
                scope object and all objects that it may contain.  
                They include:

                        CDhcpScope
                        CDhcpReservations
                        CDhcpReservationClient
                        CDhcpActiveLeases
                        CDhcpAddressPool
                        CDhcpScopeOptions

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"             // server object
#include "scope.h"              // scope object
#include "scopepp.h"    // scope property page
#include "addbootp.h"   // add BOOTP entry dialog
#include "addexcl.h"    // add exclusion range dialog
#include "addres.h"             // add reservation dialog
#include "rclntpp.h"    // reserved client property page
#include "nodes.h"              // all node (result pane) definitions
#include "optcfg.h"             // option configuration sheet
#include "dlgrecon.h"   // reconcile database dialog
#include "scopstat.h"   // scope statistics
#include "addtoss.h"    // add scope to superscope dialog

WORD gwUnicodeHeader = 0xFEFF;

// scope options result pane message stuff
#define SCOPE_OPTIONS_MESSAGE_MAX_STRING  5
typedef enum _SCOPE_OPTIONS_MESSAGES
{
    SCOPE_OPTIONS_MESSAGE_NO_OPTIONS,
    SCOPE_OPTIONS_MESSAGE_MAX
};

UINT g_uScopeOptionsMessages[SCOPE_OPTIONS_MESSAGE_MAX][SCOPE_OPTIONS_MESSAGE_MAX_STRING] =
{
    {IDS_SCOPE_OPTIONS_MESSAGE_TITLE, Icon_Information, IDS_SCOPE_OPTIONS_MESSAGE_BODY, 0, 0}
};

// reservation options result pane message stuff
#define RES_OPTIONS_MESSAGE_MAX_STRING  5
typedef enum _RES_OPTIONS_MESSAGES
{
    RES_OPTIONS_MESSAGE_NO_OPTIONS,
    RES_OPTIONS_MESSAGE_MAX
};

UINT g_uResOptionsMessages[RES_OPTIONS_MESSAGE_MAX][RES_OPTIONS_MESSAGE_MAX_STRING] =
{
    {IDS_RES_OPTIONS_MESSAGE_TITLE, Icon_Information, IDS_RES_OPTIONS_MESSAGE_BODY, 0, 0}
};

// reservations result pane message stuff
#define RESERVATIONS_MESSAGE_MAX_STRING  5
typedef enum _RESERVATIONS_MESSAGES
{
    RESERVATIONS_MESSAGE_NO_RES,
    RESERVATIONS_MESSAGE_MAX
};

UINT g_uReservationsMessages[RESERVATIONS_MESSAGE_MAX][RESERVATIONS_MESSAGE_MAX_STRING] =
{
    {IDS_RESERVATIONS_MESSAGE_TITLE, Icon_Information, IDS_RESERVATIONS_MESSAGE_BODY, 0, 0}
};



/*---------------------------------------------------------------------------
        Class CDhcpScope implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScope::CDhcpScope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpScope::CDhcpScope
(
        ITFSComponentData * pComponentData,
        DHCP_IP_ADDRESS         dhcpScopeIp,
        DHCP_IP_MASK            dhcpSubnetMask,
        LPCWSTR                         pName,
        LPCWSTR                         pComment,
        DHCP_SUBNET_STATE       dhcpSubnetState
) : CMTDhcpHandler(pComponentData)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // save off some parameters
        //
        m_dhcpIpAddress = dhcpScopeIp;
        m_dhcpSubnetMask = dhcpSubnetMask;
        m_strName = pName;
        m_strComment = pComment;
        m_dhcpSubnetState = dhcpSubnetState;
    m_bInSuperscope = FALSE;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpScope::CDhcpScope
(
        ITFSComponentData * pComponentData,
        LPDHCP_SUBNET_INFO      pdhcpSubnetInfo
) : CMTDhcpHandler(pComponentData)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // save off some parameters
        //
        m_dhcpIpAddress = pdhcpSubnetInfo->SubnetAddress;
        m_dhcpSubnetMask = pdhcpSubnetInfo->SubnetMask;
        m_strName = pdhcpSubnetInfo->SubnetName;
        m_strComment = pdhcpSubnetInfo->SubnetComment;
        m_dhcpSubnetState = pdhcpSubnetInfo->SubnetState;
    m_bInSuperscope = FALSE;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpScope::CDhcpScope
(
        ITFSComponentData * pComponentData,
        CSubnetInfo &       subnetInfo
) : CMTDhcpHandler(pComponentData)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // save off some parameters
        //
        m_dhcpIpAddress = subnetInfo.SubnetAddress;
        m_dhcpSubnetMask = subnetInfo.SubnetMask;
        m_strName = subnetInfo.SubnetName;
        m_strComment = subnetInfo.SubnetComment;
        m_dhcpSubnetState = subnetInfo.SubnetState;
    m_bInSuperscope = FALSE;
}

CDhcpScope::~CDhcpScope()
{
}


/*!--------------------------------------------------------------------------
        CDhcpScope::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;
        int nImage;

        //
        // Create the display name for this scope
        //
        CString strDisplay, strIpAddress;

        UtilCvtIpAddrToWstr (m_dhcpIpAddress,
                                                 &strIpAddress);
        
        BuildDisplayName(&strDisplay, strIpAddress, m_strName);

        SetDisplayName(strDisplay);
        
        //
        // Figure out the correct icon
        //
    if ( !IsEnabled() ) 
    {
        m_strState.LoadString(IDS_SCOPE_INACTIVE);
    }
    else
    {
        m_strState.LoadString(IDS_SCOPE_ACTIVE);
    }
    
    // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_SCOPE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_SCOPE][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_SCOPE][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::DestroyHandler
                We need to free up any resources we are holding
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScope::DestroyHandler(ITFSNode *pNode)
{
        // cleanup the stats dialog
    WaitForStatisticsWindow(&m_dlgStats);

    return CMTDhcpHandler::DestroyHandler(pNode);
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpScope::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();
    CString strIpAddress, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    UtilCvtIpAddrToWstr (m_dhcpIpAddress, &strIpAddress);

    strId = GetServerObject()->GetName() + strIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpScope::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;

    switch (m_nState)
    {
        // TODO: these need to be updated with new busy state icons
        case loading:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_OPEN_BUSY : ICON_IDX_SCOPE_FOLDER_OPEN_BUSY;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY : ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY;
            return nIndex;

        case notLoaded:
        case loaded:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_OPEN : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_CLOSED : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED;
            break;

        case unableToLoad:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION;
            return nIndex;

        default:
                        ASSERT(FALSE);
    }

    // only calcualte alert/warnings if the scope is enabled.
        if (m_spServerNode && IsEnabled())
    {
        CDhcpServer * pServer = GetServerObject();
        LPDHCP_MIB_INFO pMibInfo = pServer->DuplicateMibInfo();
            
        if (!pMibInfo)
            return nIndex;

        LPSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

            // walk the list of scopes and find our info
            for (UINT i = 0; i < pMibInfo->Scopes; i++)
            {
                    // Find our scope stats
                    if (pScopeMibInfo[i].Subnet == m_dhcpIpAddress)
                    {
                            int nPercentInUse;
                
                if ((pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree) == 0)
                    nPercentInUse = 0;
                else
                    nPercentInUse = (pScopeMibInfo[i].NumAddressesInuse * 100) / (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
        
                            // look to see if this scope meets the warning or red flag case
                            if (pScopeMibInfo[i].NumAddressesFree == 0)
                            {
                                    // red flag case, no addresses free, this is the highest
                                    // level of warning, so break out of the loop if we set this.
                    if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_FOLDER_OPEN_ALERT;
                    else
                        nIndex = ICON_IDX_SCOPE_FOLDER_CLOSED_ALERT;
                                    break;
                            }
                            else
                            if (nPercentInUse >= SCOPE_WARNING_LEVEL)
                            {
                                    // warning condition if Num Addresses in use is greater than
                                    // some pre-defined threshold.
                    if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_FOLDER_OPEN_WARNING;
                    else
                        nIndex = ICON_IDX_SCOPE_FOLDER_CLOSED_WARNING;
                            }

                            break;
                    }
            }

            pServer->FreeDupMibInfo(pMibInfo);
    }

    return nIndex;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScope::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScope::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // Get the version of the server
        LONG fFlags = 0;
    LARGE_INTEGER liDhcpVersion;
        CDhcpServer * pServer = GetServerObject();
        pServer->GetVersion(liDhcpVersion);

        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

    if (type == CCT_SCOPE)
        {
                //
                // these menu items go in the new menu, 
                // only visible from scope pane
                //
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuText.LoadString(IDS_SCOPE_SHOW_STATISTICS);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_SCOPE_SHOW_STATISTICS,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );

            // separator
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );

                    // reconcile is only supports for NT4 SP2 and greater.
                    if (liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
                    {
                            strMenuText.LoadString(IDS_SCOPE_RECONCILE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuText, 
                                                                             IDS_SCOPE_RECONCILE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }

                    // Superscope support only on NT4 SP2 and greater
                    if (liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
                    {
                            int nID = 0;

                if (IsInSuperscope())
                {
                    nID = IDS_SCOPE_REMOVE_SUPERSCOPE;
                }
                else
                {
                    // check to see if there are superscopes to add to
                    SPITFSNode spNode;
                    pNode->GetParent(&spNode);

                    pServer = GETHANDLER(CDhcpServer, spNode);

                    if (pServer->HasSuperscopes(spNode))
                        nID = IDS_SCOPE_ADD_SUPERSCOPE;
                }
            
                // load the menu item if we need to
                if (nID)
                {
                    strMenuText.LoadString(nID);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                                 strMenuText, 
                                                                                 nID,
                                                                                 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                                 fFlags );
                                ASSERT( SUCCEEDED(hr) );
                }
                    }

            // separator
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );

            // activate/deactivate
            if ( !IsEnabled() ) 
                    {
                            strMenuText.LoadString(IDS_SCOPE_ACTIVATE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuText, 
                                                                             IDS_SCOPE_ACTIVATE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }
                    else
                    {
                            strMenuText.LoadString(IDS_SCOPE_DEACTIVATE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuText, 
                                                                             IDS_SCOPE_DEACTIVATE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }
        }
    }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScope::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
        case IDS_ACTIVATE:
        case IDS_DEACTIVATE:
        case IDS_SCOPE_ACTIVATE:
                case IDS_SCOPE_DEACTIVATE:
                        OnActivateScope(pNode);
                        break;
                
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                case IDS_SCOPE_SHOW_STATISTICS:
                        OnShowScopeStats(pNode);
                        break;

                case IDS_SCOPE_RECONCILE:
                        OnReconcileScope(pNode);
                        break;

                case IDS_DELETE:
                        OnDelete(pNode);
                        break;

                case IDS_SCOPE_ADD_SUPERSCOPE:
                        OnAddToSuperscope(pNode);
                        break;

                case IDS_SCOPE_REMOVE_SUPERSCOPE:
                        OnRemoveFromSuperscope(pNode);
                        break;

        default:
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScope::OnDelete
                The base handler calls this when MMC sends a MMCN_DELETE for a 
                scope pane item.  We just call our delete command handler.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScope::OnDelete
(
        ITFSNode *      pNode, 
        LPARAM          arg, 
        LPARAM          lParam
)
{
        return OnDelete(pNode);
}

/*!--------------------------------------------------------------------------
        CDhcpScope::HasPropertyPages
                Says whether or not this handler has property pages
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScope::HasPropertyPages
(
        ITFSNode *                      pNode,
        LPDATAOBJECT            pDataObject, 
        DATA_OBJECT_TYPES   type, 
        DWORD               dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        HRESULT hr = hrOK;
        
        if (dwType & TFS_COMPDATA_CREATE)
        {
                // This is the case where we are asked to bring up property
                // pages when the user is adding a new snapin.  These calls
                // are forwarded to the root node to handle.
                // Should never get here!!
                Assert(FALSE);
                hr = S_FALSE;
        }
        else
        {
                // we have property pages in the normal case
                hr = hrOK;
        }
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScope::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT             hr = hrOK;
    DWORD               dwError;
        DWORD                       dwDynDnsFlags;
        SPIComponentData    spComponentData;
        LARGE_INTEGER       liVersion;
    CDhcpServer *       pServer;
        CDhcpIpRange        dhcpIpRange;

    //
        // Create the property page
    //
        m_spNodeMgr->GetComponentData(&spComponentData);

        CScopeProperties * pScopeProp = 
                new CScopeProperties(pNode, spComponentData, m_spTFSCompData, NULL);
        
        // Get the Server version and set it in the property sheet
        pServer = GetServerObject();
        pServer->GetVersion(liVersion);

        pScopeProp->SetVersion(liVersion);
        pScopeProp->SetSupportsDynBootp(pServer->FSupportsDynBootp());

        // Set scope specific data in the prop sheet
        pScopeProp->m_pageGeneral.m_strName = m_strName;
        pScopeProp->m_pageGeneral.m_strComment = m_strComment;

        BEGIN_WAIT_CURSOR;

        dwError = GetIpRange(&dhcpIpRange);
    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        return hrFalse;
    }

        pScopeProp->m_pageGeneral.m_dwStartAddress = dhcpIpRange.QueryAddr(TRUE);
        pScopeProp->m_pageGeneral.m_dwEndAddress = dhcpIpRange.QueryAddr(FALSE);
        pScopeProp->m_pageGeneral.m_dwSubnetMask = m_dhcpSubnetMask;
        pScopeProp->m_pageGeneral.m_uImage = GetImageIndex(FALSE);
        pScopeProp->m_pageAdvanced.m_RangeType = dhcpIpRange.GetRangeType();

    GetLeaseTime(&pScopeProp->m_pageGeneral.m_dwLeaseTime);
    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        return hrFalse;
    }
    
        if (pServer->FSupportsDynBootp())
        {
                GetDynBootpLeaseTime(&pScopeProp->m_pageAdvanced.m_dwLeaseTime);
                if (dwError != ERROR_SUCCESS)
                {
                        ::DhcpMessageBox(dwError);
                        return hrFalse;
                }
        }

        // set the DNS registration option
    dwError = GetDnsRegistration(&dwDynDnsFlags);
    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        return hrFalse;
    }
    END_WAIT_CURSOR;
        
        pScopeProp->SetDnsRegistration(dwDynDnsFlags, DhcpSubnetOptions);

        //
        // Object gets deleted when the page is destroyed
        //
        Assert(lpProvider != NULL);

        return pScopeProp->CreateModelessSheet(lpProvider, handle);
}

/*!--------------------------------------------------------------------------
        CDhcpScope::GetString
                Returns string information for display in the result pane columns
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpScope::GetString
(
    ITFSNode *  pNode,
    int         nCol
)
{
        switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
            return m_strState;

        case 2:
            return m_strComment;
        }
        
        return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScope::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CScopeProperties * pScopeProp = reinterpret_cast<CScopeProperties *>(lParam);

        LONG_PTR changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pScopeProp->OnPropertyChange(TRUE, &changeMask);

        pScopeProp->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpScope::OnUpdateToolbarButtons
                We override this function to show/hide the correct
        activate/deactivate buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        UpdateToolbarStates();
    }

    CMTDhcpHandler::OnUpdateToolbarButtons(pNode, pToolbarNotify);

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScope::UpdateToolbarStates
            Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpScope::UpdateToolbarStates()
{
        if ( !IsEnabled() ) 
        {
        g_SnapinButtonStates[DHCPSNAP_SCOPE][TOOLBAR_IDX_ACTIVATE] = ENABLED;
        g_SnapinButtonStates[DHCPSNAP_SCOPE][TOOLBAR_IDX_DEACTIVATE] = HIDDEN;
    }
    else
    {
        g_SnapinButtonStates[DHCPSNAP_SCOPE][TOOLBAR_IDX_ACTIVATE] = HIDDEN;
        g_SnapinButtonStates[DHCPSNAP_SCOPE][TOOLBAR_IDX_DEACTIVATE] = ENABLED;
    }
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScope:OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpScope::OnHaveData
(
        ITFSNode * pParentNode, 
        ITFSNode * pNewNode
)
{
        if (pNewNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ACTIVE_LEASES)
        {
        pParentNode->AddChild(pNewNode);
        m_spActiveLeases.Set(pNewNode);
        }
    else
        if (pNewNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ADDRESS_POOL)
        {
        pParentNode->AddChild(pNewNode);
        m_spAddressPool.Set(pNewNode);
        }
    else
        if (pNewNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_RESERVATIONS)
        {
        pParentNode->AddChild(pNewNode);
        m_spReservations.Set(pNewNode);
        }
    else
        if (pNewNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE_OPTIONS)
        {
        pParentNode->AddChild(pNewNode);
        m_spOptions.Set(pNewNode);
        }

    // now tell the view to update themselves
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpScope::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        // This is how we get non-node data back from the background thread.

    switch (Type)
    {
        case DHCP_QDATA_SUBNET_INFO:
        {
            LONG_PTR changeMask = 0;
            LPDHCP_SUBNET_INFO pdhcpSubnetInfo = reinterpret_cast<LPDHCP_SUBNET_INFO>(Data);

            // update the scope name and state based on the info
            if (m_strName.CompareNoCase(pdhcpSubnetInfo->SubnetName) != 0)
            {
                    CString strDisplay, strIpAddress;

                    m_strName = pdhcpSubnetInfo->SubnetName;
                UtilCvtIpAddrToWstr (m_dhcpIpAddress,
                                                             &strIpAddress);
                    
                    BuildDisplayName(&strDisplay, strIpAddress, m_strName);

                    SetDisplayName(strDisplay);

                changeMask = SCOPE_PANE_CHANGE_ITEM;
            }

            if (m_dhcpSubnetState != pdhcpSubnetInfo->SubnetState)
            {
                DHCP_SUBNET_STATE dhcpOldState = m_dhcpSubnetState;
        
                m_dhcpSubnetState = pdhcpSubnetInfo->SubnetState;

                    // Tell the scope to update it's state
                    DWORD err = SetInfo();
                    if (err != 0)
                    {
                            ::DhcpMessageBox(err);
                            m_dhcpSubnetState = dhcpOldState;
                    }
                    else
                    {
                            pParentNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
                            pParentNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
                            
                    // Update the toolbar button
                    UpdateToolbarStates();
                    SendUpdateToolbar(pParentNode, TRUE);

                    // need to notify the owning superscope to update it's state information
                    // this is strictly for UI purposes only.
                    if (IsInSuperscope())
                    {
                        SPITFSNode spSuperscopeNode;
                        pParentNode->GetParent(&spSuperscopeNode);

                        CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spSuperscopeNode);
                        Assert(pSuperscope);

                        pSuperscope->NotifyScopeStateChange(spSuperscopeNode, m_dhcpSubnetState);
                    }
        
                    changeMask = SCOPE_PANE_CHANGE_ITEM;
                }
            }

            if (pdhcpSubnetInfo)
                ::DhcpRpcFreeMemory(pdhcpSubnetInfo);

            if (changeMask)
                VERIFY(SUCCEEDED(pParentNode->ChangeNode(changeMask)));
        }
        break;

        case DHCP_QDATA_OPTION_VALUES:
        {
            COptionValueEnum * pOptionValueEnum = reinterpret_cast<COptionValueEnum *>(Data);

            SetOptionValueEnum(pOptionValueEnum);
            
            pOptionValueEnum->RemoveAll();
            delete pOptionValueEnum;
    
            break;
        }

        default:
            break;
    }
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpScope::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpScopeQueryObj* pQuery = 
                new CDhcpScopeQueryObj(m_spTFSCompData, m_spNodeMgr);
        
        pQuery->m_strServer = GetServerIpAddress();
        pQuery->m_dhcpScopeAddress = GetAddress();

    GetServerVersion(pQuery->m_liVersion);

        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpScope::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpScopeQueryObj::Execute()
{
    HRESULT                 hr = hrOK;
    DWORD                   dwReturn;
    LPDHCP_SUBNET_INFO      pdhcpSubnetInfo = NULL;
    DHCP_OPTION_SCOPE_INFO  dhcpOptionScopeInfo;
    COptionValueEnum *      pOptionValueEnum = NULL;

    dwReturn = ::DhcpGetSubnetInfo(((LPWSTR) (LPCTSTR)m_strServer),
                                                                   m_dhcpScopeAddress,
                                                                   &pdhcpSubnetInfo);

        if (dwReturn == ERROR_SUCCESS && pdhcpSubnetInfo)
    {
        AddToQueue((LPARAM) pdhcpSubnetInfo, DHCP_QDATA_SUBNET_INFO);
    }
    else
    {
        Trace1("CDhcpScopeQueryObj::Execute - DhcpGetSubnetInfo failed! %d\n", dwReturn);
        PostError(dwReturn);
        return hrFalse;
    }

    // get the option info for this scope
    pOptionValueEnum = new COptionValueEnum();

        dhcpOptionScopeInfo.ScopeType = DhcpSubnetOptions;
        dhcpOptionScopeInfo.ScopeInfo.SubnetScopeInfo = m_dhcpScopeAddress;

    pOptionValueEnum->Init(m_strServer, m_liVersion, dhcpOptionScopeInfo);
    dwReturn = pOptionValueEnum->Enum();
    if (dwReturn != ERROR_SUCCESS)
    {
        Trace1("CDhcpScopeQueryObj::Execute - EnumOptions Failed! %d\n", dwReturn);
        m_dwErr = dwReturn;
        PostError(dwReturn);

        delete pOptionValueEnum;
    }
    else
    {
        pOptionValueEnum->SortById();
        AddToQueue((LPARAM) pOptionValueEnum, DHCP_QDATA_OPTION_VALUES);
    }

    // now create the scope subcontainers
    CreateSubcontainers();
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpScope::CreateSubcontainers()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeQueryObj::CreateSubcontainers()
{
        HRESULT hr = hrOK;
    SPITFSNode spNode;

        //
        // create the address pool Handler
        //
        CDhcpAddressPool *pAddressPool = new CDhcpAddressPool(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpAddressPoolNodeType,
                                                   pAddressPool,
                                                   pAddressPool,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pAddressPool->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
    pAddressPool->Release();

    spNode.Set(NULL);

        //
        // create the Active Leases Handler
        //
        CDhcpActiveLeases *pActiveLeases = new CDhcpActiveLeases(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpActiveLeasesNodeType,
                                                   pActiveLeases,
                                                   pActiveLeases,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pActiveLeases->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
        pActiveLeases->Release();

    spNode.Set(NULL);

    //
        // create the reservations Handler
        //
        CDhcpReservations *pReservations = new CDhcpReservations(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpReservationsNodeType,
                                                   pReservations,
                                                   pReservations,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pReservations->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
        pReservations->Release();

    spNode.Set(NULL);

    //
        // create the Scope Options Handler
        //
        CDhcpScopeOptions *pScopeOptions = new CDhcpScopeOptions(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpScopeOptionsNodeType,
                                                   pScopeOptions,
                                                   pScopeOptions,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pScopeOptions->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
        pScopeOptions->Release();

    return hr;
}


/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScope::OnActivateScope
                Message handler for the scope activate/deactivate menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::OnActivateScope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DWORD               err = 0;
        int                 nOpenImage, nClosedImage;
        DHCP_SUBNET_STATE   dhcpOldState = m_dhcpSubnetState;
        
    if ( IsEnabled() ) 
    {
        // if they want to disable the scope, confirm
        if (AfxMessageBox(IDS_SCOPE_DISABLE_CONFIRM, MB_YESNO) != IDYES)
        {
            return err;
        }
    }

    SetState(
        IsEnabled()? DhcpSubnetDisabled : DhcpSubnetEnabled );

        // Tell the scope to update it's state
        err = SetInfo();
        if (err != 0)
        {
                ::DhcpMessageBox(err);
                m_dhcpSubnetState = dhcpOldState;
        }
        else
        {
        // update the icon and the status text
        if ( !IsEnabled() ) 
        {
            nOpenImage = ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN;
            nClosedImage = ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED;
            m_strState.LoadString(IDS_SCOPE_INACTIVE);
        }
        else
        {
            nOpenImage = GetImageIndex(TRUE);
            nClosedImage = GetImageIndex(FALSE);
            m_strState.LoadString(IDS_SCOPE_ACTIVE);
        }

                pNode->SetData(TFS_DATA_IMAGEINDEX, nClosedImage);
                pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
                
        VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));

        // Update the toolbar button
        UpdateToolbarStates();
        SendUpdateToolbar(pNode, TRUE);

        // need to notify the owning superscope to update it's state information
        // this is strictly for UI purposes only.
        if (IsInSuperscope())
        {
            SPITFSNode spSuperscopeNode;
            pNode->GetParent(&spSuperscopeNode);

            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spSuperscopeNode);
            Assert(pSuperscope);

            pSuperscope->NotifyScopeStateChange(spSuperscopeNode, m_dhcpSubnetState);
        }
        }

    TriggerStatsRefresh();

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnRefreshScope
                Refreshes all of the subnodes of the scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnRefreshScope
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType
)
{
        HRESULT hr = hrOK;

        CDhcpReservations * pReservations = GetReservationsObject();
        CDhcpActiveLeases * pActiveLeases = GetActiveLeasesObject();
        CDhcpAddressPool  * pAddressPool = GetAddressPoolObject();
        CDhcpScopeOptions * pScopeOptions = GetScopeOptionsObject();

        Assert(pReservations);
        Assert(pActiveLeases);
        Assert(pAddressPool);
        Assert(pScopeOptions);
        
        if (pReservations)
                pReservations->OnRefresh(m_spReservations, pDataObject, dwType, 0, 0);

        if (pActiveLeases)
                pActiveLeases->OnRefresh(m_spActiveLeases, pDataObject, dwType, 0, 0);
        
        if (pAddressPool)
                pAddressPool->OnRefresh(m_spAddressPool, pDataObject, dwType, 0, 0);
        
        if (pScopeOptions)
                pScopeOptions->OnRefresh(m_spOptions, pDataObject, dwType, 0, 0);

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnReconcileScope
                Reconciles the active leases database for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnReconcileScope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CReconcileDlg dlgRecon(pNode);
        
        dlgRecon.DoModal();

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnShowScopeStats()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnShowScopeStats
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;
    CString strScopeAddress;

    // Fill in some information in the stats object.
    // CreateNewStatisticsWindow handles the case if the window is 
    // already visible.
    m_dlgStats.SetNode(pNode);
    m_dlgStats.SetServer(GetServerIpAddress());
    m_dlgStats.SetScope(m_dhcpIpAddress);
        
        CreateNewStatisticsWindow(&m_dlgStats,
                                                          ::FindMMCMainWindow(),
                                                          IDD_STATS_NARROW);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnDelete()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = S_OK;
    SPITFSNode  spServer;
    SPITFSNode  spSuperscopeNode;
    int         nVisible = 0, nTotal = 0;
    int         nResponse;

    LONG        err = 0 ;
    
    if (IsInSuperscope())
    {
        pNode->GetParent(&spSuperscopeNode);
        
        spSuperscopeNode->GetChildCount(&nVisible, &nTotal);
    }

    if (nTotal == 1)
    {
        // warn the user that this is the last scope in the superscope
        // and the superscope will be removed.
        nResponse = AfxMessageBox(IDS_DELETE_LAST_SCOPE_FROM_SS, MB_YESNO);
    }
    else
    {
        nResponse = ::DhcpMessageBox( IsEnabled() ?
                                      IDS_MSG_DELETE_ACTIVE : IDS_MSG_DELETE_SCOPE, 
                                      MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION);
    }
    
    if (nResponse == IDYES)
    {
        SPITFSNode spTemp;
        
        if (IsInSuperscope())
        {
            // superscope
            spTemp.Set(spSuperscopeNode);
        }
        else
        {
            spTemp.Set(pNode);
        }

        spTemp->GetParent(&spServer);

        CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServer);
        err = pServer->DeleteScope(pNode);
        
        if (err == ERROR_SUCCESS &&
            nTotal == 1)
        {
            // gotta remove the superscope
            spServer->RemoveChild(spSuperscopeNode);
        }
    }

    // trigger the statistics to refresh only if we removed this scope
    if (spServer)
    {
        TriggerStatsRefresh();
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnAddToSuperscope()
                Adds this scope to a superscope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnAddToSuperscope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CString strTitle, strAddress;
    UtilCvtIpAddrToWstr(m_dhcpIpAddress, &strAddress);

    AfxFormatString1(strTitle, IDS_ADD_SCOPE_DLG_TITLE, strAddress);

    CAddScopeToSuperscope dlgAddScope(pNode, strTitle);

    dlgAddScope.DoModal();

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScope::OnRemoveFromSuperscope()
                Removes this scope from a superscope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::OnRemoveFromSuperscope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    int nVisible, nTotal, nResponse;
    SPITFSNode spSuperscopeNode;
    
    pNode->GetParent(&spSuperscopeNode);

    spSuperscopeNode->GetChildCount(&nVisible, &nTotal);
    if (nTotal == 1)
    {
        // warn the user that this is the last scope in the superscope
        // and the superscope will be removed.
        nResponse = AfxMessageBox(IDS_REMOVE_LAST_SCOPE_FROM_SS, MB_YESNO);
    }
    else
    {
        nResponse = AfxMessageBox(IDS_REMOVE_SCOPE_FROM_SS, MB_YESNO);
    }

    if (nResponse == IDYES)
    {
        // set the superscope for this scope to be NULL 
        // effectively removing it from the scope.
        DWORD dwError = SetSuperscope(NULL, TRUE);
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return hrFalse;
        }

        // now move the scope out of the supersope in the UI
        spSuperscopeNode->ExtractChild(pNode);

        // now put the scope node back in at the server level.
        SPITFSNode spServerNode;
        spSuperscopeNode->GetParent(&spServerNode);

        CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);
        pServer->AddScopeSorted(spServerNode, pNode);

        SetInSuperscope(FALSE);

        if (nTotal == 1)
        {
            // now delete the superscope.
            spServerNode->RemoveChild(spSuperscopeNode);
        }
    }

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScope::UpdateStatistics
        Notification that stats are now available.  Update stats for the 
        node and give all subnodes a chance to update.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::UpdateStatistics
(
    ITFSNode * pNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned;
    HWND            hStatsWnd;
        BOOL                    bChangeIcon = FALSE;

    // Check to see if this node has a stats sheet up.
    hStatsWnd = m_dlgStats.GetSafeHwnd();
    if (hStatsWnd != NULL)
    {
        PostMessage(hStatsWnd, WM_NEW_STATS_AVAILABLE, 0, 0);
    }
    
        if (!IsEnabled())
        return hr;

    // check to see if the image index has changed and only
    // switch it if we have to--this avoids flickering.
    LONG_PTR nOldIndex = pNode->GetData(TFS_DATA_IMAGEINDEX);
    int nNewIndex = GetImageIndex(FALSE);

    if (nOldIndex != nNewIndex)
    {
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON);
    }

    return hr;
}

/*---------------------------------------------------------------------------
        Scope manipulation functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScope::SetState
                Sets the state for this scope - updates cached information and
        display string
        Author: EricDav
 ---------------------------------------------------------------------------*/
void  
CDhcpScope::SetState
(
    DHCP_SUBNET_STATE dhcpSubnetState
)
{ 
    BOOL fSwitched = FALSE;

    if( m_dhcpSubnetState != DhcpSubnetEnabled &&
        m_dhcpSubnetState != DhcpSubnetDisabled ) {
        fSwitched = TRUE;
    }

    if( fSwitched ) {
        if( dhcpSubnetState == DhcpSubnetEnabled ) {
            dhcpSubnetState = DhcpSubnetEnabledSwitched;
        } else {
            dhcpSubnetState = DhcpSubnetDisabledSwitched;
        }
    }
    
    m_dhcpSubnetState = dhcpSubnetState; 

    // update the status text
    if ( !IsEnabled() )
    {
        m_strState.LoadString(IDS_SCOPE_INACTIVE);
    }
    else
    {
        m_strState.LoadString(IDS_SCOPE_ACTIVE);
    }
}

/*---------------------------------------------------------------------------
        CDhcpScope::CreateReservation
                Creates a reservation for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::CreateReservation
(
        const CDhcpClient * pClient
)
{
        SPITFSNode spResClientNode, spActiveLeaseNode;
        DWORD err = 0;

        //
        // Tell the DHCP server to create this client
        //
        err = CreateClient(pClient);
        if (err != 0)
                return err;

        //
        // Now that we have this reservation on the server, create the UI object
        // in both the reservation folder and the ActiveLeases folder

        //
        // create the Reservation client folder
        //
        CDhcpReservations * pRes = GETHANDLER(CDhcpReservations, m_spReservations);
    CDhcpActiveLeases * pActLeases = GETHANDLER(CDhcpActiveLeases, m_spActiveLeases);

    // only add to the UI if the node is expanded.  MMC will fail the call if
    // we try to add a child to a node that hasn't been expanded.  If we don't add
    // it now, it will be enumerated when the user selects the node.
    if (pRes->m_bExpanded)
    {
        CDhcpReservationClient * pNewResClient = 
                            new CDhcpReservationClient(m_spTFSCompData, (CDhcpClient&) *pClient);
            
            CreateContainerTFSNode(&spResClientNode,
                                                       &GUID_DhcpReservationClientNodeType,
                                                       pNewResClient,
                                                       pNewResClient,
                                                       m_spNodeMgr);

            // Tell the handler to initialize any specific data
            pNewResClient->InitializeNode((ITFSNode *) spResClientNode);

            // Add the node as a child to this node
            CDhcpReservations * pReservations = GETHANDLER(CDhcpReservations, m_spReservations);
        pReservations->AddReservationSorted(m_spReservations, spResClientNode);
            pNewResClient->Release();
    }

        //
        // Active Lease record
        //
    if (pActLeases->m_bExpanded)
    {
        CDhcpActiveLease * pNewLease = 
                        new CDhcpActiveLease(m_spTFSCompData, (CDhcpClient&) *pClient);

            CreateLeafTFSNode(&spActiveLeaseNode,
                                              &GUID_DhcpActiveLeaseNodeType,
                                              pNewLease, 
                                              pNewLease,
                                              m_spNodeMgr);

            // Tell the handler to initialize any specific data
            pNewLease->InitializeNode((ITFSNode *) spActiveLeaseNode);

            // Add the node as a child to the Active Leases container
            m_spActiveLeases->AddChild(spActiveLeaseNode);
            pNewLease->Release();
    }

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::UpdateReservation
                Creates a reservation for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::UpdateReservation
(
        const CDhcpClient * pClient,
        COptionValueEnum *  pOptionValueEnum
)
{
        DWORD err = 0;
        const CByteArray & baHardwareAddress = pClient->QueryHardwareAddress();
    SPITFSNode spResClientNode, spActiveLeaseNode;
    
        //
        // To update a reservation we need to remove the old one and update it
        // with the new information.  This is mostly for the client type field.
    //
    err = DeleteReservation((CByteArray&) baHardwareAddress,
                                pClient->QueryIpAddress());
        
    // now add the updated one
    err = AddReservation(pClient);
    if (err != ERROR_SUCCESS)
        return err;

        // restore the options for this reserved client
        err = RestoreReservationOptions(pClient, pOptionValueEnum);
    if (err != ERROR_SUCCESS)
        return err;
    
        // Now update the client info record associated with this.
    err = SetClientInfo(pClient);

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::RestoreReservationOptions
                Restores options when updating a reservation becuase the only
                way to update the reservation is to remove it and re-add it.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::RestoreReservationOptions
(
        const CDhcpClient * pClient,
        COptionValueEnum *  pOptionValueEnum
)
{
        DWORD                   dwErr = ERROR_SUCCESS;
        CDhcpOption *   pCurOption;
    LARGE_INTEGER       liVersion;

    GetServerVersion(liVersion);

        // start at the top of the list
        pOptionValueEnum->Reset();

        // loop through all the options, re-adding them
        while (pCurOption = pOptionValueEnum->Next())
        {
                CDhcpOptionValue optValue = pCurOption->QueryValue();
                DHCP_OPTION_DATA * pOptData;

                dwErr = optValue.CreateOptionDataStruct(&pOptData);
                if (dwErr != ERROR_SUCCESS)
                        break;

        if ( liVersion.QuadPart >= DHCP_NT5_VERSION )
        {
                        LPCTSTR pClassName = pCurOption->IsClassOption() ? pCurOption->GetClassName() : NULL;

                        dwErr = ::DhcpSetOptionValueV5((LPTSTR) GetServerIpAddress(),
                                           pCurOption->IsVendor() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                           pCurOption->QueryId(),
                                           (LPTSTR) pClassName,
                                           (LPTSTR) pCurOption->GetVendor(),
                                                                                   &pOptionValueEnum->m_dhcpOptionScopeInfo,
                                                                                   pOptData);
        }
        else
        {
                        dwErr = ::DhcpSetOptionValue((LPTSTR) GetServerIpAddress(),
                                                                             pCurOption->QueryId(),
                                                                             &pOptionValueEnum->m_dhcpOptionScopeInfo,
                                                                             pOptData);
        }

                if (dwErr != ERROR_SUCCESS)
                        break;
        }

        return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::AddReservation
                Deletes a reservation
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::AddReservation
(
    const CDhcpClient * pClient
)
{
    DWORD err = 0 ;

    DHCP_SUBNET_ELEMENT_DATA_V4 dhcSubElData;
        DHCP_IP_RESERVATION_V4      dhcpIpReservation;
        DHCP_CLIENT_UID                     dhcpClientUID;
        const CByteArray&                   baHardwareAddress = pClient->QueryHardwareAddress();

        dhcpClientUID.DataLength = (DWORD) baHardwareAddress.GetSize();
        dhcpClientUID.Data = (BYTE *) baHardwareAddress.GetData();
        
        dhcpIpReservation.ReservedIpAddress = pClient->QueryIpAddress();
        dhcpIpReservation.ReservedForClient = &dhcpClientUID;

    dhcSubElData.ElementType = DhcpReservedIps;
    dhcSubElData.Element.ReservedIp = &dhcpIpReservation;

    dhcpIpReservation.bAllowedClientTypes = pClient->QueryClientType();

    LARGE_INTEGER liVersion;
    GetServerVersion(liVersion);

    if (liVersion.QuadPart >= DHCP_SP2_VERSION)
    {
        err = AddElementV4( &dhcSubElData );
    }
    else
    {
        err = AddElement( reinterpret_cast<DHCP_SUBNET_ELEMENT_DATA *>(&dhcSubElData) );
    }

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::DeleteReservation
                Deletes a reservation
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::DeleteReservation
(
        CByteArray&             baHardwareAddress,
        DHCP_IP_ADDRESS dhcpReservedIpAddress
)
{
        DHCP_SUBNET_ELEMENT_DATA dhcpSubnetElementData;
        DHCP_IP_RESERVATION              dhcpIpReservation;
        DHCP_CLIENT_UID                  dhcpClientUID;

        dhcpClientUID.DataLength = (DWORD) baHardwareAddress.GetSize();
        dhcpClientUID.Data = baHardwareAddress.GetData();
        
        dhcpIpReservation.ReservedIpAddress = dhcpReservedIpAddress;
        dhcpIpReservation.ReservedForClient = &dhcpClientUID;

        dhcpSubnetElementData.ElementType = DhcpReservedIps;
        dhcpSubnetElementData.Element.ReservedIp = &dhcpIpReservation;

        return RemoveElement(&dhcpSubnetElementData, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpScope::DeleteReservation
                Deletes a reservation
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::DeleteReservation
(
        DHCP_CLIENT_UID &dhcpClientUID,
        DHCP_IP_ADDRESS dhcpReservedIpAddress
)
{
        DHCP_SUBNET_ELEMENT_DATA dhcpSubnetElementData;
        DHCP_IP_RESERVATION              dhcpIpReservation;

        dhcpIpReservation.ReservedIpAddress = dhcpReservedIpAddress;
        dhcpIpReservation.ReservedForClient = &dhcpClientUID;

        dhcpSubnetElementData.ElementType = DhcpReservedIps;
        dhcpSubnetElementData.Element.ReservedIp = &dhcpIpReservation;

        return RemoveElement(&dhcpSubnetElementData, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetClientInfo
                Gets a clients detailed information
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetClientInfo
(
        DHCP_IP_ADDRESS         dhcpClientIpAddress,
        LPDHCP_CLIENT_INFO *ppdhcpClientInfo
)
{
        DHCP_SEARCH_INFO dhcpSearchInfo;

        dhcpSearchInfo.SearchType = DhcpClientIpAddress;
        dhcpSearchInfo.SearchInfo.ClientIpAddress = dhcpClientIpAddress;

        return ::DhcpGetClientInfo(GetServerIpAddress(), &dhcpSearchInfo, ppdhcpClientInfo);
}

/*---------------------------------------------------------------------------
        CDhcpScope::CreateClient 
          CreateClient() creates a reservation for a client.  The act
          of adding a new reserved IP address causes the DHCP server
          to create a new client record; we then set the client info
          for this newly created client.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::CreateClient 
( 
    const CDhcpClient * pClient 
)
{
    DWORD err = 0;

    do
    {
        err = AddReservation( pClient );
        if (err != ERROR_SUCCESS)
            break;

        err = SetClientInfo( pClient );
    }
    while (FALSE);

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetClientInfo
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpScope::SetClientInfo
( 
    const CDhcpClient * pClient 
)
{
    DWORD               err = 0 ;
        DHCP_CLIENT_INFO_V4     dhcpClientInfo;
        const CByteArray&       baHardwareAddress = pClient->QueryHardwareAddress();
    LARGE_INTEGER       liVersion;

    GetServerVersion(liVersion);

    dhcpClientInfo.ClientIpAddress = pClient->QueryIpAddress();
        dhcpClientInfo.SubnetMask = pClient->QuerySubnet();
        dhcpClientInfo.ClientHardwareAddress.DataLength = (DWORD) baHardwareAddress.GetSize();
        dhcpClientInfo.ClientHardwareAddress.Data = (BYTE *) baHardwareAddress.GetData();
        dhcpClientInfo.ClientName = (LPTSTR) ((LPCTSTR) pClient->QueryName());
        dhcpClientInfo.ClientComment = (LPTSTR) ((LPCTSTR) pClient->QueryComment());
        dhcpClientInfo.ClientLeaseExpires = pClient->QueryExpiryDateTime();
        dhcpClientInfo.OwnerHost.IpAddress = 0;
        dhcpClientInfo.OwnerHost.HostName = NULL;
        dhcpClientInfo.OwnerHost.NetBiosName = NULL;

    if (liVersion.QuadPart >= DHCP_SP2_VERSION)
    {
        dhcpClientInfo.bClientType = pClient->QueryClientType();

        err = ::DhcpSetClientInfoV4(GetServerIpAddress(),
                                                                &dhcpClientInfo);
    }
    else
    {
        err = ::DhcpSetClientInfo(GetServerIpAddress(),
                                                              reinterpret_cast<LPDHCP_CLIENT_INFO>(&dhcpClientInfo));
    }

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::DeleteClient
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::DeleteClient
(
        DHCP_IP_ADDRESS dhcpClientIpAddress
)
{
        DHCP_SEARCH_INFO dhcpClientInfo;
        
        dhcpClientInfo.SearchType = DhcpClientIpAddress;
        dhcpClientInfo.SearchInfo.ClientIpAddress = dhcpClientIpAddress;
        
        return ::DhcpDeleteClientInfo((LPWSTR) GetServerIpAddress(),
                                                                  &dhcpClientInfo);
}


/*---------------------------------------------------------------------------
        CDhcpScope::SetInfo()
                Updates the scope's information
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetInfo()
{
    DWORD err = 0 ;

        DHCP_SUBNET_INFO dhcpSubnetInfo;

        dhcpSubnetInfo.SubnetAddress = m_dhcpIpAddress;
        dhcpSubnetInfo.SubnetMask = m_dhcpSubnetMask;
        dhcpSubnetInfo.SubnetName = (LPTSTR) ((LPCTSTR) m_strName);
        dhcpSubnetInfo.SubnetComment = (LPTSTR) ((LPCTSTR) m_strComment);
        dhcpSubnetInfo.SubnetState = m_dhcpSubnetState;
        
        GetServerIpAddress(&dhcpSubnetInfo.PrimaryHost.IpAddress);

        // Review : ericdav - do we need to fill these in?
        dhcpSubnetInfo.PrimaryHost.NetBiosName = NULL;
        dhcpSubnetInfo.PrimaryHost.HostName = NULL;

    err = ::DhcpSetSubnetInfo(GetServerIpAddress(),
                                                          m_dhcpIpAddress,
                                                          &dhcpSubnetInfo);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetIpRange()
                returns the scope's allocation range.  Connects to the server
                to get the information
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetIpRange
(
        CDhcpIpRange * pdhipr
)
{
        BOOL    bAlloced = FALSE;
    DWORD   dwError = ERROR_SUCCESS;

        pdhipr->SetAddr(0, TRUE);
        pdhipr->SetAddr(0, FALSE);

        CDhcpAddressPool * pAddressPool = GetAddressPoolObject();

        if (pAddressPool == NULL)
        {
                // the address pool folder isn't there yet...
                // Create a temporary one for now...
                pAddressPool = new CDhcpAddressPool(m_spTFSCompData);
                bAlloced = TRUE;        
        }
        
        // Get a query object from the address pool handler
        CDhcpAddressPoolQueryObj * pQueryObject = 
                reinterpret_cast<CDhcpAddressPoolQueryObj *>(pAddressPool->OnCreateQuery(m_spAddressPool));

        // if we created an address pool handler, then free it up now
        if (bAlloced)
        {
                pQueryObject->m_strServer = GetServerIpAddress();
                pQueryObject->m_dhcpScopeAddress = GetAddress();
        pQueryObject->m_fSupportsDynBootp = GetServerObject()->FSupportsDynBootp();
                pAddressPool->Release();
        }

    // tell the query object to get the ip ranges
        pQueryObject->EnumerateIpRanges();

    // check to see if there was any problems getting the information
    dwError = pQueryObject->m_dwError;
    if (dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    LPQUEUEDATA pQD;
        while (pQD = pQueryObject->RemoveFromQueue())
        {
                Assert (pQD->Type == QDATA_PNODE);
                SPITFSNode p;
                p = reinterpret_cast<ITFSNode *>(pQD->Data);
                delete pQD;

                CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, p);

                *pdhipr = *pAllocRange;
                pdhipr->SetRangeType(pAllocRange->GetRangeType());

                p.Release();
        }

        pQueryObject->Release();

    return dwError;
}

/*---------------------------------------------------------------------------
        CDhcpScope::UpdateIpRange()
                This function updates the IP range on the server.  We also need 
                to remove any exclusion ranges that fall outside of the new
                allocation range.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpScope::UpdateIpRange
(
        DHCP_IP_RANGE * pdhipr
)
{
        return SetIpRange(pdhipr, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpScope::QueryIpRange()
                Returns the scope's allocation range (doesn't talk to the server
                directly, only returns internally cached information).
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpScope::QueryIpRange
(
        DHCP_IP_RANGE * pdhipr
)
{
        pdhipr->StartAddress = 0;
        pdhipr->EndAddress = 0;

    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    m_spAddressPool->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {
                        // found the address
                        //
                        CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, spCurrentNode);

                        pdhipr->StartAddress = pAllocRange->QueryAddr(TRUE);
                        pdhipr->EndAddress = pAllocRange->QueryAddr(FALSE);
                }

                spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetIpRange
                Set's the allocation range for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetIpRange
(
        DHCP_IP_RANGE * pdhcpIpRange,
        BOOL                    bUpdateOnServer
)
{
        CDhcpIpRange dhcpIpRange = *pdhcpIpRange;

        return SetIpRange(dhcpIpRange, bUpdateOnServer);
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetIpRange
                Set's the allocation range for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetIpRange 
(
    CDhcpIpRange & dhcpIpRange,
        BOOL  bUpdateOnServer
)
{
        DWORD err = 0;
        
        if (bUpdateOnServer)
        {
                DHCP_SUBNET_ELEMENT_DATA dhcSubElData;
                CDhcpIpRange            dhipOldRange;
                DHCP_IP_RANGE           dhcpTempIpRange;

                err = GetIpRange(&dhipOldRange);
        if (err != ERROR_SUCCESS)
        {
            return err;
        }

                dhcpTempIpRange.StartAddress = dhipOldRange.QueryAddr(TRUE);
                dhcpTempIpRange.EndAddress = dhipOldRange.QueryAddr(FALSE);

                dhcSubElData.ElementType = DhcpIpRanges;
                dhcSubElData.Element.IpRange = &dhcpTempIpRange;

                // 
                // First update the information on the server
                //
                if (dhcpIpRange.GetRangeType() != 0)
                {
                        // Dynamic BOOTP stuff...
            DHCP_SUBNET_ELEMENT_DATA_V5 dhcSubElDataV5;
            DHCP_BOOTP_IP_RANGE dhcpNewIpRange = {0};

                        dhcpNewIpRange.StartAddress = dhcpIpRange.QueryAddr(TRUE);      
                        dhcpNewIpRange.EndAddress = dhcpIpRange.QueryAddr(FALSE);       
            dhcpNewIpRange.BootpAllocated = 0;
            
            // this field could be set to allow X number of dyn bootp clients from a scope.
            dhcpNewIpRange.MaxBootpAllowed = -1;

                        dhcSubElDataV5.Element.IpRange = &dhcpNewIpRange;
                        dhcSubElDataV5.ElementType = (DHCP_SUBNET_ELEMENT_TYPE) dhcpIpRange.GetRangeType();

                        err = AddElementV5(&dhcSubElDataV5);
                        if (err != ERROR_SUCCESS)
                        {
                DHCP_BOOTP_IP_RANGE dhcpOldIpRange = {0};

                                // something bad happened, try to put the old range back
                                dhcpOldIpRange.StartAddress = dhipOldRange.QueryAddr(TRUE);
                                dhcpOldIpRange.EndAddress = dhipOldRange.QueryAddr(FALSE);

                                dhcSubElDataV5.Element.IpRange = &dhcpOldIpRange;
                                dhcSubElDataV5.ElementType = (DHCP_SUBNET_ELEMENT_TYPE) dhipOldRange.GetRangeType();

                                if (AddElementV5(&dhcSubElDataV5) != ERROR_SUCCESS)
                                {
                                        Trace0("SetIpRange - cannot return ip range back to old state!!");
                                }
                        }
                }
                else
                {
                    //  Remove the old IP range;  allow "not found" error in new scope.
                    //
                    (void)RemoveElement(&dhcSubElData);

            DHCP_IP_RANGE dhcpNewIpRange = {0};
                        dhcpNewIpRange.StartAddress = dhcpIpRange.QueryAddr(TRUE);      
                        dhcpNewIpRange.EndAddress = dhcpIpRange.QueryAddr(FALSE);       

                        dhcSubElData.Element.IpRange = &dhcpNewIpRange;

                        err = AddElement( & dhcSubElData );
                        if (err != ERROR_SUCCESS)
                        {
                                // something bad happened, try to put the old range back
                                dhcpTempIpRange.StartAddress = dhipOldRange.QueryAddr(TRUE);
                                dhcpTempIpRange.EndAddress = dhipOldRange.QueryAddr(FALSE);

                                dhcSubElData.Element.IpRange = &dhcpTempIpRange;

                                if (AddElement(&dhcSubElData) != ERROR_SUCCESS)
                                {
                                        Trace0("SetIpRange - cannot return ip range back to old state!!");
                                }
                        }
                }
        }

        //
        // Find the address pool folder and update the UI object
        //
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    if (m_spAddressPool == NULL) 
                return err;

    m_spAddressPool->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {
                        // found the address
                        //
                        CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, spCurrentNode);

                        // now set them
                        //
                        pAllocRange->SetAddr(dhcpIpRange.QueryAddr(TRUE), TRUE);
                        pAllocRange->SetAddr(dhcpIpRange.QueryAddr(FALSE), FALSE);
                
                        // tell the UI to update
                        spCurrentNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
                }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        return err ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::IsOverlappingRange 
                determines if the exclusion overlaps an existing range
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
CDhcpScope::IsOverlappingRange 
( 
    CDhcpIpRange & dhcpIpRange 
)
{
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
        BOOL bOverlap = FALSE;

    m_spActiveLeases->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_EXCLUSION_RANGE)
                {
                        // found the address
                        //
                        CDhcpExclusionRange * pExclusion = GETHANDLER(CDhcpExclusionRange, spCurrentNode);

                        if ( bOverlap = pExclusion->IsOverlap( dhcpIpRange ) )
                        {
                                spCurrentNode.Release();
                                break;
                        }
                }

                spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    return bOverlap ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::IsValidExclusion
                determines if the exclusion is valid for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpScope::IsValidExclusion
(
        CDhcpIpRange & dhcpExclusionRange
)
{
        DWORD err = 0;
        CDhcpIpRange dhcpScopeRange;

    err = GetIpRange (&dhcpScopeRange);
    
        //
    //  Get the data into a range object.               
    //
    if ( IsOverlappingRange( dhcpExclusionRange ) )
    {
        //
        //  Walk the current list, determining if the new range is valid.
        //  Then, if OK, verify that it's really a sub-range of the current range.
        //
        err = IDS_ERR_IP_RANGE_OVERLAP ;
    }
    else if ( ! dhcpExclusionRange.IsSubset( dhcpScopeRange ) )
    {
        //
        //  Guarantee that the new range is an (improper) subset of the scope's range
        //
        err = IDS_ERR_IP_RANGE_NOT_SUBSET ;
    }

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::StoreExceptionList 
                Adds a bunch of exclusions to the scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
CDhcpScope::StoreExceptionList 
(
        CExclusionList * plistExclusions
)
{
    DHCP_SUBNET_ELEMENT_DATA dhcElement ;
    DHCP_IP_RANGE dhipr ;
    CDhcpIpRange * pobIpRange ;
    DWORD err = 0, err1 = 0;
        POSITION pos;

        pos = plistExclusions->GetHeadPosition();
    while ( pos )
    {
                pobIpRange = plistExclusions->GetNext(pos);

            err1 = AddExclusion( *pobIpRange ) ;
        if ( err1 != 0 )
        {
                        err = err1;
                Trace1("CDhcpScope::StoreExceptionList error adding range %d\n", err);
        }
    }

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::AddExclusion
                Adds an individual exclusion to the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::AddExclusion
(
        CDhcpIpRange &   dhcpIpRange,
        BOOL                     bAddToUI
)
{
    DHCP_SUBNET_ELEMENT_DATA dhcElement ;
    DHCP_IP_RANGE dhipr ;
        DWORD err = 0;

        dhcElement.ElementType = DhcpExcludedIpRanges ;
    dhipr = dhcpIpRange ;
    dhcElement.Element.ExcludeIpRange = & dhipr ;

    Trace2("CDhcpScope::AddExclusion add excluded range %lx %lx\n", dhipr.StartAddress, dhipr.EndAddress );

    err = AddElement( & dhcElement ) ;
    //if ( err != 0 && err != ERROR_DHCP_INVALID_RANGE)
    if ( err != 0 )
    {
        Trace1("CDhcpScope::AddExclusion error removing range %d\n", err);
    }

    if (m_spAddressPool != NULL)
    {
        CDhcpAddressPool * pAddrPool = GETHANDLER(CDhcpAddressPool, m_spAddressPool);

            if (!err && bAddToUI && pAddrPool->m_bExpanded)
            {
                    SPITFSNode spNewExclusion;

                    CDhcpExclusionRange * pExclusion = 
                            new CDhcpExclusionRange(m_spTFSCompData, &((DHCP_IP_RANGE) dhcpIpRange));
                    
                    CreateLeafTFSNode(&spNewExclusion,
                                                      &GUID_DhcpExclusionNodeType,
                                                      pExclusion,
                                                      pExclusion,
                                                      m_spNodeMgr);

                    // Tell the handler to initialize any specific data
                    pExclusion->InitializeNode((ITFSNode *) spNewExclusion);

                    // Add the node as a child to this node
                    m_spAddressPool->AddChild(spNewExclusion);
                    pExclusion->Release();
            }
    }

    TriggerStatsRefresh();

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::RemoveExclusion
                Removes and exclusion from the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::RemoveExclusion
(
        CDhcpIpRange & dhcpIpRange
)
{
    DHCP_SUBNET_ELEMENT_DATA dhcElement ;
    DHCP_IP_RANGE dhipr ;
        DWORD err = 0;

        dhcElement.ElementType = DhcpExcludedIpRanges ;
    dhipr = dhcpIpRange ;
    dhcElement.Element.ExcludeIpRange = & dhipr ;

    Trace2("CDhcpScope::RemoveExclusion remove excluded range %lx %lx\n", dhipr.StartAddress, dhipr.EndAddress);

    err = RemoveElement( & dhcElement ) ;
    //if ( err != 0 && err != ERROR_DHCP_INVALID_RANGE)
    if ( err != 0 )
    {
        Trace1("CDhcpScope::RemoveExclusion error removing range %d\n", err);
    }

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetLeaseTime
                Gets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetLeaseTime
(
        LPDWORD pdwLeaseTime
)
{
    //
    // Check option 51 -- the lease duration
    //
    DWORD dwLeaseTime = 0;
    DHCP_OPTION_VALUE * poptValue = NULL;
    DWORD err = GetOptionValue(OPTION_LEASE_DURATION,    
                                                           DhcpSubnetOptions,
                                                           &poptValue);

    if (err != ERROR_SUCCESS)
    {
        Trace0("CDhcpScope::GetLeaseTime - couldn't get lease duration -- \
                        this scope may have been created by a pre-release version of the admin tool\n");
        
                //
        // The scope doesn't have a lease duration, maybe there's
        // a global option that can come to the rescue here...
        //
        if ((err = GetOptionValue(OPTION_LEASE_DURATION,     
                                                                  DhcpGlobalOptions,
                                                                  &poptValue)) != ERROR_SUCCESS)
        {
            Trace0("CDhcpScope::GetLeaseTime - No global lease duration either -- \
                                                assuming permanent lease duration\n");
            dwLeaseTime = 0;
        }
    }

        if (err == ERROR_SUCCESS)
        {
                if (poptValue->Value.Elements != NULL)
                        dwLeaseTime = poptValue->Value.Elements[0].Element.DWordOption;
        }

        if (poptValue)
                ::DhcpRpcFreeMemory(poptValue);

        *pdwLeaseTime = dwLeaseTime;
        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetLeaseTime
                Sets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetLeaseTime
(
        DWORD dwLeaseTime
)
{
        DWORD err = 0;

        //
    // Set lease duration (option 51)
        //
    CDhcpOption dhcpOption (OPTION_LEASE_DURATION,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(dwLeaseTime);
    
        err = SetOptionValue(&dhcpOption, DhcpSubnetOptions);

        return err;
}


/*---------------------------------------------------------------------------
        CDhcpScope::GetDynBootpLeaseTime
                Gets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetDynBootpLeaseTime
(
        LPDWORD pdwLeaseTime
)
{
    //
    // Check option 51 -- the lease duration
    //
    DWORD dwLeaseTime = 0;
    DHCP_OPTION_VALUE * poptValue = NULL;

        CString strName;
        GetDynBootpClassName(strName);
 
        DWORD err = GetOptionValue(OPTION_LEASE_DURATION,    
                                                           DhcpSubnetOptions,
                                                           &poptValue,
                                                           0,
                                                           strName,
                                                           NULL);

    if (err != ERROR_SUCCESS)
    {
        Trace0("CDhcpScope::GetDynBootpLeaseTime - couldn't get lease duration -- \
                        this scope may have been created by a pre-release version of the admin tool\n");
        
                //
        // The scope doesn't have a lease duration, maybe there's
        // a global option that can come to the rescue here...
        //
        if ((err = GetOptionValue(OPTION_LEASE_DURATION,     
                                                                  DhcpGlobalOptions,
                                                                  &poptValue,
                                                                  0,
                                                                  strName,
                                                                  NULL)) != ERROR_SUCCESS)
        {
            Trace0("CDhcpScope::GetDynBootpLeaseTime - No global lease duration either -- \
                                                assuming permanent lease duration\n");
            dwLeaseTime = 0;
        }
    }

        if (err == ERROR_SUCCESS)
        {
                if (poptValue->Value.Elements != NULL)
                        dwLeaseTime = poptValue->Value.Elements[0].Element.DWordOption;
        }
    else
    {
        // none specified, using default
                dwLeaseTime = UtilConvertLeaseTime(DYN_BOOTP_DFAULT_LEASE_DAYS, 
                                                                               DYN_BOOTP_DFAULT_LEASE_HOURS,
                                                                                   DYN_BOOTP_DFAULT_LEASE_MINUTES);
    }

    if (poptValue)
                ::DhcpRpcFreeMemory(poptValue);

        *pdwLeaseTime = dwLeaseTime;
        
    return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetDynBootpLeaseTime
                Sets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetDynBootpLeaseTime
(
        DWORD dwLeaseTime
)
{
        DWORD err = 0;

        //
    // Set lease duration (option 51)
        //
    CDhcpOption dhcpOption (OPTION_LEASE_DURATION,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(dwLeaseTime);
    
        CString strName;
        GetDynBootpClassName(strName);
        err = SetOptionValue(&dhcpOption, DhcpSubnetOptions, 0, strName, NULL);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetDynBootpClassName
                returns the user class name to be used to set the lease time
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpScope::GetDynBootpClassName(CString & strName)
{
        // use DHCP_BOOTP_CLASS_TXT as the class data to search for
        CClassInfoArray classInfoArray;

        GetServerObject()->GetClassInfoArray(classInfoArray);

        for (int i = 0; i < classInfoArray.GetSize(); i++)
        {
                // check to make sure same size
        if (classInfoArray[i].IsDynBootpClass())
        {
                        // found it!
                        strName = classInfoArray[i].strName;
                        break;
                }
        }
}

DWORD
CDhcpScope::SetDynamicBootpInfo(UINT uRangeType, DWORD dwLeaseTime)
{
        DWORD dwErr = 0;

        // set the range type
        CDhcpIpRange dhcpIpRange;
        GetIpRange(&dhcpIpRange);

        dhcpIpRange.SetRangeType(uRangeType);

        // this updates the type
        dwErr = SetIpRange(dhcpIpRange, TRUE);
        if (dwErr != ERROR_SUCCESS)
                return dwErr;

        // set the lease time
        dwErr = SetDynBootpLeaseTime(dwLeaseTime);

        return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetDnsRegistration
                Gets the DNS registration option value
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetDnsRegistration
(
        LPDWORD pDnsRegOption
)
{
    //
    // Check option 81 -- the DNS registration option
    //
    DHCP_OPTION_VALUE * poptValue = NULL;
    DWORD err = GetOptionValue(OPTION_DNS_REGISTATION,    
                                                           DhcpSubnetOptions,
                                                           &poptValue);
        
        // this is the default
        if (pDnsRegOption)
                *pDnsRegOption = DHCP_DYN_DNS_DEFAULT;

        if (err == ERROR_SUCCESS)
        {
                if ((poptValue->Value.Elements != NULL) &&
                        (pDnsRegOption))
                {
                        *pDnsRegOption = poptValue->Value.Elements[0].Element.DWordOption;
                }
        }
        else
    {
        Trace0("CDhcpScope::GetDnsRegistration - couldn't get DNS reg value, option may not be defined, Getting Server value.\n");
        
                CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spServerNode);
                
                err = pServer->GetDnsRegistration(pDnsRegOption);
    }

        if (poptValue)
                ::DhcpRpcFreeMemory(poptValue);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetDnsRegistration
                Sets the DNS Registration option for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetDnsRegistration
(
        DWORD DnsRegOption
)
{
        DWORD err = 0;

        //
    // Set DNS name registration (option 81)
        //
    CDhcpOption dhcpOption (OPTION_DNS_REGISTATION,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(DnsRegOption);
    
        err = SetOptionValue(&dhcpOption, DhcpSubnetOptions);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpScope::SetOptionValue
                Sets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetOptionValue 
(
    CDhcpOption *                       pdhcType,
    DHCP_OPTION_SCOPE_TYPE      dhcOptType,
    DHCP_IP_ADDRESS                     dhipaReservation,
        LPCTSTR                                 pClassName,
        LPCTSTR                                 pVendorName
)
{
    DWORD                                       err = 0;
    DHCP_OPTION_DATA *          pdhcOptionData;
    DHCP_OPTION_SCOPE_INFO      dhcScopeInfo;
    CDhcpOptionValue *          pcOptionValue = NULL;

    ZeroMemory( & dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        pcOptionValue = new CDhcpOptionValue( & pdhcType->QueryValue() ) ;

        //if ( (err = pcOptionValue->QueryError()) == 0 )
        if ( pcOptionValue )
                {
            dhcScopeInfo.ScopeType = dhcOptType ;

            //
            //  Provide the sub-net address if this is a scope-level operation
            //
            if ( dhcOptType == DhcpSubnetOptions )
            {
                dhcScopeInfo.ScopeInfo.SubnetScopeInfo = m_dhcpIpAddress;
            }
            else if ( dhcOptType == DhcpReservedOptions )
            {
                dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = dhipaReservation;
                dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = m_dhcpIpAddress;
            }

            pcOptionValue->CreateOptionDataStruct(&pdhcOptionData, TRUE);

                        if (pClassName || pVendorName)
                        {
                                err = (DWORD) ::DhcpSetOptionValueV5((LPTSTR) GetServerIpAddress(),
                                                                                                         0,
                                                                                                     pdhcType->QueryId(),
                                                                                                         (LPTSTR) pClassName,
                                                                                                         (LPTSTR) pVendorName,
                                                                                                     &dhcScopeInfo,
                                                                                                     pdhcOptionData);
                        }
                        else
                        {
                                err = (DWORD) ::DhcpSetOptionValue(GetServerIpAddress(),
                                                                                                   pdhcType->QueryId(),
                                                                                                   &dhcScopeInfo,
                                                                                                   pdhcOptionData);
                        }
        }
    }
    END_MEM_EXCEPTION(err) ;

    delete pcOptionValue ;
    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetValue 
                Gets an option value for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::GetOptionValue 
(
    DHCP_OPTION_ID                      OptionID,
    DHCP_OPTION_SCOPE_TYPE      dhcOptType,
    DHCP_OPTION_VALUE **        ppdhcOptionValue,
    DHCP_IP_ADDRESS                     dhipaReservation,
        LPCTSTR                                 pClassName,
        LPCTSTR                                 pVendorName
)
{
    DWORD err = 0 ;

    DHCP_OPTION_SCOPE_INFO dhcScopeInfo ;

    ZeroMemory( &dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        dhcScopeInfo.ScopeType = dhcOptType ;

        //
        //  Provide the sub-net address if this is a scope-level operation
        //
        if ( dhcOptType == DhcpSubnetOptions )
        {
            dhcScopeInfo.ScopeInfo.SubnetScopeInfo = m_dhcpIpAddress;
        }
        else if ( dhcOptType == DhcpReservedOptions )
        {
            dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = dhipaReservation;
            dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = m_dhcpIpAddress;
        }

                if (pClassName || pVendorName)
                {
                        err = (DWORD) ::DhcpGetOptionValueV5((LPTSTR) GetServerIpAddress(),
                                                                                         0,
                                                                                         OptionID,
                                                                                         (LPTSTR) pClassName,
                                                                                         (LPTSTR) pVendorName,
                                                                                         &dhcScopeInfo,
                                                                                         ppdhcOptionValue );
                }
                else
                {
                        err = (DWORD) ::DhcpGetOptionValue(GetServerIpAddress(),
                                                                                           OptionID,
                                                                                           &dhcScopeInfo,
                                                                                           ppdhcOptionValue );
                }
 
        }
    END_MEM_EXCEPTION(err) ;

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::RemoveValue 
                Removes an option 
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpScope::RemoveOptionValue 
(
    DHCP_OPTION_ID                      dhcOptId,
    DHCP_OPTION_SCOPE_TYPE      dhcOptType,
    DHCP_IP_ADDRESS                     dhipaReservation 
)
{
    DHCP_OPTION_SCOPE_INFO dhcScopeInfo;

    ZeroMemory( &dhcScopeInfo, sizeof(dhcScopeInfo) );

    dhcScopeInfo.ScopeType = dhcOptType;

    //
    //  Provide the sub-net address if this is a scope-level operation
    //
    if ( dhcOptType == DhcpSubnetOptions )
    {
        dhcScopeInfo.ScopeInfo.SubnetScopeInfo = m_dhcpIpAddress;
    }
    else if ( dhcOptType == DhcpReservedOptions )
    {
        dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = dhipaReservation;
        dhcScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = m_dhcpIpAddress;
    }

    return (DWORD) ::DhcpRemoveOptionValue(GetServerIpAddress(),
                                                                                   dhcOptId,
                                                                                   &dhcScopeInfo);
}

/*---------------------------------------------------------------------------
        CDhcpScope::AddElement
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::AddElement
(
        DHCP_SUBNET_ELEMENT_DATA * pdhcpSubnetElementData
)
{
        return ::DhcpAddSubnetElement(GetServerIpAddress(),
                                                                  m_dhcpIpAddress,
                                                                  pdhcpSubnetElementData);
}

/*---------------------------------------------------------------------------
CDhcpScope::RemoveElement
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::RemoveElement
(
        DHCP_SUBNET_ELEMENT_DATA * pdhcpSubnetElementData,
        BOOL                                       bForce
)
{
        return ::DhcpRemoveSubnetElement(GetServerIpAddress(),
                                                                         m_dhcpIpAddress,
                                                                         pdhcpSubnetElementData,
                                                                         bForce ? DhcpFullForce : DhcpNoForce);

}

/*---------------------------------------------------------------------------
        CDhcpScope::AddElementV4
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::AddElementV4
(
        DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData
)
{
        return ::DhcpAddSubnetElementV4(GetServerIpAddress(),
                                                                    m_dhcpIpAddress,
                                                                    pdhcpSubnetElementData);
}

/*---------------------------------------------------------------------------
CDhcpScope::RemoveElementV4
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::RemoveElementV4
(
        DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData,
        BOOL                                          bForce
)
{
        return ::DhcpRemoveSubnetElementV4(GetServerIpAddress(),
                                                                           m_dhcpIpAddress,
                                                                           pdhcpSubnetElementData,
                                                                           bForce ? DhcpFullForce : DhcpNoForce);

}

/*---------------------------------------------------------------------------
        CDhcpScope::AddElementV5
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::AddElementV5
(
        DHCP_SUBNET_ELEMENT_DATA_V5 * pdhcpSubnetElementData
)
{
        return ::DhcpAddSubnetElementV5(GetServerIpAddress(),
                                                                    m_dhcpIpAddress,
                                                                    pdhcpSubnetElementData);
}

/*---------------------------------------------------------------------------
CDhcpScope::RemoveElementV5
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::RemoveElementV5
(
        DHCP_SUBNET_ELEMENT_DATA_V5 * pdhcpSubnetElementData,
        BOOL                                          bForce
)
{
        return ::DhcpRemoveSubnetElementV5(GetServerIpAddress(),
                                                                           m_dhcpIpAddress,
                                                                           pdhcpSubnetElementData,
                                                                           bForce ? DhcpFullForce : DhcpNoForce);

}


/*---------------------------------------------------------------------------
        CDhcpScope::GetServerIpAddress()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR
CDhcpScope::GetServerIpAddress()
{
        CDhcpServer * pServer = GetServerObject();

        return pServer->GetIpAddress();
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetServerIpAddress
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpScope::GetServerIpAddress(DHCP_IP_ADDRESS * pdhcpIpAddress)
{
        CDhcpServer * pServer = GetServerObject();

        pServer->GetIpAddress(pdhcpIpAddress);
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetServerVersion
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpScope::GetServerVersion
(
        LARGE_INTEGER& liVersion
)
{
        CDhcpServer * pServer = GetServerObject();
        pServer->GetVersion(liVersion);
}


/*---------------------------------------------------------------------------
        CDhcpScope::SetSuperscope
                Sets this scope as part of the given superscope name
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpScope::SetSuperscope
(
        LPCTSTR         pSuperscopeName,
        BOOL            bRemove
)
{
        DWORD dwReturn = 0;

        dwReturn = ::DhcpSetSuperScopeV4(GetServerIpAddress(),
                                                                         GetAddress(),
                                                                         (LPWSTR) pSuperscopeName,
                                                                         bRemove);

        if (dwReturn != ERROR_SUCCESS)
        {
                Trace1("CDhcpScope::SetSuperscope - DhcpSetSuperScopeV4 failed!!  %d\n", dwReturn);
        }

        return dwReturn;
}

/*---------------------------------------------------------------------------
        Helper functions
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::BuildDisplayName
(
        CString * pstrDisplayName,
        LPCTSTR   pIpAddress,
        LPCTSTR   pName
)
{
        if (pstrDisplayName)
        {
                CString strStandard, strIpAddress, strName;

                strIpAddress = pIpAddress;
                strName = pName;

                strStandard.LoadString(IDS_SCOPE_FOLDER);
                
                *pstrDisplayName = strStandard + L" [" + strIpAddress + L"] " + strName;
        }

        return hrOK;
}

HRESULT 
CDhcpScope::SetName
(
        LPCWSTR pName
)
{
        if (pName != NULL)      
        {
                m_strName = pName;
        }

        CString strIpAddress, strDisplayName;
        
        //
        // Create the display name for this scope
        // Convert DHCP_IP_ADDRES to a string and initialize this object
        //
        UtilCvtIpAddrToWstr (m_dhcpIpAddress,
                                                 &strIpAddress);
        
        BuildDisplayName(&strDisplayName, strIpAddress, pName);

        SetDisplayName(strDisplayName);
        
        return hrOK;
}


/*---------------------------------------------------------------------------
        CDhcpScope::GetAddressPoolObject()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpAddressPool * 
CDhcpScope::GetAddressPoolObject()
{
        if (m_spAddressPool)
                return GETHANDLER(CDhcpAddressPool, m_spAddressPool);
        else
                return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetReservationsObject()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpReservations * 
CDhcpScope::GetReservationsObject()
{
        if ( m_spReservations )
            return GETHANDLER(CDhcpReservations, m_spReservations);
        else
            return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetReservationsObject()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpActiveLeases * 
CDhcpScope::GetActiveLeasesObject()
{
        if (m_spActiveLeases)
                return GETHANDLER(CDhcpActiveLeases, m_spActiveLeases);
        else
                return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetScopeOptionsContainer()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpScopeOptions * 
CDhcpScope::GetScopeOptionsObject()
{
        if (m_spOptions)
                return GETHANDLER(CDhcpScopeOptions, m_spOptions);
        else
                return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpScope::TriggerStatsRefresh()
                Calls into the server object to update the stats
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScope::TriggerStatsRefresh()
{
    GetServerObject()->TriggerStatsRefresh(m_spServerNode);
    
    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservations Implementation
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
        CDhcpReservations::CDhcpReservations()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpReservations::CDhcpReservations
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

//
// copy all the resrved ips to an array and qsort it
// when matching an entry that is read from dhcp db
// we can do a binary search on the qsorted array
// a better algorithm for large n ( n number of active clients ) is to 
// go through the active clients once for each m ( reserved ip ) where m > 
// 100 but << n

BOOL 
CDhcpReservationsQueryObj::AddReservedIPsToArray( )
{

    DHCP_RESUME_HANDLE  dhcpResumeHandle = NULL;
    DWORD               dwElementsRead = 0, dwElementsTotal = 0, dwTotalRead = 0;
    DWORD               dwError = ERROR_MORE_DATA;
    DWORD               dwResvThreshold = 100;

    m_resvMap.RemoveAll();
    m_subnetElements = NULL;
    
    while (dwError == ERROR_MORE_DATA)
    {

        dwError = ::DhcpEnumSubnetElementsV4(((LPWSTR) (LPCTSTR)m_strServer),
                                   m_dhcpScopeAddress,
                                   DhcpReservedIps,
                                   &dhcpResumeHandle,
                                   -1,
                                   &m_subnetElements,
                                   &dwElementsRead,
                                   &dwElementsTotal);

        Trace3("BuildReservationList: Scope %lx Reservations read %d, total %d\n", m_dhcpScopeAddress, dwElementsRead, dwElementsTotal );

        //
        // If number of reservations is less than 100 handle it the old way
        //

        if ( dwElementsTotal <= dwResvThreshold )
        {
            m_totalResvs = dwElementsTotal;
            return( FALSE );
        }

        if (dwElementsRead && dwElementsTotal && m_subnetElements )
        {

            //
            // Loop through the array that was returned
            //


            for (DWORD i = 0; i < m_subnetElements->NumElements; i++)
            {
                m_resvMap.SetAt( m_subnetElements->Elements[i].Element.ReservedIp->ReservedIpAddress,
                                 &m_subnetElements->Elements[ i ]);
            }

            dwTotalRead += dwElementsRead;
            if ( dwTotalRead <= dwElementsTotal )
            {
                m_totalResvs = dwTotalRead;
            }
            else
            {
                m_totalResvs = dwElementsTotal;
            }
        }

    } // while

    return( TRUE );
}

CDhcpReservations::~CDhcpReservations()
{
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservations::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_RESERVATIONS_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_RESERVATIONS);

        SetColumnStringIDs(&aColumns[DHCPSNAP_RESERVATIONS][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_RESERVATIONS][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservations::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpReservations::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strIpAddress, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    DHCP_IP_ADDRESS dhcpIpAddress = GetScopeObject(pNode)->GetAddress();

    UtilCvtIpAddrToWstr (dhcpIpAddress, &strIpAddress);

    strId = GetServerName(pNode) + strIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservations::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpReservations::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_RESERVATIONS_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_RESERVATIONS_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_RESERVATIONS_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_RESERVATIONS_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                            nIndex = ICON_IDX_RESERVATIONS_FOLDER_OPEN_LOST_CONNECTION;
            else
                            nIndex = ICON_IDX_RESERVATIONS_FOLDER_CLOSED_LOST_CONNECTION;
                        break;

                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::RemoveReservationFromUI
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpReservations::RemoveReservationFromUI
(
        ITFSNode *              pReservationsNode,
        DHCP_IP_ADDRESS dhcpReservationIp
)
{
        DWORD                                    dwError = E_UNEXPECTED;
        CDhcpReservationClient * pReservationClient = NULL;
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    pReservationsNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                pReservationClient = GETHANDLER(CDhcpReservationClient, spCurrentNode);

                if (dhcpReservationIp == pReservationClient->GetIpAddress())
                {
                        //
                        // Tell this reservation to delete itself
                        //
                        pReservationsNode->RemoveChild(spCurrentNode);
            spCurrentNode.Release();
                        dwError = ERROR_SUCCESS;
                        
                        break;
                }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        return dwError;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservations::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservations::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    // these menu items go in the new menu, 
                    // only visible from scope pane
                    strMenuText.LoadString(IDS_CREATE_NEW_RESERVATION);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_CREATE_NEW_RESERVATION,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpReservations::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservations::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_NEW_RESERVATION:
                        OnCreateNewReservation(pNode);
                        break;

                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservations::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpReservations::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpReservationClient *pDhcpRC1 = GETHANDLER(CDhcpReservationClient, spNode1);
        CDhcpReservationClient *pDhcpRC2 = GETHANDLER(CDhcpReservationClient, spNode2);

        switch (nCol)
        {
                case 0:
                {
                        // IP address compare
                        //
                        DHCP_IP_ADDRESS dhcpIp1 = pDhcpRC1->GetIpAddress();
                        DHCP_IP_ADDRESS dhcpIp2 = pDhcpRC2->GetIpAddress();
                        
                        if (dhcpIp1 < dhcpIp2)
                                nCompare = -1;
                        else
                        if (dhcpIp1 > dhcpIp2)
                                nCompare =  1;

                        // default is that they are equal
                }
                break;
        }

        return nCompare;
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservations::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CMTDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
        hr = S_FALSE;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::OnResultSelect
                Update the verbs and the result pane message
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpReservations::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPITFSNode      spNode;

    CORg(CMTDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg (pComponent->GetSelectedNode(&spNode));

    if ( spNode != 0 ) {
        UpdateResultMessage(spNode);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::UpdateResultMessage
        Figures out what message to put in the result pane, if any
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CDhcpReservations::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default
    int nVisible, nTotal;
    int i;

    CString strTitle, strBody, strTemp;

    if (!m_dwErr)
    {
                pNode->GetChildCount(&nVisible, &nTotal);

        // determine what message to display
        if ( (m_nState == notLoaded) || 
             (m_nState == loading) )
        {
            nMessage = -1;
        }
        else
        if (nTotal == 0)
        {
            nMessage = RESERVATIONS_MESSAGE_NO_RES;
        }

        // build the strings
        if (nMessage != -1)
        {
            // now build the text strings
            // first entry is the title
            strTitle.LoadString(g_uReservationsMessages[nMessage][0]);

            // second entry is the icon
            // third ... n entries are the body strings

            for (i = 2; g_uReservationsMessages[nMessage][i] != 0; i++)
            {
                strTemp.LoadString(g_uReservationsMessages[nMessage][i]);
                strBody += strTemp;
            }
        }
    }

    // show the message
    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uReservationsMessages[nMessage][1]);
    }
}

/*---------------------------------------------------------------------------
        Message handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservations::OnCreateNewReservation
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpReservations::OnCreateNewReservation
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spScopeNode;
        pNode->GetParent(&spScopeNode);

    CDhcpScope * pScope = GETHANDLER(CDhcpScope, spScopeNode);
    LARGE_INTEGER liVersion;

    pScope->GetServerVersion(liVersion);

    CAddReservation dlgAddReservation(spScopeNode, liVersion);

        dlgAddReservation.DoModal();

    GetScopeObject(pNode)->TriggerStatsRefresh();

    UpdateResultMessage(pNode);

    return 0;
}


/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservations::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpReservations::OnHaveData
(
        ITFSNode * pParentNode, 
        ITFSNode * pNewNode
)
{
    AddReservationSorted(pParentNode, pNewNode);    

    // update the view
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpReservations::AddReservationSorted
    Adding reservation after sorting it by comparing against the resvname
    takes too much time.
                Adds a scope node to the UI sorted
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservations::AddReservationSorted
(
    ITFSNode * pReservationsNode,
    ITFSNode * pResClientNode
)
{

   HRESULT         hr = hrOK;
   SPITFSNodeEnum  spNodeEnum;
   SPITFSNode      spCurrentNode;
   SPITFSNode      spPrevNode;
   ULONG           nNumReturned = 0;

   CDhcpReservationClient *  pResClient;

   // get our target address
   pResClient = GETHANDLER(CDhcpReservationClient, pResClientNode);

   // get the enumerator for this node
   CORg(pReservationsNode->GetEnum(&spNodeEnum));

   CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
   while (nNumReturned)
   {
       pResClient = GETHANDLER(CDhcpReservationClient, spCurrentNode);

       // get the next node in the list
       spPrevNode.Set(spCurrentNode);

       spCurrentNode.Release();
       spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
   }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (m_bExpanded)
        {
            pResClientNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
            pResClientNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
        }

        CORg(pReservationsNode->InsertChild(spPrevNode, pResClientNode));
    }
    else
    {
        // add to the head
        if (m_bExpanded)
        {
            pResClientNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }

        CORg(pReservationsNode->AddChild(pResClientNode));
    }
    
Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservations::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpReservations::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpReservationsQueryObj* pQuery = 
                new CDhcpReservationsQueryObj(m_spTFSCompData, m_spNodeMgr);
        
        pQuery->m_strServer = GetServerIpAddress(pNode);
        
        pQuery->m_dhcpScopeAddress = GetScopeObject(pNode)->GetAddress();
        pQuery->m_dhcpResumeHandle = NULL;
        pQuery->m_dwPreferredMax   = 2000;
        pQuery->m_resvMap.RemoveAll();
        pQuery->m_totalResvs       = 0;
        pQuery->m_subnetElements = NULL;
        GetScopeObject(pNode)->GetServerVersion(pQuery->m_liVersion);

        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpReservationsQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpReservationsQueryObj::Execute()
{
    HRESULT hr = hrOK;

    if (m_liVersion.QuadPart >= DHCP_SP2_VERSION)
    {

        if ( AddReservedIPsToArray( ) )
        {
            //
            //
            // this should handle the case where there are a large # of resvs.
            //
            //

                    hr = EnumerateReservationsV4();
        }
        else
        {
            //
            // a typical corporation doesnt have more than 100 resvs
            // handle it here
            //

            hr = EnumerateReservationsForLessResvsV4( );
        }
    }
    else
    {
        hr = EnumerateReservations();
    }
    
    return hr;
}

HRESULT
CDhcpReservationsQueryObj::EnumerateReservationsForLessResvsV4( )
{

        DWORD                                                       dwError = ERROR_MORE_DATA;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 pdhcpSubnetElementArray = NULL;
        DWORD                                                       dwElementsRead = 0, dwElementsTotal = 0;
    HRESULT                             hr = hrOK;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetElementsV4(((LPWSTR) (LPCTSTR)m_strServer),
                                                                                     m_dhcpScopeAddress,
                                                                                     DhcpReservedIps,
                                                                                     &m_dhcpResumeHandle,
                                                                                     m_dwPreferredMax,
                                                                                     &pdhcpSubnetElementArray,
                                                                                     &dwElementsRead,
                                                                                     &dwElementsTotal);
                
                Trace3("Scope %lx Reservations read %d, total %d\n", m_dhcpScopeAddress, dwElementsRead, dwElementsTotal);
                
                if (dwElementsRead && dwElementsTotal && pdhcpSubnetElementArray)
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // For each reservation, we need to get the client info
                                //
                                DWORD                               dwReturn;
                                LPDHCP_CLIENT_INFO_V4   pClientInfo = NULL;
                                DHCP_SEARCH_INFO            dhcpSearchInfo;

                                dhcpSearchInfo.SearchType = DhcpClientIpAddress;
                                dhcpSearchInfo.SearchInfo.ClientIpAddress = 
                                        pdhcpSubnetElementArray->Elements[i].Element.ReservedIp->ReservedIpAddress;
                                
                dwReturn = ::DhcpGetClientInfoV4(m_strServer,
                                                                                         &dhcpSearchInfo,
                                                                                         &pClientInfo);
                                if (dwReturn == ERROR_SUCCESS)
                                {
                                        //
                                        // Create the result pane item for this element
                                        //
                                        SPITFSNode spNode;
                                        CDhcpReservationClient * pDhcpReservationClient;

                    COM_PROTECT_TRY
                    {
                        pDhcpReservationClient = 
                            new CDhcpReservationClient(m_spTFSCompData, pClientInfo);
                                            
                        // Tell the reservation what the client type is
                        pDhcpReservationClient->SetClientType(pdhcpSubnetElementArray->Elements[i].Element.ReservedIp->bAllowedClientTypes);

                        CreateContainerTFSNode(&spNode,
                                                                                       &GUID_DhcpReservationClientNodeType,
                                                                                       pDhcpReservationClient,
                                                                                       pDhcpReservationClient,
                                                                                       m_spNodeMgr);

                        // Tell the handler to initialize any specific data
                                            pDhcpReservationClient->InitializeNode(spNode);

                                            AddToQueue(spNode);
                                            pDhcpReservationClient->Release();
                    }
                    COM_PROTECT_CATCH

                                        ::DhcpRpcFreeMemory(pClientInfo);
                                }
                else
                {
                    // REVIEW: ericdav - do we need to post the error back here?
                    Trace1("EnumReservationsV4 - GetClientInfoV4 failed! %d\n", dwReturn);
                }
                        }

                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);

                pdhcpSubnetElementArray = NULL;
                dwElementsRead = 0;
            dwElementsTotal = 0;
                }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateReservationsV4 error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
    

}
/*---------------------------------------------------------------------------
        CDhcpReservationsQueryObj::EnumerateReservationsV4()
                Enumerates leases for NT4 SP2 and newer servers
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservationsQueryObj::EnumerateReservationsV4()
{

    DWORD                       dwError = ERROR_MORE_DATA;
    LPDHCP_CLIENT_INFO_ARRAY_V5 pdhcpClientArrayV5 = NULL;
    LPDHCP_SUBNET_ELEMENT_DATA_V4 pSubnetData = NULL;
    DWORD                       dwClientsRead = 0, dwClientsTotal = 0;
    DWORD                       dwResvsHandled  = 0;
    DWORD                       dwEnumedClients = 0;
    DWORD                       dwResvThreshold = 1000;
    DWORD                       i = 0;
    DWORD                       k = 0;
    DWORD                       *j = NULL;
    HRESULT                     hr = hrOK;


    while (dwError == ERROR_MORE_DATA)
    {
        dwError = ::DhcpEnumSubnetClientsV5(((LPWSTR) (LPCTSTR)m_strServer),
                                         m_dhcpScopeAddress,
                                         &m_dhcpResumeHandle,
                                         -1,
                                         &pdhcpClientArrayV5,
                                         &dwClientsRead,
                                         &dwClientsTotal);


        if ( dwClientsRead && dwClientsTotal && pdhcpClientArrayV5 )

        {

                //
                // we do a binary search for a reservation 
                // that is present in the table.
                //

                for( i = 0; i < dwClientsRead; i ++ )
                {

                    //
                    // do binary search against each client that was read to see 
                    // if it is a reservation.
                    //

                    k = pdhcpClientArrayV5 -> Clients[i] -> ClientIpAddress;

                    if ( m_resvMap.Lookup( k, pSubnetData ))
                    {

                    //
                    // Create the result pane item for this element
                    //

                    SPITFSNode spNode;
                    CDhcpReservationClient * pDhcpReservationClient;

                    COM_PROTECT_TRY
                     {

                        pDhcpReservationClient =
                             new CDhcpReservationClient( m_spTFSCompData, reinterpret_cast<LPDHCP_CLIENT_INFO_V4>(pdhcpClientArrayV5 -> Clients[ i ] ));
                        pDhcpReservationClient->SetClientType( pSubnetData->Element.ReservedIp->bAllowedClientTypes );

                        CreateContainerTFSNode(&spNode,
                                            &GUID_DhcpReservationClientNodeType,
                                            pDhcpReservationClient,
                                            pDhcpReservationClient,
                                            m_spNodeMgr);

                        //
                        // Tell the handler to initialize any specific data
                        //

                        pDhcpReservationClient->InitializeNode(spNode);

                        AddToQueue(spNode);
                        pDhcpReservationClient->Release();
                      }
                     COM_PROTECT_CATCH

                     } // end of if that adds a reservation

               } // end of for

              ::DhcpRpcFreeMemory(pdhcpClientArrayV5);

              pdhcpClientArrayV5 = NULL;
              dwEnumedClients += dwClientsRead;
              dwClientsRead  = 0;
              dwClientsTotal = 0;

                } // end of main if that checks if read succeeded.

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateReservationsV4 error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }

    DhcpRpcFreeMemory( m_subnetElements );
    m_subnetElements = NULL;
    m_totalResvs = 0;
    m_resvMap.RemoveAll();

    return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpReservationsQueryObj::Execute()
                Enumerates reservations for pre NT4 SP2 servers
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservationsQueryObj::EnumerateReservations()
{
        DWORD                                                    dwError = ERROR_MORE_DATA;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY pdhcpSubnetElementArray = NULL;
        DWORD                                                    dwElementsRead = 0, dwElementsTotal = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetElements(((LPWSTR) (LPCTSTR)m_strServer),
                                                                                   m_dhcpScopeAddress,
                                                                                   DhcpReservedIps,
                                                                                   &m_dhcpResumeHandle,
                                                                                   m_dwPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);
                
                Trace3("Scope %lx Reservations read %d, total %d\n", m_dhcpScopeAddress, dwElementsRead, dwElementsTotal);
                
                if (dwElementsRead && dwElementsTotal && pdhcpSubnetElementArray)
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // For each reservation, we need to get the client info
                                //
                                DWORD                       dwReturn;
                                LPDHCP_CLIENT_INFO      pClientInfo = NULL;
                                DHCP_SEARCH_INFO    dhcpSearchInfo;

                                dhcpSearchInfo.SearchType = DhcpClientIpAddress;
                                dhcpSearchInfo.SearchInfo.ClientIpAddress = 
                                        pdhcpSubnetElementArray->Elements[i].Element.ReservedIp->ReservedIpAddress;
                                
                dwReturn = ::DhcpGetClientInfo(m_strServer,
                                                                                           &dhcpSearchInfo,
                                                                                           &pClientInfo);
                                if (dwReturn == ERROR_SUCCESS)
                                {
                                        //
                                        // Create the result pane item for this element
                                        //
                                        SPITFSNode spNode;
                                        CDhcpReservationClient * pDhcpReservationClient;

                    pDhcpReservationClient = 
                        new CDhcpReservationClient(m_spTFSCompData, reinterpret_cast<LPDHCP_CLIENT_INFO>(pClientInfo));
                                        
                                        CreateContainerTFSNode(&spNode,
                                                                                   &GUID_DhcpReservationClientNodeType,
                                                                                   pDhcpReservationClient,
                                                                                   pDhcpReservationClient,
                                                                                   m_spNodeMgr);

                                        // Tell the handler to initialize any specific data
                                        pDhcpReservationClient->InitializeNode(spNode);

                                        AddToQueue(spNode);
                                        pDhcpReservationClient->Release();

                                        ::DhcpRpcFreeMemory(pClientInfo);
                                }
                        }

                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);

                pdhcpSubnetElementArray = NULL;
                dwElementsRead = 0;
            dwElementsTotal = 0;
                }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateReservations error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
}

/*!--------------------------------------------------------------------------
        CDhcpReservations::OnNotifyExiting
                CMTDhcpHandler overridden functionality
                allows us to know when the background thread is done
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservations::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        spNode.Set(m_spNode); // save this off because OnNotifyExiting will release it

        HRESULT hr = CMTDhcpHandler::OnNotifyExiting(lParam);

    UpdateResultMessage(spNode);

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpReservationClient::CDhcpReservationClient
(
        ITFSComponentData * pComponentData,
        LPDHCP_CLIENT_INFO pDhcpClientInfo
) : CMTDhcpHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    InitializeData(pDhcpClientInfo);

        //
        // Intialize our client type
        //
        m_bClientType = CLIENT_TYPE_UNSPECIFIED;

    m_fResProp = TRUE;
}

CDhcpReservationClient::CDhcpReservationClient
(
        ITFSComponentData *     pComponentData,
        LPDHCP_CLIENT_INFO_V4   pDhcpClientInfo
) : CMTDhcpHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    InitializeData(reinterpret_cast<LPDHCP_CLIENT_INFO>(pDhcpClientInfo));

        //
        // Intialize our client type
        //
    m_bClientType = pDhcpClientInfo->bClientType;

    m_fResProp = TRUE;
}

CDhcpReservationClient::CDhcpReservationClient
(
        ITFSComponentData * pComponentData,
        CDhcpClient &       dhcpClient
) : CMTDhcpHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_dhcpClientIpAddress = dhcpClient.QueryIpAddress();
        
        //
        // Copy data out if it's there
        //
        if (dhcpClient.QueryName().GetLength() > 0)
        {
                m_pstrClientName = new CString (dhcpClient.QueryName());
        }
        else
        {
                m_pstrClientName = NULL;
        }

        if (dhcpClient.QueryComment().GetLength() > 0)
        {
                m_pstrClientComment = new CString(dhcpClient.QueryComment());
        }
        else
        {
                m_pstrClientComment = NULL;
        }

        //
        // build the clients hardware address
        //
        if (dhcpClient.QueryHardwareAddress().GetSize() > 0)
        {
                m_baHardwareAddress.Copy(dhcpClient.QueryHardwareAddress());
        }

        if ( (dhcpClient.QueryExpiryDateTime().dwLowDateTime == 0) &&
             (dhcpClient.QueryExpiryDateTime().dwHighDateTime == 0) )
        {
                //
                // This is an inactive reservation
                //
                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_INACTIVE);
        }
        else
        {
                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_ACTIVE);
        }

        //
        // Intialize our client type
        //
        m_bClientType = dhcpClient.QueryClientType();

    m_fResProp = TRUE;
}

CDhcpReservationClient::~CDhcpReservationClient()
{
        if (m_pstrClientName)
        {
                delete m_pstrClientName;
        }

        if (m_pstrClientComment)
        {
                delete m_pstrClientComment;
        }
}

void
CDhcpReservationClient::InitializeData
(
    LPDHCP_CLIENT_INFO  pDhcpClientInfo
)
{
    Assert(pDhcpClientInfo);

    m_dhcpClientIpAddress = pDhcpClientInfo->ClientIpAddress;
        
        //
        // Copy data out if it's there
        //
        if (pDhcpClientInfo->ClientName)
        {
                m_pstrClientName = new CString (pDhcpClientInfo->ClientName);
        }
        else
        {
                m_pstrClientName = NULL;
        }

        if (pDhcpClientInfo->ClientComment)
        {
                m_pstrClientComment = new CString(pDhcpClientInfo->ClientComment);
        }
        else
        {
                m_pstrClientComment = NULL;
        }

        // build a copy of the hardware address
        if (pDhcpClientInfo->ClientHardwareAddress.DataLength)
        {
                for (DWORD i = 0; i < pDhcpClientInfo->ClientHardwareAddress.DataLength; i++)
                {
                        m_baHardwareAddress.Add(pDhcpClientInfo->ClientHardwareAddress.Data[i]);
                }
        }

        if ( (pDhcpClientInfo->ClientLeaseExpires.dwLowDateTime == 0) &&
             (pDhcpClientInfo->ClientLeaseExpires.dwHighDateTime == 0) )
        {
                //
                // This is an inactive reservation
                //
                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_INACTIVE);
        }
        else
        {
                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_ACTIVE);
        }
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservationClient::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;
        CString strIpAddress, strDisplayName;
        
        //
        // Create the display name for this scope
        // Convert DHCP_IP_ADDRES to a string and initialize this object
        //
        UtilCvtIpAddrToWstr (m_dhcpClientIpAddress,
                                                 &strIpAddress);
        
        BuildDisplayName(&strDisplayName, strIpAddress, *m_pstrClientName);

        SetDisplayName(strDisplayName);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_RESERVATION_CLIENT);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_RESERVATION_CLIENT][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_RESERVATION_CLIENT][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpReservationClient::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strScopeIpAddress, strResIpAddress, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    DHCP_IP_ADDRESS dhcpIpAddress = GetScopeObject(pNode, TRUE)->GetAddress();

    UtilCvtIpAddrToWstr (dhcpIpAddress, &strScopeIpAddress);
    UtilCvtIpAddrToWstr (m_dhcpClientIpAddress, &strResIpAddress);

    strId = GetServerName(pNode, TRUE) + strScopeIpAddress + strResIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpReservationClient::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                        nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_LOST_CONNECTION;
            else
                        nIndex = ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_LOST_CONNECTION;
                        break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservationClient::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuText.LoadString(IDS_CREATE_OPTION_RESERVATION);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_CREATE_OPTION_RESERVATION,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservationClient::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                case IDS_DELETE:
                        OnDelete(pNode);
                        break;
                
                case IDS_CREATE_OPTION_RESERVATION:     
                        OnCreateNewOptions(pNode);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpReservationClient::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpOptionItem *pOpt1 = GETHANDLER(CDhcpOptionItem, spNode1);
        CDhcpOptionItem *pOpt2 = GETHANDLER(CDhcpOptionItem, spNode2);

        switch (nCol)
        {
                case 0:
                {
                        //
            // Name compare - use the option #
                        //
            LONG_PTR uImage1 = spNode1->GetData(TFS_DATA_IMAGEINDEX);
            LONG_PTR uImage2 = spNode2->GetData(TFS_DATA_IMAGEINDEX);

            nCompare = UtilGetOptionPriority((int) uImage1, (int) uImage2);
            if (nCompare == 0)
            {
                DHCP_OPTION_ID  id1 = pOpt1->GetOptionId();
                DHCP_OPTION_ID  id2 = pOpt2->GetOptionId();
                            
                            if (id1 < id2)
                                    nCompare = -1;
                            else
                            if (id1 > id2)
                                    nCompare =  1;
            }
        }
                break;

        case 1:
        {
            // compare the vendor strings
            CString str1, str2;
            str1 = pOpt1->GetVendorDisplay();
            str2 = pOpt2->GetVendorDisplay();

            nCompare = str1.CompareNoCase(str2);
        }
        break;

        case 2:  {
            // compare the printable values
            CString str1, str2;
            str1 = pOpt1->GetString( pComponent, cookieA, nCol );
            str2 = pOpt2->GetString( pComponent, cookieB, nCol );
            
            nCompare = str1.CompareNoCase( str2 );
            break;
        }

        case 3:
        {
            CString str1, str2;
            str1 = pOpt1->GetClassName();
            str2 = pOpt2->GetClassName();

            nCompare = str1.CompareNoCase(str2);
        }
        break;
    }

        return nCompare;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnResultSelect
                Update the verbs and the result pane message
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpReservationClient::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPITFSNode      spNode;

    CORg(CMTDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg (pComponent->GetSelectedNode(&spNode));

    if ( spNode != 0 ) {
       UpdateResultMessage(spNode);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::UpdateResultMessage
        Figures out what message to put in the result pane, if any
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CDhcpReservationClient::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default
    int nVisible, nTotal;
    int i;

    CString strTitle, strBody, strTemp;

    if (!m_dwErr)
    {
                pNode->GetChildCount(&nVisible, &nTotal);

        // determine what message to display
        if ( (m_nState == notLoaded) || 
             (m_nState == loading) )
        {
            nMessage = -1;
        }
        else
        if (nTotal == 0)
        {
            nMessage = RES_OPTIONS_MESSAGE_NO_OPTIONS;
        }

        // build the strings
        if (nMessage != -1)
        {
            // now build the text strings
            // first entry is the title
            strTitle.LoadString(g_uResOptionsMessages[nMessage][0]);

            // second entry is the icon
            // third ... n entries are the body strings

            for (i = 2; g_uResOptionsMessages[nMessage][i] != 0; i++)
            {
                strTemp.LoadString(g_uResOptionsMessages[nMessage][i]);
                strBody += strTemp;
            }
        }
    }

    // show the message
    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uResOptionsMessages[nMessage][1]);
    }
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnDelete
                The base handler calls this when MMC sends a MMCN_DELETE for a 
                scope pane item.  We just call our delete command handler.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::OnDelete
(
        ITFSNode *      pNode, 
        LPARAM          arg, 
        LPARAM          lParam
)
{
        return OnDelete(pNode);
}

/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservationClient::OnCreateNewOptions
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CPropertyPageHolderBase *   pPropSheet;
        CString                             strOptCfgTitle, strOptType;
        SPITFSNode                          spServerNode;
        SPIComponentData            spComponentData;
        COptionsConfig *            pOptCfg;
        DHCP_OPTION_SCOPE_INFO      dhcpScopeInfo;
        HRESULT                     hr = hrOK;

        COM_PROTECT_TRY
        {
        CString             strOptCfgTitle, strOptType;
            SPIComponentData    spComponentData;
            BOOL fFound = FALSE;

        strOptType.LoadString(IDS_CONFIGURE_OPTIONS_CLIENT);
            AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

        // this gets kinda weird because we implemented the option config page 
        // as a property page, so technically this node has two property pages.
        // 
        // search the open prop pages to see if the option config is up
        // if it's up, set it active instead of creating a new one.
        for (int i = 0; i < HasPropSheetsOpen(); i++)
        {
            GetOpenPropSheet(i, &pPropSheet);

            HWND hwnd = pPropSheet->GetSheetWindow();
            CString strTitle;

            ::GetWindowText(hwnd, strTitle.GetBuffer(256), 256);
            strTitle.ReleaseBuffer();

            if (strTitle == strOptCfgTitle)
            {
                pPropSheet->SetActiveWindow();
                fFound = TRUE;
                break;
            }
        }

        if (!fFound)
        {
            m_spNodeMgr->GetComponentData(&spComponentData);

            m_fResProp = FALSE;

            hr = DoPropertiesOurselvesSinceMMCSucks(pNode, spComponentData, strOptCfgTitle);

            m_fResProp = TRUE;
        }
        }
        COM_PROTECT_CATCH;

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnDelete
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpReservationClient::OnDelete
(
        ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    CString strMessage, strTemp;
    DWORD dwError = 0;
    
    CDhcpReservations *pResrv;
    pResrv = GETHANDLER( CDhcpReservations, pNode );
    
    // Check for any open property sheets
    if ( pResrv->HasPropSheetsOpen()) {
        AfxMessageBox( IDS_MSG_CLOSE_PROPSHEET );

        return ERROR_INVALID_PARAMETER;
    }

        
    UtilCvtIpAddrToWstr (m_dhcpClientIpAddress,
                         &strTemp);

    AfxFormatString1(strMessage, IDS_DELETE_RESERVATION, (LPCTSTR) strTemp);

    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
        BEGIN_WAIT_CURSOR;
        
        dwError = GetScopeObject(pNode, TRUE)->DeleteReservation(m_baHardwareAddress, m_dhcpClientIpAddress);
        if (dwError != 0) {
            //
            // OOOpss.  Something happened, reservation not 
            // deleted, so don't remove from UI and put up a message box
            //
            ::DhcpMessageBox(dwError);
        }
        else {
            CDhcpScope * pScope = NULL;
            SPITFSNode spActiveLeasesNode;
            
            pScope = GetScopeObject(pNode, TRUE);
            pScope->GetActiveLeasesNode(&spActiveLeasesNode);
            
            pScope->GetActiveLeasesObject()->DeleteClient(spActiveLeasesNode, m_dhcpClientIpAddress);
            
            SPITFSNode spReservationsNode;
            pNode->GetParent(&spReservationsNode);
            
            spReservationsNode->RemoveChild(pNode);
            
            // update stats
            pScope->TriggerStatsRefresh();
        } // else
        
        END_WAIT_CURSOR;
    } // if 

    return dwError;
} // CDhcpReservationClient::OnDelete()


/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnResultPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::OnResultPropertyChange
(
        ITFSComponent * pComponent,
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);
        COptionsConfig * pOptCfg = reinterpret_cast<COptionsConfig *>(param);

        LPARAM changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pOptCfg->OnPropertyChange(TRUE, &changeMask);

        pOptCfg->AcknowledgeNotify();

        if (changeMask)
                spNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservationClient::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
    HRESULT hr = hrOK;

    if (m_fResProp)
    {
        hr = DoResPages(pNode, lpProvider, pDataObject, handle, dwType);
    }
    else
    {
        hr = DoOptCfgPages(pNode, lpProvider, pDataObject, handle, dwType);
    }

    return hr;
}

HRESULT
CDhcpReservationClient::DoResPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Create the property page
    //
        SPIComponentData spComponentData;
        m_spNodeMgr->GetComponentData(&spComponentData);

        CReservedClientProperties * pResClientProp = 
                new CReservedClientProperties(pNode, spComponentData, m_spTFSCompData, NULL);

        // Get the Server version and set it in the property sheet
        LARGE_INTEGER liVersion;
        CDhcpServer * pServer = GetScopeObject(pNode, TRUE)->GetServerObject();
        pServer->GetVersion(liVersion);

        pResClientProp->SetVersion(liVersion);

        // fill in the data for the prop page
        pResClientProp->m_pageGeneral.m_dwClientAddress = m_dhcpClientIpAddress;
        
        if (m_pstrClientName)
                pResClientProp->m_pageGeneral.m_strName = *m_pstrClientName;

        if (m_pstrClientComment)
                pResClientProp->m_pageGeneral.m_strComment = *m_pstrClientComment;

        pResClientProp->SetClientType(m_bClientType);

        // fill in the UID string
        UtilCvtByteArrayToString(m_baHardwareAddress, pResClientProp->m_pageGeneral.m_strUID);

        // set the DNS registration option
        DWORD           dwDynDnsFlags;
        DWORD           dwError;

    BEGIN_WAIT_CURSOR;

    dwError = GetDnsRegistration(pNode, &dwDynDnsFlags);
    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        return hrFalse;
    }

    END_WAIT_CURSOR;
        
        pResClientProp->SetDnsRegistration(dwDynDnsFlags, DhcpReservedOptions);

        //
        // Object gets deleted when the page is destroyed
        //
        Assert(lpProvider != NULL);

        return pResClientProp->CreateModelessSheet(lpProvider, handle);
}

HRESULT
CDhcpReservationClient::DoOptCfgPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD                       dwError;
    DWORD                       dwDynDnsFlags;
    HRESULT             hr = hrOK;
        COptionsConfig *    pOptCfg;
        CString             strOptCfgTitle, strOptType;
        SPITFSNode          spServerNode;
        SPIComponentData    spComponentData;
    COptionValueEnum *  pOptionValueEnum;

    //
        // Create the property page
    //
    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spComponentData);

        BEGIN_WAIT_CURSOR;

        strOptType.LoadString(IDS_CONFIGURE_OPTIONS_CLIENT);
                AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

                GetScopeObject(pNode, TRUE)->GetServerNode(&spServerNode);

        pOptCfg = new COptionsConfig(pNode, 
                                                                     spServerNode,
                                                                         spComponentData, 
                                                                         m_spTFSCompData,
                                                                         GetOptionValueEnum(),
                                                                         strOptCfgTitle);
      
        END_WAIT_CURSOR;
            
            //
            // Object gets deleted when the page is destroyed
        //
            Assert(lpProvider != NULL);

        hr = pOptCfg->CreateModelessSheet(lpProvider, handle);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CPropertyPageHolderBase * pProp = 
                reinterpret_cast<CPropertyPageHolderBase *>(lParam);

        LONG_PTR changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pProp->OnPropertyChange(TRUE, &changeMask);

        pProp->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode  spResClient, spSelectedNode;
    DWORD       dwError;
    
    m_spNodeMgr->FindNode(cookie, &spResClient);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spResClient);
        if (spSelectedNode != spResClient)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int) listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

    // check to make sure we are deleting just scope options
    POSITION pos = listNodesToDelete.GetHeadPosition();
    while (pos)
    {
        ITFSNode * pNode = listNodesToDelete.GetNext(pos);
        if (pNode->GetData(TFS_DATA_IMAGEINDEX) != ICON_IDX_CLIENT_OPTION_LEAF)
        {
            // this option is not scope option.  Put up a dialog telling the user what to do
            AfxMessageBox(IDS_CANNOT_DELETE_OPTION_RES);
            return NOERROR;
        }
    }

    CString strServer = GetServerIpAddress(spResClient, TRUE);

        DHCP_OPTION_SCOPE_INFO    dhcpOptionScopeInfo;
        dhcpOptionScopeInfo.ScopeType = DhcpReservedOptions;
        dhcpOptionScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = m_dhcpClientIpAddress;
        
        CDhcpScope * pScope = GetScopeObject(spResClient, TRUE);
        dhcpOptionScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = pScope->GetAddress();

        //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;
        
    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spOptionNode;
                spOptionNode = listNodesToDelete.RemoveHead();
                
                CDhcpOptionItem * pOptItem = GETHANDLER(CDhcpOptionItem, spOptionNode);

                //
                // Try to remove it from the server
                //
        
        if (pOptItem->IsVendorOption() ||
            pOptItem->IsClassOption())
        {
            LPCTSTR pClassName = pOptItem->GetClassName();
            if (lstrlen(pClassName) == 0)
                pClassName = NULL;

            dwError = ::DhcpRemoveOptionValueV5((LPTSTR) ((LPCTSTR) strServer),
                                                pOptItem->IsVendorOption() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                                pOptItem->GetOptionId(),
                                                (LPTSTR) pClassName,
                                                (LPTSTR) pOptItem->GetVendor(),
                                                &dhcpOptionScopeInfo);
        }
        else
        {
            dwError = ::DhcpRemoveOptionValue(strServer, 
                                                                                      pOptItem->GetOptionId(), 
                                                                                      &dhcpOptionScopeInfo);
        }

                if (dwError != 0)
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

            hr = E_FAIL;
            continue;
                }

        GetOptionValueEnum()->Remove(pOptItem->GetOptionId(), pOptItem->GetVendor(), pOptItem->GetClassName());    

        //
                // Remove from UI now
                //
                spResClient->RemoveChild(spOptionNode);
                spOptionNode.Release();
        }
    
    END_WAIT_CURSOR;

    UpdateResultMessage(spResClient);

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CMTDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
                
                hr = S_FALSE;
        }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpReservationClient::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        // This is how we get non-node data back from the background thread.
    switch (Type)
    {
        case DHCP_QDATA_OPTION_VALUES:
        {
            HRESULT             hr = hrOK;
                SPIComponentData        spCompData;
                SPIConsole                      spConsole;
            SPIDataObject       spDataObject;
            IDataObject *       pDataObject;
            COptionValueEnum *  pOptionValueEnum = reinterpret_cast<COptionValueEnum *>(Data);

            SetOptionValueEnum(pOptionValueEnum);
            
            pOptionValueEnum->RemoveAll();
            delete pOptionValueEnum;

            // now tell the view to update themselves
                m_spNodeMgr->GetComponentData(&spCompData);

                CORg ( spCompData->QueryDataObject((MMC_COOKIE) pParentNode, CCT_SCOPE, &pDataObject) );
            spDataObject = pDataObject;

            CORg ( m_spNodeMgr->GetConsole(&spConsole) );
                CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) pParentNode, DHCPSNAP_UPDATE_OPTIONS) ); 

            break;
        }
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnNotifyExiting
                CMTDhcpHandler overridden functionality
                allows us to know when the background thread is done
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpReservationClient::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        spNode.Set(m_spNode); // save this off because OnNotifyExiting will release it

        HRESULT hr = CMTDhcpHandler::OnNotifyExiting(lParam);

    UpdateResultMessage(spNode);

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::OnResultUpdateView
                Implementation of ITFSResultHandler::OnResultUpdateView
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpReservationClient::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM          data, 
    LPARAM          hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
                return S_OK; // no selection for our IComponentData

    if ( hint == DHCPSNAP_UPDATE_OPTIONS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        EnumerateResultPane(pComponent, (MMC_COOKIE) spSelectedNode.p, 0, 0);
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CMTDhcpHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpReservationClient::EnumerateResultPane
                We override this function for the options nodes for one reason.
        Whenever an option class is deleted, then all options defined for
        that class will be removed as well.  Since there are multiple places
        that these options may show up, it's easier to just not show any
        options that don't have a class defined for it.  
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::EnumerateResultPane
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM            arg, 
    LPARAM            lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CClassInfoArray     ClassInfoArray;
        SPITFSNode          spContainer, spServerNode;
    CDhcpServer *       pServer;
    COptionValueEnum *  aEnum[3];
    int                 aImages[3] = {ICON_IDX_CLIENT_OPTION_LEAF, ICON_IDX_SCOPE_OPTION_LEAF, ICON_IDX_SERVER_OPTION_LEAF};

    m_spNodeMgr->FindNode(cookie, &spContainer);

    spServerNode = GetServerNode(spContainer, TRUE);
    pServer = GETHANDLER(CDhcpServer, spServerNode);

    pServer->GetClassInfoArray(ClassInfoArray);

    aEnum[0] = GetOptionValueEnum();
    aEnum[1] = GetScopeObject(spContainer, TRUE)->GetOptionValueEnum();
    aEnum[2] = pServer->GetOptionValueEnum();

    aEnum[0]->Reset();
    aEnum[1]->Reset();
    aEnum[2]->Reset();

    return OnResultUpdateOptions(pComponent, spContainer, &ClassInfoArray, aEnum, aImages, 3);
}

/*---------------------------------------------------------------------------
        Helper functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservationClient::GetDnsRegistration
                Gets the DNS registration option value
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpReservationClient::GetDnsRegistration
(
        ITFSNode *      pNode,
        LPDWORD         pDnsRegOption
)
{
    //
    // Check option 81 -- the DNS registration option
    //
        CDhcpScope * pScope = GetScopeObject(pNode, TRUE);

    DHCP_OPTION_VALUE * poptValue = NULL;
    DWORD err = pScope->GetOptionValue(OPTION_DNS_REGISTATION,    
                                                                           DhcpReservedOptions,
                                                                           &poptValue,
                                                                           m_dhcpClientIpAddress);
        
        // this is the default
        if (pDnsRegOption)
                *pDnsRegOption = DHCP_DYN_DNS_DEFAULT;

        if (err == ERROR_SUCCESS)
        {
                if ((poptValue->Value.Elements != NULL) &&
                        (pDnsRegOption))
                {
                        *pDnsRegOption = poptValue->Value.Elements[0].Element.DWordOption;
                }
        }
        else
    {
        Trace0("CDhcpReservationClient::GetDnsRegistration - couldn't get DNS reg value -- \
                        option may not be defined, Getting Scope value.\n");
        
                err = pScope->GetDnsRegistration(pDnsRegOption);
    }

        if (poptValue)
                ::DhcpRpcFreeMemory(poptValue);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::SetDnsRegistration
                Sets the DNS Registration option for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpReservationClient::SetDnsRegistration
(
        ITFSNode *       pNode,
        DWORD            DnsRegOption
)
{
        CDhcpScope * pScope = GetScopeObject(pNode, TRUE);
        DWORD err = 0;

        //
    // Set DNS name registration (option 81)
        //
    CDhcpOption dhcpOption (OPTION_DNS_REGISTATION,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(DnsRegOption);
    
        err = pScope->SetOptionValue(&dhcpOption, DhcpReservedOptions, m_dhcpClientIpAddress);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::BuildDisplayName
                Builds the display name string
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpReservationClient::BuildDisplayName
(
        CString * pstrDisplayName,
        LPCTSTR   pIpAddress,
        LPCTSTR   pName
)
{
        if (pstrDisplayName)
        {
                CString strTemp = pIpAddress;
                strTemp = L"[" + strTemp + L"]";
                
                if (pName)
                {
                        CString strName = pName;
                        strTemp += L" " + strName;
                }
        
                *pstrDisplayName = strTemp;
        }

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::BuildDisplayName
                Updates the cached name for this reservation and updates the UI
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::SetName
(
        LPCTSTR pName
)
{
        if (pName != NULL)      
        {
                if (m_pstrClientName)
                {
                        *m_pstrClientName = pName;
                }
                else
                {
                        m_pstrClientName = new CString(pName);
                }
        }
        else
        {
                if (m_pstrClientName)
                {
                        delete m_pstrClientName;
                        m_pstrClientName = NULL;
                }
        }

        CString strIpAddress, strDisplayName;
        
        //
        // Create the display name for this scope
        // Convert DHCP_IP_ADDRES to a string and initialize this object
        //
        UtilCvtIpAddrToWstr (m_dhcpClientIpAddress,
                                                 &strIpAddress);
        
        BuildDisplayName(&strDisplayName, strIpAddress, pName);

        SetDisplayName(strDisplayName);
        
        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::BuildDisplayName
                Updates the cached comment for this reservation
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::SetComment
(
        LPCTSTR pComment
)
{
        if (pComment != NULL)   
        {
                if (m_pstrClientComment)
                {
                        *m_pstrClientComment = pComment;
                }
                else
                {
                        m_pstrClientComment = new CString(pComment);
                }
        }
        else
        {
                if (m_pstrClientComment)
                {
                        delete m_pstrClientComment;
                        m_pstrClientComment = NULL;
                }
        }

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::SetUID
                Updates the cached unique ID for this reservation
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpReservationClient::SetUID
(
        const CByteArray & baClientUID
)
{
        m_baHardwareAddress.Copy(baClientUID);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClient::SetClientType
                Updates the cached client type for this record
        Author: EricDav
 ---------------------------------------------------------------------------*/
BYTE    
CDhcpReservationClient::SetClientType
(
    BYTE bClientType
) 
{ 
    BYTE bRet = m_bClientType; 
    m_bClientType = bClientType; 
    
    return bRet; 
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpReservationClient::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpReservationClient::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpReservationClientQueryObj* pQuery = 
                new CDhcpReservationClientQueryObj(m_spTFSCompData, m_spNodeMgr);

        pQuery->m_strServer = GetServerIpAddress(pNode, TRUE);
        pQuery->m_dhcpScopeAddress = GetScopeObject(pNode, TRUE)->GetAddress();
        pQuery->m_dhcpClientIpAddress = m_dhcpClientIpAddress;
        
    GetScopeObject(pNode, TRUE)->GetServerVersion(pQuery->m_liDhcpVersion);
    GetScopeObject(pNode, TRUE)->GetDynBootpClassName(pQuery->m_strDynBootpClassName);

    pQuery->m_dhcpResumeHandle = NULL;
        pQuery->m_dwPreferredMax = 0xFFFFFFFF;

        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpReservationClientQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpReservationClientQueryObj::Execute()
{
    DWORD                   dwErr;
    COptionNodeEnum         OptionNodeEnum(m_spTFSCompData, m_spNodeMgr);
        DHCP_OPTION_SCOPE_INFO  dhcpOptionScopeInfo;
    
    COptionValueEnum * pOptionValueEnum = new COptionValueEnum;
    pOptionValueEnum->m_strDynBootpClassName = m_strDynBootpClassName;

        dhcpOptionScopeInfo.ScopeType = DhcpReservedOptions;
        dhcpOptionScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress = m_dhcpClientIpAddress;
        dhcpOptionScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress = m_dhcpScopeAddress;

    pOptionValueEnum->Init(m_strServer, m_liDhcpVersion, dhcpOptionScopeInfo);
    dwErr = pOptionValueEnum->Enum();

    // add all of the nodes 
    if (dwErr != ERROR_SUCCESS)
    {
        Trace1("CDhcpReservationClientQueryObj::Execute - Enum Failed! %d\n", dwErr);
        m_dwErr = dwErr;
        PostError(dwErr);

        delete pOptionValueEnum;
    }
    else
    {
        pOptionValueEnum->SortById();
        AddToQueue((LPARAM) pOptionValueEnum, DHCP_QDATA_OPTION_VALUES);
    }

    return hrFalse;
}

/////////////////////////////////////////////////////////////////////
// 
// CDhcpActiveLeases implementation
//
/////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpActiveLeases::CDhcpActiveLeases
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CDhcpActiveLeases::~CDhcpActiveLeases()
{
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLeases::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLeases::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_ACTIVE_LEASES_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ACTIVE_LEASES);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpActiveLeases::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strIpAddress, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    DHCP_IP_ADDRESS dhcpIpAddress = GetScopeObject(pNode)->GetAddress();

    UtilCvtIpAddrToWstr (dhcpIpAddress, &strIpAddress);

    strId = GetServerName(pNode) + strIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpActiveLeases::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_LOST_CONNECTION;
            else
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_LOST_CONNECTION;
                        break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}


/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpActiveLeases::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                        /* removed, using new MMC save list functionality
                    strMenuText.LoadString(IDS_EXPORT_LEASE_INFO);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_EXPORT_LEASE_INFO,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
                        */
        }
        
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpActiveLeases::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

        case IDS_EXPORT_LEASE_INFO:
            OnExportLeases(pNode);
            break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpActiveLeases::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE      cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;
        BOOL bIsRes, bIsActive, bBadAddress;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spActiveLeases, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spActiveLeases);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spActiveLeases);
        if (spSelectedNode != spActiveLeases)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int) listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

        //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spActiveLeaseNode;
                spActiveLeaseNode = listNodesToDelete.RemoveHead();
                CDhcpActiveLease * pActiveLease = GETHANDLER(CDhcpActiveLease, spActiveLeaseNode);
                
                //
                // delete the node, check to see if it is a reservation
                //
                bIsRes = pActiveLease->IsReservation(&bIsActive, &bBadAddress);
                if (bIsRes && !bBadAddress)
                {
                        //
                        // Delete the reservation
                        //
                        LPDHCP_CLIENT_INFO pdhcpClientInfo;

                        DWORD dwError = GetScopeObject(spActiveLeases)->GetClientInfo(pActiveLease->GetIpAddress(), &pdhcpClientInfo);
                        if (dwError == ERROR_SUCCESS)
                        {       
                                dwError = GetScopeObject(spActiveLeases)->DeleteReservation(pdhcpClientInfo->ClientHardwareAddress, 
                                                                                                                pdhcpClientInfo->ClientIpAddress);      
                                if (dwError == ERROR_SUCCESS)
                                {
                                        //
                                        // Tell the reservations folder to remove this from it's list
                                        //
                                        SPITFSNode spReservationsNode;
                                        GetScopeObject(spActiveLeases)->GetReservationsNode(&spReservationsNode);
                                        
                                        GetScopeObject(spActiveLeases)->GetReservationsObject()->
                                                                RemoveReservationFromUI((ITFSNode *) spReservationsNode, pActiveLease->GetIpAddress());

                                        spActiveLeases->RemoveChild(spActiveLeaseNode);
                                }
                                else
                                {
                    UtilCvtIpAddrToWstr(pActiveLease->GetIpAddress(), &strTemp);
                    AfxFormatString1(strMessage, IDS_ERROR_DELETING_RECORD, (LPCTSTR) strTemp);
                
                                    if (::DhcpMessageBoxEx(dwError, strMessage, MB_OKCANCEL) == IDCANCEL)
                    {
                        break;
                    }
                    RESTORE_WAIT_CURSOR;

                                        Trace1("Delete reservation failed %lx\n", dwError);
                                        hr = E_FAIL;
                                }

                                ::DhcpRpcFreeMemory(pdhcpClientInfo);
                        }
                        else
                        {
                UtilCvtIpAddrToWstr(pActiveLease->GetIpAddress(), &strTemp);
                AfxFormatString1(strMessage, IDS_ERROR_DELETING_RECORD, (LPCTSTR) strTemp);
                
                                if (::DhcpMessageBoxEx(dwError, strMessage, MB_OKCANCEL) == IDCANCEL)
                {
                    break;
                }
                RESTORE_WAIT_CURSOR;

                                Trace1("GetClientInfo failed %lx\n", dwError);
                                hr = E_FAIL;
                        }

                }
                else
                {
                        DWORD dwError = GetScopeObject(spActiveLeases)->DeleteClient(pActiveLease->GetIpAddress());
                        if (dwError == ERROR_SUCCESS)
                        {
                                //
                                // Client gone, now remove from UI
                                //
                spActiveLeases->RemoveChild(spActiveLeaseNode);

                // if we are deleting a lot of addresses, then we can hit the server hard..
                // lets take a short time out to smooth out the process
                Sleep(5);
                        }
                        else
                        {
                UtilCvtIpAddrToWstr(pActiveLease->GetIpAddress(), &strTemp);
                AfxFormatString1(strMessage, IDS_ERROR_DELETING_RECORD, (LPCTSTR) strTemp);
                
                                if (::DhcpMessageBoxEx(dwError, strMessage, MB_OKCANCEL) == IDCANCEL)
                {
                    break;
                }

                RESTORE_WAIT_CURSOR;

                Trace1("DhcpDeleteClientInfo failed %lx\n", dwError);
                                hr = E_FAIL;
                        }
                }

                spActiveLeaseNode.Release();
        }
    
    // update stats
    GetScopeObject(spActiveLeases)->TriggerStatsRefresh();

    END_WAIT_CURSOR;

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::DeleteClient
                The reservations object will call this when a reservation is 
                deleted.  Since a reservation also has an active lease record, 
                we have to delete it as well.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpActiveLeases::DeleteClient
(
        ITFSNode *                      pActiveLeasesNode,
        DHCP_IP_ADDRESS         dhcpIpAddress
)
{
        DWORD                           dwError = E_UNEXPECTED;
        CDhcpActiveLease *      pActiveLease = NULL;
    
        SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    pActiveLeasesNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                pActiveLease = GETHANDLER(CDhcpActiveLease, spCurrentNode);

                if (dhcpIpAddress == pActiveLease->GetIpAddress())
                {
                        //
                        // Tell this reservation to delete itself
                        //
                        pActiveLeasesNode->RemoveChild(spCurrentNode);
                spCurrentNode.Release();
                        dwError = ERROR_SUCCESS;
                        
                        break;
                }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
        
        return dwError;
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLeases::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpActiveLeases::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpActiveLeases::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpActiveLease *pDhcpAL1 = GETHANDLER(CDhcpActiveLease, spNode1);
        CDhcpActiveLease *pDhcpAL2 = GETHANDLER(CDhcpActiveLease, spNode2);

        switch (nCol)
        {
                case 0:
                        {
                                // IP address compare
                                //
                                nCompare = CompareIpAddresses(pDhcpAL1, pDhcpAL2);
                        }
                        break;
                
                case 1:
                        {
                                // Client Name compare
                                //
                                CString strAL1 = pDhcpAL1->GetString(pComponent, cookieA, nCol);
                                CString strAL2 = pDhcpAL2->GetString(pComponent, cookieA, nCol);

                                nCompare = strAL1.CompareNoCase(strAL2);
                        }
                        break;
                
                case 2:
                        {
                                // Lease expiration compare
                                //
                                BOOL  bIsActive1, bIsActive2;
                                BOOL  bIsBad1, bIsBad2;
                                
                                BOOL bIsRes1 = pDhcpAL1->IsReservation(&bIsActive1, &bIsBad1);
                                BOOL bIsRes2 = pDhcpAL2->IsReservation(&bIsActive2, &bIsBad2);
                                
                                // 
                                // Check to see if these are reservations
                                //
                                if (bIsRes1 && bIsRes2)
                                {
                                        //
                                        // Figure out if this is a bad address
                                        // They go first 
                                        //
                                        if (bIsBad1 && bIsBad2)
                                        {
                                                //
                                                // Sort by IP Address
                                                //
                                                nCompare = CompareIpAddresses(pDhcpAL1, pDhcpAL2);
                                        }
                                        else 
                                        if (bIsBad1)
                                                nCompare = -1;
                                        else
                                        if (bIsBad2)
                                                nCompare = 1;
                                        else
                                        if ((bIsActive1 && bIsActive2) ||
                                                (!bIsActive1 && !bIsActive2))
                                        {
                                                //
                                                // if both reservations are either active/inactive
                                                // sort by IP address
                                                //
                                                nCompare = CompareIpAddresses(pDhcpAL1, pDhcpAL2);
                                        }
                                        else
                                        if (bIsActive1)
                                                nCompare = -1;
                                        else
                                                nCompare = 1;
                                }
                                else 
                                if (bIsRes1)
                                {
                                        nCompare = -1;
                                }
                                else 
                                if (bIsRes2)
                                {       
                                        nCompare = 1;
                                }
                                else
                                {
                                        CTime timeAL1, timeAL2;
                
                                        pDhcpAL1->GetLeaseExpirationTime(timeAL1);
                                        pDhcpAL2->GetLeaseExpirationTime(timeAL2);
                                
                                        if (timeAL1 < timeAL2)
                                                nCompare = -1;
                                        else
                                        if (timeAL1 > timeAL2)
                                                nCompare = 1;
                                }

                                // default is that they are equal
                        }
                        break;
                
                case 3:
                        {
                                // Client Type Compare
                                CString strAL1 = pDhcpAL1->GetString(pComponent, cookieA, nCol);
                                CString strAL2 = pDhcpAL2->GetString(pComponent, cookieA, nCol);

                                nCompare = strAL1.Compare(strAL2);
                        }
                        break;
                
                case 4:
                        {
                                CString strUID1 = pDhcpAL1->GetUID();

                                nCompare =      strUID1.CompareNoCase(pDhcpAL2->GetUID());
                        }
                        break;

                case 5:
                        {
                                CString strComment1 = pDhcpAL1->GetComment();

                                nCompare =      strComment1.CompareNoCase(pDhcpAL2->GetComment());
                        }
                        break;
        }
                
        return nCompare;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int
CDhcpActiveLeases::CompareIpAddresses
(
        CDhcpActiveLease * pDhcpAL1,
        CDhcpActiveLease * pDhcpAL2
)
{
        int     nCompare = 0;

        DHCP_IP_ADDRESS dhcpIp1 = pDhcpAL1->GetIpAddress();
        DHCP_IP_ADDRESS dhcpIp2 = pDhcpAL2->GetIpAddress();
        
        if (dhcpIp1 < dhcpIp2)
                nCompare = -1;
        else
        if (dhcpIp1 > dhcpIp2)
                nCompare =  1;

        return nCompare;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnExportLeases()
                -
        Author: EricDav
---------------------------------------------------------------------------*/
HRESULT 
CDhcpActiveLeases::OnExportLeases(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

        // Bring up the Save Dialog
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;

    CString strType;
        CString strDefFileName;
        CString strFilter;
        CString strTitle;
    CString strFileName;

    strType.LoadString(IDS_FILE_EXTENSION);
        strDefFileName.LoadString(IDS_FILE_DEFNAME);
    strFilter.LoadString(IDS_STR_EXPORTFILE_FILTER);
        
        CFileDialog     cFileDlg(FALSE, strType, strDefFileName, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, strFilter);//_T("Comma Separated Files (*.csv)|*.csv||") );
        
        strTitle.LoadString(IDS_EXPFILE_TITLE);
        cFileDlg.m_ofn.lpstrTitle  = strTitle;

    // put up the file dialog
    if( cFileDlg.DoModal() != IDOK )
                return hrFalse;

        strFileName = cFileDlg.GetPathName();

        COM_PROTECT_TRY
    {
                CString strContent;
                CString strLine;
        CString strTemp;
                CString strDelim = _T(',');
                CString strNewLine = _T("\r\n");
        int nCount = 0;

                // create a file named "WinsExp.txt" in the current directory
                CFile cFileExp(strFileName, CFile::modeCreate | CFile::modeRead | CFile::modeWrite);

        // this is a unicode file, write the unicde lead bytes (2)
        cFileExp.Write(&gwUnicodeHeader, sizeof(WORD));

        // write the header
        for (int i = 0; i < MAX_COLUMNS; i++)
        {
            if (aColumns[DHCPSNAP_ACTIVE_LEASES][i])
            {
                if (!strLine.IsEmpty())
                    strLine += strDelim;

                strTemp.LoadString(aColumns[DHCPSNAP_ACTIVE_LEASES][i]);
                strLine += strTemp;
            }
        }

        strLine += strNewLine;
        cFileExp.Write(strLine, strLine.GetLength()*sizeof(TCHAR));
                cFileExp.SeekToEnd();

                BEGIN_WAIT_CURSOR

                #ifdef DEBUG
                CTime timeStart, timeFinish;
                timeStart = CTime::GetCurrentTime();
                #endif

        // enumerate all the leases and output
        pNode->GetEnum(&spNodeEnum);

            spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
            {
            CDhcpActiveLease * pLease = GETHANDLER(CDhcpActiveLease, spCurrentNode);
                        
            strLine.Empty();

            // ipaddr, name, type, lease exp, UID, comment
            for (int j = 0; j < 6; j++)
            {
                if (!strLine.IsEmpty())
                    strLine += strDelim;
                strLine += pLease->GetString(NULL, NULL, j);
            }
            
            strLine += strNewLine;
            strContent += strLine;

            nCount++;
            
                        //optimize
                        // write to the file for every 1000 records converted
                        if( nCount % 1000 == 0)
                        {
                                cFileExp.Write(strContent, strContent.GetLength() * (sizeof(TCHAR)) );
                                cFileExp.SeekToEnd();
                                
                                // clear all the strings now
                                strContent.Empty();
                        }

            spCurrentNode.Release();
            spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
        
                // write to the file
                cFileExp.Write(strContent, strContent.GetLength() * (sizeof(TCHAR)) );
                cFileExp.Close();

                #ifdef DEBUG
                timeFinish = CTime::GetCurrentTime();
                CTimeSpan timeDelta = timeFinish - timeStart;
                Trace2("ActiveLeases - Export Entries: %d records written, total time %s\n", nCount, timeDelta.Format(_T("%H:%M:%S")));
                #endif

        END_WAIT_CURSOR
        }
        COM_PROTECT_CATCH

        CString strDisp;
        AfxFormatString1(strDisp, IDS_EXPORT_SUCCESS, strFileName);

        AfxMessageBox(strDisp, MB_ICONINFORMATION );

        return hr;
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
        CDhcpActiveLeases::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpActiveLeases::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpActiveLeasesQueryObj* pQuery = 
                new CDhcpActiveLeasesQueryObj(m_spTFSCompData, m_spNodeMgr);
        
        pQuery->m_strServer = GetServerIpAddress(pNode);
        
        pQuery->m_dhcpScopeAddress = GetScopeObject(pNode)->GetAddress();
        pQuery->m_dhcpResumeHandle = NULL;
        pQuery->m_dwPreferredMax = 2000;
        GetServerVersion(pNode, pQuery->m_liDhcpVersion);
        
        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpActiveLeasesQueryObj::Execute()
{
        HRESULT hr;

    BuildReservationList();

    if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
                hr = EnumerateLeasesV5();
        }
        else
        if (m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
        {
                hr = EnumerateLeasesV4();
        }
        else
        {
                hr = EnumerateLeases();
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::IsReservation()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpActiveLeasesQueryObj::IsReservation(DWORD dwIp)
{
    BOOL fIsRes = FALSE;

    for (int i = 0; i < m_ReservationArray.GetSize(); i++)
    {
        if (m_ReservationArray[i] == dwIp)
        {
            fIsRes = TRUE;
            break;
        }
    }

    return fIsRes;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::BuildReservationList()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLeasesQueryObj::BuildReservationList()
{
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY pdhcpSubnetElementArray = NULL;
    DHCP_RESUME_HANDLE  dhcpResumeHandle = NULL;
        DWORD                           dwElementsRead = 0, dwElementsTotal = 0;
    DWORD               dwError = ERROR_MORE_DATA;

        while (dwError == ERROR_MORE_DATA)
        {
            dwError = ::DhcpEnumSubnetElements(((LPWSTR) (LPCTSTR)m_strServer),
                                                                               m_dhcpScopeAddress,
                                                                               DhcpReservedIps,
                                                                               &dhcpResumeHandle,
                                                                               -1,
                                                                               &pdhcpSubnetElementArray,
                                                                               &dwElementsRead,
                                           &dwElementsTotal);

        Trace3("BuildReservationList: Scope %lx Reservations read %d, total %d\n", m_dhcpScopeAddress, dwElementsRead, dwElementsTotal);
                
                if (dwElementsRead && dwElementsTotal && pdhcpSubnetElementArray)
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                            m_ReservationArray.Add(pdhcpSubnetElementArray->Elements[i].Element.ReservedIp->ReservedIpAddress);
            }
        }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: BuildReservationList error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::EnumerateLeasesV5()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLeasesQueryObj::EnumerateLeasesV5()
{
        DWORD                                           dwError = ERROR_MORE_DATA;
        LPDHCP_CLIENT_INFO_ARRAY_V5     pdhcpClientArrayV5 = NULL;
        DWORD                                           dwClientsRead = 0, dwClientsTotal = 0;
        DWORD                                           dwEnumedClients = 0;

        while (dwError == ERROR_MORE_DATA)
        {
        dwError = ::DhcpEnumSubnetClientsV5(((LPWSTR) (LPCTSTR)m_strServer),
                                                                                        m_dhcpScopeAddress,
                                                                                        &m_dhcpResumeHandle,
                                                                                        m_dwPreferredMax,
                                                                                        &pdhcpClientArrayV5,
                                                                                        &dwClientsRead,
                                                                                        &dwClientsTotal);
                if (dwClientsRead && dwClientsTotal && pdhcpClientArrayV5)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        for (DWORD i = 0; i < dwClientsRead; i++)
                        {
                                CDhcpActiveLease * pDhcpActiveLease;
                                
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                pDhcpActiveLease = 
                                        new CDhcpActiveLease(m_spTFSCompData, pdhcpClientArrayV5->Clients[i]);
                        
                // filter these types of records out
                if (pDhcpActiveLease->IsUnreg())
                {
                    delete pDhcpActiveLease;
                    continue;
                }

                if (IsReservation(pdhcpClientArrayV5->Clients[i]->ClientIpAddress))
                    pDhcpActiveLease->SetReservation(TRUE);

                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpActiveLeaseNodeType,
                                                                  pDhcpActiveLease,
                                                                  pDhcpActiveLease,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpActiveLease->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpActiveLease->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpClientArrayV5);
                
                        dwEnumedClients += dwClientsRead;
                        dwClientsRead = 0;
                        dwClientsTotal = 0;
                        pdhcpClientArrayV5 = NULL;
                }
                
                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;
            
        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateLeasesV5 error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        Trace1("DHCP snapin: V5 Leases enumerated: %d\n", dwEnumedClients);
        return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::EnumerateLeasesV4()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLeasesQueryObj::EnumerateLeasesV4()
{
        DWORD                                           dwError = ERROR_MORE_DATA;
        LPDHCP_CLIENT_INFO_ARRAY_V4     pdhcpClientArrayV4 = NULL;
        DWORD                                           dwClientsRead = 0, dwClientsTotal = 0;
        DWORD                                           dwEnumedClients = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetClientsV4(((LPWSTR) (LPCTSTR)m_strServer),
                                                                                        m_dhcpScopeAddress,
                                                                                        &m_dhcpResumeHandle,
                                                                                        m_dwPreferredMax,
                                                                                        &pdhcpClientArrayV4,
                                                                                        &dwClientsRead,
                                                                                        &dwClientsTotal);
                
                if (dwClientsRead && dwClientsTotal && pdhcpClientArrayV4)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        //for (DWORD i = 0; i < pdhcpClientArrayV4->NumElements; i++)
                        for (DWORD i = 0; i < dwClientsRead; i++)
                        {
                                CDhcpActiveLease * pDhcpActiveLease;
                                
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                pDhcpActiveLease = 
                                        new CDhcpActiveLease(m_spTFSCompData, pdhcpClientArrayV4->Clients[i]);
                                
                // filter these types of records out
                if (pDhcpActiveLease->IsGhost() ||
                    pDhcpActiveLease->IsUnreg() ||
                    pDhcpActiveLease->IsDoomed() )
                {
                    delete pDhcpActiveLease;
                    continue;
                }

                if (IsReservation(pdhcpClientArrayV4->Clients[i]->ClientIpAddress))
                    pDhcpActiveLease->SetReservation(TRUE);

                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpActiveLeaseNodeType,
                                                                  pDhcpActiveLease,
                                                                  pDhcpActiveLease,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpActiveLease->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpActiveLease->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpClientArrayV4);
                
                        dwEnumedClients += dwClientsRead;
                        dwClientsRead = 0;
                        dwClientsTotal = 0;
                        pdhcpClientArrayV4 = NULL;
                }
                
                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateLeasesV4 error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        Trace1("DHCP snapin: V4 Leases enumerated: %d\n", dwEnumedClients);
        return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpActiveLeasesQueryObj::EnumerateLeases()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLeasesQueryObj::EnumerateLeases()
{
        DWORD                                           dwError = ERROR_MORE_DATA;
        LPDHCP_CLIENT_INFO_ARRAY        pdhcpClientArray = NULL;
        DWORD                                           dwClientsRead = 0, dwClientsTotal = 0;
        DWORD                                           dwEnumedClients = 0;
        
        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetClients(((LPWSTR) (LPCTSTR)m_strServer),
                                                                                  m_dhcpScopeAddress,
                                                                                  &m_dhcpResumeHandle,
                                                                                  m_dwPreferredMax,
                                                                                  &pdhcpClientArray,
                                                                                  &dwClientsRead,
                                                                                  &dwClientsTotal);
                if (dwClientsRead && dwClientsTotal && pdhcpClientArray)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        for (DWORD i = 0; i < pdhcpClientArray->NumElements; i++)
                        {
                                CDhcpActiveLease * pDhcpActiveLease;
                                
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                pDhcpActiveLease = 
                                        new CDhcpActiveLease(m_spTFSCompData,pdhcpClientArray->Clients[i]);
                                
                // filter these types of records out
                if (pDhcpActiveLease->IsGhost() ||
                    pDhcpActiveLease->IsUnreg() ||
                    pDhcpActiveLease->IsDoomed() )
                {
                    delete pDhcpActiveLease;
                    continue;
                }

                if (IsReservation(pdhcpClientArray->Clients[i]->ClientIpAddress))
                    pDhcpActiveLease->SetReservation(TRUE);

                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpActiveLeaseNodeType,
                                                                  pDhcpActiveLease,
                                                                  pDhcpActiveLease,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpActiveLease->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpActiveLease->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpClientArray);

                        dwEnumedClients += dwClientsRead;
        
                        dwClientsRead = 0;
                        dwClientsTotal = 0;
                        pdhcpClientArray = NULL;
                }
                
                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateLeases error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        Trace1("DHCP snpain: Leases enumerated: %d\n", dwEnumedClients);
        return hrFalse;
}

/*---------------------------------------------------------------------------
        Class CDhcpAddressPool implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpAddressPool::CDhcpAddressPool
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CDhcpAddressPool::~CDhcpAddressPool()
{
}

/*!--------------------------------------------------------------------------
        CDhcpAddressPool::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpAddressPool::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_ADDRESS_POOL_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ADDRESS_POOL);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_ADDRESS_POOL][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_ADDRESS_POOL][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpAddressPool::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strIpAddress, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    DHCP_IP_ADDRESS dhcpIpAddress = GetScopeObject(pNode)->GetAddress();

    UtilCvtIpAddrToWstr (dhcpIpAddress, &strIpAddress);

    strId = GetServerName(pNode) + strIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpAddressPool::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpAddressPool::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                            nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN_LOST_CONNECTION;
            else
                            nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED_LOST_CONNECTION;
                        break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}


/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpAddressPool::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
                // these menu items go in the new menu, 
                // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuText.LoadString(IDS_CREATE_NEW_EXCLUSION);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_CREATE_NEW_EXCLUSION,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpAddressPool::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_NEW_EXCLUSION:
                        OnCreateNewExclusion(pNode);
                        break;
        
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        Message handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnCreateNewExclusion
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpAddressPool::OnCreateNewExclusion
(
        ITFSNode *              pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spScopeNode;
        pNode->GetParent(&spScopeNode);

        CAddExclusion dlgAddExclusion(spScopeNode);

        dlgAddExclusion.DoModal();

        return 0;
}

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpAddressPool::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = NOERROR;
        BOOL bIsRes, bIsActive, bBadAddress;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spAddressPool, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spAddressPool);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spAddressPool);
        if (spSelectedNode != spAddressPool)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int)listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

        //
        // Loop through all items deleting
        //
        BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spExclusionRangeNode;
                spExclusionRangeNode = listNodesToDelete.RemoveHead();
                
                CDhcpExclusionRange * pExclusion = GETHANDLER(CDhcpExclusionRange, spExclusionRangeNode);
                
                if (spExclusionRangeNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {       
                        //
                        // This is the allocation range, can't delete
                        //
                        AfxMessageBox(IDS_CANNOT_DELETE_ALLOCATION_RANGE);
                        spExclusionRangeNode.Release();
                        continue;
                }

                //
                // Try to remove it from the server
                //
                CDhcpIpRange dhcpIpRange((DHCP_IP_RANGE) *pExclusion);

                DWORD dwError = GetScopeObject(spAddressPool)->RemoveExclusion(dhcpIpRange);
                if (dwError != 0)
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

                        hr = E_FAIL;
                        continue;
                }

                //
                // Remove from UI now
                //
                spAddressPool->RemoveChild(spExclusionRangeNode);
                spExclusionRangeNode.Release();
        }

    // update stats
    GetScopeObject(spAddressPool)->TriggerStatsRefresh();

    END_WAIT_CURSOR;

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpAddressPool::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpAddressPool::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpAddressPool::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpAddressPool::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpAddressPoolQueryObj* pQuery = 
                new CDhcpAddressPoolQueryObj(m_spTFSCompData, m_spNodeMgr);
        
        pQuery->m_strServer = GetServerIpAddress(pNode);
        
        CDhcpScope * pScope = GetScopeObject(pNode);
        if (pScope) 
    {
                pQuery->m_dhcpScopeAddress = pScope->GetAddress();
        pQuery->m_fSupportsDynBootp = pScope->GetServerObject()->FSupportsDynBootp();
    }

        pQuery->m_dhcpExclResumeHandle = NULL;
        pQuery->m_dwExclPreferredMax = 0xFFFFFFFF;
        
        pQuery->m_dhcpIpResumeHandle = NULL;
        pQuery->m_dwIpPreferredMax = 0xFFFFFFFF;

        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpAddressPoolQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpAddressPoolQueryObj::Execute()
{
        HRESULT hr1 = EnumerateIpRanges();
        HRESULT hr2 = EnumerateExcludedIpRanges();
        
        if (hr1 == hrOK || hr2 == hrOK)
                return hrOK;
        else
                return hrFalse;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpAddressPoolQueryObj::EnumerateExcludedIpRanges()
{
        DWORD                                                    dwError = ERROR_MORE_DATA;
        DHCP_RESUME_HANDLE                               dhcpResumeHandle = 0;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY pdhcpSubnetElementArray = NULL;
        DWORD                                                    dwElementsRead = 0, dwElementsTotal = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetElements((LPWSTR) ((LPCTSTR) m_strServer),
                                                                                   m_dhcpScopeAddress,
                                                                                   DhcpExcludedIpRanges,
                                                                                   &m_dhcpExclResumeHandle,
                                                                                   m_dwExclPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);
                
                Trace3("Scope %lx Excluded Ip Ranges read %d, total %d\n", m_dhcpScopeAddress, dwElementsRead, dwElementsTotal);
                
                if (dwElementsRead && dwElementsTotal && pdhcpSubnetElementArray)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                CDhcpExclusionRange * pDhcpExclusionRange = 
                                        new CDhcpExclusionRange(m_spTFSCompData,
                                                                                        pdhcpSubnetElementArray->Elements[i].Element.ExcludeIpRange);
                                
                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpExclusionNodeType,
                                                                  pDhcpExclusionRange,
                                                                  pDhcpExclusionRange,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpExclusionRange->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpExclusionRange->Release();
                        }

                        // Free up the memory from the RPC call
                        //
                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);
                }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateExcludedIpRanges error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpAddressPoolQueryObj::EnumerateIpRanges()
{
        DWORD                                                    dwError = ERROR_MORE_DATA;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY pdhcpSubnetElementArray = NULL;
        DWORD                                                    dwElementsRead = 0, dwElementsTotal = 0;

        if (m_fSupportsDynBootp)
        {
                return EnumerateIpRangesV5();
        }

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetElements((LPWSTR) ((LPCTSTR) m_strServer),
                                                                                   m_dhcpScopeAddress,
                                                                                   DhcpIpRanges,
                                                                                   &m_dhcpIpResumeHandle,
                                                                                   m_dwIpPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);
                
                Trace4("Scope %lx allocation ranges read %d, total %d, dwError = %lx\n", 
                        m_dhcpScopeAddress, dwElementsRead, dwElementsTotal, dwError);
                
                if ((dwError == ERROR_MORE_DATA) ||
                        ( (dwElementsRead) && (dwError == ERROR_SUCCESS) ))
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                CDhcpAllocationRange * pDhcpAllocRange = 
                                        new CDhcpAllocationRange(m_spTFSCompData, 
                                                                                        pdhcpSubnetElementArray->Elements[i].Element.IpRange);
                                
                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpAllocationNodeType,
                                                                  pDhcpAllocRange,
                                                                  pDhcpAllocRange,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpAllocRange->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpAllocRange->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);
                }
        else
        if (dwError != ERROR_SUCCESS &&
            dwError != ERROR_NO_MORE_ITEMS)
        {
            // set the error variable so that it can be looked at later
            m_dwError = dwError;
        }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateAllocationRanges error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
}

HRESULT
CDhcpAddressPoolQueryObj::EnumerateIpRangesV5()
{
        DWORD                                                           dwError = ERROR_MORE_DATA;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 pdhcpSubnetElementArray = NULL;
        DWORD                                                           dwElementsRead = 0, dwElementsTotal = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnetElementsV5((LPWSTR) ((LPCTSTR) m_strServer),
                                                                                   m_dhcpScopeAddress,
                                                                                   DhcpIpRangesDhcpBootp,
                                                                                   &m_dhcpIpResumeHandle,
                                                                                   m_dwIpPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);
                
                Trace4("EnumerateIpRangesV5: Scope %lx allocation ranges read %d, total %d, dwError = %lx\n", 
                        m_dhcpScopeAddress, dwElementsRead, dwElementsTotal, dwError);
                
                if ((dwError == ERROR_MORE_DATA) ||
                        ( (dwElementsRead) && (dwError == ERROR_SUCCESS) ))
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                CDhcpAllocationRange * pDhcpAllocRange = 
                                        new CDhcpAllocationRange(m_spTFSCompData, 
                                                                                        pdhcpSubnetElementArray->Elements[i].Element.IpRange);
                                pDhcpAllocRange->SetRangeType(pdhcpSubnetElementArray->Elements[i].ElementType);

                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpAllocationNodeType,
                                                                  pDhcpAllocRange,
                                                                  pDhcpAllocRange,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpAllocRange->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpAllocRange->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);
                }
        else
        if (dwError != ERROR_SUCCESS &&
            dwError != ERROR_NO_MORE_ITEMS)
        {
            // set the error variable so that it can be looked at later
            m_dwError = dwError;
        }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateAllocationRanges error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpAddressPool::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpAddressPool::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpAllocationRange *pDhcpAR1 = GETHANDLER(CDhcpAllocationRange, spNode1);
        CDhcpAllocationRange *pDhcpAR2 = GETHANDLER(CDhcpAllocationRange, spNode2);

        switch (nCol)
        {
                case 0:
                        {
                                // Start IP address compare
                                //
                                DHCP_IP_ADDRESS dhcpIp1 = pDhcpAR1->QueryAddr(TRUE);
                                DHCP_IP_ADDRESS dhcpIp2 = pDhcpAR2->QueryAddr(TRUE);
                                
                                if (dhcpIp1 < dhcpIp2)
                                        nCompare = -1;
                                else
                                if (dhcpIp1 > dhcpIp2)
                                        nCompare =  1;

                                // default is that they are equal
                        }
                        break;

                case 1:
                        {
                                // End IP address compare
                                //
                                DHCP_IP_ADDRESS dhcpIp1 = pDhcpAR1->QueryAddr(FALSE);
                                DHCP_IP_ADDRESS dhcpIp2 = pDhcpAR2->QueryAddr(FALSE);
                                
                                if (dhcpIp1 < dhcpIp2)
                                        nCompare = -1;
                                else
                                if (dhcpIp1 > dhcpIp2)
                                        nCompare =  1;

                                // default is that they are equal
                        }
                        break;

                case 2:
                        {
                                // Description compare
                                //
                                CString strRange1 = pDhcpAR1->GetString(pComponent, cookieA, nCol);
                                CString strRange2 = pDhcpAR2->GetString(pComponent, cookieA, nCol);

                                // Compare should not be case sensitive
                                //
                                strRange1.MakeUpper();
                                strRange2.MakeUpper();

                                nCompare = strRange1.Compare(strRange2);
                        }
                        break;
        }

        return nCompare;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions Implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScopeOptions Constructor and destructor

        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpScopeOptions::CDhcpScopeOptions
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CDhcpScopeOptions::~CDhcpScopeOptions()
{
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScopeOptions::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_SCOPE_OPTIONS_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_SCOPE_OPTIONS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_SCOPE_OPTIONS][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_SCOPE_OPTIONS][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpScopeOptions::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strIpAddress, strGuid;
    
    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    DHCP_IP_ADDRESS dhcpIpAddress = GetScopeObject(pNode)->GetAddress();

    UtilCvtIpAddrToWstr (dhcpIpAddress, &strIpAddress);

    strId = GetServerName(pNode) + strIpAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpScopeOptions::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_LOST_CONNECTION;
            else
                        nIndex = ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_LOST_CONNECTION;
                        break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}



/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScopeOptions::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    // these menu items go in the new menu, 
                    // only visible from scope pane
                    strMenuText.LoadString(IDS_CREATE_OPTION_SCOPE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_CREATE_OPTION_SCOPE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }
        

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScopeOptions::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_OPTION_SCOPE:
                        OnCreateNewOptions(pNode);
                        break;

                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::HasPropertyPages
                Implementation of ITFSNodeHandler::HasPropertyPages
        NOTE: the root node handler has to over-ride this function to 
        handle the snapin manager property page (wizard) case!!!
        
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScopeOptions::HasPropertyPages
(
        ITFSNode *                      pNode,
        LPDATAOBJECT            pDataObject, 
        DATA_OBJECT_TYPES   type, 
        DWORD               dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        HRESULT hr = hrOK;
        
        // we have property pages in the normal case, but don't put the
        // menu up if we are not loaded yet
        if ( m_nState != loaded )
        {
                hr = hrFalse;
        }
        else
        {
                hr = hrOK;
        }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScopeOptions::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD                       dwError;
    DWORD                       dwDynDnsFlags;
    HRESULT             hr = hrOK;
        COptionsConfig *    pOptCfg;
        CString             strOptCfgTitle, strOptType;
        SPITFSNode          spServerNode;
        SPIComponentData    spComponentData;
    COptionValueEnum *  pOptionValueEnum;

    //
        // Create the property page
    //
    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spComponentData);

        BEGIN_WAIT_CURSOR;

        strOptType.LoadString(IDS_CONFIGURE_OPTIONS_SCOPE);
                AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

                GetScopeObject(pNode)->GetServerNode(&spServerNode);
        pOptionValueEnum = GetScopeObject(pNode)->GetOptionValueEnum();

        pOptCfg = new COptionsConfig(pNode, 
                                                                     spServerNode,
                                                                         spComponentData, 
                                                                         m_spTFSCompData,
                                                                         pOptionValueEnum,
                                                                         strOptCfgTitle);
      
        END_WAIT_CURSOR;
            
            //
            // Object gets deleted when the page is destroyed
        //
            Assert(lpProvider != NULL);

        hr = pOptCfg->CreateModelessSheet(lpProvider, handle);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeOptions::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        COptionsConfig * pOptCfg = reinterpret_cast<COptionsConfig *>(lParam);

        LPARAM changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pOptCfg->OnPropertyChange(TRUE, &changeMask);

        pOptCfg->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeOptions::OnResultPropertyChange
(
        ITFSComponent * pComponent,
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);
        COptionsConfig * pOptCfg = reinterpret_cast<COptionsConfig *>(param);

        LPARAM changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pOptCfg->OnPropertyChange(TRUE, &changeMask);

        pOptCfg->AcknowledgeNotify();

        if (changeMask)
                spNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpScopeOptions::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpOptionItem *pOpt1 = GETHANDLER(CDhcpOptionItem, spNode1);
        CDhcpOptionItem *pOpt2 = GETHANDLER(CDhcpOptionItem, spNode2);

        switch (nCol)
        {
                case 0:
                {
                        //
            // Name compare - use the option #
                        //
            LONG_PTR uImage1 = spNode1->GetData(TFS_DATA_IMAGEINDEX);
            LONG_PTR uImage2 = spNode2->GetData(TFS_DATA_IMAGEINDEX);

            nCompare = UtilGetOptionPriority((int) uImage1, (int) uImage2);
            if (nCompare == 0)
            {
                DHCP_OPTION_ID  id1 = pOpt1->GetOptionId();
                DHCP_OPTION_ID  id2 = pOpt2->GetOptionId();
                            
                            if (id1 < id2)
                                    nCompare = -1;
                            else
                            if (id1 > id2)
                                    nCompare =  1;
            }
                }
                break;

        case 1:
        {
            // compare the vendor strings
            CString str1, str2;
            str1 = pOpt1->GetVendorDisplay();
            str2 = pOpt2->GetVendorDisplay();

            nCompare = str1.CompareNoCase(str2);
        }
        break;

        case 2:  {
            // compare the printable values
            CString str1, str2;
            str1 = pOpt1->GetString( pComponent, cookieA, nCol );
            str2 = pOpt2->GetString( pComponent, cookieB, nCol );
            
            nCompare = str1.CompareNoCase( str2 );
            break;
        }

        case 3:
        {
            CString str1, str2;
            str1 = pOpt1->GetClassName();
            str2 = pOpt2->GetClassName();

            nCompare = str1.CompareNoCase(str2);
        }
        break;
    }

        return nCompare;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::OnResultSelect
                Update the verbs and the result pane message
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpScopeOptions::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPITFSNode      spNode;

    CORg(CMTDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg (pComponent->GetSelectedNode(&spNode));

    if ( spNode != 0 ) {
        UpdateResultMessage(spNode);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeOptions::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spScopeOpt, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spScopeOpt);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spScopeOpt);
        if (spSelectedNode != spScopeOpt)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int)listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

    // check to make sure we are deleting just scope options
    POSITION pos = listNodesToDelete.GetHeadPosition();
    while (pos)
    {
        ITFSNode * pNode = listNodesToDelete.GetNext(pos);
        if (pNode->GetData(TFS_DATA_IMAGEINDEX) != ICON_IDX_SCOPE_OPTION_LEAF)
        {
            // this option is not scope option.  Put up a dialog telling the user what to do
            AfxMessageBox(IDS_CANNOT_DELETE_OPTION_SCOPE);
            return NOERROR;
        }
    }
    
        CString strServer = GetServerIpAddress(spScopeOpt);

        DHCP_OPTION_SCOPE_INFO    dhcpOptionScopeInfo;
        dhcpOptionScopeInfo.ScopeType = DhcpSubnetOptions;
        dhcpOptionScopeInfo.ScopeInfo.SubnetScopeInfo = GetScopeObject(spScopeOpt)->GetAddress();

        //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spOptionNode;
                spOptionNode = listNodesToDelete.RemoveHead();
                
                CDhcpOptionItem * pOptItem = GETHANDLER(CDhcpOptionItem, spOptionNode);
                        
        //
                // Try to remove it from the server
                //
            DWORD dwError;
        
        if (pOptItem->IsVendorOption() ||
            pOptItem->IsClassOption())
        {
            LPCTSTR pClassName = pOptItem->GetClassName();
            if (lstrlen(pClassName) == 0)
                pClassName = NULL;

            dwError = ::DhcpRemoveOptionValueV5((LPTSTR) ((LPCTSTR) strServer),
                                                pOptItem->IsVendorOption() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                                pOptItem->GetOptionId(),
                                                (LPTSTR) pClassName,
                                                (LPTSTR) pOptItem->GetVendor(),
                                                &dhcpOptionScopeInfo);
        }
        else
        {
            dwError = ::DhcpRemoveOptionValue(strServer, 
                                                                                      pOptItem->GetOptionId(), 
                                                                                      &dhcpOptionScopeInfo);
        }

                if (dwError != 0)
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

                        hr = E_FAIL;
                        continue;
                }

        // 
        // remove from our internal list
        //
        GetScopeObject(spScopeOpt)->GetOptionValueEnum()->Remove(pOptItem->GetOptionId(), pOptItem->GetVendor(), pOptItem->GetClassName());    

        //
                // Remove from UI now
                //
                spScopeOpt->RemoveChild(spOptionNode);
                spOptionNode.Release();
        }

    END_WAIT_CURSOR;

    UpdateResultMessage(spScopeOpt);

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpScopeOptions::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        // This is how we get non-node data back from the background thread.
    switch (Type)
    {
        case DHCP_QDATA_OPTION_VALUES:
        {
            HRESULT             hr = hrOK;
                SPIComponentData        spCompData;
                SPIConsole                      spConsole;
            SPIDataObject       spDataObject;
            IDataObject *       pDataObject;
            CDhcpScope  *       pScope = GetScopeObject(pParentNode);
            COptionValueEnum *  pOptionValueEnum = reinterpret_cast<COptionValueEnum *>(Data);

            pScope->SetOptionValueEnum(pOptionValueEnum);
            
            pOptionValueEnum->RemoveAll();
            delete pOptionValueEnum;

            // now tell the view to update themselves
                m_spNodeMgr->GetComponentData(&spCompData);

                CORg ( spCompData->QueryDataObject((MMC_COOKIE) pParentNode, CCT_SCOPE, &pDataObject) );
            spDataObject = pDataObject;

            CORg ( m_spNodeMgr->GetConsole(&spConsole) );
                CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) pParentNode, DHCPSNAP_UPDATE_OPTIONS) ); 

            break;
        }
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::OnResultUpdateView
                Implementation of ITFSResultHandler::OnResultUpdateView
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpScopeOptions::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
                return S_OK; // no selection for our IComponentData

    if ( hint == DHCPSNAP_UPDATE_OPTIONS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        EnumerateResultPane(pComponent, (MMC_COOKIE) spSelectedNode.p, 0, 0);
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CMTDhcpHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeOptions::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CMTDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
                
                hr = S_FALSE;
        }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::UpdateResultMessage
        Figures out what message to put in the result pane, if any
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CDhcpScopeOptions::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default
    int nVisible, nTotal;
    int i;

    CString strTitle, strBody, strTemp;

    if (!m_dwErr)
    {
                pNode->GetChildCount(&nVisible, &nTotal);

        // determine what message to display
        if ( (m_nState == notLoaded) || 
             (m_nState == loading) )
        {
            nMessage = -1;
        }
        else
        if (nTotal == 0)
        {
            nMessage = SCOPE_OPTIONS_MESSAGE_NO_OPTIONS;
        }

        // build the strings
        if (nMessage != -1)
        {
            // now build the text strings
            // first entry is the title
            strTitle.LoadString(g_uScopeOptionsMessages[nMessage][0]);

            // second entry is the icon
            // third ... n entries are the body strings

            for (i = 2; g_uScopeOptionsMessages[nMessage][i] != 0; i++)
            {
                strTemp.LoadString(g_uScopeOptionsMessages[nMessage][i]);
                strBody += strTemp;
            }
        }
    }

    // show the message
    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uScopeOptionsMessages[nMessage][1]);
    }
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::EnumerateResultPane
                We override this function for the options nodes for one reason.
        Whenever an option class is deleted, then all options defined for
        that class will be removed as well.  Since there are multiple places
        that these options may show up, it's easier to just not show any
        options that don't have a class defined for it.  
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpScopeOptions::EnumerateResultPane
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CClassInfoArray     ClassInfoArray;
        SPITFSNode          spContainer, spServerNode;
    CDhcpServer *       pServer;
    COptionValueEnum *  aEnum[2];
    int                 aImages[2] = {ICON_IDX_SCOPE_OPTION_LEAF, ICON_IDX_SERVER_OPTION_LEAF};

    m_spNodeMgr->FindNode(cookie, &spContainer);

    spServerNode = GetServerNode(spContainer);
    pServer = GETHANDLER(CDhcpServer, spServerNode);

    pServer->GetClassInfoArray(ClassInfoArray);

    aEnum[0] = GetScopeObject(spContainer)->GetOptionValueEnum();
    aEnum[1] = pServer->GetOptionValueEnum();

    aEnum[0]->Reset();
    aEnum[1]->Reset();

    return OnResultUpdateOptions(pComponent, spContainer, &ClassInfoArray, aEnum, aImages, 2);
}

/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpScopeOptions::OnCreateNewOptions
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPageHolderBase *   pPropSheet;
        HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
                if (HasPropSheetsOpen())
                {
                        GetOpenPropSheet(0, &pPropSheet);

                        pPropSheet->SetActiveWindow();
                }
                else
                {
                CString             strOptCfgTitle, strOptType;
                SPIComponentData    spComponentData;

            strOptType.LoadString(IDS_CONFIGURE_OPTIONS_SCOPE);
                AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

            m_spNodeMgr->GetComponentData(&spComponentData);

            hr = DoPropertiesOurselvesSinceMMCSucks(pNode, spComponentData, strOptCfgTitle);
        }
    }
    COM_PROTECT_CATCH

        return hr;

}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpScopeOptions::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpScopeOptions::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpScopeOptionsQueryObj* pQuery = 
                new CDhcpScopeOptionsQueryObj(m_spTFSCompData, m_spNodeMgr);
        
        pQuery->m_strServer = GetServerIpAddress(pNode);
        
        pQuery->m_dhcpScopeAddress = GetScopeObject(pNode)->GetAddress();
        pQuery->m_dhcpResumeHandle = NULL;
        pQuery->m_dwPreferredMax = 0xFFFFFFFF;
        
    GetScopeObject(pNode)->GetDynBootpClassName(pQuery->m_strDynBootpClassName);
    GetScopeObject(pNode)->GetServerVersion(pQuery->m_liDhcpVersion);

    return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpScopeOptionsQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpScopeOptionsQueryObj::Execute()
{
    DWORD                   dwErr;
        DHCP_OPTION_SCOPE_INFO  dhcpOptionScopeInfo;
    COptionValueEnum *      pOptionValueEnum;

    pOptionValueEnum = new COptionValueEnum();
    pOptionValueEnum->m_strDynBootpClassName = m_strDynBootpClassName;

    dhcpOptionScopeInfo.ScopeType = DhcpSubnetOptions;
        dhcpOptionScopeInfo.ScopeInfo.SubnetScopeInfo = m_dhcpScopeAddress;

    pOptionValueEnum->Init(m_strServer, m_liDhcpVersion, dhcpOptionScopeInfo);
    dwErr = pOptionValueEnum->Enum();

    if (dwErr != ERROR_SUCCESS)
    {
        Trace1("CDhcpScopeOptionsQueryObj::Execute - Enum Failed! %d\n", dwErr);
        m_dwErr = dwErr;
        PostError(dwErr);

        delete pOptionValueEnum;
    }
    else
    {
        pOptionValueEnum->SortById();
        AddToQueue((LPARAM) pOptionValueEnum, DHCP_QDATA_OPTION_VALUES);
    }

    return hrFalse;
}

/*!--------------------------------------------------------------------------
        CDhcpScopeOptions::OnNotifyExiting
                CMTDhcpHandler overridden functionality
                allows us to know when the background thread is done
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpScopeOptions::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        spNode.Set(m_spNode); // save this off because OnNotifyExiting will release it

        HRESULT hr = CMTDhcpHandler::OnNotifyExiting(lParam);

    UpdateResultMessage(spNode);

        return hr;
}

//
//
// qsort comparison routine to compare the ip addresses.
//
//

int __cdecl QCompare( const void *ip1, const void *ip2 )
{
    
 DWORD *lip1, *lip2;

 if ( ip1 && ip2 )
 {
     lip1 = (DWORD *)ip1;
     lip2 = (DWORD *)ip2;

     if ( *lip1 < *lip2 )
     {
         return -1;
     }
     else if ( *lip1 > *lip2 )
     {
         return 1;
     }
     else
     {
         return 0;
     }
 }

 return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopewiz.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        scopewiz.cpp
                DHCP scope creation dialog
                
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "scopewiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MASK_MIN    1
#define MASK_MAX    31

#define SCOPE_WARNING_COUNT 20

int CScopeWizLeaseTime::m_nDaysDefault = SCOPE_DFAULT_LEASE_DAYS;
int CScopeWizLeaseTime::m_nHoursDefault = SCOPE_DFAULT_LEASE_HOURS;
int CScopeWizLeaseTime::m_nMinutesDefault = SCOPE_DFAULT_LEASE_MINUTES;


/////////////////////////////////////////////////////////////////////////////
//
// CScopeWiz holder
//
/////////////////////////////////////////////////////////////////////////////
CScopeWiz::CScopeWiz
(
        ITFSNode *                      pNode,
        IComponentData *        pComponentData,
        ITFSComponentData * pTFSCompData,
        LPCTSTR                         pSuperscopeName,
        LPCTSTR                         pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
        //ASSERT(pFolderNode == GetContainerNode());

        m_bAutoDeletePages = FALSE; // we have the pages as embedded members

        AddPageToList((CPropertyPageBase*) &m_pageWelcome);
        AddPageToList((CPropertyPageBase*) &m_pageName);
        AddPageToList((CPropertyPageBase*) &m_pageInvalidName);
        AddPageToList((CPropertyPageBase*) &m_pageSetRange);
        AddPageToList((CPropertyPageBase*) &m_pageSetExclusions);
        AddPageToList((CPropertyPageBase*) &m_pageLeaseTime);
        AddPageToList((CPropertyPageBase*) &m_pageCreateSuperscope);
        AddPageToList((CPropertyPageBase*) &m_pageConfigOptions);
        AddPageToList((CPropertyPageBase*) &m_pageRouter);
        AddPageToList((CPropertyPageBase*) &m_pageDNS);
        AddPageToList((CPropertyPageBase*) &m_pageWINS);
        AddPageToList((CPropertyPageBase*) &m_pageActivate);
    AddPageToList((CPropertyPageBase*) &m_pageFinished);

        Assert(pTFSCompData != NULL);
        
    m_spTFSCompData.Set(pTFSCompData);
        m_strSuperscopeName = pSuperscopeName;
        
    m_fCreateSuperscope = FALSE;
    m_fOptionsConfigured = FALSE;
    m_fActivateScope = FALSE;
    m_fWizardCancelled = TRUE;

    m_pDefaultOptions = NULL;
    m_poptDomainName = NULL;
    m_poptDNSServers = NULL;
    m_poptRouters = NULL;
    m_poptWINSNodeType = NULL;
    m_poptWINSServers = NULL;

    m_bWiz97 = TRUE;

    m_spTFSCompData->SetWatermarkInfo(&g_WatermarkInfoScope);
}

CScopeWiz::~CScopeWiz()
{
    RemovePageFromList(( CPropertyPageBase * ) &m_pageWelcome, FALSE );
    RemovePageFromList((CPropertyPageBase*) &m_pageName, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageInvalidName, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageSetRange, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageSetExclusions, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageLeaseTime, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageCreateSuperscope, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageConfigOptions, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageRouter, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageDNS, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageWINS, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageActivate, FALSE);
    RemovePageFromList((CPropertyPageBase*) &m_pageFinished, FALSE);

    // Set the registry key used by the CYS wizard to detect cancel
    // HKCU\Software\Microsoft\Windows NT\CurrentVersion\srvWiz\DHCPWizResult
    // should be set to "The wizard was cancelled"
    if ( m_fWizardCancelled ) {
        LONG Error;
        HKEY hKey;
        LPWSTR SrvWizKey = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz";
        LPWSTR ValueName = L"DhcpWizResult";
        DWORD  ValueType = REG_SZ;
        LPWSTR Value =  L"The wizard was canceled";
        DWORD ValueLen = sizeof( WCHAR ) * wcslen( Value );
        
        Error = RegOpenKey( HKEY_CURRENT_USER, SrvWizKey, &hKey );
        if ( ERROR_SUCCESS == Error ) {
            Error = RegSetValueEx( hKey, ValueName, 0, ValueType,
                                 ( const BYTE * ) Value, ValueLen );

        } // if 
        RegCloseKey( hKey );
    } // if
}

//
// Called from the OnWizardFinish to add the DHCP Server to the list
//
DWORD
CScopeWiz::OnFinish()
{
    m_fWizardCancelled = FALSE;

    if (m_fCreateSuperscope)
    {
        return CreateSuperscope();
    }
    else
    {
        return CreateScope();
    }
}

BOOL
CScopeWiz::GetScopeRange(CDhcpIpRange * pdhcpIpRange)
{
        return m_pageSetRange.GetScopeRange(pdhcpIpRange);
}

DWORD
CScopeWiz::CreateSuperscope()
{
    LONG                err = 0;
    LONG                dwErrReturn = 0;
    BOOL                fScopeCreated = FALSE;
        BOOL                fFinished = FALSE;
    DHCP_IP_ADDRESS     dhcpSubnetId ;
    DHCP_IP_ADDRESS     dhcpSubnetMask ;
    CDhcpScope *        pobScope = NULL ;
    CDhcpIpRange        dhcpIpRange;
        CDhcpServer *       pServer;
        SPITFSNode          spServerNode, spSuperscopeNode;
        CString             strSuperscopeTemplate = _T("Superscope %d");
    CString             strSuperscopeName;
    CString             strFinishText;
    int                 nSuperscopeSuffix = 0;
    int                 nScopesCreated = 0;
    int                 nScopesTotal = 0;
    SPITFSComponentData spTFSCompData;
        SPITFSNodeMgr       spNodeMgr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get the server node depending upon how we were called
        if (m_strSuperscopeName.IsEmpty())
        {
                spServerNode = GetNode();
        }
        else
        {
                SPITFSNode spSscopeNode;
                spSscopeNode = GetNode();
                spSscopeNode->GetParent(&spServerNode);
        }

        spServerNode->GetNodeMgr(&spNodeMgr);
        spTFSCompData = GetTFSCompData();

        // setup some necessary things for the superscope object for the UI
        CDhcpSuperscope * pSuperscope = new CDhcpSuperscope(spTFSCompData);
        pSuperscope->SetServer(spServerNode);

        // find a superscope name that doesn't already exist
        strSuperscopeName.Format(strSuperscopeTemplate, nSuperscopeSuffix);
        while (S_OK != pSuperscope->DoesSuperscopeExist(strSuperscopeName))
        {
                nSuperscopeSuffix++;            
                strSuperscopeName.Format(strSuperscopeTemplate, nSuperscopeSuffix);
        }
        
        // Set the new name in the superscope object
        pSuperscope->SetName(strSuperscopeName);

        CreateContainerTFSNode(&spSuperscopeNode,
                                                   &GUID_DhcpSuperscopeNodeType,
                                                   pSuperscope,
                                                   pSuperscope,
                                                   spNodeMgr);

        // Tell the handler to initialize any specific data
    if (m_fOptionsConfigured && m_fActivateScope)
        pSuperscope->SetState(DhcpSubnetEnabled);

        pSuperscope->InitializeNode((ITFSNode *) spSuperscopeNode);
        pServer = GETHANDLER(CDhcpServer, spServerNode);

        // Ok, now the fun begins...
        CDhcpIpRange ipRangeTotal, ipRangeCurrent;
        m_pageSetRange.GetScopeRange(&ipRangeTotal);

    dhcpSubnetMask = m_pageSetRange.GetSubnetMask();
        
    // Set the start address for the first scope
        ipRangeCurrent.SetAddr(ipRangeTotal.QueryAddr(TRUE), TRUE);

    while (!fFinished)
    {
                SPITFSNode spNode;

            nScopesTotal++;

        // Calculate the subnet ID
                dhcpSubnetId = ipRangeCurrent.QueryAddr(TRUE) & dhcpSubnetMask;
                
                // 0 is an invalid start address for a range.  Check to make sure
                // that the starting address of the range isn't 0, if it is, then add 1
                DWORD startAddr = ipRangeCurrent.QueryAddr(TRUE);
                if ((startAddr & ~dhcpSubnetMask) == 0)
                {
                        ipRangeCurrent.SetAddr(startAddr+1, TRUE);
                }

                // set the ending address of the (subnetId + ~subnetmask) - 1.  Just adding the subnet
                // mask gives us the broadcast address for that subnet.  We don't want that!
                ipRangeCurrent.SetAddr((dhcpSubnetId + ~dhcpSubnetMask) - 1, FALSE);


                // check to see if we are at the last scope, if so make sure we don't
                // go over what the range the user specified and set the flag so we'll quit
                if (ipRangeCurrent.QueryAddr(FALSE) >= ipRangeTotal.QueryAddr(FALSE))
                {
                        // set the ending address to what the user specified
                        ipRangeCurrent.SetAddr(ipRangeTotal.QueryAddr(FALSE), FALSE);
                        fFinished = TRUE;
                }

                // Create the scope on the server and then we can
                // create our internal object.
        err = pServer->CreateScope(dhcpSubnetId,
                                                                   dhcpSubnetMask,
                                                                   m_pageName.m_strName,
                                                                   m_pageName.m_strComment);

                if (err != ERROR_SUCCESS)
                {
                        Trace1("CScopeWiz::CreateScope() - Couldn't create scope! Error = %d\n", err);

            dwErrReturn = err;
                        
                        // increment the scope address by 2.  +1 gets us the network broadcast address,
            // the next +1 gets us to the next subnet.
            ipRangeCurrent.SetAddr(ipRangeCurrent.QueryAddr(FALSE) + 2, TRUE);
                        continue;
                }

                // now create our object that represents the scope for the UI
        pobScope = new CDhcpScope(spTFSCompData,
                                                                  dhcpSubnetId,
                                                                  dhcpSubnetMask,
                                                                  m_pageName.m_strName,
                                                                  m_pageName.m_strComment);

                if ( pobScope == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;    
        }

                // Store the server object in the holder
                CreateContainerTFSNode(&spNode,
                                                           &GUID_DhcpScopeNodeType,
                                                           pobScope,
                                                           pobScope,
                                                           spNodeMgr);

                // Tell the handler to initialize any specific data
                pobScope->SetServer(spServerNode);
                pobScope->InitializeNode((ITFSNode *) spNode);

                pobScope->Release();

        //  Finish creating the scope.  First, the IP address range
        //  from which to allocate addresses.
                if ( err = pobScope->SetIpRange( ipRangeCurrent, TRUE ) ) 
        {
                        Trace2("SetIpRange on scope %lx failed!!  %d\n", dhcpSubnetId, err);
            dwErrReturn = err;
            pServer->DeleteSubnet(pobScope->GetAddress());
                        goto Cleanup;
        }

                //  set the lease time
                DWORD dwLeaseTime;

                dwLeaseTime = m_pageLeaseTime.GetLeaseTime();

                err = pobScope->SetLeaseTime(dwLeaseTime);
                if (err != ERROR_SUCCESS)
                {
                        Trace2("SetLeaseTime on Scope %lx failed!!  %d\n", dhcpSubnetId, err);
            dwErrReturn = err;
            pServer->DeleteSubnet(pobScope->GetAddress());
                        goto Cleanup;
                }
                
                // Set this scope as part of the superscope
                err = pobScope->SetSuperscope(strSuperscopeName, FALSE);
                if (err != ERROR_SUCCESS)
                {
                        Trace2("SetSuperscope on scope %lx failed!!  %d\n", dhcpSubnetId, err);
            dwErrReturn = err;
            pServer->DeleteSubnet(pobScope->GetAddress());
                        goto Cleanup;
                }

        pobScope->SetInSuperscope(TRUE);
        
        // now set any optional options the user may want
        if (m_fOptionsConfigured)
        {
            err = SetScopeOptions(pobScope);
                    if (err != ERROR_SUCCESS)
                    {
                            Trace1("SetScopeOptions failed!!  %d\n", err);
                            break;
                    }
        }

        // increment our counter
        nScopesCreated++;

                // cleanup this node and handler... they were only temporary
Cleanup:
                // we add two to the ending address to get the next starting address.  This
                // is because the ending adddress is one less than the maximum address for the
                // subnet.  The maximum address is reserved as the broadcast address.  So to get
                // the starting address of the next subnet we add one to get us to the broadcast 
                // address, and one more to get us to the beginning of the next subnet.  
                // This gives us a total of 2.
                ipRangeCurrent.SetAddr(ipRangeCurrent.QueryAddr(FALSE) + 2, TRUE);
                spNode->DeleteAllChildren(FALSE);
                spNode->Destroy();
        }
        
        pSuperscope->Release();

    // let the user know how many scopes were created and if there was an error;
    CString strTemp;
    if (nScopesCreated == 0)
    {
        strFinishText.LoadString(IDS_SUPERSCOPE_CREATE_FAILED);
    }
    else
    if (nScopesCreated < nScopesTotal)
    {
        strTemp.LoadString(IDS_SUPERSCOPE_CREATE_STATUS);
        strFinishText.Format(strTemp, strSuperscopeName, nScopesCreated, nScopesTotal);
    }

    if (dwErrReturn != ERROR_SUCCESS)
    {
        LPTSTR pBuf;

        strFinishText += _T("\n\n");
        strTemp.LoadString(IDS_POSSIBLE_ERROR);
  
        strFinishText += strTemp;

        pBuf = strTemp.GetBuffer(4000);
        ::LoadMessage(dwErrReturn, pBuf, 4000);
        strTemp.ReleaseBuffer();

        strFinishText += strTemp;
    }

    if (nScopesCreated)
    {
        // add the superscope to the UI
        pServer->AddSuperscopeSorted(spServerNode, spSuperscopeNode);
    }

    if (!strFinishText.IsEmpty())
        AfxMessageBox(strFinishText);
  
    return ERROR_SUCCESS;
}

DWORD
CScopeWiz::CreateScope()
{
    LONG err = 0,
         err2 ;
    BOOL fScopeCreated = FALSE;
    DHCP_IP_ADDRESS dhcpSubnetId ;
    DHCP_IP_ADDRESS dhcpSubnetMask ;
    CDhcpScope * pobScope = NULL ;
    CDhcpIpRange dhcpIpRange;
        CDhcpServer * pServer;
        SPITFSNode spNode, spServerNode, spSuperscopeNode;

    // Get the correct node depending up how the wizard was launched
        // ie. either from the Server node or the superscope node.
        if (m_strSuperscopeName.IsEmpty())
        {
                spServerNode = GetNode();
        }
        else
        {
                spSuperscopeNode = GetNode();
                spSuperscopeNode->GetParent(&spServerNode);
        }

    do
    {
                pServer = GETHANDLER(CDhcpServer, spServerNode);
                //
                // Create the scope on the server and then we can
                // create our internal object.
                //
                dhcpSubnetId = m_pageSetRange.DetermineSubnetId(TRUE);
        dhcpSubnetMask = m_pageSetRange.GetSubnetMask();
                 
        err = pServer->CreateScope(dhcpSubnetId,
                                                                   dhcpSubnetMask,
                                                                   m_pageName.m_strName,
                                                                   m_pageName.m_strComment);

                if (err != 0)
                {
                        Trace1("CScopeWiz::CreateScope() - Couldn't create scope! Error = %d\n", err);
                        break;
                }

                SPITFSComponentData spTFSCompData;
                spTFSCompData = GetTFSCompData();

        pobScope = new CDhcpScope(spTFSCompData,
                                                                  dhcpSubnetId,
                                                                  dhcpSubnetMask,
                                                                  m_pageName.m_strName,
                                                                  m_pageName.m_strComment);

                if ( pobScope == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;    
        }

                SPITFSNodeMgr spNodeMgr;
                spServerNode->GetNodeMgr(&spNodeMgr);

                //
                // Store the server object in the holder
                //
                CreateContainerTFSNode(&spNode,
                                                           &GUID_DhcpServerNodeType,
                                                           pobScope,
                                                           pobScope,
                                                           spNodeMgr);

                // Tell the handler to initialize any specific data
                pobScope->SetServer(spServerNode);
                pobScope->InitializeNode((ITFSNode *) spNode);

                if (m_strSuperscopeName.IsEmpty())
                {
                        CDhcpServer * pServer1 = GETHANDLER(CDhcpServer, spServerNode);
            pServer1->AddScopeSorted(spServerNode, spNode);
                }
                else
                {
                        CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spSuperscopeNode);
            pSuperscope->AddScopeSorted(spSuperscopeNode, spNode);
        }
                
                pobScope->Release();

        fScopeCreated = TRUE;

        //
        //  Finish updating the scope.  First, the IP address range
        //  from which to allocate addresses.
        //
        m_pageSetRange.GetScopeRange(&dhcpIpRange);

                if ( err = pobScope->SetIpRange( dhcpIpRange, TRUE ) ) 
        {
                        Trace1("SetIpRange failed!!  %d\n", err);
            break ; 
        }

        //
        //  Next, see if any exclusions were specified.
        //
        err = pobScope->StoreExceptionList( m_pageSetExclusions.GetExclusionList() ) ;
                if (err != ERROR_SUCCESS)
                {
                        Trace1("StoreExceptionList failed!!  %d\n", err);
                        break;
                }

                //
                //  set the lease time
                //
                DWORD dwLeaseTime;

                dwLeaseTime = m_pageLeaseTime.GetLeaseTime();

                err = pobScope->SetLeaseTime(dwLeaseTime);
                if (err != ERROR_SUCCESS)
                {
                        Trace1("SetLeaseTime failed!!  %d\n", err);
                        break;
                }
                
                if (!m_strSuperscopeName.IsEmpty())
                {
                        // Set this scope as part of the superscope
                        err = pobScope->SetSuperscope(m_strSuperscopeName, FALSE);

                        if (err != ERROR_SUCCESS)
                        {
                                Trace1("SetSuperscope failed!!  %d\n", err);
                                break;
                        }
                }

        // now set any optional options the user may want
        if (m_fOptionsConfigured)
        {
            err = SetScopeOptions(pobScope);
                    if (err != ERROR_SUCCESS)
                    {
                            Trace1("SetScopeOptions failed!!  %d\n", err);
                            break;
                    }

            if (m_fActivateScope)
            {
                // update the icon
                    spNode->SetData(TFS_DATA_IMAGEINDEX, pobScope->GetImageIndex(FALSE));
                    spNode->SetData(TFS_DATA_OPENIMAGEINDEX, pobScope->GetImageIndex(TRUE));

                spNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON);
            }
        }
        }
    while ( FALSE ) ;

    if ( err )
    {
                //
        // CODEWORK:: The scope should never have been added
        //            to the remote registry in the first place.
        //
        if (pobScope != NULL)
        {
            if (fScopeCreated)
            {
                Trace0("Bad scope nevertheless was created\n");
                err2 = pServer->DeleteSubnet(pobScope->GetAddress());
                if (err2 != ERROR_SUCCESS)
                {
                    Trace1("Couldn't remove the bad scope! Error = %d\n", err2);
                }
            }
            
                        if (m_strSuperscopeName.IsEmpty())
                        {
                                spServerNode->RemoveChild(spNode);
                        }
                        else
                        {
                                spSuperscopeNode->RemoveChild(spNode);
                        }
                }
        }

        return err;
}

DWORD
CScopeWiz::SetScopeOptions(CDhcpScope * pScope)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (m_poptRouters)
    {
        dwErr = pScope->SetOptionValue(m_poptRouters, DhcpSubnetOptions);
        if (dwErr)
            return dwErr;
    }
    
    if (m_poptDomainName)
    {
        dwErr = pScope->SetOptionValue(m_poptDomainName, DhcpSubnetOptions);
        if (dwErr)
            return dwErr;
    }

    if (m_poptDNSServers)
    {
        dwErr = pScope->SetOptionValue(m_poptDNSServers, DhcpSubnetOptions);
        if (dwErr)
            return dwErr;
    }

    if (m_poptWINSServers)
    {
        dwErr = pScope->SetOptionValue(m_poptWINSServers, DhcpSubnetOptions);
        if (dwErr)
            return dwErr;
    }

    if (m_poptWINSNodeType)
    {
        dwErr = pScope->SetOptionValue(m_poptWINSNodeType, DhcpSubnetOptions);
        if (dwErr)
            return dwErr;
    }

    if (m_fActivateScope)
    {
        pScope->SetState(DhcpSubnetEnabled);
        dwErr = pScope->SetInfo();
    }

    return dwErr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizName property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizName, CPropertyPageBase)

CScopeWizName::CScopeWizName() : CPropertyPageBase(CScopeWizName::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizName)
        m_strName = _T("");
        m_strComment = _T("");
        //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SCOPE_WIZ_NAME_TITLE, IDS_SCOPE_WIZ_NAME_SUBTITLE);
}

CScopeWizName::~CScopeWizName()
{
}

void CScopeWizName::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizName)
        DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editScopeName);
        DDX_Control(pDX, IDC_EDIT_SCOPE_COMMENT, m_editScopeComment);
        DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strName);
        DDX_Text(pDX, IDC_EDIT_SCOPE_COMMENT, m_strComment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizName, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizName)
        ON_EN_CHANGE(IDC_EDIT_SCOPE_NAME, OnChangeEditScopeName)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizName message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizName::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();

        // Limit the size of the name
        m_editScopeName.LimitText( MAX_NAME_LENGTH );
        m_editScopeComment.LimitText( MAX_NAME_LENGTH );
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizName::OnWizardNext() 
{
        UpdateData();
        
        return IDW_SCOPE_SET_SCOPE;
}

BOOL CScopeWizName::OnSetActive() 
{
        UpdateButtons();
        
        return CPropertyPageBase::OnSetActive();
}

void CScopeWizName::OnChangeEditScopeName() 
{
        UpdateButtons();        
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizName implementation specific
//
/////////////////////////////////////////////////////////////////////////////
void
CScopeWizName::UpdateButtons()
{
        BOOL bValid = FALSE;

        UpdateData();

        if (m_strName.GetLength() > 0)
                bValid = TRUE;

        GetHolder()->SetWizardButtonsMiddle(bValid);
}


/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizInvalidName property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizInvalidName, CPropertyPageBase)

CScopeWizInvalidName::CScopeWizInvalidName() : CPropertyPageBase(CScopeWizInvalidName::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizInvalidName)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SCOPE_WIZ_INVALID_NAME_TITLE, IDS_SCOPE_WIZ_INVALID_NAME_SUBTITLE);
}

CScopeWizInvalidName::~CScopeWizInvalidName()
{
}

void CScopeWizInvalidName::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizInvalidName)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizInvalidName, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizInvalidName)
                // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizInvalidName message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizInvalidName::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizInvalidName::OnWizardBack() 
{
        // TODO: Add your specialized code here and/or call the base class
        
        return IDW_SCOPE_NAME;
}

BOOL CScopeWizInvalidName::OnSetActive() 
{
        GetHolder()->SetWizardButtonsLast(FALSE);
        
        return CPropertyPageBase::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetRange property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizSetRange, CPropertyPageBase)

CScopeWizSetRange::CScopeWizSetRange() : CPropertyPageBase(CScopeWizSetRange::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizSetRange)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

        m_bAutoUpdateMask = FALSE;

    InitWiz97(FALSE, IDS_SCOPE_WIZ_SCOPE_TITLE, IDS_SCOPE_WIZ_SCOPE_SUBTITLE);
}

CScopeWizSetRange::~CScopeWizSetRange()
{
}

void CScopeWizSetRange::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizSetRange)
        DDX_Control(pDX, IDC_SPIN_MASK_LENGTH, m_spinMaskLength);
        DDX_Control(pDX, IDC_EDIT_MASK_LENGTH, m_editMaskLength);
        //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_POOL_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_POOL_STOP, m_ipaEnd);
    DDX_Control(pDX, IDC_IPADDR_SUBNET_MASK, m_ipaSubnetMask);
}


BEGIN_MESSAGE_MAP(CScopeWizSetRange, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizSetRange)
        ON_EN_KILLFOCUS(IDC_IPADDR_POOL_START, OnKillfocusPoolStart)
        ON_EN_KILLFOCUS(IDC_IPADDR_POOL_STOP, OnKillfocusPoolStop)
        ON_EN_CHANGE(IDC_EDIT_MASK_LENGTH, OnChangeEditMaskLength)
        ON_EN_KILLFOCUS(IDC_IPADDR_SUBNET_MASK, OnKillfocusSubnetMask)
        ON_EN_CHANGE(IDC_IPADDR_POOL_START, OnChangePoolStart)
        ON_EN_CHANGE(IDC_IPADDR_POOL_STOP, OnChangePoolStop)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetRange message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizSetRange::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();

        m_spinMaskLength.SetRange(MASK_MIN, MASK_MAX);

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizSetRange::OnWizardNext() 
{
    // check to make sure the address range is not in the multicast area
    CDhcpIpRange rangeScope, rangeMulticast;
    DWORD        dwSubnetMask;

    GetScopeRange(&rangeScope);

    rangeMulticast.SetAddr(MCAST_ADDRESS_MIN, TRUE);
    rangeMulticast.SetAddr(MCAST_ADDRESS_MAX, FALSE);

    dwSubnetMask = GetSubnetMask();

    // make sure the starting < ending
    if (rangeScope.QueryAddr(TRUE) > rangeScope.QueryAddr(FALSE))
    {
        AfxMessageBox(IDS_ERR_IP_RANGE_INV_START);
        m_ipaStart.SetFocus();
        return -1;
    }

    if (rangeScope.IsOverlap(rangeMulticast))
    {
        AfxMessageBox(IDS_SCOPE_CONTAINS_MULTICAST);
        m_ipaStart.SetFocus();
        return -1;
    }

    // make sure that the starting address != subnet address
    if ((rangeScope.QueryAddr(TRUE) & ~dwSubnetMask) == (DWORD) 0)
    {
        Trace0("CScopeWizSetRange::OnWizardNext() - starting range is 0 for subnet\n");
        AfxMessageBox(IDS_ERR_IP_RANGE_INV_START);
        m_ipaStart.SetFocus();
        return -1;
    }

    // make sure that the subnet broadcast address is not the ending address
    if ((rangeScope.QueryAddr(FALSE) & ~dwSubnetMask) == ~dwSubnetMask)
    {
        Trace0("CScopeWizSetRange::OnWizardNext() - ending range is subnet broadcast addr\n");
        AfxMessageBox(IDS_ERR_IP_RANGE_INV_END);
        m_ipaEnd.SetFocus();
        return -1;
    }

    if (FScopeExists(rangeScope, dwSubnetMask))
    {
        // tell the user this scope exists 
        Trace0("CScopeWizSetRange::OnWizardNext() - scope already exists\n");
        AfxMessageBox(IDS_ERR_SCOPE_EXISTS);
        m_ipaStart.SetFocus();
        return -1;
    }

    // now figure out where to go...
    if (DetermineSubnetId(TRUE) != DetermineSubnetId(FALSE))
        {
                //
                // The subnet range that was entered spans more than
                // one subnet.  Query the user to create a superscope.
                //
                return IDW_SCOPE_CREATE_SUPERSCOPE;
        }
        else
        {
                //
                // The range is only one subnet.  Proceed as normal.
                //
                CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
                pScopeWiz->SetCreateSuperscope(FALSE);

                return IDW_SCOPE_SET_EXCLUSIONS;
        }
}

BOOL CScopeWizSetRange::FScopeExists(CDhcpIpRange & rangeScope, DWORD dwMask)
{
    BOOL  fFound = FALSE;
        DWORD dwScopeId = rangeScope.QueryAddr(TRUE) & dwMask;

    CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());

    SPITFSNode spServerNode, spSuperscopeNode;

    // Get the correct node depending up how the wizard was launched
    // ie. either from the Server node or the superscope node.
    if (pScopeWiz->m_strSuperscopeName.IsEmpty())
    {
        spServerNode = pScopeWiz->GetNode();
    }
    else
    {
        spSuperscopeNode = pScopeWiz->GetNode();
        spSuperscopeNode->GetParent(&spServerNode);
    }

    CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);

    CSubnetInfo subnetInfo;

    if (pServer->m_pSubnetInfoCache->Lookup(dwScopeId, subnetInfo))
    {
        fFound = TRUE;
    }

    return fFound;
}

LRESULT CScopeWizSetRange::OnWizardBack() 
{
        return IDW_SCOPE_NAME;
}

BOOL CScopeWizSetRange::OnSetActive() 
{
        m_fPageActive = TRUE;

        UpdateButtons();

        return CPropertyPageBase::OnSetActive();
}

BOOL CScopeWizSetRange::OnKillActive() 
{
        m_fPageActive = FALSE;

        UpdateButtons();

        return CPropertyPageBase::OnKillActive();
}

void CScopeWizSetRange::OnKillfocusPoolStart()
{
        if (m_fPageActive)
        {
                SuggestSubnetMask();
        }
}

void CScopeWizSetRange::OnKillfocusPoolStop()
{
        if (m_fPageActive)
        {
                SuggestSubnetMask();
        }
}

void CScopeWizSetRange::OnChangeEditMaskLength() 
{
        if (m_bAutoUpdateMask)
        {
        CString strText;
        m_editMaskLength.GetWindowText(strText);
        
        int nLength = _ttoi(strText);

        if (nLength < MASK_MIN)
        {
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MASK_MIN, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMaskLength.SetWindowText(strText);
            m_spinMaskLength.SetPos(MASK_MIN);

            MessageBeep(MB_ICONEXCLAMATION);
        }
        else
        if (nLength > MASK_MAX)
        {
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MASK_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMaskLength.SetWindowText(strText);
            m_spinMaskLength.SetPos(MASK_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }

                UpdateMask(TRUE);
                UpdateButtons();
        }
}

void CScopeWizSetRange::OnKillfocusSubnetMask() 
{
        if (m_bAutoUpdateMask)
        {
                UpdateMask(FALSE);
        }
}

void CScopeWizSetRange::OnChangePoolStop()
{
        UpdateButtons();
}

void CScopeWizSetRange::OnChangePoolStart()
{
        UpdateButtons();
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetRange implementation specific
//
/////////////////////////////////////////////////////////////////////////////
BOOL
CScopeWizSetRange::GetScopeRange(CDhcpIpRange * pdhcpIpRange)
{
        DHCP_IP_RANGE dhcpIpRange;

    if ( !m_ipaStart.GetAddress( & dhcpIpRange.StartAddress ) )
    {
        return FALSE ;
    }

    if ( !m_ipaEnd.GetAddress( & dhcpIpRange.EndAddress ) )
    {
                return FALSE;
        }

        *pdhcpIpRange = dhcpIpRange;

        return TRUE;
}

DHCP_IP_ADDRESS
CScopeWizSetRange::GetSubnetMask()
{
        DWORD dwAddress;
        m_ipaSubnetMask.GetAddress(&dwAddress);

        return dwAddress;
}

void
CScopeWizSetRange::UpdateButtons()
{
        DWORD   lStart, lEnd, lMask;

        m_ipaStart.GetAddress(&lStart);
        m_ipaEnd.GetAddress(&lEnd);
        m_ipaSubnetMask.GetAddress(&lMask);

        if (lStart && lEnd)
                GetHolder()->SetWizardButtonsMiddle(TRUE);
        else
                GetHolder()->SetWizardButtonsMiddle(FALSE);

}

//
// Update the subnet mask field using either the length identifier or 
// the acutal address as the base
//
void
CScopeWizSetRange::UpdateMask(BOOL bUseLength)
{
        if (bUseLength)
        {
                DWORD dwAddress = 0xFFFFFFFF;

        int nLength = m_spinMaskLength.GetPos();
        if (nLength)
            dwAddress = dwAddress << (32 - (DWORD) nLength);    
        else
            dwAddress = 0;
                
                m_ipaSubnetMask.SetAddress(dwAddress);
        }
        else
        {
                DWORD dwAddress, dwTestMask = 0x80000000;
                int nLength = 0;

                m_ipaSubnetMask.GetAddress(&dwAddress);

                while (TRUE)
                {
                        if (dwAddress & dwTestMask)
                        {
                                nLength++;
                                dwTestMask = dwTestMask >> 1;
                        }
                        else
                        {
                                break;
                        }

                }

                m_spinMaskLength.SetPos(nLength);
        }
}


//
//  Given the start and end IP addresses, suggest a good subnet mask
//  (unless the latter has been filled in already, of course)
//
void 
CScopeWizSetRange::SuggestSubnetMask()
{
    DWORD lStart, lEnd, lMask, lMask2;
    
        m_ipaSubnetMask.GetAddress(&lMask);
    if (lMask != 0L)
    {
        //
        // Already has an address, do nothing
        //
        return;
    }

        m_ipaStart.GetAddress(&lStart);
        m_ipaEnd.GetAddress(&lEnd);
        
    lMask = DefaultNetMaskForIpAddress( lStart );
    lMask2 = DefaultNetMaskForIpAddress( lEnd );
/*
    if (lMask != lMask2)
    {
        //
        // Forget about suggesting a subnet mask
        //
        lMask = 0;
    }
*/
        m_bAutoUpdateMask = TRUE;

    if (lMask != 0)
    {
                m_ipaSubnetMask.SetAddress(lMask);
                UpdateMask(FALSE);
        }
}

DWORD
CScopeWizSetRange::DefaultNetMaskForIpAddress
(
    DWORD dwAddress
)
{
    DWORD dwMask = 0L;

    if (!(dwAddress & 0x80000000))
    {
        //
        // Class A - mask 255.0.0.0
        //
        dwMask = 0xFF000000;
    }
    else 
        if (!(dwAddress & 0x40000000))
    {
        //
        // Class B - mask 255.255.0.0
        //
        dwMask = 0xFFFF0000;
    }
    else 
        if (!(dwAddress & 0x20000000))
    {
        //
        // Class C - mask 255.255.255.0
        //
        dwMask = 0xFFFFFF00;
    }

    return dwMask;
}

//
//  Returns the Subnet IP identifier of either the 
//  scope's starting or ending IP Address.
//
DWORD 
CScopeWizSetRange::DetermineSubnetId
( 
    BOOL        bStartIpAddress
) 
{
    DWORD lAddress, lMask;

        m_ipaSubnetMask.GetAddress(&lMask);
        
        if (bStartIpAddress)
                m_ipaStart.GetAddress(&lAddress);
        else
                m_ipaEnd.GetAddress(&lAddress);
        
    return (lAddress & lMask);
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetExclusions property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizSetExclusions, CPropertyPageBase)

CScopeWizSetExclusions::CScopeWizSetExclusions() : CPropertyPageBase(CScopeWizSetExclusions::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizSetExclusions)
        //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SCOPE_WIZ_EXCLUSIONS_TITLE, IDS_SCOPE_WIZ_EXCLUSIONS_SUBTITLE);
}

CScopeWizSetExclusions::~CScopeWizSetExclusions()
{
        while (m_listExclusions.GetCount())
                delete m_listExclusions.RemoveHead();
}

void CScopeWizSetExclusions::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizSetExclusions)
        DDX_Control(pDX, IDC_LIST_EXCLUSION_RANGES, m_listboxExclusions);
        DDX_Control(pDX, IDC_BUTTON_EXCLUSION_DELETE, m_buttonExclusionDelete);
        DDX_Control(pDX, IDC_BUTTON_EXCLUSION_ADD, m_buttonExclusionAdd);
        //}}AFX_DATA_MAP

        //
        // IP Address custom controls
        //
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_END, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CScopeWizSetExclusions, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizSetExclusions)
        ON_BN_CLICKED(IDC_BUTTON_EXCLUSION_ADD, OnButtonExclusionAdd)
        ON_BN_CLICKED(IDC_BUTTON_EXCLUSION_DELETE, OnButtonExclusionDelete)
        //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPADDR_EXCLUSION_START, OnChangeExclusionStart)
    ON_EN_CHANGE(IDC_IPADDR_EXCLUSION_END, OnChangeExclusionEnd)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetExclusions message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizSetExclusions::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizSetExclusions::OnWizardNext() 
{
        return IDW_SCOPE_LEASE_TIME;
}

LRESULT CScopeWizSetExclusions::OnWizardBack() 
{
        return IDW_SCOPE_SET_SCOPE;
}

BOOL CScopeWizSetExclusions::OnSetActive() 
{
        GetHolder()->SetWizardButtonsMiddle(TRUE);
        
        UpdateButtons();

        return CPropertyPageBase::OnSetActive();
}

void CScopeWizSetExclusions::OnChangeExclusionStart()
{
        UpdateButtons();
}

void CScopeWizSetExclusions::OnChangeExclusionEnd()
{
        UpdateButtons();
}

void CScopeWizSetExclusions::OnButtonExclusionAdd() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        DWORD err = 0;
        CDhcpIpRange dhcpExclusionRange;
        CDhcpIpRange dhcpScopeRange;

        ((CScopeWiz *)GetHolder())->GetScopeRange(&dhcpScopeRange);
        
    //
    //  Get the data into a range object.               
    //
    if ( !GetExclusionRange(dhcpExclusionRange) )
    {
        err = IDS_ERR_IP_RANGE_INVALID ;
    }
    else if ( IsOverlappingRange( dhcpExclusionRange ) )
    {
        //
        //  Walk the current list, determining if the new range is valid.
        //  Then, if OK, verify that it's really a sub-range of the current range.
        //
        err = IDS_ERR_IP_RANGE_OVERLAP ;
        m_ipaStart.SetFocus();
    }
    else if ( ! dhcpExclusionRange.IsSubset( dhcpScopeRange ) )
    {
        //
        //  Guarantee that the new range is an (improper) subset of the scope's range
        //
        err = IDS_ERR_IP_RANGE_NOT_SUBSET ;
        m_ipaStart.SetFocus();
    }
    if ( err == 0 )
    {
        //TRY
        {
            //
            //  Create a new IP range object and add it to the current list
            //
            CDhcpIpRange * pIpRange = new CDhcpIpRange( dhcpExclusionRange ) ;

                        m_listExclusions.AddTail(pIpRange);

            //
            //  Refill the exclusions listbox including the new item.
            //
            Fill( (int) (m_listExclusions.GetCount() - 1) ) ;
        }
        //CATCH_ALL(e)
        //{
        //    err = ERROR_NOT_ENOUGH_MEMORY ;
        //}
        //END_CATCH_ALL
    }

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
    }
    else
    {
        //
        // Succesfully added the exlusion range, now blank out the
        // ip controls
        //
        m_ipaStart.ClearAddress();
        m_ipaEnd.ClearAddress();
        m_ipaStart.SetFocus();
        }
}

void CScopeWizSetExclusions::OnButtonExclusionDelete() 
{
    //
    //  Index into the listbox, delete the item from the active list
    //  and move its data into the edit controls
    //
    int index = m_listboxExclusions.GetCurSel() ;

    ASSERT( index >= 0 ) ;      // Button should not be enabled if no selection.
    if ( index < 0 )
    {
        return ;
    }

    POSITION pos = m_listExclusions.FindIndex(index);
        CDhcpIpRange * pdhcRange = (CDhcpIpRange *) m_listExclusions.GetAt(pos);

        m_listExclusions.RemoveAt(pos);

    ASSERT( pdhcRange != NULL ) ;

    //
    //  Put the deleted range into the exclusions controls
    //
    FillExcl( pdhcRange ) ;

    //
    //  Refill the list box and call HandleActivation()
    //
    if ( index >= m_listboxExclusions.GetCount() )
    {
        index-- ;
    }
    
        Fill( index ) ;
  
        m_ipaStart.SetFocus();

        UpdateButtons();
}

//
//  Format the IP range pair into the exclusion edit controls
//
void 
CScopeWizSetExclusions::FillExcl 
( 
    CDhcpIpRange * pdhcIpRange 
)
{
    LONG lStart = pdhcIpRange->QueryAddr( TRUE );
    LONG lEnd = pdhcIpRange->QueryAddr( FALSE );

    m_ipaStart.SetAddress( lStart ) ;
    m_ipaStart.SetModify( TRUE ) ;
    m_ipaStart.Invalidate() ;

    //
    // If the ending address is the same as the starting address,
    // do not fill in the ending address.
    //
    if (lStart != lEnd)
    {
        m_ipaEnd.SetAddress( lEnd ) ;
    }
    else
    {
        m_ipaEnd.ClearAddress();
    }

    m_ipaEnd.SetModify( TRUE ) ;
    m_ipaEnd.Invalidate() ;
}

//
//  Convert the IP address range controls to a range.
//
BOOL 
CScopeWizSetExclusions::GetExclusionRange 
( 
    CDhcpIpRange & dhcIpRange 
)
{
    DHCP_IP_RANGE dhipr ;

    if ( !m_ipaStart.GetAddress( & dhipr.StartAddress ) )
    {
        m_ipaStart.SetFocus();
        return FALSE ;
    }
    if ( !m_ipaEnd.GetAddress( & dhipr.EndAddress ) )
    {
        //
        // If no ending range was specified, assume a singular exlusion
        // (the starting address) was requested.
        //
        m_ipaEnd.SetFocus();
        dhipr.EndAddress = dhipr.StartAddress;
    }

    dhcIpRange = dhipr ;
    return (BOOL) dhcIpRange ;
}

BOOL 
CScopeWizSetExclusions::IsOverlappingRange 
( 
    CDhcpIpRange & dhcpIpRange 
)
{
    POSITION pos;
        CDhcpIpRange * pdhcpRange ;
    BOOL bOverlap = FALSE ;

        pos = m_listExclusions.GetHeadPosition();
    while ( pos )
    {
                pdhcpRange = m_listExclusions.GetNext(pos);
        if ( bOverlap = pdhcpRange->IsOverlap( dhcpIpRange ) )
        {
            break ;
        }
    }

    return bOverlap ;
}

//
//  Fill the exclusions listbox from the current list
//
void 
CScopeWizSetExclusions::Fill 
( 
    int         nCurSel, 
    BOOL        bToggleRedraw 
)
{
        POSITION pos;
    CDhcpIpRange * pIpRange ;
    CString strIp1 ;
    CString strIp2 ;
    CString strFormatPair ;
    CString strFormatSingleton ;
    TCHAR chBuff [STRING_LENGTH_MAX] ;

    if ( ! strFormatPair.LoadString( IDS_INFO_FORMAT_IP_RANGE ) )
    {
        return ;
    }

    if ( ! strFormatSingleton.LoadString( IDS_INFO_FORMAT_IP_UNITARY ) )
    {
        return ;
    }

    if ( bToggleRedraw )
    {
        m_listboxExclusions.SetRedraw( FALSE ) ;
    }

    m_listboxExclusions.ResetContent() ;
        pos = m_listExclusions.GetHeadPosition();

    while ( pos )
    {
        pIpRange = m_listExclusions.GetNext(pos);

                DHCP_IP_RANGE dhipr = *pIpRange ;

        CString & strFmt = dhipr.StartAddress == dhipr.EndAddress
                ? strFormatSingleton
                : strFormatPair ;

        //
        //  Format the IP addresses
        //
        UtilCvtIpAddrToWstr( dhipr.StartAddress, &strIp1 ) ;
        UtilCvtIpAddrToWstr( dhipr.EndAddress, &strIp2 ) ;

        //
        //  Construct the display line
        //
        ::wsprintf( chBuff,
                (LPCTSTR) strFmt,
                (LPCTSTR) strIp1,
                (LPCTSTR) strIp2 ) ;

        //
        //  Add it to the list box.                     
        //
        if ( m_listboxExclusions.AddString( chBuff ) < 0 )
        {
            break ;
        }
    }

    //
    //  Check that we loaded the list box successfully.
    //
    if ( pos != NULL )
    {
        AfxMessageBox( IDS_ERR_DLG_UPDATE ) ;
    }

    if ( bToggleRedraw )
    {
        m_listboxExclusions.SetRedraw( TRUE ) ;
        m_listboxExclusions.Invalidate() ;
    }

    if ( nCurSel >= 0 )
    {
        m_listboxExclusions.SetCurSel( nCurSel ) ;
    }
}

void CScopeWizSetExclusions::UpdateButtons() 
{
        DWORD   dwAddress;
        BOOL    bEnable;

        m_ipaStart.GetAddress(&dwAddress);

        if (dwAddress)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonExclusionAdd.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonExclusionAdd.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonExclusionAdd.EnableWindow(bEnable);
        
        if (m_listboxExclusions.GetCurSel() != LB_ERR)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonExclusionDelete.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonExclusionDelete.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonExclusionDelete.EnableWindow(bEnable);
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizLeaseTime property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizLeaseTime, CPropertyPageBase)

CScopeWizLeaseTime::CScopeWizLeaseTime() : CPropertyPageBase(CScopeWizLeaseTime::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizLeaseTime)
        //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SCOPE_WIZ_LEASE_TITLE, IDS_SCOPE_WIZ_LEASE_SUBTITLE);
}

CScopeWizLeaseTime::~CScopeWizLeaseTime()
{
}

void CScopeWizLeaseTime::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizLeaseTime)
        DDX_Control(pDX, IDC_SPIN_LEASE_MINUTES, m_spinMinutes);
        DDX_Control(pDX, IDC_SPIN_LEASE_HOURS, m_spinHours);
        DDX_Control(pDX, IDC_SPIN_LEASE_DAYS, m_spinDays);
        DDX_Control(pDX, IDC_EDIT_LEASE_MINUTES, m_editMinutes);
        DDX_Control(pDX, IDC_EDIT_LEASE_HOURS, m_editHours);
        DDX_Control(pDX, IDC_EDIT_LEASE_DAYS, m_editDays);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizLeaseTime, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizLeaseTime)
        ON_EN_CHANGE(IDC_EDIT_LEASE_HOURS, OnChangeEditLeaseHours)
        ON_EN_CHANGE(IDC_EDIT_LEASE_MINUTES, OnChangeEditLeaseMinutes)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizLeaseTime message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizLeaseTime::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        m_spinMinutes.SetRange(0, MINUTES_MAX);
        m_spinHours.SetRange(0, HOURS_MAX);
        m_spinDays.SetRange(0, 999);

        m_editMinutes.LimitText(2);
        m_editHours.LimitText(2);
        m_editDays.LimitText(3);

        m_spinMinutes.SetPos(CScopeWizLeaseTime::m_nMinutesDefault);
        m_spinHours.SetPos(CScopeWizLeaseTime::m_nHoursDefault);
        m_spinDays.SetPos(CScopeWizLeaseTime::m_nDaysDefault);

        ActivateDuration(TRUE);

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizLeaseTime::OnWizardNext() 
{
    DWORD dwLeaseTime = GetLeaseTime();
    if (dwLeaseTime == 0)
    {
        AfxMessageBox(IDS_ERR_NO_DURATION_SPECIFIED);
        return -1;
    }
    else
    {
            return IDW_SCOPE_CONFIGURE_OPTIONS;
    }
}

LRESULT CScopeWizLeaseTime::OnWizardBack() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
        if (pScopeWiz->GetCreateSuperscope())
        {
                return IDW_SCOPE_CREATE_SUPERSCOPE;
        }
        else
        {
                return IDW_SCOPE_SET_EXCLUSIONS;
        }
}

BOOL CScopeWizLeaseTime::OnSetActive() 
{
        GetHolder()->SetWizardButtonsMiddle(TRUE);
        
        return CPropertyPageBase::OnSetActive();
}

void CScopeWizLeaseTime::OnChangeEditLeaseHours() 
{
    if (IsWindow(m_editHours.GetSafeHwnd()))
    {
        CString strText;
        m_editHours.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > HOURS_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(HOURS_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editHours.SetWindowText(strText);
            m_spinHours.SetPos(HOURS_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }
}

void CScopeWizLeaseTime::OnChangeEditLeaseMinutes() 
{
    if (IsWindow(m_editMinutes.GetSafeHwnd()))
    {
        CString strText;
        m_editMinutes.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > MINUTES_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MINUTES_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMinutes.SetWindowText(strText);
            m_spinMinutes.SetPos(MINUTES_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }
}

DWORD
CScopeWizLeaseTime::GetLeaseTime()
{
        DWORD dwLeaseTime = 0;

        int nDays, nHours, nMinutes;

        nDays = m_spinDays.GetPos();
        nHours = m_spinHours.GetPos();
        nMinutes = m_spinMinutes.GetPos();

        //
        // Lease time is in minutes so convert
        //
        dwLeaseTime = UtilConvertLeaseTime(nDays, nHours, nMinutes);

        return dwLeaseTime;
}

void 
CScopeWizLeaseTime::ActivateDuration
(
        BOOL fActive
)
{
        m_spinMinutes.EnableWindow(fActive);
    m_spinHours.EnableWindow(fActive);
    m_spinDays.EnableWindow(fActive);

        m_editMinutes.EnableWindow(fActive);
    m_editHours.EnableWindow(fActive);
    m_editDays.EnableWindow(fActive);

        GetDlgItem(IDC_STATIC_DAYS)->EnableWindow(fActive);
        GetDlgItem(IDC_STATIC_HOURS)->EnableWindow(fActive);
        GetDlgItem(IDC_STATIC_MINUTES)->EnableWindow(fActive);
}   

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizCreateSuperscope property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizCreateSuperscope, CPropertyPageBase)

CScopeWizCreateSuperscope::CScopeWizCreateSuperscope() : CPropertyPageBase(CScopeWizCreateSuperscope::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizCreateSuperscope)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SCOPE_WIZ_SUPERSCOPE_TITLE, IDS_SCOPE_WIZ_SUPERSCOPE_SUBTITLE);
}

CScopeWizCreateSuperscope::~CScopeWizCreateSuperscope()
{
}

void CScopeWizCreateSuperscope::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizCreateSuperscope)
        DDX_Control(pDX, IDC_STATIC_SUPERSCOPE_INFO, m_staticInfo);
        DDX_Control(pDX, IDC_STATIC_WARNING_TEXT, m_staticWarning);
        DDX_Control(pDX, IDC_STATIC_ICON_WARNING, m_staticIcon);
        DDX_Control(pDX, IDC_RADIO_SUPERSCOPE_NO, m_radioNo);
        DDX_Control(pDX, IDC_RADIO_SUPERSCOPE_YES, m_radioYes);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizCreateSuperscope, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizCreateSuperscope)
        ON_BN_CLICKED(IDC_RADIO_SUPERSCOPE_NO, OnRadioSuperscopeNo)
        ON_BN_CLICKED(IDC_RADIO_SUPERSCOPE_YES, OnRadioSuperscopeYes)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizCreateSuperscope message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizCreateSuperscope::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        m_radioNo.SetCheck(1);
        m_radioYes.SetCheck(0);

    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizCreateSuperscope::OnWizardNext() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
        pScopeWiz->SetCreateSuperscope(TRUE);

        return IDW_SCOPE_LEASE_TIME;
}

LRESULT CScopeWizCreateSuperscope::OnWizardBack() 
{
        return IDW_SCOPE_SET_SCOPE;
}

BOOL CScopeWizCreateSuperscope::OnSetActive() 
{
        UpdateButtons();

    UpdateWarning();

        return CPropertyPageBase::OnSetActive();
}

void CScopeWizCreateSuperscope::OnRadioSuperscopeNo() 
{
        m_radioNo.SetCheck(1);
        m_radioYes.SetCheck(0);

        UpdateButtons();
}

void CScopeWizCreateSuperscope::OnRadioSuperscopeYes() 
{
        m_radioNo.SetCheck(0);
        m_radioYes.SetCheck(1);

        UpdateButtons();
}

void
CScopeWizCreateSuperscope::UpdateButtons()
{
        if (m_radioYes.GetCheck())
        {
                GetHolder()->SetWizardButtonsMiddle(TRUE);
        }
        else
        {
                GetHolder()->SetWizardButtonsMiddle(FALSE);
        }
}

void
CScopeWizCreateSuperscope::UpdateWarning()
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
    CString     strText;

    CDhcpIpRange    ipRange;
    DHCP_IP_ADDRESS dhcpSubnetMask;
    DHCP_IP_ADDRESS startAddr, endAddr;

    // get the range and mask the user entered
    pScopeWiz->m_pageSetRange.GetScopeRange(&ipRange);
    dhcpSubnetMask = pScopeWiz->m_pageSetRange.GetSubnetMask();

    startAddr = ipRange.QueryAddr(TRUE);
    endAddr = ipRange.QueryAddr(FALSE);

    // now calculate how many addresses per scope
    int nLength = pScopeWiz->m_pageSetRange.m_spinMaskLength.GetPos();
    int nCount = 32 - nLength;

    DWORD dwAddrCount = 1;

    int nAddrCount = (int) (dwAddrCount << (nCount));
    
    // calculate how many scopes are there
    int nScopeCount = ((endAddr & dhcpSubnetMask) - (startAddr & dhcpSubnetMask)) >> nCount;

    nScopeCount ++;
    
    // put up the informative text
    strText.Format(IDS_CREATE_SUPERSCOPE_INFO, nScopeCount, nAddrCount);
    m_staticInfo.SetWindowText(strText);

    // check to seee if we need to warn the user
    BOOL fShowWarning = FALSE;

    if (nScopeCount > SCOPE_WARNING_COUNT)
    {
        fShowWarning = TRUE;

        HICON hIcon = AfxGetApp()->LoadStandardIcon(IDI_EXCLAMATION);
        if (hIcon)
        {
            m_staticIcon.ShowWindow(TRUE);
            m_staticIcon.SetIcon(hIcon);
        }

        strText.Format(IDS_CREATE_SUPERSCOPE_WARNING, SCOPE_WARNING_COUNT);
        m_staticWarning.SetWindowText(strText);
    }

    m_staticIcon.ShowWindow(fShowWarning);
    m_staticWarning.ShowWindow(fShowWarning);
}

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizFinished property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CScopeWizFinished, CPropertyPageBase)

CScopeWizFinished::CScopeWizFinished() : CPropertyPageBase(CScopeWizFinished::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizFinished)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CScopeWizFinished::~CScopeWizFinished()
{
}

void CScopeWizFinished::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizFinished)
        DDX_Control(pDX, IDC_STATIC_FINISHED_TITLE, m_staticTitle);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizFinished, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizFinished)
                // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizFinished message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CScopeWizFinished::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        CString strFontName;
        CString strFontSize;

        strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
        strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
        if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);

    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizFinished::OnWizardBack() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
    if (pScopeWiz->m_fOptionsConfigured)
    {
        return IDW_SCOPE_CONFIGURE_ACTIVATE;
    }
    else
    {
            return IDW_SCOPE_CONFIGURE_OPTIONS;
    }
}

BOOL CScopeWizFinished::OnWizardFinish()
{
        DWORD err;

    BEGIN_WAIT_CURSOR;

    err = GetHolder()->OnFinish();

    END_WAIT_CURSOR;
        
        if (err) 
        {
                ::DhcpMessageBox(err);
                return FALSE;
        }
        else
        {
                return TRUE;
        }
}

BOOL CScopeWizFinished::OnSetActive() 
{
        GetHolder()->SetWizardButtonsLast(TRUE);
        
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
    GetDlgItem(IDC_STATIC_FINISHED_MORE)->ShowWindow(!pScopeWiz->m_fOptionsConfigured);
    GetDlgItem(IDC_STATIC_FINISHED_MORE2)->ShowWindow(!pScopeWiz->m_fOptionsConfigured);
    GetDlgItem(IDC_STATIC_FINISHED_MORE3)->ShowWindow(!pScopeWiz->m_fOptionsConfigured);

    return CPropertyPageBase::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizWelcome property page

IMPLEMENT_DYNCREATE(CScopeWizWelcome, CPropertyPageBase)

CScopeWizWelcome::CScopeWizWelcome() : CPropertyPageBase(CScopeWizWelcome::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizWelcome)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CScopeWizWelcome::~CScopeWizWelcome()
{
}

void CScopeWizWelcome::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizWelcome)
        DDX_Control(pDX, IDC_STATIC_WELCOME_TITLE, m_staticTitle);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizWelcome, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizWelcome)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizWelcome message handlers
BOOL CScopeWizWelcome::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
        CString strFontName;
        CString strFontSize;

        strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
        strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
        if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);
        
    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CScopeWizWelcome::OnSetActive() 
{
    GetHolder()->SetWizardButtonsFirst(TRUE);
        
        return CPropertyPageBase::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizConfigOptions property page

IMPLEMENT_DYNCREATE(CScopeWizConfigOptions, CPropertyPageBase)

CScopeWizConfigOptions::CScopeWizConfigOptions() : CPropertyPageBase(CScopeWizConfigOptions::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizConfigOptions)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    InitWiz97(FALSE, IDS_SCOPE_WIZ_CONFIG_TITLE, IDS_SCOPE_WIZ_CONFIG_SUBTITLE);
}

CScopeWizConfigOptions::~CScopeWizConfigOptions()
{
}

void CScopeWizConfigOptions::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizConfigOptions)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizConfigOptions, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizConfigOptions)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizConfigOptions message handlers

BOOL CScopeWizConfigOptions::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
    ((CButton *) GetDlgItem(IDC_RADIO_YES))->SetCheck(TRUE);

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizConfigOptions::OnWizardNext() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
    LRESULT lNextPage = IDW_SCOPE_FINISHED;
    BOOL fConfigureOptionsNow = FALSE;

    if (((CButton *) GetDlgItem(IDC_RADIO_YES))->GetCheck())
    {
        fConfigureOptionsNow = TRUE;            
        lNextPage = IDW_SCOPE_CONFIGURE_ROUTER;
    }

    pScopeWiz->m_fOptionsConfigured = fConfigureOptionsNow;

        return lNextPage;
}

LRESULT CScopeWizConfigOptions::OnWizardBack() 
{
        return IDW_SCOPE_LEASE_TIME;
}

BOOL CScopeWizConfigOptions::OnSetActive() 
{
        GetHolder()->SetWizardButtonsMiddle(TRUE);

        return CPropertyPageBase::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizRouter property page

IMPLEMENT_DYNCREATE(CScopeWizRouter, CPropertyPageBase)

CScopeWizRouter::CScopeWizRouter() : CPropertyPageBase(CScopeWizRouter::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizRouter)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    InitWiz97(FALSE, IDS_SCOPE_WIZ_ROUTER_TITLE, IDS_SCOPE_WIZ_ROUTER_SUBTITLE);
}

CScopeWizRouter::~CScopeWizRouter()
{
}

void CScopeWizRouter::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizRouter)
        DDX_Control(pDX, IDC_LIST_DEFAULT_GW_LIST, m_listboxRouters);
        DDX_Control(pDX, IDC_BUTTON_DEFAULT_GW_DELETE, m_buttonDelete);
        DDX_Control(pDX, IDC_BUTTON_DEFAULT_GW_ADD, m_buttonAdd);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_UP, m_buttonIpAddrUp);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_DOWN, m_buttonIpAddrDown);
        //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_DEFAULT_GW, m_ipaRouter);
}


BEGIN_MESSAGE_MAP(CScopeWizRouter, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizRouter)
        ON_BN_CLICKED(IDC_BUTTON_DEFAULT_GW_ADD, OnButtonDefaultGwAdd)
        ON_BN_CLICKED(IDC_BUTTON_DEFAULT_GW_DELETE, OnButtonDefaultGwDelete)
        ON_LBN_SELCHANGE(IDC_LIST_DEFAULT_GW_LIST, OnSelchangeListDefaultGwList)
        ON_EN_CHANGE(IDC_IPADDR_DEFAULT_GW, OnChangeRouter)
        ON_WM_DESTROY()
        //}}AFX_MSG_MAP

        ON_BN_CLICKED(IDC_BUTTON_IPADDR_UP, OnButtonIpAddrUp)
        ON_BN_CLICKED(IDC_BUTTON_IPADDR_DOWN, OnButtonIpAddrDown)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizRouter message handlers

BOOL CScopeWizRouter::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
    m_buttonDelete.EnableWindow(FALSE);
    m_buttonAdd.EnableWindow(FALSE);
        
        UpdateButtons();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CScopeWizRouter::OnDestroy() 
{
        CPropertyPageBase::OnDestroy();
}

LRESULT CScopeWizRouter::OnWizardNext() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());

    // now build the option info for the routers
    if (m_listboxRouters.GetCount() == 0)
    {
        if (pScopeWiz->m_poptRouters)
        {
            delete pScopeWiz->m_poptRouters;
            pScopeWiz->m_poptRouters = NULL;
        }
    }
    else
    {
        // we have some DNS servers, get the option info from the master list and build an
        // option info struct we can use later
        CDhcpOption * pRoutersOption = pScopeWiz->m_pDefaultOptions->Find(DHCP_OPTION_ID_ROUTERS, NULL);
        if (pRoutersOption)
        {
            CDhcpOption * pNewRouters;

            if (pScopeWiz->m_poptRouters)
                pNewRouters = pScopeWiz->m_poptRouters;
            else
                pNewRouters = new CDhcpOption(*pRoutersOption);

            if (pNewRouters)
            {
                CDhcpOptionValue optValue = pNewRouters->QueryValue();

                optValue.SetUpperBound(m_listboxRouters.GetCount());

                // grab stuff from the listbox and store it in the option value
                for (int i = 0; i < m_listboxRouters.GetCount(); i++)
                {
                    DWORD dwIp = (DWORD) m_listboxRouters.GetItemData(i);
                    optValue.SetIpAddr(dwIp, i);
                }

                pNewRouters->Update(optValue);
           
                pScopeWiz->m_poptRouters = pNewRouters;
            }
        }

    }
        
        return CPropertyPageBase::OnWizardNext();
}

LRESULT CScopeWizRouter::OnWizardBack() 
{
        return CPropertyPageBase::OnWizardBack();
}

BOOL CScopeWizRouter::OnSetActive() 
{
        return CPropertyPageBase::OnSetActive();
}

void CScopeWizRouter::OnButtonDefaultGwAdd() 
{
    DWORD dwIp;
    m_ipaRouter.GetAddress(&dwIp);

    if (dwIp)
    {
        CString strText;

        UtilCvtIpAddrToWstr(dwIp, &strText);
        int nIndex = m_listboxRouters.AddString(strText);
        m_listboxRouters.SetItemData(nIndex, dwIp);
    }

    m_ipaRouter.ClearAddress();
    m_ipaRouter.SetFocus();
}

void CScopeWizRouter::OnButtonDefaultGwDelete() 
{
    int nSel = m_listboxRouters.GetCurSel();
    if (nSel != LB_ERR)
    {
        m_ipaRouter.SetAddress((DWORD)m_listboxRouters.GetItemData(nSel));
        m_listboxRouters.DeleteString(nSel);
        m_ipaRouter.SetFocus();
    }

    UpdateButtons();
}

void CScopeWizRouter::OnSelchangeListDefaultGwList() 
{
    UpdateButtons();
}

void CScopeWizRouter::OnChangeRouter()
{
    UpdateButtons();
}

void CScopeWizRouter::UpdateButtons()
{
        DWORD   dwAddress;
        BOOL    bEnable;

        m_ipaRouter.GetAddress(&dwAddress);

        if (dwAddress)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonAdd.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonAdd.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonAdd.EnableWindow(bEnable);
        
        if (m_listboxRouters.GetCurSel() != LB_ERR)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonDelete.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonDelete.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonDelete.EnableWindow(bEnable);

        // up and down buttons
        BOOL bEnableUp = (m_listboxRouters.GetCurSel() >= 0) && (m_listboxRouters.GetCurSel() != 0);
        m_buttonIpAddrUp.EnableWindow(bEnableUp);

        BOOL bEnableDown = (m_listboxRouters.GetCurSel() >= 0) && (m_listboxRouters.GetCurSel() < m_listboxRouters.GetCount() - 1);
        m_buttonIpAddrDown.EnableWindow(bEnableDown);
}

void CScopeWizRouter::OnButtonIpAddrDown() 
{
        MoveValue(FALSE);
    if (m_buttonIpAddrDown.IsWindowEnabled())
        m_buttonIpAddrDown.SetFocus();
    else
        m_buttonIpAddrUp.SetFocus();
}

void CScopeWizRouter::OnButtonIpAddrUp() 
{
        MoveValue(TRUE);
    if (m_buttonIpAddrUp.IsWindowEnabled())
        m_buttonIpAddrUp.SetFocus();
    else
        m_buttonIpAddrDown.SetFocus();
}

void CScopeWizRouter::MoveValue(BOOL bUp)
{
        // now get which item is selected in the listbox
        int cFocus = m_listboxRouters.GetCurSel();
        int cNewFocus;
        DWORD err;

        // make sure it's valid for this operation
        if ( (bUp && cFocus <= 0) ||
                 (!bUp && cFocus >= m_listboxRouters.GetCount()) )
        {
           return;
        }

        // move the value up/down
        CATCH_MEM_EXCEPTION
        {
                if (bUp)
                {
                        cNewFocus = cFocus - 1;
                }
                else
                {
                        cNewFocus = cFocus + 1;
                }

                // remove the old one
                DWORD dwIp = (DWORD) m_listboxRouters.GetItemData(cFocus);
                m_listboxRouters.DeleteString(cFocus);

                // re-add it in it's new home
            CString strText;
            UtilCvtIpAddrToWstr(dwIp, &strText);
                m_listboxRouters.InsertString(cNewFocus, strText);
                m_listboxRouters.SetItemData(cNewFocus, dwIp);

                m_listboxRouters.SetCurSel(cNewFocus);
        }
        END_MEM_EXCEPTION(err)

        UpdateButtons();
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizDNS property page

IMPLEMENT_DYNCREATE(CScopeWizDNS, CPropertyPageBase)

CScopeWizDNS::CScopeWizDNS() : CPropertyPageBase(CScopeWizDNS::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizDNS)
        //}}AFX_DATA_INIT
    InitWiz97(FALSE, IDS_SCOPE_WIZ_DNS_TITLE, IDS_SCOPE_WIZ_DNS_SUBTITLE);
}

CScopeWizDNS::~CScopeWizDNS()
{
}

void CScopeWizDNS::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizDNS)
        DDX_Control(pDX, IDC_EDIT_SERVER_NAME, m_editServerName);
        DDX_Control(pDX, IDC_BUTTON_RESOLVE, m_buttonResolve);
        DDX_Control(pDX, IDC_BUTTON_DNS_DELETE, m_buttonDelete);
        DDX_Control(pDX, IDC_BUTTON_DNS_ADD, m_buttonAdd);
        DDX_Control(pDX, IDC_EDIT_DOMAIN_NAME, m_editDomainName);
        DDX_Control(pDX, IDC_LIST_DNS_LIST, m_listboxDNSServers);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_UP, m_buttonIpAddrUp);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_DOWN, m_buttonIpAddrDown);
        //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_DNS_SERVER, m_ipaDNS);
}


BEGIN_MESSAGE_MAP(CScopeWizDNS, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizDNS)
        ON_BN_CLICKED(IDC_BUTTON_DNS_ADD, OnButtonDnsAdd)
        ON_BN_CLICKED(IDC_BUTTON_DNS_DELETE, OnButtonDnsDelete)
        ON_LBN_SELCHANGE(IDC_LIST_DNS_LIST, OnSelchangeListDnsList)
        ON_EN_CHANGE(IDC_IPADDR_DNS_SERVER, OnChangeDnsServer)
        ON_WM_DESTROY()
        ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
        ON_BN_CLICKED(IDC_BUTTON_RESOLVE, OnButtonResolve)
        //}}AFX_MSG_MAP

        ON_BN_CLICKED(IDC_BUTTON_IPADDR_UP, OnButtonIpAddrUp)
        ON_BN_CLICKED(IDC_BUTTON_IPADDR_DOWN, OnButtonIpAddrDown)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizDNS message handlers

BOOL CScopeWizDNS::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
    m_buttonDelete.EnableWindow(FALSE);
    m_buttonAdd.EnableWindow(FALSE);
        
        UpdateButtons();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CScopeWizDNS::OnDestroy() 
{
        CPropertyPageBase::OnDestroy();
}

LRESULT CScopeWizDNS::OnWizardNext() 
{
    // build the option stuff for the domain name
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());
    CString strText;

    m_editDomainName.GetWindowText(strText);
    if (strText.IsEmpty())
    {
        if (pScopeWiz->m_poptDomainName)
        {
            delete pScopeWiz->m_poptDomainName;
            pScopeWiz->m_poptDomainName = NULL;
        }
    }
    else
    {
        // we have a domain name, get the option info from the master list and build an
        // option info struct we can use later
        CDhcpOption * pDomainNameOption = pScopeWiz->m_pDefaultOptions->Find(DHCP_OPTION_ID_DOMAIN_NAME, NULL);
        if (pDomainNameOption)
        {
            CDhcpOption * pNewDomainName;
            
            if (pScopeWiz->m_poptDomainName)
                pNewDomainName = pScopeWiz->m_poptDomainName;
            else
                pNewDomainName = new CDhcpOption(*pDomainNameOption);

            if (pNewDomainName)
            {
                CDhcpOptionValue optValue = pNewDomainName->QueryValue();

                optValue.SetString(strText);
                pNewDomainName->Update(optValue);
            
                pScopeWiz->m_poptDomainName = pNewDomainName;
            }
        }
    }

    // now build the option info for the DNS servers
    if (m_listboxDNSServers.GetCount() == 0)
    {
        if (pScopeWiz->m_poptDNSServers)
        {
            delete pScopeWiz->m_poptDNSServers;
            pScopeWiz->m_poptDNSServers = NULL;
        }
    }
    else
    {
        // we have some DNS servers, get the option info from the master list and build an
        // option info struct we can use later
        CDhcpOption * pDNSServersOption = pScopeWiz->m_pDefaultOptions->Find(DHCP_OPTION_ID_DNS_SERVERS, NULL);
        if (pDNSServersOption)
        {
            CDhcpOption * pNewDNS;
            
            if (pScopeWiz->m_poptDNSServers)
                pNewDNS = pScopeWiz->m_poptDNSServers;
            else
                pNewDNS = new CDhcpOption(*pDNSServersOption);

            if (pNewDNS)
            {
                CDhcpOptionValue optValue = pNewDNS->QueryValue();

                optValue.SetUpperBound(m_listboxDNSServers.GetCount());

                // grab stuff from the listbox and store it in the option value
                for (int i = 0; i < m_listboxDNSServers.GetCount(); i++)
                {
                    DWORD dwIp = (DWORD)m_listboxDNSServers.GetItemData(i);
                    optValue.SetIpAddr(dwIp, i);
                }

                pNewDNS->Update(optValue);
           
                pScopeWiz->m_poptDNSServers = pNewDNS;
            }
        }

    }

        return CPropertyPageBase::OnWizardNext();
}

LRESULT CScopeWizDNS::OnWizardBack() 
{
        return CPropertyPageBase::OnWizardBack();
}

BOOL CScopeWizDNS::OnSetActive() 
{
        return CPropertyPageBase::OnSetActive();
}

void CScopeWizDNS::OnButtonDnsAdd() 
{
    DWORD dwIp;
    m_ipaDNS.GetAddress(&dwIp);

    if (dwIp)
    {
        CString strText;

        UtilCvtIpAddrToWstr(dwIp, &strText);
        int nIndex = m_listboxDNSServers.AddString(strText);
        m_listboxDNSServers.SetItemData(nIndex, dwIp);
    }

    m_ipaDNS.ClearAddress();
    m_ipaDNS.SetFocus();
}

void CScopeWizDNS::OnButtonDnsDelete() 
{
    int nSel = m_listboxDNSServers.GetCurSel();
    if (nSel != LB_ERR)
    {
        m_ipaDNS.SetAddress((DWORD)m_listboxDNSServers.GetItemData(nSel));
        m_listboxDNSServers.DeleteString(nSel);
        m_ipaDNS.SetFocus();
    }

    UpdateButtons();
}

void CScopeWizDNS::OnSelchangeListDnsList() 
{
    UpdateButtons();
}

void CScopeWizDNS::OnChangeDnsServer()
{
    UpdateButtons();
}

void CScopeWizDNS::UpdateButtons()
{
        DWORD   dwAddress;
        BOOL    bEnable;
    CString strServerName;

    // update the resolve button
    m_editServerName.GetWindowText(strServerName);
        m_buttonResolve.EnableWindow(strServerName.GetLength() > 0);

    m_ipaDNS.GetAddress(&dwAddress);

        if (dwAddress)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonAdd.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonAdd.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonAdd.EnableWindow(bEnable);
        
        if (m_listboxDNSServers.GetCurSel() != LB_ERR)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonDelete.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonDelete.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonDelete.EnableWindow(bEnable);

        // up and down buttons
        BOOL bEnableUp = (m_listboxDNSServers.GetCurSel() >= 0) && (m_listboxDNSServers.GetCurSel() != 0);
        m_buttonIpAddrUp.EnableWindow(bEnableUp);

        BOOL bEnableDown = (m_listboxDNSServers.GetCurSel() >= 0) && (m_listboxDNSServers.GetCurSel() < m_listboxDNSServers.GetCount() - 1);
        m_buttonIpAddrDown.EnableWindow(bEnableDown);
}

void CScopeWizDNS::OnButtonIpAddrDown() 
{
        MoveValue(FALSE);
    if (m_buttonIpAddrDown.IsWindowEnabled())
        m_buttonIpAddrDown.SetFocus();
    else
        m_buttonIpAddrUp.SetFocus();
}

void CScopeWizDNS::OnButtonIpAddrUp() 
{
        MoveValue(TRUE);
    if (m_buttonIpAddrUp.IsWindowEnabled())
        m_buttonIpAddrUp.SetFocus();
    else
        m_buttonIpAddrDown.SetFocus();
}

void CScopeWizDNS::MoveValue(BOOL bUp)
{
        // now get which item is selected in the listbox
        int cFocus = m_listboxDNSServers.GetCurSel();
        int cNewFocus;
        DWORD err;

        // make sure it's valid for this operation
        if ( (bUp && cFocus <= 0) ||
                 (!bUp && cFocus >= m_listboxDNSServers.GetCount()) )
        {
           return;
        }

        // move the value up/down
        CATCH_MEM_EXCEPTION
        {
                if (bUp)
                {
                        cNewFocus = cFocus - 1;
                }
                else
                {
                        cNewFocus = cFocus + 1;
                }

                // remove the old one
                DWORD dwIp = (DWORD) m_listboxDNSServers.GetItemData(cFocus);
                m_listboxDNSServers.DeleteString(cFocus);

                // re-add it in it's new home
            CString strText;
            UtilCvtIpAddrToWstr(dwIp, &strText);
                m_listboxDNSServers.InsertString(cNewFocus, strText);
                m_listboxDNSServers.SetItemData(cNewFocus, dwIp);

                m_listboxDNSServers.SetCurSel(cNewFocus);
        }
        END_MEM_EXCEPTION(err)

        UpdateButtons();
}

void CScopeWizDNS::OnChangeEditServerName() 
{
    UpdateButtons();
}

void CScopeWizDNS::OnButtonResolve() 
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString strServer;
        DHCP_IP_ADDRESS dhipa = 0;
        DWORD err = 0;

        m_editServerName.GetWindowText(strServer);

    //
    //  See what type of name it is.
    //
    BEGIN_WAIT_CURSOR

    switch (UtilCategorizeName(strServer))
    {
        case HNM_TYPE_IP:
            dhipa = ::UtilCvtWstrToIpAddr( strServer ) ;
            break ;

        case HNM_TYPE_NB:
        case HNM_TYPE_DNS:
            err = ::UtilGetHostAddress( strServer, & dhipa ) ;
                        if (!err)
                                UtilCvtIpAddrToWstr(dhipa, &strServer);
                        break ;
                            
        default:
            err = IDS_ERR_BAD_HOST_NAME ;
            break ;
    }

    END_WAIT_CURSOR

        if (err)
        {
                ::DhcpMessageBox(err);
        }
        else
        {
                m_ipaDNS.SetAddress(dhipa);     
        }
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizWINS property page

IMPLEMENT_DYNCREATE(CScopeWizWINS, CPropertyPageBase)

CScopeWizWINS::CScopeWizWINS() : CPropertyPageBase(CScopeWizWINS::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizWINS)
        //}}AFX_DATA_INIT
    InitWiz97(FALSE, IDS_SCOPE_WIZ_WINS_TITLE, IDS_SCOPE_WIZ_WINS_SUBTITLE);
}

CScopeWizWINS::~CScopeWizWINS()
{
}

void CScopeWizWINS::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizWINS)
        DDX_Control(pDX, IDC_BUTTON_RESOLVE, m_buttonResolve);
        DDX_Control(pDX, IDC_EDIT_SERVER_NAME, m_editServerName);
        DDX_Control(pDX, IDC_LIST_WINS_LIST, m_listboxWINSServers);
        DDX_Control(pDX, IDC_BUTTON_WINS_DELETE, m_buttonDelete);
        DDX_Control(pDX, IDC_BUTTON_WINS_ADD, m_buttonAdd);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_UP, m_buttonIpAddrUp);
        DDX_Control(pDX, IDC_BUTTON_IPADDR_DOWN, m_buttonIpAddrDown);
        //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_WINS_SERVER, m_ipaWINS);
}


BEGIN_MESSAGE_MAP(CScopeWizWINS, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizWINS)
        ON_BN_CLICKED(IDC_BUTTON_WINS_ADD, OnButtonWinsAdd)
        ON_BN_CLICKED(IDC_BUTTON_WINS_DELETE, OnButtonWinsDelete)
        ON_LBN_SELCHANGE(IDC_LIST_WINS_LIST, OnSelchangeListWinsList)
        ON_EN_CHANGE(IDC_IPADDR_WINS_SERVER, OnChangeWinsServer)
        ON_WM_DESTROY()
        ON_BN_CLICKED(IDC_BUTTON_RESOLVE, OnButtonResolve)
        ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
        //}}AFX_MSG_MAP

        ON_BN_CLICKED(IDC_BUTTON_IPADDR_UP, OnButtonIpAddrUp)
        ON_BN_CLICKED(IDC_BUTTON_IPADDR_DOWN, OnButtonIpAddrDown)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizWINS message handlers

BOOL CScopeWizWINS::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();
        
    m_buttonAdd.EnableWindow(FALSE);
    m_buttonDelete.EnableWindow(FALSE);

        UpdateButtons();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CScopeWizWINS::OnDestroy() 
{
        CPropertyPageBase::OnDestroy();
}

LRESULT CScopeWizWINS::OnWizardNext() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());

    // now build the option info for the routers
    if (m_listboxWINSServers.GetCount() == 0)
    {
        // get rid of the servers option if it is there
        if (pScopeWiz->m_poptWINSServers)
        {
            delete pScopeWiz->m_poptWINSServers;
            pScopeWiz->m_poptWINSServers = NULL;
        }

        // get rid of the node type option as well
        if (pScopeWiz->m_poptWINSNodeType)
        {
            delete pScopeWiz->m_poptWINSNodeType;
            pScopeWiz->m_poptWINSNodeType = NULL;
        }

    }
    else
    {
        // we have some DNS servers, get the option info from the master list and build an
        // option info struct we can use later
        CDhcpOption * pWINSServersOption = pScopeWiz->m_pDefaultOptions->Find(DHCP_OPTION_ID_WINS_SERVERS, NULL);
        if (pWINSServersOption)
        {
            CDhcpOption * pNewWINS;

            if (pScopeWiz->m_poptWINSServers)
                pNewWINS = pScopeWiz->m_poptWINSServers;
            else
                pNewWINS = new CDhcpOption(*pWINSServersOption);

            if (pNewWINS)
            {
                CDhcpOptionValue optValue = pNewWINS->QueryValue();

                optValue.SetUpperBound(m_listboxWINSServers.GetCount());

                // grab stuff from the listbox and store it in the option value
                for (int i = 0; i < m_listboxWINSServers.GetCount(); i++)
                {
                    DWORD dwIp = (DWORD)m_listboxWINSServers.GetItemData(i);
                    optValue.SetIpAddr(dwIp, i);
                }

                pNewWINS->Update(optValue);
           
                pScopeWiz->m_poptWINSServers = pNewWINS;
            }
        }

        // if we are configuring WINS, then we also need to set the node type option.  
        // we don't ask the user what type they want, the default should cover 95% of the cases
        CDhcpOption * pNodeTypeOption = pScopeWiz->m_pDefaultOptions->Find(DHCP_OPTION_ID_WINS_NODE_TYPE, NULL);
        if (pNodeTypeOption)
        {
            CDhcpOption * pNewNodeType;

            if (pScopeWiz->m_poptWINSNodeType)
                pNewNodeType = pScopeWiz->m_poptWINSNodeType;
            else
                pNewNodeType = new CDhcpOption(*pNodeTypeOption);
    
            if (pNewNodeType)
            {
                CDhcpOptionValue optValue = pNewNodeType->QueryValue();
                optValue.SetNumber(WINS_DEFAULT_NODE_TYPE);

                pNewNodeType->Update(optValue);
           
                pScopeWiz->m_poptWINSNodeType = pNewNodeType;
            }
        }
    }
        
        return CPropertyPageBase::OnWizardNext();
}

LRESULT CScopeWizWINS::OnWizardBack() 
{
        return CPropertyPageBase::OnWizardBack();
}

BOOL CScopeWizWINS::OnSetActive() 
{
        return CPropertyPageBase::OnSetActive();
}

void CScopeWizWINS::OnButtonWinsAdd() 
{
    DWORD dwIp;
    m_ipaWINS.GetAddress(&dwIp);

    if (dwIp)
    {
        CString strText;

        UtilCvtIpAddrToWstr(dwIp, &strText);
        int nIndex = m_listboxWINSServers.AddString(strText);
        m_listboxWINSServers.SetItemData(nIndex, dwIp);
    }

    m_ipaWINS.ClearAddress();
    m_ipaWINS.SetFocus();
}

void CScopeWizWINS::OnButtonWinsDelete() 
{
    int nSel = m_listboxWINSServers.GetCurSel();
    if (nSel != LB_ERR)
    {
        m_ipaWINS.SetAddress((DWORD)m_listboxWINSServers.GetItemData(nSel));
        m_listboxWINSServers.DeleteString(nSel);
        m_ipaWINS.SetFocus();
    }

    UpdateButtons();
}

void CScopeWizWINS::OnSelchangeListWinsList() 
{
    UpdateButtons();
}

void CScopeWizWINS::OnChangeWinsServer()
{
    UpdateButtons();
}

void CScopeWizWINS::UpdateButtons()
{
        DWORD   dwAddress;
        BOOL    bEnable;
    CString strServerName;

    // update the resolve button
    m_editServerName.GetWindowText(strServerName);
        m_buttonResolve.EnableWindow(strServerName.GetLength() > 0);

        m_ipaWINS.GetAddress(&dwAddress);

        if (dwAddress)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonAdd.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonAdd.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonAdd.EnableWindow(bEnable);
        
        if (m_listboxWINSServers.GetCurSel() != LB_ERR)
        {
                bEnable = TRUE;
        }
        else
        {
                bEnable = FALSE;
                if (m_buttonDelete.GetButtonStyle() & BS_DEFPUSHBUTTON)
                {
                        m_buttonDelete.SetButtonStyle(BS_PUSHBUTTON);
                }
        }
        m_buttonDelete.EnableWindow(bEnable);

        // up and down buttons
        BOOL bEnableUp = (m_listboxWINSServers.GetCurSel() >= 0) && (m_listboxWINSServers.GetCurSel() != 0);
        m_buttonIpAddrUp.EnableWindow(bEnableUp);

        BOOL bEnableDown = (m_listboxWINSServers.GetCurSel() >= 0) && (m_listboxWINSServers.GetCurSel() < m_listboxWINSServers.GetCount() - 1);
        m_buttonIpAddrDown.EnableWindow(bEnableDown);
}

void CScopeWizWINS::OnButtonIpAddrDown() 
{
        MoveValue(FALSE);
    if (m_buttonIpAddrDown.IsWindowEnabled())
        m_buttonIpAddrDown.SetFocus();
    else
        m_buttonIpAddrUp.SetFocus();
}

void CScopeWizWINS::OnButtonIpAddrUp() 
{
        MoveValue(TRUE);
    if (m_buttonIpAddrUp.IsWindowEnabled())
        m_buttonIpAddrUp.SetFocus();
    else
        m_buttonIpAddrDown.SetFocus();
}

void CScopeWizWINS::MoveValue(BOOL bUp)
{
        // now get which item is selected in the listbox
        int cFocus = m_listboxWINSServers.GetCurSel();
        int cNewFocus;
        DWORD err;

        // make sure it's valid for this operation
        if ( (bUp && cFocus <= 0) ||
                 (!bUp && cFocus >= m_listboxWINSServers.GetCount()) )
        {
           return;
        }

        // move the value up/down
        CATCH_MEM_EXCEPTION
        {
                if (bUp)
                {
                        cNewFocus = cFocus - 1;
                }
                else
                {
                        cNewFocus = cFocus + 1;
                }

                // remove the old one
                DWORD dwIp = (DWORD) m_listboxWINSServers.GetItemData(cFocus);
                m_listboxWINSServers.DeleteString(cFocus);

                // re-add it in it's new home
            CString strText;
            UtilCvtIpAddrToWstr(dwIp, &strText);
                m_listboxWINSServers.InsertString(cNewFocus, strText);
                m_listboxWINSServers.SetItemData(cNewFocus, dwIp);

                m_listboxWINSServers.SetCurSel(cNewFocus);
        }
        END_MEM_EXCEPTION(err)

        UpdateButtons();
}

void CScopeWizWINS::OnButtonResolve() 
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString strServer;
        DHCP_IP_ADDRESS dhipa = 0;
        DWORD err = 0;

        m_editServerName.GetWindowText(strServer);

    //
    //  See what type of name it is.
    //
    BEGIN_WAIT_CURSOR

    switch (UtilCategorizeName(strServer))
    {
        case HNM_TYPE_IP:
            dhipa = ::UtilCvtWstrToIpAddr( strServer ) ;
            break ;

        case HNM_TYPE_NB:
        case HNM_TYPE_DNS:
            err = ::UtilGetHostAddress( strServer, & dhipa ) ;
                        if (!err)
                                UtilCvtIpAddrToWstr(dhipa, &strServer);
                        break ;

        default:
            err = IDS_ERR_BAD_HOST_NAME ;
            break ;
    }

    END_WAIT_CURSOR

        if (err)
        {
                ::DhcpMessageBox(err);
        }
        else
        {
                m_ipaWINS.SetAddress(dhipa);    
        }
}

void CScopeWizWINS::OnChangeEditServerName() 
{
    UpdateButtons();    
}

/////////////////////////////////////////////////////////////////////////////
// CScopeWizActivate property page

IMPLEMENT_DYNCREATE(CScopeWizActivate, CPropertyPageBase)

CScopeWizActivate::CScopeWizActivate() : CPropertyPageBase(CScopeWizActivate::IDD)
{
        //{{AFX_DATA_INIT(CScopeWizActivate)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    InitWiz97(FALSE, IDS_SCOPE_WIZ_ACTIVATE_TITLE, IDS_SCOPE_WIZ_ACTIVATE_SUBTITLE);
}

CScopeWizActivate::~CScopeWizActivate()
{
}

void CScopeWizActivate::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CScopeWizActivate)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScopeWizActivate, CPropertyPageBase)
        //{{AFX_MSG_MAP(CScopeWizActivate)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScopeWizActivate message handlers

BOOL CScopeWizActivate::OnInitDialog() 
{
        CPropertyPageBase::OnInitDialog();

    ((CButton *) GetDlgItem(IDC_RADIO_YES))->SetCheck(TRUE);
        
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CScopeWizActivate::OnWizardNext() 
{
        CScopeWiz * pScopeWiz = reinterpret_cast<CScopeWiz *>(GetHolder());

    pScopeWiz->m_fActivateScope = (((CButton *) GetDlgItem(IDC_RADIO_YES))->GetCheck()) ? TRUE : FALSE;
        
        return CPropertyPageBase::OnWizardNext();
}

LRESULT CScopeWizActivate::OnWizardBack() 
{
        // TODO: Add your specialized code here and/or call the base class
        
        return CPropertyPageBase::OnWizardBack();
}

BOOL CScopeWizActivate::OnSetActive() 
{
        GetHolder()->SetWizardButtonsMiddle(TRUE);
        
        return CPropertyPageBase::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scope.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	scope.cpp
		This file contains all of the prototypes for the DHCP
		scope object and all objects that it may contain.  
		They include:

			CDhcpScope
			CDhcpReservations
			CDhcpReservationClient
			CDhcpActiveLeases
			CDhcpAddressPool
			CDhcpScopeOptions

    FILE HISTORY:
        
*/

#ifndef _SCOPE_H
#define _SCOPE_H

#ifndef _SCOPSTAT_H
#include "scopstat.h"   // Scope statistics
#endif

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

class CDhcpScope;
class CDhcpAddressPool;
class CDhcpReservations;
class CDhcpActiveLeases;
class CDhcpActiveLease;
class CDhcpScopeOptions;

#define DHCP_QDATA_SUBNET_INFO            0x00000004

/*---------------------------------------------------------------------------
    Class: QSort compare routine for sorting ip addresses in an array.
 ----------------------------------------------------------------------------*/

int __cdecl QCompare( const void *ip1, const void *ip2 );

/*---------------------------------------------------------------------------
	Class:	CDhcpScope
 ---------------------------------------------------------------------------*/
class CDhcpScope : public CMTDhcpHandler
{
public:
	CDhcpScope
	(
		ITFSComponentData * pComponentData,
		DHCP_IP_ADDRESS		dhcpScopeIp,
		DHCP_IP_MASK		dhcpSubnetMask,
		LPCWSTR				pName,
		LPCWSTR				pComment,
		DHCP_SUBNET_STATE	dhcpSubnetState = DhcpSubnetDisabled
	);

	CDhcpScope(ITFSComponentData * pComponentData, LPDHCP_SUBNET_INFO pdhcpSubnetInfo);
	CDhcpScope(ITFSComponentData * pComponentData, CSubnetInfo & subnetInfo);
	
	~CDhcpScope();

// Interface
public:
	// Node handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString();
    OVERRIDE_NodeHandler_DestroyHandler();
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    // choose the notifications that we want to handle
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

	// Result handler functionality we override

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
    virtual DWORD   UpdateStatistics(ITFSNode * pNode);
    HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
	
    int      GetImageIndex(BOOL bOpenImage);

    // CMTDhcpHandler overrides
    virtual void    OnHaveData(ITFSNode * pParent, ITFSNode * pNew);
	virtual void    OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	void SetServer(ITFSNode * pServerNode) { m_spServerNode.Set(pServerNode); }

	// public functions for scope manipulation
	LPCWSTR GetName() { return m_strName; };
	HRESULT SetName(LPCWSTR pName);
	
	LPCWSTR GetComment() { return m_strComment; };
	void    SetComment(LPCWSTR pComment) { m_strComment = pComment; };
	
	DWORD   UpdateIpRange(DHCP_IP_RANGE * pdhipr);
	DWORD   SetIpRange(DHCP_IP_RANGE *pdhcpIpRange, BOOL bSetOnServer);
	DWORD   SetIpRange(CDhcpIpRange & dhcpIpRange, BOOL bSetOnServer);
    void    QueryIpRange (DHCP_IP_RANGE * pdhipr);
    DWORD   GetIpRange (CDhcpIpRange * pdhipr);
	
	DHCP_IP_MASK QuerySubnetMask() { return m_dhcpSubnetMask; };
	
	DHCP_IP_ADDRESS GetAddress() { return m_dhcpIpAddress; }

	DWORD   AddElement(DHCP_SUBNET_ELEMENT_DATA * pdhcpSubnetElementData);
	DWORD   RemoveElement(DHCP_SUBNET_ELEMENT_DATA * pdhcpSubnetElementData, BOOL bForce = FALSE);
    
	// NT4 SP2 added functionality
    DWORD   AddElementV4(DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData);
	DWORD   RemoveElementV4(DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData, BOOL bForce = FALSE);

	// NT5 functionality
    DWORD   AddElementV5(DHCP_SUBNET_ELEMENT_DATA_V5 * pdhcpSubnetElementData);
	DWORD   RemoveElementV5(DHCP_SUBNET_ELEMENT_DATA_V5 * pdhcpSubnetElementData, BOOL bForce = FALSE);

	LPCWSTR GetServerIpAddress();
	void    GetServerIpAddress(DHCP_IP_ADDRESS * pdhcpIpAddress);
	
	void    GetServerVersion(LARGE_INTEGER& liVersion);

	CDhcpReservations * GetReservationsObject();
	CDhcpActiveLeases * GetActiveLeasesObject();
	CDhcpAddressPool  * GetAddressPoolObject();
	CDhcpScopeOptions * GetScopeOptionsObject();

	HRESULT GetReservationsNode(ITFSNode ** ppNode)
	{
		Assert(ppNode);
		SetI((LPUNKNOWN *) ppNode, m_spReservations);
		return hrOK;
	}
	HRESULT GetActiveLeasesNode(ITFSNode ** ppNode)
	{
		Assert(ppNode);
		SetI((LPUNKNOWN *) ppNode, m_spActiveLeases);
		return hrOK;
	}
	HRESULT GetScopeOptionsNode(ITFSNode ** ppNode)
	{
		Assert(ppNode);
		SetI((LPUNKNOWN *) ppNode, m_spOptions);
		return hrOK;
	}
	HRESULT GetAddressPoolNode(ITFSNode ** ppNode)
	{
		Assert(ppNode);
		SetI((LPUNKNOWN *) ppNode, m_spAddressPool);
		return hrOK;
	}
	
	// reservation functionality
    DWORD CreateReservation(const CDhcpClient * pClient);
	DWORD AddReservation(const CDhcpClient *pClient);
	DWORD DeleteReservation(CByteArray&	baHardwareAddress, DHCP_IP_ADDRESS dhcpReservedIpAddress);
	DWORD DeleteReservation(DHCP_CLIENT_UID	&dhcpClientUID, DHCP_IP_ADDRESS dhcpReservedIpAddress);
    DWORD UpdateReservation(const CDhcpClient * pClient, COptionValueEnum * pOptionValueEnum);
	DWORD RestoreReservationOptions(const CDhcpClient * pClient, COptionValueEnum * pOptionValueEnum);

	// lease functionality
    DWORD CreateClient(const CDhcpClient * pClient);
	DWORD SetClientInfo(const CDhcpClient * pClient);
	DWORD GetClientInfo(DHCP_IP_ADDRESS	dhcpClientIpAddress, LPDHCP_CLIENT_INFO * pdhcpClientInfo);
	DWORD DeleteClient(DHCP_IP_ADDRESS dhcpClientIpAddress);

	// exclusion functionality
    LONG  StoreExceptionList(CExclusionList * plistExclusions);
	DWORD AddExclusion(CDhcpIpRange & dhcpIpRange, BOOL bAddToUI = FALSE);
	DWORD RemoveExclusion(CDhcpIpRange & dhcpIpRange);
	BOOL  IsOverlappingRange(CDhcpIpRange & dhcpIpRange);
	DWORD IsValidExclusion(CDhcpIpRange & dhcpExclusion);

	// Functions to get and set the lease time
	DWORD GetLeaseTime(LPDWORD pdwLeaseTime);
	DWORD SetLeaseTime(DWORD dwLeaseTime);

	// Functions to get and set the dynamic bootp lease time
	DWORD GetDynBootpLeaseTime(LPDWORD pdwLeaseTime);
	DWORD SetDynBootpLeaseTime(DWORD dwLeaseTime);
	DWORD SetDynamicBootpInfo(UINT uRangeType, DWORD dwLeaseTime);

	// Functions to get and set the DNS reg option
	DWORD GetDnsRegistration(LPDWORD pDnsRegOption);
	DWORD SetDnsRegistration(DWORD DnsRegOption);
	
	// option functionality
    DWORD SetOptionValue(CDhcpOption *			pdhcType,
						 DHCP_OPTION_SCOPE_TYPE	dhcOptType,
						 DHCP_IP_ADDRESS		dhipaReservation = 0,
						 LPCTSTR				pClassName = NULL,
						 LPCTSTR				pVendorName = NULL);
	DWORD GetOptionValue(DHCP_OPTION_ID			OptionID,
						 DHCP_OPTION_SCOPE_TYPE	dhcOptType,
						 DHCP_OPTION_VALUE **	ppdhcOptionValue,
						 DHCP_IP_ADDRESS		dhipaReservation = 0,
						 LPCTSTR				pClassName = NULL,
						 LPCTSTR				pVendorName = NULL);
	DWORD RemoveOptionValue(DHCP_OPTION_ID			dhcOptId,
							DHCP_OPTION_SCOPE_TYPE	dhcOptType,
							DHCP_IP_ADDRESS			dhipaReservation = 0);
	DWORD SetInfo();

	// used to set this scope on the server
    DWORD SetSuperscope(LPCTSTR pSuperscopeName, BOOL bRemove);
	
    // interal state information
    BOOL  IsEnabled() {
        return m_dhcpSubnetState == DhcpSubnetEnabled ||
        m_dhcpSubnetState == DhcpSubnetEnabledSwitched; }
	void  SetState(DHCP_SUBNET_STATE dhcpSubnetState); 
	DHCP_SUBNET_STATE GetState() {
        return IsEnabled() ? DhcpSubnetEnabled :
        DhcpSubnetDisabled; }

    // used for initialization and querring of internal flag
    BOOL  IsInSuperscope() { return m_bInSuperscope; }
    void  SetInSuperscope(BOOL bInSuperscope) { m_bInSuperscope = bInSuperscope; }

    void SetOptionValueEnum(COptionValueEnum * pEnum)
    {
        m_ScopeOptionValues.DeleteAll();
        m_ScopeOptionValues.Copy(pEnum);
    }

    COptionValueEnum * GetOptionValueEnum()
    {
        return &m_ScopeOptionValues;
    }
    
	// dynamic bootp stuff
	void GetDynBootpClassName(CString & strName);

// Implementation
public:
	// helpers
	HRESULT GetServerNode(ITFSNode ** ppNode) 
	{ 
		m_spServerNode->AddRef(); 
		*ppNode = m_spServerNode; 
		return hrOK; 
	}
	CDhcpServer *  GetServerObject() { return GETHANDLER(CDhcpServer, m_spServerNode); }
	HRESULT        BuildDisplayName(CString * pstrDisplayName, LPCTSTR	pIpAddress, LPCTSTR	pName);
    void           UpdateToolbarStates();
    HRESULT        TriggerStatsRefresh();

private:
	// command Handlers
	DWORD	OnActivateScope(ITFSNode * pNode);
	HRESULT OnRefreshScope(ITFSNode * pNode, LPDATAOBJECT pDataObject, DWORD dwType);
	HRESULT OnReconcileScope(ITFSNode * pNode);
	HRESULT OnShowScopeStats(ITFSNode * pNode);
	HRESULT OnDelete(ITFSNode * pNode);
	HRESULT OnAddToSuperscope(ITFSNode * pNode);
	HRESULT OnRemoveFromSuperscope(ITFSNode * pNode);
	
	// Helpers
	HRESULT CreateSubcontainers(ITFSNode * pNode);

// Attributes
private:
	DHCP_IP_ADDRESS		m_dhcpIpAddress;   // Ip address for this scope
    DHCP_IP_MASK		m_dhcpSubnetMask;
    DWORD				m_dwClusterSize;
    DWORD				m_dwPreallocate;
	CString				m_strName;
	CString				m_strComment;
    CString             m_strState;
    DHCP_SUBNET_STATE	m_dhcpSubnetState;
    BOOL                m_bInSuperscope;

	SPITFSNode			m_spAddressPool;
	SPITFSNode 			m_spActiveLeases;
	SPITFSNode 			m_spReservations;
	SPITFSNode 			m_spOptions;

	SPITFSNode			m_spServerNode;

    CScopeStats         m_dlgStats;
    COptionValueEnum    m_ScopeOptionValues;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpScopeSubobject
		All subobjects of a scope derive from this to provide base
		functionality to get information from the scope.
 ---------------------------------------------------------------------------*/
class CDhcpScopeSubobject
{
public:
	CDhcpScope * GetScopeObject(ITFSNode * pNode, 
								BOOL bResClient = FALSE)
	{ 
		if (pNode == NULL)
			return NULL;

		SPITFSNode spScopeNode;
		if (bResClient)
		{
			SPITFSNode spResNode;
			pNode->GetParent(&spResNode);
			spResNode->GetParent(&spScopeNode);
		}
		else
		{
			pNode->GetParent(&spScopeNode);
		}

		return GETHANDLER(CDhcpScope, spScopeNode);
	}

	ITFSNode * GetServerNode(ITFSNode * pNode, BOOL bResClient = FALSE)
	{
		CDhcpScope * pScope = GetScopeObject(pNode, bResClient);

		SPITFSNode spServerNode;

		if (pScope)
		{
			pScope->GetServerNode(&spServerNode);
			spServerNode->AddRef();
		}

		return spServerNode;
	}

   	LPCTSTR GetServerName(ITFSNode * pNode, 
					      BOOL bResClient = FALSE) 
	{
        LPCTSTR pszReturn = NULL;

		CDhcpScope * pScope = GetScopeObject(pNode, bResClient);
		if (pScope)
        {
            CDhcpServer * pServer = pScope->GetServerObject();
            if (pServer)
                pszReturn = pServer->GetName();
        }

        return pszReturn;
	}

	LPCTSTR GetServerIpAddress(ITFSNode * pNode, 
							   BOOL bResClient = FALSE) 
	{
		CDhcpScope * pScope = GetScopeObject(pNode, bResClient);
		if (pScope)
			return pScope->GetServerIpAddress(); 
		else
			return NULL;
	}

	void GetServerIpAddress(ITFSNode * pNode, 
							DHCP_IP_ADDRESS * pdhcpIpAddress, 
							BOOL bResClient = FALSE)
	{
		CDhcpScope * pScope = GetScopeObject(pNode, bResClient);
		if (pScope)
			pScope->GetServerIpAddress(pdhcpIpAddress);
	}

	void GetServerVersion(ITFSNode * pNode, 
						  LARGE_INTEGER& liVersion, 
						  BOOL bResClient = FALSE) 
	{ 
		CDhcpScope * pScope = GetScopeObject(pNode, bResClient);
		if (pScope)
			pScope->GetServerVersion(liVersion); 
	} 
};

/*---------------------------------------------------------------------------
	Class:	CDhcpReservations
 ---------------------------------------------------------------------------*/
class CDhcpReservations : 
	public CMTDhcpHandler,
	public CDhcpScopeSubobject
{
public:
	CDhcpReservations(ITFSComponentData * pComponentData);
	~CDhcpReservations();

// Interface
public:
	// Node handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString() 
			{ return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    // result handler overrides
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int     GetImageIndex(BOOL bOpenImage);
    
    // CMTDhcpHandler overrides
    virtual void    OnHaveData(ITFSNode * pParent, ITFSNode * pNew);

    STDMETHOD(OnNotifyExiting)(LPARAM);

public:	
	// implementation specific functionality
	DWORD RemoveReservationFromUI(ITFSNode *pReservationsNode, DHCP_IP_ADDRESS dhcpReservationIp);

	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

    HRESULT AddReservationSorted(ITFSNode * pReservationsNode, ITFSNode * pResClientNode);

// Implementation
private:
	// message handlers
	DWORD     OnCreateNewReservation(ITFSNode*	pNode);

// Attributes
private:
    void    UpdateResultMessage(ITFSNode * pNode);
};


/*---------------------------------------------------------------------------
	Class:	CDhcpReservationClient
 ---------------------------------------------------------------------------*/
class CDhcpReservationClient : 
	public CMTDhcpHandler,
	public CDhcpScopeSubobject
{
public:
	CDhcpReservationClient(ITFSComponentData *      pComponentData,
						   LPDHCP_CLIENT_INFO       pDhcpClientInfo);
	CDhcpReservationClient(ITFSComponentData *      pComponentData,
						   LPDHCP_CLIENT_INFO_V4    pDhcpClientInfo);
	CDhcpReservationClient(ITFSComponentData *      pComponentData,
						   CDhcpClient &            dhcpClient);
	~CDhcpReservationClient();

// Interface
public:
    // Node handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages() { return hrOK; }
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString() 
			{ return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    // choose the notifications that we want to handle
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

	// Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

    virtual HRESULT EnumerateResultPane(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    HRESULT DoResPages(ITFSNode * pNode, LPPROPERTYSHEETCALLBACK lpProvider, LPDATAOBJECT pDataObject, LONG_PTR	handle, DWORD dwType);
    HRESULT DoOptCfgPages(ITFSNode * pNode, LPPROPERTYSHEETCALLBACK lpProvider, LPDATAOBJECT pDataObject, LONG_PTR	handle, DWORD dwType);

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int     GetImageIndex(BOOL bOpenImage);
	virtual void    OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    STDMETHOD(OnNotifyExiting)(LPARAM);

public:
	// command handlers
	HRESULT OnCreateNewOptions(ITFSNode * pNode);

public:
	// implementation specifc
	DHCP_IP_ADDRESS GetIpAddress() { return m_dhcpClientIpAddress; };
	HRESULT BuildDisplayName(CString * pstrDisplayName, LPCTSTR	pIpAddress, LPCTSTR	pName);
	HRESULT SetName(LPCTSTR pName);
	HRESULT SetComment(LPCTSTR pComment);
	HRESULT SetUID(const CByteArray & baClientUID);
    BYTE    SetClientType(BYTE bClientType);
    
    LPCTSTR GetName() { return (m_pstrClientName == NULL) ? NULL : (LPCTSTR) *m_pstrClientName; }
    BYTE    GetClientType() { return m_bClientType; }

	// Functions to get and set the DNS reg option
	DWORD GetDnsRegistration(ITFSNode * pNode, LPDWORD pDnsRegOption);
	DWORD SetDnsRegistration(ITFSNode * pNode, DWORD DnsRegOption);
	
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

    void SetOptionValueEnum(COptionValueEnum * pEnum)
    {
        m_ResClientOptionValues.DeleteAll();
        m_ResClientOptionValues.Copy(pEnum);
    }

    COptionValueEnum * GetOptionValueEnum()
    {
        return &m_ResClientOptionValues;
    }

// Implementation
private:
	// command handlers
	DWORD   OnDelete(ITFSNode * pNode);

    // helpers
    void    InitializeData(LPDHCP_CLIENT_INFO pDhcpClientInfo);
    void    UpdateResultMessage(ITFSNode * pNode);

// Attributes
public:
    DHCP_IP_ADDRESS		m_dhcpClientIpAddress;

private:
	CString	*			m_pstrClientName;
	CString	*			m_pstrClientComment;
	CString				m_strLeaseExpires;
	CByteArray			m_baHardwareAddress;
    BYTE                m_bClientType;
    COptionValueEnum    m_ResClientOptionValues;
    BOOL                m_fResProp;
};


/*---------------------------------------------------------------------------
	Class:	CDhcpActiveLeases
 ---------------------------------------------------------------------------*/
class CDhcpActiveLeases : 
	public CMTDhcpHandler,
	public CDhcpScopeSubobject
{
//    friend class CDhcpComponent;
//    friend class CDhcpComponentData;

public:
    CDhcpActiveLeases(ITFSComponentData * pComponentData);
	~CDhcpActiveLeases();

// Interface
public:
    // Node handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString() 
			{ return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

	// Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_CompareItems();

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int GetImageIndex(BOOL bOpenImage);

public:
	// implementation specifiec
    HRESULT	OnExportLeases(ITFSNode * pNode);
	DWORD DeleteClient(ITFSNode * pActiveLeasesNode, DHCP_IP_ADDRESS dhcpIpAddress);

	HRESULT FillFakeLeases(int nNumEntries);

	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

// Implementation
private:
	int		CompareIpAddresses(CDhcpActiveLease * pDhcpAL1, CDhcpActiveLease * pDhcpAL2);

// Attributes
private:
};


/*---------------------------------------------------------------------------
	Class:	CDhcpAddressPool
 ---------------------------------------------------------------------------*/
class CDhcpAddressPool : 
	public CMTDhcpHandler,
	public CDhcpScopeSubobject

{
public:
    CDhcpAddressPool(ITFSComponentData * pComponentData);
	~CDhcpAddressPool();

// Interface
public:
    // Node handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString() 
			{ return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

	// Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int GetImageIndex(BOOL bOpenImage);

public:
	// implementation specific
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

private:
	// command handlers
	DWORD OnCreateNewExclusion(ITFSNode * pNode);
// Attributes
private:
};

/*---------------------------------------------------------------------------
	Class:	CDhcpScopeOptions
 ---------------------------------------------------------------------------*/
class CDhcpScopeOptions : 
	public CMTDhcpHandler,
	public CDhcpScopeSubobject
{
public:
    CDhcpScopeOptions(ITFSComponentData * pComponentData);
	~CDhcpScopeOptions();

// Interface
public:
    // Node handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();

	OVERRIDE_NodeHandler_GetString() 
			{ return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

	// Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

    virtual HRESULT EnumerateResultPane(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

public:
	// CDhcpHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int     GetImageIndex(BOOL bOpenImage);
	virtual void    OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    STDMETHOD(OnNotifyExiting)(LPARAM);

public:
	// command handlers
	HRESULT OnCreateNewOptions(ITFSNode * pNode);

public:
	// implementation specific
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

// Implementation
private:
    void    UpdateResultMessage(ITFSNode * pNode);

// Attributes
private:
};

/*---------------------------------------------------------------------------
	Class:	CDhcpScopeQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpScopeQueryObj : public CDHCPQueryObj
{
public:
	CDhcpScopeQueryObj(ITFSComponentData * pTFSCompData,
					   ITFSNodeMgr *	   pNodeMgr) 
		: CDHCPQueryObj(pTFSCompData, pNodeMgr)	{ m_nQueueCountMax = 20; }
	
	STDMETHODIMP Execute();
    HRESULT      CreateSubcontainers();

	LARGE_INTEGER		m_liVersion;
	DHCP_IP_ADDRESS		m_dhcpScopeAddress;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpActiveLeasesQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpActiveLeasesQueryObj : public CDHCPQueryObj
{
public:
	CDhcpActiveLeasesQueryObj(ITFSComponentData * pTFSCompData,
							  ITFSNodeMgr *		  pNodeMgr) 
		: CDHCPQueryObj(pTFSCompData, pNodeMgr)	{ m_nQueueCountMax = 20; }
	
	STDMETHODIMP Execute();
	HRESULT EnumerateLeasesV5();
	HRESULT EnumerateLeasesV4();
	HRESULT EnumerateLeases();

    HRESULT BuildReservationList();
    BOOL    IsReservation(DWORD dwIp);

public:
    LARGE_INTEGER		m_liDhcpVersion;
	DHCP_IP_ADDRESS		m_dhcpScopeAddress;
	DHCP_RESUME_HANDLE	m_dhcpResumeHandle;
	DWORD				m_dwPreferredMax;
    CDWordArray         m_ReservationArray;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpReservationsQueryObj
 ---------------------------------------------------------------------------*/
typedef CMap< DHCP_IP_ADDRESS, DHCP_IP_ADDRESS,
              LPDHCP_SUBNET_ELEMENT_DATA_V4, LPDHCP_SUBNET_ELEMENT_DATA_V4 > CSubnetElementMap;

class CDhcpReservationsQueryObj : public CDHCPQueryObj
{
public:
	CDhcpReservationsQueryObj(ITFSComponentData * pTFSCompData,
							  ITFSNodeMgr *		  pNodeMgr) 
		: CDHCPQueryObj(pTFSCompData, pNodeMgr)	{};
	
    STDMETHODIMP Execute();
    HRESULT EnumerateReservationsV4();
    HRESULT EnumerateReservationsForLessResvsV4( );
    HRESULT EnumerateReservations();
    BOOL    AddReservedIPsToArray( );

    LARGE_INTEGER       m_liVersion;
    DHCP_IP_ADDRESS		m_dhcpScopeAddress;
    DHCP_RESUME_HANDLE	m_dhcpResumeHandle;
    DWORD               m_dwPreferredMax;
    DWORD               m_totalResvs;
    CSubnetElementMap   m_resvMap;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 m_subnetElements;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpReservationClientQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpReservationClientQueryObj : public CDHCPQueryObj
{
public:
	CDhcpReservationClientQueryObj(ITFSComponentData * pTFSCompData,
							  ITFSNodeMgr *		  pNodeMgr) 
		: CDHCPQueryObj(pTFSCompData, pNodeMgr)	{};

	STDMETHODIMP Execute();

public:
	DHCP_IP_ADDRESS		m_dhcpScopeAddress;
	DHCP_IP_ADDRESS		m_dhcpClientIpAddress;
	DHCP_RESUME_HANDLE	m_dhcpResumeHandle;
	DWORD				m_dwPreferredMax;

    LARGE_INTEGER       m_liDhcpVersion;

    CString             m_strDynBootpClassName;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpAddressPoolQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpAddressPoolQueryObj : public CDHCPQueryObj
{
public:
	CDhcpAddressPoolQueryObj(ITFSComponentData * pTFSCompData,
							  ITFSNodeMgr *		  pNodeMgr) 
            : CDHCPQueryObj(pTFSCompData, pNodeMgr),
              m_dwError(0),
              m_fSupportsDynBootp(FALSE) {};

	STDMETHODIMP Execute();
	HRESULT EnumerateIpRanges();
	HRESULT EnumerateIpRangesV5();
	HRESULT EnumerateExcludedIpRanges();

public:
	DHCP_IP_ADDRESS		m_dhcpScopeAddress;

	DHCP_RESUME_HANDLE	m_dhcpExclResumeHandle;
	DWORD				m_dwExclPreferredMax;
	
	DHCP_RESUME_HANDLE	m_dhcpIpResumeHandle;
	DWORD				m_dwIpPreferredMax;
    DWORD               m_dwError;
	BOOL				m_fSupportsDynBootp;
};

/*---------------------------------------------------------------------------
	Class:	CDhcpScopeOptionsQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpScopeOptionsQueryObj : public CDHCPQueryObj
{
public:
	CDhcpScopeOptionsQueryObj(ITFSComponentData * pTFSCompData,
							  ITFSNodeMgr *		  pNodeMgr) 
		: CDHCPQueryObj(pTFSCompData, pNodeMgr)	{};

	STDMETHODIMP Execute();

public:
	DHCP_IP_ADDRESS		m_dhcpScopeAddress;
	DHCP_RESUME_HANDLE	m_dhcpResumeHandle;
	DWORD				m_dwPreferredMax;

    LARGE_INTEGER       m_liDhcpVersion;

    CString             m_strDynBootpClassName;
};



#endif _SCOPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopstat.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ScopStat.h
		The scope statistics dialog
		
    FILE HISTORY:
        
*/


#ifndef _SCOPSTAT_H
#define _SCOPSTAT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

class CScopeStats : public StatsDialog
{
public:
	CScopeStats();
	~CScopeStats();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    void UpdateWindow(LPDHCP_MIB_INFO pMibInfo);

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }
    void SetScope(DHCP_IP_ADDRESS scopeAddress) { m_dhcpSubnetAddress = scopeAddress; }

    DECLARE_MESSAGE_MAP()

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(IDD_STATS_NARROW); }
    
protected:
    CString         m_strServerAddress;
    DHCP_IP_ADDRESS m_dhcpSubnetAddress;
    SPITFSNode      m_spNode;
};

#endif _SCOPSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopstat.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ScopStat.cpp
		The scope statistics dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ScopStat.h"
#include "scope.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum 
{
    SCOPE_STAT_TOTAL_ADDRESSES = 0,
    SCOPE_STAT_IN_USE,
    SCOPE_STAT_AVAILABLE,
    SCOPE_STAT_MAX
};

/*---------------------------------------------------------------------------
	CScopeStats implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgScopeStatsColumnInfo[] =
{
	{ IDS_STATS_TOTAL_ADDRESSES,		0,		TRUE },
	{ IDS_STATS_IN_USE,   		        0,		TRUE },
	{ IDS_STATS_AVAILABLE, 		        0,		TRUE },
};

CScopeStats::CScopeStats()
	: StatsDialog(STATSDLG_VERTICAL)
{
    SetColumnInfo(s_rgScopeStatsColumnInfo,
				  DimensionOf(s_rgScopeStatsColumnInfo));
}

CScopeStats::~CScopeStats()
{
}

BEGIN_MESSAGE_MAP(CScopeStats, StatsDialog)
	//{{AFX_MSG_MAP(CScopeStats)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
END_MESSAGE_MAP()

HRESULT CScopeStats::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;
	    LPDHCP_MIB_INFO pMibInfo = NULL;
	    
        BEGIN_WAIT_CURSOR;
        dwError = ::DhcpGetMibInfo(m_strServerAddress, &pMibInfo);
        END_WAIT_CURSOR;
    
        if (dwError != ERROR_SUCCESS)
	    {
		    ::DhcpMessageBox(dwError);
		    return hrOK;
	    }

        UpdateWindow(pMibInfo);

        if (pMibInfo)
		    ::DhcpRpcFreeMemory(pMibInfo);
    }

    return hrOK;
}

BOOL CScopeStats::OnInitDialog()
{
	CString	st, strScopeAddress;
    BOOL bRet;

    UtilCvtIpAddrToWstr(m_dhcpSubnetAddress, &strScopeAddress);
    AfxFormatString1(st, IDS_SCOPE_STATS_TITLE, strScopeAddress);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    return bRet;
}

void CScopeStats::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}


afx_msg long CScopeStats::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    SPITFSNode    spNode;
    CDhcpScope *  pScope;
    CDhcpServer * pServer;

    pScope = GETHANDLER(CDhcpScope, m_spNode);
    pServer = pScope->GetServerObject();

    LPDHCP_MIB_INFO pMibInfo = pServer->DuplicateMibInfo();

    Assert(pMibInfo);
    if (!pMibInfo)
        return 0;

    UpdateWindow(pMibInfo);

    pServer->FreeDupMibInfo(pMibInfo);

    return 0;
}

void CScopeStats::UpdateWindow(LPDHCP_MIB_INFO pMibInfo)
{
	Assert (pMibInfo);

    UINT i;
    int nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;

    if (pMibInfo)
    {
        LPSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

	    // walk the list of scopes and calculate totals
	    for (i = 0; i < pMibInfo->Scopes; i++)
	    {
		    if (pScopeMibInfo[i].Subnet == m_dhcpSubnetAddress)
		    {
			    nTotalAddresses += (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
			    nTotalInUse = pScopeMibInfo[i].NumAddressesInuse;
			    nTotalAvailable = pScopeMibInfo[i].NumAddressesFree;

			    break;
		    }
	    }
    }

    int     nPercent;
	CString	st;
    TCHAR   szFormat[] = _T("%d");
    TCHAR   szPercentFormat[] =  _T("%d (%d%%)");

    for (i = 0; i < SCOPE_STAT_MAX; i++)
	{
        if (!pMibInfo)
            st = _T("---");
        else
        {
		    switch (i)
		    {
                case SCOPE_STAT_TOTAL_ADDRESSES:
            	    st.Format(szFormat, nTotalAddresses);
                    break;

                case SCOPE_STAT_IN_USE:
	                if (nTotalAddresses > 0)
		                nPercent = (int)(((LONGLONG)nTotalInUse * (LONGLONG)100) / nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalInUse, nPercent);
                    break;

                case SCOPE_STAT_AVAILABLE:
	                if (nTotalAddresses > 0)
		                nPercent = (int)(((LONGLONG)nTotalAvailable * (LONGLONG)100) / nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalAvailable, nPercent);
                    break;
            
    		    default:
				    Panic1("Unknown scope stat id : %d", i);
				    break;
		    }
        }
        
		m_listCtrl.SetItemText(i, 1, (LPCTSTR) st);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\scopewiz.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        scopewiz.h
                DHCP scope creation dialog
                
    FILE HISTORY:
        
*/

#if !defined(AFX_DHCPSCPD_H__D3DDA5C5_88F7_11D0_97F9_00C04FC3357A__INCLUDED_)
#define AFX_DHCPSCPD_H__D3DDA5C5_88F7_11D0_97F9_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define DHCP_OPTION_ID_DOMAIN_NAME          15
#define DHCP_OPTION_ID_DNS_SERVERS          6
#define DHCP_OPTION_ID_WINS_SERVERS         44          
#define DHCP_OPTION_ID_WINS_NODE_TYPE       46
#define DHCP_OPTION_ID_ROUTERS              3

#define WINS_DEFAULT_NODE_TYPE              8

#ifndef _SCOPE_H
#include "scope.h"
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizName dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizName : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizName)

// Construction
public:
        CScopeWizName();
        ~CScopeWizName();

// Dialog Data
        //{{AFX_DATA(CScopeWizName)
        enum { IDD = IDW_SCOPE_NAME };
        CEdit   m_editScopeName;
        CEdit   m_editScopeComment;
        CString m_strName;
        CString m_strComment;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizName)
        public:
        virtual LRESULT OnWizardNext();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
public:
        void UpdateButtons();

protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizName)
        virtual BOOL OnInitDialog();
        afx_msg void OnChangeEditScopeName();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizInvalidName dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizInvalidName : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizInvalidName)

// Construction
public:
        CScopeWizInvalidName();
        ~CScopeWizInvalidName();

// Dialog Data
        //{{AFX_DATA(CScopeWizInvalidName)
        enum { IDD = IDW_SCOPE_INVALID_NAME };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizInvalidName)
        public:
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizInvalidName)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetRange dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizSetRange : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizSetRange)

// Construction
public:
        CScopeWizSetRange();
        ~CScopeWizSetRange();

// Dialog Data
        //{{AFX_DATA(CScopeWizSetRange)
        enum { IDD = IDW_SCOPE_SET_SCOPE };
        CSpinButtonCtrl m_spinMaskLength;
        CEdit   m_editMaskLength;
        //}}AFX_DATA

    CWndIpAddress m_ipaStart;       //  Start Address
    CWndIpAddress m_ipaEnd;         //  End Address
    CWndIpAddress m_ipaSubnetMask;  //  Subnet Mask

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizSetRange)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        virtual BOOL OnKillActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
public:
        void    SuggestSubnetMask();
        DWORD   DefaultNetMaskForIpAddress(DWORD dwAddress);
        DWORD   DetermineSubnetId(BOOL bStartIpAddress);
        BOOL    GetScopeRange(CDhcpIpRange * pdhcpIpRange);

        DHCP_IP_ADDRESS GetSubnetMask();

    BOOL FScopeExists(CDhcpIpRange & rangeScope, DWORD dwMask);
        
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizSetRange)
        virtual BOOL OnInitDialog();
        afx_msg void OnKillfocusPoolStart();
        afx_msg void OnKillfocusPoolStop();
        afx_msg void OnChangeEditMaskLength();
        afx_msg void OnKillfocusSubnetMask();
        afx_msg void OnChangePoolStart();
        afx_msg void OnChangePoolStop();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        BOOL m_bAutoUpdateMask;
        BOOL m_fPageActive;

        void UpdateButtons();
        void UpdateMask(BOOL bUseLength);
};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizSetExclusions dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizSetExclusions : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizSetExclusions)

// Construction
public:
        CScopeWizSetExclusions();
        ~CScopeWizSetExclusions();

// Dialog Data
        //{{AFX_DATA(CScopeWizSetExclusions)
        enum { IDD = IDW_SCOPE_SET_EXCLUSIONS };
        CListBox        m_listboxExclusions;
        CButton m_buttonExclusionDelete;
        CButton m_buttonExclusionAdd;
        //}}AFX_DATA

    CWndIpAddress m_ipaStart;       //  Start Address
    CWndIpAddress m_ipaEnd;         //  End Address

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizSetExclusions)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
public:
        CExclusionList * GetExclusionList() { return &m_listExclusions; }

protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizSetExclusions)
        virtual BOOL OnInitDialog();
        afx_msg void OnButtonExclusionAdd();
        afx_msg void OnButtonExclusionDelete();
        //}}AFX_MSG
        
    afx_msg void OnChangeExclusionStart();
    afx_msg void OnChangeExclusionEnd();
        
        DECLARE_MESSAGE_MAP()

        CExclusionList m_listExclusions;

    //  Fill the exclusions listbox from the current list
    void Fill ( int nCurSel = 0, BOOL bToggleRedraw = TRUE ) ;

    //  Return TRUE if the given range overlaps an already-defined range
    BOOL IsOverlappingRange ( CDhcpIpRange & dhcIpRange ) ;

    //  Store the excluded IP range values into a range object
    BOOL GetExclusionRange (CDhcpIpRange & dhcIpRange ) ;

    //  Format an IP range pair into the exclusion edit controls
    void FillExcl ( CDhcpIpRange * pdhcIpRange ) ;

        void UpdateButtons();
};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizLeaseTime dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizLeaseTime : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizLeaseTime)

// Construction
public:
        CScopeWizLeaseTime();
        ~CScopeWizLeaseTime();

// Dialog Data
        //{{AFX_DATA(CScopeWizLeaseTime)
        enum { IDD = IDW_SCOPE_LEASE_TIME };
        CButton m_radioLimited;
        CButton m_radioUnlimited;
        CSpinButtonCtrl m_spinMinutes;
        CSpinButtonCtrl m_spinHours;
        CSpinButtonCtrl m_spinDays;
        CEdit   m_editMinutes;
        CEdit   m_editHours;
        CEdit   m_editDays;
        //}}AFX_DATA

        static int m_nDaysDefault;
        static int m_nHoursDefault;
        static int m_nMinutesDefault;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizLeaseTime)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
public:
        DWORD GetLeaseTime();

protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizLeaseTime)
        virtual BOOL OnInitDialog();
        afx_msg void OnChangeEditLeaseHours();
        afx_msg void OnChangeEditLeaseMinutes();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void ActivateDuration(BOOL fActive);
};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizCreateSuperscope dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizCreateSuperscope : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizCreateSuperscope)

// Construction
public:
        CScopeWizCreateSuperscope();
        ~CScopeWizCreateSuperscope();

// Dialog Data
        //{{AFX_DATA(CScopeWizCreateSuperscope)
        enum { IDD = IDW_SCOPE_CREATE_SUPERSCOPE };
        CStatic m_staticInfo;
        CStatic m_staticWarning;
        CStatic m_staticIcon;
        CButton m_radioNo;
        CButton m_radioYes;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizCreateSuperscope)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizCreateSuperscope)
        virtual BOOL OnInitDialog();
        afx_msg void OnRadioSuperscopeNo();
        afx_msg void OnRadioSuperscopeYes();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void UpdateButtons();
    void UpdateWarning();
};

/////////////////////////////////////////////////////////////////////////////
//
// CScopeWizFinished dialog
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWizFinished : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizFinished)

// Construction
public:
        CScopeWizFinished();
        ~CScopeWizFinished();

// Dialog Data
        //{{AFX_DATA(CScopeWizFinished)
        enum { IDD = IDW_SCOPE_FINISHED };
        CStatic m_staticTitle;
        //}}AFX_DATA

        CFont   m_fontBig;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizFinished)
        public:
        virtual BOOL OnWizardFinish();
        virtual BOOL OnSetActive();
        virtual LRESULT OnWizardBack();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizFinished)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CScopeWizWelcome dialog

class CScopeWizWelcome : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizWelcome)

// Construction
public:
        CScopeWizWelcome();
        ~CScopeWizWelcome();

// Dialog Data
        //{{AFX_DATA(CScopeWizWelcome)
        enum { IDD = IDW_SCOPE_WELCOME };
        CStatic m_staticTitle;
        //}}AFX_DATA

        CFont   m_fontBig;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizWelcome)
        public:
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizWelcome)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CScopeWizConfigOptions dialog

class CScopeWizConfigOptions : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizConfigOptions)

// Construction
public:
        CScopeWizConfigOptions();
        ~CScopeWizConfigOptions();

// Dialog Data
        //{{AFX_DATA(CScopeWizConfigOptions)
        enum { IDD = IDW_SCOPE_CONFIGURE_OPTIONS };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizConfigOptions)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizConfigOptions)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CScopeWizRouter dialog

class CScopeWizRouter : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizRouter)

// Construction
public:
        CScopeWizRouter();
        ~CScopeWizRouter();

// Dialog Data
        //{{AFX_DATA(CScopeWizRouter)
        enum { IDD = IDW_SCOPE_CONFIGURE_ROUTER };
        CListBox        m_listboxRouters;
        CButton m_buttonDelete;
        CButton m_buttonAdd;
    CButton     m_buttonIpAddrUp;
        CButton m_buttonIpAddrDown;
        //}}AFX_DATA


        void MoveValue(BOOL bUp);

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizRouter)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

    CWndIpAddress m_ipaRouter;

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizRouter)
        virtual BOOL OnInitDialog();
        afx_msg void OnButtonDefaultGwAdd();
        afx_msg void OnButtonDefaultGwDelete();
        afx_msg void OnSelchangeListDefaultGwList();
        afx_msg void OnChangeRouter();
        afx_msg void OnDestroy();
        //}}AFX_MSG

        afx_msg void OnButtonIpAddrDown();
        afx_msg void OnButtonIpAddrUp();
        
        DECLARE_MESSAGE_MAP()

    void UpdateButtons();
};

/////////////////////////////////////////////////////////////////////////////
// CScopeWizDNS dialog

class CScopeWizDNS : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizDNS)

// Construction
public:
        CScopeWizDNS();
        ~CScopeWizDNS();

// Dialog Data
        //{{AFX_DATA(CScopeWizDNS)
        enum { IDD = IDW_SCOPE_CONFIGURE_DNS };
        CEdit   m_editServerName;
        CButton m_buttonResolve;
        CButton m_buttonDelete;
        CButton m_buttonAdd;
        CEdit   m_editDomainName;
        CListBox        m_listboxDNSServers;
    CButton     m_buttonIpAddrUp;
        CButton m_buttonIpAddrDown;
        //}}AFX_DATA

        void MoveValue(BOOL bUp);

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizDNS)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

    CWndIpAddress m_ipaDNS;

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizDNS)
        virtual BOOL OnInitDialog();
        afx_msg void OnButtonDnsAdd();
        afx_msg void OnButtonDnsDelete();
        afx_msg void OnSelchangeListDnsList();
        afx_msg void OnChangeDnsServer();
        afx_msg void OnDestroy();
        afx_msg void OnChangeEditServerName();
        afx_msg void OnButtonResolve();
        //}}AFX_MSG

        afx_msg void OnButtonIpAddrDown();
        afx_msg void OnButtonIpAddrUp();
        
        DECLARE_MESSAGE_MAP()

    void UpdateButtons();
};
/////////////////////////////////////////////////////////////////////////////
// CScopeWizWINS dialog

class CScopeWizWINS : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizWINS)

// Construction
public:
        CScopeWizWINS();
        ~CScopeWizWINS();

// Dialog Data
        //{{AFX_DATA(CScopeWizWINS)
        enum { IDD = IDW_SCOPE_CONFIGURE_WINS };
        CButton m_buttonResolve;
        CEdit   m_editServerName;
        CListBox        m_listboxWINSServers;
        CButton m_buttonDelete;
        CButton m_buttonAdd;
    CButton     m_buttonIpAddrUp;
        CButton m_buttonIpAddrDown;
        //}}AFX_DATA

        void MoveValue(BOOL bUp);

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizWINS)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

    CWndIpAddress m_ipaWINS;

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizWINS)
        virtual BOOL OnInitDialog();
        afx_msg void OnButtonWinsAdd();
        afx_msg void OnButtonWinsDelete();
        afx_msg void OnSelchangeListWinsList();
        afx_msg void OnChangeWinsServer();
        afx_msg void OnDestroy();
        afx_msg void OnButtonResolve();
        afx_msg void OnChangeEditServerName();
        //}}AFX_MSG

        afx_msg void OnButtonIpAddrDown();
        afx_msg void OnButtonIpAddrUp();
        
        DECLARE_MESSAGE_MAP()

    void UpdateButtons();
};
/////////////////////////////////////////////////////////////////////////////
// CScopeWizActivate dialog

class CScopeWizActivate : public CPropertyPageBase
{
        DECLARE_DYNCREATE(CScopeWizActivate)

// Construction
public:
        CScopeWizActivate();
        ~CScopeWizActivate();

// Dialog Data
        //{{AFX_DATA(CScopeWizActivate)
        enum { IDD = IDW_SCOPE_CONFIGURE_ACTIVATE };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CScopeWizActivate)
        public:
        virtual LRESULT OnWizardNext();
        virtual LRESULT OnWizardBack();
        virtual BOOL OnSetActive();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CScopeWizActivate)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

///////////////////////////////////////////////////////////////////////////////
//
// CScopeWiz
//      page holder to contain Superscope wizard pages
//
/////////////////////////////////////////////////////////////////////////////
class CScopeWiz : public CPropertyPageHolderBase
{
    friend class CScopeWizWelcome;
    friend class CScopeWizName;
    friend class CScopeWizInvalidName;
    friend class CScopeWizSetRange;
    friend class CScopeWizSetExclusions;
    friend class CScopeWizLeaseTime;
    friend class CScopeWizCreateSuperscope;
    friend class CScopeWizConfigOptions;
    friend class CScopeWizRouter;
    friend class CScopeWizDNS;
    friend class CScopeWizWINS;
    friend class CScopeWizActivate;
    friend class CScopeWizFinished;

public:
    CScopeWiz(ITFSNode *          pNode,
              IComponentData *    pComponentData,
              ITFSComponentData * pTFSCompData,
              LPCTSTR             pSuperscopeName,
              LPCTSTR             pszSheetName);
    virtual ~CScopeWiz();
    
    virtual DWORD OnFinish();
    BOOL GetScopeRange(CDhcpIpRange * pdhcpIpRange);
    
    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

    void SetCreateSuperscope(BOOL fCreateSuperscope) { m_fCreateSuperscope = fCreateSuperscope; }
    BOOL GetCreateSuperscope() { return m_fCreateSuperscope; }
    
public:
    CScopeWizWelcome            m_pageWelcome;
    CScopeWizName               m_pageName;
    CScopeWizInvalidName        m_pageInvalidName;
    CScopeWizSetRange           m_pageSetRange;
    CScopeWizSetExclusions      m_pageSetExclusions;
    CScopeWizLeaseTime          m_pageLeaseTime;
    CScopeWizCreateSuperscope   m_pageCreateSuperscope;
    CScopeWizConfigOptions      m_pageConfigOptions;
    CScopeWizRouter             m_pageRouter;
    CScopeWizDNS                m_pageDNS;
    CScopeWizWINS               m_pageWINS;
    CScopeWizActivate           m_pageActivate;
    CScopeWizFinished           m_pageFinished;

public:
    CDhcpDefaultOptionsOnServer * m_pDefaultOptions;

protected:
    DWORD CreateScope();
    DWORD CreateSuperscope();
    DWORD SetScopeOptions(CDhcpScope * pScope);

    SPITFSComponentData     m_spTFSCompData;
    CString                 m_strSuperscopeName;
    BOOL                    m_fCreateSuperscope;
    BOOL                    m_fOptionsConfigured;
    BOOL                    m_fActivateScope;
    BOOL                    m_fWizardCancelled;
    CDhcpOption *           m_poptDomainName;
    CDhcpOption *           m_poptDNSServers;
    CDhcpOption *           m_poptRouters;
    CDhcpOption *           m_poptWINSNodeType;
    CDhcpOption *           m_poptWINSServers;

};

#endif // !defined(AFX_DHCPSCPD_H__D3DDA5C5_88F7_11D0_97F9_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servbind.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       servbind.cpp
//
//--------------------------------------------------------------------------

// servbind.cpp : implementation file
//

#include "stdafx.h"
#include "servbind.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define BINDINGS_COLUMNS 2

/////////////////////////////////////////////////////////////////////////////
// CServerBindings dialog


CServerBindings::CServerBindings(CWnd* pParent /*=NULL*/)
    : CBaseDialog(CServerBindings::IDD, pParent)
{
    //{{AFX_DATA_INIT(CServerBindings)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CServerBindings::CServerBindings(CDhcpServer *pServer, CWnd *pParent)
    : CBaseDialog(CServerBindings::IDD, pParent)
{
    m_Server = pServer;
    m_BindingsInfo = NULL;
}


CServerBindings::~CServerBindings()
{
    ::DhcpRpcFreeMemory(m_BindingsInfo);
    m_BindingsInfo = NULL;

    //
    // if needed destory the list ctrl also
    //
    if( m_listctrlBindingsList.GetSafeHwnd() != NULL ) {
        m_listctrlBindingsList.SetImageList(NULL, LVSIL_STATE);
        m_listctrlBindingsList.DeleteAllItems();
    }
    m_listctrlBindingsList.DestroyWindow();
}


void CServerBindings::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerBindings)
    DDX_Control(pDX, IDC_LIST_BINDINGS, m_listctrlBindingsList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerBindings, CBaseDialog)
    //{{AFX_MSG_MAP(CServerBindings)
    ON_BN_CLICKED(IDCANCEL, OnBindingsCancel)
    ON_BN_CLICKED(IDOK, OnBindingsOK)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerBindings message handlers

BOOL CServerBindings::OnInitDialog() 
{
    ULONG dwError;
	
    CBaseDialog::OnInitDialog();
	
    // initialize the list ctrl
    InitListCtrl();

    BEGIN_WAIT_CURSOR;
    // get the state from the server..

    dwError = m_Server->GetBindings(m_BindingsInfo);

    END_WAIT_CURSOR;

    if( 0 != dwError) {
        ::DhcpMessageBox(dwError);
        m_BindingsInfo = NULL;

        // can't do anything if we don't have what we want.
        // so cancel the window itself.
        OnCancel();

    } else {

        int col_width = 0, col2_width = 0, base_width;

        // basic fudge factor
        base_width = 15 + m_listctrlBindingsList.GetStringWidth(TEXT("++"));

        // now set each item..
        for( ULONG i = 0; i < m_BindingsInfo->NumElements ; i ++ ) {
            LPWSTR IpString = NULL;

            if( 0 != m_BindingsInfo->Elements[i].AdapterPrimaryAddress ) {
                IpString = ::UtilDupIpAddrToWstr(
                    htonl(m_BindingsInfo->Elements[i].AdapterPrimaryAddress)
                    );
            }
            int width = m_listctrlBindingsList.GetStringWidth(IpString);
            if( col_width < width) col_width = width;

            if( m_BindingsInfo->Elements[i].IfDescription != NULL ) {
                width = m_listctrlBindingsList.GetStringWidth(
                    m_BindingsInfo->Elements[i].IfDescription
                    );
                if( col2_width < width) col2_width = width;
            }

            int nIndex = m_listctrlBindingsList.AddItem(
                IpString, m_BindingsInfo->Elements[i].IfDescription,
                LISTVIEWEX_NOT_CHECKED
                );

            if( m_BindingsInfo->Elements[i].fBoundToDHCPServer ) {
                m_listctrlBindingsList.CheckItem(nIndex);
            }
            if( IpString ) delete IpString;
        }
        m_listctrlBindingsList.SetColumnWidth(0, col_width + base_width);
        m_listctrlBindingsList.SetColumnWidth(1, col2_width + base_width/2);
		
        // if there are any elements, set focus on this window.
        if( m_BindingsInfo->NumElements ) {
            m_listctrlBindingsList.SelectItem(0);
            m_listctrlBindingsList.SetFocus();
            //
            // return false to indicate that we have set focus.
            //
            return FALSE;
        }
    }
	
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CServerBindings::InitListCtrl()
{
    // set image lists
    m_StateImageList.Create(IDB_LIST_STATE, 16, 1, RGB(255, 0, 0));

    m_listctrlBindingsList.SetImageList(NULL, LVSIL_NORMAL);
    m_listctrlBindingsList.SetImageList(NULL, LVSIL_SMALL);
    m_listctrlBindingsList.SetImageList(&m_StateImageList, LVSIL_STATE);

    // insert a column so we can see the items
    LV_COLUMN lvc;
    CString strColumnHeader;

    for (int i = 0; i < BINDINGS_COLUMNS; i++)
    {
        lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT;;
        lvc.iSubItem = i;
        lvc.fmt = LVCFMT_LEFT;
        lvc.pszText = NULL;

        m_listctrlBindingsList.InsertColumn(i, &lvc);
    }

    m_listctrlBindingsList.SetFullRowSel(TRUE);
}

void CServerBindings::OnBindingsCancel() 
{
    CBaseDialog::OnCancel();	
}


void CServerBindings::OnBindingsOK() 
{
    DWORD dwError;

    if( NULL != m_BindingsInfo ) {
        //
        // Save that onto the dhcp server
        //
        UpdateBindingInfo();
        dwError = m_Server->SetBindings(m_BindingsInfo);
        if( NO_ERROR != dwError ) {
            ::DhcpMessageBox(dwError);
        } else {
            CBaseDialog::OnOK();
        }
    } else {
        CBaseDialog::OnOK();
    }
}


void CServerBindings::UpdateBindingInfo()
{
    for( int i = 0; i < m_listctrlBindingsList.GetItemCount() ; i ++ ) {
        BOOL fBound;

        if( m_listctrlBindingsList.GetCheck(i) ) {
            m_BindingsInfo->Elements[i].fBoundToDHCPServer = TRUE;
        } else {
            m_BindingsInfo->Elements[i].fBoundToDHCPServer = FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servbind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       servbind.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SERVBIND_H__9B74926E_B074_11D2_9326_00C04F79C3A8__INCLUDED_)
#define AFX_SERVBIND_H__9B74926E_B074_11D2_9326_00C04F79C3A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// servbind.h : header file

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CServerBindings dialog

class CServerBindings : public CBaseDialog
{
// Construction
public:
	void UpdateBindingInfo();
	~CServerBindings();
	CServerBindings(CDhcpServer *pServer, CWnd* pParent = NULL);
	CImageList m_StateImageList;
	void InitListCtrl();
	CServerBindings(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServerBindings)
	enum { IDD = IDD_SERVER_BINDINGS };
	CMyListCtrl	m_listctrlBindingsList;
	//}}AFX_DATA

// Context help support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CServerBindings::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerBindings)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
	CDhcpServer *m_Server;
	LPDHCP_BIND_ELEMENT_ARRAY m_BindingsInfo;

protected:

	// Generated message map functions
	//{{AFX_MSG(CServerBindings)
	virtual BOOL OnInitDialog();
	afx_msg void OnBindingsCancel();
	afx_msg void OnBindingsOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVBIND_H__9B74926E_B074_11D2_9326_00C04F79C3A8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servbrow.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ServBrow.cpp
		The server browser dialog
		
    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "ServBrow.h"
#include <windns.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CAuthServerList::CAuthServerList()
    : m_pos(NULL), m_bInitialized(FALSE)
{
}

CAuthServerList::~CAuthServerList()
{
    Destroy();
}

HRESULT 
CAuthServerList::Destroy()
{
    CSingleLock sl( &m_cs );
    sl.Lock();
    ::DhcpDsCleanup();
    m_bInitialized = FALSE;
    return S_OK;
}

HRESULT
CAuthServerList::Init()
{
    DWORD dwErr = ERROR_SUCCESS;

    CSingleLock sl(&m_cs);  // only one thread at a time in here

    sl.Lock();
    dwErr = ::DhcpDsInit();
    if ( dwErr == ERROR_SUCCESS ) {
	m_bInitialized = TRUE;
	m_bQueried = FALSE;
    }
    return HRESULT_FROM_WIN32(dwErr);
}

HRESULT 
CAuthServerList::EnumServers( BOOL force )
{
    LPDHCP_SERVER_INFO_ARRAY pServerInfoArray = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    
    CSingleLock sl( &m_cs );
    sl.Lock();

    // DS must be initialized before EnumServers() is called.
    if ( !m_bInitialized ) {
        dwErr = ERROR_FILE_NOT_FOUND;
        return HRESULT_FROM_WIN32( dwErr );
    }

    // Query only if not previously queried or forced.
    if (( !m_bQueried ) || ( force )) {
        m_bQueried = FALSE;
        dwErr = ::DhcpEnumServers(0, NULL, &pServerInfoArray, NULL, NULL);
    }
    if (( dwErr != ERROR_SUCCESS ) ||
        ( m_bQueried )) {
        return HRESULT_FROM_WIN32(dwErr);
    }

    Assert( NULL != pServerInfoArray );

    // Stuff the results in to the authorized servers list
    Clear();
    if ( NULL != pServerInfoArray ) {
        for (UINT i = 0; i < pServerInfoArray->NumElements; i++) {
            CServerInfo ServerInfo(pServerInfoArray->Servers[i].ServerAddress,
                                   pServerInfoArray->Servers[i].ServerName);

        AddTail(ServerInfo);
        } // for

        // Cleanup allocated memory
        DhcpRpcFreeMemory( pServerInfoArray );
    } // if

    m_bQueried = TRUE;
    return S_OK;

} // CAuthServerList::EnumServers()

BOOL    
CAuthServerList::IsAuthorized
(
    DWORD dwIpAddress
)
{
    BOOL bValid = FALSE;
    POSITION pos = GetHeadPosition();

    while (pos)
    {
        if (GetNext(pos).m_dwIp == dwIpAddress)
        {
            bValid = TRUE;
            break;
        }
    }

    return bValid;
}

HRESULT 
CAuthServerList::AddServer
(
    DWORD dwIpAddress, 
    LPCTSTR pFQDN
)
{
    DWORD dwErr = ERROR_SUCCESS;
    DHCP_SERVER_INFO dhcpServerInfo = {0};
    
    dhcpServerInfo.ServerAddress = dwIpAddress;
    dhcpServerInfo.ServerName = (LPTSTR) pFQDN;

    dwErr = ::DhcpAddServer(0, NULL, &dhcpServerInfo, NULL, NULL);
    if (dwErr != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(dwErr);

    CServerInfo ServerInfo(dwIpAddress, pFQDN);
    CSingleLock sl( &m_cs );
    sl.Lock();
    AddTail(ServerInfo);
    return S_OK;
}

HRESULT 
CAuthServerList::RemoveServer
(
    DWORD    dwIpAddress,
    LPCTSTR  pFQDN
)
{
    DWORD dwErr = ERROR_SUCCESS;
    DHCP_SERVER_INFO dhcpServerInfo = {0};
    
    POSITION posCurrent;
    POSITION pos = GetHeadPosition();

    while (pos)
    {
        posCurrent = pos;
        
        CServerInfo & ServerInfo = GetNext(pos);
        if (( ServerInfo.m_dwIp == dwIpAddress) &&
	    ( ServerInfo.m_strName == pFQDN ))
        {
            dhcpServerInfo.ServerAddress = ServerInfo.m_dwIp;
            dhcpServerInfo.ServerName = (LPTSTR) ((LPCTSTR)ServerInfo.m_strName);

            dwErr = ::DhcpDeleteServer(0, NULL, &dhcpServerInfo, NULL, NULL);
            if (dwErr == ERROR_SUCCESS)
            {
                // success, remove from list
		CSingleLock sl( &m_cs );
		sl.Lock();
                RemoveAt(posCurrent);
            }

            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    return E_INVALIDARG;
}

void
CAuthServerList::Clear()
{
    CSingleLock sl( &m_cs );
    sl.Lock();
    RemoveAll();
}

/*---------------------------------------------------------------------------
    CAuthServerWorker
 ---------------------------------------------------------------------------*/
CAuthServerWorker::CAuthServerWorker(CAuthServerList ** ppList)
{
    m_ppList = ppList;
}

CAuthServerWorker::~CAuthServerWorker()
{
}

void
CAuthServerWorker::OnDoAction()
{
    HRESULT hr = hrOK;

    m_pAuthList = &g_AuthServerList;
    
    hr = m_pAuthList->Init();
    Trace1("CAuthServerWorker::OnDoAction - Init returned %d\n", hr);

    hr = m_pAuthList->EnumServers();
    Trace1("CAuthServerWorker::OnDoAction - EnumServers returned %d\n", hr);

    if (!IsAbandoned())
    {
        if (m_ppList)
            *m_ppList = m_pAuthList;
    }
}

/*---------------------------------------------------------------------------
    CStandaloneAuthServerWorker
 ---------------------------------------------------------------------------*/
CStandaloneAuthServerWorker::CStandaloneAuthServerWorker()
    : CAuthServerWorker(NULL)
{
    m_bAutoDelete = TRUE;
}

CStandaloneAuthServerWorker::~CStandaloneAuthServerWorker()
{
}

int
CStandaloneAuthServerWorker::Run()
{
    OnDoAction();

    return 0;
}

int CALLBACK ServerBrowseCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((CServerBrowse *) lParamSort)->HandleSort(lParam1, lParam2);
}


/////////////////////////////////////////////////////////////////////////////
// CServerBrowse dialog


CServerBrowse::CServerBrowse(BOOL bMultiselect, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CServerBrowse::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServerBrowse)
	//}}AFX_DATA_INIT

    m_bMultiselect = bMultiselect;

    ResetSort();
}


void CServerBrowse::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerBrowse)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_BUTTON_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_LIST_VALID_SERVERS, m_listctrlServers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerBrowse, CBaseDialog)
	//{{AFX_MSG_MAP(CServerBrowse)
	ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_VALID_SERVERS, OnItemchangedListValidServers)
	ON_BN_CLICKED(IDC_BUTTON_AUTHORIZE, OnButtonAuthorize)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_VALID_SERVERS, OnColumnclickListValidServers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerBrowse message handlers

BOOL CServerBrowse::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    LV_COLUMN lvColumn;
    CString   strText;

    strText.LoadString(IDS_NAME);

    ListView_SetExtendedListViewStyle(m_listctrlServers.GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 175;
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    
    m_listctrlServers.InsertColumn(0, &lvColumn);

    strText.LoadString(IDS_IP_ADDRESS);
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    lvColumn.cx = 100;
    m_listctrlServers.InsertColumn(1, &lvColumn);
    
    FillListCtrl();

    UpdateButtons();

    if (m_bMultiselect)
    {
        DWORD dwStyle = ::GetWindowLong(m_listctrlServers.GetSafeHwnd(), GWL_STYLE);
        dwStyle &= ~LVS_SINGLESEL;
        ::SetWindowLong(m_listctrlServers.GetSafeHwnd(), GWL_EXSTYLE, dwStyle);	
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CServerBrowse::OnOK() 
{
    int nSelectedItem = m_listctrlServers.GetNextItem(-1, LVNI_SELECTED);
    while (nSelectedItem != -1)
    {
        m_astrName.Add(m_listctrlServers.GetItemText(nSelectedItem, 0));
        m_astrIp.Add(m_listctrlServers.GetItemText(nSelectedItem, 1));

        nSelectedItem = m_listctrlServers.GetNextItem(nSelectedItem, LVNI_SELECTED);
    }

	CBaseDialog::OnOK();
}

void CServerBrowse::RefreshData()
{
    if (m_pServerList)
    {
        m_pServerList->Clear();
        m_pServerList->EnumServers( TRUE );

        ResetSort();
        FillListCtrl();
    }
}

void CServerBrowse::UpdateButtons()
{
    // Find the selected item
    int nSelectedItem = m_listctrlServers.GetNextItem(-1, LVNI_SELECTED);
    BOOL bEnable = (nSelectedItem != -1) ? TRUE : FALSE;

    m_buttonOk.EnableWindow(bEnable);
    m_buttonRemove.EnableWindow(bEnable);
}

void CServerBrowse::FillListCtrl()
{
    CServerInfo ServerInfo;
    CString     strIp;
    int         nItem = 0;

    m_listctrlServers.DeleteAllItems();

    POSITION pos = m_pServerList->GetHeadPosition();

    // walk the list and add items to the list control
    while (pos != NULL)
    {
        POSITION lastpos = pos;

        // get the next item
        ServerInfo = m_pServerList->GetNext(pos);

        UtilCvtIpAddrToWstr(ServerInfo.m_dwIp, &strIp);

        nItem = m_listctrlServers.InsertItem(nItem, ServerInfo.m_strName);
        m_listctrlServers.SetItemText(nItem, 1, strIp);

        // save off the position value for sorting later
        m_listctrlServers.SetItemData(nItem, (DWORD_PTR) lastpos);
    }

    Sort(COLUMN_NAME);
}

void CServerBrowse::OnButtonAuthorize() 
{
    // put up the dialog to get the name and IP address of the server
    DWORD         err;
    CGetServer    dlgGetServer;

    if (dlgGetServer.DoModal() == IDOK)
    {
        BEGIN_WAIT_CURSOR;

        err = m_pServerList->AddServer(dlgGetServer.m_dwIpAddress, dlgGetServer.m_strName);
        if (err != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(WIN32_FROM_HRESULT(err));
        }
        else
        {
            RefreshData();
            UpdateButtons();
        }

        END_WAIT_CURSOR;
    }
}

void CServerBrowse::OnButtonRefresh() 
{
    BEGIN_WAIT_CURSOR;

    RefreshData();

    UpdateButtons();

    END_WAIT_CURSOR;
}

void CServerBrowse::OnButtonRemove() 
{
    HRESULT hr; 

    int nSelectedItem = m_listctrlServers.GetNextItem(-1, LVNI_SELECTED);
    if (nSelectedItem != -1)
    {
        CString strIp = m_listctrlServers.GetItemText(nSelectedItem, 1);
	CString strFQDN = m_listctrlServers.GetItemText(nSelectedItem, 0);
        DWORD dwIp = UtilCvtWstrToIpAddr(strIp);

        BEGIN_WAIT_CURSOR;
        
        hr = m_pServerList->RemoveServer(dwIp, strFQDN);
        
        END_WAIT_CURSOR;

        if (FAILED(hr))
        {   
            ::DhcpMessageBox(WIN32_FROM_HRESULT(hr));
        }
        else
        {
            BEGIN_WAIT_CURSOR;
            
            RefreshData();
            UpdateButtons();

            END_WAIT_CURSOR;
        }
    }
    // set the focus back to the remove button
    SetFocus();
}

void CServerBrowse::OnItemchangedListValidServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    UpdateButtons();

	*pResult = 0;
}

void CServerBrowse::OnColumnclickListValidServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);

	*pResult = 0;
}

void CServerBrowse::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listctrlServers.SortItems(ServerBrowseCompareFunc, (LPARAM) this);
}

int CServerBrowse::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;
    CServerInfo ServerInfo1, ServerInfo2;

    ServerInfo1 = m_pServerList->GetAt((POSITION) lParam1);
    ServerInfo2 = m_pServerList->GetAt((POSITION) lParam2);

    switch (m_nSortColumn)
    {
        case COLUMN_NAME:
            {
                nCompare = ServerInfo1.m_strName.CompareNoCase(ServerInfo2.m_strName);
            }

            // if the names are the same, fall back to the IP address
            if (nCompare != 0)
            {
                break;
            }


        case COLUMN_IP:
            {
                if (ServerInfo1.m_dwIp > ServerInfo2.m_dwIp)
                    nCompare = 1;
                else
                if (ServerInfo1.m_dwIp < ServerInfo2.m_dwIp)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

void CServerBrowse::ResetSort()
{
    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }
}

/////////////////////////////////////////////////////////////////////////////
// CGetServer dialog


CGetServer::CGetServer(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CGetServer::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetServer)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_dwIpAddress = 0;
}


void CGetServer::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetServer)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetServer, CBaseDialog)
	//{{AFX_MSG_MAP(CGetServer)
	ON_EN_CHANGE(IDC_EDIT_SERVER_NAME_IP, OnChangeEditServerNameIp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetServer message handlers

BOOL CGetServer::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    GetDlgItem(IDOK)->EnableWindow(FALSE);
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGetServer::OnOK() 
{
    CString                 strNameOrIp;
    DWORD                   err = 0;
    DHC_HOST_INFO_STRUCT    dhcHostInfo;

    BEGIN_WAIT_CURSOR;

    GetDlgItem(IDC_EDIT_SERVER_NAME_IP)->GetWindowText(strNameOrIp);

    switch (UtilCategorizeName(strNameOrIp))
    {
        case HNM_TYPE_IP:
            m_dwIpAddress = ::UtilCvtWstrToIpAddr( strNameOrIp ) ;
            break ;

        case HNM_TYPE_NB:
        case HNM_TYPE_DNS:
            err = ::UtilGetHostAddress( strNameOrIp, &m_dwIpAddress ) ;
	    m_strName = strNameOrIp;    // default
			break ;

        default:
            err = IDS_ERR_BAD_HOST_NAME ;
            break;
    }

    // now that we have the address, try to get the full host info
    // an empty host name is valid here, so if we can't find a host
    // name then we'll just leave it blank.
    if (err == ERROR_SUCCESS)
    {
        if ( INADDR_LOOPBACK == m_dwIpAddress ) {
            ::UtilGetLocalHostAddress( &m_dwIpAddress );
        }
        err = UtilGetHostInfo(m_dwIpAddress, &dhcHostInfo);
        if (err == ERROR_SUCCESS)
        {
            m_strName = dhcHostInfo._chHostName;
        }
    }

    END_WAIT_CURSOR;

    // confirm choice with user, give them a chance to modify our findings
    CConfirmAuthorization dlgConfirm;

    dlgConfirm.m_strName = m_strName;
    dlgConfirm.m_dwAuthAddress = m_dwIpAddress;
    
    if (dlgConfirm.DoModal() != IDOK)
    {
        return;
    }

    // use whatever they selected
    m_strName = dlgConfirm.m_strName;
    m_dwIpAddress = dlgConfirm.m_dwAuthAddress;

	CBaseDialog::OnOK();
}

void CGetServer::OnChangeEditServerNameIp() 
{
    CString strText;
    BOOL    fEnable = FALSE;

    GetDlgItem(IDC_EDIT_SERVER_NAME_IP)->GetWindowText(strText);

    // Trim any white spaces
    strText.TrimLeft();
    strText.TrimRight();

    if (( !strText.IsEmpty()) &&
	( -1 == strText.FindOneOf( _T(" \t")))) {
        fEnable = TRUE;
    }

    GetDlgItem(IDOK)->EnableWindow(fEnable);
}

/////////////////////////////////////////////////////////////////////////////
// CConfirmAuthorization dialog


CConfirmAuthorization::CConfirmAuthorization(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CConfirmAuthorization::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfirmAuthorization)
	m_strName = _T("");
	//}}AFX_DATA_INIT

    m_dwAuthAddress = 0;
}


void CConfirmAuthorization::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfirmAuthorization)
	DDX_Text(pDX, IDC_EDIT_AUTH_NAME, m_strName);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_AUTH, m_ipaAuth);
}


BEGIN_MESSAGE_MAP(CConfirmAuthorization, CBaseDialog)
	//{{AFX_MSG_MAP(CConfirmAuthorization)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmAuthorization message handlers

BOOL CConfirmAuthorization::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    if (m_dwAuthAddress != 0)
    {
	    m_ipaAuth.SetAddress(m_dwAuthAddress);
    }
    else
    {
	    m_ipaAuth.ClearAddress();
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfirmAuthorization::OnOK() 
{
    DNS_STATUS dnsResult;

    m_ipaAuth.GetAddress(&m_dwAuthAddress);
    GetDlgItem( IDC_EDIT_AUTH_NAME )->GetWindowText( m_strName );    

    UpdateData( FALSE );

    // Trim leading and trailing white spaces
    m_strName.TrimLeft();
    m_strName.TrimRight();

    dnsResult = DnsValidateName( m_strName, DnsNameDomain );
    if (( m_strName.IsEmpty()) ||
	( ERROR_INVALID_NAME == dnsResult ) ||
	( DNS_ERROR_INVALID_NAME_CHAR == dnsResult )) {
	DhcpMessageBox( IDS_ERR_BAD_HOST_NAME );
	return;
    }
    if (m_dwAuthAddress == 0)
    {
        DhcpMessageBox(IDS_ERR_DLL_INVALID_ADDRESS);
        m_ipaAuth.SetFocus();
        return;
    }

    UpdateData( FALSE );
    CBaseDialog::OnOK();
} // CConfirmAuthorization::OnOK()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servbrow.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ServBrow.h
		The server browser dialog
		
    FILE HISTORY:
        
*/

#if !defined _SERVBROW_H
#define _SERVBROW_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _BUSYDLG_H
#include "busydlg.h"
#endif

// defines used in the display of owner info
enum _AUTH_COLUMNS
{
    COLUMN_NAME,
    COLUMN_IP,
    COLUMN_MAX
};

class CServerInfo 
{
public:
    CServerInfo() 
        : m_dwIp(0) {};

    CServerInfo(DWORD dwIp, LPCTSTR pFQDN)
        : m_dwIp(dwIp), m_strName(pFQDN)    {};

    CServerInfo(CServerInfo & ServerInfo)
    {
        *this = ServerInfo;
    }

    CServerInfo & operator = (const CServerInfo & ServerInfo)
    {
        if (this != &ServerInfo)
        {
            m_dwIp = ServerInfo.m_dwIp;
            m_strName = ServerInfo.m_strName;
        }
        
        return *this;
    }

public:
    DWORD       m_dwIp;
    CString     m_strName;
};

typedef CList<CServerInfo, CServerInfo&> CServerInfoListBase;

class CAuthServerList : public CServerInfoListBase
{
public:
    CAuthServerList();
    ~CAuthServerList();

public:
    HRESULT Init();
    HRESULT Destroy();
    BOOL    IsInitialized() { return m_bInitialized; }
    HRESULT EnumServers( BOOL force = FALSE );
    BOOL    IsAuthorized(DWORD dwIpAddress);
    HRESULT AddServer(DWORD dwIpAddress, LPCTSTR pFQDN);
    HRESULT RemoveServer(DWORD dwIpAddress, LPCTSTR pFQDN);

    void    Clear();
    void    Reset();
    HRESULT Next(CServerInfo &ServerInfo);

private:
    POSITION              m_pos;
    BOOL                  m_bInitialized;
    CCriticalSection      m_cs;
    BOOL                  m_bQueried;
};

class CAuthServerWorker : public CDlgWorkerThread
{
public:
    CAuthServerWorker(CAuthServerList ** ppList);
    ~CAuthServerWorker();
    
    void OnDoAction();

private:
    CAuthServerList * m_pAuthList;
    CAuthServerList ** m_ppList;
};

class CStandaloneAuthServerWorker : public CAuthServerWorker
{
public:
    CStandaloneAuthServerWorker();
    ~CStandaloneAuthServerWorker();

    virtual int Run();
};

/////////////////////////////////////////////////////////////////////////////
// CServerBrowse dialog

class CServerBrowse : public CBaseDialog
{
// Construction
public:
	CServerBrowse(BOOL bMultiselect = FALSE, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServerBrowse)
	enum { IDD = IDD_BROWSE_SERVERS };
	CButton	m_buttonOk;
	CButton	m_buttonRemove;
	CListCtrl	m_listctrlServers;
	//}}AFX_DATA

public:
    void SetServerList(CAuthServerList * pServerList) { m_pServerList = pServerList; }
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CServerBrowse::IDD); }

    int HandleSort(LPARAM lParam1, LPARAM lParam2);
    void ResetSort();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerBrowse)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void RefreshData();
    void UpdateButtons();
    void FillListCtrl();
    void Sort(int nCol);

	// Generated message map functions
	//{{AFX_MSG(CServerBrowse)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonRefresh();
	afx_msg void OnButtonRemove();
	afx_msg void OnItemchangedListValidServers(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonAuthorize();
	afx_msg void OnColumnclickListValidServers(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    // these contain the name and IP of the selected item on exit
    CStringArray    m_astrName;
    CStringArray    m_astrIp;

private:
    CAuthServerList *	m_pServerList;
	BOOL				m_bMultiselect;
    int                 m_nSortColumn;
    BOOL                m_aSortOrder[COLUMN_MAX];
};

/////////////////////////////////////////////////////////////////////////////
// CGetServer dialog

class CGetServer : public CBaseDialog
{
// Construction
public:
	CGetServer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetServer)
	enum { IDD = IDD_GET_SERVER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    DWORD       m_dwIpAddress;
    CString     m_strName;

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CGetServer::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetServer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGetServer)
	virtual void OnOK();
	afx_msg void OnChangeEditServerNameIp();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CConfirmAuthorization dialog

class CConfirmAuthorization : public CBaseDialog
{
// Construction
public:
	CConfirmAuthorization(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfirmAuthorization)
	enum { IDD = IDD_GET_SERVER_CONFIRM };
	CString	m_strName;
	//}}AFX_DATA

    DWORD m_dwAuthAddress;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfirmAuthorization)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CConfirmAuthorization::IDD); }

// Implementation
protected:
    CWndIpAddress	m_ipaAuth;   

	// Generated message map functions
	//{{AFX_MSG(CConfirmAuthorization)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _SERVBROW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\server.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        server.cpp
                This file contains the implementation for a DHCP Server
                object and the objects that can be contained within it.  
                Those objects are CDhcpBootp, CDhcpGlobalOptions and 
                CDhcpSuperscope.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"             // Server definition
#include "scope.h"              // Scope definition
#include "servpp.h"         // Server Property page
#include "sscopwiz.h"   // Superscope Wizard
#include "sscoppp.h"    // Scope Property Page
#include "scopewiz.h"   // Scope wizard
#include "addbootp.h"   // Add BOOTP entry dialog
#include "nodes.h"              // Result pane node definitions
#include "optcfg.h"             // Configure options dialog
#include "dlgdval.h"    // default options dialog
#include "sscpstat.h"   // Superscope statistics
#include "modeless.h"   // modeless thread 
#include "mscope.h"     // multicast scope stuff
#include "mscopwiz.h"   // multicast scope wizard
#include "classes.h"    // define classes dialog
#include "dlgrecon.h"   // reconcile dialog
#include "service.h"    // service control functions

#define SERVER_MESSAGE_MAX_STRING  11
typedef enum _SERVER_MESSAGES
{
    SERVER_MESSAGE_CONNECTED_NO_SCOPES,
    SERVER_MESSAGE_CONNECTED_NOT_AUTHORIZED,
    SERVER_MESSAGE_CONNECTED_BOTH,
    SERVER_MESSAGE_ACCESS_DENIED,
    SERVER_MESSAGE_UNABLE_TO_CONNECT,
    SERVER_MESSAGE_MAX
};

UINT g_uServerMessages[SERVER_MESSAGE_MAX][SERVER_MESSAGE_MAX_STRING] =
{
    {IDS_SERVER_MESSAGE_NO_SCOPES_TITLE,        Icon_Information, IDS_SERVER_MESSAGE_NO_SCOPES_BODY1,       IDS_SERVER_MESSAGE_NO_SCOPES_BODY2, 0},
    {IDS_SERVER_MESSAGE_NOT_AUTHORIZED_TITLE,   Icon_Information, IDS_SERVER_MESSAGE_NOT_AUTHORIZED_BODY1,  IDS_SERVER_MESSAGE_NOT_AUTHORIZED_BODY2, 0},
    {IDS_SERVER_MESSAGE_NOT_CONFIGURED_TITLE,   Icon_Information, IDS_SERVER_MESSAGE_NOT_CONFIGURED_BODY1,  IDS_SERVER_MESSAGE_NOT_CONFIGURED_BODY2, 0},
    {IDS_SERVER_MESSAGE_ACCESS_DENIED_TITLE,    Icon_Error,       IDS_SERVER_MESSAGE_ACCESS_DENIED_BODY,    0, 0},
    {IDS_SERVER_MESSAGE_CONNECT_FAILED_TITLE,   Icon_Error,       IDS_SERVER_MESSAGE_CONNECT_FAILED_BODY,   IDS_SERVER_MESSAGE_CONNECT_FAILED_REFRESH, 0},
};

#define SERVER_OPTIONS_MESSAGE_MAX_STRING  5
typedef enum _SERVER_OPTIONS_MESSAGES
{
    SERVER_OPTIONS_MESSAGE_NO_OPTIONS,
    SERVER_OPTIONS_MESSAGE_MAX
};

UINT g_uServerOptionsMessages[SERVER_OPTIONS_MESSAGE_MAX][SERVER_OPTIONS_MESSAGE_MAX_STRING] =
{
    {IDS_SERVER_OPTIONS_MESSAGE_TITLE, Icon_Information, IDS_SERVER_OPTIONS_MESSAGE_BODY, 0, 0}
};


CTimerMgr g_TimerMgr;

VOID CALLBACK 
StatisticsTimerProc
( 
    HWND        hwnd, 
    UINT        uMsg, 
    UINT_PTR    idEvent, 
    DWORD       dwTime 
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSingleLock slTimerMgr(&g_TimerMgr.m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    // on the timer, get the timer descriptor for this event
    // Call into the appropriate handler to update the stats.
    CTimerDesc * pTimerDesc;

    pTimerDesc = g_TimerMgr.GetTimerDesc(idEvent);

    pTimerDesc->pServer->TriggerStatsRefresh(pTimerDesc->spNode);
}


/*---------------------------------------------------------------------------
        Class CDhcpServer implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Constructor and destructor
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpServer::CDhcpServer
(
        ITFSComponentData *     pComponentData, 
        LPCWSTR                         pServerName
) : CMTDhcpHandler(pComponentData)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_strServerAddress = pServerName;
        m_dhcpServerAddress = UtilCvtWstrToIpAddr(pServerName);

        m_bNetbios = FALSE;
        m_liDhcpVersion.QuadPart = -1;
        m_pDefaultOptionsOnServer = new CDhcpDefaultOptionsOnServer;

    m_dwServerOptions = SERVER_OPTION_SHOW_ROGUE;
    m_dwRefreshInterval = DHCPSNAP_REFRESH_INTERVAL_DEFAULT;
        m_dwPingRetries = 0;

    m_pMibInfo = NULL;
    m_pMCastMibInfo = NULL;

    m_bStatsOnly = FALSE;
    m_StatsTimerId = -1;

        m_fSupportsDynBootp = FALSE;
        m_fSupportsBindings = FALSE;

    m_RogueInfo.fIsRogue = TRUE;
    m_RogueInfo.fIsInNt5Domain = TRUE;

    m_pSubnetInfoCache = NULL;
}

CDhcpServer::~CDhcpServer()
{
        if (m_pDefaultOptionsOnServer)
                delete m_pDefaultOptionsOnServer;
    
    if (IsAutoRefreshEnabled())
                g_TimerMgr.FreeTimer(m_StatsTimerId);

    if (m_pSubnetInfoCache)
        delete m_pSubnetInfoCache;

    // free up the Mib info struct if there is one.
    SetMibInfo(NULL);
    SetMCastMibInfo(NULL);
}

/*!--------------------------------------------------------------------------
        CDhcpServer::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strTemp;
    BuildDisplayName(&strTemp);
    
    SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_SERVER);

        SetColumnStringIDs(&aColumns[DHCPSNAP_SERVER][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_SERVER][0]);

    // assuming good status
    m_strState.LoadString(IDS_STATUS_UNKNOWN);

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DestroyHandler
                We need to free up any resources we are holding
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpServer::DestroyHandler(ITFSNode *pNode)
{
        // cleanup the stats dialog
    WaitForStatisticsWindow(&m_dlgStats);

    return CMTDhcpHandler::DestroyHandler(pNode);
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpServer::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = GetName() + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetImageIndex
                NOTE: the NumPendingOffers field of the scope MIB info is not used
        for display.  It is used to know the current state (active, inactive)
        of the scope.  If the scope is inactive, no warning or alert icons
        are displayed, therefore there should be no indication in the server
        of any inactive scope warnings or alerts.
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpServer::GetImageIndex(BOOL bOpenImage) 
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        int nIndex = -1;
        switch (m_nState)
        {
        case loading:
            nIndex = ICON_IDX_SERVER_BUSY;
            break;

                case notLoaded:
            case loaded:
        {
                        if (!m_pMibInfo)
                        {
                                nIndex = ICON_IDX_SERVER;
                        }
                        else
                        {
                    nIndex = ICON_IDX_SERVER_CONNECTED;

                                LPSCOPE_MIB_INFO pScopeMibInfo = m_pMibInfo->ScopeInfo;

                                // walk the list of scopes and calculate totals
                                for (UINT i = 0; i < m_pMibInfo->Scopes; i++)
                                {
                                        // don't worry about disabled scopes
                                        if (pScopeMibInfo[i].NumPendingOffers == DhcpSubnetDisabled)
                                                continue;

                                        int nPercentInUse;
                                        if ((pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree) == 0)
                                                nPercentInUse = 0;
                                        else
                                                nPercentInUse = (pScopeMibInfo[i].NumAddressesInuse * 100) / (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
    
                                        // look to see if any scope meets the warning or red flag case
                                        if (pScopeMibInfo[i].NumAddressesFree == 0)
                                        {
                                                // red flag case, no addresses free, this is the highest
                                                // level of warning, we don't want to look for anything else
                                                nIndex = ICON_IDX_SERVER_ALERT;
                                                break;
                                        }
                                        else
                                        if (nPercentInUse >= SCOPE_WARNING_LEVEL)
                                        {
                                                nIndex = ICON_IDX_SERVER_WARNING;
                                        }
                                }

                                // now see if this is a rogue server
                                if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION && 
                                        m_RogueInfo.fIsRogue)
                                {
                                        nIndex = ICON_IDX_SERVER_ROGUE;
                                }
                        }
        }

                case unableToLoad:
            if (m_dwErr == ERROR_ACCESS_DENIED)
            {
                            nIndex = ICON_IDX_SERVER_NO_ACCESS;
            }
            else
                        if (m_dwErr)
            {
                            nIndex = ICON_IDX_SERVER_LOST_CONNECTION;
            }
                        break;
                
        default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnHaveData
                When the background thread enumerates nodes to be added to the UI,
        we get called back here.  We need to figure out where to put these
        darn things, depending on what type of node it is...
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpServer::OnHaveData
(
        ITFSNode * pParentNode, 
        ITFSNode * pNewNode
)
{
    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    LPARAM              dwType = pNewNode->GetData(TFS_DATA_TYPE);

    if (pNewNode->IsContainer())
        {
                // assume all the child containers are derived from this class
                //((CDHCPMTContainer*)pNode)->SetServer(GetServer());
        }
        
    CORg (pParentNode->ChangeNode(SCOPE_PANE_STATE_CLEAR) );

    switch (dwType)
    {
        case DHCPSNAP_SCOPE:
        {
                    CDhcpScope * pScope = GETHANDLER(CDhcpScope, pNewNode);
                    pScope->SetServer(pParentNode);
            pScope->InitializeNode(pNewNode);

            AddScopeSorted(pParentNode, pNewNode);
        }
            break;

        case DHCPSNAP_SUPERSCOPE:
        {
                    CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, pNewNode);
                    pSuperscope->SetServer(pParentNode);
            pSuperscope->InitializeNode(pNewNode);

            AddSuperscopeSorted(pParentNode, pNewNode);
        }
            break;

        case DHCPSNAP_BOOTP_TABLE:
        {
            // the default node visiblity is to show
            if (!IsBootpVisible())
                pNewNode->SetVisibilityState(TFS_VIS_HIDE);

            LONG_PTR uRelativeFlag, uRelativeID;
            GetBootpPosition(pParentNode, &uRelativeFlag, &uRelativeID);

            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, uRelativeFlag);
            pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, uRelativeID);

            pParentNode->AddChild(pNewNode);
        }
            break;

        case DHCPSNAP_MSCOPE:
        {
                    CDhcpMScope * pMScope = GETHANDLER(CDhcpMScope, pNewNode);
                    pMScope->SetServer(pParentNode);
            pMScope->InitializeNode(pNewNode);

            AddMScopeSorted(pParentNode, pNewNode);
        }
            break;

        default:
            // global options get added here
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
            pParentNode->AddChild(pNewNode);
            break;
    }

    // now tell the view to update themselves
    ExpandNode(pParentNode, TRUE);

Error:
    return;
}

/*---------------------------------------------------------------------------
        CDhcpServer::AddScopeSorted
                Adds a scope node to the UI sorted
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::AddScopeSorted
(
    ITFSNode * pServerNode,
    ITFSNode * pScopeNode
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
        ULONG           nNumReturned = 0;
        DHCP_IP_ADDRESS dhcpIpAddressCurrent = 0;
        DHCP_IP_ADDRESS dhcpIpAddressTarget;

    CDhcpScope *   pScope;

    // get our target address
        pScope = GETHANDLER(CDhcpScope, pScopeNode);
        dhcpIpAddressTarget = pScope->GetAddress();

    // get the enumerator for this node
        CORg(pServerNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
                // walk the list subnodes, first we skip over superscopes
        // since they go at the top of the list.
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
            spPrevNode.Set(spCurrentNode);
            spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
            continue;
        }
        
        if (spCurrentNode->GetData(TFS_DATA_TYPE) != DHCPSNAP_SCOPE)
        {
            // we've gone through all the scopes and have now run
            // into either the bootp node or global options.
            // insert before whatever node this is.
            break;
        }

        pScope = GETHANDLER(CDhcpScope, spCurrentNode);
                dhcpIpAddressCurrent = pScope->GetAddress();

                if (dhcpIpAddressCurrent > dhcpIpAddressTarget)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next node in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (m_bExpanded)
        {
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
            pScopeNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
        }
        
        CORg(pServerNode->InsertChild(spPrevNode, pScopeNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);

        CORg(pServerNode->AddChild(pScopeNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::AddSuperscopeSorted
                Adds a superscope node to the UI sorted
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::AddSuperscopeSorted
(
    ITFSNode * pServerNode,
    ITFSNode * pSuperscopeNode
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
        ULONG           nNumReturned = 0;
    CString         strNameTarget;
    CString         strNameCurrent;
    
    CDhcpSuperscope *   pSuperscope;

    // get our target address
        pSuperscope = GETHANDLER(CDhcpSuperscope, pSuperscopeNode);
        strNameTarget = pSuperscope->GetName();

    // get the enumerator for this node
        CORg(pServerNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) != DHCPSNAP_SUPERSCOPE)
        {
            // we've gone through all the superscopes and have now run
            // into either a scope node, the bootp node or global options.
            // insert before whatever node this is.
            break;
        }

        pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);
                strNameCurrent = pSuperscope->GetName();

                if (strNameTarget.Compare(strNameCurrent) < 0)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next node in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (m_bExpanded)
        {
            pSuperscopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
            pSuperscopeNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
        }
        
        CORg(pServerNode->InsertChild(spPrevNode, pSuperscopeNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
            pSuperscopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);

        CORg(pServerNode->AddChild(pSuperscopeNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::AddMScopeSorted
                Adds a scope node to the UI sorted
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::AddMScopeSorted
(
    ITFSNode * pServerNode,
    ITFSNode * pScopeNode
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
        ULONG           nNumReturned = 0;
    CString         strCurrentName;
    CString         strTargetName;

    CDhcpMScope *   pScope;

    // get our target address
        pScope = GETHANDLER(CDhcpMScope, pScopeNode);
        strTargetName = pScope->GetName();

    // get the enumerator for this node
        CORg(pServerNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
                // walk the list subnodes, first we skip over superscopes
        // since they go at the top of the list.
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE ||
            spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
        {
            spPrevNode.Set(spCurrentNode);
            spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
            continue;
        }
        
        if (spCurrentNode->GetData(TFS_DATA_TYPE) != DHCPSNAP_MSCOPE)
        {
            // we've gone through all the scopes and have now run
            // into either the bootp node or global options.
            // insert before whatever node this is.
            break;
        }

        pScope = GETHANDLER(CDhcpMScope, spCurrentNode);
                strCurrentName = pScope->GetName();

                if (strCurrentName.Compare(strTargetName) >= 0)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next node in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (m_bExpanded)
        {
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
            pScopeNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
        }
        
        CORg(pServerNode->InsertChild(spPrevNode, pScopeNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);

        CORg(pServerNode->AddChild(pScopeNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetBootpPosition
                Returns the correct flag and relative ID for adding the BOOTP
        folder to the UI.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::GetBootpPosition
(
    ITFSNode * pServerNode,
    LONG_PTR * puRelativeFlag,
    LONG_PTR * puRelativeID
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
        ULONG           nNumReturned = 0;
    
    // get the enumerator for this node
        CORg(pServerNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_GLOBAL_OPTIONS)
        {
            // the BOOTP folder goes right before the global options folder
            break;
        }

                // get the next node in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    if (spCurrentNode)
    {
        if (puRelativeFlag)
            *puRelativeFlag = SDI_NEXT;
        
        if (puRelativeID)
            *puRelativeID = spCurrentNode->GetData(TFS_DATA_SCOPEID);
    }
    else
    {
        if (puRelativeFlag)
            *puRelativeFlag = SDI_FIRST;
        
        if (puRelativeID)
            *puRelativeID = 0;
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpServer::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    // This is how we get non-node data back from the background thread.
    switch (Type)
    {
        case DHCP_QDATA_VERSION:
            {
                    LARGE_INTEGER * pLI = reinterpret_cast<LARGE_INTEGER *>(Data);
                    m_liDhcpVersion.QuadPart = pLI->QuadPart;

                    delete pLI;
            break;
            }

            case DHCP_QDATA_SERVER_ID:
            {
                    LPDHCP_SERVER_ID pServerId = reinterpret_cast<LPDHCP_SERVER_ID>(Data);

            Trace2("Server IP chagned, updating.  Old name %s, New name %s.\n", m_strServerAddress, pServerId->strIp);

                        m_strServerAddress = pServerId->strIp;
                        m_dhcpServerAddress = UtilCvtWstrToIpAddr(pServerId->strIp);

                        // update the display
                        CString strDisplayName;
                        BuildDisplayName(&strDisplayName);
                        SetDisplayName(strDisplayName);

                        // update the node
            pParentNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);

                    delete pServerId;
                        break;
                }

        case DHCP_QDATA_SERVER_INFO:
            {
                    LPDHCP_SERVER_CONFIG pServerInfo = reinterpret_cast<LPDHCP_SERVER_CONFIG>(Data);
                    SetAuditLogging(pServerInfo->fAuditLog);
                    SetPingRetries(pServerInfo->dwPingRetries);
            m_strDatabasePath = pServerInfo->strDatabasePath;
            m_strBackupPath = pServerInfo->strBackupPath;
            m_strAuditLogPath = pServerInfo->strAuditLogDir;
                        m_fSupportsDynBootp = pServerInfo->fSupportsDynBootp;
                        m_fSupportsBindings = pServerInfo->fSupportsBindings;
                
                    delete pServerInfo;
            break;
            }

        case DHCP_QDATA_STATS:
            {
            LPDHCP_MIB_INFO pMibInfo = reinterpret_cast<LPDHCP_MIB_INFO>(Data);

            SetMibInfo(pMibInfo);

            UpdateStatistics(pParentNode);
            break;
        }

        case DHCP_QDATA_CLASS_INFO:
            {
            CClassInfoArray * pClassInfoArray = reinterpret_cast<CClassInfoArray *>(Data);

            SetClassInfoArray(pClassInfoArray);

            delete pClassInfoArray;
            break;
        }

        case DHCP_QDATA_OPTION_VALUES:
        {
            COptionValueEnum * pOptionValueEnum = reinterpret_cast<COptionValueEnum *>(Data);

            SetOptionValueEnum(pOptionValueEnum);
            
            pOptionValueEnum->RemoveAll();
            delete pOptionValueEnum;

            break;
        }

        case DHCP_QDATA_MCAST_STATS:
        {
            LPDHCP_MCAST_MIB_INFO pMibInfo = reinterpret_cast<LPDHCP_MCAST_MIB_INFO>(Data);

            SetMCastMibInfo(pMibInfo);

            UpdateStatistics(pParentNode);
            break;
        }

        case DHCP_QDATA_ROGUE_INFO:
        {
            CString strNewState;
            DHCP_ROGUE_INFO * pRogueInfo = (DHCP_ROGUE_INFO *) Data;

            m_RogueInfo = *pRogueInfo;
            delete pRogueInfo;

                        // NT4 servers are never rogue
            if (m_liDhcpVersion.QuadPart <= DHCP_NT5_VERSION)
                        {
                                m_RogueInfo.fIsRogue = FALSE;
                        }

            // if we aren't part of an NT5 domain, then don't display 
            // rogue warning messages
            if (!m_RogueInfo.fIsInNt5Domain)
            {
                m_dwServerOptions &= ~SERVER_OPTION_SHOW_ROGUE;
            }

                        if (m_RogueInfo.fIsRogue)
            {
                strNewState.LoadString(IDS_STATUS_ROGUE);

                                // put up a warning message
                                //DisplayRogueWarning();
            }
            else
            {
                strNewState.LoadString(IDS_STATUS_RUNNING);
            }

                        // update the UI if the state has changed
            if (strNewState.Compare(m_strState) != 0)
            {
                m_strState = strNewState;

                // update the icon
                pParentNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
                pParentNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));

                pParentNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);
            }

            break;
        }

        case DHCP_QDATA_SUBNET_INFO_CACHE:
        {
            CSubnetInfoCache * pSubnetInfo = reinterpret_cast<CSubnetInfoCache *>(Data);

            if (m_pSubnetInfoCache)
                delete m_pSubnetInfoCache;

            m_pSubnetInfoCache = pSubnetInfo;

            break;
        }

    }
}

/*!--------------------------------------------------------------------------
        CDhcpServer::OnNotifyExiting
                We override this for the server node because we don't want the 
        icon to change when the thread goes away.  Normal behavior is that
        the node's icon changes to a wait cursor when the background thread
        is running.  If we are only doing stats collection, then we 
        don't want the icon to change.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        CDhcpServerQueryObj * pQuery = (CDhcpServerQueryObj *) lParam;
        
    if (pQuery)
        pQuery->AddRef();

    if (!pQuery->m_bStatsOnly)
        OnChangeState(m_spNode);

    UpdateResultMessage(m_spNode);

    ReleaseThreadHandler();

        Unlock();

    if (pQuery)
        pQuery->Release();

    return hrOK;
}

void
CDhcpServer::DisplayRogueWarning()
{
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::UpdateToolbar
                Updates the toolbar depending upon the state of the node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::UpdateToolbar
(
    IToolbar *  pToolbar,
    LONG_PTR    dwNodeType,
    BOOL        bSelect
)
{
    if (m_liDhcpVersion.QuadPart < DHCP_SP2_VERSION)
    {
        // superscopes not available
        // Enable/disable toolbar buttons
        int i;
        BOOL aEnable[TOOLBAR_IDX_MAX];

        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = TRUE);
                aEnable[TOOLBAR_IDX_CREATE_SUPERSCOPE] = FALSE;
                break;
        
            case notLoaded:
            case loading:
                for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
                aEnable[TOOLBAR_IDX_REFRESH] = TRUE;
                break;
        }

        // if we are deselecting, then disable all
        if (!bSelect)
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);

        EnableToolbar(pToolbar,
                      g_SnapinButtons,
                      ARRAYLEN(g_SnapinButtons),
                      g_SnapinButtonStates[dwNodeType],
                      aEnable);
    }
    else
    {
        // just call the base handler
        CMTDhcpHandler::UpdateToolbar(pToolbar, dwNodeType, bSelect);
    }
}

 /*!--------------------------------------------------------------------------
        CDhcpServer::GetString
                Returns string information for display in the result pane columns
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpServer::GetString
(
    ITFSNode *  pNode,
    int         nCol
)
{
    switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
            return m_strState;
        }
        
        return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpServer::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0, fLoadingFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuItem;

        if ( m_nState != loaded )
        {
                fFlags |= MF_GRAYED;
        }

        if ( m_nState == loading)
        {
                fLoadingFlags = MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_SHOW_SERVER_STATS);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SHOW_SERVER_STATS,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );

            // separator
            // all menu Items go at the top now, these were under new
            // insert a separater here
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );


            strMenuItem.LoadString(IDS_CREATE_NEW_SCOPE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_CREATE_NEW_SCOPE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags,
                                    _T("_CREATE_NEW_SCOPE") );
                    ASSERT( SUCCEEDED(hr) );

                    // 
                    // Check the version number to see if the server supports
                    // the NT4 sp2 superscoping functionality
                    //
                    if (m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION &&
                FEnableCreateSuperscope(pNode))
                    {
                            strMenuItem.LoadString(IDS_CREATE_NEW_SUPERSCOPE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_CREATE_NEW_SUPERSCOPE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );

                            ASSERT( SUCCEEDED(hr) );
                    }

            // multicast scopes only supported on NT5 Servers
            if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
                    {
                            strMenuItem.LoadString(IDS_CREATE_NEW_MSCOPE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_CREATE_NEW_MSCOPE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
            }

            if (m_liDhcpVersion.QuadPart >= DHCP_NT51_VERSION)
                    {
                // put a separator
                        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                         strMenuItem, 
                                                                         0,
                                                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                         MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );

                            // backup
                strMenuItem.LoadString(IDS_SERVER_BACKUP);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_SERVER_BACKUP,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );

                // restore
                strMenuItem.LoadString(IDS_SERVER_RESTORE);
                hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_SERVER_RESTORE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
            }

            // former task menu items now on top
            if (m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
                    {
                // put a separator
                        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                         strMenuItem, 
                                                                         0,
                                                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                         MF_SEPARATOR);
                        ASSERT( SUCCEEDED(hr) );

                strMenuItem.LoadString(IDS_RECONCILE_ALL);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_RECONCILE_ALL,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }

            // authorization only required for NT5 machines
            if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
            {
                // if we haven't initialized yet on the background thread, don't put it up
                if (g_AuthServerList.IsInitialized())
                {
                    UINT uId = IDS_SERVER_AUTHORIZE;

                    if (g_AuthServerList.IsAuthorized(m_dhcpServerAddress))
                    //if (!m_RogueInfo.fIsRogue)
                    {
                        uId = IDS_SERVER_DEAUTHORIZE;
                    }

                            strMenuItem.LoadString(uId);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                                 strMenuItem, 
                                                                                 uId,
                                                                                 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                                 fFlags );
                                ASSERT( SUCCEEDED(hr) );
                }
            }

            // separator
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );

            // user/vendor class stuff for nt5
            if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
                    {
                            strMenuItem.LoadString(IDS_DEFINE_USER_CLASSES);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_DEFINE_USER_CLASSES,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );

                            strMenuItem.LoadString(IDS_DEFINE_VENDOR_CLASSES);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_DEFINE_VENDOR_CLASSES,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }

                    strMenuItem.LoadString(IDS_SET_DEFAULT_OPTIONS);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SET_DEFAULT_OPTIONS,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
        {
            // start/stop service menu items
                if ( m_nState == notLoaded ||
                 m_nState == loading)
                {
                        fFlags = MF_GRAYED;
                }
            else
            {
                fFlags = 0;
            }

            DWORD dwServiceStatus, dwErrorCode, dwErr;
            dwErr = ::TFSGetServiceStatus(m_strServerAddress, _T("dhcpserver"), &dwServiceStatus, &dwErrorCode);
                        if (dwErr != ERROR_SUCCESS)
                fFlags |= MF_GRAYED;

            // determining the restart state is the same as the stop flag
            LONG lStartFlag = (dwServiceStatus == SERVICE_STOPPED) ? 0 : MF_GRAYED;
            
            LONG lStopFlag = ( (dwServiceStatus == SERVICE_RUNNING) ||
                               (dwServiceStatus == SERVICE_PAUSED) ) ? 0 : MF_GRAYED;

            LONG lPauseFlag = ( (dwServiceStatus == SERVICE_RUNNING) ||
                                ( (dwServiceStatus != SERVICE_PAUSED) &&
                                  (dwServiceStatus != SERVICE_STOPPED) ) ) ? 0 : MF_GRAYED;
            
            LONG lResumeFlag = (dwServiceStatus == SERVICE_PAUSED) ? 0 : MF_GRAYED;

            strMenuItem.LoadString(IDS_SERVER_START_SERVICE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SERVER_START_SERVICE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                                                     fFlags | lStartFlag);

            strMenuItem.LoadString(IDS_SERVER_STOP_SERVICE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SERVER_STOP_SERVICE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                                                     fFlags | lStopFlag);

            strMenuItem.LoadString(IDS_SERVER_PAUSE_SERVICE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SERVER_PAUSE_SERVICE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                                                     fFlags | lPauseFlag);

            strMenuItem.LoadString(IDS_SERVER_RESUME_SERVICE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SERVER_RESUME_SERVICE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                     fFlags | lResumeFlag);

            strMenuItem.LoadString(IDS_SERVER_RESTART_SERVICE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SERVER_RESTART_SERVICE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                                                     fFlags | lStopFlag);
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpServer::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_DEFINE_USER_CLASSES:
                        OnDefineUserClasses(pNode);
                        break;

        case IDS_DEFINE_VENDOR_CLASSES:
                        OnDefineVendorClasses(pNode);
                        break;
    
        case IDS_CREATE_NEW_SUPERSCOPE:
                        OnCreateNewSuperscope(pNode);
                        break;

                case IDS_CREATE_NEW_SCOPE:
                        OnCreateNewScope(pNode);
                        break;

                case IDS_CREATE_NEW_MSCOPE:
                        OnCreateNewMScope(pNode);
                        break;

        case IDS_SHOW_SERVER_STATS:
                        OnShowServerStats(pNode);
                        break;

                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                case IDS_SET_DEFAULT_OPTIONS:
                        OnSetDefaultOptions(pNode);
                        break;

        case IDS_RECONCILE_ALL:
            OnReconcileAll(pNode);
            break;

        case IDS_SERVER_AUTHORIZE:
            OnServerAuthorize(pNode);
            break;

        case IDS_SERVER_DEAUTHORIZE:
            OnServerDeauthorize(pNode);
            break;

        case IDS_SERVER_STOP_SERVICE:
            hr = OnControlService(pNode, FALSE);
            break;

        case IDS_SERVER_START_SERVICE:
            hr = OnControlService(pNode, TRUE);
            break;

        case IDS_SERVER_PAUSE_SERVICE:
            hr = OnPauseResumeService(pNode, TRUE);
            break;

        case IDS_SERVER_RESUME_SERVICE:
            hr = OnPauseResumeService(pNode, FALSE);
            break;

        case IDS_SERVER_RESTART_SERVICE:
            OnControlService( pNode, FALSE );
            OnControlService( pNode, TRUE );
            break;

        case IDS_SERVER_BACKUP:
                    hr = OnServerBackup(pNode);
                    break;

        case IDS_SERVER_RESTORE:
                    hr = OnServerRestore(pNode);
                    break;

        default:
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpServer::OnDelete
                The base handler calls this when MMC sends a MMCN_DELETE for a 
                scope pane item.  We just call our delete command handler.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::OnDelete
(
        ITFSNode *      pNode, 
        LPARAM          arg, 
        LPARAM          lParam
)
{
    return OnDelete(pNode);
}

/*!--------------------------------------------------------------------------
        CDhcpServer::HasPropertyPages
                Implementation of ITFSNodeHandler::HasPropertyPages
        NOTE: the root node handler has to over-ride this function to 
        handle the snapin manager property page (wizard) case!!!
        
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpServer::HasPropertyPages
(
        ITFSNode *                      pNode,
        LPDATAOBJECT            pDataObject, 
        DATA_OBJECT_TYPES   type, 
        DWORD               dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        HRESULT hr = hrOK;
        
        if (dwType & TFS_COMPDATA_CREATE)
        {
                // This is the case where we are asked to bring up property
                // pages when the user is adding a new snapin.  These calls
                // are forwarded to the root node to handle.
                hr = hrOK;
                Assert(FALSE); // should never get here
        }
        else
        {
                // we have property pages in the normal case, but don't put the
                // menu up if we are not loaded yet
                if ( m_nState != loaded )
                {
                        hr = hrFalse;
                }
                else
                {
                        hr = hrOK;
                }
        }
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpServer::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD               dwError;
    DWORD               dwDynDnsFlags;
    HRESULT     hr = hrOK;
        
    //
        // Create the property page
    //
        SPIComponentData spComponentData;

    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spComponentData);

            CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

        if ( pServerProp == NULL )
            return ( hrFalse );

            pServerProp->SetVersion(m_liDhcpVersion);

            GetAutoRefresh(&pServerProp->m_pageGeneral.m_nAutoRefresh, 
                       &pServerProp->m_pageGeneral.m_dwRefreshInterval);
            pServerProp->m_pageGeneral.m_nAuditLogging = GetAuditLogging();
        pServerProp->m_pageGeneral.m_bShowBootp = IsBootpVisible() ? TRUE : FALSE;
        pServerProp->m_pageGeneral.m_uImage = GetImageIndex(FALSE);
        pServerProp->m_pageGeneral.m_fIsInNt5Domain = m_RogueInfo.fIsInNt5Domain;

            pServerProp->m_pageAdvanced.m_nConflictAttempts = GetPingRetries();
        pServerProp->m_pageAdvanced.m_strDatabasePath = m_strDatabasePath;
        pServerProp->m_pageAdvanced.m_strAuditLogPath = m_strAuditLogPath;
        pServerProp->m_pageAdvanced.m_strBackupPath = m_strBackupPath;
        pServerProp->m_pageAdvanced.m_dwIp = m_dhcpServerAddress;

        BEGIN_WAIT_CURSOR;

        dwError = GetDnsRegistration(&dwDynDnsFlags);
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return hrFalse;
        }
            
        END_WAIT_CURSOR;

            pServerProp->SetDnsRegistration(dwDynDnsFlags, DhcpGlobalOptions);
            
            //
            // Object gets deleted when the page is destroyed
        //
            Assert(lpProvider != NULL);

        hr = pServerProp->CreateModelessSheet(lpProvider, handle);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);
    
    LPARAM changeMask = 0;
    
    // tell the property page to do whatever now that we are back on the
    // main thread
    pServerProp->OnPropertyChange(TRUE, &changeMask);
    
    pServerProp->AcknowledgeNotify();
    
    if (changeMask) {
        pNode->ChangeNode(changeMask);
    }
    // Refresh the server node 
    OnRefresh( pNode, NULL, 0, 0, 0 );
    
    
    return hrOK;
} // CDhcpServer::OnPropertyChange()

/*---------------------------------------------------------------------------
        CDhcpServer::OnGetResultViewType
                Return the result view that this node is going to support
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CMTDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
        hr = S_FALSE;
    }

    return hr;
}
STDMETHODIMP_(int)
CDhcpServer::CompareItems
(
     ITFSComponent * pComponent, 
     MMC_COOKIE      cookieA, 
     MMC_COOKIE      cookieB, 
     int             nCol
) 
{ 
    SPITFSNode spNode1, spNode2;

    m_spNodeMgr->FindNode(cookieA, &spNode1);
    m_spNodeMgr->FindNode(cookieB, &spNode2);
    int nCompare = 0; 

    CString str1 = spNode1->GetString( nCol );
    CString str2 = spNode2->GetString( nCol );

    nCompare = str1.Compare( str2 );
    return nCompare;
} // CDhcpServer::CompareItems()

STDMETHODIMP_(int)
CDhcpServer::CompareItems
(
    ITFSComponent *pComponent,
    RDCOMPARE     *prdc
)
{
    SPITFSNode spNode1, spNode2;

    m_spNodeMgr->FindNode( prdc->prdch1->cookie, &spNode1);
    m_spNodeMgr->FindNode( prdc->prdch2->cookie, &spNode2);
    int nCompare = 0; 

    CString str1 = spNode1->GetString( prdc->nColumn );
    CString str2 = spNode2->GetString( prdc->nColumn );

    nCompare = str1.Compare( str2 );
    return nCompare;

}

/*!--------------------------------------------------------------------------
        CDhcpServer::OnResultSelect
                Update the verbs and the result pane message
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpServer::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    SPINTERNAL          spInternal;
    BOOL            bMultiSelect = FALSE;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(pComponent, spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

    UpdateResultMessage(spNode);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpServer::UpdateResultMessage
        Figures out what message to put in the result pane, if any
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CDhcpServer::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default
    int i;
    BOOL fScopes = FALSE, fAuthorized = FALSE;

    CString strTitle, strBody, strTemp;

        if (m_dwErr && m_dwErr != ERROR_ACCESS_DENIED)
    {
        // this is sorta special case as we need to build a special string
        TCHAR chMesg [4000] = {0};
        BOOL bOk ;

        UINT nIdPrompt = (UINT) m_dwErr;

        bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));

        nMessage = SERVER_MESSAGE_UNABLE_TO_CONNECT;

        strTitle.LoadString(g_uServerMessages[nMessage][0]);
        AfxFormatString1(strBody, g_uServerMessages[nMessage][2], chMesg);

        strTemp.LoadString(g_uServerMessages[nMessage][3]);
        strBody += strTemp;
    }
    else
    {   
        // build up some conditions
        if (m_pSubnetInfoCache && m_pSubnetInfoCache->GetCount() > 0) 
        {
            fScopes = TRUE;
        }

        if (!m_RogueInfo.fIsRogue)
        {
            fAuthorized = TRUE;
        }

        // determine what message to display
        if ( (m_nState == notLoaded) || 
             (m_nState == loading) )
        {
            nMessage = -1;
        }
        else
        if (m_dwErr == ERROR_ACCESS_DENIED)
        {       
            nMessage = SERVER_MESSAGE_ACCESS_DENIED;
        }
        else
        if (fScopes && fAuthorized)
        {
            nMessage = -1;
        }
        else
        if (!fScopes && fAuthorized)
        {
            nMessage = SERVER_MESSAGE_CONNECTED_NO_SCOPES;
        }
        else
        if (fScopes && !fAuthorized)
        {
            nMessage = SERVER_MESSAGE_CONNECTED_NOT_AUTHORIZED;
        }
        else
        {
            nMessage = SERVER_MESSAGE_CONNECTED_BOTH;
        }

        // build the strings
        if (nMessage != -1)
        {
            // now build the text strings
            // first entry is the title
            strTitle.LoadString(g_uServerMessages[nMessage][0]);

            // second entry is the icon
            // third ... n entries are the body strings

            for (i = 2; g_uServerMessages[nMessage][i] != 0; i++)
            {
                strTemp.LoadString(g_uServerMessages[nMessage][i]);
                strBody += strTemp;
            }
        }
    }

    // show the message
    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uServerMessages[nMessage][1]);
    }
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode  spServer, spSelectedNode;
    DWORD       dwError;
    
    m_spNodeMgr->FindNode(cookie, &spServer);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spServer);
        if (spSelectedNode != spServer)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int) listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

    BOOL fRefreshServer = FALSE;

    //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;
        
    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode   spCurNode;
        const GUID * pGuid;

                spCurNode = listNodesToDelete.RemoveHead();
        pGuid = spCurNode->GetNodeType();

        // do the right thing depending on what is selected
        if (*pGuid == GUID_DhcpSuperscopeNodeType)
        {
            BOOL fRefresh = FALSE;
            DeleteSuperscope(spCurNode, &fRefresh);
            if (fRefresh)
                fRefreshServer = TRUE;
        }
        else
        if (*pGuid == GUID_DhcpScopeNodeType)
        {
            BOOL fWantCancel = TRUE;

            DeleteScope(spCurNode, &fWantCancel);
            
            if (fWantCancel)
                break;  // user canceled out
        }
        else
        if (*pGuid == GUID_DhcpMScopeNodeType)
        {
            BOOL fWantCancel = TRUE;

            DeleteMScope(spCurNode, &fWantCancel);

            if (fWantCancel)
                break;  // user canceled out
        }
        else
        {
            Assert(FALSE);
        }
    }
    
    END_WAIT_CURSOR;

    if (fRefreshServer)
        OnRefresh(spServer, NULL, 0, 0, 0);

    return hr;
}


 /*!--------------------------------------------------------------------------
        CDhcpServer::UpdateConsoleVerbs
                Updates the standard verbs depending upon the state of the node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::UpdateConsoleVerbs
(
    ITFSComponent* pComponent,
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    HRESULT             hr = hrOK;
        CTFSNodeList        listSelectedNodes;
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];      
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        hr = BuildSelectedItemList(pComponent, &listSelectedNodes);

        if (SUCCEEDED(hr))
        {
            // collect all of the unique guids
            while (listSelectedNodes.GetCount() > 0)
                {
                        SPITFSNode   spCurNode;
                const GUID * pGuid;

                        spCurNode = listSelectedNodes.RemoveHead();
                pGuid = spCurNode->GetNodeType();
        
                // if the user selects the global options or BOOTP folder, disable delete
                if ( (*pGuid == GUID_DhcpGlobalOptionsNodeType) ||
                     (*pGuid == GUID_DhcpBootpNodeType) )
                {
                    bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
                }
            }
        }

        EnableVerbs(pConsoleVerb, ButtonState, bStates);
    }
    else
    {
        // default handler
        CMTDhcpHandler::UpdateConsoleVerbs(pConsoleVerb, dwNodeType, bMultiSelect);
    }
}

/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------
        CDhcpServer::OnDefineUserClasses
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnDefineUserClasses
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    CClassInfoArray ClassInfoArray;

    GetClassInfoArray(ClassInfoArray);

    CDhcpClasses dlgClasses(&ClassInfoArray, GetIpAddress(), CLASS_TYPE_USER);

    dlgClasses.DoModal();
    SetClassInfoArray(&ClassInfoArray);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnDefineVendorClasses
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnDefineVendorClasses
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    CClassInfoArray ClassInfoArray;

    GetClassInfoArray(ClassInfoArray);

    CDhcpClasses dlgClasses(&ClassInfoArray, GetIpAddress(), CLASS_TYPE_VENDOR);

    dlgClasses.DoModal();
    SetClassInfoArray(&ClassInfoArray);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateNewSuperscope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnCreateNewSuperscope
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CString strSuperscopeWizTitle;
        SPIComponentData spComponentData;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        strSuperscopeWizTitle.LoadString(IDS_SUPERSCOPE_WIZ_TITLE);

        m_spNodeMgr->GetComponentData(&spComponentData);
            CSuperscopeWiz * pSuperscopeWiz = new CSuperscopeWiz(pNode, 
                                                                                                                     spComponentData, 
                                                                                                                     m_spTFSCompData,
                                                                                                                     strSuperscopeWizTitle);
        if ( pSuperscopeWiz == NULL )
            return( hrFalse );

            BEGIN_WAIT_CURSOR;
        pSuperscopeWiz->GetScopeInfo();
        END_WAIT_CURSOR;

        hr = pSuperscopeWiz->DoModalWizard();
    }
    COM_PROTECT_CATCH

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateNewScope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnCreateNewScope
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
        CString         strScopeWizTitle;
        SPIComponentData spComponentData;
    SPIConsole      spConsole;

    COM_PROTECT_TRY
    {
        strScopeWizTitle.LoadString(IDS_SCOPE_WIZ_TITLE);

        m_spNodeMgr->GetComponentData(&spComponentData);
            CScopeWiz * pScopeWiz = new CScopeWiz(pNode, 
                                                  spComponentData, 
                                                  m_spTFSCompData,
                                                  NULL,
                                                  strScopeWizTitle);
        
        if ( pScopeWiz == NULL )
        {
            hr = hrFalse;
            return( hr );
        }

        pScopeWiz->m_pDefaultOptions = GetDefaultOptionsList();
        
        hr = pScopeWiz->DoModalWizard();

        // trigger the statistics to refresh
        TriggerStatsRefresh(pNode);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateNewMScope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnCreateNewMScope
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CString strScopeWizTitle;
        SPIComponentData spComponentData;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        strScopeWizTitle.LoadString(IDS_SCOPE_WIZ_TITLE);

        m_spNodeMgr->GetComponentData(&spComponentData);
            CMScopeWiz * pScopeWiz = new CMScopeWiz(pNode, 
                                                                                        spComponentData, 
                                                                                        m_spTFSCompData,
                                                                                        NULL);
            hr = pScopeWiz->DoModalWizard();
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnShowServerStats()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnShowServerStats
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    // Fill in some information in the stats object.
    // CreateNewStatisticsWindow handles the case if the window is 
    // already visible.
    m_dlgStats.SetNode(pNode);
    m_dlgStats.SetServer(GetIpAddress());
    
        CreateNewStatisticsWindow(&m_dlgStats,
                                                          ::FindMMCMainWindow(),
                                                          IDD_STATS_NARROW);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnSetDefaultOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnSetDefaultOptions(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

        COptionList & listOptions = m_pDefaultOptionsOnServer->GetOptionList();

        CDhcpDefValDlg dlgDefVal(pNode, &listOptions);

        dlgDefVal.DoModal();

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnReconcileAll()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnReconcileAll(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

        CReconcileDlg dlgRecon(pNode, TRUE);
        
        dlgRecon.DoModal();

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnServerAuthorize()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnServerAuthorize(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    hr = g_AuthServerList.AddServer(m_dhcpServerAddress, m_strDnsName);
    if (FAILED(hr))
    {
        ::DhcpMessageBox(WIN32_FROM_HRESULT(hr));
        // TODO: update node state
    }
    else
    {
        UpdateResultMessage(pNode);

        // refresh the node to update the icon
                TriggerStatsRefresh(pNode);
    }

        return S_OK;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnServerDeauthorize()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnServerDeauthorize(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    if (AfxMessageBox(IDS_WARNING_DEAUTHORIZE, MB_YESNO) == IDYES)
    {
        hr = g_AuthServerList.RemoveServer(m_dhcpServerAddress, m_strDnsName);
        if (FAILED(hr))
        {
            ::DhcpMessageBox(WIN32_FROM_HRESULT(hr));
            // TODO: update node state
        }
        else
        {
            UpdateResultMessage(pNode);

            // refresh the node to update the icon
                TriggerStatsRefresh(pNode);
        }
    }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnControlService
        -
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnControlService
(
    ITFSNode *  pNode,
    BOOL        fStart
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
    CString strServiceDesc;
        
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

    if (fStart)
    {
                err = TFSStartServiceEx(m_strDnsName, _T("dhcpserver"), _T("DHCP Service"), strServiceDesc);
    }
    else
    {
                err = TFSStopServiceEx(m_strDnsName, _T("dhcpserver"), _T("DHCP Service"), strServiceDesc);
    }

    if (err == ERROR_SUCCESS)
    {
        if (!fStart)
            m_fSilent = TRUE;

                OnRefresh(pNode, NULL, 0, 0, 0);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(err);
        ::DhcpMessageBox(err);
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnPauseResumeService
        -
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnPauseResumeService
(
    ITFSNode *  pNode,
    BOOL        fPause
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
        CString strServiceDesc;
        
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

    if (fPause)
    {
                err = TFSPauseService(m_strDnsName, _T("dhcpserver"), strServiceDesc);
    }
    else
    {
                err = TFSResumeService(m_strDnsName, _T("dhcpserver"), strServiceDesc);
    }

    if (err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        ::DhcpMessageBox(err);
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::RestartService
        -
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::RestartService
(
    ITFSNode *  pNode
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
        CString strServiceDesc;
        
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

        err = TFSStopServiceEx(m_strDnsName, _T("dhcpserver"), _T("DHCP Service"), strServiceDesc);
    if (err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
    }

    if (SUCCEEDED(hr))
    {
                err = TFSStartServiceEx(m_strDnsName, _T("dhcpserver"), _T("DHCP Service"), strServiceDesc);
        if (err != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(err);
            ::DhcpMessageBox(err);
        }
    }
    else
    {
        ::DhcpMessageBox(WIN32_FROM_HRESULT(hr));
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnServerBackup
        Just need to call the API, don't need to stop/start the service
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnServerBackup
(
    ITFSNode *  pNode
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;

    CString strHelpText, strPath;

    strHelpText.LoadString(IDS_BACKUP_HELP);

    UtilGetFolderName(m_strBackupPath, strHelpText, strPath);

    BEGIN_WAIT_CURSOR;

    err = ::DhcpServerBackupDatabase((LPWSTR) GetIpAddress(), (LPWSTR) (LPCTSTR) strPath);
    
    END_WAIT_CURSOR;

    if (err != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(err);
    }

    return HRESULT_FROM_WIN32(err);
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnServerRestore
        Calls the DHCP API and then restarts the service to take effect
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnServerRestore
(
    ITFSNode *  pNode
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;

    CString strHelpText, strPath;

    strHelpText.LoadString(IDS_RESTORE_HELP);

    BOOL fGotPath = UtilGetFolderName(m_strBackupPath, strHelpText, strPath);

    if (fGotPath)
    {
        BEGIN_WAIT_CURSOR;

        err = ::DhcpServerRestoreDatabase((LPWSTR) GetIpAddress(), (LPWSTR) (LPCTSTR) strPath);
        
        END_WAIT_CURSOR;

        if (err != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(err);
        }
        else
        {
            // need to restart the service to take effect.
            if (::AfxMessageBox(IDS_PATH_CHANGE_RESTART_SERVICE, MB_YESNO) == IDYES)
            {
                hr = RestartService(pNode);
                if (SUCCEEDED(hr))
                {
                    // call the QueryAttribute API to see if the restore completed
                    // successfully.  The restore is done when the service starts.  The service may
                    // start successfully even if the restore fails.
                    LPDHCP_ATTRIB pdhcpAttrib = NULL;

                    OnRefresh( pNode, NULL, 0, 0, 0 );
                    err = ::DhcpServerQueryAttribute((LPWSTR) GetIpAddress(), NULL, DHCP_ATTRIB_ULONG_RESTORE_STATUS, &pdhcpAttrib);
                    if (err == ERROR_SUCCESS)
                    {
                        Assert(pdhcpAttrib);
                        if (pdhcpAttrib->DhcpAttribUlong != ERROR_SUCCESS)
                        {
                            // the restore failed, but the service is running. tell the user
                            ::DhcpMessageBox( IDS_ERR_RESTORE_FAILED, NULL, MB_OK, pdhcpAttrib->DhcpAttribUlong );
                        }

                        ::DhcpRpcFreeMemory(pdhcpAttrib);
                    }
                }
            }
        }
    }

    return HRESULT_FROM_WIN32(err);
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnDelete()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = S_OK;
    CDhcpServer *pServ;

    // Is any property sheet open?
    pServ = GETHANDLER( CDhcpServer, pNode );
    if ( pServ->HasPropSheetsOpen()) {
        AfxMessageBox( IDS_MSG_CLOSE_PROPSHEET );
        return S_FALSE;
    }

    CString strMessage, strTemp;
    strTemp.LoadString(IDS_WRN_DISCONNECT);
    strMessage.Format(strTemp, GetIpAddress());
    
    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
        // remove this node from the list, there's nothing we need to tell
        // the server, it's just our local list of servers
        SPITFSNode spParent;
        
        pNode->GetParent(&spParent);
        spParent->RemoveChild(pNode);
    }
    
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpServer::OnUpdateToolbarButtons
                We override this function to show/hide the correct
        activate/deactivate buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        UpdateToolbarStates(pNode);
    }

    CMTDhcpHandler::OnUpdateToolbarButtons(pNode, pToolbarNotify);

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpServer::UpdateToolbarStates
            Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::UpdateToolbarStates(ITFSNode * pNode)
{
    g_SnapinButtonStates[DHCPSNAP_SERVER][TOOLBAR_IDX_CREATE_SUPERSCOPE] = FEnableCreateSuperscope(pNode) ? ENABLED : HIDDEN;
}

/*---------------------------------------------------------------------------
        CDhcpServer::FEnableCreateSuperscope()
                Determines whether to enable the create superscope option.  Only 
        enable if there are non-superscoped scopes
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL    
CDhcpServer::FEnableCreateSuperscope(ITFSNode * pNode)
{
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        ULONG           nNumReturned = 0;
    BOOL            bEnable = FALSE;
    HRESULT         hr = hrOK;

    // get the enumerator for this node
        CORg(pNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
        {
            // there is a non-superscoped scope
            bEnable = TRUE;
            break;
        }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

Error:
    return bEnable;
}

/*---------------------------------------------------------------------------
        Server manipulation functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpServer::CreateScope
                Creates a scope on the DHCP server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::CreateScope
(
        DHCP_IP_ADDRESS dhcpSubnetAddress,
        DHCP_IP_ADDRESS dhcpSubnetMask,
        LPCTSTR                 pName,
        LPCTSTR                 pComment
)
{
        DHCP_SUBNET_INFO dhcpSubnetInfo;

        dhcpSubnetInfo.SubnetAddress = dhcpSubnetAddress;
        dhcpSubnetInfo.SubnetMask = dhcpSubnetMask;
        dhcpSubnetInfo.SubnetName = (LPTSTR) pName;
        dhcpSubnetInfo.SubnetComment = (LPTSTR) pComment;
        dhcpSubnetInfo.SubnetState = DhcpSubnetDisabled;
        
        dhcpSubnetInfo.PrimaryHost.IpAddress = m_dhcpServerAddress;

        // Review : ericdav - do we need to fill these in?
        dhcpSubnetInfo.PrimaryHost.NetBiosName = NULL;
        dhcpSubnetInfo.PrimaryHost.HostName = NULL;

        DWORD dwErr =  ::DhcpCreateSubnet(GetIpAddress(),
                                          dhcpSubnetAddress,
                                          &dhcpSubnetInfo);

    if ( (dwErr == ERROR_SUCCESS) &&
         (m_pSubnetInfoCache) )
    {
        // add to subnet info cache
        CSubnetInfo subnetInfo;

        subnetInfo.Set(&dhcpSubnetInfo);

        m_pSubnetInfoCache->SetAt(dhcpSubnetAddress, subnetInfo);
    }

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteScope
                Deletes a scope on the DHCP server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::DeleteScope
(
    ITFSNode * pScopeNode,
    BOOL *     pfWantCancel
)
{
    DWORD        err = 0;
    BOOL         fAbortDelete = FALSE;
    BOOL         fDeactivated = FALSE;
    BOOL         fCancel = FALSE;
    BOOL         fWantCancel = FALSE;
    SPITFSNode   spParentNode;
    CDhcpScope * pScope;

    if (pfWantCancel)
        fWantCancel = *pfWantCancel;

    pScope = GETHANDLER(CDhcpScope, pScopeNode);

    //
    // Check if there are any property sheets open
    //

    if ( pScope->HasPropSheetsOpen()) {
        AfxMessageBox( IDS_MSG_CLOSE_PROPSHEET );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We do permit the deleting of active scopes, but
    // they do have to be disabled first.
    //
    if (pScope->IsEnabled())
    {
        pScope->SetState(DhcpSubnetDisabled);

                // Tell the scope to update it's state
                pScope->SetInfo();
        fDeactivated = TRUE;
    }

    //
    // First try without forcing
    //
    BEGIN_WAIT_CURSOR;
    err = DeleteSubnet(pScope->GetAddress(), FALSE); // Force = FALSE
    
    Trace1( "CDhcpServer::DeleteScope() : err = %ld\n", err );

    if (err == ERROR_FILE_NOT_FOUND)
    {
        //
        // Someone else already deleted this scope.
        // This is not a serious error.
        //
        UINT uType = (fWantCancel) ? MB_OKCANCEL : MB_OK;
        if (::DhcpMessageBox(IDS_MSG_ALREADY_DELETED, uType | MB_ICONINFORMATION) == IDCANCEL)

        RESTORE_WAIT_CURSOR;

        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS)
    {
        //
        // Give them a second shot
        //
        UINT uType = (fWantCancel) ? MB_YESNOCANCEL : MB_YESNO;
        int nRet = ::DhcpMessageBox (IDS_MSG_DELETE_SCOPE_FORCE, 
                                     uType | MB_DEFBUTTON2 | MB_ICONQUESTION);
        if (nRet == IDYES)
        {
            err = DeleteSubnet(pScope->GetAddress(), TRUE); // Force = TRUE
            if (err == ERROR_FILE_NOT_FOUND)
            {
                err = ERROR_SUCCESS;
            }
        }
        else
        {
            //
            // We don't want to delete the active scope.
            //
            fAbortDelete = TRUE;

            if (nRet == IDCANCEL)
                fCancel = TRUE;
        }

        END_WAIT_CURSOR;
    }

    if (err == ERROR_SUCCESS)
    {
                // remove from UI
                pScopeNode->GetParent(&spParentNode);
                spParentNode->RemoveChild(pScopeNode);
    }
    else
    {
        //
        // If we got here because we aborted the active
        // scope deletion, then we don't display the
        // error, and we may have to re-activate
        // the scope.  Otherwise, it's a genuine
        // error, and we put up an error message.
        //
        if (!fAbortDelete)
        {
            UINT uType = (fWantCancel) ? MB_OKCANCEL : MB_OK;
            if (::DhcpMessageBox( err, uType ) == IDCANCEL)
                fCancel = TRUE;

            goto Error;
        }
        else
        {
            if (fDeactivated)
            {
                //
                // We de-activated the scope preperatory to
                // to deleting the scope, but later aborted
                // this, so undo the de-activation now.
                //
                pScope->SetState(DhcpSubnetEnabled);

                                // Tell the scope to update it's state
                                pScope->SetInfo();
            }
        }
    }

Error:
    if (pfWantCancel)
        *pfWantCancel = fCancel;

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteSubnet
                Delete's this subnet on the DHCP Server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::DeleteSubnet
(
    DWORD   dwScopeId,
    BOOL    bForce
)
{
    DWORD dwErr =  ::DhcpDeleteSubnet(GetIpAddress(),
                                                          dwScopeId,
                                                          bForce ? DhcpFullForce : DhcpNoForce);

    if ( (dwErr == ERROR_SUCCESS) &&
         (m_pSubnetInfoCache) )
    {
        // remove from subnet info cache
        m_pSubnetInfoCache->RemoveKey(dwScopeId);
    }

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteSuperscope
                Deletes a superscope on the DHCP server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::DeleteSuperscope
(
    ITFSNode *  pNode,
    BOOL *      pfRefresh
)
{
    SPITFSNode        spServerNode;
    CDhcpSuperscope * pSuperscope;

    pSuperscope = GETHANDLER(CDhcpSuperscope, pNode);
    pNode->GetParent(&spServerNode);

    DWORD dwError = 0;

    if (pfRefresh)
        *pfRefresh = FALSE;

    BEGIN_WAIT_CURSOR;
    dwError = RemoveSuperscope(pSuperscope->GetName());
    END_WAIT_CURSOR;

        if (dwError != ERROR_SUCCESS)
        {
                ::DhcpMessageBox(dwError);
                return dwError;
        }
                
        // remove this node from the list and move all of the subscopes up 
        // one level as a child of the server node.
        SPITFSNodeEnum spNodeEnum;
        SPITFSNode spCurrentNode;
        ULONG nNumReturned = 0;
    int   nScopes = 0;

        pNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
                pNode->ExtractChild(spCurrentNode);
                
        CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);
        pServer->AddScopeSorted(spServerNode, spCurrentNode);

        CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);
        pScope->SetInSuperscope(FALSE);

                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nScopes++;
        }
        
    if (nScopes)
    {
        // remove the superscope node
            spServerNode->RemoveChild(pNode);
    }
    else
    {
        // node wasn't expanded yet, need to refresh the server
        if (pfRefresh)
            *pfRefresh = TRUE;
    }

    return dwError;
}

 /*---------------------------------------------------------------------------
        CDhcpServer::RemoveSuperscope()
                Wrapper for the DhcpDeleteSuperScopeV4 call
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::RemoveSuperscope(LPCTSTR pszName)
{
        return ::DhcpDeleteSuperScopeV4(GetIpAddress(), (LPWSTR) pszName);
}


/*---------------------------------------------------------------------------
        CDhcpServer::CreateMScope
                Creates a scope on the DHCP server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD   
CDhcpServer::CreateMScope
(
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    CString strLangTag;
    DWORD dwErr = ERROR_SUCCESS;

    // fill in the owner host stuff
        pMScopeInfo->PrimaryHost.IpAddress = m_dhcpServerAddress;

    // fill in the language ID
    GetLangTag(strLangTag);
    pMScopeInfo->LangTag = (LPWSTR) ((LPCTSTR) strLangTag);

        // Review : ericdav - do we need to fill these in?
        pMScopeInfo->PrimaryHost.NetBiosName = NULL;
        pMScopeInfo->PrimaryHost.HostName = NULL;

    dwErr = ::DhcpSetMScopeInfo(GetIpAddress(),
                                pMScopeInfo->MScopeName,
                                pMScopeInfo,
                                TRUE);
    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteMScope
                Deletes a scope on the DHCP server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::DeleteMScope
(
    ITFSNode *  pScopeNode,
    BOOL *      pfWantCancel

)
{
    DWORD        err = 0;
    BOOL         fAbortDelete = FALSE;
    BOOL         fDeactivated = FALSE;
    BOOL         fWantCancel = FALSE;
    BOOL         fCancel = FALSE;
    SPITFSNode   spServerNode;
    CDhcpMScope * pScope;

    if (pfWantCancel)
        fWantCancel = *pfWantCancel;

    pScope = GETHANDLER(CDhcpMScope, pScopeNode);

    //
    // We do permit the deleting of active scopes, but
    // they do have to be disabled first.
    //
    if (pScope->IsEnabled())
    {
        pScope->SetState(DhcpSubnetDisabled);

                // Tell the scope to update it's state
                pScope->SetInfo();
        fDeactivated = TRUE;
    }

    //
    // First try without forcing
    //
    BEGIN_WAIT_CURSOR;
    err = DeleteMSubnet(pScope->GetName(), FALSE); // Force = FALSE

    if (err == ERROR_FILE_NOT_FOUND)
    {
        //
        // Someone else already deleted this scope.
        // This is not a serious error.
        //
        UINT uType = (fWantCancel) ? MB_OKCANCEL : MB_OK;
        if (::DhcpMessageBox(IDS_MSG_ALREADY_DELETED, uType | MB_ICONINFORMATION) == IDCANCEL)
            fCancel = TRUE;

        RESTORE_WAIT_CURSOR;

        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS)
    {
        //
        // Give them a second shot
        //
        UINT uType = (fWantCancel) ? MB_YESNOCANCEL : MB_YESNO;
        int nRet = ::DhcpMessageBox (IDS_MSG_DELETE_SCOPE_FORCE, 
                                     uType | MB_DEFBUTTON2 | MB_ICONQUESTION);
        if (nRet == IDYES)
        {
            err = DeleteMSubnet(pScope->GetName(), TRUE); // Force = TRUE
            if (err == ERROR_FILE_NOT_FOUND)
            {
                err = ERROR_SUCCESS;
            }
        }
        else
        {
            //
            // We don't want to delete the active scope.
            //
            fAbortDelete = TRUE;

            if (nRet == IDCANCEL)
                fCancel = TRUE;
        }

        END_WAIT_CURSOR;
    }

    if (err == ERROR_SUCCESS)
    {
                // remove from UI
                pScopeNode->GetParent(&spServerNode);
                spServerNode->RemoveChild(pScopeNode);
    }
    else
    {
        //
        // If we got here because we aborted the active
        // scope deletion, then we don't display the
        // error, and we may have to re-activate
        // the scope.  Otherwise, it's a genuine
        // error, and we put up an error message.
        //
        if (!fAbortDelete)
        {
            UINT uType = (fWantCancel) ? MB_OKCANCEL : MB_OK;
            if (::DhcpMessageBox( err, uType ) == IDCANCEL)
                fCancel = TRUE;

            goto Error;
        }
        else
        {
            if (fDeactivated)
            {
                //
                // We de-activated the scope preperatory to
                // to deleting the scope, but later aborted
                // this, so undo the de-activation now.
                //
                pScope->SetState(DhcpSubnetEnabled);

                                // Tell the scope to update it's state
                                pScope->SetInfo();
            }
        }
    }

Error:
    if (pfWantCancel)
        *pfWantCancel = fCancel;

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteMSubnet
                Delete's this scope on the DHCP Server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpServer::DeleteMSubnet
(
    LPCTSTR pszName,
    BOOL    bForce
)
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = ::DhcpDeleteMScope((LPWSTR) GetIpAddress(),
                                                           (LPWSTR) pszName,
                                                           bForce ? DhcpFullForce : DhcpNoForce);

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetConfigInfo
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::SetConfigInfo
(
        BOOL    bAuditLogging,
        DWORD   dwPingRetries,
    LPCTSTR pszDatabasePath,
    LPCTSTR pszBackupPath
)
{
        DWORD dwError = 0;
        DWORD dwSetFlags = 0;

        Assert(m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION);

        if (m_liDhcpVersion.QuadPart < DHCP_SP2_VERSION)
                return dwError;

        DHCP_SERVER_CONFIG_INFO_V4 dhcpConfigInfo;
        ::ZeroMemory(&dhcpConfigInfo, sizeof(dhcpConfigInfo));

        if (bAuditLogging != GetAuditLogging())
        {
                dwSetFlags |= Set_AuditLogState;
                dhcpConfigInfo.fAuditLog = bAuditLogging;
        }

        if (dwPingRetries != GetPingRetries())
        {
                dwSetFlags |= Set_PingRetries;
                dhcpConfigInfo.dwPingRetries = dwPingRetries;
        }

    if (pszDatabasePath && m_strDatabasePath.Compare(pszDatabasePath) != 0)
    {
                dwSetFlags |= Set_DatabasePath;
        dhcpConfigInfo.DatabasePath = (LPWSTR) pszDatabasePath;
    }

    if (pszBackupPath && m_strBackupPath.Compare(pszBackupPath) != 0)
    {
                dwSetFlags |= Set_BackupPath;
        dhcpConfigInfo.BackupPath = (LPWSTR) pszBackupPath;
    }

    if (dwSetFlags)
        {
        if ( (dwSetFlags & Set_PingRetries) ||
             (dwSetFlags & Set_AuditLogState) )
        {
                    dwError = SetConfigInfo(dwSetFlags, &dhcpConfigInfo);
        }
        else
        {
            // use the old API to set the database path to be backward compatible
            dwError = SetConfigInfo(dwSetFlags, (DHCP_SERVER_CONFIG_INFO *) &dhcpConfigInfo);
        }

                if (dwError == 0)
                {
                        if (dwSetFlags & Set_PingRetries)
                                SetPingRetries(dhcpConfigInfo.dwPingRetries);

                        if (dwSetFlags & Set_AuditLogState)
                                SetAuditLogging(dhcpConfigInfo.fAuditLog);

            // update this here because it takes effect immediately and we 
            // don't have to restart the service.

            if (dwSetFlags & Set_BackupPath ) 
                m_strBackupPath = pszBackupPath;
                }
        }

        return dwError;
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetConfigInfo
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::SetConfigInfo
(
        DWORD   dwSetFlags,
        LPDHCP_SERVER_CONFIG_INFO pServerConfigInfo
)
{
        return ::DhcpServerSetConfig(GetIpAddress(), dwSetFlags, pServerConfigInfo);
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetConfigInfo
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::SetConfigInfo
(
        DWORD dwSetFlags,
        LPDHCP_SERVER_CONFIG_INFO_V4 pServerConfigInfo
)
{
        return ::DhcpServerSetConfigV4(GetIpAddress(), dwSetFlags, pServerConfigInfo);
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetAutoRefresh
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::SetAutoRefresh
(
    ITFSNode *  pNode,
        BOOL            bAutoRefreshOn,
        DWORD           dwRefreshInterval
)
{
    BOOL bCurrentAutoRefresh = IsAutoRefreshEnabled();

        if (bCurrentAutoRefresh &&
        !bAutoRefreshOn)
    {
        // turning off the timer
        g_TimerMgr.FreeTimer(m_StatsTimerId);
    }
    else
    if (!bCurrentAutoRefresh &&
        bAutoRefreshOn)
    {
        // gotta turn on the timer
        m_StatsTimerId = g_TimerMgr.AllocateTimer(pNode, this, dwRefreshInterval, StatisticsTimerProc);
    }
    else
    if (bAutoRefreshOn &&
        m_dwRefreshInterval != dwRefreshInterval)
    {
        // time to change the timer
        g_TimerMgr.ChangeInterval(m_StatsTimerId, dwRefreshInterval);
    }

    m_dwServerOptions = bAutoRefreshOn ? m_dwServerOptions | SERVER_OPTION_AUTO_REFRESH : 
                                         m_dwServerOptions & ~SERVER_OPTION_AUTO_REFRESH;
        m_dwRefreshInterval = dwRefreshInterval;

        return 0;
}

/*---------------------------------------------------------------------------
        CDhcpServer::ShowNode()
                Hides/shows either the bootp or classid node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpServer::ShowNode
(   
    ITFSNode *  pServerNode, 
    UINT        uNodeType, 
    BOOL        bVisible
)
{
    HRESULT hr = hrOK;

    switch (uNodeType)
    {
        case DHCPSNAP_BOOTP_TABLE:
        {
            if ( (bVisible && IsBootpVisible()) ||
                 (!bVisible && !IsBootpVisible()) )
                return hr;
            
            // find the bootp node
            SPITFSNodeEnum spNodeEnum;
                SPITFSNode spCurrentNode;
                ULONG nNumReturned = 0;

                pServerNode->GetEnum(&spNodeEnum);

                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
                while (nNumReturned)
                {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_BOOTP_TABLE)
                    break;

                spCurrentNode.Release();
                        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
                }

            Assert(spCurrentNode);

            // node doesn't exist... This should never happen because we shouldn't
            // allow the user the option to hide/show the node if the server doesn't
            // support BOOTP
            if (spCurrentNode == NULL)
                return hr;

            if (bVisible)
            {
                spCurrentNode->SetVisibilityState(TFS_VIS_SHOW);
                m_dwServerOptions |= SERVER_OPTION_SHOW_BOOTP;

                LONG_PTR uRelativeFlag, uRelativeID;
                GetBootpPosition(pServerNode, &uRelativeFlag, &uRelativeID);

                spCurrentNode->SetData(TFS_DATA_RELATIVE_FLAGS, uRelativeFlag);
                spCurrentNode->SetData(TFS_DATA_RELATIVE_SCOPEID, uRelativeID);
            }
            else
            {
                spCurrentNode->SetVisibilityState(TFS_VIS_HIDE);
                m_dwServerOptions &= ~SERVER_OPTION_SHOW_BOOTP;
            }

            spCurrentNode->Show();

        }
            break;

        default:
            Panic0("Invalid node type passed to ShowNode");
            break;
    }

    return hr;

}


/*---------------------------------------------------------------------------
        CDhcpServer::DoesMScopeExist()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpServer::DoesMScopeExist(ITFSNode * pServerNode, DWORD dwScopeId)
{
    // find all multicast scope nodes and mark the ones as not default
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        ULONG           nNumReturned = 0;
    BOOL            bFound = FALSE;

        pServerNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_MSCOPE)
        {
            CDhcpMScope * pMScope = GETHANDLER(CDhcpMScope, spCurrentNode);
            if (pMScope->GetScopeId() == dwScopeId)
            {
                bFound = TRUE;
                break;
            }
        }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    return bFound;
}
/*---------------------------------------------------------------------------
        CDhcpServer::GetGlobalOptionsContainer()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpGlobalOptions * 
CDhcpServer::GetGlobalOptionsContainer()
{
//      return reinterpret_cast<CDhcpGlobalOptions*>(GetChildByType(DHCPSNAP_GLOBAL_OPTIONS));
        return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetDefaultOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpServer::GetDefaultOptions()
{
        if (m_pDefaultOptionsOnServer)
                m_pDefaultOptionsOnServer->Enumerate(m_strServerAddress, m_liDhcpVersion);

        return TRUE;
}

/*---------------------------------------------------------------------------
        CDhcpServer::FindOption
                Finds an option from the list of default options on this server
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpOption *
CDhcpServer::FindOption(DHCP_OPTION_ID dhcpOptionId, LPCTSTR pszVendor)
{
    if (m_pDefaultOptionsOnServer)
            return m_pDefaultOptionsOnServer->Find(dhcpOptionId, pszVendor);
    else
        return NULL;
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetIpAddress()
                Returns the IP Address for this server in a string
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR
CDhcpServer::GetIpAddress()
{
        return m_strServerAddress;
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetIpAddress
                Returns the 32bit address of the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::GetIpAddress(DHCP_IP_ADDRESS *pdhcpIpAddress)
{
        *pdhcpIpAddress = m_dhcpServerAddress;
}

/*---------------------------------------------------------------------------
        CDhcpServer::BuildDisplayName
                Builds the string that goes in the UI for this server
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::BuildDisplayName
(
        CString * pstrDisplayName
)
{
        if (pstrDisplayName)
        {
                CString strName, strIp;

                strName = GetName();
        strIp = GetIpAddress();

        strName += _T(" [") + strIp + _T("]");

                *pstrDisplayName = strName;
        }

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetExtensionName
                Builds the string that goes in the UI for this server in the 
        extension case
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::SetExtensionName()
{
    SetDisplayName(_T("DHCP"));
}

/*---------------------------------------------------------------------------
        CDhcpServer::CreateOption()
                Create a new option type to match the given information
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServer::CreateOption 
(
    CDhcpOption * pdhcType
)
{
    DHCP_OPTION dhcOption ;
    DHCP_OPTION_DATA * pOptData;
        LONG err ;
    CDhcpOptionValue * pcOptionValue = NULL ;

    ::ZeroMemory(&dhcOption, sizeof(dhcOption));

    CATCH_MEM_EXCEPTION
    {
        //
        //  Create the structure required for RPC; force inclusion of
        //  at least one data element to define the data type.
        //
        pcOptionValue = new CDhcpOptionValue( &pdhcType->QueryValue() ) ;

        dhcOption.OptionID      = pdhcType->QueryId();
        dhcOption.OptionName    = ::UtilWcstrDup( pdhcType->QueryName() );
        dhcOption.OptionComment = ::UtilWcstrDup( pdhcType->QueryComment() ) ;
        dhcOption.OptionType    = pdhcType->QueryOptType() ;

                pcOptionValue->CreateOptionDataStruct(&pOptData);
                CopyMemory(&dhcOption.DefaultValue, pOptData, sizeof(DHCP_OPTION_DATA));

        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
            err = (LONG) ::DhcpCreateOptionV5((LPTSTR) ((LPCTSTR) m_strServerAddress),
                                              pdhcType->IsVendor() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                              dhcOption.OptionID,
                                              NULL,
                                              (LPTSTR) pdhcType->GetVendor(),
                                                                                      &dhcOption ) ;
        }
        else
        {
            err = (LONG) ::DhcpCreateOption( m_strServerAddress,
                                                                                     pdhcType->QueryId(),
                                                                                    &dhcOption ) ;
        }

        if (dhcOption.OptionName)
            delete dhcOption.OptionName;
        
        if (dhcOption.OptionComment)
            delete dhcOption.OptionComment;
    }
    END_MEM_EXCEPTION(err)

    if (err != ERROR_SUCCESS)
        Trace3("Create option type %d in scope %s FAILED, error = %d\n", (int) dhcOption.OptionID, m_strServerAddress, err);

    if (pcOptionValue)
        delete pcOptionValue ;
    
    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DeleteOption()
                Delete the option type associated with this ID
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServer::DeleteOption 
(
        DHCP_OPTION_ID  dhcid,
    LPCTSTR         pszVendor
)
{
    if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        DWORD dwFlags = (pszVendor == NULL) ? 0 : DHCP_FLAGS_OPTION_IS_VENDOR;

        return (LONG) ::DhcpRemoveOptionV5((LPTSTR) ((LPCTSTR) m_strServerAddress), 
                                           dwFlags,
                                           dhcid, 
                                           NULL, 
                                           (LPTSTR) pszVendor);   
    }
    else
    {
        return (LONG) ::DhcpRemoveOption(m_strServerAddress, dhcid);
    }
}

/*---------------------------------------------------------------------------
        CDhcpServer::GetDnsRegistration
                Gets the DNS registration option value
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::GetDnsRegistration
(
        LPDWORD pDnsRegOption
)
{
    //
    // Check option 81 -- the DNS registration option
    //
    DHCP_OPTION_VALUE * poptValue = NULL;
    DWORD                               err = 0 ;

    DHCP_OPTION_SCOPE_INFO dhcScopeInfo ;
    ZeroMemory( &dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        dhcScopeInfo.ScopeType = DhcpGlobalOptions;

        err = (DWORD) ::DhcpGetOptionValue(m_strServerAddress,
                                                                                   OPTION_DNS_REGISTATION,
                                                                                   &dhcScopeInfo,
                                                                                   &poptValue );
        }
    END_MEM_EXCEPTION(err) ;
        
        // this is the default
        if (pDnsRegOption)
                *pDnsRegOption = DHCP_DYN_DNS_DEFAULT;

        // if this option is defined, then use it's value
        if (err == ERROR_SUCCESS)
        {
                if ((poptValue->Value.Elements != NULL) &&
                        (pDnsRegOption))
                {
                        *pDnsRegOption = poptValue->Value.Elements[0].Element.DWordOption;
                }
        }
        else
    {
        Trace0("CDhcpServer::GetDnsRegistration - couldn't get DNS reg value -- option may not be defined. Setting default value.\n");

                err = ERROR_SUCCESS;
    }

        // free up the RPC memory
        if (poptValue)
                ::DhcpRpcFreeMemory(poptValue);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetDnsRegistration
                Sets the DNS Registration option for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::SetDnsRegistration
(
        DWORD DnsRegOption
)
{
        DWORD err = 0;

        //
    // Set DNS name registration (option 81)
        //
    CDhcpOption dhcpOption (OPTION_DNS_REGISTATION,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(DnsRegOption);
    
    DHCP_OPTION_DATA *          pdhcOptionData;
    DHCP_OPTION_SCOPE_INFO      dhcScopeInfo;
    CDhcpOptionValue *          pcOptionValue = NULL;

    ZeroMemory( & dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        pcOptionValue = new CDhcpOptionValue( & dhcpOption.QueryValue() ) ;

        if ( pcOptionValue )
                {
            dhcScopeInfo.ScopeType = DhcpGlobalOptions ;

            pcOptionValue->CreateOptionDataStruct(&pdhcOptionData, TRUE);

            err = (DWORD) ::DhcpSetOptionValue(m_strServerAddress,
                                                                                           dhcpOption.QueryId(),
                                                                                           &dhcScopeInfo,
                                                                                           pdhcOptionData);
        }
    }
    END_MEM_EXCEPTION(err) ;

    delete pcOptionValue ;
        return err;
}

/*---------------------------------------------------------------------------
        CDhcpServer::ScanDatabase()
                Scan/reconcile database
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServer::ScanDatabase  
(
    DWORD                         FixFlag,
    LPDHCP_SCAN_LIST *ScanList, 
        DHCP_IP_ADDRESS   dhcpSubnetAddress
)
{
    return (LONG) ::DhcpScanDatabase (m_strServerAddress,
                                                                          dhcpSubnetAddress,
                                                                          FixFlag,
                                                                          ScanList);
}

/*---------------------------------------------------------------------------
        CDhcpServer::ScanDatabase()
                Scan/reconcile database
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServer::ScanDatabase  
(
    DWORD                         FixFlag,
    LPDHCP_SCAN_LIST *ScanList, 
        LPWSTR            pMScopeName
)
{
    return (LONG) ::DhcpScanMDatabase(m_strServerAddress,
                                                                          pMScopeName,
                                                                          FixFlag,
                                                                          ScanList);
}

/*---------------------------------------------------------------------------
        CDhcpServer::UpdateTypeList()
                Scan/reconcile database
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServer::UpdateOptionList 
(
    COptionList * poblValues,     // The list of types/values
    COptionList * poblDefunct,    // The list of deleted types/values
    CWnd *                pwndMsgParent   // IF !NULL, window for use for popups
)
{
    LONG err = 0,
         err2 ;
    CDhcpOption * pdhcType;

    //
    //  First, delete the deleted types
    //
    poblDefunct->Reset();
    while ( pdhcType = poblDefunct->Next() )
    {
        err2 = DeleteOption( pdhcType->QueryId(), pdhcType->GetVendor()) ;
        if ( err2 != 0 )
        {
            if ( err == 0 )
            {
                err = err2 ;
            }
        }
        pdhcType->SetApiErr( err2 ) ;
    }

    //
    //  Next, update the altered values. We do this by deleting the old setting
    //  and re adding it.
    //
    poblValues->Reset();
        while ( pdhcType = poblValues->Next() )
    {
        if ( pdhcType->IsDirty() )
        {
            //
            //  Delete the old value.
            //
            DeleteOption( pdhcType->QueryId(), pdhcType->GetVendor() ) ;

            //
            //  Recreate it.
            //
            err2 = CreateOption( pdhcType ) ;
            if ( err2 != 0 )
            {
                if ( err == 0 )
                {
                    err = err2 ;
                }
            }
            else
            {
                pdhcType->SetDirty( FALSE ) ;
            }
            
                        pdhcType->SetApiErr( err2 );
        }
    }

    //
    //  If there were errors and we're given a window handle, display
    //  each error message in some detail.
    //
    if ( err && pwndMsgParent )
    {
        DisplayUpdateErrors( poblValues, poblDefunct, pwndMsgParent ) ;
    }

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DisplayUpdateErrors()
                Display all the errors associated with a pair of update lists.
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::DisplayUpdateErrors 
(
    COptionList * poblValues,
    COptionList * poblDefunct,
    CWnd *                pwndMsgParent
)
{
    CDhcpOption * pdhcType ;
    DWORD err ;
    TCHAR chBuff [STRING_LENGTH_MAX] ;
    TCHAR chMask [STRING_LENGTH_MAX] ;

    ::LoadString( AfxGetInstanceHandle(), IDS_INFO_OPTION_REFERENCE,
                 chMask, sizeof(chMask)/sizeof(chMask[0]) ) ;

    if ( poblDefunct )
    {
        poblDefunct->Reset();
                while ( pdhcType = poblDefunct->Next() )
        {
            if ( err = pdhcType->QueryApiErr() )
            {
                //
                // If we couldn't find the thing in the registry, that's
                // actually OK, because it may never have been saved in
                // the first place, i.e. it may have been added and deleted
                // in the same session of this dialog.
                //
                if ( err == ERROR_FILE_NOT_FOUND )
                {
                    err = ERROR_SUCCESS;
                }
                else
                {
                    ::wsprintf( chBuff, chMask, (int) pdhcType->QueryId() ) ;
                    ::DhcpMessageBox( err, MB_OK, chBuff ) ;
                }
            }
        }
    }

    if ( poblValues )
    {
                poblValues->Reset();
        while ( pdhcType = poblValues->Next() )
        {
            if ( err = pdhcType->QueryApiErr() )
            {
                ::wsprintf( chBuff, chMask, (int) pdhcType->QueryId() ) ;
                ::DhcpMessageBox( err, MB_OK, chBuff ) ;
            }
        }
    }
}

/*---------------------------------------------------------------------------
        CDhcpServer::HasSuperscopes
                Determines if the server has superscopes (based on cached info)
        Doesn't contact the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
CDhcpServer::HasSuperscopes
(
    ITFSNode * pNode
)
{
    BOOL bHasSuperscopes = FALSE;

        SPITFSNodeEnum spNodeEnum;
        SPITFSNode spCurrentNode;
        ULONG nNumReturned = 0;

        pNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
            bHasSuperscopes = TRUE;
            break;
        }

                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
        
    return bHasSuperscopes;
}

/*---------------------------------------------------------------------------
        CDhcpServer::UpdateStatistics
        Notification that stats are now available.  Update stats for the 
        server node and give all subnodes a chance to update.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServer::UpdateStatistics
(
    ITFSNode * pNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned;
    HWND            hStatsWnd;
        BOOL                    bChangeIcon = FALSE;

    // Check to see if this node has a stats sheet up.
    hStatsWnd = m_dlgStats.GetSafeHwnd();
    if (hStatsWnd != NULL)
    {
        PostMessage(hStatsWnd, WM_NEW_STATS_AVAILABLE, 0, 0);
    }
    
    // Set the icon to whatever is correct based on the state and
    // statistics
    LONG_PTR nOldIndex = pNode->GetData(TFS_DATA_IMAGEINDEX);
    int nNewIndex = GetImageIndex(FALSE);

    if (nOldIndex != nNewIndex)
    {
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON);
    }

    // After updating everything for the server node,
    // tell the scope and superscope nodes to update anything
    // they need to based on the new stats.
    CORg(pNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
        {
            CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);

            pScope->UpdateStatistics(spCurrentNode);
        }
        else
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);

            pSuperscope->UpdateStatistics(spCurrentNode);
        }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetMibInfo()
                Updates our pointer to the MIB info struct
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPDHCP_MIB_INFO 
CDhcpServer::SetMibInfo
(
    LPDHCP_MIB_INFO pMibInfo
) 
{
    CSingleLock slMibInfo(&m_csMibInfo);

    slMibInfo.Lock();
    
    LPDHCP_MIB_INFO pTemp = NULL;

    if (m_pMibInfo)
    {
        pTemp = m_pMibInfo;
        ::DhcpRpcFreeMemory(m_pMibInfo);
        pTemp = 0;
    }

    m_pMibInfo = pMibInfo;

    return pTemp;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DuplicateMibInfo()
                Makes a copy if the MibInfo struct.  We do this because the MIB info
        struct may get updated in the background.
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPDHCP_MIB_INFO
CDhcpServer::DuplicateMibInfo()
{
    HRESULT         hr = hrOK;
    LPDHCP_MIB_INFO pDupMibInfo = NULL;
    int             nSize = 0;
    CSingleLock     slMibInfo(&m_csMibInfo);
    
    slMibInfo.Lock();

    Assert(m_pMibInfo);
    if (m_pMibInfo == NULL)
        return NULL;

    COM_PROTECT_TRY
    {
        nSize = sizeof(DHCP_MIB_INFO) + m_pMibInfo->Scopes * sizeof(SCOPE_MIB_INFO);
        pDupMibInfo = (LPDHCP_MIB_INFO) new BYTE[nSize];

        *pDupMibInfo = *m_pMibInfo;

                pDupMibInfo->ScopeInfo = (LPSCOPE_MIB_INFO) ((LPBYTE) pDupMibInfo + sizeof(DHCP_MIB_INFO));

                if (m_pMibInfo->ScopeInfo)
                {
                        memcpy(pDupMibInfo->ScopeInfo, m_pMibInfo->ScopeInfo, m_pMibInfo->Scopes * sizeof(SCOPE_MIB_INFO));
                }
    }
    COM_PROTECT_CATCH

    return pDupMibInfo;
}

/*---------------------------------------------------------------------------
        CDhcpServer::FreeDupMibInfo()
                Scan/reconcile database
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::FreeDupMibInfo(LPDHCP_MIB_INFO pDupMibInfo)
{
    delete [] (( BYTE * ) pDupMibInfo);
}

/*---------------------------------------------------------------------------
        CDhcpServer::SetMCastMibInfo()
                Updates our pointer to the MIB info struct
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPDHCP_MCAST_MIB_INFO 
CDhcpServer::SetMCastMibInfo
(
    LPDHCP_MCAST_MIB_INFO pMibInfo
) 
{
    CSingleLock slMibInfo(&m_csMibInfo);

    slMibInfo.Lock();
    
    LPDHCP_MCAST_MIB_INFO pTemp = NULL;

    if (m_pMCastMibInfo)
    {
        pTemp = m_pMCastMibInfo;
        ::DhcpRpcFreeMemory(m_pMCastMibInfo);
        pTemp = 0;
    }

    m_pMCastMibInfo = pMibInfo;

    return pTemp;
}

/*---------------------------------------------------------------------------
        CDhcpServer::DuplicateMCastMibInfo()
                Makes a copy if the MibInfo struct.  We do this because the MIB info
        struct may get updated in the background.
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPDHCP_MCAST_MIB_INFO
CDhcpServer::DuplicateMCastMibInfo()
{
    HRESULT                 hr = hrOK;
    LPDHCP_MCAST_MIB_INFO   pDupMibInfo = NULL;
    int                     nSize = 0;
    CSingleLock             slMibInfo(&m_csMibInfo);
    
    slMibInfo.Lock();

    Assert(m_pMCastMibInfo);
    if (m_pMCastMibInfo == NULL)
        return NULL;

    do {
        pDupMibInfo = new DHCP_MCAST_MIB_INFO;
        if ( 0 == pDupMibInfo ) {
            break;
        }
        *pDupMibInfo = *m_pMCastMibInfo;

        if ( m_pMCastMibInfo->Scopes > 0 ) {
            
            pDupMibInfo->ScopeInfo =
                new MSCOPE_MIB_INFO[ m_pMCastMibInfo->Scopes ];
            if ( 0 != pDupMibInfo->ScopeInfo ) {
                for ( DWORD i = 0 ; i < m_pMCastMibInfo->Scopes; i++ ) {
                    pDupMibInfo->ScopeInfo[ i ] = m_pMCastMibInfo->ScopeInfo[ i ];
                    pDupMibInfo->ScopeInfo[ i ].MScopeName = 
                        ::UtilWcstrDup( m_pMCastMibInfo->ScopeInfo[ i ].MScopeName, NULL );
                } // for
            } // if 
            else {
                pDupMibInfo->Scopes = 0;
                pDupMibInfo->ScopeInfo = 0;
            }
        } // if 
    } while ( FALSE );
//      COM_PROTECT_CATCH

    return pDupMibInfo;
} // CDhcpServer::DuplicateMCastMibInfo()

/*---------------------------------------------------------------------------
        CDhcpServer::FreeDupMCastMibInfo()
                Scan/reconcile database
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServer::FreeDupMCastMibInfo(LPDHCP_MCAST_MIB_INFO pDupMibInfo)
{
    for ( DWORD i = 0; i < pDupMibInfo->Scopes; i++ ) {
        delete [] pDupMibInfo->ScopeInfo[ i ].MScopeName;
    }
    delete [] pDupMibInfo->ScopeInfo;
    delete pDupMibInfo;
}

/*---------------------------------------------------------------------------
        CDhcpServer::TriggerStatsRefresh()
                Starts the background thread to gather stats only
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpServer::TriggerStatsRefresh(ITFSNode * pNode)
{
        m_dwErr = 0;
    m_bStatsOnly = TRUE;
        OnRefreshStats(pNode, NULL, NULL, 0, 0);
    m_bStatsOnly = FALSE;

    return hrOK;
}



/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateQuery
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpServer::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpServerQueryObj* pQuery = NULL;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
            pQuery = new CDhcpServerQueryObj(m_spTFSCompData, m_spNodeMgr);
            
        if ( pQuery == NULL )
        {
            return pQuery;
        }

            pQuery->m_strServer = m_strServerAddress;
                pQuery->m_strServerName = m_strDnsName;
                
            pQuery->m_dhcpResumeHandle = NULL;
            pQuery->m_dwPreferredMax = 0xFFFFFFFF;
            pQuery->m_liDhcpVersion.QuadPart = m_liDhcpVersion.QuadPart;
            pQuery->m_pDefaultOptionsOnServer = m_pDefaultOptionsOnServer;

        pQuery->m_bStatsOnly = m_bStatsOnly;
    }
    COM_PROTECT_CATCH

    return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpServer::OnCreateStatsQuery
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpServer::OnCreateStatsQuery(ITFSNode * pNode)
{
        CDhcpServerQueryObj* pQuery = NULL;
    HRESULT hr = hrOK;

        COM_PROTECT_TRY
    {
        pQuery = new CDhcpServerQueryObj(m_spTFSCompData, m_spNodeMgr);
            
        if ( pQuery == NULL )
        {
            return pQuery;
        }

            pQuery->m_strServer = m_strServerAddress;
            
            pQuery->m_dhcpResumeHandle = NULL;
            pQuery->m_dwPreferredMax = 0;
            pQuery->m_liDhcpVersion.QuadPart = 0;
            pQuery->m_pDefaultOptionsOnServer = NULL;

        pQuery->m_bStatsOnly = TRUE;
    }
    COM_PROTECT_CATCH

    return pQuery;
}

/*---------------------------------------------------------------------------
    CDhcpServerQueryObj::OnEventAbort
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServerQueryObj::OnEventAbort
(
        LPARAM Data,
        LPARAM Type
)
{
        if (Type == DHCP_QDATA_VERSION)
        {
                Trace0("CDhcpServerQueryObj::OnEventAbort - deleting version");
                delete (void *) Data;
        }

        if (Type == DHCP_QDATA_SERVER_INFO)
        {
                Trace0("CDhcpServerQueryObj::OnEventAbort - deleting ServerInfo");
                delete (void *) Data;
        }

        if (Type == DHCP_QDATA_STATS)
        {
                Trace0("CDhcpServerQueryObj::OnEventAbort - deleting Stats Info");
        ::DhcpRpcFreeMemory((void *) Data);
    }
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpServerQueryObj::Execute()
{
    HRESULT                         hr = hrOK;
        DWORD                           err = ERROR_SUCCESS;
    LPDHCP_SERVER_CONFIG            pServerInfo = NULL;
    LPDHCP_SERVER_ID                    pServerId = NULL;
        SPITFSNode                      spGlobalOptionsNode;
        SPITFSNode                      spBootpNode;
    DHCP_OPTION_SCOPE_INFO          dhcpOptionScopeInfo;
    CDhcpDefaultOptionsMasterList   MasterList;
    CDhcpGlobalOptions *            pGlobalOptions = NULL;
    CDhcpBootp *                    pDhcpBootp = NULL;
    CClassInfoArray *               pClassInfoArray = NULL;
    COptionValueEnum *              pOptionValueEnum = NULL;
        LARGE_INTEGER *                                 pLI = NULL;

    COM_PROTECT_TRY
    {
        m_pSubnetInfoCache = new CSubnetInfoCache;

                // check to see if the ip address has changed
                if (VerifyDhcpServer())
                {
                        // ip address has changed...
                    pServerId = new DHCP_SERVER_ID;

                        pServerId->strIp = m_strServer;
                        pServerId->strName = m_strServerName;

                        AddToQueue((LPARAM) pServerId, DHCP_QDATA_SERVER_ID);
                }

        // Get the server's version
            err = SetVersion();
            if (err != ERROR_SUCCESS)
            {
                    PostError(err);

                        if (m_bStatsOnly)
                        {
                                // poke the main thread to update the UI
                                AddToQueue(NULL, DHCP_QDATA_STATS);
                        }

                    return hrFalse;
            }

                // send the info back to the main thread
                pLI = new LARGE_INTEGER;
                *pLI = m_liDhcpVersion;
                AddToQueue((LPARAM) pLI, DHCP_QDATA_VERSION);

        // Get server stats
        err = GetStatistics();
        if (err != ERROR_SUCCESS)
        { 
            Trace1("CDhcpServerQueryObj: ERROR - GetStatistics returned %d\n", err);
            PostError(err);

                        if (m_bStatsOnly)
                        {
                                // poke the main thread to update the UI
                                AddToQueue(NULL, DHCP_QDATA_STATS);
                        }
            
                        return hrFalse;
        }

                // Get rogue and other info
        err = GetStatus();
        if (err != ERROR_SUCCESS)
        { 
            Trace1("CDhcpServerQueryObj: ERROR - GetStatus returned %d\n", err);
            PostError(err);

                        if (m_bStatsOnly)
                        {
                                // poke the main thread to update the UI
                                AddToQueue(NULL, DHCP_QDATA_STATS);
                        }
            
                        return hrFalse;
        }
        
        // if we are only querring for stats, exit out.
        if (m_bStatsOnly)
        {
            delete m_pSubnetInfoCache;
            return hrFalse;
        }

        // Get the configuration information
            err = GetConfigInfo();
            if (err != ERROR_SUCCESS)
            {
                    PostError(err);
                    return hrFalse;
            }

            pServerInfo = new DHCP_SERVER_CONFIG;
            pServerInfo->fAuditLog = m_fAuditLog;
            pServerInfo->dwPingRetries = m_dwPingRetries;
        pServerInfo->strDatabasePath = m_strDatabasePath;
        pServerInfo->strBackupPath = m_strBackupPath;
        pServerInfo->strAuditLogDir = m_strAuditLogPath;
                pServerInfo->fSupportsDynBootp = m_fSupportsDynBootp;
                pServerInfo->fSupportsBindings = m_fSupportsBindings;

        // get the new name
                /*
        DHCP_IP_ADDRESS dhipa = UtilCvtWstrToIpAddr(m_strServer);
        DHC_HOST_INFO_STRUCT hostInfo;
        err = ::UtilGetHostInfo(dhipa, &hostInfo);
        if (err == ERROR_SUCCESS)
        {
            pServerInfo->strDnsName = hostInfo._chHostName;
        }
        */
        
                AddToQueue((LPARAM) pServerInfo, DHCP_QDATA_SERVER_INFO);

            //
            // Now enumerate all of the options on the server
            //
            m_pDefaultOptionsOnServer->Enumerate(m_strServer, m_liDhcpVersion);
            Trace2("Server %s has %d default options defined.\n", m_strServer, m_pDefaultOptionsOnServer->GetCount());

        MasterList.BuildList();

            if (m_pDefaultOptionsOnServer->GetCount() != MasterList.GetCount())
            {
                    // 
                    // This server doesn't have any options defined or is missing some
                    //
                    UpdateDefaultOptionsOnServer(m_pDefaultOptionsOnServer, &MasterList);
            }

        // enumerate global options
        Trace0("Enumerating global options.\n");

        // enumerate the classes on the server
        pOptionValueEnum = new COptionValueEnum();

        dhcpOptionScopeInfo.ScopeType = DhcpGlobalOptions;
        dhcpOptionScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

        pOptionValueEnum->Init(m_strServer, m_liDhcpVersion, dhcpOptionScopeInfo);
        err = pOptionValueEnum->Enum();
        if (err != ERROR_SUCCESS)
        {
            PostError(err);
            delete pOptionValueEnum;
            return hrFalse;
        }
        else
        {
            pOptionValueEnum->SortById();
            AddToQueue((LPARAM) pOptionValueEnum, DHCP_QDATA_OPTION_VALUES);
        }

            //
            // Make Global Options folder
            //
            pGlobalOptions = new CDhcpGlobalOptions(m_spTFSCompData);
            CreateContainerTFSNode(&spGlobalOptionsNode,
                                                       &GUID_DhcpGlobalOptionsNodeType,
                                                       pGlobalOptions,
                                                       pGlobalOptions,
                                                       m_spNodeMgr);

            // Tell the handler to initialize any specific data
            pGlobalOptions->InitializeNode(spGlobalOptionsNode);
            AddToQueue(spGlobalOptionsNode);
            pGlobalOptions->Release();

        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
                    Trace0("Version is at least NT5, enumerating classes on server.\n");

            // enumerate the classes on the server
            pClassInfoArray = new CClassInfoArray();
            pClassInfoArray->RefreshData(m_strServer);
            AddToQueue((LPARAM) pClassInfoArray, DHCP_QDATA_CLASS_INFO);

            EnumMScopes();
        }

        if (m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
            {
                    //
                    // This server supports the v4 calls
                    //
                    Trace0("Version is at least NT4 SP2, Creating BOOTP Folder.\n");

                    //
                    // Make the BOOTP Table folder
                    //
                    pDhcpBootp = new CDhcpBootp(m_spTFSCompData);
                    CreateContainerTFSNode(&spBootpNode,
                                                               &GUID_DhcpBootpNodeType,
                                                               pDhcpBootp,
                                                               pDhcpBootp,
                                                               m_spNodeMgr);

                    // Tell the handler to initialize any specific data
                    pDhcpBootp->InitializeNode(spBootpNode);

                    AddToQueue(spBootpNode);
                    pDhcpBootp->Release();

                    EnumSubnetsV4();
            }
            else
            {
                    //
                    // This server doesn't support the V4 calls
                    //
                    EnumSubnets();
            }

        AddToQueue((LPARAM) m_pSubnetInfoCache, DHCP_QDATA_SUBNET_INFO_CACHE);

    }
    COM_PROTECT_CATCH

        return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpServerQueryObj::VerifyDhcpServer()
                Resolve the IP address and see if the names are the same.  If not,
                get the new IP address.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpServerQueryObj::VerifyDhcpServer()
{
    DHCP_IP_ADDRESS                     dhipa = UtilCvtWstrToIpAddr(m_strServer);
    DHC_HOST_INFO_STRUCT        hostInfo;
        BOOL                                    fChanged = FALSE;
        DWORD                                   dwErr = ERROR_SUCCESS;

    dwErr = ::UtilGetHostInfo(dhipa, &hostInfo);
    if ( (dwErr != ERROR_SUCCESS) ||
         (m_strServerName.CompareNoCase(hostInfo._chHostName) != 0) )
        {
                // assume the IP address has changed
                // get the IP address associated with the name we had before
                fChanged = TRUE;

        if (m_strServerName.IsEmpty())
        {
            // host name couldn't be resolved when we entered the IP 
            // originally...  So now it can be so lets update the name
            m_strServerName = hostInfo._chHostName;
        }
        else
        {
            // IP resolved to a different name
            // so, let's resolve the name we've stored away to the
            // new IP
                    if (UtilGetHostAddress(m_strServerName, &dhipa) == ERROR_SUCCESS)
            {
                        UtilCvtIpAddrToWstr(dhipa, &m_strServer);
            }
        }
    }
    
        return fChanged;
}

/*---------------------------------------------------------------------------
        CDhcpServerQueryObj::SetVersion()
                 Call the the get version number API,
                 to determine the DHCP version of this
                 host.

                 Return TRUE for success.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServerQueryObj::SetVersion()
{
    DWORD       dwMajorVersion = 0;
    DWORD       dwMinorVersion = 0;
        LPCWSTR pServerAddress = (LPCWSTR) m_strServer;

    DWORD dw = ::DhcpGetVersion((LPWSTR) pServerAddress, &dwMajorVersion, &dwMinorVersion);
    
        Trace3("DhcpGetVersion returned %lx.  Version is %d.%d\n", dw, dwMajorVersion, dwMinorVersion);

    if (dw == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        //
        // Only in 3.5 was this API not present, so
        // set the version to 1.0, and reset the error
        //
        Trace0("API Not present, version 1.0 assumed\n");
        dwMajorVersion = 1;
        dwMinorVersion = 0;
        dw = ERROR_SUCCESS;
    }

    if (dw == ERROR_SUCCESS)
    {
        m_liDhcpVersion.LowPart = dwMinorVersion;
        m_liDhcpVersion.HighPart = dwMajorVersion;
        }

        return dw;
} 

/*---------------------------------------------------------------------------
        GetConfigInfo()
                This function gets the conflict detection attempt count and the
                audit logging flag from the server.  These are the only server
                config options we care about.  We store the option values in 
                the query object so that if this object gets used by sometime 
                other than the background thread, the values can just be read 
                out of the object, and we don't have to muck with the data queue.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServerQueryObj::GetConfigInfo()
{
        DWORD dwError = 0;

        if (m_liDhcpVersion.QuadPart >= DHCP_SP2_VERSION)
        {
        LPDHCP_SERVER_CONFIG_INFO_V4 pConfigInfo = NULL;
        
        dwError = ::DhcpServerGetConfigV4(m_strServer, &pConfigInfo);
                if (dwError == ERROR_SUCCESS)
                {
                        m_fAuditLog = pConfigInfo->fAuditLog;
                        m_dwPingRetries = pConfigInfo->dwPingRetries;
            m_strDatabasePath = pConfigInfo->DatabasePath;
            m_strBackupPath = pConfigInfo->BackupPath;

                        ::DhcpRpcFreeMemory(pConfigInfo);
                }
        }
    else
    {
        LPDHCP_SERVER_CONFIG_INFO pConfigInfo = NULL;
        
        dwError = ::DhcpServerGetConfig(m_strServer, &pConfigInfo);
                if (dwError == ERROR_SUCCESS)
                {
            m_strDatabasePath = pConfigInfo->DatabasePath;
            m_strBackupPath = pConfigInfo->BackupPath;

                        ::DhcpRpcFreeMemory(pConfigInfo);
                }
    }

        // audit logging stuff
        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
                LPWSTR          pAuditLogPath = NULL;
                DWORD           dwDiskCheckInterval = 0, dwMaxLogFilesSize = 0, dwMinSpaceOnDisk = 0;

                dwError = ::DhcpAuditLogGetParams((LPWSTR) (LPCTSTR) m_strServer,
                                                                                  0,
                                                                                  &pAuditLogPath,
                                                                                  &dwDiskCheckInterval,
                                                                                  &dwMaxLogFilesSize,
                                                                                  &dwMinSpaceOnDisk);
                if (dwError == ERROR_SUCCESS)
                {
                        m_strAuditLogPath = pAuditLogPath;

                        ::DhcpRpcFreeMemory(pAuditLogPath);
                }
        }
        
        // dynamic BOOTP supported?
        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
        LPDHCP_ATTRIB pdhcpAttrib = NULL;

        DWORD dwTempError = ::DhcpServerQueryAttribute((LPWSTR) (LPCTSTR) m_strServer, NULL, DHCP_ATTRIB_BOOL_IS_DYNBOOTP, &pdhcpAttrib);
                if (dwTempError == ERROR_SUCCESS)
                {
            Assert(pdhcpAttrib);
                        m_fSupportsDynBootp = pdhcpAttrib->DhcpAttribBool;
                        
            ::DhcpRpcFreeMemory(pdhcpAttrib);
                }
                else
                {
                        m_fSupportsDynBootp = FALSE;
                }
        }
        else
        {
                m_fSupportsDynBootp = FALSE;
        }

        // Bindings supported?
        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        LPDHCP_ATTRIB pdhcpAttrib = NULL;

        DWORD dwTempError = ::DhcpServerQueryAttribute((LPWSTR) (LPCTSTR) m_strServer, NULL, DHCP_ATTRIB_BOOL_IS_BINDING_AWARE, &pdhcpAttrib);
        if (dwTempError == ERROR_SUCCESS)
        {
            Assert(pdhcpAttrib);
            m_fSupportsBindings = pdhcpAttrib->DhcpAttribBool;
                        
            ::DhcpRpcFreeMemory(pdhcpAttrib);
        }
        else
        {
            m_fSupportsBindings = FALSE;
        }
    }
    else
    {
        m_fSupportsBindings = FALSE;
    }

    return dwError;
}

/*---------------------------------------------------------------------------
        GetStatus()
        This function gets the rogue status of the DHCP server.  
    Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServerQueryObj::GetStatus()
{
        DWORD dwError = 0;

    LPDHCP_ATTRIB       pdhcpAttrib = NULL;
    DHCP_ROGUE_INFO  *  pRogueInfo = new DHCP_ROGUE_INFO;

    if (pRogueInfo == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRogueInfo->fIsInNt5Domain = TRUE;  // assume true

        if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
        {
            pRogueInfo->fIsRogue = TRUE;        // assume the worst here
    
                dwError = ::DhcpServerQueryAttribute((LPWSTR) (LPCTSTR) m_strServer, NULL, DHCP_ATTRIB_BOOL_IS_ROGUE, &pdhcpAttrib);
                if (dwError == ERROR_SUCCESS)
                {
            Assert(pdhcpAttrib);

            pRogueInfo->fIsRogue = pdhcpAttrib->DhcpAttribBool;

            ::DhcpRpcFreeMemory(pdhcpAttrib);
                        pdhcpAttrib = NULL;
                }

        dwError = ::DhcpServerQueryAttribute((LPWSTR) (LPCTSTR) m_strServer, NULL, DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC, &pdhcpAttrib);
                if (dwError == ERROR_SUCCESS)
                {
            Assert(pdhcpAttrib);

            pRogueInfo->fIsInNt5Domain = pdhcpAttrib->DhcpAttribBool;

            ::DhcpRpcFreeMemory(pdhcpAttrib);
                        pdhcpAttrib = NULL;
                }
        }
        else
        {
                // pre-NT5 servers are never rogue
                pRogueInfo->fIsRogue = FALSE;
        }

    AddToQueue((LPARAM) pRogueInfo, DHCP_QDATA_ROGUE_INFO);

        return ERROR_SUCCESS;
}

/*---------------------------------------------------------------------------
    CDhcpServerQueryObj::GetStatistics
                Gets stats info from the server.
        WARNING WARNING - I use the NumPendingOffers field of the scope 
        stats for the current state of the scope.  This field is not 
        used in any of the statistics displays. The server node needs to
        know if the scope is active or not.  Because of the way nodes are 
        enumerated, we may not have created all of the scope nodes 
        below a superscope, so there is no way to garuntee we can determine
        the state of all scopes through our internal tree.
        If the scope is not active, then we DO NOT display 
        any warning indicators.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpServerQueryObj::GetStatistics()
{
    DWORD               dwError;
        LPDHCP_MIB_INFO     pMibInfo = NULL;

    dwError = ::DhcpGetMibInfo(m_strServer, &pMibInfo);
    if (dwError != ERROR_SUCCESS)
        {
                return dwError;
        }

    Assert(pMibInfo);
    if (pMibInfo == NULL)
        return ERROR_INVALID_DATA;

    // now loop through and get the state for each scope
    LPSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;
    CSubnetInfo     subnetInfo;

    // walk the list of scopes and get the state
    for (UINT i = 0; i < pMibInfo->Scopes; i++)
    {
        // assume the scope is not active
        pScopeMibInfo[i].NumPendingOffers = DhcpSubnetEnabled;

        dwError = m_pSubnetInfoCache->GetInfo(m_strServer, pScopeMibInfo[i].Subnet, subnetInfo);
        if (dwError == ERROR_SUCCESS)
        {
            pScopeMibInfo[i].NumPendingOffers = subnetInfo.SubnetState;
        }
    }
     
        AddToQueue((LPARAM) pMibInfo, DHCP_QDATA_STATS);

    if (m_liDhcpVersion.QuadPart >= DHCP_NT5_VERSION)
    {
            LPDHCP_MCAST_MIB_INFO pMCastMibInfo = NULL;
            
        dwError = ::DhcpGetMCastMibInfo(m_strServer, &pMCastMibInfo);
        if (dwError == ERROR_SUCCESS)
            {
            LPMSCOPE_MIB_INFO pMScopeMibInfo = pMCastMibInfo->ScopeInfo;

            // walk the list of scopes and get the state
            for (i = 0; i < pMCastMibInfo->Scopes; i++)
            {
                // assume the scope is not active
                pMScopeMibInfo[i].NumPendingOffers = DhcpSubnetEnabled;

                dwError = m_MScopeInfoCache.GetInfo(m_strServer, pMScopeMibInfo[i].MScopeName, subnetInfo);
                if (dwError == ERROR_SUCCESS)
                {
                    pMScopeMibInfo[i].NumPendingOffers = subnetInfo.SubnetState;
                }
            }
            }

        AddToQueue((LPARAM) pMCastMibInfo, DHCP_QDATA_MCAST_STATS);
    }

    return dwError;
}

/*---------------------------------------------------------------------------
    CDhcpServerQueryObj::UpdateDefaultOptionsOnServer
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServerQueryObj::UpdateDefaultOptionsOnServer
(
        CDhcpDefaultOptionsOnServer     *       pOptionsOnServer,
        CDhcpDefaultOptionsMasterList * pMasterList
)
{
    LONG err = ERROR_SUCCESS,
         err2;
    BOOL fAddedTypes = FALSE;
    CString strMasterVendor, strOptionVendor;

        CDhcpOption * pMasterOption;
    CDhcpOption * pServerOption = pOptionsOnServer->Next() ;

    if (pServerOption)
        strOptionVendor = pServerOption->GetVendor();

    while ( pMasterOption = pMasterList->Next() )
    {
        DHCP_OPTION_ID idMaster;

        if (pMasterOption)
        {
            idMaster = pMasterOption->QueryId();
            strMasterVendor = pMasterOption->GetVendor();
        }

        while ( pServerOption != NULL && 
                                idMaster > pServerOption->QueryId() )
        {
            //
                        // The cached list contains an entry not on the master list.
            // Advance to the next element in the cached list.
            //
                        pServerOption = pOptionsOnServer->Next();
            if (pServerOption)
                strOptionVendor = pServerOption->GetVendor();
        }

        if ( pServerOption != NULL && 
                         idMaster == pServerOption->QueryId() &&
             strMasterVendor.CompareNoCase(strOptionVendor) == 0 )
        {
            //
                        // This entry is on both the cached list and the master list.
            // Advance to the next element in both lists.
            //
                        pServerOption = pOptionsOnServer->Next();
            if (pServerOption)
                strOptionVendor = pServerOption->GetVendor();

            continue;
        }

        //
                // There is no DhcpCreateOptions (plural), and DhcpSetValues
        //  only initializes OptionValue
        //
                err2 = CreateOption( pMasterOption ); // ignore error return
        if ( err2 != ERROR_SUCCESS )
        {
            Trace2("CDhcpServerQueryObj: error %d adding type %d\n", err2, idMaster);
        }

        fAddedTypes = TRUE;
    }

    //
        // Update cache if necessary
    //
        if ( fAddedTypes )
    {
        if (err == ERROR_SUCCESS)
            err = pOptionsOnServer->Enumerate(m_strServer, m_liDhcpVersion);
    }

    if ( err != ERROR_SUCCESS )
    {
        Trace1("UpdateDefaultOptionsOnServer error %d in CreateTypeList\n", err);
    }
}

/*---------------------------------------------------------------------------
        Function Name Here
                Create a new type to match the given information
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG
CDhcpServerQueryObj::CreateOption 
(
    CDhcpOption * pOption
)
{
    DHCP_OPTION dhcpOption;
    LONG err ;
        LPDHCP_OPTION_DATA pDhcpOptionData;
        CDhcpOptionValue & OptionValue = pOption->QueryValue();

        OptionValue.CreateOptionDataStruct(&pDhcpOptionData, TRUE);
    
        ZeroMemory( &dhcpOption, sizeof(dhcpOption) ) ;

    CATCH_MEM_EXCEPTION
    {
        dhcpOption.OptionID      = pOption->QueryId() ;
        dhcpOption.OptionName    = ((LPWSTR) (LPCTSTR) pOption->QueryName()) ;
        dhcpOption.OptionComment = ((LPWSTR) (LPCTSTR) pOption->QueryComment())  ;
        dhcpOption.DefaultValue  = *pDhcpOptionData ;
        dhcpOption.OptionType    = pOption->QueryOptType() ;

        err = (LONG) ::DhcpCreateOption( m_strServer,
                                                                                 pOption->QueryId(),
                                                                                 &dhcpOption ) ;
    }
    END_MEM_EXCEPTION(err)

    if (err)
                Trace3("Create option type %d on server %s FAILED, error = %d\n", dhcpOption.OptionID, m_strServer, err); 
                
        OptionValue.FreeOptionDataStruct();
    
        return err ;
}

/*---------------------------------------------------------------------------
    CDhcpServerQueryObj::EnumMScopes()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServerQueryObj::EnumMScopes()
{

        DWORD                                           dwError = ERROR_MORE_DATA;
        DWORD                                           dwElementsRead = 0, dwElementsTotal = 0;
        LPDHCP_MSCOPE_TABLE                     pMScopeTable = NULL;
    CSubnetInfo                 subnetInfo;

        //
        // for this server, enumerate all of it's subnets
        // 
        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumMScopes((LPCTSTR)m_strServer,
                                                                        &m_dhcpResumeHandle,
                                                                        m_dwPreferredMax, 
                                                                        &pMScopeTable,
                                                                        &dwElementsRead,
                                                                        &dwElementsTotal);
        
        Trace2("Server %s - DhcpEnumMScopes returned %lx.\n", m_strServer, dwError);

                if (dwElementsRead && dwElementsTotal && pMScopeTable)
                {
                        //
                        // loop through all of the subnets that were returned
                        //
                        for (DWORD i = 0; i < pMScopeTable->NumElements; i++)
                        {
                DWORD dwReturn = m_MScopeInfoCache.GetInfo(m_strServer,  pMScopeTable->pMScopeNames[i], subnetInfo);
                if (dwReturn != ERROR_SUCCESS)
                {
                    Trace3("Server %s, MScope %s - DhcpGetMScopeInfo returned %lx.\n", m_strServer, pMScopeTable->pMScopeNames[i], dwError);
                }
                else
                {
                            //
                                    // Create the new scope based on the info we querried
                                    //

                                    SPITFSNode spNode;
                                    CDhcpMScope * pDhcpMScope = new CDhcpMScope(m_spTFSCompData);
                                    CreateContainerTFSNode(&spNode,
                                                                               &GUID_DhcpMScopeNodeType,
                                                                               pDhcpMScope,
                                                                               pDhcpMScope,
                                                                               m_spNodeMgr);

                                    // Tell the handler to initialize any specific data
                    pDhcpMScope->InitMScopeInfo(subnetInfo);
                    pDhcpMScope->InitializeNode(spNode);
                            
                                    AddToQueue(spNode);

                                    pDhcpMScope->Release();
                }
                        }

                        //
                        // Free up the RPC memory
                        //
                        ::DhcpRpcFreeMemory(pMScopeTable);

                        dwElementsRead = 0;
                        dwElementsTotal = 0;
                        pMScopeTable = NULL;
                }
        }
}

/*---------------------------------------------------------------------------
    CDhcpServerQueryObj::EnumSubnetsV4()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServerQueryObj::EnumSubnetsV4()
{
    DWORD                           dwError = ERROR_MORE_DATA;
    LPDHCP_SUPER_SCOPE_TABLE        pSuperscopeTable = NULL;
    DHCP_SUPER_SCOPE_TABLE_ENTRY *  pSuperscopeTableEntry;  // Pointer to a single entry in array
    CDhcpSuperscope *               pSuperscope = NULL;
    CNodeList                       listSuperscopes;
    CSubnetInfo                     subnetInfo;

    dwError = ::DhcpGetSuperScopeInfoV4((LPWSTR) ((LPCTSTR)m_strServer),
                                        &pSuperscopeTable);

    if (dwError != ERROR_SUCCESS)
    {
        PostError(dwError);
        return;
    }

    Trace2("Server %s - DhcpGetSuperScopeInfoV4 returned %lx.\n", m_strServer, dwError);

    if (pSuperscopeTable == NULL)
    {
        ASSERT(FALSE);
        return; // Just in case
    }

    pSuperscopeTableEntry = pSuperscopeTable->pEntries;
    if (pSuperscopeTableEntry == NULL && pSuperscopeTable->cEntries != 0)
    {
        ASSERT(FALSE);
        return; // Just in case
    }

    for (int iSuperscopeEntry = pSuperscopeTable->cEntries;
         iSuperscopeEntry > 0;
         iSuperscopeEntry--, pSuperscopeTableEntry++)
    {
        if (pSuperscopeTableEntry->SuperScopeName == NULL)
        {
            //
            // The API lists all the scopes, not just scopes that are members of a superscope.
            // You can tell if a scope is a member of a superscope by looking at the SuperScopeName.
            // If its NULL, the scope is not a member of a superscope.
            //

            DWORD dwReturn = m_pSubnetInfoCache->GetInfo(m_strServer,
                                                         pSuperscopeTableEntry->SubnetAddress, subnetInfo);
            if (dwReturn != ERROR_SUCCESS)
            {
                Trace2("Server %s - DhcpGetSubnetInfo returned %lx.\n", m_strServer, dwReturn);
            }
            else
            {
                SPITFSNode spScopeNode;
                CDhcpScope * pDhcpScope = new CDhcpScope(m_spTFSCompData, subnetInfo);
                CreateContainerTFSNode(&spScopeNode,
                                       &GUID_DhcpScopeNodeType,
                                       pDhcpScope,
                                       pDhcpScope,
                                       m_spNodeMgr);

                // Tell the handler to initialize any specific data
                pDhcpScope->InitializeNode(spScopeNode);

                AddToQueue(spScopeNode);
                pDhcpScope->Release();
            } // else

            continue;
        } // if
        else
        {
            //
            // Try to find if the superscope name already exists
            //
            pSuperscope = FindSuperscope(listSuperscopes, pSuperscopeTableEntry->SuperScopeName);
            if (pSuperscope == NULL)
            {
                //
                // Allocate a new superscope object and put it on our internal list
                // so that it we can check it later against other superscopes we may find
                //
                ITFSNode * pSuperscopeNode;
                pSuperscope = new CDhcpSuperscope(m_spTFSCompData, pSuperscopeTableEntry->SuperScopeName);
                CreateContainerTFSNode(&pSuperscopeNode,
                                       &GUID_DhcpSuperscopeNodeType,
                                       pSuperscope,
                                       pSuperscope,
                                       m_spNodeMgr);

                // this gets done when the node is added to the UI on the main thread
                pSuperscope->InitializeNode(pSuperscopeNode);

                listSuperscopes.AddTail(pSuperscopeNode);
                pSuperscope->Release();
            } // if
            else
            {
                // Otherwise keep it
            }

            // now check to see if the scope is enabled.  If it is, then
            // set the superscope state to enabled.
            // our definition of superscope enabled/disabled is if one scope is
            // enabled then the superscope is considered to be enabled.
            DWORD dwReturn = m_pSubnetInfoCache->GetInfo(m_strServer,
                                                         pSuperscopeTableEntry->SubnetAddress, subnetInfo);

            if (dwReturn != ERROR_SUCCESS)
            {
                Trace2("Server %s - m_SubnetInfoCache.GetInfo returned %lx.\n", m_strServer, dwReturn);
            }

            if (subnetInfo.SubnetState == DhcpSubnetEnabled)
            {
                Assert(pSuperscope);
                pSuperscope->SetState(DhcpSubnetEnabled);
            }
        } // else

    } // for

    //
    // Now take all of the superscopes and put them on the queue to be added
    //
    if (listSuperscopes.GetCount() > 0)
    {
        POSITION pos = listSuperscopes.GetHeadPosition();
        SPITFSNode spNode;

        while (pos)
        {
            spNode = listSuperscopes.GetNext(pos);

            // we re-initialize the node so that the state will be updated correctly
            pSuperscope = GETHANDLER(CDhcpSuperscope, spNode);
            pSuperscope->InitializeNode(spNode);
            AddToQueue(spNode);

            spNode.Release();
        }
        listSuperscopes.RemoveAll();
    } // if

    //
    // Free the memory
    //
    ::DhcpRpcFreeMemory(pSuperscopeTable);
}

/*---------------------------------------------------------------------------
        CDhcpServerQueryObj::EnumSubnets()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpServerQueryObj::EnumSubnets()
{
        DWORD                                           dwError = ERROR_MORE_DATA;
        DWORD                                           dwElementsRead = 0, dwElementsTotal = 0;
        LPDHCP_IP_ARRAY                         pdhcpIpArray = NULL;
    CSubnetInfo                 subnetInfo;

        //
        // for this server, enumerate all of it's subnets
        // 
        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumSubnets(((LPWSTR) (LPCTSTR)m_strServer),
                                                                        &m_dhcpResumeHandle,
                                                                        m_dwPreferredMax, 
                                                                        &pdhcpIpArray,
                                                                        &dwElementsRead,
                                                                        &dwElementsTotal);

                if (dwElementsRead && dwElementsTotal && pdhcpIpArray)
                {
                        //
                        // loop through all of the subnets that were returned
                        //
                        for (DWORD i = 0; i < pdhcpIpArray->NumElements; i++)
                        {
                                DWORD   dwReturn;

                dwReturn = m_pSubnetInfoCache->GetInfo(m_strServer, pdhcpIpArray->Elements[i], subnetInfo);

                                //
                                // Create the new scope based on the info we querried
                                //
                                SPITFSNode spNode;
                                CDhcpScope * pDhcpScope = new CDhcpScope(m_spTFSCompData, subnetInfo);
                                CreateContainerTFSNode(&spNode,
                                                                           &GUID_DhcpScopeNodeType,
                                                                           pDhcpScope,
                                                                           pDhcpScope,
                                                                           m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                pDhcpScope->InitializeNode(spNode);
                        
                                AddToQueue(spNode);
                                pDhcpScope->Release();
                        }

                        //
                        // Free up the RPC memory
                        //
                        ::DhcpRpcFreeMemory(pdhcpIpArray);

                        dwElementsRead = 0;
                        dwElementsTotal = 0;
                        pdhcpIpArray = NULL;
                }
        }
}

/*---------------------------------------------------------------------------
        CDhcpServerQueryObj::FindSuperscope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpSuperscope * 
CDhcpServerQueryObj::FindSuperscope
(
        CNodeListBase  & listSuperscopes, 
        LPWSTR                   pSuperScopeName
)
{
        CString                 strSuperscopeName = pSuperScopeName;
        POSITION                pos = listSuperscopes.GetHeadPosition();
        CDhcpSuperscope *pSuperscope = NULL;

        while (pos)
        {
                ITFSNode * pSuperscopeNode;
                
                pSuperscopeNode = listSuperscopes.GetNext(pos);
                
                CDhcpSuperscope * pCurrentSuperscope = GETHANDLER(CDhcpSuperscope, pSuperscopeNode);
                
                if (strSuperscopeName.Compare(pCurrentSuperscope->GetName()) == 0)
                {
                        pSuperscope = pCurrentSuperscope;
                        break;
                }
        }

        return pSuperscope;
}



/*---------------------------------------------------------------------------
        Class CDhcpGlobalOptions implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::CDhcpGlobalOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpGlobalOptions::CDhcpGlobalOptions
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CDhcpGlobalOptions::~CDhcpGlobalOptions()
{
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpGlobalOptions::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strTemp;
        strTemp.LoadString(IDS_GLOBAL_OPTIONS_FOLDER);
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_GLOBAL_OPTIONS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_GLOBAL_OPTIONS][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_GLOBAL_OPTIONS][0]);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpGlobalOptions::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();
    
    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = GetServerObject(pNode)->GetName() + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpGlobalOptions::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_SERVER_OPTION_FOLDER_OPEN;
            else
                        nIndex = ICON_IDX_SERVER_OPTION_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_SERVER_OPTION_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                            nIndex = ICON_IDX_SERVER_OPTION_FOLDER_OPEN_LOST_CONNECTION;
            else
                            nIndex = ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_LOST_CONNECTION;
                        break;

                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpGlobalOptions::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0, fLoadingFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuItem;

        if ( m_nState != loaded )
        {
                fFlags |= MF_GRAYED;
        }

        if ( m_nState == loading)
        {
                fLoadingFlags = MF_GRAYED;
        }
        
        if (type == CCT_SCOPE)
        {
                // these menu items go in the new menu, 
                // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuItem.LoadString(IDS_CREATE_OPTION_GLOBAL);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_CREATE_OPTION_GLOBAL,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpGlobalOptions::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_OPTION_GLOBAL:
                        OnCreateNewOptions(pNode);
                        break;
        
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::HasPropertyPages
                Implementation of ITFSNodeHandler::HasPropertyPages
        NOTE: the root node handler has to over-ride this function to 
        handle the snapin manager property page (wizard) case!!!
        
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpGlobalOptions::HasPropertyPages
(
        ITFSNode *                      pNode,
        LPDATAOBJECT            pDataObject, 
        DATA_OBJECT_TYPES   type, 
        DWORD               dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        HRESULT hr = hrOK;
        
        // we have property pages in the normal case, but don't put the
        // menu up if we are not loaded yet
        if ( m_nState != loaded )
        {
                hr = hrFalse;
        }
        else
        {
                hr = hrOK;
        }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpGlobalOptions::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD                       dwError;
    DWORD                       dwDynDnsFlags;
    HRESULT             hr = hrOK;
        COptionsConfig *    pOptCfg;
        CString             strOptCfgTitle, strOptType;
        SPITFSNode          spServerNode;
        SPIComponentData    spComponentData;
    COptionValueEnum *  pOptionValueEnum;

    //
        // Create the property page
    //
    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spComponentData);

        BEGIN_WAIT_CURSOR;

        strOptType.LoadString(IDS_CONFIGURE_OPTIONS_GLOBAL);
                AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

                pNode->GetParent(&spServerNode);
        pOptionValueEnum = GetServerObject(pNode)->GetOptionValueEnum();

        pOptCfg = new COptionsConfig(pNode, 
                                                                     spServerNode,
                                                                         spComponentData, 
                                                                         m_spTFSCompData,
                                                                         pOptionValueEnum,
                                                                         strOptCfgTitle);
      
        END_WAIT_CURSOR;
            
        if ( pOptCfg == NULL )
        {
            hr = hrFalse;
            return hr;
        }

            //
            // Object gets deleted when the page is destroyed
        //
            Assert(lpProvider != NULL);

        hr = pOptCfg->CreateModelessSheet(lpProvider, handle);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpGlobalOptions::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        COptionsConfig * pOptCfg = reinterpret_cast<COptionsConfig *>(lParam);

        LPARAM changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pOptCfg->OnPropertyChange(TRUE, &changeMask);

        pOptCfg->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpGlobalOptions::OnResultPropertyChange
(
        ITFSComponent * pComponent,
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);
        COptionsConfig * pOptCfg = reinterpret_cast<COptionsConfig *>(param);

        LPARAM changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pOptCfg->OnPropertyChange(TRUE, &changeMask);

        pOptCfg->AcknowledgeNotify();

        if (changeMask)
                spNode->ChangeNode(changeMask);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpGlobalOptions::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpOptionItem *pOpt1 = GETHANDLER(CDhcpOptionItem, spNode1);
        CDhcpOptionItem *pOpt2 = GETHANDLER(CDhcpOptionItem, spNode2);

        switch (nCol)
        {
                case 0:
                {
                        //
            // Name compare - use the option #
                        //
            LONG_PTR uImage1 = spNode1->GetData(TFS_DATA_IMAGEINDEX);
            LONG_PTR uImage2 = spNode2->GetData(TFS_DATA_IMAGEINDEX);

            nCompare = UtilGetOptionPriority((int) uImage1, (int) uImage2);
            if (nCompare == 0)
            {
                // compare the IDs
                DHCP_OPTION_ID  id1 = pOpt1->GetOptionId();
                DHCP_OPTION_ID  id2 = pOpt2->GetOptionId();
                            
                            if (id1 < id2)
                                    nCompare = -1;
                            else
                            if (id1 > id2)
                                    nCompare =  1;
            }
                }
                break;

        case 1:
        {
            // compare the vendor strings
            CString str1, str2;
            str1 = pOpt1->GetVendorDisplay();
            str2 = pOpt2->GetVendorDisplay();

            nCompare = str1.CompareNoCase(str2);
        }
        break;
        case 2:  {
            // compare the printable values
            CString str1, str2;
            str1 = pOpt1->GetString( pComponent, cookieA, nCol );
            str2 = pOpt2->GetString( pComponent, cookieB, nCol );
            
            nCompare = str1.CompareNoCase( str2 );
            break;
        }
        case 3:
        {
            CString str1, str2;
            str1 = pOpt1->GetClassName();
            str2 = pOpt2->GetClassName();

            nCompare = str1.CompareNoCase(str2);
        }
        break;
        }

        return nCompare;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::OnResultSelect
                Update the verbs and the result pane message
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpGlobalOptions::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPITFSNode      spNode;

    CORg(CMTDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg (pComponent->GetSelectedNode(&spNode));

    if (spNode)
        UpdateResultMessage(spNode);

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpGlobalOptions::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spGlobalOpt, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spGlobalOpt);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spGlobalOpt);
        if (spSelectedNode != spGlobalOpt)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int) listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

        CString strServer = GetServerObject(spGlobalOpt)->GetIpAddress();

        DHCP_OPTION_SCOPE_INFO    dhcpOptionScopeInfo;
        dhcpOptionScopeInfo.ScopeType = DhcpGlobalOptions;
        dhcpOptionScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

        //
        // Loop through all items deleting
        //
        BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spOptionNode;
                spOptionNode = listNodesToDelete.RemoveHead();
                
                CDhcpOptionItem * pOptItem = GETHANDLER(CDhcpOptionItem, spOptionNode);

                //
                // Try to remove it from the server
                //
            DWORD dwError;
        
        if (pOptItem->IsVendorOption() ||
            pOptItem->IsClassOption())
        {
            LPCTSTR pClassName = pOptItem->GetClassName();
            if (lstrlen(pClassName) == 0)
                pClassName = NULL;

            dwError = ::DhcpRemoveOptionValueV5((LPTSTR) ((LPCTSTR) strServer),
                                                pOptItem->IsVendorOption() ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                                pOptItem->GetOptionId(),
                                                (LPTSTR) pClassName,
                                                (LPTSTR) pOptItem->GetVendor(),
                                                &dhcpOptionScopeInfo);
        }
        else
        {
            dwError = ::DhcpRemoveOptionValue(strServer, 
                                                                                      pOptItem->GetOptionId(), 
                                                                                      &dhcpOptionScopeInfo);
        }

                if (dwError != 0)
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

                        hr = E_FAIL;
                        continue;
                }

        // 
        // remove from our internal list
        //
        GetServerObject(spGlobalOpt)->GetOptionValueEnum()->Remove(pOptItem->GetOptionId(), pOptItem->GetVendor(), pOptItem->GetClassName());    

        //
                // Remove from UI now
                //
                spGlobalOpt->RemoveChild(spOptionNode);
                spOptionNode.Release();
        }

        END_WAIT_CURSOR;

    UpdateResultMessage(spGlobalOpt);

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::OnResultUpdateView
                Implementation of ITFSResultHandler::OnResultUpdateView
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpGlobalOptions::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
                return S_OK; // no selection for our IComponentData

    if ( hint == DHCPSNAP_UPDATE_OPTIONS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        EnumerateResultPane(pComponent, (MMC_COOKIE) spSelectedNode.p, 0, 0);
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CMTDhcpHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::EnumerateResultPane
                We override this function for the options nodes for one reason.
        Whenever an option class is deleted, then all options defined for
        that class will be removed as well.  Since there are multiple places
        that these options may show up, it's easier to just not show any
        options that don't have a class defined for it.  
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpGlobalOptions::EnumerateResultPane
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    COptionValueEnum *  pEnum;
    CClassInfoArray     ClassInfoArray;
        SPITFSNode          spContainer;
    int                 nImage = ICON_IDX_SERVER_OPTION_LEAF;

    m_spNodeMgr->FindNode(cookie, &spContainer);

        GetServerObject(spContainer)->GetClassInfoArray(ClassInfoArray);
    pEnum = GetServerObject(spContainer)->GetOptionValueEnum();
    pEnum->Reset();

    return OnResultUpdateOptions(pComponent, spContainer, &ClassInfoArray, &pEnum, &nImage, 1);
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpGlobalOptions::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    // call the base class to see if it is handling this
    if (CMTDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions) != S_OK)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
        hr = S_FALSE;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::UpdateResultMessage
        Figures out what message to put in the result pane, if any
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CDhcpGlobalOptions::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = -1;   // default
    int nVisible, nTotal;
    int i;

    CString strTitle, strBody, strTemp;

    if (!m_dwErr)
    {
                pNode->GetChildCount(&nVisible, &nTotal);

        // determine what message to display
        if ( (m_nState == notLoaded) || 
             (m_nState == loading) )
        {
            nMessage = -1;
        }
        else
        if (nTotal == 0)
        {
            nMessage = SERVER_OPTIONS_MESSAGE_NO_OPTIONS;
        }

        // build the strings
        if (nMessage != -1)
        {
            // now build the text strings
            // first entry is the title
            strTitle.LoadString(g_uServerOptionsMessages[nMessage][0]);

            // second entry is the icon
            // third ... n entries are the body strings

            for (i = 2; g_uServerOptionsMessages[nMessage][i] != 0; i++)
            {
                strTemp.LoadString(g_uServerOptionsMessages[nMessage][i]);
                strBody += strTemp;
            }
        }
    }

    // show the message
    if (nMessage == -1)
    {
        ClearMessage(pNode);
    }
    else
    {
        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uServerOptionsMessages[nMessage][1]);
    }
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpGlobalOptions::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        // This is how we get non-node data back from the background thread.
    switch (Type)
    {
        case DHCP_QDATA_OPTION_VALUES:
        {
            HRESULT             hr = hrOK;
                SPIComponentData        spCompData;
                SPIConsole                      spConsole;
            SPIDataObject       spDataObject;
            IDataObject *       pDataObject;
            CDhcpServer *       pServer = GetServerObject(pParentNode);
            COptionValueEnum *  pOptionValueEnum = reinterpret_cast<COptionValueEnum *>(Data);

            pServer->SetOptionValueEnum(pOptionValueEnum);
            
            pOptionValueEnum->RemoveAll();
            delete pOptionValueEnum;

            // now tell the view to update themselves
                m_spNodeMgr->GetComponentData(&spCompData);

                CORg ( spCompData->QueryDataObject((MMC_COOKIE) pParentNode, CCT_SCOPE, &pDataObject) );
            spDataObject = pDataObject;

            CORg ( m_spNodeMgr->GetConsole(&spConsole) );
                CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) pParentNode, DHCPSNAP_UPDATE_OPTIONS) ); 

            break;
        }
    }

Error:
    return;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptions::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpGlobalOptions::OnCreateQuery(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    CDhcpGlobalOptionsQueryObj* pQuery = NULL;

    COM_PROTECT_TRY
    {
        pQuery = new CDhcpGlobalOptionsQueryObj(m_spTFSCompData, m_spNodeMgr);
            
            pQuery->m_strServer = GetServerObject(pNode)->GetIpAddress();
        pQuery->m_dwPreferredMax = 0xFFFFFFFF;
            pQuery->m_dhcpResumeHandle = NULL;
            
        GetServerObject(pNode)->GetVersion(pQuery->m_liDhcpVersion);
    }
    COM_PROTECT_CATCH

    return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpGlobalOptionsQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpGlobalOptionsQueryObj::Execute()
{
    DWORD                   dwErr;
    COptionValueEnum *      pOptionValueEnum = NULL;
    DHCP_OPTION_SCOPE_INFO      dhcpOptionScopeInfo;

    pOptionValueEnum = new COptionValueEnum();
        
    dhcpOptionScopeInfo.ScopeType = DhcpGlobalOptions;
        dhcpOptionScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    pOptionValueEnum->Init(m_strServer, m_liDhcpVersion, dhcpOptionScopeInfo);
    dwErr = pOptionValueEnum->Enum();

    if (dwErr != ERROR_SUCCESS)
    {
        Trace1("CDhcpGlobalOptionsQueryObj::Execute - Enum Failed! %d\n", dwErr);
        m_dwErr = dwErr;
        PostError(dwErr);

        delete pOptionValueEnum;
    }
    else
    {
        pOptionValueEnum->SortById();
        AddToQueue((LPARAM) pOptionValueEnum, DHCP_QDATA_OPTION_VALUES);
    }

    return hrFalse;
}

/*!--------------------------------------------------------------------------
        CDhcpGlobalOptions::OnNotifyExiting
                CMTDhcpHandler overridden functionality
                allows us to know when the background thread is done
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpGlobalOptions::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        spNode.Set(m_spNode); // save this off because OnNotifyExiting will release it

        HRESULT hr = CMTDhcpHandler::OnNotifyExiting(lParam);

    UpdateResultMessage(spNode);

        return hr;
}

/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
        CDhcpGlobalOptionsQueryObj::OnCreateNewOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpGlobalOptions::OnCreateNewOptions
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = hrOK;
    COptionsConfig * pOptCfg = NULL;

    COM_PROTECT_TRY
    {
        if (HasPropSheetsOpen())
            {
                    CPropertyPageHolderBase * pPropSheet;
                    GetOpenPropSheet(0, &pPropSheet);

                    pPropSheet->SetActiveWindow();
            }
            else
            {
                CString             strOptCfgTitle, strOptType;
                SPIComponentData    spComponentData;

            strOptType.LoadString(IDS_CONFIGURE_OPTIONS_GLOBAL);
                AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

            m_spNodeMgr->GetComponentData(&spComponentData);

            hr = DoPropertiesOurselvesSinceMMCSucks(pNode, spComponentData, strOptCfgTitle);
            }
    }
    COM_PROTECT_CATCH

        return hr;
}

/*---------------------------------------------------------------------------
        Class CDhcpBootp implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpBootp::CDhcpBootp
(
        ITFSComponentData* pTFSComponentData
) : CMTDhcpHandler(pTFSComponentData)
{
}

CDhcpBootp::~CDhcpBootp()
{
}

/*!--------------------------------------------------------------------------
        CDhcpBootp::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpBootp::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strDisplayName;

        strDisplayName.LoadString(IDS_BOOTP_TABLE_FOLDER);
        SetDisplayName(strDisplayName);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_BOOTP_TABLE);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_BOOTP_TABLE][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_BOOTP_TABLE][0]);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpBootp::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpBootp::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();
    
    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = GetServerObject(pNode)->GetName() + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpBootp::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpBootp::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                        nIndex = ICON_IDX_BOOTP_TABLE_OPEN;
            else
                        nIndex = ICON_IDX_BOOTP_TABLE_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_BOOTP_TABLE_OPEN_BUSY;
            else
                nIndex = ICON_IDX_BOOTP_TABLE_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                            nIndex = ICON_IDX_BOOTP_TABLE_OPEN_LOST_CONNECTION;
            else
                            nIndex = ICON_IDX_BOOTP_TABLE_CLOSED_LOST_CONNECTION;
                        break;
    
        default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpBootp::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpBootp::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0, fLoadingFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuItem;

        if ( m_nState != loaded )
        {
                fFlags |= MF_GRAYED;
        }

        if ( m_nState == loading)
        {
                fLoadingFlags = MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
                // these menu items go in the new menu, 
                // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuItem.LoadString(IDS_CREATE_NEW_BOOT_IMAGE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_CREATE_NEW_BOOT_IMAGE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpBootp::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpBootp::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_NEW_BOOT_IMAGE:
                        OnCreateNewBootpEntry(pNode);
                        break;

                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpBootp::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpBootp::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpBootpEntry *pDhcpBootp1 = GETHANDLER(CDhcpBootpEntry, spNode1);
        CDhcpBootpEntry *pDhcpBootp2 = GETHANDLER(CDhcpBootpEntry, spNode2);

        CString strNode1;
        CString strNode2;

        switch (nCol)
        {
                case 0:
                {
                        // Boot Image compare
                        strNode1 = pDhcpBootp1->QueryBootImage();
                        strNode2 = pDhcpBootp2->QueryBootImage();
                }
                        break;

                case 1:
                {
                        // File Name compare
                        strNode1 = pDhcpBootp1->QueryFileName();
                        strNode2 = pDhcpBootp2->QueryFileName();
                }
                        break;
                
                case 2:
                {
                        // FileServer compare
                        strNode1 = pDhcpBootp1->QueryFileServer();
                        strNode2 = pDhcpBootp2->QueryFileServer();
                }
                        break;
        }

        nCompare = strNode1.CompareNoCase(strNode2);

        return nCompare;
}

/*---------------------------------------------------------------------------
        CDhcpBootp::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpBootp::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE      cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
    HRESULT hr = hrOK;
    WCHAR * pNewBootpList  = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // translate the cookie into a node pointer
    SPITFSNode spBootp, spSelectedNode;

    m_spNodeMgr->FindNode(cookie, &spBootp);
    pComponent->GetSelectedNode(&spSelectedNode);

    Assert(spSelectedNode == spBootp);
    if (spSelectedNode != spBootp)
        return hr;

    // build the list of selected nodes
    CTFSNodeList listNodesToDelete;
    hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

    //
    // Confirm with the user
    //
    CString strMessage, strTemp;
    int nNodes = (int) listNodesToDelete.GetCount();
    if (nNodes > 1)
    {
        strTemp.Format(_T("%d"), nNodes);
        AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
    }
    else
    {
        strMessage.LoadString(IDS_DELETE_ITEM);
    }

    if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
    {
        return NOERROR;
    }

    BEGIN_WAIT_CURSOR;

    CString strServer = GetServerObject(spBootp)->GetIpAddress();

    // Grab the current list of bootp entries from the server
    DWORD dwError = 0;
    LPDHCP_SERVER_CONFIG_INFO_V4 pServerConfig = NULL;

    dwError = ::DhcpServerGetConfigV4(strServer, &pServerConfig);

    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        return dwError;
    }

    if (pServerConfig->cbBootTableString == 0)
    {
        ::DhcpRpcFreeMemory(pServerConfig);
        return hrOK;
    }

    // allocate enough space to hold the new list.  It should be the same
    // size if not smaller
    pNewBootpList = (WCHAR *) malloc(pServerConfig->cbBootTableString);
    if ( NULL == pNewBootpList ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    WCHAR * pNewBootpListEntry = pNewBootpList;

    ZeroMemory(pNewBootpList, pServerConfig->cbBootTableString);

    // walk the list and copy non-deleted entries to our new list
    BOOL bDelete = FALSE;
    int nItemsRemoved = 0, nNewBootpListLength = 0;
    CDhcpBootpEntry tempBootpEntry(m_spTFSCompData);
    CONST WCHAR * pszwBootpList = pServerConfig->wszBootTableString;
    DWORD dwLength = pServerConfig->cbBootTableString;

    while (*pszwBootpList != '\0')
    {
        bDelete = FALSE;
        WCHAR * pCurEntry = (WCHAR *) pszwBootpList;

        // initialize the temp item with data.  We just do this so we can 
        // compare the nodes that were selected for deletion easily
        pszwBootpList = tempBootpEntry.InitData(IN pszwBootpList, dwLength);
        dwLength = pServerConfig->cbBootTableString -
            (DWORD) ((LPBYTE) pszwBootpList - (LPBYTE) pServerConfig->wszBootTableString);

        // Loop through the list of selected bootp entries
        POSITION pos = listNodesToDelete.GetHeadPosition();
        while (pos)
        {
            // the get next call does not addref the pointer, 
            // so don't use a smart pointer.
            ITFSNode * pBootpEntryNode;
            pBootpEntryNode = listNodesToDelete.GetNext(pos);

            CDhcpBootpEntry * pSelectedBootpEntry = GETHANDLER(CDhcpBootpEntry, pBootpEntryNode);

            if (tempBootpEntry == *pSelectedBootpEntry)
            {
                // don't copy this to our new list, it's being deleted
                // remove from the list
                listNodesToDelete.RemoveNode(pBootpEntryNode);

                // Remove from UI
                spBootp->RemoveChild(pBootpEntryNode);
                pBootpEntryNode->Release();

                bDelete = TRUE;
                nItemsRemoved++;
                break;
            } // if
        } // while pos

        if (!bDelete)
        {
            // copy 
            CopyMemory(pNewBootpListEntry, pCurEntry, wcslen(pCurEntry) * sizeof(WCHAR));
            pNewBootpListEntry += wcslen(pCurEntry) + 1; // 1 for null terminator
        }

    } // while

    pNewBootpListEntry++; // increment 1 spot for the entire list terminator

    // calc size of list in bytes
    nNewBootpListLength = (int) (pNewBootpListEntry - pNewBootpList) * sizeof(WCHAR);

    // if we've removed something from the list, then write the new list to the server
    if (nItemsRemoved)
    {
        DHCP_SERVER_CONFIG_INFO_V4 dhcpServerInfo;

        ::ZeroMemory(&dhcpServerInfo, sizeof(dhcpServerInfo));

        dhcpServerInfo.cbBootTableString = nNewBootpListLength;
        dhcpServerInfo.wszBootTableString = pNewBootpList;

        dwError = ::DhcpServerSetConfigV4(strServer,
                                          Set_BootFileTable,
                                          &dhcpServerInfo);

        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
        }
    } // if 

    if (pServerConfig)
        ::DhcpRpcFreeMemory(pServerConfig);

    Assert (listNodesToDelete.GetCount() == 0);

    END_WAIT_CURSOR;

    free( pNewBootpList );
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpBootp::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpBootp::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*---------------------------------------------------------------------------
        Command Handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpBootp::OnCreateNewBootpEntry
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpBootp::OnCreateNewBootpEntry
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
        CString strServerAddress = GetServerObject(pNode)->GetIpAddress();

        CAddBootpEntry dlgAddBootpEntry(pNode, strServerAddress);

        dlgAddBootpEntry.DoModal();

        return 0;
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpBootp::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpBootp::OnCreateQuery(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    CDhcpBootpQueryObj* pQuery = NULL;

    COM_PROTECT_TRY
    {
        pQuery = new CDhcpBootpQueryObj(m_spTFSCompData, m_spNodeMgr);
        
            pQuery->m_strServer = GetServerObject(pNode)->GetIpAddress();
    }
    COM_PROTECT_CATCH
        
        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpBootpQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpBootpQueryObj::Execute()
{
    HRESULT hr = hrOK;
    DWORD                                                       dwError = 0;
        LPDHCP_SERVER_CONFIG_INFO_V4    pDhcpConfigInfo = NULL;
    CONST WCHAR *                   pszwBootpList = NULL;
        SPITFSNode                      spNode;
    CDhcpBootpEntry *               pBootpEntryNew = NULL;
    DWORD                           dwLength = 0;

        dwError = ::DhcpServerGetConfigV4((LPWSTR) ((LPCTSTR)m_strServer),
                                                                      &pDhcpConfigInfo);

        Trace2("Server %s - DhcpServerGetConfigV4 returned %lx.\n", m_strServer, dwError);

        if (pDhcpConfigInfo)
        {
        COM_PROTECT_TRY
        {
            pszwBootpList = pDhcpConfigInfo->wszBootTableString;
            dwLength = pDhcpConfigInfo->cbBootTableString;

                    if (pszwBootpList == NULL || pDhcpConfigInfo->cbBootTableString == 0)
                    {
                            // Empty list -> nothing to do
                            return hrFalse;
                    }
            
            // Parse the BOOTP list of format "%s,%s,%s","%s,%s,%s",...
                    while (*pszwBootpList != '\0')
                    {
                            pBootpEntryNew = new CDhcpBootpEntry(m_spTFSCompData);
                            CreateLeafTFSNode(&spNode,
                                                              &GUID_DhcpBootpEntryNodeType,
                                                              pBootpEntryNew,
                                                              pBootpEntryNew,
                                                              m_spNodeMgr);

                            // Tell the handler to initialize any specific data
                            pBootpEntryNew->InitializeNode(spNode);
                            pszwBootpList = pBootpEntryNew->InitData(IN pszwBootpList, dwLength);
                dwLength = pDhcpConfigInfo->cbBootTableString - 
                            (DWORD) ((LPBYTE) pszwBootpList - (LPBYTE) pDhcpConfigInfo->wszBootTableString);

                            // now add it to the queue to be posted back to the main thread
                            AddToQueue(spNode);
                            
                pBootpEntryNew->Release();
                spNode.Set(NULL);

                    } // while
        }
        COM_PROTECT_CATCH
                
                ::DhcpRpcFreeMemory(pDhcpConfigInfo);
        }

        if (dwError != ERROR_NO_MORE_ITEMS && 
        dwError != ERROR_SUCCESS)
        {
                m_dwErr = dwError;
                PostError(dwError);
        }

    return hrFalse;
}

/*---------------------------------------------------------------------------
        Class CDhcpSuperscope implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpSuperscope::CDhcpSuperscope
(
        ITFSComponentData * pComponentData,
        LPCWSTR pSuperscopeName
) : CMTDhcpHandler(pComponentData)
{
        m_strName = pSuperscopeName;
    m_SuperscopeState = DhcpSubnetDisabled;
}

CDhcpSuperscope::~CDhcpSuperscope()
{
}

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        int     nIndex;
    CString strDisplayName;

        BuildDisplayName(&strDisplayName, m_strName);
        SetDisplayName(strDisplayName);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);

    pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));

    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_SUPERSCOPE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_SUPERSCOPE][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_SUPERSCOPE][0]);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::DestroyHandler
                We need to free up any resources we are holding
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpSuperscope::DestroyHandler(ITFSNode *pNode)
{
        // cleanup the stats dialog
    WaitForStatisticsWindow(&m_dlgStats);

    return CMTDhcpHandler::DestroyHandler(pNode);
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpSuperscope::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = GetServerObject()->GetName() + m_strName + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpSuperscope::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                    nIndex = (m_SuperscopeState == DhcpSubnetEnabled) ?
                                    ICON_IDX_SCOPE_FOLDER_OPEN : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN;
            else
                    nIndex = (m_SuperscopeState == DhcpSubnetEnabled) ?
                                    ICON_IDX_SCOPE_FOLDER_CLOSED : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED;
                        break;

        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_SCOPE_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY;
            break;

        case unableToLoad:
            if (bOpenImage)
                    nIndex = (m_SuperscopeState == DhcpSubnetEnabled) ?
                                    ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION;
            else
                    nIndex = (m_SuperscopeState == DhcpSubnetEnabled) ?
                                    ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION;
                        break;

                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpSuperscope::OnHaveData
(
        ITFSNode * pParentNode, 
        ITFSNode * pNewNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (pNewNode->IsContainer())
        {
                // assume all the child containers are derived from this class
                //((CDHCPMTContainer*)pNode)->SetServer(GetServer());
        }
        
        if (pNewNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
        {
                CDhcpScope * pScope = GETHANDLER(CDhcpScope, pNewNode);
                pScope->SetServer(m_spServerNode);
        pScope->InitializeNode(pNewNode);

        if (pScope->IsEnabled())
        {
            m_SuperscopeState = DhcpSubnetEnabled;
            m_strState.LoadString(IDS_SCOPE_ACTIVE);
        }

        AddScopeSorted(pParentNode, pNewNode);
        }
        
    // now tell the view to update themselves
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::AddScopeSorted
                Adds a scope node to the UI sorted
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::AddScopeSorted
(
    ITFSNode * pSuperscopeNode,
    ITFSNode * pScopeNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
        ULONG           nNumReturned = 0;
        DHCP_IP_ADDRESS dhcpIpAddressCurrent = 0;
        DHCP_IP_ADDRESS dhcpIpAddressTarget;

    CDhcpScope *   pScope;

    // get our target address
        pScope = GETHANDLER(CDhcpScope, pScopeNode);
        dhcpIpAddressTarget = pScope->GetAddress();

    // get the enumerator for this node
        CORg(pSuperscopeNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        pScope = GETHANDLER(CDhcpScope, spCurrentNode);
                dhcpIpAddressCurrent = pScope->GetAddress();

                if (dhcpIpAddressCurrent > dhcpIpAddressTarget)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next node in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (m_bExpanded)
        {
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
            pScopeNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
        }
        
        CORg(pSuperscopeNode->InsertChild(spPrevNode, pScopeNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pScopeNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }

        CORg(pSuperscopeNode->AddChild(pScopeNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpSuperscope::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0, fLoadingFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuItem;

        if ( m_nState != loaded )
        {
                fFlags |= MF_GRAYED;
        }

        if ( m_nState == loading)
        {
                fLoadingFlags = MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuItem.LoadString(IDS_SUPERSCOPE_SHOW_STATISTICS);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_SUPERSCOPE_SHOW_STATISTICS,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );

            // separator
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );

                    // these menu items go in the new menu, 
                    // only visible from scope pane
                    strMenuItem.LoadString(IDS_CREATE_NEW_SCOPE);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_CREATE_NEW_SCOPE,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        
            // separator
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     0,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     MF_SEPARATOR);
                    ASSERT( SUCCEEDED(hr) );
            
                    // Add Activate/Deactivate depending upon state
                    if (m_SuperscopeState == DhcpSubnetDisabled)
                    {
                            strMenuItem.LoadString(IDS_SUPERSCOPE_ACTIVATE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_SUPERSCOPE_ACTIVATE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }
                    else
                    {
                            strMenuItem.LoadString(IDS_SUPERSCOPE_DEACTIVATE);
                            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                             strMenuItem, 
                                                                             IDS_SUPERSCOPE_DEACTIVATE,
                                                                             CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                             fFlags );
                            ASSERT( SUCCEEDED(hr) );
                    }
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpSuperscope::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_NEW_SCOPE:
                        OnCreateNewScope(pNode);
                        break;

        case IDS_ACTIVATE:
        case IDS_DEACTIVATE:
        case IDS_SUPERSCOPE_ACTIVATE:
                case IDS_SUPERSCOPE_DEACTIVATE:
                        OnActivateSuperscope(pNode);
                        break;

                case IDS_REFRESH:
            // default state for the superscope is disabled.  If 
            // any active scopes are found, the state will be set to active.
            m_SuperscopeState = DhcpSubnetDisabled;
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                case IDS_SUPERSCOPE_SHOW_STATISTICS:
                        OnShowSuperscopeStats(pNode);
                        break;

                case IDS_DELETE:
                        OnDelete(pNode);
                        break;

                default:
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::OnDelete
                The base handler calls this when MMC sends a MMCN_DELETE for a 
                scope pane item.  We just call our delete command handler.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::OnDelete
(
        ITFSNode *      pNode, 
        LPARAM          arg, 
        LPARAM          lParam
)
{
        return OnDelete(pNode);
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpSuperscope::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        //
        // Create the property page
    //
        SPIComponentData spComponentData;
        CSuperscopeProperties * pSuperscopeProp = NULL;
    HRESULT hr = hrOK;
    
    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spComponentData);

            pSuperscopeProp = new CSuperscopeProperties(pNode, spComponentData, m_spTFSCompData, NULL);
            
            // Set superscope specific data in the prop sheet
            pSuperscopeProp->m_pageGeneral.m_strSuperscopeName = GetName();
            pSuperscopeProp->m_pageGeneral.m_uImage = GetImageIndex(FALSE);

            //
            // Object gets deleted when the page is destroyed
            //
            Assert(lpProvider != NULL);

        hr = pSuperscopeProp->CreateModelessSheet(lpProvider, handle);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::GetString
                Returns string information for display in the result pane columns
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpSuperscope::GetString
(
    ITFSNode *  pNode,
    int         nCol
)
{
        switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
            return m_strState;
        }
        
        return NULL;
}


/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CSuperscopeProperties * pSuperscopeProp = 
                reinterpret_cast<CSuperscopeProperties *>(lParam);

        LONG_PTR changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pSuperscopeProp->OnPropertyChange(TRUE, &changeMask);

        pSuperscopeProp->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::OnUpdateToolbarButtons
                We override this function to show/hide the correct
        activate/deactivate buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        UpdateToolbarStates();
    }

    CMTDhcpHandler::OnUpdateToolbarButtons(pNode, pToolbarNotify);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode  spSuperscope, spServer, spSelectedNode;
    DWORD       dwError;
    
    m_spNodeMgr->FindNode(cookie, &spSuperscope);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spSuperscope);
        if (spSelectedNode != spSuperscope)
                return hr;

    spSuperscope->GetParent(&spServer);

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int) listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

    BOOL fRefreshServer = FALSE;

    //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;
        
    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode   spCurNode;
        const GUID * pGuid;

        CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServer);

                spCurNode = listNodesToDelete.RemoveHead();

        BOOL fWantCancel = TRUE;

        pServer->DeleteScope(spCurNode, &fWantCancel);
        
        if (fWantCancel)
            break;  // user canceled out
    }
    
    END_WAIT_CURSOR;

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = hrOK;

    if ( CMTDhcpHandler::OnGetResultViewType( pComponent, cookie,
                                              ppViewType, pViewOptions ) != S_OK ) {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

        // we still want the default MMC result pane view, we just want
        // multiselect, so return S_FALSE
        hr = S_FALSE;
    }
    return hr;
} // CDhcpSuperscope::OnGetResultViewType()

STDMETHODIMP_(int)
CDhcpSuperscope::CompareItems
(
    ITFSComponent *pComponent,
    RDCOMPARE     *prdc
 )
{
    SPITFSNode spNode1, spNode2;

    m_spNodeMgr->FindNode( prdc->prdch1->cookie, &spNode1);
    m_spNodeMgr->FindNode( prdc->prdch2->cookie, &spNode2);
    int nCompare = 0; 

    CString str1 = spNode1->GetString( prdc->nColumn );
    CString str2 = spNode2->GetString( prdc->nColumn );

    nCompare = str1.Compare( str2 );
    return nCompare;

} // CDhcpSuperScope::CompareItems()

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::UpdateToolbarStates
            Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpSuperscope::UpdateToolbarStates()
{
        if (m_SuperscopeState == DhcpSubnetDisabled)
        {
        g_SnapinButtonStates[DHCPSNAP_SUPERSCOPE][TOOLBAR_IDX_ACTIVATE] = ENABLED;
        g_SnapinButtonStates[DHCPSNAP_SUPERSCOPE][TOOLBAR_IDX_DEACTIVATE] = HIDDEN;
    }
    else
    {
        g_SnapinButtonStates[DHCPSNAP_SUPERSCOPE][TOOLBAR_IDX_ACTIVATE] = HIDDEN;
        g_SnapinButtonStates[DHCPSNAP_SUPERSCOPE][TOOLBAR_IDX_DEACTIVATE] = ENABLED;
    }
}

/*---------------------------------------------------------------------------
        Command Handlers
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::OnActivateSuperscope
                handler for the activate superscope menu item
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::OnActivateSuperscope
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = hrOK;
        DWORD err = 0;
        SPITFSNodeEnum spNodeEnum;
        SPITFSNode spCurrentNode;
        ULONG nNumReturned = 0;

        DHCP_SUBNET_STATE NewSubnetState, OldSubnetState;
        NewSubnetState = (m_SuperscopeState == DhcpSubnetDisabled) ? 
                                                        DhcpSubnetEnabled : DhcpSubnetDisabled;

        // get the enumerator for this node
        pNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
                // walk the list of subscopes and activate all of them
                CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);

                OldSubnetState = pScope->GetState();
                if (OldSubnetState != NewSubnetState)
                {
                        pScope->SetState(NewSubnetState);
                        err = pScope->SetInfo();
                        if (err != 0)
                        {
                // set the state back
                pScope->SetState(OldSubnetState);

                if (::DhcpMessageBox(err, MB_OKCANCEL) == IDCANCEL)
                    break;
                        }
                        else
                        {
                                // Need to update the icon for this scope
                int nOpenImage = pScope->GetImageIndex(TRUE);
                int nClosedImage = pScope->GetImageIndex(FALSE);

                                spCurrentNode->SetData(TFS_DATA_IMAGEINDEX, nClosedImage);
                                spCurrentNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
                                
                                VERIFY(SUCCEEDED(spCurrentNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));
                        }
                }

                // get the next scope in the list
                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        // update the superscope state and icon
        m_SuperscopeState = NewSubnetState;
        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));

    // Update toolbar buttons
    UpdateToolbarStates();
    SendUpdateToolbar(pNode, m_bSelected);

    GetServerObject()->TriggerStatsRefresh(m_spServerNode);

        return hr;
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::OnCreateNewScope
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::OnCreateNewScope
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CString strScopeWizTitle;
        SPIComponentData spComponentData;
    CScopeWiz * pScopeWiz = NULL;

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        strScopeWizTitle.LoadString(IDS_SCOPE_WIZ_TITLE);

            m_spNodeMgr->GetComponentData(&spComponentData);
            pScopeWiz = new CScopeWiz(pNode, 
                                                              spComponentData, 
                                                      m_spTFSCompData,
                                                              GetName(),
                                                              strScopeWizTitle);

        pScopeWiz->m_pDefaultOptions = GetServerObject()->GetDefaultOptionsList();

        hr = pScopeWiz->DoModalWizard();
    }
    COM_PROTECT_CATCH

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnDelete()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::OnDelete(ITFSNode * pNode)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

        CString strMessage, strTemp;

        AfxFormatString1(strMessage, IDS_DELETE_SUPERSCOPE, GetName());
        
        if (AfxMessageBox(strMessage, MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
                BOOL    fRefresh = FALSE;
        DWORD   dwError = 0;

        CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spServerNode);
        pServer->DeleteSuperscope(pNode, &fRefresh);

        // tell the server to refresh the view
        if (fRefresh)
            pServer->OnRefresh(m_spServerNode, NULL, 0, 0, 0);
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::OnShowSuperscopeStats()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::OnShowSuperscopeStats
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    // Fill in some information in the stats object.
    // CreateNewStatisticsWindow handles the case if the window is 
    // already visible.
    m_dlgStats.SetNode(pNode);
    m_dlgStats.SetServer(GetServerObject()->GetIpAddress());
    m_dlgStats.SetSuperscopeName(m_strName);

        CreateNewStatisticsWindow(&m_dlgStats,
                                                          ::FindMMCMainWindow(),
                                                          IDD_STATS_NARROW);

    return hr;
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::DoesSuperscopeExist()
                This function checks to see if the given superscope name already
                exists.  Since there is no API call to do this, we get the superscope
                info which lists all of the scopes and their superscope owners.
                We then check each one to see if a superscope already exists.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::DoesSuperscopeExist(LPCWSTR szName)
{
        LPDHCP_SUPER_SCOPE_TABLE pSuperscopeTable = NULL;
        CString strName = szName;

        DWORD dwErr = GetSuperscopeInfo(&pSuperscopeTable);
        if (dwErr != ERROR_SUCCESS)
                return dwErr;

        for (UINT i = 0; i < pSuperscopeTable->cEntries; i++)
        {
                if (pSuperscopeTable->pEntries[i].SuperScopeName)
                {
                        if (strName.Compare(pSuperscopeTable->pEntries[i].SuperScopeName) == 0)
                                return E_FAIL;
                }
        }

        ::DhcpRpcFreeMemory(pSuperscopeTable);

        return S_OK;
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::AddScope()
                Adds a scope to this superscope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::AddScope(DHCP_IP_ADDRESS scopeAddress)
{
        return SetSuperscope(scopeAddress, FALSE);
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::RemoveScope()
                Removes a scope from this superscope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::RemoveScope(DHCP_IP_ADDRESS scopeAddress)
{
        return SetSuperscope(scopeAddress, TRUE);
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::Rename()
                There is no API to rename a superscope.  What needs to be done is to
                delete the superscope and then re-add all of the scopes that were 
                a part of the superscope.  So, we get the superscope info first.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::Rename(ITFSNode * pNode, LPCWSTR szNewName)
{
    SPITFSNode spServerNode;
        CDhcpServer * pServer;
    CDWordArray arrayScopes;
        LPDHCP_SUPER_SCOPE_TABLE pSuperscopeTable = NULL;

    pNode->GetParent(&spServerNode);
    pServer = GETHANDLER(CDhcpServer, spServerNode);

        // initialize the array
        //arrayScopes.SetSize(10);

        // check to see if the new name already exists
        if (FAILED(DoesSuperscopeExist(szNewName)))
                return E_FAIL;

        // Get the info
        DWORD dwErr = GetSuperscopeInfo(&pSuperscopeTable);
        if (dwErr != ERROR_SUCCESS)
                return dwErr;

        // build our array of scopes in this superscope
        for (UINT i = 0; i < pSuperscopeTable->cEntries; i++)
        {
                // if this scope has a superscope and it's the one we're renaming, 
                // then add it to our list.
                if ((pSuperscopeTable->pEntries[i].SuperScopeName != NULL) &&
                        (m_strName.Compare(pSuperscopeTable->pEntries[i].SuperScopeName) == 0))
                {
                        arrayScopes.Add(pSuperscopeTable->pEntries[i].SubnetAddress);
                }
        }

        // free the RPC memory
        ::DhcpRpcFreeMemory(pSuperscopeTable);

        // now we have the info.  Lets delete the old superscope.
        dwErr = pServer->RemoveSuperscope(GetName());

        SetName(szNewName);

        // now we re-add all the scopes
        for (i = 0; i < (UINT) arrayScopes.GetSize(); i++)
        {       
                DHCP_IP_ADDRESS SubnetAddress = arrayScopes[i];
                AddScope(SubnetAddress);
        }

        arrayScopes.RemoveAll();

        // Update the display string
        CString strDisplayName;
        BuildDisplayName(&strDisplayName, GetName());
        SetDisplayName(strDisplayName);

        return S_OK;
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::GetSuperscopeInfo()
                Wrapper for the DhcpGetSuperScopeInfoV4 call
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::GetSuperscopeInfo(LPDHCP_SUPER_SCOPE_TABLE *ppSuperscopeTable)
{
        CDhcpServer * pServer = GetServerObject();
        return ::DhcpGetSuperScopeInfoV4(pServer->GetIpAddress(), ppSuperscopeTable);
}

 /*---------------------------------------------------------------------------
        CDhcpSuperscope::SetSuperscope()
                Wrapper for the DhcpSetSuperScopeV4 call
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpSuperscope::SetSuperscope(DHCP_IP_ADDRESS SubnetAddress, BOOL ChangeExisting)
{
        CDhcpServer * pServer = GetServerObject();
        return ::DhcpSetSuperScopeV4(pServer->GetIpAddress(), SubnetAddress, (LPWSTR) GetName(), ChangeExisting);
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        CDhcpSuperscope::OnNotifyExiting
                CMTDhcpHandler overridden functionality
                allows us to know when the background thread is done
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpSuperscope::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        spNode.Set(m_spNode); // save this off because OnNotifyExiting will release it

        HRESULT hr = CMTHandler::OnNotifyExiting(lParam);

        if (m_nState == loaded)
        {
                // count the number of scopes in this superscope.
                // if there are none, ask the user if they want to delete this node.
                int nVisible, nTotal;
                HRESULT lhr = spNode->GetChildCount(&nVisible, &nTotal);

                if (nTotal == 0)
                {
            // this superscope is empty and will be removed from the UI
            // notify the user and remove
            ::AfxMessageBox(IDS_SUPERSCOPE_EMPTY, MB_OK);

            // remove from UI
                        SPITFSNode spParent;

                        spNode->GetParent(&spParent);
                        spParent->RemoveChild(spNode);
                }
        }

        return hr;
}


 /*---------------------------------------------------------------------------
        CDhcpSuperscope::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpSuperscope::OnCreateQuery(ITFSNode * pNode)
{
        HRESULT hr = hrOK;
    CDhcpSuperscopeQueryObj* pQuery = NULL;

    COM_PROTECT_TRY
    {
        pQuery = new CDhcpSuperscopeQueryObj(m_spTFSCompData, m_spNodeMgr);
            
            pQuery->m_strServer = GetServerObject()->GetIpAddress();
            
            pQuery->m_strSuperscopeName = GetName();
    }
    COM_PROTECT_CATCH
        
        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscopeQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpSuperscopeQueryObj::Execute()
{
        DWORD                                                   dwError = ERROR_MORE_DATA;
        LPDHCP_SUPER_SCOPE_TABLE                pSuperscopeTable = NULL;
        DHCP_SUPER_SCOPE_TABLE_ENTRY *  pSuperscopeTableEntry;  // Pointer to a single entry in array

        dwError = ::DhcpGetSuperScopeInfoV4((LPWSTR) ((LPCTSTR)m_strServer),
                                                                                &pSuperscopeTable);
        
        if (pSuperscopeTable == NULL ||
        dwError != ERROR_SUCCESS)
        {
                //ASSERT(FALSE);
        PostError(dwError);
                return hrFalse; // Just in case
        }

        pSuperscopeTableEntry = pSuperscopeTable->pEntries;
        if (pSuperscopeTableEntry == NULL && pSuperscopeTable->cEntries != 0)
        {
                ASSERT(FALSE);
        PostError(dwError);
                return hrFalse; // Just in case
        }

        for (int iSuperscopeEntry = pSuperscopeTable->cEntries;
                 iSuperscopeEntry > 0;
                 iSuperscopeEntry--, pSuperscopeTableEntry++)
        {
                LPDHCP_SUBNET_INFO      pdhcpSubnetInfo;

                if ((pSuperscopeTableEntry->SuperScopeName != NULL) && 
                        (m_strSuperscopeName.Compare(pSuperscopeTableEntry->SuperScopeName) == 0))
                {
                        //
                        // The API list all the scopes, not just scopes that are members of a superscope.
                        // You can tell if a scope is a member of a superscope by looking at the SuperScopeName.
                        // So, we look to see if the superscope name matches what we are enumerating for...
                        //
                        DWORD dwReturn = ::DhcpGetSubnetInfo((LPWSTR) ((LPCTSTR)m_strServer),
                                                                                                 pSuperscopeTableEntry->SubnetAddress,
                                                                                                 &pdhcpSubnetInfo);
                        //
                        // Create the new scope based on the info we querried
                        //
                        SPITFSNode spNode;
                        CDhcpScope * pDhcpScope = new CDhcpScope(m_spTFSCompData, pdhcpSubnetInfo);
                        CreateContainerTFSNode(&spNode,
                                                                   &GUID_DhcpScopeNodeType,
                                                                   pDhcpScope,
                                                                   pDhcpScope,
                                                                   m_spNodeMgr);

                        // Tell the handler to initialize any specific data
            pDhcpScope->InitializeNode(spNode);

            // Set some information about the scope
            pDhcpScope->SetInSuperscope(TRUE);

            AddToQueue(spNode);

                        pDhcpScope->Release();
                
                        ::DhcpRpcFreeMemory(pdhcpSubnetInfo);
                }
        }
        
        //
        // Free the memory
        //
        ::DhcpRpcFreeMemory(pSuperscopeTable);

        return hrFalse;
}

/*---------------------------------------------------------------------------
        Helper functions
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpSuperscope::BuildDisplayName
(
        CString * pstrDisplayName,
        LPCTSTR   pName
)
{
        if (pstrDisplayName)
        {
                CString strStandard, strName;

                strName = pName;

                strStandard.LoadString(IDS_SUPERSCOPE_FOLDER);
                
                *pstrDisplayName = strStandard + L" " + strName;
        }

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::NotifyScopeStateChange()
                This function gets called when a sub-scope of a superscope is 
        changing state.  We need to update the state of the superscope.
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpSuperscope::NotifyScopeStateChange
(
    ITFSNode *          pNode,
    DHCP_SUBNET_STATE   newScopeState
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (newScopeState == DhcpSubnetEnabled)
    {
        // A subscope is being enabled.  That means the superscope is active.
        if (m_SuperscopeState == DhcpSubnetDisabled)
        {
            m_SuperscopeState = DhcpSubnetEnabled;
            m_strState.LoadString(IDS_SCOPE_ACTIVE);

            pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
            pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
        }

    }
    else
    {
        // a scope is being deactivated.  Walk the list of scopes and make
        // sure at least one is still active.
        DHCP_SUBNET_STATE   dhcpSuperscopeState = DhcpSubnetDisabled;
        SPITFSNodeEnum      spNodeEnum;
        SPITFSNode          spCurrentNode;
        ULONG               nNumReturned = 0;
        int                 nStringId = IDS_SCOPE_INACTIVE;

        pNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
            CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);
            DHCP_SUBNET_STATE scopeState = pScope->GetState();

            if (scopeState == DhcpSubnetEnabled)
            {
                // at least one scope is enabled.  This superscope is
                // therefore enabled.
                dhcpSuperscopeState = DhcpSubnetEnabled;
                nStringId = IDS_SCOPE_ACTIVE;
                break;
            }

                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        // set the superscope state based on what we found
        m_strState.LoadString(nStringId);
        m_SuperscopeState = dhcpSuperscopeState;

        pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
    }

        VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));
}

/*---------------------------------------------------------------------------
        CDhcpSuperscope::UpdateStatistics
        Notification that stats are now available.  Update stats for the 
        node and give all subnodes a chance to update.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpSuperscope::UpdateStatistics
(
    ITFSNode * pNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned;
    HWND            hStatsWnd;

    // Check to see if this node has a stats sheet up.
    hStatsWnd = m_dlgStats.GetSafeHwnd();
    if (hStatsWnd != NULL)
    {
        PostMessage(hStatsWnd, WM_NEW_STATS_AVAILABLE, 0, 0);
    }
    
    // tell the scope nodes to update anything
    // they need to based on the new stats.
    CORg(pNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
        if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
        {
            CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);

            pScope->UpdateStatistics(spCurrentNode);
        }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

Error:
    return hr;
}




/*---------------------------------------------------------------------------
        Class COptionNodeEnum
        Enumerates the options for a given level.  Generates a list of
        nodes.
        Author: EricDav
 ---------------------------------------------------------------------------*/
COptionNodeEnum::COptionNodeEnum
(
    ITFSComponentData * pComponentData,
    ITFSNodeMgr *       pNodeMgr
)
{
    m_spTFSCompData.Set(pComponentData);
    m_spNodeMgr.Set(pNodeMgr);
}

/*---------------------------------------------------------------------------
        COptionNodeEnum::Enum()
                Calls the appropriate enum function depending upon version
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionNodeEnum::Enum
(
    LPCTSTR                  pServer,
    LARGE_INTEGER &          liVersion,
    DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo
)
{
    DWORD dwErr;

    if (liVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        // enumerate standard plus the vendor and class ID based options
        dwErr = EnumOptionsV5(pServer, dhcpOptionScopeInfo);
    }
    else
    {
        // Enumerate the standard options
        dwErr = EnumOptions(pServer, dhcpOptionScopeInfo);
    }

    return dwErr;
}

/*---------------------------------------------------------------------------
        COptionNodeEnum::EnumOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionNodeEnum::EnumOptions
(
    LPCTSTR                  pServer,
    DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo
)
{
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues = NULL;
        DWORD dwOptionsRead = 0, dwOptionsTotal = 0;
        DWORD err = ERROR_SUCCESS;
    HRESULT hr = hrOK;
    DHCP_RESUME_HANDLE dhcpResumeHandle = NULL;

        err = ::DhcpEnumOptionValues((LPWSTR) pServer,
                                                                 &dhcpOptionScopeInfo,
                                                                 &dhcpResumeHandle,
                                                                 0xFFFFFFFF,
                                                                 &pOptionValues,
                                                                 &dwOptionsRead,
                                                                 &dwOptionsTotal);
        
    Trace4("Server %s - DhcpEnumOptionValues returned %lx, read %d, Total %d.\n", pServer, err, dwOptionsRead, dwOptionsTotal);
        
        if (dwOptionsRead && dwOptionsTotal && pOptionValues) 
        {
                for (DWORD i = 0; i < dwOptionsRead; i++)
                {
                        // 
                        // Filter out the "special" option values that we don't want the
                        // user to see.
                        //
                        // CODEWORK: don't filter vendor specifc options... all vendor 
            // specifc options are visible.
            //
                        if (FilterOption(pOptionValues->Values[i].OptionID))
                                continue;
                        
                        //
                        // Create the result pane item for this element
                        //
                        SPITFSNode spNode;
                        CDhcpOptionItem * pOptionItem = NULL;
            
            COM_PROTECT_TRY
            {
                                pOptionItem = new CDhcpOptionItem(m_spTFSCompData, &pOptionValues->Values[i], ICON_IDX_SERVER_OPTION_LEAF);

                            CreateLeafTFSNode(&spNode,
                                                              &GUID_DhcpOptionNodeType,
                                                              pOptionItem,
                                                              pOptionItem,
                                                              m_spNodeMgr);

                            // Tell the handler to initialize any specific data
                            pOptionItem->InitializeNode(spNode);
                        
                // extra addref to keep the node alive while it is on the list
                spNode->AddRef();
                AddTail(spNode);
                            
                pOptionItem->Release();
            }
            COM_PROTECT_CATCH
                }

                ::DhcpRpcFreeMemory(pOptionValues);
        }

        if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

    return err;
}

/*---------------------------------------------------------------------------
        COptionNodeEnum::EnumOptionsV5()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionNodeEnum::EnumOptionsV5
(
    LPCTSTR                  pServer,
    DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo
)
{
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues = NULL;
    LPDHCP_ALL_OPTION_VALUES  pAllOptions = NULL;
    DWORD dwNumOptions, err, i;

    err = ::DhcpGetAllOptionValues((LPWSTR) pServer,
                                   0,
                                                                   &dhcpOptionScopeInfo,
                                                                   &pAllOptions);
        
    Trace2("Server %s - DhcpGetAllOptionValues (Global) returned %lx\n", pServer, err);

    if (err == ERROR_NO_MORE_ITEMS || err == ERROR_SUCCESS)
    {
            if (pAllOptions == NULL)
            {
                    // This happens when stressing the server.  Perhaps when server is OOM.
                    err = ERROR_OUTOFMEMORY;
            return err;
            }

        // get the list of options (vendor and non-vendor) defined for
        // the NULL class (no class)
        for (i = 0; i < pAllOptions->NumElements; i++)
        {
            CreateOptions(pAllOptions->Options[i].OptionsArray, 
                          pAllOptions->Options[i].ClassName,
                          pAllOptions->Options[i].VendorName);
        }
        
        if (pAllOptions)
            ::DhcpRpcFreeMemory(pAllOptions);
        }

    if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

        return err;
}

/*---------------------------------------------------------------------------
        COptionNodeEnum::CreateOptions()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
COptionNodeEnum::CreateOptions
(
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues,
    LPCTSTR                   pClassName,
    LPCTSTR                   pszVendor
)
{
    HRESULT hr = hrOK;
    SPITFSNode spNode;
    CDhcpOptionItem * pOptionItem;
    
    if (pOptionValues == NULL)
        return hr;

    Trace1("COptionNodeEnum::CreateOptions - Creating %d options\n", pOptionValues->NumElements);

    COM_PROTECT_TRY
    {
        for (DWORD i = 0; i < pOptionValues->NumElements; i++)
        {
                // 
                // Filter out the "special" option values that we don't want the
                // user to see.
                //
                // don't filter vendor specifc options... all vendor 
            // specifc options are visible.
            // 
            // also don't filter out class based options
            //
                if (FilterOption(pOptionValues->Values[i].OptionID) &&
                pClassName == NULL &&
                !pszVendor)
                        continue;
                                        
                //
                // Create the result pane item for this element
                //
                pOptionItem = new CDhcpOptionItem(m_spTFSCompData, &pOptionValues->Values[i], ICON_IDX_SERVER_OPTION_LEAF);

                if (pClassName)
                pOptionItem->SetClassName(pClassName);

            if (pszVendor)
                pOptionItem->SetVendor(pszVendor);

            CORg (CreateLeafTFSNode(&spNode,
                                                    &GUID_DhcpOptionNodeType,
                                                        pOptionItem,
                                                        pOptionItem,
                                                        m_spNodeMgr));

                // Tell the handler to initialize any specific data
                pOptionItem->InitializeNode(spNode);
                
            // extra addref to keep the node alive while it is on the list
            spNode->AddRef();
            AddTail(spNode);
                                        
            pOptionItem->Release();
            spNode.Set(NULL);

            COM_PROTECT_ERROR_LABEL;
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

DWORD
CSubnetInfoCache::GetInfo
(
    CString &       strServer, 
    DHCP_IP_ADDRESS ipAddressSubnet, 
    CSubnetInfo &   subnetInfo
)
{
    CSubnetInfo subnetInfoCached;
    DWORD       dwError = 0;
    int         i;
    BOOL        fFound = FALSE;

    // look in the cache for it....
    if (Lookup(ipAddressSubnet, subnetInfoCached))
    {
        // found it
        fFound = TRUE;
    }

    if (!fFound)
    {
        // not in cache go get it
        LPDHCP_SUBNET_INFO pSubnetInfo;
        dwError = ::DhcpGetSubnetInfo(strServer, ipAddressSubnet, &pSubnetInfo);
        if (dwError == ERROR_SUCCESS)
        {
            if (pSubnetInfo == NULL)
            {
                // at present this only happens when the user creates a scope in the multicast range
                // without going through the multicast APIs.
                Trace1("Scope %lx DhcpGetSubnetInfo returned null!\n", ipAddressSubnet);
            }
            else
            {
                subnetInfoCached.Set(pSubnetInfo);
                ::DhcpRpcFreeMemory(pSubnetInfo);

                SetAt(ipAddressSubnet, subnetInfoCached);
            }
        }
    }

    subnetInfo = subnetInfoCached;

    return dwError;
}

DWORD
CMScopeInfoCache::GetInfo
(
    CString &       strServer, 
    LPCTSTR         pszName, 
    CSubnetInfo &   subnetInfo
)
{
    CSubnetInfo subnetInfoCached;
    DWORD       dwError = 0;
    int         i;
    BOOL        fFound = FALSE;

    // look in the cache for it....
    if (Lookup(pszName, subnetInfoCached))
    {
        // found it
        fFound = TRUE;
    }

    if (!fFound)
    {
        // try getting multicast scopes
                LPDHCP_MSCOPE_INFO      pdhcpMScopeInfo = NULL;

                dwError = ::DhcpGetMScopeInfo(((LPWSTR) (LPCTSTR)strServer),
                                                                          (LPWSTR) pszName,
                                                                           &pdhcpMScopeInfo);
        if (dwError == ERROR_SUCCESS)
        {
            if (pdhcpMScopeInfo == NULL)
            {
                // at present this only happens when the user creates a scope in the multicast range
                // without going through the multicast APIs.
                Trace1("MScope %s DhcpGetMScopeInfo returned null!\n", pszName);
            }
            else
            {
                subnetInfoCached.Set(pdhcpMScopeInfo);
                ::DhcpRpcFreeMemory(pdhcpMScopeInfo);

                Add(subnetInfoCached);
            }
        }
    }

    subnetInfo = subnetInfoCached;

    return dwError;
}

DWORD CDhcpServer::GetBindings(LPDHCP_BIND_ELEMENT_ARRAY &BindArray)
{
    // check if call supported.
    if( FALSE == m_fSupportsBindings ) return ERROR_NOT_SUPPORTED;

    // now, attempt to do the retrieval..
    BindArray = 0;
    return ::DhcpGetServerBindingInfo(
        m_strServerAddress, 0, &BindArray
        );
}

DWORD CDhcpServer::SetBindings(LPDHCP_BIND_ELEMENT_ARRAY BindArray)
{
    // check again, if atleaset supported...
    if( FALSE == m_fSupportsBindings ) return ERROR_NOT_SUPPORTED;

    // now attempt to set the bindings information..
    return ::DhcpSetServerBindingInfo(
        m_strServerAddress, 0, BindArray
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscoppp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	sscoppp.cpp
		The superscope properties page
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "sscoppp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CSuperscopeProperties::CSuperscopeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CSuperscopeProperties::~CSuperscopeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CSuperscopePropGeneral property page

IMPLEMENT_DYNCREATE(CSuperscopePropGeneral, CPropertyPageBase)

CSuperscopePropGeneral::CSuperscopePropGeneral() : CPropertyPageBase(CSuperscopePropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CSuperscopePropGeneral)
	m_strSuperscopeName = _T("");
	//}}AFX_DATA_INIT

    m_uImage = 0;
}

CSuperscopePropGeneral::~CSuperscopePropGeneral()
{
}

void CSuperscopePropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopePropGeneral)
	DDX_Text(pDX, IDC_EDIT_SUPERSCOPE_NAME, m_strSuperscopeName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopePropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopePropGeneral)
	ON_EN_CHANGE(IDC_EDIT_SUPERSCOPE_NAME, OnChangeEditSuperscopeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSuperscopePropGeneral message handlers

BOOL CSuperscopePropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	SPITFSNode spSuperscopeNode;
	spSuperscopeNode = GetHolder()->GetNode();

	CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spSuperscopeNode);

	BEGIN_WAIT_CURSOR;
    pSuperscope->Rename(spSuperscopeNode, m_strSuperscopeName);
    END_WAIT_CURSOR;

	*ChangeMask = SCOPE_PANE_CHANGE_ITEM_DATA;
	
	return FALSE;
}

void CSuperscopePropGeneral::OnChangeEditSuperscopeName() 
{
	SetDirty(TRUE);
}

BOOL CSuperscopePropGeneral::OnApply() 
{
	UpdateData();
	
	return CPropertyPageBase::OnApply();
}

BOOL CSuperscopePropGeneral::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

    // Limit the name and comment fields to 255 chars
    CEdit *pEditName = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SUPERSCOPE_NAME ));
    if ( 0 != pEditName ) {
        pEditName->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }
    
    SetDirty(FALSE);
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscoppp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	sscoppp.h
		The superscope properties page
		
    FILE HISTORY:
        
*/

#if !defined(AFX_SSCOPPP_H__A1A51389_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_SSCOPPP_H__A1A51389_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSuperscopePropGeneral dialog

class CSuperscopePropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopePropGeneral)

// Construction
public:
	CSuperscopePropGeneral();
	~CSuperscopePropGeneral();

// Dialog Data
	//{{AFX_DATA(CSuperscopePropGeneral)
	enum { IDD = IDP_SUPERSCOPE_GENERAL };
	CString	m_strSuperscopeName;
	//}}AFX_DATA

    UINT    m_uImage;

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CSuperscopePropGeneral::IDD); }
    
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopePropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopePropGeneral)
	afx_msg void OnChangeEditSuperscopeName();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CSuperscopeProperties : public CPropertyPageHolderBase
{
	friend class CSuperscopePropGeneral;

public:
	CSuperscopeProperties(ITFSNode *		  pNode,
						  IComponentData *	  pComponentData,
						  ITFSComponentData * pTFSCompData,
						  LPCTSTR			  pszSheetName);
	virtual ~CSuperscopeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

public:
	CSuperscopePropGeneral		m_pageGeneral;

protected:
	SPITFSComponentData			m_spTFSCompData;
};


#endif // !defined(AFX_SSCOPPP_H__A1A51389_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\server.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        server.h
                This file contains the prototypes for a DHCP Server
                object and the Bootp and Global Options objects
                contained within it.  The other object that a can be
                within a DHCP server is a superscope, which is defined is
                in cdhcpss.cpp and cdhcpss.h.
                
    FILE HISTORY:
        
*/

#ifndef _SERVER_H
#define _SERVER_H

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#ifndef _SERVSTAT_H
#include "servstat.h"   // Server statistics
#endif

#ifndef _SSCPSTAT_H
#include "sscpstat.h"   // Superscope statistics
#endif

#ifndef _CLASSMOD_H
#include "classmod.h"    // Class Stuff
#endif

#define SERVER_OPTION_AUTO_REFRESH      0x00000001
#define SERVER_OPTION_AUDIT_LOGGING     0x00000002
#define SERVER_OPTION_SHOW_BOOTP        0x00000004
#define SERVER_OPTION_EXTENSION         0x00000008 // this server was added as an extension
#define SERVER_OPTION_SHOW_ROGUE        0x00000010

#define AUTO_REFRESH_HOURS_MAX              23
#define AUTO_REFRESH_MINUTES_MAX            59
#define AUTO_REFRESH_SECONDS_MAX            59

#define DHCP_QDATA_VERSION                          0x00000001
#define DHCP_QDATA_SERVER_INFO              0x00000002
#define DHCP_QDATA_STATS                0x00000003
#define DHCP_QDATA_CLASS_INFO           0x00000004
#define DHCP_QDATA_MCAST_STATS          0x00000005
#define DHCP_QDATA_OPTION_VALUES        0x00000006
#define DHCP_QDATA_ROGUE_INFO           0x00000007
#define DHCP_QDATA_SERVER_ID            0x00000008
#define DHCP_QDATA_SUBNET_INFO_CACHE    0x00000009

typedef struct DhcpRogueInfo_tag
{
    BOOL    fIsRogue;
    BOOL    fIsInNt5Domain;
}
DHCP_ROGUE_INFO, * LPDHCP_ROGUE_INFO;

typedef struct DhcpServerInfo_tag
{
        BOOL    fAuditLog;
        DWORD   dwPingRetries;
    CString strDatabasePath;
    CString strBackupPath;

    // audit logging stuff
    CString strAuditLogDir;
    DWORD   dwDiskCheckInterval;
    DWORD   dwMaxLogFilesSize;
    DWORD   dwMinSpaceOnDisk;
    
        // Does it support DynamicBOOTP?
        BOOL    fSupportsDynBootp;

        // Does it support Bindings?
        BOOL    fSupportsBindings;
}
DHCP_SERVER_CONFIG, * LPDHCP_SERVER_CONFIG;

typedef struct DhcpServerId_tag
{
        CString                         strIp;
        CString                         strName;
}
DHCP_SERVER_ID, * LPDHCP_SERVER_ID;

class CDhcpGlobalOptions;
class CSubnetInfoCache;

/*---------------------------------------------------------------------------
        Class:  CDhcpServer
 ---------------------------------------------------------------------------*/
class CDhcpServer : public CMTDhcpHandler
{
public:
    CDhcpServer(ITFSComponentData* pTFSComponentData, LPCWSTR pServerName = NULL);
        ~CDhcpServer();

// Interface
public:
        // base handler functionality we override
        OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
        OVERRIDE_NodeHandler_OnAddMenuItems();
        OVERRIDE_NodeHandler_OnCommand();
        OVERRIDE_NodeHandler_GetString();
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    OVERRIDE_NodeHandler_DestroyHandler();

        // Choose which messages we want to handle
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

    // Result handler functionality 
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_CompareItemsEx();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
        // CMTDhcpHandler functionality
        virtual HRESULT  InitializeNode(ITFSNode * pNode);
        virtual int      GetImageIndex(BOOL bOpenImage);
        ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void     OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
        virtual void     OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);
    virtual DWORD    UpdateStatistics(ITFSNode * pNode);
    ITFSQueryObject* OnCreateStatsQuery(ITFSNode *pNode);
    virtual void     UpdateToolbar(IToolbar * pToolbar, LONG_PTR dwNodeType, BOOL bSelect);
    
    void     UpdateConsoleVerbs(ITFSComponent* pComponent, IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);
        
    STDMETHOD(OnNotifyExiting)(LPARAM);

    HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

public:
        // implementation specific     
    HRESULT RestartService(ITFSNode * pNode);

    BOOL    FEnableCreateSuperscope(ITFSNode * pNode);
    void    UpdateToolbarStates(ITFSNode * pNode);
    void    SetExtensionName();
    HRESULT BuildDisplayName(CString * pstrDisplayName);

    LPCWSTR     GetIpAddress();
        void    GetIpAddress(DHCP_IP_ADDRESS *pdhcpIpAddress);

    LPCTSTR GetName() { return m_strDnsName; }
    void    SetName(LPCTSTR pName) { m_strDnsName = pName; }

    BOOL    GetDefaultOptions();
        CDhcpOption * FindOption(DHCP_OPTION_ID dhcpOptionId, LPCTSTR pszVendor);

        void    SetVersion(LARGE_INTEGER & liVersion)
                        { m_liDhcpVersion.QuadPart = liVersion.QuadPart; }
        void    GetVersion(LARGE_INTEGER & liVersion) 
                        { liVersion.QuadPart = m_liDhcpVersion.QuadPart; } 

        DWORD   CreateScope(DHCP_IP_ADDRESS dhcpSubnetAddress,
                                            DHCP_IP_ADDRESS dhcpSubnetMask,
                                            LPCTSTR                 pName,
                                            LPCTSTR             pComment);
        
        DWORD   CreateMScope(LPDHCP_MSCOPE_INFO pMScopeInfo);

    DWORD   DeleteScope(ITFSNode * pScopeNode, BOOL * pfWantCancel = NULL);
    DWORD   DeleteSubnet(DWORD dwScopeId, BOOL bForce = FALSE);

    DWORD   DeleteSuperscope(ITFSNode * pNode, BOOL * pfRefresh = NULL);
    DWORD   RemoveSuperscope(LPCTSTR pszName);

    DWORD   DeleteMScope(ITFSNode * pScopeNode, BOOL * pfWantCancel = NULL);
    DWORD   DeleteMSubnet(LPCTSTR pszName, BOOL bForce = FALSE);

    DWORD   SetConfigInfo(BOOL bAuditLogging, DWORD dwPingRetries, LPCTSTR pszDatabasePath = NULL, LPCTSTR pszBackupPath = NULL);
        DWORD   SetConfigInfo(DWORD dwSetFlags, LPDHCP_SERVER_CONFIG_INFO pServerConfigInfo);
        DWORD   SetConfigInfo(DWORD dwSetFlags, LPDHCP_SERVER_CONFIG_INFO_V4 pServerConfigInfo);

        DWORD   SetAutoRefresh(ITFSNode * pNode, BOOL bAutoRefreshOn, DWORD dwRefreshInterval);
    BOOL    IsAutoRefreshEnabled() { return m_dwServerOptions & SERVER_OPTION_AUTO_REFRESH; }
    void    GetAutoRefresh(BOOL * pbAutoRefreshOn, LPDWORD pdwRefreshInterval)
        { 
                if (pbAutoRefreshOn) *pbAutoRefreshOn = m_dwServerOptions & SERVER_OPTION_AUTO_REFRESH;
                if (pdwRefreshInterval) *pdwRefreshInterval = m_dwRefreshInterval;
        }

        // default option functions
        LONG    CreateOption(CDhcpOption * pdhcType);
        LONG    DeleteOption(DHCP_OPTION_ID dhcid, LPCTSTR pszVendor);
        LONG    UpdateOptionList(COptionList * poblValues, COptionList * poblDefunct, CWnd *pwndMsgParent);
        void    DisplayUpdateErrors(COptionList * poblValues, COptionList * poblDefunct, CWnd *pwndMsgParent);

        // Functions to get and set the DNS reg option
        DWORD   GetDnsRegistration(LPDWORD pDnsRegOption);
        DWORD   SetDnsRegistration(DWORD DnsRegOption);
        
        LONG    ScanDatabase(DWORD FixFlag, LPDHCP_SCAN_LIST *ScanList, DHCP_IP_ADDRESS dhcpSubnetAddress);
        LONG    ScanDatabase(DWORD FixFlag, LPDHCP_SCAN_LIST *ScanList, LPWSTR pMScopeName);

    CDhcpDefaultOptionsOnServer * GetDefaultOptionsList() { return m_pDefaultOptionsOnServer; }
        CDhcpGlobalOptions * GetGlobalOptionsContainer();

        // These funtions allow initialization of cached values in the server object.
        // use SetConfigInfo to actually set them on the server
        BOOL    SetAuditLogging(BOOL bNewAuditLogging) 
    { 
        BOOL bOld = m_dwServerOptions & SERVER_OPTION_AUDIT_LOGGING; 
        m_dwServerOptions = bNewAuditLogging ? m_dwServerOptions | SERVER_OPTION_AUDIT_LOGGING :
                                               m_dwServerOptions & ~SERVER_OPTION_AUDIT_LOGGING; 
        return bOld; 
    }
    BOOL    GetAuditLogging() { return m_dwServerOptions & SERVER_OPTION_AUDIT_LOGGING; }
        DWORD   SetPingRetries(DWORD dwNewCount) { DWORD dwOld = m_dwPingRetries; m_dwPingRetries = dwNewCount; return dwOld; }
    DWORD   GetPingRetries() { return m_dwPingRetries; }

    void    SetAuditLogPath(LPCTSTR pszPath) { m_strAuditLogPath = pszPath; }

    // determine if the server has superscopes
    BOOL    HasSuperscopes(ITFSNode * pNode);

    // statistics information
    LPDHCP_MIB_INFO SetMibInfo(LPDHCP_MIB_INFO pMibInfo);
    LPDHCP_MIB_INFO DuplicateMibInfo();
    void            FreeDupMibInfo(LPDHCP_MIB_INFO pDupMibInfo);

    LPDHCP_MCAST_MIB_INFO SetMCastMibInfo(LPDHCP_MCAST_MIB_INFO pMibInfo);
    LPDHCP_MCAST_MIB_INFO DuplicateMCastMibInfo();
    void                  FreeDupMCastMibInfo(LPDHCP_MCAST_MIB_INFO pDupMibInfo);

    // adding child nodes sorted
    HRESULT AddScopeSorted(ITFSNode * pServerNode, ITFSNode * pScopeNode);
    HRESULT AddSuperscopeSorted(ITFSNode * pServerNode, ITFSNode * pScopeNode);
    HRESULT AddMScopeSorted(ITFSNode * pServerNode, ITFSNode * pScopeNode);
    HRESULT GetBootpPosition(ITFSNode * pServerNode, LONG_PTR * puRelativeFlag, LONG_PTR * puRelativeID);

    // hide/show/query bootp folders
    BOOL    IsBootpVisible() { return m_dwServerOptions & SERVER_OPTION_SHOW_BOOTP; }

    HRESULT ShowNode(ITFSNode * pServerNode, UINT uNodeType, BOOL bVisible);

    // access to the server options for save/restore
    DWORD   GetServerOptions() { return m_dwServerOptions; }
    void    SetServerOptions(DWORD dwServerOptions) { m_dwServerOptions = dwServerOptions; }
    
    HRESULT TriggerStatsRefresh(ITFSNode * pNode);

    void DisplayRogueWarning();

    // multicast scope stuff
    BOOL    DoesMScopeExist(ITFSNode * pServerNode, DWORD dwScopeId);

        // Dynamic Bootp support
        BOOL    FSupportsDynBootp() { return m_fSupportsDynBootp; }

        // Bindings support
        BOOL    FSupportsBindings() { return m_fSupportsBindings; }
    
        // Access to the classInfoarray
    void SetClassInfoArray(CClassInfoArray * pClassInfoArray)
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        m_ClassInfoArray.RemoveAll();
        m_ClassInfoArray.Copy(*pClassInfoArray);
    }

    void GetClassInfoArray(CClassInfoArray & ClassInfoArray)
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        ClassInfoArray.Copy(m_ClassInfoArray);
    }

    CClassInfoArray * GetClassInfoArray()
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        return &m_ClassInfoArray;
    }

    BOOL RemoveClass(LPCTSTR pClassName)
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        return m_ClassInfoArray.RemoveClass(pClassName);
    }

    void AddClass(LPCTSTR pName, LPCTSTR pComment, CByteArray & baData)
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        CClassInfo ClassInfo;

        ClassInfo.strName = pName;
        ClassInfo.strComment = pComment;
        ClassInfo.baData.Copy(baData);

        m_ClassInfoArray.Add(ClassInfo);
    }

    void SetOptionValueEnum(COptionValueEnum * pEnum)
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        m_ServerOptionValues.DeleteAll();
        m_ServerOptionValues.Copy(pEnum);
    }

    COptionValueEnum * GetOptionValueEnum()
    {
        CSingleLock sl(&m_csMibInfo);
        sl.Lock();

        return &m_ServerOptionValues;
    }

// Implementation
private:
        // Command handlers
        HRESULT OnDefineUserClasses(ITFSNode * pNode);
        HRESULT OnDefineVendorClasses(ITFSNode * pNode);
        HRESULT OnCreateNewSuperscope(ITFSNode * pNode);
        HRESULT OnCreateNewScope(ITFSNode * pNode);
        HRESULT OnCreateNewMScope(ITFSNode * pNode);
        HRESULT OnShowServerStats(ITFSNode * pNode);
        HRESULT OnSetDefaultOptions(ITFSNode * pNode);
        HRESULT OnReconcileAll(ITFSNode * pNode);
        HRESULT OnServerAuthorize(ITFSNode * pNode);
        HRESULT OnServerDeauthorize(ITFSNode * pNode);
        HRESULT OnDelete(ITFSNode * pNode);
    HRESULT OnControlService(ITFSNode * pNode, BOOL fStart);
    HRESULT OnPauseResumeService(ITFSNode * pNode, BOOL fPause);
    HRESULT OnServerBackup(ITFSNode * pNode);
    HRESULT OnServerRestore(ITFSNode * pNode);

// Attributes
public:
        DWORD SetBindings(LPDHCP_BIND_ELEMENT_ARRAY BindArray);
        DWORD GetBindings(LPDHCP_BIND_ELEMENT_ARRAY &BindArray);
    BOOL                m_bStatsOnly;
    CSubnetInfoCache *  m_pSubnetInfoCache;

protected:
    void    UpdateResultMessage(ITFSNode * pNode);
    
    // we override this because we handle the error messages ourselves in UpdateResultMessage
    // by not returning anything the base class won't put up a result pane message
    void    GetErrorMessages(CString & strTitle, CString & strBody, IconIdentifier * icon) {};

private:
        BOOL                            m_bNetbios;                         //  Name is a NetBIOS name

    DHCP_IP_ADDRESS             m_dhcpServerAddress;    //  Standard 32-bit value (eg: 0x7f000001)
        
    CString                             m_strServerAddress;
        CString             m_strDnsName;
    CString             m_strState;             // rogue or not
    LARGE_INTEGER               m_liDhcpVersion;
        
    DWORD               m_dwServerOptions;      // Any of the SERVER_OPTIONS
    DWORD                               m_dwRefreshInterval;
        DWORD                           m_dwPingRetries;
    CString             m_strAuditLogPath;
    CString             m_strDatabasePath;
    CString             m_strBackupPath;

        BOOL                            m_fSupportsDynBootp;
        BOOL                            m_fSupportsBindings;

    int                 m_StatsTimerId;

    LPDHCP_MIB_INFO       m_pMibInfo;           // for statistics
    LPDHCP_MCAST_MIB_INFO m_pMCastMibInfo;

    DHCP_ROGUE_INFO     m_RogueInfo;

    CCriticalSection    m_csMibInfo;

        CDhcpDefaultOptionsOnServer     * m_pDefaultOptionsOnServer;

    CServerStats        m_dlgStats;
    CClassInfoArray     m_ClassInfoArray;
    COptionValueEnum    m_ServerOptionValues;
};


/*---------------------------------------------------------------------------
        Class:  CDhcpGlobalOptions
 ---------------------------------------------------------------------------*/
class CDhcpGlobalOptions : public CMTDhcpHandler
{
public:
    CDhcpGlobalOptions(ITFSComponentData * pComponentData);
    ~CDhcpGlobalOptions();

// Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString()
    { return (nCol == 0) ? GetDisplayName() : NULL; }

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

    virtual HRESULT EnumerateResultPane(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
    // CMTDhcpHandler functionality
    virtual HRESULT InitializeNode(ITFSNode * pNode);
    virtual int GetImageIndex(BOOL bOpenImage);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    STDMETHOD(OnNotifyExiting)(LPARAM);

    CDhcpServer* GetServerObject(ITFSNode * pNode)
    { 
        SPITFSNode spServerNode;
        pNode->GetParent(&spServerNode);
        return GETHANDLER(CDhcpServer, spServerNode);
    }

private:
    // command handlers
    HRESULT OnCreateNewOptions(ITFSNode * pNode);

// Attributes
private:
    void    UpdateResultMessage(ITFSNode * pNode);

};


/*---------------------------------------------------------------------------
        Class:  CDhcpBootp
 ---------------------------------------------------------------------------*/
class CDhcpBootp : public CMTDhcpHandler
{
public:
    CDhcpBootp(ITFSComponentData * pComponentData);
        ~CDhcpBootp();

// Interface
public:
        // base handler functionality we override
        OVERRIDE_NodeHandler_OnAddMenuItems();
        OVERRIDE_NodeHandler_OnCommand();
        OVERRIDE_NodeHandler_GetString()
                        { return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

        // Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
        // CMTDhcpHandler functionality
        virtual HRESULT InitializeNode(ITFSNode * pNode);
        virtual int GetImageIndex(BOOL bOpenImage);
        ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

        CDhcpServer* GetServerObject(ITFSNode * pNode)
        { 
                SPITFSNode spServerNode;
                pNode->GetParent(&spServerNode);
                return GETHANDLER(CDhcpServer, spServerNode);
        }

private:
        // command handlers
        DWORD OnCreateNewBootpEntry(ITFSNode *          pNode);

// Implementation
private:

// Attributes
private:
};


/*---------------------------------------------------------------------------
        Class:  CDhcpSuperscope
 ---------------------------------------------------------------------------*/
class CDhcpSuperscope : public CMTDhcpHandler
{
public:
    CDhcpSuperscope(ITFSComponentData * pComponentData, LPCWSTR pSuperscopeName = NULL);
        ~CDhcpSuperscope();

public:
        // base handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages() { return hrOK; }
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();

    OVERRIDE_NodeHandler_DestroyHandler();

    // Choose which messages we want to handle
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

        // Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_CompareItemsEx();

// Implementation
private:
        // Command handlers
        HRESULT OnActivateSuperscope(ITFSNode * pNode);
        HRESULT OnCreateNewScope(ITFSNode * pNode);
        HRESULT OnDelete(ITFSNode * pNode);
        HRESULT OnShowSuperscopeStats(ITFSNode * pNode);

public:
        // public functions for superscope manipulation
        LPCWSTR GetName() { return m_strName; };
        void    SetName(LPCWSTR pName) { m_strName = pName; }
        
        HRESULT DoesSuperscopeExist(LPCWSTR szName);
        HRESULT AddScope(DHCP_IP_ADDRESS scopeAddress);
        HRESULT RemoveScope(DHCP_IP_ADDRESS scopeAddress);
        HRESULT Rename(ITFSNode * pNode, LPCWSTR szNewName);
        HRESULT GetSuperscopeInfo(LPDHCP_SUPER_SCOPE_TABLE *pSuperscopeTable);
        HRESULT SetSuperscope(DHCP_IP_ADDRESS SubnetAddress, BOOL ChangeExisting);

public:
        // helpers
        void    SetServer(ITFSNode * pServerNode) { m_spServerNode.Set(pServerNode); }
        HRESULT BuildDisplayName(CString * pstrDisplayName, LPCTSTR     pName);
    void    UpdateToolbarStates();
    void    SetState(DHCP_SUBNET_STATE dhcpState) { m_SuperscopeState = dhcpState; }
    void    NotifyScopeStateChange(ITFSNode * pNode, DHCP_SUBNET_STATE newScopeState);
    
    // adding child nodes sorted
    HRESULT AddScopeSorted(ITFSNode * pServerNode, ITFSNode * pScopeNode);

public:
        // CMTDhcpHandler functionality
        virtual HRESULT InitializeNode(ITFSNode * pNode);
        virtual void    OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
        virtual int             GetImageIndex(BOOL bOpenImage);
    virtual DWORD   UpdateStatistics(ITFSNode * pNode);
        ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

        STDMETHOD(OnNotifyExiting)(LPARAM lParam);

        CDhcpServer* GetServerObject()
        { 
                return GETHANDLER(CDhcpServer, m_spServerNode);
        }

    HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

// Implementation
private:

// Attributes
private:
        CString                         m_strName;
    CString             m_strState;
    DHCP_SUBNET_STATE   m_SuperscopeState;
        SPITFSNode                      m_spServerNode;
    CSuperscopeStats    m_dlgStats;
};


/*---------------------------------------------------------------------------
        Class:  CHostInfo
 ---------------------------------------------------------------------------*/
class CHostInfo
{
public:
    CHostInfo()
    {
        IpAddress = 0;
    }

    CHostInfo(LPDHCP_HOST_INFO pDhcpHostInfo)
    {
        Set(pDhcpHostInfo);
    }

    CHostInfo(CHostInfo & hostInfo)
    {
        *this = hostInfo;
    }

    CHostInfo & operator = (const CHostInfo & hostInfo)
    {
        if (this != &hostInfo)
        {
            IpAddress = hostInfo.IpAddress;
            NetBiosName = hostInfo.NetBiosName;
            HostName = hostInfo.HostName;
        }
        
        return *this;
    }

    void Set(LPDHCP_HOST_INFO pDhcpHostInfo)
    {
        IpAddress = pDhcpHostInfo->IpAddress;
        NetBiosName = pDhcpHostInfo->NetBiosName;
        HostName = pDhcpHostInfo->HostName;
    }

public:
    DHCP_IP_ADDRESS     IpAddress;      // minimum information always available
    CString             NetBiosName;             // optional information
    CString             HostName;                // optional information
};

/*---------------------------------------------------------------------------
        Class:  CSubnetInfo
 ---------------------------------------------------------------------------*/
class CSubnetInfo
{
public:
    CSubnetInfo()
    {
        SubnetAddress = 0;
        SubnetMask = 0;
        SubnetState = DhcpSubnetDisabled;

        // multicast specific fields
        MScopeAddressPolicy = 0;
        MScopeFlags = 0;
        TTL = 0;
        ExpiryTime.dwLowDateTime = 0;
        ExpiryTime.dwHighDateTime = 0;
    }

    CSubnetInfo(LPDHCP_SUBNET_INFO pDhcpSubnetInfo)
    {
        Set(pDhcpSubnetInfo);
    }

    CSubnetInfo(CSubnetInfo & subnetInfo)
    {
        *this = subnetInfo;
    }

    CSubnetInfo & operator = (const CSubnetInfo & subnetInfo)
    {
        if (this != &subnetInfo)
        {
            SubnetAddress = subnetInfo.SubnetAddress;
            SubnetMask = subnetInfo.SubnetMask;
            SubnetName = subnetInfo.SubnetName;
            SubnetComment = subnetInfo.SubnetComment;
            PrimaryHost = subnetInfo.PrimaryHost;
            SubnetState = subnetInfo.SubnetState;

            MScopeAddressPolicy = subnetInfo.MScopeAddressPolicy;
            MScopeFlags = subnetInfo.MScopeFlags;
            TTL = subnetInfo.TTL;
            ExpiryTime = subnetInfo.ExpiryTime;
            LangTag = subnetInfo.LangTag;
        }

        return *this;
    }

    void Set(LPDHCP_SUBNET_INFO pDhcpSubnetInfo)
    {
        SubnetAddress = pDhcpSubnetInfo->SubnetAddress;
        SubnetMask = pDhcpSubnetInfo->SubnetMask;
        SubnetName = pDhcpSubnetInfo->SubnetName;
        SubnetComment = pDhcpSubnetInfo->SubnetComment;
        PrimaryHost.Set(&pDhcpSubnetInfo->PrimaryHost);
        SubnetState = pDhcpSubnetInfo->SubnetState;
    
        MScopeAddressPolicy = 0;
        MScopeFlags = 0;
        TTL = 0;
        ExpiryTime.dwLowDateTime = 0;
        ExpiryTime.dwHighDateTime = 0;
    }

    void Set(LPDHCP_MSCOPE_INFO pMScopeInfo)
    {
        SubnetName = pMScopeInfo->MScopeName;
        SubnetComment = pMScopeInfo->MScopeComment;
        SubnetAddress = pMScopeInfo->MScopeId;
        MScopeAddressPolicy = pMScopeInfo->MScopeAddressPolicy;
        PrimaryHost.Set(&pMScopeInfo->PrimaryHost);
        SubnetState = pMScopeInfo->MScopeState;
        MScopeFlags = pMScopeInfo->MScopeFlags;
        TTL = pMScopeInfo->TTL;
        ExpiryTime = pMScopeInfo->ExpiryTime;
        LangTag = pMScopeInfo->LangTag;

        SubnetMask = 0;
    }

public:
    // common fields
    DHCP_IP_ADDRESS     SubnetAddress;
    DHCP_IP_MASK        SubnetMask;
    CString             SubnetName;
    CString             SubnetComment;
    CHostInfo           PrimaryHost;
    DHCP_SUBNET_STATE   SubnetState;

    // multicast specific fields
    DWORD               MScopeAddressPolicy;
    DWORD               MScopeFlags;
    BYTE                TTL;
    DATE_TIME           ExpiryTime;
    CString             LangTag;
};

typedef CArray<CSubnetInfo, CSubnetInfo&> CSubnetInfoArrayBase;
typedef CMap<DHCP_IP_ADDRESS, DHCP_IP_ADDRESS, CSubnetInfo, CSubnetInfo &> CSubnetInfoCacheBase;

 /*---------------------------------------------------------------------------
        Class:  CSubnetInfoCache
 ---------------------------------------------------------------------------*/
class CSubnetInfoCache : public CSubnetInfoCacheBase
{
public:
    DWORD GetInfo(CString & strServer, DHCP_IP_ADDRESS ipAddress, CSubnetInfo & subnetInfo);
};

class CMScopeInfoCache : public CSubnetInfoArrayBase
{
public:
    DWORD GetInfo(CString & strServer, LPCTSTR pszName, CSubnetInfo & subnetInfo);
    BOOL  Lookup(LPCTSTR pszName, CSubnetInfo & subnetInfo)
    {   
        BOOL fFound = FALSE;

        for (int i = 0; i < GetSize(); i++)
        {
            if (GetAt(i).SubnetName.Compare(pszName) == 0)
            {
                subnetInfo = GetAt(i);
                fFound = TRUE;
            }
        }

        return fFound;
    }
};

/*---------------------------------------------------------------------------
        Class:  CDhcpServerQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpServerQueryObj : public CDHCPQueryObj
{
public:
        CDhcpServerQueryObj(ITFSComponentData * pTFSComponentData,
                                                ITFSNodeMgr *       pNodeMgr) 
                        : CDHCPQueryObj(pTFSComponentData, pNodeMgr) 
    {
        // default to the cache in this object
        m_pSubnetInfoCache = &m_SubnetInfoCache;
    };
        
        STDMETHODIMP Execute();
        
        virtual void OnEventAbort(LPARAM Data, LPARAM Type);

        LONG CreateOption(CDhcpOption * pOption);
        void UpdateDefaultOptionsOnServer(CDhcpDefaultOptionsOnServer * pOptionsOnServer,
                                                                          CDhcpDefaultOptionsMasterList * pMasterList);
    void EnumSubnetsV4();
        void EnumSubnets();
    void EnumMScopes();  //Multicast scopes

        CDhcpSuperscope * FindSuperscope(CNodeListBase & listSuperscopes, LPWSTR pSuperScopeName);
        
        DWORD SetVersion();
        DWORD GetConfigInfo();
        DWORD GetStatistics();
        DWORD GetStatus();

        BOOL  VerifyDhcpServer();

public:
        DHCP_RESUME_HANDLE                              m_dhcpResumeHandle;
        DWORD                                                   m_dwPreferredMax;
        LARGE_INTEGER                                   m_liDhcpVersion;

        DWORD                                                   m_dwPingRetries;
        BOOL                                                    m_fAuditLog;
    BOOL                            m_bStatsOnly;
        BOOL                                                    m_fSupportsDynBootp;
        BOOL                                                    m_fSupportsBindings;
    CString                         m_strDatabasePath;
    CString                         m_strBackupPath;
        CString                                                 m_strAuditLogPath;
        CString                                                 m_strServerName;

        CDhcpDefaultOptionsOnServer *   m_pDefaultOptionsOnServer;

    CSubnetInfoCache *              m_pSubnetInfoCache;
    CSubnetInfoCache                m_SubnetInfoCache;
    CMScopeInfoCache                m_MScopeInfoCache;
};

/*---------------------------------------------------------------------------
        Class:  CDhcpSuperscopeQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpSuperscopeQueryObj : public CDHCPQueryObj
{
public:
        CDhcpSuperscopeQueryObj
        (
                ITFSComponentData* pTFSComponentData,
                ITFSNodeMgr*       pNodeMgr
        ) : CDHCPQueryObj(pTFSComponentData, pNodeMgr) {};
        STDMETHODIMP Execute();

public:
        CString         m_strSuperscopeName;    
};

/*---------------------------------------------------------------------------
        Class:  CDhcpBootpQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpBootpQueryObj : public CDHCPQueryObj
{
public:
        CDhcpBootpQueryObj
        (
                ITFSComponentData* pTFSComponentData,
                ITFSNodeMgr*       pNodeMgr
        ) : CDHCPQueryObj(pTFSComponentData, pNodeMgr) {};
        
        STDMETHODIMP Execute();
};

/*---------------------------------------------------------------------------
        Class:  CDhcpGlobalOptionsQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpGlobalOptionsQueryObj : public CDHCPQueryObj
{
public:
        CDhcpGlobalOptionsQueryObj
        (
                ITFSComponentData* pTFSComponentData,
                ITFSNodeMgr*       pNodeMgr
        ) : CDHCPQueryObj(pTFSComponentData, pNodeMgr) {};

        STDMETHODIMP Execute();

public:
        DHCP_RESUME_HANDLE      m_dhcpResumeHandle;
        DWORD                           m_dwPreferredMax;
    LARGE_INTEGER       m_liDhcpVersion;
};


/*---------------------------------------------------------------------------
        Class:  COptionNodeEnum
 ---------------------------------------------------------------------------*/
class COptionNodeEnum : public CTFSNodeList
{
public:
    COptionNodeEnum(ITFSComponentData * pTFSCompData, ITFSNodeMgr * pNodeMgr);
    
    DWORD Enum(LPCTSTR pServer, LARGE_INTEGER & liVersion, DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo);

protected:
    DWORD EnumOptions(LPCTSTR pServer, DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo);
    DWORD EnumOptionsV5(LPCTSTR pServer, DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo);

    // V5 Helper
    HRESULT CreateOptions(LPDHCP_OPTION_VALUE_ARRAY pOptionValues, LPCTSTR pClassName, LPCTSTR pszVendor);

protected:
    SPITFSComponentData     m_spTFSCompData;
    SPITFSNodeMgr           m_spNodeMgr;
};


#endif _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servstat.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ServStat.cpp
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ServStat.h"
#include "server.h"
#include "intltime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum 
{
    SERVER_STAT_START_TIME = 0,
    SERVER_STAT_UPTIME,
    SERVER_STAT_DISCOVERS,
    SERVER_STAT_OFFERS,
    SERVER_STAT_REQUESTS,
    SERVER_STAT_ACKS,
    SERVER_STAT_NACKS,
    SERVER_STAT_DECLINES,
    SERVER_STAT_RELEASES,
    SERVER_STAT_TOTAL_SCOPES,
    SERVER_STAT_TOTAL_ADDRESSES,
    SERVER_STAT_IN_USE,
    SERVER_STAT_AVAILABLE,
    SERVER_STAT_MAX
};

/*---------------------------------------------------------------------------
	CServerStats implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgServerStatsColumnInfo[] =
{
	{ IDS_SERVER_STATS_START_TIME,	    0,		TRUE },
	{ IDS_SERVER_STATS_UPTIME,	        0,		TRUE },
	{ IDS_SERVER_STATS_DISCOVERS,   	0,		TRUE },
	{ IDS_SERVER_STATS_OFFERS,   		0,		TRUE },
	{ IDS_SERVER_STATS_REQUESTS,   		0,		TRUE },
	{ IDS_SERVER_STATS_ACKS,   		    0,		TRUE },
	{ IDS_SERVER_STATS_NACKS,   		0,		TRUE },
	{ IDS_SERVER_STATS_DECLINES,   		0,		TRUE },
	{ IDS_SERVER_STATS_RELEASES,		0,		TRUE },
	{ IDS_STATS_TOTAL_SCOPES,   		0,		TRUE },
	{ IDS_STATS_TOTAL_ADDRESSES,		0,		TRUE },
	{ IDS_STATS_IN_USE,   		        0,		TRUE },
	{ IDS_STATS_AVAILABLE, 		        0,		TRUE },
};

CServerStats::CServerStats()
	: StatsDialog(STATSDLG_VERTICAL)
{
    SetColumnInfo(s_rgServerStatsColumnInfo,
				  DimensionOf(s_rgServerStatsColumnInfo));
}

CServerStats::~CServerStats()
{
}

BEGIN_MESSAGE_MAP(CServerStats, StatsDialog)
	//{{AFX_MSG_MAP(CServerStatistics)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
END_MESSAGE_MAP()

HRESULT CServerStats::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;
	    LPDHCP_MIB_INFO pMibInfo = NULL;
	    
        BEGIN_WAIT_CURSOR;
        dwError = ::DhcpGetMibInfo(m_strServerAddress, &pMibInfo);
        END_WAIT_CURSOR;
    
        if (dwError != ERROR_SUCCESS)
	    {
		    ::DhcpMessageBox(dwError);
		    return hrOK;
	    }

        UpdateWindow(pMibInfo);

        if (pMibInfo)
		    ::DhcpRpcFreeMemory(pMibInfo);
    }

    return hrOK;
}

BOOL CServerStats::OnInitDialog()
{
	CString	st;
    BOOL bRet;

    AfxFormatString1(st, IDS_SERVER_STATS_TITLE, m_strServerAddress);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

    // set the default window size
    RECT rect;
    GetWindowRect(&rect);
    SetWindowPos(NULL, rect.left, rect.top, SERVER_STATS_DEFAULT_WIDTH, SERVER_STATS_DEFAULT_HEIGHT, SWP_SHOWWINDOW);

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    return bRet;
}

void CServerStats::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}


afx_msg long CServerStats::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    SPITFSNode    spNode;
    CDhcpServer * pServer;

    pServer = GETHANDLER(CDhcpServer, m_spNode);

    LPDHCP_MIB_INFO pMibInfo = pServer->DuplicateMibInfo();

    Assert(pMibInfo);
    if (!pMibInfo)
        return 0;

    UpdateWindow(pMibInfo);

    pServer->FreeDupMibInfo(pMibInfo);

    return 0;
}

void CServerStats::UpdateWindow(LPDHCP_MIB_INFO pMibInfo)
{
	Assert (pMibInfo);

    UINT i;
    UINT nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;

    if (pMibInfo)
    {
        LPSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

	    // walk the list of scopes and calculate totals
	    for (i = 0; i < pMibInfo->Scopes; i++)
	    {
		    nTotalAddresses += (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
		    nTotalInUse += pScopeMibInfo[i].NumAddressesInuse;
		    nTotalAvailable += pScopeMibInfo[i].NumAddressesFree;
	    }
    }

    int     nPercent;
	CString	st;
    TCHAR   szFormat[] = _T("%d");
    TCHAR   szPercentFormat[] =  _T("%d (%d%%)");

    for (i = 0; i < SERVER_STAT_MAX; i++)
	{
        if (!pMibInfo)
            st = _T("---");
        else
        {
            switch (i)
		    {
                case SERVER_STAT_START_TIME:
                {
                    FILETIME filetime;
	                filetime.dwLowDateTime = pMibInfo->ServerStartTime.dwLowDateTime;
	                filetime.dwHighDateTime = pMibInfo->ServerStartTime.dwHighDateTime;

                    FormatDateTime(st, &filetime);
                }
                    break;

                case SERVER_STAT_UPTIME:
                {
                    FILETIME filetime;
	                filetime.dwLowDateTime = pMibInfo->ServerStartTime.dwLowDateTime;
	                filetime.dwHighDateTime = pMibInfo->ServerStartTime.dwHighDateTime;

	                CTime timeServerStart(filetime);
                    CTime timeCurrent = CTime::GetCurrentTime();
                    
                    CTimeSpan timeUp = timeCurrent - timeServerStart;

                    LONG_PTR nHours = timeUp.GetTotalHours();
                    LONG nMinutes = timeUp.GetMinutes();
                    LONG nSeconds = timeUp.GetSeconds();

                    CString strFormat;
                    strFormat.LoadString(IDS_UPTIME_FORMAT);
                    st.Format(strFormat, nHours, nMinutes, nSeconds);
                }
                    break;

                case SERVER_STAT_DISCOVERS:
	                st.Format(szFormat, pMibInfo->Discovers);
                    break;

                case SERVER_STAT_OFFERS:
	                st.Format(szFormat, pMibInfo->Offers);
                    break;

                case SERVER_STAT_REQUESTS:
	                st.Format(szFormat, pMibInfo->Requests);
                    break;

                case SERVER_STAT_ACKS:
	                st.Format(szFormat, pMibInfo->Acks);
                    break;

                case SERVER_STAT_NACKS:
	                st.Format(szFormat, pMibInfo->Naks);
                    break;

                case SERVER_STAT_DECLINES:
	                st.Format(szFormat, pMibInfo->Declines);
                    break;

                case SERVER_STAT_RELEASES:
	                st.Format(szFormat, pMibInfo->Releases);
                    break;

                case SERVER_STAT_TOTAL_SCOPES:
                    st.Format(szFormat, pMibInfo->Scopes);
                    break;

                case SERVER_STAT_TOTAL_ADDRESSES:
            	    st.Format(szFormat, nTotalAddresses);
                    break;

                case SERVER_STAT_IN_USE:
	                if (nTotalAddresses > 0)
		                nPercent = (int) ((float) (nTotalInUse * 100) / (float) nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalInUse, nPercent);
                    break;

                case SERVER_STAT_AVAILABLE:
	                if (nTotalAddresses > 0)
		                nPercent = (int) ((float) (nTotalAvailable * 100) / (float) nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalAvailable, nPercent);
                    break;
            
    		    default:
				    Panic1("Unknown server id : %d", i);
				    break;
		    }
        }

		m_listCtrl.SetItemText(i, 1, (LPCTSTR) st);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	servpp.h
		This file contains the prototypes for the server
		property page(s).

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__A1A51385_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_SERVPP_H__A1A51385_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if !defined _DNSPROP_H
#include "dnsprop.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral dialog

class CServerPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropGeneral)

// Construction
public:
	CServerPropGeneral();
	~CServerPropGeneral();

// Dialog Data
	//{{AFX_DATA(CServerPropGeneral)
	enum { IDD = IDP_SERVER_GENERAL };
	CEdit	m_editMinutes;
	CEdit	m_editHours;
	CEdit	m_editConflictAttempts;
	CSpinButtonCtrl	m_spinMinutes;
	CSpinButtonCtrl	m_spinHours;
	CSpinButtonCtrl	m_spinConflictAttempts;
	CButton	m_checkStatAutoRefresh;
	CButton	m_checkAuditLogging;
	BOOL	m_nAuditLogging;
	BOOL	m_nAutoRefresh;
	BOOL	m_bShowBootp;
	//}}AFX_DATA

	DWORD			m_dwSetFlags;
	DWORD			m_dwRefreshInterval;
	
	BOOL			m_bUpdateStatsRefresh;
    BOOL            m_fIsInNt5Domain;
    UINT            m_uImage;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CServerPropGeneral::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
	int m_nHours, m_nMinutes;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckAutoRefresh();
	afx_msg void OnCheckAuditLogging();
	afx_msg void OnChangeEditRefreshHours();
	afx_msg void OnChangeEditRefreshMinutes();
	afx_msg void OnCheckShowBootp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void ValidateRefreshInterval();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced dialog

class CServerPropAdvanced : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropAdvanced)

// Construction
public:
	CServerPropAdvanced();
	~CServerPropAdvanced();

// Dialog Data
	//{{AFX_DATA(CServerPropAdvanced)
	enum { IDD = IDP_SERVER_ADVANCED };
	CStatic	m_staticCredentials;
	CButton	m_buttonCredentials;
	CButton	m_buttonBrowseBackup;
	CStatic	m_staticBindings;
	CButton	m_buttonBindings;
	CStatic	m_staticDatabase;
	CButton	m_buttonBrowseDatabase;
	CEdit	m_editDatabasePath;
	CButton	m_buttonBrowseLog;
	CEdit	m_editAuditLogPath;
	CEdit	m_editBackupPath;
	CStatic	m_staticLogFile;
	CSpinButtonCtrl	m_spinConflictAttempts;
	CEdit	m_editConflictAttempts;
	//}}AFX_DATA

	int				m_nConflictAttempts;

	DWORD			m_dwSetFlags;
    DWORD           m_dwIp;

    CString         m_strDatabasePath;
    CString         m_strAuditLogPath;
    CString         m_strBackupPath;
    CString         m_strComputerName;

    BOOL            m_fPathChange;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CServerPropAdvanced::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropAdvanced)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
    DWORD GetMachineName(CString & strName);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowseDatabase();
	afx_msg void OnButtonBrowseLog();
	afx_msg void OnChangeEditConflictAttempts();
	afx_msg void OnChangeEditDatabasePath();
	afx_msg void OnChangeEditLogPath();
	afx_msg void OnButtonBindings();
	afx_msg void OnButtonBrowseBackup();
	afx_msg void OnChangeEditBackup();
	afx_msg void OnButtonCredentials();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CServerProperties : public CPropertyPageHolderBase
{
	friend class CServerPropGeneral;

public:
	CServerProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName);
	virtual ~CServerProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetVersion(LARGE_INTEGER & liVersion);
	void SetDnsRegistration(DWORD dwDynDnsFlags, DHCP_OPTION_SCOPE_TYPE dhcpOptionType);

public:
	CServerPropGeneral		m_pageGeneral;
	CServerPropAdvanced		m_pageAdvanced;
	CDnsPropRegistration	m_pageDns;
	
    LARGE_INTEGER	        m_liVersion;

protected:
	SPITFSComponentData		m_spTFSCompData;
};




#endif // !defined(AFX_SERVPP_H__A1A51385_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        servpp.cpp
                This file contains the implementation for the server
                property page(s).

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "servpp.h"
#include "server.h"
#include "shlobj.h"
#include "service.h"
#include "servbind.h"
#include "cred.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CServerProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CServerProperties::CServerProperties
(
        ITFSNode *                      pNode,
        IComponentData *        pComponentData,
        ITFSComponentData * pTFSCompData,
        LPCTSTR                         pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
        //ASSERT(pFolderNode == GetContainerNode());

        m_bAutoDeletePages = FALSE; // we have the pages as embedded members

        AddPageToList((CPropertyPageBase*) &m_pageGeneral);

        m_liVersion.QuadPart = 0;

    Assert(pTFSCompData != NULL);
        m_spTFSCompData.Set(pTFSCompData);
}

CServerProperties::~CServerProperties()
{
        RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
        
        if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
        {
                RemovePageFromList((CPropertyPageBase*) &m_pageDns, FALSE);
        }

        RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}

void
CServerProperties::SetVersion
(
        LARGE_INTEGER &  liVersion
)
{
        m_liVersion = liVersion;

        if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
        {
                AddPageToList((CPropertyPageBase*) &m_pageDns);
        }

        AddPageToList((CPropertyPageBase*) &m_pageAdvanced);
}

void
CServerProperties::SetDnsRegistration
(
        DWORD                                   dwDynDnsFlags,
        DHCP_OPTION_SCOPE_TYPE  dhcpOptionType
)
{
        m_pageDns.m_dwFlags = dwDynDnsFlags;
        m_pageDns.m_dhcpOptionType = dhcpOptionType;
}

/////////////////////////////////////////////////////////////////////////////
//
// CServerPropGeneral property page
//
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CServerPropGeneral, CPropertyPageBase)

CServerPropGeneral::CServerPropGeneral() : CPropertyPageBase(CServerPropGeneral::IDD)
{
        //{{AFX_DATA_INIT(CServerPropGeneral)
        m_nAuditLogging = FALSE;
        m_nAutoRefresh = FALSE;
        m_bShowBootp = FALSE;
        //}}AFX_DATA_INIT

        m_dwSetFlags = 0;
        m_bUpdateStatsRefresh = FALSE;
    m_uImage = 0;
}

CServerPropGeneral::~CServerPropGeneral()
{
}

void CServerPropGeneral::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CServerPropGeneral)
        DDX_Control(pDX, IDC_EDIT_REFRESH_MINUTES, m_editMinutes);
        DDX_Control(pDX, IDC_EDIT_REFRESH_HOURS, m_editHours);
        DDX_Control(pDX, IDC_SPIN_REFRESH_MINUTES, m_spinMinutes);
        DDX_Control(pDX, IDC_SPIN_REFRESH_HOURS, m_spinHours);
        DDX_Control(pDX, IDC_CHECK_AUTO_REFRESH, m_checkStatAutoRefresh);
        DDX_Control(pDX, IDC_CHECK_AUDIT_LOGGING, m_checkAuditLogging);
        DDX_Check(pDX, IDC_CHECK_AUDIT_LOGGING, m_nAuditLogging);
        DDX_Check(pDX, IDC_CHECK_AUTO_REFRESH, m_nAutoRefresh);
        DDX_Check(pDX, IDC_CHECK_SHOW_BOOTP, m_bShowBootp);
        DDX_Text(pDX, IDC_EDIT_REFRESH_MINUTES, m_nMinutes);
        DDX_Text(pDX, IDC_EDIT_REFRESH_HOURS, m_nHours);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropGeneral, CPropertyPageBase)
        //{{AFX_MSG_MAP(CServerPropGeneral)
        ON_BN_CLICKED(IDC_CHECK_AUTO_REFRESH, OnCheckAutoRefresh)
        ON_BN_CLICKED(IDC_CHECK_AUDIT_LOGGING, OnCheckAuditLogging)
        ON_EN_CHANGE(IDC_EDIT_REFRESH_HOURS, OnChangeEditRefreshHours)
        ON_EN_CHANGE(IDC_EDIT_REFRESH_MINUTES, OnChangeEditRefreshMinutes)
        ON_BN_CLICKED(IDC_CHECK_SHOW_BOOTP, OnCheckShowBootp)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral message handlers


BOOL CServerPropGeneral::OnApply() 
{
        UpdateData();

    BOOL bRet = CPropertyPageBase::OnApply();

        if (bRet == FALSE)
        {
                // Something bad happened... grab the error code
                AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
                ::DhcpMessageBox(GetHolder()->GetError());
        }
    else
    {
        m_dwSetFlags = 0;
    }

    return bRet;
}

BOOL CServerPropGeneral::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
    if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart < DHCP_SP2_VERSION) {
        // bootp and audit logging available.  Hide the options
        // to show bootp and classid
        m_checkAuditLogging.EnableWindow(FALSE);
        
        GetDlgItem(IDC_CHECK_SHOW_BOOTP)->ShowWindow(SW_HIDE);
    }

    m_spinMinutes.SetRange(0, 59);
    m_spinHours.SetRange(0, 23);
    
    m_editMinutes.LimitText(2);
    m_editHours.LimitText(2);
    
    DWORD dwRefreshInterval = m_dwRefreshInterval;
    
    m_nHours = dwRefreshInterval / MILLISEC_PER_HOUR;
    dwRefreshInterval -= m_nHours * MILLISEC_PER_HOUR;
    
    m_nMinutes = dwRefreshInterval / MILLISEC_PER_MINUTE;
    
    m_spinHours.SetPos(m_nHours);
    m_spinMinutes.SetPos(m_nMinutes);
        
    OnCheckAutoRefresh();

    m_dwSetFlags = 0;
    m_bUpdateStatsRefresh = FALSE;

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }
    
    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CServerPropGeneral::OnCheckAutoRefresh() 
{
        int nCheck = m_checkStatAutoRefresh.GetCheck();
        
        m_editHours.EnableWindow(nCheck);
        m_editMinutes.EnableWindow(nCheck);

        m_spinHours.EnableWindow(nCheck);
        m_spinMinutes.EnableWindow(nCheck);

        m_bUpdateStatsRefresh = TRUE;

        SetDirty(TRUE);
}

void CServerPropGeneral::OnCheckAuditLogging() 
{
        m_dwSetFlags |= Set_AuditLogState;

        SetDirty(TRUE);
}

BOOL CServerPropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode      spNode;
    SPITFSNode      spRootNode;
    CDhcpServer    *pServer;
    DWORD           dwError;

    BEGIN_WAIT_CURSOR;

    spNode = GetHolder()->GetNode();
    spNode->GetParent(&spRootNode);
    
    pServer = GETHANDLER(CDhcpServer, spNode);
    
    if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart >= DHCP_SP2_VERSION) {
        if (m_dwSetFlags) {
            dwError = pServer->SetConfigInfo(m_nAuditLogging, pServer->GetPingRetries());
            if (dwError != ERROR_SUCCESS) {
                GetHolder()->SetError(dwError);
            }
        }
    }

    if (m_bUpdateStatsRefresh) {
 
        m_dwRefreshInterval =  ( m_nHours * MILLISEC_PER_HOUR ) +
            ( m_nMinutes * MILLISEC_PER_MINUTE );
        pServer->SetAutoRefresh(spNode, m_nAutoRefresh, m_dwRefreshInterval );
        
        // mark the console as dirty
        spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    } // if m_bUpdateStatsRefresh

    // hide/show bootp and classid
    pServer->ShowNode(spNode, DHCPSNAP_BOOTP_TABLE, m_bShowBootp);

    DWORD dwServerOptions = pServer->GetServerOptions();

    // update options if they have changed
    if (dwServerOptions != pServer->GetServerOptions()) {
        pServer->SetServerOptions(dwServerOptions);
        
        // mark the console as dirty
        spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }
    
    END_WAIT_CURSOR;
    
    return FALSE;
} // CServerPropGeneral::OnPropertyChange()

void CServerPropGeneral::OnChangeEditRefreshHours() 
{
    m_bUpdateStatsRefresh = TRUE;
    ValidateRefreshInterval();
    SetDirty(TRUE);
}

void CServerPropGeneral::OnChangeEditRefreshMinutes() 
{
    m_bUpdateStatsRefresh = TRUE;
    ValidateRefreshInterval();
    SetDirty(TRUE);
}

void CServerPropGeneral::ValidateRefreshInterval()
{
    CString strText;
    int hour = 0, min = 0;

    hour = m_spinHours.GetPos();
    min = m_spinMinutes.GetPos();
    if ( hour > HOURS_MAX ) {
        m_spinHours.SetPos( HOURS_MAX );
        MessageBeep( MB_ICONEXCLAMATION );
    }
    if ( min > MINUTES_MAX ) {
        m_spinMinutes.SetPos( MINUTES_MAX );
        MessageBeep( MB_ICONEXCLAMATION );
    }
    if (( 0 == hour ) && ( 0 == min )) {
        m_spinMinutes.SetPos( 1 );
        MessageBeep( MB_ICONEXCLAMATION );
    }

} // CServerPropGeneral::ValidateRefreshInterval()

void CServerPropGeneral::OnCheckShowBootp() 
{
        SetDirty(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced property page

IMPLEMENT_DYNCREATE(CServerPropAdvanced, CPropertyPageBase)

CServerPropAdvanced::CServerPropAdvanced() : CPropertyPageBase(CServerPropAdvanced::IDD)
{
        //{{AFX_DATA_INIT(CServerPropAdvanced)
        //}}AFX_DATA_INIT

    m_nConflictAttempts = 0;
    m_fPathChange = FALSE;
}

CServerPropAdvanced::~CServerPropAdvanced()
{
}

void CServerPropAdvanced::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPageBase::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CServerPropAdvanced)
        DDX_Control(pDX, IDC_STATIC_CREDENTIALS, m_staticCredentials);
        DDX_Control(pDX, IDC_BUTTON_CREDENTIALS, m_buttonCredentials);
        DDX_Control(pDX, IDC_BUTTON_BROWSE_BACKUP, m_buttonBrowseBackup);
        DDX_Control(pDX, IDC_STATIC_MODIFY_BINDINGS_STRING, m_staticBindings);
        DDX_Control(pDX, IDC_BUTTON_BINDINGS, m_buttonBindings);
        DDX_Control(pDX, IDC_STATIC_DATABASE, m_staticDatabase);
        DDX_Control(pDX, IDC_BUTTON_BROWSE_DATABASE, m_buttonBrowseDatabase);
        DDX_Control(pDX, IDC_EDIT_DATABASE_PATH, m_editDatabasePath);
        DDX_Control(pDX, IDC_BUTTON_BROWSE_LOG, m_buttonBrowseLog);
        DDX_Control(pDX, IDC_EDIT_LOG_PATH, m_editAuditLogPath);
        DDX_Control(pDX, IDC_EDIT_BACKUP, m_editBackupPath);
        DDX_Control(pDX, IDC_STATIC_LOGFILE, m_staticLogFile);
        DDX_Control(pDX, IDC_SPIN_CONFLICT_ATTEMPTS, m_spinConflictAttempts);
        DDX_Control(pDX, IDC_EDIT_CONFLICT_ATTEMPTS, m_editConflictAttempts);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropAdvanced, CPropertyPageBase)
        //{{AFX_MSG_MAP(CServerPropAdvanced)
        ON_BN_CLICKED(IDC_BUTTON_BROWSE_DATABASE, OnButtonBrowseDatabase)
        ON_BN_CLICKED(IDC_BUTTON_BROWSE_LOG, OnButtonBrowseLog)
        ON_EN_CHANGE(IDC_EDIT_CONFLICT_ATTEMPTS, OnChangeEditConflictAttempts)
        ON_EN_CHANGE(IDC_EDIT_DATABASE_PATH, OnChangeEditDatabasePath)
        ON_EN_CHANGE(IDC_EDIT_LOG_PATH, OnChangeEditLogPath)
        ON_BN_CLICKED(IDC_BUTTON_BINDINGS, OnButtonBindings)
        ON_BN_CLICKED(IDC_BUTTON_BROWSE_BACKUP, OnButtonBrowseBackup)
        ON_EN_CHANGE(IDC_EDIT_BACKUP, OnChangeEditBackup)
        ON_BN_CLICKED(IDC_BUTTON_CREDENTIALS, OnButtonCredentials)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced message handlers

BOOL CServerPropAdvanced::OnInitDialog() 
{
    BOOL  fEnable = FALSE;
    TCHAR szBuffer[64];
    DWORD dwSize = sizeof( szBuffer ) / sizeof( TCHAR );
    SPITFSNode      spNode;
    CDhcpServer *   pServer;
    DWORD           dwError;


    CPropertyPageBase::OnInitDialog();
        
        // check to see if this is the local machine.  If so, enable the browse buttons
    BEGIN_WAIT_CURSOR;
    GetMachineName(m_strComputerName);
    END_WAIT_CURSOR;

    GetComputerName(szBuffer, &dwSize);

    if (m_strComputerName.CompareNoCase(szBuffer) == 0)
        fEnable = TRUE;

    // can only browse for folders if this is the local machine
    m_buttonBrowseLog.EnableWindow(fEnable);
    m_buttonBrowseDatabase.EnableWindow(fEnable);
    m_buttonBrowseBackup.EnableWindow(fEnable);

    // enable Bindings button only if server allows bindings..
    // also hide the buttons if they are not enabled.
    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CDhcpServer, spNode);

    if( FALSE == pServer->FSupportsBindings() ) {
        m_buttonBindings.EnableWindow(FALSE);
        m_staticBindings.EnableWindow(FALSE);
        m_buttonBindings.ShowWindow(SW_HIDE);
        m_staticBindings.ShowWindow(SW_HIDE);
    }

    // enable the appropriate controls based on the server version  
        if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart < DHCP_NT5_VERSION)
        {
        // changing the audit logging path only available on NT5
        m_buttonBrowseLog.EnableWindow(FALSE);
        m_staticLogFile.EnableWindow(FALSE);
        m_editAuditLogPath.EnableWindow(FALSE);
    }

        if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart < DHCP_NT51_VERSION)
        {
        // DHCP credentials for Dynamic DNS registrations available on this version.
        m_buttonCredentials.EnableWindow(FALSE);
    }

    if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart < DHCP_SP2_VERSION)
        {
                // conflict detection not available
                m_editConflictAttempts.EnableWindow(FALSE);
                m_spinConflictAttempts.EnableWindow(FALSE);
        }
        else
        {
                m_spinConflictAttempts.SetPos(m_nConflictAttempts);
        }

    m_spinConflictAttempts.SetRange(0,5);

        m_dwSetFlags = 0;

    // set the path's
    m_editAuditLogPath.SetWindowText(m_strAuditLogPath);
    m_editDatabasePath.SetWindowText(m_strDatabasePath);
    m_editBackupPath.SetWindowText(m_strBackupPath);
    
    m_fPathChange = FALSE;
    SetDirty(FALSE);

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CServerPropAdvanced::OnApply() 
{
        UpdateData();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    BOOL fRestartService = FALSE;

        if (m_fPathChange)
    {
        if (AfxMessageBox(IDS_PATH_CHANGE_RESTART_SERVICE, MB_YESNO) == IDYES)
        {
            fRestartService = TRUE;        
        }
    }
    
    m_nConflictAttempts = m_spinConflictAttempts.GetPos();

    m_editAuditLogPath.GetWindowText(m_strAuditLogPath);
    m_editDatabasePath.GetWindowText(m_strDatabasePath);
    m_editBackupPath.GetWindowText(m_strBackupPath);

    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE) {
	// Something bad happened... grab the error code
	// AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	::DhcpMessageBox(GetHolder()->GetError());
    }
    else  {
	if (fRestartService) {
	    SPITFSNode spNode;
	    SPITFSNode spRootNode;
	    CDhcpServer *pServer;
	    SPIConsole  spConsole;

	    spNode = GetHolder()->GetNode();
	    spNode->GetParent( &spRootNode );
	    pServer = GETHANDLER( CDhcpServer, spNode );

	    // Restart the server
	    pServer->RestartService( spRootNode );
            
	    // Refresh the server node
	    CMTDhcpHandler *pMTHandler = GETHANDLER( CMTDhcpHandler, spNode );
	    pMTHandler->OnRefresh( spNode, NULL, 0, 0, 0 );

	} // if

	m_fPathChange = FALSE;
	m_dwSetFlags = 0;

    } // else
	
    return bRet;
} // CServerPropAdvanced::OnApply()

BOOL CServerPropAdvanced::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode      spNode;
    CDhcpServer *   pServer;
    DWORD           dwError;
    
    BEGIN_WAIT_CURSOR;
    
    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CDhcpServer, spNode);
    
    if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart >= DHCP_NT5_VERSION) {
	// Get all of the parameters so we can just change the audit log path
	LPWSTR pAuditLogPath = NULL;
	DWORD  dwDiskCheckInterval = 0, dwMaxLogFilesSize = 0, dwMinSpaceOnDisk = 0;
	
	dwError = ::DhcpAuditLogGetParams((LPWSTR) pServer->GetIpAddress(),
					  0,
					  &pAuditLogPath,
					  &dwDiskCheckInterval,
					  &dwMaxLogFilesSize,
					  &dwMinSpaceOnDisk);
	if (dwError == ERROR_SUCCESS) {
	    ::DhcpRpcFreeMemory(pAuditLogPath);
	    
	    dwError = ::DhcpAuditLogSetParams((LPWSTR) pServer->GetIpAddress(),
					      0,
					      (LPWSTR) (LPCTSTR) m_strAuditLogPath,
					      dwDiskCheckInterval,
					      dwMaxLogFilesSize,
					      dwMinSpaceOnDisk);
	    if (dwError != ERROR_SUCCESS) {
		GetHolder()->SetError(dwError);
	    }
            else {
		// don't update this until the service is restarted...
                //pServer->SetAuditLogPath(m_strAuditLogPath);
            }
	} // if success
    } // if NT5

    int nPingRetries = pServer->GetPingRetries();

    if (((CServerProperties *) GetHolder())->m_liVersion.QuadPart >= DHCP_SP2_VERSION) {
        // only available on NT4 Sp2 and higher
        nPingRetries = m_nConflictAttempts;
    }
    
    dwError = pServer->SetConfigInfo(pServer->GetAuditLogging(),
				     nPingRetries, m_strDatabasePath,
				     m_strBackupPath);
    if (dwError != ERROR_SUCCESS) {
	GetHolder()->SetError(dwError);
    }
    
    END_WAIT_CURSOR;
    
    return FALSE;
} // CServerPropAdvanced::OnPropertyChange()

void CServerPropAdvanced::OnButtonBrowseDatabase() 
{
    CString strNewPath, strHelpText;
    strHelpText.LoadString(IDS_BROWSE_DATABASE_PATH);

    UtilGetFolderName(m_strDatabasePath, strHelpText, strNewPath);

    if (!strNewPath.IsEmpty() && 
        strNewPath.CompareNoCase(m_strDatabasePath) != 0)
    {
        m_strDatabasePath = strNewPath;
        m_editDatabasePath.SetWindowText(strNewPath);
    }
}

void CServerPropAdvanced::OnButtonBrowseLog() 
{
    CString strNewPath, strHelpText;
    strHelpText.LoadString(IDS_BROWSE_LOG_PATH);

    UtilGetFolderName(m_strAuditLogPath, strHelpText, strNewPath);

    if (!strNewPath.IsEmpty() && 
        strNewPath.CompareNoCase(m_strAuditLogPath) != 0)
    {
        m_strAuditLogPath = strNewPath;
        m_editAuditLogPath.SetWindowText(m_strAuditLogPath);

        SetDirty(TRUE);
    }
}

void CServerPropAdvanced::OnButtonBrowseBackup() 
{
    CString strNewPath, strHelpText;
    strHelpText.LoadString(IDS_BACKUP_HELP);

    UtilGetFolderName(m_strBackupPath, strHelpText, strNewPath);

    if (!strNewPath.IsEmpty() && 
        strNewPath.CompareNoCase(m_strBackupPath) != 0)
    {
        m_strBackupPath = strNewPath;
        m_editBackupPath.SetWindowText(m_strBackupPath);

        SetDirty(TRUE);
    }
}

void CServerPropAdvanced::OnChangeEditConflictAttempts() 
{
        m_dwSetFlags |= Set_PingRetries;

        SetDirty(TRUE);
}

void CServerPropAdvanced::OnChangeEditDatabasePath() 
{
    m_fPathChange = TRUE;
    SetDirty(TRUE);
}

void CServerPropAdvanced::OnChangeEditLogPath() 
{
    m_fPathChange = TRUE;
    SetDirty(TRUE);
}

void CServerPropAdvanced::OnChangeEditBackup() 
{
    SetDirty(TRUE);
}

DWORD
CServerPropAdvanced::GetMachineName(CString & strName)
{
    CString strHostName, strNetbiosName;
    DHC_HOST_INFO_STRUCT dhcHostInfo;

    ::UtilGetHostInfo(m_dwIp, &dhcHostInfo);

    strHostName = dhcHostInfo._chHostName;
    strNetbiosName = dhcHostInfo._chNetbiosName;

    if (strNetbiosName.IsEmpty())
        strName = strHostName;
    else
        strName = strNetbiosName;

    // strip off any periods
    int nIndex = strName.Find(_T("."));
    if (nIndex > 0)
        strName = strName.Left(nIndex);

    return ERROR_SUCCESS;

}


void CServerPropAdvanced::OnButtonBindings() 
{
    SPITFSNode      spNode;
    CDhcpServer *   pServer;

    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CDhcpServer, spNode);

    CServerBindings BindingsDialog(pServer);

    BindingsDialog.DoModal();

    // if there is an error in CServerBindings.OnInitDialog,
    // it calls OnCancel, and for some reason loses focus.
    // So, regain focus.
    SetFocus();
}


void CServerPropAdvanced::OnButtonCredentials() 
{
    CCredentials    dlgCred;
        SPITFSNode      spNode;
        CDhcpServer *   pServer;

    spNode = GetHolder()->GetNode();
        pServer = GETHANDLER(CDhcpServer, spNode);
    
    dlgCred.SetServerIp(pServer->GetIpAddress());

    dlgCred.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\servstat.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ServStat.h
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#ifndef _SERVSTAT_H
#define _SERVSTAT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#define SERVER_STATS_DEFAULT_WIDTH      345
#define SERVER_STATS_DEFAULT_HEIGHT     265

class CServerStats : public StatsDialog
{
public:
	CServerStats();
	~CServerStats();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    void UpdateWindow(LPDHCP_MIB_INFO pMibInfo);

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }

    DECLARE_MESSAGE_MAP()

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(IDD_STATS_NARROW); }
    
protected:
    CString         m_strServerAddress;
    SPITFSNode      m_spNode;
};

#endif _SERVSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscopwiz.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sscopwiz.cpp
		Superscope creation wizards.

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "sscopwiz.h"
#include "server.h"
#include "scope.h"

// compare function for the sorting of IP addresses in the available scopes box
int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int nCompare = 0;

    if (lParam1 > lParam2)
    {
        nCompare = 1;
    }
    else
    if (lParam1 < lParam2)
    {
        nCompare = -1;
    }

    return nCompare;
}


/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWiz holder
//
/////////////////////////////////////////////////////////////////////////////
CSuperscopeWiz::CSuperscopeWiz
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*)&m_pageWelcome);
	AddPageToList((CPropertyPageBase*)&m_pageName);
	AddPageToList((CPropertyPageBase*)&m_pageError);
	AddPageToList((CPropertyPageBase*)&m_pageSelectScopes);
	AddPageToList((CPropertyPageBase*)&m_pageConfirm);

	m_pQueryObject = NULL;
	m_spTFSCompData.Set(pTFSCompData);

    m_bWiz97 = TRUE;

    m_spTFSCompData->SetWatermarkInfo(&g_WatermarkInfoScope);
}

CSuperscopeWiz::~CSuperscopeWiz()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageWelcome, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageName, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageError, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageSelectScopes, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageConfirm, FALSE);

	if (m_pQueryObject)
	{
		LPQUEUEDATA pQD = NULL;

		while (pQD = m_pQueryObject->RemoveFromQueue())
		{
			// smart pointer will release node
			SPITFSNode spNode;

			spNode = reinterpret_cast<ITFSNode *>(pQD->Data);
			delete pQD;

			spNode->DeleteAllChildren(FALSE); // don't remove from UI, not added 
		}
			
		m_pQueryObject->Release();
	}
}

//
// Called from the OnWizardFinish to create the new superscope
//
DWORD
CSuperscopeWiz::OnFinish()
{
	DWORD               dwReturn = 0;
	DHCP_SUBNET_STATE   dhcpSuperscopeState = DhcpSubnetDisabled;
    SPITFSNode          spServerNode;
    LPDHCP_SUBNET_INFO	pdhcpSubnetInfo;

    BEGIN_WAIT_CURSOR;

    spServerNode = GetNode();

	CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);
		
	int nScopeCount = m_pageConfirm.m_listboxSelectedScopes.GetCount();

	for (int i = 0; i < nScopeCount; i++)
	{
		DHCP_IP_ADDRESS dhcpSubnetAddress = (DHCP_IP_ADDRESS) m_pageConfirm.m_listboxSelectedScopes.GetItemData(i);

		dwReturn = ::DhcpSetSuperScopeV4(pServer->GetIpAddress(),
										 dhcpSubnetAddress,
										 (LPWSTR) ((LPCTSTR) m_pageName.m_strSuperscopeName),
										 FALSE);

		if (dwReturn != ERROR_SUCCESS)
		{
			TRACE(_T("CSuperscopeWiz::OnFinish() - DhcpSetSuperScopeV4 failed!!  %d\n"), dwReturn);
			break;
		}

        // check to see if the subnet is enabled so we can set the superscope state later
        dwReturn = ::DhcpGetSubnetInfo((LPWSTR) pServer->GetIpAddress(),
				   	  				   dhcpSubnetAddress,
									   &pdhcpSubnetInfo);
        if (dwReturn == ERROR_SUCCESS)
        {
            if (pdhcpSubnetInfo->SubnetState == DhcpSubnetEnabled)
                dhcpSuperscopeState = DhcpSubnetEnabled;

			::DhcpRpcFreeMemory(pdhcpSubnetInfo);
        }

	}

	if (dwReturn == ERROR_SUCCESS)
	{
		// Create the new superscope node
		CDhcpSuperscope * pSuperscope;
		SPITFSNode spSuperscopeNode;
		SPITFSNodeMgr spNodeMgr;
		
		spServerNode->GetNodeMgr(&spNodeMgr);

		pSuperscope = new CDhcpSuperscope(m_spTFSCompData, m_pageName.m_strSuperscopeName);
		CreateContainerTFSNode(&spSuperscopeNode,
							   &GUID_DhcpSuperscopeNodeType,
							   pSuperscope,
							   pSuperscope,
							   spNodeMgr);

		pSuperscope->SetState(dhcpSuperscopeState);

        // Tell the handler to initialize any specific data
		pSuperscope->InitializeNode(spSuperscopeNode);
		pSuperscope->SetServer(spServerNode);
		
		// Add the node as a child to this node
		pServer = GETHANDLER(CDhcpServer, spServerNode);
        pServer->AddSuperscopeSorted(spServerNode, spSuperscopeNode);
		pSuperscope->Release();

		// 
		// Now look for any scopes that we just created and move them 
		// as a child of the new superscope node
		SPITFSNodeEnum spNodeEnum;
		SPITFSNode spCurrentNode;
		DWORD nNumReturned; 

		spServerNode->GetEnum(&spNodeEnum);

		for (i = 0; i < nScopeCount; i++)
		{
			DHCP_IP_ADDRESS dhcpSubnetAddress = (DHCP_IP_ADDRESS) m_pageConfirm.m_listboxSelectedScopes.GetItemData(i);
			
			spNodeEnum->Reset();
			
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			while (nNumReturned)
			{
				// is this node a scope?  -- could be a superscope, bootp folder or global options
				if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
				{
					CDhcpScope * pScope = GETHANDLER(CDhcpScope, spCurrentNode);

					// is this a scope that we just added to the superscope?
					if (pScope->GetAddress() == dhcpSubnetAddress)
					{
						// We just remove this node from the server list and don't
						// add it to the new superscope node because it will just get 
						// enumerated when the user clicks on the new superscope.
						spServerNode->RemoveChild(spCurrentNode);
                    }
				}

				spCurrentNode.Release();
				spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			}
		}
	}

	END_WAIT_CURSOR;

    return dwReturn;
}

HRESULT 
CSuperscopeWiz::GetScopeInfo()
{
	HRESULT hr = hrOK;

	SPITFSNode spServerNode;
	spServerNode = GetNode();

	CDhcpServer * pServer = GETHANDLER(CDhcpServer, spServerNode);

	m_pQueryObject = reinterpret_cast<CDHCPQueryObj * >(pServer->OnCreateQuery(spServerNode));

	if (!m_pQueryObject)
	{
		return E_FAIL;
	}
	
	(reinterpret_cast<CDhcpServerQueryObj *> (m_pQueryObject))->EnumSubnetsV4();

	return hr;
}

BOOL
CSuperscopeWiz::DoesSuperscopeExist
(
	LPCTSTR pSuperscopeName
)
{
	// walk our cached information to see if the superscope already exists
	CString strNewName = pSuperscopeName;
	BOOL bExists = FALSE;
	CQueueDataListBase & listQData = m_pQueryObject->GetQueue();

	POSITION pos;
	pos = listQData.GetHeadPosition();
	while (pos)
	{
		LPQUEUEDATA pQD = listQData.GetNext(pos);
		Assert(pQD->Type == QDATA_PNODE);

		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(pQD->Data);

		if (pNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
		{
			CDhcpSuperscope * pSScope = GETHANDLER(CDhcpSuperscope, pNode);

			if (strNewName.Compare(pSScope->GetName()) == 0)
			{
				bExists = TRUE;
				break;
			}
		}
	}

	return bExists;
}

HRESULT
CSuperscopeWiz::FillAvailableScopes
(
	CListCtrl & listboxScopes
)
{
	HRESULT hr = hrOK;
    int nCount = 0;

	CQueueDataListBase & listQData = m_pQueryObject->GetQueue();

	POSITION pos;
	pos = listQData.GetHeadPosition();
	while (pos)
	{
		LPQUEUEDATA pQD = listQData.GetNext(pos);
		Assert(pQD->Type == QDATA_PNODE);

		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(pQD->Data);

		if (pNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SCOPE)
		{
			CDhcpScope * pScope = GETHANDLER(CDhcpScope, pNode);

			CString strSuperscopeFormat, strSuperscopeName, strScopeAddress;
			
			// build the display name
			UtilCvtIpAddrToWstr (pScope->GetAddress(),
								 &strScopeAddress);

			strSuperscopeFormat.LoadString(IDS_INFO_FORMAT_SCOPE_NAME);
			strSuperscopeName.Format(strSuperscopeFormat, strScopeAddress, pScope->GetName());

			int nIndex = listboxScopes.InsertItem(nCount, strSuperscopeName);
			listboxScopes.SetItemData(nIndex, pScope->GetAddress());

            nCount++;
		}
	}

    listboxScopes.SortItems( CompareFunc, NULL );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizName property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CSuperscopeWizName, CPropertyPageBase)

CSuperscopeWizName::CSuperscopeWizName() : 
		CPropertyPageBase(CSuperscopeWizName::IDD)
{
    //{{AFX_DATA_INIT(CSuperscopeWizName)
    m_strSuperscopeName = _T("");
    //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SUPERSCOPE_WIZ_NAME_TITLE, IDS_SUPERSCOPE_WIZ_NAME_SUBTITLE);
}

CSuperscopeWizName::~CSuperscopeWizName()
{
}

void CSuperscopeWizName::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopeWizName)
	DDX_Text(pDX, IDC_EDIT_SUPERSCOPE_NAME, m_strSuperscopeName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopeWizName, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopeWizName)
	ON_EN_CHANGE(IDC_EDIT_SUPERSCOPE_NAME, OnChangeEditSuperscopeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizName message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CSuperscopeWizName::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

    CEdit *pEdit = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SUPERSCOPE_NAME ));
    if ( 0 != pEdit ) {
        pEdit->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSuperscopeWizName::OnWizardNext() 
{
	UpdateData();

	CSuperscopeWiz * pSScopeWiz = 
		reinterpret_cast<CSuperscopeWiz *>(GetHolder());
	
	if (pSScopeWiz->DoesSuperscopeExist(m_strSuperscopeName) == TRUE)
	{
		//
		// Go to the error page
		//
        AfxMessageBox(IDS_ERR_SUPERSCOPE_NAME_IN_USE);
        GetDlgItem(IDC_EDIT_SUPERSCOPE_NAME)->SetFocus();
		return -1;
	}
	else
	{
		//
		// Go to the next valid page
		//
		return IDW_SUPERSCOPE_SELECT_SCOPES;
	}
}

BOOL CSuperscopeWizName::OnSetActive() 
{
	SetButtons();
	
	return CPropertyPageBase::OnSetActive();
}

void CSuperscopeWizName::OnChangeEditSuperscopeName() 
{
	SetButtons();	
}

void CSuperscopeWizName::SetButtons()
{
	UpdateData();

	if (m_strSuperscopeName.IsEmpty())
	{
		GetHolder()->SetWizardButtonsMiddle(FALSE);
	}
	else
	{
		GetHolder()->SetWizardButtonsMiddle(TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizError property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CSuperscopeWizError, CPropertyPageBase)

CSuperscopeWizError::CSuperscopeWizError() : 
		CPropertyPageBase(CSuperscopeWizError::IDD)
{
	//{{AFX_DATA_INIT(CSuperscopeWizError)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SUPERSCOPE_WIZ_ERROR_TITLE, IDS_SUPERSCOPE_WIZ_ERROR_SUBTITLE);
}

CSuperscopeWizError::~CSuperscopeWizError()
{
}

void CSuperscopeWizError::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopeWizError)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopeWizError, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopeWizError)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizError message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CSuperscopeWizError::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSuperscopeWizError::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(FALSE);
	
	return CPropertyPageBase::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizSelectScopes property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CSuperscopeWizSelectScopes, CPropertyPageBase)

CSuperscopeWizSelectScopes::CSuperscopeWizSelectScopes() : 
		CPropertyPageBase(CSuperscopeWizSelectScopes::IDD)
{
	//{{AFX_DATA_INIT(CSuperscopeWizSelectScopes)
		// NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_SUPERSCOPE_WIZ_SELECT_TITLE, IDS_SUPERSCOPE_WIZ_SELECT_SUBTITLE);
}

CSuperscopeWizSelectScopes::~CSuperscopeWizSelectScopes()
{
}

void CSuperscopeWizSelectScopes::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopeWizSelectScopes)
	DDX_Control(pDX, IDC_LIST_AVAILABLE_SCOPES, m_listboxAvailScopes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopeWizSelectScopes, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopeWizSelectScopes)
	ON_LBN_SELCHANGE(IDC_LIST_AVAILABLE_SCOPES, OnSelchangeListAvailableScopes)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_AVAILABLE_SCOPES, OnItemchangedListAvailableScopes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizSelectScopes message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CSuperscopeWizSelectScopes::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	CSuperscopeWiz * pSScopeWiz = reinterpret_cast<CSuperscopeWiz *>(GetHolder());

    RECT rect;
    m_listboxAvailScopes.GetWindowRect(&rect);
    m_listboxAvailScopes.InsertColumn(0, _T(""), LVCFMT_LEFT, rect.right - rect.left - 20);

    ListView_SetExtendedListViewStyle(m_listboxAvailScopes.GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    pSScopeWiz->FillAvailableScopes(m_listboxAvailScopes);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSuperscopeWizSelectScopes::OnWizardBack() 
{
	//
	// Go back to the first page
	//
	return IDW_SUPERSCOPE_NAME;
}

LRESULT CSuperscopeWizSelectScopes::OnWizardNext() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CPropertyPageBase::OnWizardNext();
}

BOOL CSuperscopeWizSelectScopes::OnSetActive() 
{
	SetButtons();
	
	return CPropertyPageBase::OnSetActive();
}

void CSuperscopeWizSelectScopes::OnSelchangeListAvailableScopes() 
{
	SetButtons();	
}

void CSuperscopeWizSelectScopes::OnItemchangedListAvailableScopes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetButtons();

	*pResult = 0;
}

void CSuperscopeWizSelectScopes::SetButtons()
{
	if (m_listboxAvailScopes.GetSelectedCount() > 0)
	{
		GetHolder()->SetWizardButtonsMiddle(TRUE);
	}
	else
	{
		GetHolder()->SetWizardButtonsMiddle(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizConfirm property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CSuperscopeWizConfirm, CPropertyPageBase)

CSuperscopeWizConfirm::CSuperscopeWizConfirm() : 
		CPropertyPageBase(CSuperscopeWizConfirm::IDD)
{
	//{{AFX_DATA_INIT(CSuperscopeWizConfirm)
	//}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CSuperscopeWizConfirm::~CSuperscopeWizConfirm()
{
}

void CSuperscopeWizConfirm::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopeWizConfirm)
	DDX_Control(pDX, IDC_STATIC_FINISHED_TITLE, m_staticTitle);
	DDX_Control(pDX, IDC_LIST_SELECTED_SCOPES, m_listboxSelectedScopes);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopeWizConfirm, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopeWizConfirm)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizConfirm message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CSuperscopeWizConfirm::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	CString strFontName;
	CString strFontSize;

	strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
	strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
	if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSuperscopeWizConfirm::OnWizardFinish() 
{
	//
	// Tell the wizard holder that we need to finish
	//
	DWORD dwErr = GetHolder()->OnFinish();

    if (dwErr != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwErr);
        return FALSE;
    }

    return (dwErr == ERROR_SUCCESS) ? TRUE : FALSE;
}


BOOL CSuperscopeWizConfirm::OnSetActive() 
{
	GetHolder()->SetWizardButtonsLast(TRUE);
	
	CSuperscopeWiz * pSScopeWiz = 
		reinterpret_cast<CSuperscopeWiz *>(GetHolder());

	// Get the new superscope name and set the window text
	m_editName.SetWindowText(pSScopeWiz->m_pageName.m_strSuperscopeName);

    int nSelCount = pSScopeWiz->m_pageSelectScopes.m_listboxAvailScopes.GetSelectedCount();

	// now get the selected scope names and build our list
	m_listboxSelectedScopes.ResetContent();

    int nItem = pSScopeWiz->m_pageSelectScopes.m_listboxAvailScopes.GetNextItem(-1, LVNI_SELECTED);
	while (nItem != -1)
	{
		CString strText = pSScopeWiz->m_pageSelectScopes.m_listboxAvailScopes.GetItemText(nItem, 0);

		int nIndex = m_listboxSelectedScopes.AddString(strText);
		m_listboxSelectedScopes.SetItemData(nIndex, 
			pSScopeWiz->m_pageSelectScopes.m_listboxAvailScopes.GetItemData(nItem));
	
        nItem = pSScopeWiz->m_pageSelectScopes.m_listboxAvailScopes.GetNextItem(nItem, LVNI_SELECTED);    
    }

	return CPropertyPageBase::OnSetActive();
}



/////////////////////////////////////////////////////////////////////////////
// CSuperscopeWizWelcome property page

IMPLEMENT_DYNCREATE(CSuperscopeWizWelcome, CPropertyPageBase)

CSuperscopeWizWelcome::CSuperscopeWizWelcome() : CPropertyPageBase(CSuperscopeWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CSuperscopeWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CSuperscopeWizWelcome::~CSuperscopeWizWelcome()
{
}

void CSuperscopeWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuperscopeWizWelcome)
	DDX_Control(pDX, IDC_STATIC_WELCOME_TITLE, m_staticTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSuperscopeWizWelcome, CPropertyPageBase)
	//{{AFX_MSG_MAP(CSuperscopeWizWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSuperscopeWizWelcome message handlers
BOOL CSuperscopeWizWelcome::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	CString strFontName;
	CString strFontSize;

	strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
	strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
	if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSuperscopeWizWelcome::OnSetActive() 
{
    GetHolder()->SetWizardButtonsFirst(TRUE);
	
    return CPropertyPageBase::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscpstat.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	SscpStat.h
		The superscope statistics dialog
		
    FILE HISTORY:
        
*/

#ifndef _SSCPSTAT_H
#define _SSCPSTAT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

class CSuperscopeStats : public StatsDialog
{
public:
	CSuperscopeStats();
	~CSuperscopeStats();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    void UpdateWindow(LPDHCP_MIB_INFO pMibInfo);

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }
    void SetSuperscopeName(LPCTSTR pSuperscopeName) { m_strSuperscopeName = pSuperscopeName; }

    DECLARE_MESSAGE_MAP()

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(IDD_STATS_NARROW); }
    
protected:
    CString         m_strServerAddress;
    CString         m_strSuperscopeName;
    CDWordArray     m_dwScopeArray;
    SPITFSNode      m_spNode;
};


#endif _SSCPSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\strarrdlg.cpp ===
// strarrdlg.cpp : implementation file
//

#include "stdafx.h"
#include "strarrdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// StringArrayEditor dialog


CDhcpStringArrayEditor::CDhcpStringArrayEditor(
    CDhcpOption *pdhcType,
    DHCP_OPTION_SCOPE_TYPE dhcScopeType,
    CWnd *pParent )
    : CBaseDialog( CDhcpStringArrayEditor::IDD, pParent ),
      m_p_type( pdhcType ),
      m_option_type( dhcScopeType )
{
    //{{AFX_DATA_INIT(StringArrayEditor)
//      m_edit_value.Empty();
    //}}AFX_DATA_INIT
}


void CDhcpStringArrayEditor::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDhcpStringArrayEditor)
    DDX_Control(pDX, IDC_STATIC_OPTION_NAME, m_static_option_name);
    DDX_Control(pDX, IDC_STATIC_APPLICATION, m_static_application);
    DDX_Control(pDX, IDC_BUTN_UP, m_b_up);
    DDX_Control(pDX, IDC_BUTN_DOWN, m_b_down);
    DDX_Control(pDX, IDC_BUTN_DELETE, m_b_delete);
    DDX_Control(pDX, IDC_BUTN_ADD, m_b_add);
    DDX_Control(pDX, IDC_LIST_STRING, m_lb_str);
    DDX_Control(pDX, IDC_EDIT_STRING, m_edit);
    DDX_Text(pDX, IDC_EDIT_STRING, m_edit_value);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDhcpStringArrayEditor, CBaseDialog)
    //{{AFX_MSG_MAP(CDhcpStringArrayEditor)
    ON_BN_CLICKED(IDC_BUTN_ADD, OnButnAdd)
    ON_BN_CLICKED(IDC_BUTN_DELETE, OnButnDelete)
    ON_BN_CLICKED(IDC_BUTN_DOWN, OnButnDown)
    ON_BN_CLICKED(IDC_BUTN_UP, OnButnUp)
    ON_EN_CHANGE(IDC_EDIT_STRING, OnChangeEditString)
    ON_LBN_SELCHANGE(IDC_LIST_STRING, OnSelchangeListString)
	//}}AFX_MSG_MAP
    END_MESSAGE_MAP()

    /////////////////////////////////////////////////////////////////////////////
    // CDhcpStringArrayEditor message handlers

void CDhcpStringArrayEditor::OnButnAdd() 
{
    UpdateData();

    m_lb_str.InsertString( 0, m_edit_value );
    m_edit_value.Empty();
    m_lb_str.SetCurSel( 0 );

    // Set the focus back to the edit_value
    m_edit.SetFocus();

    UpdateData( FALSE );
    HandleActivation();

} // CDhcpStringArrayEditor::OnButnAdd()

void CDhcpStringArrayEditor::OnButnDelete() 
{
    int nSel = m_lb_str.GetCurSel();

    m_lb_str.GetText( nSel, m_edit_value );
    m_lb_str.DeleteString( nSel );
    nSel--;
    if ( nSel < 0 ) {
	nSel = 0;
    }
    m_lb_str.SetCurSel( nSel );
    m_lb_str.SetFocus();

    UpdateData( FALSE );
    HandleActivation();
} // CDhcpStringArrayEditor::OnButnDelete() 

void CDhcpStringArrayEditor::OnButnDown() 
{
    int nSel = m_lb_str.GetCurSel();
    CString str;

    m_lb_str.GetText( nSel, str );
    m_lb_str.DeleteString( nSel );
    nSel++;
    m_lb_str.InsertString( nSel, str );
    m_lb_str.SetCurSel( nSel );

    UpdateData( FALSE );
    HandleActivation();
} // CDhcpStringArrayEditor::OnButnDown() 

void CDhcpStringArrayEditor::OnButnUp() 
{
    int nSel = m_lb_str.GetCurSel();
    CString str;

    m_lb_str.GetText( nSel, str );
    m_lb_str.DeleteString( nSel );
    nSel--;
    m_lb_str.InsertString( nSel, str );
    m_lb_str.SetCurSel( nSel );

    UpdateData( FALSE );
    HandleActivation();
} // CDhcpStringArrayEditor::OnButnUp() 

void CDhcpStringArrayEditor::OnChangeEditString() 
{
    UpdateData();
    m_b_add.EnableWindow( !m_edit_value.IsEmpty());

} // CDhcpStringArrayEditor::OnChangeEditString()

void CDhcpStringArrayEditor::OnSelchangeListString() 
{
    HandleActivation();
} // CDhcpStringArrayEditor::OnSelchangeListString() 


void CDhcpStringArrayEditor::OnCancel() 
{
    CBaseDialog::OnCancel();
}

void CDhcpStringArrayEditor::OnOK() 
{
    int cItems = ( int ) m_lb_str.GetCount();
    DWORD err = 0;
    CString str;

    UpdateData();

    CATCH_MEM_EXCEPTION {
	CDhcpOptionValue *pdhcValue = &m_p_type->QueryValue();

	pdhcValue->RemoveAll();

	pdhcValue->SetUpperBound( cItems );

	for ( int i = 0; i < cItems; i++ ) {
	    m_lb_str.GetText( i, str );
	    pdhcValue->SetString( str, i );
	} // for
	m_p_type->SetDirty();
    }
    END_MEM_EXCEPTION( err );

    if ( err ) {
	::DhcpMessageBox( err );
	OnCancel();
    }
    else {
	CBaseDialog::OnOK();
    }
} // CDhcpStringArrayEditor::OnOK()

BOOL CDhcpStringArrayEditor::OnInitDialog() 
{
    CBaseDialog::OnInitDialog();
    
    DWORD err = 0;

    int cStrId = ( m_option_type == DhcpDefaultOptions)
	? IDS_INFO_TITLE_DEFAULT_OPTIONS
	: (( m_option_type == DhcpGlobalOptions )
	   ? IDS_INFO_TITLE_GLOBAL_OPTIONS
	   : IDS_INFO_TITLE_SCOPE_OPTIONS );

    CString str;

    CATCH_MEM_EXCEPTION {
	m_static_option_name.SetWindowText( m_p_type->QueryName());
	str.LoadString( cStrId );
	m_static_application.SetWindowText( str );

	// fill the internal list form the current value

	int cMax = m_p_type->QueryValue().QueryUpperBound();
	for ( int i = 0; i < cMax; i++ ) {
	    str = m_p_type->QueryValue().QueryString( i );
	    if ( !str.IsEmpty()) {
		m_lb_str.AddString( str );
	    }
	} // for 
	
	// Select the top most value
	if ( cMax > 0 ) {
	    m_lb_str.SetCurSel( 0 );
	}

	// Set proper button states.
	HandleActivation();
    }
    END_MEM_EXCEPTION( err );
    
    UpdateData( FALSE );

    if ( err ) {
	::DhcpMessageBox( err );
	EndDialog( -1 );
    }

    m_edit_value.Empty();  
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
} // CDhcpStringArrayEditor::OnInitDialog()

void CDhcpStringArrayEditor::HandleActivation()
{

    int cItems = m_lb_str.GetCount();
    int cSel = m_lb_str.GetCurSel();

    m_b_add.EnableWindow( !m_edit_value.IsEmpty());

    if ( 0 == cItems ) {
	m_b_delete.EnableWindow( FALSE );
	m_b_down.EnableWindow( FALSE );
	m_b_up.EnableWindow( FALSE );
	return;
    }
    if ( LB_ERR != cSel ) {
	m_b_delete.EnableWindow( TRUE );
	m_b_down.EnableWindow( cItems > ( cSel + 1 ));
	m_b_up.EnableWindow( cSel > 0 );
    } // else

    // check if the focus in on a disabled control
    // If yes, put the focus back to list box
    if ( !::IsWindowEnabled( ::GetFocus())) {
        m_lb_str.SetFocus();
    }

} // CDhcpStringArrayEditor::HandleActivation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\strarrdlg.h ===
#if !defined(AFX_STRARRDLG_H__AC005639_461C_4626_8D2F_7EE27F09AFFD__INCLUDED_)
#define AFX_STRARRDLG_H__AC005639_461C_4626_8D2F_7EE27F09AFFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// strarrdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// StringArrayEditor dialog

class CDhcpStringArrayEditor : public CBaseDialog
{
    // Construction
public:
    CDhcpStringArrayEditor( CDhcpOption *pdhcType,
			    DHCP_OPTION_SCOPE_TYPE dhcScopeType,
			    CWnd *pParent = NULL );

    // Dialog Data
    //{{AFX_DATA(StringArrayEditor)
    enum { IDD = IDD_STRING_ARRAY_EDIT };
    CStatic m_static_option_name;
    CStatic m_static_application;
    CButton	m_b_up;
    CButton	m_b_down;
    CButton	m_b_delete;
    CButton	m_b_add;
    CListBox	m_lb_str;
    CEdit       m_edit;
    CString	m_edit_value;
    //}}AFX_DATA

    CDhcpOption *m_p_type;
    DHCP_OPTION_SCOPE_TYPE m_option_type;

    void HandleActivation();
    void Fill( INT  cFocus = -1,
	       BOOL bToggleRedraw = TRUE );

    virtual DWORD * GetHelpMap() { 
	return DhcpGetHelpMap( CDhcpStringArrayEditor::IDD );
    }

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(StringArrayEditor)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    // Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(StringArrayEditor)
    afx_msg void OnButnAdd();
    afx_msg void OnButnDelete();
    afx_msg void OnButnDown();
    afx_msg void OnButnUp();
    afx_msg void OnChangeEditString();
    afx_msg void OnSelchangeListString();
    virtual void OnCancel();
    virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
	};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STRARRDLG_H__AC005639_461C_4626_8D2F_7EE27F09AFFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscpstat.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	SscpStat.h
		The superscope statistics dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "sscpstat.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum 
{
    SUPERSCOPE_STAT_TOTAL_SCOPES = 0,
    SUPERSCOPE_STAT_TOTAL_ADDRESSES,
    SUPERSCOPE_STAT_IN_USE,
    SUPERSCOPE_STAT_AVAILABLE,
    SUPERSCOPE_STAT_MAX
};

/*---------------------------------------------------------------------------
	CSuperscopeStats implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgSuperscopeStatsColumnInfo[] =
{
	{ IDS_STATS_TOTAL_SCOPES,		0,		TRUE },
	{ IDS_STATS_TOTAL_ADDRESSES,	0,		TRUE },
	{ IDS_STATS_IN_USE,   		    0,		TRUE },
	{ IDS_STATS_AVAILABLE, 		    0,		TRUE },
};

CSuperscopeStats::CSuperscopeStats()
	: StatsDialog(STATSDLG_VERTICAL)
{
    SetColumnInfo(s_rgSuperscopeStatsColumnInfo,
				  DimensionOf(s_rgSuperscopeStatsColumnInfo));
}

CSuperscopeStats::~CSuperscopeStats()
{
}

BEGIN_MESSAGE_MAP(CSuperscopeStats, StatsDialog)
	//{{AFX_MSG_MAP(CSuperscopeStats)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
END_MESSAGE_MAP()

HRESULT CSuperscopeStats::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;
	    LPDHCP_MIB_INFO pMibInfo = NULL;
	    LPDHCP_SUPER_SCOPE_TABLE pSuperscopeTable = NULL;
        LPDHCP_SUPER_SCOPE_TABLE_ENTRY pSuperscopeTableEntry = NULL;

        // build up a list of scopes to get info from
        BEGIN_WAIT_CURSOR;
        dwError = ::DhcpGetSuperScopeInfoV4(m_strServerAddress, &pSuperscopeTable);
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return dwError;
        }

	    // walk the list returned by the server
        pSuperscopeTableEntry = pSuperscopeTable->pEntries;
	    if (pSuperscopeTableEntry == NULL && pSuperscopeTable->cEntries != 0)
	    {
		    ASSERT(FALSE);
		    return dwError; // Just in case
	    }

	    // clear the array out
        m_dwScopeArray.RemoveAll();

        // find any scope addresses that belong to this superscope and build our
        // array for later
        for (int iSuperscopeEntry = pSuperscopeTable->cEntries;
		     iSuperscopeEntry > 0;
		     iSuperscopeEntry--, pSuperscopeTableEntry++)
	    {
   		    if (pSuperscopeTableEntry->SuperScopeName &&
                m_strSuperscopeName.Compare(pSuperscopeTableEntry->SuperScopeName) == 0)
            {
                m_dwScopeArray.Add(pSuperscopeTableEntry->SubnetAddress);
            }
        }

        dwError = ::DhcpGetMibInfo(m_strServerAddress, &pMibInfo);
        END_WAIT_CURSOR;
        if (dwError != ERROR_SUCCESS)
	    {
		    ::DhcpMessageBox(dwError);
		    return dwError;
	    }
        
        UpdateWindow(pMibInfo);

        if (pMibInfo)
		    ::DhcpRpcFreeMemory(pMibInfo);
    }

    return hrOK;
}

BOOL CSuperscopeStats::OnInitDialog()
{
	CString	st, strScopeAddress;
    BOOL bRet;

    AfxFormatString1(st, IDS_SUPERSCOPE_STATS_TITLE, m_strSuperscopeName);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    return bRet;
}

void CSuperscopeStats::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}


afx_msg long CSuperscopeStats::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    CDhcpSuperscope *   pSuperscope;
    CDhcpServer *       pServer;

    pSuperscope = GETHANDLER(CDhcpSuperscope, m_spNode);
    pServer = pSuperscope->GetServerObject();

    LPDHCP_MIB_INFO pMibInfo = pServer->DuplicateMibInfo();

    Assert(pMibInfo);
    if (!pMibInfo)
        return 0;

    UpdateWindow(pMibInfo);

    pServer->FreeDupMibInfo(pMibInfo);

    return 0;
}

void CSuperscopeStats::UpdateWindow(LPDHCP_MIB_INFO pMibInfo)
{
	Assert (pMibInfo);

    UINT i, j;
    int nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;

    if (pMibInfo)
    {
        LPSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

	    // walk the list of scopes and total the scopes that are in the superscope
	    for (i = 0; i < pMibInfo->Scopes; i++)
	    {
            for (j = 0; j < (UINT) m_dwScopeArray.GetSize(); j++)
            {
                if (pScopeMibInfo[i].Subnet == m_dwScopeArray[j])
		        {
			        nTotalAddresses += (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
			        nTotalInUse += pScopeMibInfo[i].NumAddressesInuse;
			        nTotalAvailable += pScopeMibInfo[i].NumAddressesFree;

			        break;
		        }
            }
	    }
    }

    int     nPercent;
	CString	st;
    TCHAR   szFormat[] = _T("%d");
    TCHAR   szPercentFormat[] =  _T("%d (%d%%)");

    for (i = 0; i < SUPERSCOPE_STAT_MAX; i++)
	{
        if (!pMibInfo)
            st = _T("---");
        else
        {
		    switch (i)
		    {
                case SUPERSCOPE_STAT_TOTAL_SCOPES:
            	    st.Format(szFormat, m_dwScopeArray.GetSize());
                    break;

                case SUPERSCOPE_STAT_TOTAL_ADDRESSES:
            	    st.Format(szFormat, nTotalAddresses);
                    break;

                case SUPERSCOPE_STAT_IN_USE:
	                if (nTotalAddresses > 0)
		                nPercent = (nTotalInUse * 100) / nTotalAddresses;
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalInUse, nPercent);
                    break;

                case SUPERSCOPE_STAT_AVAILABLE:
	                if (nTotalAddresses > 0)
		                nPercent = (nTotalAvailable * 100) / nTotalAddresses;
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalAvailable, nPercent);
                    break;
            
    		    default:
				    Panic1("Unknown scope stat id : %d", i);
				    break;
		    }
        }

		m_listCtrl.SetItemText(i, 1, (LPCTSTR) st);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\sscopwiz.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sscopwiz.h
		Superscope creation wizard
			- Create Superscope Dialog

	FILE HISTORY:
        
*/

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#define SUPERSCOPE_NAME_LENGTH_MAX	255	// Maximum length of a superscope name

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizName dialog
//
/////////////////////////////////////////////////////////////////////////////
class CSuperscopeWizName : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopeWizName)

// Construction
public:
	CSuperscopeWizName();
	~CSuperscopeWizName();

// Dialog Data
	//{{AFX_DATA(CSuperscopeWizName)
	enum { IDD = IDW_SUPERSCOPE_NAME };
	CString	m_strSuperscopeName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopeWizName)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	void SetButtons();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopeWizName)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditSuperscopeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizError dialog
//
/////////////////////////////////////////////////////////////////////////////
class CSuperscopeWizError : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopeWizError)

// Construction
public:
	CSuperscopeWizError();
	~CSuperscopeWizError();

// Dialog Data
	//{{AFX_DATA(CSuperscopeWizError)
	enum { IDD = IDW_SUPERSCOPE_ERROR };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopeWizError)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopeWizError)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizSelectScopes dialog
//
/////////////////////////////////////////////////////////////////////////////
class CSuperscopeWizSelectScopes : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopeWizSelectScopes)

// Construction
public:
	CSuperscopeWizSelectScopes();
	~CSuperscopeWizSelectScopes();

// Dialog Data
	//{{AFX_DATA(CSuperscopeWizSelectScopes)
	enum { IDD = IDW_SUPERSCOPE_SELECT_SCOPES };
	CListCtrl	m_listboxAvailScopes;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopeWizSelectScopes)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	void SetButtons();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopeWizSelectScopes)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListAvailableScopes();
	afx_msg void OnItemchangedListAvailableScopes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWizConfirm dialog
//
/////////////////////////////////////////////////////////////////////////////
class CSuperscopeWizConfirm : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopeWizConfirm)

// Construction
public:
	CSuperscopeWizConfirm();
	~CSuperscopeWizConfirm();

// Dialog Data
	//{{AFX_DATA(CSuperscopeWizConfirm)
	enum { IDD = IDW_SUPERSCOPE_CONFIRM };
	CStatic	m_staticTitle;
	CListBox	m_listboxSelectedScopes;
	CEdit	m_editName;
	//}}AFX_DATA

   	CFont	m_fontBig;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopeWizConfirm)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopeWizConfirm)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CSuperscopeWizWelcome dialog

class CSuperscopeWizWelcome : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSuperscopeWizWelcome)

// Construction
public:
	CSuperscopeWizWelcome();
	~CSuperscopeWizWelcome();

// Dialog Data
	//{{AFX_DATA(CSuperscopeWizWelcome)
	enum { IDD = IDW_SUPERSCOPE_WELCOME };
	CStatic	m_staticTitle;
	//}}AFX_DATA

   	CFont	m_fontBig;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuperscopeWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuperscopeWizWelcome)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

///////////////////////////////////////////////////////////////////////////////
//
// CSuperscopeWiz
//	page holder to contain Superscope wizard pages
//
/////////////////////////////////////////////////////////////////////////////
class CSuperscopeWiz : public CPropertyPageHolderBase
{
	friend class CSuperscopeWizName;
	friend class CSuperscopeWizError;
	friend class CSuperscopeWizSelectScopes;
	friend class CSuperscopeWizConfirm;
	friend class CSuperscopeWizWelcome;

public:
	CSuperscopeWiz (ITFSNode *			pNode,
					IComponentData *	pComponentData,
					ITFSComponentData * pTFSCompData,
					LPCTSTR				pszSheetName);
	virtual ~CSuperscopeWiz();

	HRESULT FillAvailableScopes(CListCtrl & listboxScopes);
	BOOL	DoesSuperscopeExist(LPCTSTR pSuperscopeName);
	HRESULT GetScopeInfo();

	virtual DWORD OnFinish();

private:
	CSuperscopeWizWelcome		m_pageWelcome;
	CSuperscopeWizName			m_pageName;
	CSuperscopeWizError			m_pageError;
	CSuperscopeWizSelectScopes	m_pageSelectScopes;
	CSuperscopeWizConfirm		m_pageConfirm;

	CDHCPQueryObj *				m_pQueryObject;

	SPITFSComponentData		m_spTFSCompData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\utils.cpp ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    utils.cpp
		Utility routines for the DHCP admin snapin

    FILE HISTORY:
	   DavidHov    6/15/93     Created

*/

#include "stdafx.h"
//#include "svcguid.h"

#define NUM_OPTION_TYPES    3
#define NUM_OPTION_POSS     NUM_OPTION_TYPES * NUM_OPTION_TYPES

int g_OptionPriorityMap[NUM_OPTION_POSS][NUM_OPTION_TYPES] = 
{
    {ICON_IDX_CLIENT_OPTION_LEAF, ICON_IDX_CLIENT_OPTION_LEAF, 0},
    {ICON_IDX_CLIENT_OPTION_LEAF, ICON_IDX_SCOPE_OPTION_LEAF, -1},
    {ICON_IDX_CLIENT_OPTION_LEAF, ICON_IDX_SERVER_OPTION_LEAF, -1},
    {ICON_IDX_SCOPE_OPTION_LEAF, ICON_IDX_CLIENT_OPTION_LEAF, 1},
    {ICON_IDX_SCOPE_OPTION_LEAF, ICON_IDX_SCOPE_OPTION_LEAF, 0},
    {ICON_IDX_SCOPE_OPTION_LEAF, ICON_IDX_SERVER_OPTION_LEAF, -1},
    {ICON_IDX_SERVER_OPTION_LEAF, ICON_IDX_CLIENT_OPTION_LEAF, 1},
    {ICON_IDX_SERVER_OPTION_LEAF, ICON_IDX_SCOPE_OPTION_LEAF, 1},
    {ICON_IDX_SERVER_OPTION_LEAF, ICON_IDX_SERVER_OPTION_LEAF, 0}
};

int
UtilGetOptionPriority(int nOpt1, int nOpt2)
{
    int nRet = 0;

    for (int i = 0; i < NUM_OPTION_POSS; i++)
    {       
        if ( (nOpt1 == g_OptionPriorityMap[i][0]) &&
             (nOpt2 == g_OptionPriorityMap[i][1]) )   
        {
            nRet = g_OptionPriorityMap[i][2];
            break;
        }
    }

    return nRet;
}

int ServerBrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    int i;

    switch (uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }

    return 0;
}

/*---------------------------------------------------------------------------
	UtilGetFolderName()
		Gets the folder name for backup/restore.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
UtilGetFolderName(CString & strInitialPath, CString& strHelpText, CString& strSelectedPath)
{
    BOOL  fOk = FALSE;
	TCHAR szBuffer[MAX_PATH];
    TCHAR szExpandedPath[MAX_PATH * 2];
    HRESULT hr;

    CString strStartingPath = strInitialPath;
    if (strStartingPath.IsEmpty())
    {
        strStartingPath = _T("%SystemDrive%\\");
    }

    ExpandEnvironmentStrings(strStartingPath, szExpandedPath, sizeof(szExpandedPath) / sizeof(TCHAR));

	LPITEMIDLIST pidlPrograms = NULL; 
	hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlPrograms);
    if ( FAILED( hr ) )
    {
        return fOk;
    }

	BROWSEINFO browseInfo;
    browseInfo.hwndOwner = ::FindMMCMainWindow();
	browseInfo.pidlRoot = pidlPrograms;            
	browseInfo.pszDisplayName = szBuffer;  
	
    browseInfo.lpszTitle = strHelpText;
    browseInfo.ulFlags = BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS ;            
    browseInfo.lpfn = ServerBrowseCallbackProc;        

    browseInfo.lParam = (LPARAM) szExpandedPath;
	
	LPITEMIDLIST pidlBrowse = SHBrowseForFolder(&browseInfo);

	fOk = SHGetPathFromIDList(pidlBrowse, szBuffer); 

	CString strPath(szBuffer);
	strSelectedPath = strPath;

    LPMALLOC pMalloc = NULL;

    if (pidlPrograms && SUCCEEDED(SHGetMalloc(&pMalloc)))
    {
        if (pMalloc)
            pMalloc->Free(pidlPrograms);
    }

    return fOk;
}

/*---------------------------------------------------------------------------
	UtilConvertLeaseTime
		Converts the lease time from a dword to its day, hour and minute 
		values
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
UtilConvertLeaseTime
(
	DWORD	dwLeaseTime,
	int *	pnDays,
	int *	pnHours,
	int *   pnMinutes
)
{
	*pnDays = dwLeaseTime / (60 * 60 * 24);
	dwLeaseTime = (dwLeaseTime % (60 * 60 * 24));

	*pnHours = dwLeaseTime / (60 * 60);
	dwLeaseTime = (dwLeaseTime % (60 * 60));

	*pnMinutes = dwLeaseTime / 60;
}

/*---------------------------------------------------------------------------
	UtilConvertLeaseTime
		Converts the lease time from its day, hour and minute values to
		a dword
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
UtilConvertLeaseTime
(
	int 	nDays,
	int 	nHours,
	int     nMinutes
)
{
	return  (DWORD) (nDays * 60 * 60 * 24) + 
				    (nHours * 60 * 60)  +
				    (nMinutes * 60);
}

/*---------------------------------------------------------------------------
	UtilCvtStringToIpAddr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
ENUM_HOST_NAME_TYPE
UtilCategorizeName 
(
	LPCTSTR pszName
)
{
    // assume a NetBios name
	ENUM_HOST_NAME_TYPE enResult = HNM_TYPE_NB ;
	const TCHAR chDash = '-';
    const TCHAR chDot = '.' ;
	const TCHAR chSlash = '\\' ;
	CString strName( pszName ) ;

	int cch = strName.GetLength() ;

	//  Does the name begin with two slashes??

	if (    cch > 2
		&& strName.GetAt(0) == chSlash
		&& strName.GetAt(1) == chSlash )
	{
		enResult = HNM_TYPE_NB ;
	}
	else
	{
		//
		//  Scan the name looking for DNS name or IP address
		//
		int i = 0,
			cDots = 0,
			cAlpha = 0,
            cDash = 0;
		TCHAR ch ;
		BOOL bOk = TRUE ;

		for ( ; i < cch ; i++ )
		{
			switch ( ch = strName.GetAt( i ) )
			{
				case chDot:
					if ( ++cDots > 3 )
					{
                        // we keep track of the number of dots,
                        // but we need to be able to handle fully
                        // qualified domain names (FQDN) so more than
                        // 3 dots is ok.
						//bOk = FALSE ;
					}
					break;

				default:
					if ( _istalpha( ch ) )
					{
						cAlpha++;
					}
                    else if ( ch == chDash )
                    {
                        cDash++;
                    }
					else if ( !_istdigit(ch) )
					{
						bOk = FALSE;
					}

					break;
			}
			if ( ! bOk )
			{
				break ;
			}
		}
		if ( bOk )
		{
			if ( cAlpha )
			{
				enResult = HNM_TYPE_DNS ;
			}
			else if ( cDots == 3 )
			{
				enResult = HNM_TYPE_IP ;
			}
		}
	}

	return enResult ;
}

/*---------------------------------------------------------------------------
	UtilCvtStringToIpAddr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DHCP_IP_ADDRESS
UtilCvtStringToIpAddr 
(
    const CHAR * pszString
)
{
    //
    //  Convert the string to network byte order, then to host byte order.
    //
    return (DHCP_IP_ADDRESS) ::ntohl( ::inet_addr( pszString ) ) ;
}

/*---------------------------------------------------------------------------
	UtilCvtWstrToIpAddr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DHCP_IP_ADDRESS
UtilCvtWstrToIpAddr 
(
    const LPCWSTR pcwString
)
{
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_OEMCP, 0, pcwString, -1, szString, sizeof(szString), NULL, NULL);

	//
    //  Convert the string to network byte order, then to host byte order.
    //
    return (DHCP_IP_ADDRESS) ::ntohl( ::inet_addr( szString ) );
}

/*---------------------------------------------------------------------------
	UtilCvtIpAddrToString
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
UtilCvtIpAddrToString 
(
    DHCP_IP_ADDRESS		dhipa,
    CHAR *				pszString,
    UINT				cBuffSize 
)
{
    struct in_addr ipaddr ;

    //
    //  Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl( (u_long) dhipa ) ;

    //
    //  Convert the IP address value to a string
    //
    CHAR * pszAddr = inet_ntoa( ipaddr ) ;

    //  Copy the string to the caller's buffer.
    ASSERT(cBuffSize > ::strlen(pszAddr));
    ASSERT(pszString);
    if (pszAddr)
    {
        ::strcpy( pszString, pszAddr ) ;
    }
}

/*---------------------------------------------------------------------------
	UtilCvtIpAddrToWstr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
UtilCvtIpAddrToWstr 
(
    DHCP_IP_ADDRESS		dhipa,
	CString *			pstrIpAddress
)
{
    CHAR szString [ MAX_PATH ] ;
	LPCTSTR	pbuf;

    ::UtilCvtIpAddrToString( dhipa, szString, MAX_PATH );
    INT cch = ::strlen( szString ) ;

	LPTSTR pBuf = pstrIpAddress->GetBuffer(IP_ADDDRESS_LENGTH_MAX);
	ZeroMemory(pBuf, IP_ADDDRESS_LENGTH_MAX);

    ::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, szString, -1, pBuf, IP_ADDDRESS_LENGTH_MAX);
	
	pstrIpAddress->ReleaseBuffer();

	return TRUE;
}

/*---------------------------------------------------------------------------
	UtilCvtIpAddrToWstr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
UtilCvtIpAddrToWstr 
(
    DHCP_IP_ADDRESS		dhipa,
    WCHAR *				pwcszString,
    INT					cBuffCount 
)
{
    CHAR szString [ MAX_PATH ] ;

    if ( cBuffCount > sizeof szString - 1 )
    {
        cBuffCount = sizeof szString - 1 ;
    }

    ::UtilCvtIpAddrToString( dhipa, szString, cBuffCount );
#ifdef FE_SB
    INT cch;

    cch = ::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, szString, -1, pwcszString, cBuffCount);
    pwcszString[cch] = L'\0';
#else
    INT cch = ::strlen( szString ) ;

    //::mbstowcs( pwcszString, szString, cch ) ;
    ::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, szString, cch, pwcszString, cBuffCount);
    pwcszString[cch] = 0 ;
#endif
    return TRUE ;
}

/*---------------------------------------------------------------------------
	UtilDupIpAddrToWstr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR *
UtilDupIpAddrToWstr 
(
    DHCP_IP_ADDRESS dhipa 
)
{
    WCHAR wcszString [ MAX_PATH ] ;

    if ( ! ::UtilCvtIpAddrToWstr( dhipa, wcszString, ( sizeof ( wcszString ) / sizeof( WCHAR ) ) ) )
    {
        return NULL ;
    }

    return ::UtilWcstrDup( wcszString ) ;
}

/*---------------------------------------------------------------------------
	validateNetbiosName
		Simplistic routine to check to see if the given name is viable
		as a NetBIOS name.
	Author: EricDav
 ---------------------------------------------------------------------------*/
static BOOL
validateNetbiosName 
(
    const CHAR * pchName
)
{
    INT nChars = ::strlen( pchName ) ;
    if ( nChars > MAX_COMPUTERNAME_LENGTH || nChars == 0 )
    {
        return FALSE ;
    }

    for ( ; *pchName ; pchName++ )
    {
        if ( *pchName == '.' )
        {
            break ;
        }
    }

    return *pchName == 0 ;
}

/*---------------------------------------------------------------------------
	UtilGetHostInfo
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
UtilGetHostInfo 
(
    DHCP_IP_ADDRESS			dhipa,
    DHC_HOST_INFO_STRUCT *	pdhsrvi
)
{
    ZeroMemory(pdhsrvi, sizeof(DHC_HOST_INFO_STRUCT));

    pdhsrvi->_dhipa = dhipa ;

    //
    //  Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl( (u_long) dhipa ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
										   sizeof ulAddrInNetOrder,
										   PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
	}

    CHAR * * ppchAlias = pHostInfo->h_aliases ;

    //
    //  Check and copy the host name.
    //
    if ( sizeof (pdhsrvi->_chNetbiosName) <= ::strlen( pHostInfo->h_name ) )
    {
        return ERROR_INVALID_NAME ;
    }

	ZeroMemory(pdhsrvi->_chNetbiosName, sizeof(pdhsrvi->_chNetbiosName));

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          lstrlenA(pHostInfo->h_name), 
                          pdhsrvi->_chNetbiosName, 
                          sizeof(pdhsrvi->_chNetbiosName) / sizeof( pdhsrvi->_chNetbiosName[ 0 ]));

    // remove any periods at the end
    while (pdhsrvi->_chHostName[lstrlen(pdhsrvi->_chNetbiosName) - 1] == '.')
    {
        pdhsrvi->_chHostName[lstrlen(pdhsrvi->_chNetbiosName) - 1] = 0;
    }

    // gethostbyaddr is returning the hostname only in some cases.  
    // Make another call to get the fqdn
    CString strTemp = pdhsrvi->_chNetbiosName;
    if (strTemp.Find('.') == -1)
    {
        // this is not a FQDN
        strTemp.Empty();
        UtilGetHostAddressFQDN(pdhsrvi->_chNetbiosName, &strTemp, &dhipa);
    }

    // copy the data into the buffer
    strTemp.MakeLower();
    memset(pdhsrvi->_chHostName, 0, sizeof(pdhsrvi->_chHostName));
    lstrcpy(pdhsrvi->_chHostName, strTemp);

    //
    //  Find the first acceptable NetBIOS name among the aliases;
    //  i.e., the first name without a period
    //
    /*
    for ( ; *ppchAlias ; ppchAlias++ )
    {
        if  ( validateNetbiosName( *ppchAlias ) )
        {
            break ;
        }
    }

    //
    //  Empty the NetBIOS name in case we didn't get one.
    //
    pdhsrvi->_chNetbiosName[0] = 0 ;
    
    if ( *ppchAlias )
    {
        //
        //  We found a usable name; copy it to output structure.
        //
        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              *ppchAlias, 
                              lstrlenA(*ppchAlias),
                              pdhsrvi->_chNetbiosName, 
                              sizeof(pdhsrvi->_chNetbiosName));
    }
    */

    return NOERROR ;
}

/*---------------------------------------------------------------------------
	addrFromHostent
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
static DHCP_IP_ADDRESS 
addrFromHostent 
(
    const HOSTENT * pHostent,
    INT				index = 0 
)
{
    return (DHCP_IP_ADDRESS) ::ntohl( *((u_long *) pHostent->h_addr_list[index]) ) ;
}

/*---------------------------------------------------------------------------
	UtilGetHostAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
UtilGetHostAddressFQDN
(
    LPCTSTR				pszHostName,
    CString *           pstrFQDN,
    DHCP_IP_ADDRESS *	pdhipa
)
{
	HRESULT hr = NOERROR;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;

        LPTSTR pName = pstrFQDN->GetBuffer(DHCPSNAP_STRING_MAX * sizeof( WCHAR ));
        ZeroMemory(pName, DHCPSNAP_STRING_MAX * sizeof( WCHAR ));

        ::MultiByteToWideChar(CP_ACP,
                              MB_PRECOMPOSED,
                              pHostent->h_name,
                              strlen(pHostent->h_name),
                              pName,
                              DHCPSNAP_STRING_MAX );

        pstrFQDN->ReleaseBuffer();

    }
    else
    {
        hr = ::WSAGetLastError() ;
	}

    return hr;
}

/*---------------------------------------------------------------------------
	UtilGetHostAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
UtilGetHostAddress 
(
    LPCTSTR				pszHostName,
    DHCP_IP_ADDRESS *	pdhipa
)
{
	HRESULT hr = NOERROR;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;
    }
    else
    {
        hr = ::WSAGetLastError() ;
	}

    return hr ;
}

/*---------------------------------------------------------------------------
	UtilGetLocalHostAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
UtilGetLocalHostAddress 
(
    DHCP_IP_ADDRESS * pdhipa
)
{
    CHAR chHostName [ DHCPSNAP_STRING_MAX ] ;
	HRESULT hr = NOERROR;

    if ( ::gethostname( chHostName, sizeof chHostName ) == 0 )
    {
        CString strTemp = chHostName;
		hr = ::UtilGetHostAddress( strTemp, pdhipa ) ;
    }
    else
    {
        //err = ::WSAGetLastError() ;
		hr = E_FAIL;
	}

    return hr;
}

/*---------------------------------------------------------------------------
	UtilGetLocalHostName
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
UtilGetLocalHostName
(
    CString * pstrName
)
{
    CHAR chHostName [ DHCPSNAP_STRING_MAX * 2 ] ;
	HRESULT hr = NOERROR;

    if ( ::gethostname( chHostName, sizeof (chHostName) ) == 0 )
    {
        LPTSTR pName = pstrName->GetBuffer(DHCPSNAP_STRING_MAX * sizeof( WCHAR ));
		ZeroMemory(pName, DHCPSNAP_STRING_MAX * sizeof( WCHAR ));

        ::MultiByteToWideChar(CP_ACP,
                              MB_PRECOMPOSED,
                              chHostName,
                              strlen(chHostName),
                              pName,
                              DHCPSNAP_STRING_MAX );

        pstrName->ReleaseBuffer();
    }
    else
    {
        //err = ::WSAGetLastError() ;
		hr = E_FAIL;
	}

    return hr;
}

/*---------------------------------------------------------------------------
	UtilGetNetbiosAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
UtilGetNetbiosAddress 
(
    LPCTSTR				pszNetbiosName,
    DHCP_IP_ADDRESS *	pdhipa
)
{
    //
    //   This code presupposes that the "hosts" file maps NetBIOS names
    //   and DNS names identically.  THIS IS NOT A VALID SUPPOSITION, but is
    //   expedient for the on-campus work.
    //
    return UtilGetHostAddress( pszNetbiosName, pdhipa ) ;
}

/*---------------------------------------------------------------------------
	UtilWcstrDup
		"strdup" a WC string
	Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR * 
UtilWcstrDup 
(
    const WCHAR *	pwcsz,
    INT *			pccwLength
)
{
    WCHAR szwchEmpty [2] = { 0 } ;

    if ( pwcsz == NULL )
    {
        pwcsz = szwchEmpty ;
    }

    INT ccw = ::wcslen( pwcsz );

    WCHAR * pwcszNew = new WCHAR [ ccw + 1 ] ;
    if ( pwcszNew == NULL )
    {
        return NULL ;
    }
    ::wcscpy( pwcszNew, pwcsz ) ;

    if ( pccwLength )
    {
        *pccwLength = ccw ;
    }

    return pwcszNew ;
}

/*---------------------------------------------------------------------------
	UtilWcstrDup
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR * 
UtilWcstrDup 
(
    const CHAR *	psz,
    INT *			pccwLength
)
{
    INT ccw = ::strlen( psz ) ;

    WCHAR * pwcszNew = new WCHAR [ ccw + 1 ] ;

    if ( pwcszNew == NULL )
    {
        return NULL ;
    }

    //::mbstowcs( pwcszNew, psz, ccw ) ;
#ifdef FE_SB
    ccw = ::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, psz, -1, pwcszNew, ccw+1);
    if ( pccwLength )
    {
        *pccwLength = ccw ;
    }
    pwcszNew[ccw] = L'\0';
#else
    ::MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, psz, ccw, pwcszNew, ccw+1);
    if ( pccwLength )
    {
        *pccwLength = ccw ;
    }
    pwcszNew[ccw] = 0 ;
#endif

    return pwcszNew ;
}

/*---------------------------------------------------------------------------
	UtilCstrDup
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CHAR * 
UtilCstrDup 
(
    const WCHAR * pwcsz
)
{
    INT ccw = ::wcslen( pwcsz ),
    cch = (ccw + 1) * 2 ;
    CHAR * psz = new CHAR [ cch ] ;
    if ( psz == NULL )
    {
        return NULL ;
    }

    //::wcstombs( psz, pwcsz, cch ) ;
    ::WideCharToMultiByte( CP_OEMCP, WC_COMPOSITECHECK, pwcsz, -1, psz, cch, NULL, NULL ) ;

    return psz ;
}

/*---------------------------------------------------------------------------
	UtilCstrDup
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CHAR * 
UtilCstrDup 
(
	const CHAR * psz
)
{
    CHAR * pszNew = new CHAR [ ::strlen( psz ) + 1 ] ;
    if ( pszNew == NULL )
    {
        return NULL ;
    }
    ::strcpy( pszNew, psz ) ;

    return pszNew ;
}

/*---------------------------------------------------------------------------
	cvtWcStrToStr
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
static HRESULT 
cvtWcStrToStr 
(
    char *			psz,
    size_t			cch,
    const WCHAR *	pwcsz,
    size_t			cwch 
)
{

#ifdef FE_SB
    int cchResult = ::WideCharToMultiByte( CP_ACP, 0,
                           pwcsz, -1,
                           psz, cch,
                           NULL, NULL ) ;
#else
    int cchResult = ::WideCharToMultiByte( CP_ACP, 0,
                           pwcsz, cwch,
                           psz, cwch,
                           NULL, NULL ) ;
#endif

    psz[ cchResult ] = 0 ;

    //return cchResult ? 0 : ::GetLastError();
	return cchResult ? NOERROR : E_FAIL;
}


wchar_t rgchHex[] = L"00112233445566778899aAbBcCdDeEfF";
/*---------------------------------------------------------------------------
	UtilCvtHexString
		Convert a string of hex digits to a byte array
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
UtilCvtHexString 
(
    LPCTSTR 	 pszNum,
    CByteArray & cByte
)
{
    int i = 0,
        iDig,
        iByte,
        cDig ;
    int iBase = 16 ;
    BOOL bByteBoundary ;

    //
    //  Skip leading blanks
    //
    for ( ; *pszNum == L' ' ; pszNum++ ) ;

    //
    //  Skip a leading zero
    //
    if ( *pszNum == L'0' )
    {
        pszNum++  ;
    }

    //
    //  Look for hexadecimal marker
    //
    if ( *pszNum == L'x' || *pszNum == L'X' )
    {
       pszNum++ ;
    }

    bByteBoundary = ::wcslen( pszNum ) % 2 ;

    for ( iByte = cDig = 0 ; *pszNum ; )
    {
        wchar_t * pszDig = ::wcschr( rgchHex, *pszNum++ ) ;
        if ( pszDig == NULL )
        {
			break;
            // return FALSE;
        }

        iDig = ((int) (pszDig - rgchHex)) / 2 ;
        if ( iDig >= iBase )
        {
            break ;
			// return FALSE;
        }

        iByte = (iByte * 16) + iDig ;

        if ( bByteBoundary )
        {
            cByte.SetAtGrow( cDig++, (UCHAR) iByte ) ;
            iByte = 0 ;
        }
        bByteBoundary = ! bByteBoundary ;
    }

    cByte.SetSize( cDig ) ;

    //
    //  Return TRUE if we reached the end of the string.
    //
    return *pszNum == 0 ;
}

/*---------------------------------------------------------------------------
	UtilCvtByteArrayToString
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
UtilCvtByteArrayToString 
(
    const CByteArray & abAddr,
    CString & str
)
{
    int i ;
    DWORD err = 0 ;

//    TRY
    {
        str.Empty() ;

        //
        //  The hex conversion string has two characters per nibble,
        //  to allow for upper case.
        //
        for ( i = 0 ; i < abAddr.GetSize() ; i++ )
        {
            int i1 = ((abAddr.GetAt(i) & 0xF0) >> 4) * 2 ,
                i2 = (abAddr.GetAt(i) & 0x0F) * 2 ;
                str += rgchHex[ i1 ] ;
                str += rgchHex[ i2 ] ;
        }
    }

//	CATCH(CMemoryException, pMemException)

//    if ( pMemException )
//    {
//        str.Empty() ;
//		err = 1;
//    }

    return err == 0 ;
}

/*---------------------------------------------------------------------------
	PchParseUnicodeString
		Parse a unicode string by copying its content
		into a CString object.
		The parsing ends when the null-terminator ('\0')is
		reached or the comma (',') is reached.

		Return pointer to the character where parsing
		ended('\0') or (',')

	Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR *
PchParseUnicodeString
(
	CONST WCHAR * szwString,	// IN: String to parse
    DWORD         dwLength,
	CString&      rString		// OUT: Content of the substring
)			
{
	ASSERT(szwString != NULL);
	ASSERT(BOOT_FILE_STRING_DELIMITER_W == L',');	// Just in case

	WCHAR szwBufferT[1024];		// Temporary buffer
	WCHAR * pchwDst = szwBufferT;

	while (*szwString != L'\0')
	{
		if (*szwString == BOOT_FILE_STRING_DELIMITER_W)
			break;
		*pchwDst++ = *szwString++;
        if ((DWORD) (pchwDst - szwBufferT) > dwLength)
        {   
            // we've gone past the end of our buffer!! ouch
            Panic0("PchParseUnicodeString: Gone past end of buffer");
            break;
        }
		
        ASSERT((pchwDst - szwBufferT < sizeof(szwBufferT)) && "Buffer overflow");		
	} // while

	*pchwDst = L'\0';
	rString = szwBufferT;	// Copy the string into the CString object
	
	return const_cast<WCHAR *>(szwString);
} // PchParseUnicodeString()


/////////////////////////////////////////////////////////////////////////////
//	FGetCtrlDWordValue()
//
//	Return a 32-bit unsigned integer from an edit control
//
//	This function is like GetDlgItemInt() except it accepts hexadecimal values,
//	has range checking and/or overflow checking.
//	If value is out of range, function will display a friendly message and will
//	set the focus to control.
//	Range: dwMin to dwMax inclusive
//	- If both dwMin and dwMax are zero, no range checking is performed
//	- Return TRUE if successful, otherwise FALSE
//	- On error, pdwValue remains unchanged.
//
BOOL FGetCtrlDWordValue(HWND hwndEdit, DWORD * pdwValue, DWORD dwMin, DWORD dwMax)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR szT[256];
        
    DWORD Len, dwResult;
    BOOL  Success;

    ASSERT(IsWindow(hwndEdit));
    ASSERT(pdwValue);
    ASSERT(dwMin <= dwMax);

    ::GetWindowText(hwndEdit, szT, (sizeof(szT)-1)/sizeof(TCHAR));
    szT[ 255 ] = _T('\0');
    Success = FCvtAsciiToInteger( szT, OUT &dwResult );
    *pdwValue = dwResult;
    if (( !Success ) || (dwResult < dwMin) || (dwResult > dwMax)) {
	CString strBuffer;
            
	strBuffer.LoadString( IDS_ERR_INVALID_INTEGER );
	::wsprintf( szT, strBuffer, dwMin, dwMax, dwMin, dwMax );

	ASSERT( wcslen( szT ) < sizeof( szT ));
	::SetFocus( hwndEdit );
	::AfxMessageBox( szT );
	::SetFocus( hwndEdit );
	return FALSE;
    } // if

    return TRUE;
} // FGetCtrlDWordValue


/////////////////////////////////////////////////////////////////////////////
//
//	Convert a string to a binary integer
//		- String is allowed to be decimal or hexadecimal
//		- Minus sign is not allowed
//	If successful, set *pdwValue to the integer and return TRUE.
//	If not successful (overflow or illegal integer) return FALSE.
//
BOOL
FCvtAsciiToInteger(
     IN const TCHAR * pszNum,
     OUT DWORD * pdwValue
)
{
    DWORD dwResult = 0;
    DWORD Res = 0;
    BOOL  IsHex = FALSE;
    LPWSTR Format;
    const TCHAR *pBuf;

    ASSERT(pszNum != NULL);
    ASSERT(pdwValue != NULL);
    
    pBuf = pszNum;

    //  Skip leading blanks and/or zeroes
    while (( *pszNum == _T(' ')) || 
	   ( *pszNum == _T('\t')) ||
	   ( *pszNum == _T('0'))) {
        pszNum++;
    }

    // If there is just '0' in the buffer, make sure we don't ignore it

    // Check if we are using hexadecimal base
    if (( *pszNum == _T('x')) || ( *pszNum == _T('X'))) {
	IsHex = TRUE;
	pszNum++;
    }
    else if (( pszNum != pBuf ) &&
	     ( *(pszNum - 1) == _T('0'))) {
	// back track the 0 we skipped
	pszNum--;
    }

    // -ve numbers are not valid
    if ( *pszNum == L'-' ) {
	*pdwValue = 0;
	return FALSE;
    }

    // if we are the end of the string, then return success 
    if ( *pszNum == L'\0' ) {
	*pdwValue = 0;
	return TRUE;
    }

    Format = ( IsHex ) ? L"%lx" : L"%lu";

    Res = swscanf( pszNum, Format, &dwResult );
    if ( Res == 0 ) {
	*pdwValue = 0;
	return FALSE;
    }

    ASSERT( Res == 1 );

    *pdwValue = dwResult;
    return TRUE;
} // FCvtAsciiToInteger


void UtilConvertStringToDwordDword(LPCTSTR pszString, DWORD_DWORD * pdwdw)
{
    ULARGE_INTEGER value;
    BOOL           hex = FALSE;

    value.QuadPart = 0;

    // skip white spaces
    while (( *pszString == L' ' ) ||
	   ( *pszString == L'\t' )) {
	pszString++;
    }

    hex = (( pszString[ 0 ] == L'0' ) &&
	   ( pszString[ 1 ] == L'x' )) 
	? TRUE : FALSE;
    if ( hex ) {
	if ( 1 != _stscanf( pszString + 2, _T( "%I64x" ), &value.QuadPart )) {
            value.QuadPart = 0;
        }
    }
    else { // decimal
        if ( 1 != _stscanf( pszString, _T( "%I64u" ), &value.QuadPart )) {
            value.QuadPart = 0;
        }
    }

    // Use 0 for all -ve numbers

    if ( *pszString == L'-' ) {
	value.QuadPart = 0;
    }

    pdwdw->DWord1 = value.HighPart;
    pdwdw->DWord2 = value.LowPart;
} // UtilConvertStringToDwordDword()

void UtilConvertDwordDwordToString(DWORD_DWORD * pdwdw, CString * pstrString, BOOL bDecimal)
{
    TCHAR szNum [ STRING_LENGTH_MAX ] ;
    ULARGE_INTEGER Temp;

    Temp.HighPart = pdwdw->DWord1;
    Temp.LowPart = pdwdw->DWord2;

    if (bDecimal)
    {
	::wsprintf( szNum, L"%I64u", Temp.QuadPart );
    }
    else
    {
        ::wsprintf( szNum, L"0x%I64x", Temp.QuadPart );
    }

    *pstrString = szNum ;
}

// End of DHCPUTIL.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/


#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>

#include <atlbase.h>
#include <htmlhelp.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>

extern "C"
{
	#include "dhcpapi.h"
	#include "winsock2.h"    //  WinSock definitions
	#include "lmerr.h"
	#include "dhcpopt.h"
    #include "mdhcsapi.h"   // mutlicast APIs
}

#include "resource.h"
#include "miscres.h"

// Global defines for DHCP snapin
#include "dhcpsnap.h"

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <dialog.h>

// project specific
#include "dhcpcomp.h"
#include "general.h"
#include "utils.h"
#include "helparr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\wsockmsg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corporation, 1993 - 1997 **/
/**********************************************************************/

/*
    wsockmsg.h

    This file is generated by the MC tool from the CKMMSG.MC message
    file.

*/


#ifndef _WSOCKMSG_H_
#define _WSOCKMSG_H_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WSA_ERR_EINTR
//
// MessageText:
//
//  Interrupted system call.
//
#define WSA_ERR_EINTR                    0x00002714L

//
// MessageId: WSA_ERR_EBADF
//
// MessageText:
//
//  Bad file number.
//
#define WSA_ERR_EBADF                    0x00002719L

//
// MessageId: WSA_ERR_EACCES
//
// MessageText:
//
//  Access denied.
//
#define WSA_ERR_EACCES                   0x0000271DL

//
// MessageId: WSA_ERR_EFAULT
//
// MessageText:
//
//  Bad address.
//
#define WSA_ERR_EFAULT                   0x0000271EL

//
// MessageId: WSA_ERR_EINVAL
//
// MessageText:
//
//  Invalid argument.
//
#define WSA_ERR_EINVAL                   0x00002726L

//
// MessageId: WSA_ERR_EMFILE
//
// MessageText:
//
//  Too many open files.
//
#define WSA_ERR_EMFILE                   0x00002728L

//
// MessageId: WSA_ERR_EWOULDBLOCK
//
// MessageText:
//
//  Operation would block.
//
#define WSA_ERR_EWOULDBLOCK              0x00002733L

//
// MessageId: WSA_ERR_EINPROGRESS
//
// MessageText:
//
//  Operation now in progress.
//
#define WSA_ERR_EINPROGRESS              0x00002734L

//
// MessageId: WSA_ERR_EALREADY
//
// MessageText:
//
//  Operation already in progress.
//
#define WSA_ERR_EALREADY                 0x00002735L

//
// MessageId: WSA_ERR_ENOTSOCK
//
// MessageText:
//
//  Socket operation on non-socket.
//
#define WSA_ERR_ENOTSOCK                 0x00002736L

//
// MessageId: WSA_ERR_EDESTADDRREQ
//
// MessageText:
//
//  Destination address required.
//
#define WSA_ERR_EDESTADDRREQ             0x00002737L

//
// MessageId: WSA_ERR_EMSGSIZE
//
// MessageText:
//
//  Message too long.
//
#define WSA_ERR_EMSGSIZE                 0x00002738L

//
// MessageId: WSA_ERR_EPROTOTYPE
//
// MessageText:
//
//  Protocol is wrong type for socket.
//
#define WSA_ERR_EPROTOTYPE               0x00002739L

//
// MessageId: WSA_ERR_ENOPROTOOPT
//
// MessageText:
//
//  Bad protocol option.
//
#define WSA_ERR_ENOPROTOOPT              0x0000273AL

//
// MessageId: WSA_ERR_EPROTONOSUPPORT
//
// MessageText:
//
//  Protocol not supported.
//
#define WSA_ERR_EPROTONOSUPPORT          0x0000273BL

//
// MessageId: WSA_ERR_ESOCKNOSUPPORT
//
// MessageText:
//
//  Socket type not supported.
//
#define WSA_ERR_ESOCKNOSUPPORT           0x0000273CL

//
// MessageId: WSA_ERR_EOPNOTSUPP
//
// MessageText:
//
//  Operation not supported on socket.
//
#define WSA_ERR_EOPNOTSUPP               0x0000273DL

//
// MessageId: WSA_ERR_EPFNOSUPPORT
//
// MessageText:
//
//  Protocol family not supported.
//
#define WSA_ERR_EPFNOSUPPORT             0x0000273EL

//
// MessageId: WSA_ERR_EAFNOSUPPORT
//
// MessageText:
//
//  Address family not supported by protocol family.
//
#define WSA_ERR_EAFNOSUPPORT             0x0000273FL

//
// MessageId: WSA_ERR_EADDRINUSE
//
// MessageText:
//
//  Address already in use.
//
#define WSA_ERR_EADDRINUSE               0x00002740L

//
// MessageId: WSA_ERR_EADDRNOTAVAIL
//
// MessageText:
//
//  Can't assign requested address.
//
#define WSA_ERR_EADDRNOTAVAIL            0x00002741L

//
// MessageId: WSA_ERR_ENETDOWN
//
// MessageText:
//
//  Network is down.
//
#define WSA_ERR_ENETDOWN                 0x00002742L

//
// MessageId: WSA_ERR_ENETUNREACH
//
// MessageText:
//
//  ICMP network unreachable.
//
#define WSA_ERR_ENETUNREACH              0x00002743L

//
// MessageId: WSA_ERR_ENETRESET
//
// MessageText:
//
//  Network was reset.
//
#define WSA_ERR_ENETRESET                0x00002744L

//
// MessageId: WSA_ERR_ECONNABORTED
//
// MessageText:
//
//  Software caused connection abort.
//
#define WSA_ERR_ECONNABORTED             0x00002745L

//
// MessageId: WSA_ERR_ECONNRESET
//
// MessageText:
//
//  Connection reset by peer.
//
#define WSA_ERR_ECONNRESET               0x00002746L

//
// MessageId: WSA_ERR_ENOBUFS
//
// MessageText:
//
//  No buffer space is supported.
//
#define WSA_ERR_ENOBUFS                  0x00002747L

//
// MessageId: WSA_ERR_EISCONN
//
// MessageText:
//
//  Socket is already connected.
//
#define WSA_ERR_EISCONN                  0x00002748L

//
// MessageId: WSA_ERR_ENOTCONN
//
// MessageText:
//
//  Socket is not connected.
//
#define WSA_ERR_ENOTCONN                 0x00002749L

//
// MessageId: WSA_ERR_ESHUTDOWN
//
// MessageText:
//
//  Can't send after socket shutdown.
//
#define WSA_ERR_ESHUTDOWN                0x0000274AL

//
// MessageId: WSA_ERR_ETOOMANYREFS
//
// MessageText:
//
//  Too many references.
//
#define WSA_ERR_ETOOMANYREFS             0x0000274BL

//
// MessageId: WSA_ERR_ETIMEDOUT
//
// MessageText:
//
//  Connection timed out.
//
#define WSA_ERR_ETIMEDOUT                0x0000274CL

//
// MessageId: WSA_ERR_ECONNREFUSED
//
// MessageText:
//
//  Connection refused.
//
#define WSA_ERR_ECONNREFUSED             0x0000274DL

//
// MessageId: WSA_ERR_ELOOP
//
// MessageText:
//
//  Too many levels of symbolic links.
//
#define WSA_ERR_ELOOP                    0x0000274EL

//
// MessageId: WSA_ERR_ENAMETOOLONG
//
// MessageText:
//
//  Name too long.
//
#define WSA_ERR_ENAMETOOLONG             0x0000274FL

//
// MessageId: WSA_ERR_EHOSTDOWN
//
// MessageText:
//
//  Host is down.
//
#define WSA_ERR_EHOSTDOWN                0x00002750L

//
// MessageId: WSA_ERR_EHOSTUNREACH
//
// MessageText:
//
//  Host is unreachable.
//
#define WSA_ERR_EHOSTUNREACH             0x00002751L

//
// MessageId: WSA_ERR_ENOTEMPTY
//
// MessageText:
//
//  Directory not empty.
//
#define WSA_ERR_ENOTEMPTY                0x00002752L

//
// MessageId: WSA_ERR_EPROCLIM
//
// MessageText:
//
//  EPROCLIM returned.
//
#define WSA_ERR_EPROCLIM                 0x00002753L

//
// MessageId: WSA_ERR_EUSERS
//
// MessageText:
//
//  EUSERS returned.
//
#define WSA_ERR_EUSERS                   0x00002754L

//
// MessageId: WSA_ERR_EDQUOT
//
// MessageText:
//
//  Disk quota exceeded.
//
#define WSA_ERR_EDQUOT                   0x00002755L

//
// MessageId: WSA_ERR_ESTALE
//
// MessageText:
//
//  ESTALE returned.
//
#define WSA_ERR_ESTALE                   0x00002756L

//
// MessageId: WSA_ERR_EREMOTE
//
// MessageText:
//
//  The object is remote.
//
#define WSA_ERR_EREMOTE                  0x00002757L

//
// MessageId: WSA_ERR_SYSNOTREADY
//
// MessageText:
//
//  System not ready.
//
#define WSA_ERR_SYSNOTREADY              0x0000276BL

//
// MessageId: WSA_ERR_VERNOTSUPPORTED
//
// MessageText:
//
//  Version is not supported.
//
#define WSA_ERR_VERNOTSUPPORTED          0x0000276CL

//
// MessageId: WSA_ERR_NOTINITIALISED
//
// MessageText:
//
//  Not initialized.
//
#define WSA_ERR_NOTINITIALISED           0x0000276DL

//
// MessageId: WSA_ERR_EDISCON
//
// MessageText:
//
//  Disconnected.
//
#define WSA_ERR_EDISCON                  0x00002775L

//
// MessageId: WSA_ERR_HOST_NOT_FOUND
//
// MessageText:
//
//  Host not found.
//
#define WSA_ERR_HOST_NOT_FOUND           0x00002AF9L

//
// MessageId: WSA_ERR_TRY_AGAIN
//
// MessageText:
//
//  Try again.
//
#define WSA_ERR_TRY_AGAIN                0x00002AFAL

//
// MessageId: WSA_ERR_NO_RECOVERY
//
// MessageText:
//
//  Non-recoverable error.
//
#define WSA_ERR_NO_RECOVERY              0x00002AFBL

//
// MessageId: WSA_ERR_NO_DATA
//
// MessageText:
//
//  No data record available.
//
#define WSA_ERR_NO_DATA                  0x00002AFCL


#endif  // _WSOCKMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\utils.h ===
/**********************************************************************/
/**     		  Microsoft Windows NT  		     **/
/**     	   Copyright(c) Microsoft Corporation, 1991 - 1998 	     **/
/**********************************************************************/

/*
	utils.h
	    Utility routine header file for DHCPSNAP.DLL

    FILE HISTORY:
		DavidHov	6/15/93 	Created
		EricDav		2/13/97		Updated 
*/

#if !defined(_DHCPUTIL_H_)
#define _DHCPUTIL_H_

enum ENUM_HOST_NAME_TYPE 
{
     HNM_TYPE_INVALID,
     HNM_TYPE_IP,
     HNM_TYPE_DNS,
     HNM_TYPE_NB,
     HNM_TYPE_MAX
};

#define DHCPSNAP_STRING_MAX  			256
#define DHCPSNAP_COMPUTER_NAME_MAX   	20

extern wchar_t rgchHex[];

typedef struct
{
    DHCP_IP_ADDRESS _dhipa ;    						//   IP Address
    TCHAR _chHostName [DHCPSNAP_STRING_MAX*2] ; 			//   Host DNS name
    TCHAR _chNetbiosName [DHCPSNAP_STRING_MAX*2] ;  //   Host NetBIOS name (if known)
} DHC_HOST_INFO_STRUCT ;

int
UtilGetOptionPriority(int nOpt1, int nOpt2);

BOOL
UtilGetFolderName(CString & strInitialPath, CString& strHelpText, CString& strSelectedPath);

void  
UtilConvertLeaseTime(DWORD dwLeaseTime, int *pnDays, int *pnHours, int *pnMinutes);

DWORD 
UtilConvertLeaseTime(int pnDays, int pnHours, int pnMinutes);

ENUM_HOST_NAME_TYPE
UtilCategorizeName (LPCTSTR pszName);

//  Convert a string to an IP address
extern DHCP_IP_ADDRESS 
UtilCvtStringToIpAddr 
(
	const CHAR * pszString
);

extern DHCP_IP_ADDRESS
UtilCvtWstrToIpAddr 
(
    const LPCWSTR pcwString
);


//  Convert an IP address into a displayable string

extern void 
UtilCvtIpAddrToString 
(
    DHCP_IP_ADDRESS dhipa,
    CHAR * pszString,
    UINT cBuffSize
);

extern BOOL
UtilCvtIpAddrToWstr 
(
    DHCP_IP_ADDRESS		dhipa,
	CString *			pstrIpAddress
);


extern BOOL 
UtilCvtIpAddrToWstr 
(
    DHCP_IP_ADDRESS dhipa,
    WCHAR * pwcszString,
    INT cBuffCount
);

extern WCHAR * 
UtilDupIpAddrToWstr 
(
    DHCP_IP_ADDRESS dhipa 
);

//  "strdup" for C++ wcstrs.
extern WCHAR * 
UtilWcstrDup 
(
    const WCHAR * pwcsz,
    INT * pccwLength = NULL 
);

extern WCHAR * 
UtilWcstrDup 
(
    const CHAR * psz,
    INT * pccwLength = NULL
);

extern CHAR * 
UtilCstrDup 
(
    const WCHAR * pwcsz
);

extern CHAR * 
UtilCstrDup 
(
    const CHAR * psz 
);

//  Return a standard information structure for the given
//  host IP address

extern DWORD
UtilGetHostInfo 
(
    DHCP_IP_ADDRESS dhipa,
    DHC_HOST_INFO_STRUCT * pdhsrvi
);


//  Return the IP address of this host machine

extern HRESULT 
UtilGetLocalHostAddress 
(
    DHCP_IP_ADDRESS * pdhipa
);

extern HRESULT 
UtilGetHostAddressFQDN
(
    LPCTSTR				pszHostName,
    CString *           pstrFQDN,
    DHCP_IP_ADDRESS *	pdhipa
);

extern HRESULT 
UtilGetHostAddress 
(
    LPCTSTR			  pszHostName,
    DHCP_IP_ADDRESS * pdhipa
);

extern HRESULT 
UtilGetLocalHostName
(
    CString * pstrName
);

extern HRESULT 
UtilGetNetbiosAddress 
(
    LPCTSTR           pszNetbiosName,
    DHCP_IP_ADDRESS * pdhipa
);


extern BOOL
UtilCvtHexString 
(
    LPCTSTR		 pszNum,
    CByteArray & cByte
);

extern BOOL
UtilCvtByteArrayToString 
(
    const CByteArray & abAddr,
    CString & str
);

WCHAR * 
PchParseUnicodeString
(
	CONST WCHAR *   szwString, 
    DWORD           dwLength,
	CString&        rString
);

BOOL FGetCtrlDWordValue(HWND hwndEdit, DWORD * pdwValue, DWORD dwMin, DWORD dwMax);

//  Convert ASCII string of decimal or hex numbers to binary integer
BOOL FCvtAsciiToInteger(IN const TCHAR * pszNum, OUT DWORD * pdwValue);

void UtilConvertStringToDwordDword(LPCTSTR pszString, DWORD_DWORD * pdwdw);
void UtilConvertDwordDwordToString(DWORD_DWORD * pdwdw, CString * pstrString, BOOL bDecimal);

#endif  //  _DHCPUTIL_H_

// End of DHCPUTIL.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dialin.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   dialin.cpp
      Implementationof CRasDialin class, this class implements COM
      interfaces IUnknown, IShellExtInit, IShellPropSheetExt to extend
      User object's property sheet.

    FILE HISTORY:

*/

#include "stdafx.h"
#include "Dialin.h"
#include "DlgDial.h"
#include <dsrole.h>
#include <lmserver.h>
#include <localsec.h>
#include <dsgetdc.h>
#include <mmc.h>
#include <adsprop.h>
#include <sdowrap.h>
#include "sharesdo.h"
#include "iastrace.h"

#ifdef __cplusplus
extern "C"{
#endif


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRasDialin = {0xB52C1E4F,0x1DD2,0x11D1,{0xBC,0x43,0x00,0xC0,0x4F,0xC3,0x1F,0xD3}};


const IID LIBID_RASDIALLib = {0xB52C1E42,0x1DD2,0x11D1,{0xBC,0x43,0x00,0xC0,0x4F,0xC3,0x1F,0xD3}};


const CLSID CLSID_RasDialin = {0xB52C1E50,0x1DD2,0x11D1,{0xBC,0x43,0x00,0xC0,0x4F,0xC3,0x1F,0xD3}};


#ifdef __cplusplus
}
#endif

static ULONG_PTR g_cfMachineName = 0;
static ULONG_PTR g_cfDisplayName = 0;
LONG  g_lComponentDataSessions = 0;


/////////////////////////////////////////////////////////////////////////////
// CRasDialin
CRasDialin::CRasDialin()
{
   m_pPage = NULL;
   m_pMergedPage = NULL;

   m_pwszObjName = NULL;
   m_pwszClass = NULL;
   ZeroMemory(&m_ObjMedium, sizeof(m_ObjMedium));
   m_ObjMedium.tymed =TYMED_HGLOBAL;
   m_ObjMedium.hGlobal = NULL;
   m_bShowPage = TRUE;
}

CRasDialin::~CRasDialin()
{
   // stgmedia
// delete m_pPage;
   ReleaseStgMedium(&m_ObjMedium);
}


//===============================================================================
// IShellExtInit::Initialize
//
// information of the user object is passed in via parameter pDataObject
// further processing will be based on the DN of the user object

STDMETHODIMP CRasDialin::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hRegKey)
{
   IASTraceString("CRasDialin::Initialize()");
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   ASSERT (pDataObj != NULL);

   // get the object name out of the pDataObj
   HRESULT     hr = S_OK;

   IASTracePrintf("RegisterClipboardFormat %s", CFSTR_DSOBJECTNAMES);
   ULONG_PTR cfDsObjectNames = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
   IASTracePrintf(" %x", cfDsObjectNames);
   FORMATETC fmte = {cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   LPDSOBJECTNAMES pDsObjectNames;
    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
   IASTraceString("pDataObj->GetData returns");
   CHECK_HR(hr = pDataObj->GetData(&fmte, &m_ObjMedium));
   IASTracePrintf(" %x", hr);
   pDsObjectNames = (LPDSOBJECTNAMES)m_ObjMedium.hGlobal;
   if (pDsObjectNames->cItems < 1)
   {
      ASSERT (0);
      return E_FAIL;
   }

   m_bShowPage = TRUE;

   if(m_bShowPage)
   {
      // get the name of the object
      m_pwszObjName = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetName);

      // get the class name of the object
      m_pwszClass = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);

      IASTracePrintf("UserPath %s", m_pwszObjName);

      HWND hNotifyObj;
      hr = ADsPropCreateNotifyObj(
              pDataObj,
              m_pwszObjName,
              &hNotifyObj
              );
      if (FAILED(hr))
      {
         return hr;
      }

      try{
         ASSERT(!m_pMergedPage);
         CString machineName;

         m_pMergedPage = new CDlgRASDialinMerge(
                                RASUSER_ENV_DS,
                                NULL,
                                m_pwszObjName,
                                hNotifyObj
                                );

         IASTracePrintf("new Dialin page object %x", m_pMergedPage);
         ASSERT(m_pMergedPage);

#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
         IASTraceString("HrGetDCName returns ");
         CHECK_HR(hr = m_pMergedPage->HrGetDCName(machineName));
         IASTracePrintf("%x",hr);
         IASTraceString("HrGetSharedSdoServer returns ");

         // ignore return value:
         // reason: marshalling could fail in case this call was made from different thread,
         // before the pointer is used, it will be checked again
         GetSharedSdoServer((LPCTSTR)machineName, NULL, NULL, NULL, m_pMergedPage->GetMarshalSdoServerHolder());
         IASTracePrintf("%x", hr);
#endif
      }
      catch (CException* e)
      {
         hr = COleException::Process(e);
         e->Delete();
      }
   }

L_ERR:
   IASTracePrintf("%x", hr);
    return hr;
}

//
//  FUNCTION: IShellPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//

STDMETHODIMP CRasDialin::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
   IASTraceString("CRasDialin::AddPages()");

   if(!m_bShowPage)  return S_OK;

   HRESULT  hr = S_OK;

   // param validation
   ASSERT (lpfnAddPage);
    if (lpfnAddPage == NULL)
        return E_UNEXPECTED;

   // make sure our state is fixed up (cause we don't know what context we were called in)
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ASSERT(m_pMergedPage);

    // tell MMC to hook the proc because we are running on a separate,
      // non MFC thread.
   m_pMergedPage->m_psp.pfnCallback = &CDlgRASDialinMerge::PropSheetPageProc;

   // We also need to save a self-reference so that the static callback
   // function can recover a "this" pointer
   m_pMergedPage->m_psp.lParam = (LONG_PTR)m_pMergedPage;

   MMCPropPageCallback(&m_pMergedPage->m_psp);

   HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&m_pMergedPage->m_psp);

   ASSERT (hPage);
   if (hPage == NULL)
      return E_UNEXPECTED;
      // add the page
   lpfnAddPage (hPage, lParam);


   m_pPage = NULL;   // since it's just consumed by the dialog, cannot added again

    return S_OK;
}

//
//  FUNCTION: IShellPropSheetExt::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP CRasDialin::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    IASTraceString("CRasDialin::ReplacePage()");
    return E_FAIL;
}


/*---------------------------------------------------------------------------
    IExtendPropertySheet Implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    IExtendPropertySheet::QueryPagesFor
        MMC calls this to see if a node has property pages
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CRasDialin::QueryPagesFor
(
    LPDATAOBJECT pDataObject
)
{
   return S_OK;
}


/*!--------------------------------------------------------------------------
    TFSComponentData::CreatePropertyPages
        Implementation of IExtendPropertySheet::CreatePropertyPages
        Called for a node to put up property pages
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CRasDialin::CreatePropertyPages
(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR                    handle,
    LPDATAOBJECT            pDataObject
)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   FORMATETC               fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   STGMEDIUM               mediumMachine = { TYMED_HGLOBAL, NULL, NULL };
   STGMEDIUM               mediumUser = { TYMED_HGLOBAL, NULL, NULL };

   HGLOBAL          hMem = GlobalAlloc(GMEM_SHARE, MAX_PATH * sizeof(WCHAR));
   mediumMachine.hGlobal = hMem;

   hMem = GlobalAlloc(GMEM_SHARE, MAX_PATH * sizeof(WCHAR));
   mediumUser.hGlobal = hMem;

   HRESULT        hr = S_OK;
   DWORD         dwError;
   LPWSTR        pMachineName = NULL;
   LPWSTR        pUserName = NULL;
   SERVER_INFO_102* pServerInfo102 = NULL;
   NET_API_STATUS   netRet = 0;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdsRole = NULL;

   //==================================================================

   // check if the machine is a standalone NT5 server
   // check if the machine focused on is NT5 machine
   if ( !g_cfMachineName )
        g_cfMachineName = RegisterClipboardFormat(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);

   fmte.cfFormat = g_cfMachineName;

   CHECK_HR( hr = pDataObject->GetDataHere(&fmte, &mediumMachine));
   pMachineName = (LPWSTR)mediumMachine.hGlobal;

   ASSERT(pMachineName);

   if(!pMachineName)   CHECK_HR(hr = E_INVALIDARG);

   if (g_cfDisplayName == 0)
      g_cfDisplayName = RegisterClipboardFormat(CCF_DISPLAY_NAME);


   fmte.cfFormat = g_cfDisplayName;

   CHECK_HR( hr = pDataObject->GetDataHere(&fmte, &mediumUser));
   pUserName = (LPWSTR)mediumUser.hGlobal;

   ASSERT(pUserName);

   if(!pUserName)
      CHECK_HR(hr = E_INVALIDARG);

   ASSERT(!m_pMergedPage);

   try{
      m_pMergedPage = new CDlgRASDialinMerge(
                             RASUSER_ENV_LOCAL,
                             pMachineName,
                             pUserName,
                             NULL
                             );

#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
      CHECK_HR(hr = GetSharedSdoServer(pMachineName, NULL, NULL, NULL, m_pMergedPage->GetMarshalSdoServerHolder()));
#endif

      // tell MMC to hook the proc because we are running on a separate,
      // non MFC thread.
      m_pMergedPage->m_psp.pfnCallback = &CDlgRASDialinMerge::PropSheetPageProc;

      // We also need to save a self-reference so that the static callback
      // function can recover a "this" pointer
      m_pMergedPage->m_psp.lParam = (LONG_PTR)m_pMergedPage;

      MMCPropPageCallback(&m_pMergedPage->m_psp);

      HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&m_pMergedPage->m_psp);
      if(hPage == NULL)
         return E_UNEXPECTED;

      lpProvider->AddPage(hPage);
   }catch(CMemoryException* pException){
      pException->Delete();
      delete m_pMergedPage;
      m_pMergedPage = NULL;
      CHECK_HR(hr = E_OUTOFMEMORY);
   }

L_ERR:
   if FAILED(hr)
      ReportError(hr, IDS_ERR_PROPERTYPAGE, NULL);

   if(pUserName)
      GlobalFree(pUserName);

   if(pMachineName)
      GlobalFree(pMachineName);

   if(pServerInfo102)
      NetApiBufferFree(pServerInfo102);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dialin.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   dialin.h
      Class CRASDialin definition. This class implements COM interfaces:
      IUnknown
      IShellExtInit, IShellPropSheetExt
         -- to extend User object's property sheet,
      IRasDialin -- currently, no method is implemented, it'll be useful
         when part of the UI need to be reused

    FILE HISTORY:
      12/15/97    Modified WeiJiang -- localsec snapin in User node extension

*/


#ifndef __RASDIALIN_H_
#define __RASDIALIN_H_

#include <rtutils.h>
#include "resource.h"       // main symbols
#include "helper.h"
#include "iastrace.h"

EXTERN_C const CLSID CLSID_RasDialin;


class CDlgRASDialin;
class CDlgRASDialinMerge;

#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
extern LONG g_lComponentDataSessions;
#endif

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

class CDoNothingComponent :
   public CComObjectRoot,
   public IComponent
{
public:
BEGIN_COM_MAP(CDoNothingComponent)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

   // IComponent
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
        /* [in] */ LPCONSOLE lpConsole) SAYOK;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param) SAYOK;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy(
        /* [in] */ MMC_COOKIE cookie) SAYOK;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) NOIMP;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType(
        /* [in] */ MMC_COOKIE cookie,
        /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
        /* [out] */ long __RPC_FAR *pViewOptions) NOIMP;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem) NOIMP;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB) SAYOK;
};

/////////////////////////////////////////////////////////////////////////////
// CRasDialin
//class ATL_NO_VTABLE CRasDialin :
class CRasDialin :
   public CComObjectRoot,
   public CComCoClass<CRasDialin, &CLSID_RasDialin>,
   public IShellExtInit,         // shell property page extension -- DS user
   public IShellPropSheetExt,    // shell property page extension -- DS user
#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
   public IComponentData,
#endif
   public IExtendPropertySheet,     // Snapin node property page extension
   private IASTraceInitializer
{
public:
   CRasDialin();
   virtual ~CRasDialin();

BEGIN_COM_MAP(CRasDialin)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
    COM_INTERFACE_ENTRY(IComponentData)
#endif
END_COM_MAP()

// IRasDialin
public:

   //IShellExtInit methods
   STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

   // IExtendPropertySheet :: added by WeiJiang 12/15/97 to support local sec extension
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle, LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    DECLARE_REGISTRY(CRasDialin, _T("RasDialin.UserAdminExt.1"), _T("RasDialin.UserAdminExt"), 0, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID(){ return CLSID_RasDialin; };

#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users

    // IComponentData
    STDMETHOD(Initialize)(/* [in] */ LPUNKNOWN pUnknown)
    {
      InterlockedIncrement(&g_lComponentDataSessions);
      return S_OK;
    };

    STDMETHOD(CreateComponent)(/* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
    {
      CComObject<CDoNothingComponent>* pComp = NULL;
      HRESULT              hr = S_OK;

      hr = CComObject<CDoNothingComponent>::CreateInstance(&pComp);

      if(hr == S_OK && pComp)
      {
         hr = pComp->QueryInterface(IID_IComponent, (void**)ppComponent);
      }

      return hr;
    };

    STDMETHOD(Notify)(
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) SAYOK;

   STDMETHOD(Destroy)( void)
   {
      LONG  l = InterlockedDecrement(&g_lComponentDataSessions);

      if (l == 0)
      {
         delete g_pSdoServerPool;
         g_pSdoServerPool = NULL;

      }

      ASSERT(l >= 0);

      return S_OK;

   };

    STDMETHOD(QueryDataObject)(
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) NOIMP;

    STDMETHOD(GetDisplayInfo)(
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem) NOIMP;

    STDMETHOD(CompareObjects)(
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) NOIMP;
#endif

#ifdef   _REGDS
   // registration of user object extension
   // only for testing purpose, retail version will have these information
   // register by setup program
   static HRESULT RegisterAdminPropertyPage(bool bRegister);
#endif

    LPWSTR        m_pwszObjName;
    LPWSTR        m_pwszClass;
   CDlgRASDialin* m_pPage;
   CDlgRASDialinMerge*  m_pMergedPage;
   STGMEDIUM      m_ObjMedium;
   BOOL        m_bShowPage;
};

#endif //__RASDIALIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgdial.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dlgdial.h
		This file contains the definition for CDlgRASDialin property page, this
		is the page appears on the User Object Property sheet tab "Ras Dial-in"

    FILE HISTORY:

*/

#if !defined(AFX_DLGRASDIALIN_H__FFB0722F_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_)
#define AFX_DLGRASDIALIN_H__FFB0722F_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_

#include "helper.h"
#include "rasdial.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgRASDialin.h : header file
//
#include "resource.h"		// definition for resource IDs

// By WeiJiang 2/6/98
// The merge dialog is ues to merge with IAS
// this eventually will replace the orginal dialog
/////////////////////////////////////////////////////////////////////////////
// CDlgRASDialinMerge dialog

class CDlgRASDialinMerge : public CPropertyPage, public CRASUserMerge
{
    DECLARE_DYNAMIC(CDlgRASDialinMerge)
		// Construction
private:
	CDlgRASDialinMerge();   // standard constructor
public:
	CDlgRASDialinMerge(
      RasEnvType type,
      LPCWSTR location,
      LPCWSTR userPath,
      HWND notifyObj
      );
	virtual ~CDlgRASDialinMerge();

// Dialog Data
	//{{AFX_DATA(CDlgRASDialinMerge)
	enum { IDD = IDD_RASDIALIN_MERGE };
   PADS_ATTR_INFO m_pWritableAttrs;
	CButton	m_CheckStaticIPAddress;
	CButton	m_CheckCallerId;
	CButton	m_CheckApplyStaticRoutes;
	CButton	m_RadioNoCallback;
	CButton	m_RadioSetByCaller;
	CButton	m_RadioSecureCallbackTo;
	CEdit	m_EditCallerId;
	CEdit	m_EditCallback;
	CButton	m_ButtonStaticRoutes;
	BOOL	m_bApplyStaticRoutes;
	int		m_nCurrentProfileIndex;
	int		m_nCallbackPolicy;
	BOOL	m_bCallingStationId;
	BOOL	m_bOverride;
	int		m_nDialinPermit;
	//}}AFX_DATA

	CWnd*				m_pEditIPAddress;	// Static IP Address control
	BOOL				m_bStaticIPAddress;
	CString				m_strCallingStationId;

	BOOL				m_bInitFailed;	// when this is true, most of the dialog functions will be called
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgRASDialinMerge)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	void SetModified( BOOL bChanged = TRUE )
	{
		m_bModified = bChanged;
		CPropertyPage::SetModified(bChanged);
	};

	BOOL GetModified()
	{
		return m_bModified;
	};

// Implementation
protected:

   BOOL IsPropertyWritable(const wchar_t* propName) const throw ();

	// Enable the dialog items for each group
	void EnableAccessControl(BOOL bEnable = true);
	void EnableStaticRoutes(BOOL bEnable = true);
	void EnableIPAddress(BOOL bEnable = true);
	void EnableCallback(BOOL bEnable = true);
	void EnableCallerId(BOOL bEnable = true);

	// Enable/Disable all items on the dialog
	void EnableDialinSettings();

	// set internal variables to original state
	void Reset();

	// Generated message map functions
	//{{AFX_MSG(CDlgRASDialinMerge)
	afx_msg void OnButtonStaticRoutes();
	afx_msg void OnCheckApplyStaticRoutes();
	afx_msg void OnCheckCallerId();
	afx_msg void OnRadioSecureCallbackTo();
	afx_msg void OnRadioNoCallback();
	afx_msg void OnRadioSetByCaller();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckStaticIPAddress();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeEditcallback();
	afx_msg void OnChangeEditcallerid();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPermitAllow();
	afx_msg void OnPermitDeny();
	afx_msg void OnPermitPolicy();
	afx_msg void OnFieldchangedEditipaddress(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:

	//=====================================================
	// Overload the virtual functions defined in CRASUser

	// To load the RASUser object
	virtual HRESULT Load();

protected:

    LPFNPSPCALLBACK      m_pfnOriginalCallback;
    BOOL				 m_bModified;
public:
    static UINT CALLBACK PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGRASDIALIN_H__FFB0722F_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgdial.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   dlgdial.cpp
      This files contains the implementation of class CDlgRasDialin
      which is the class to represent the property page appears on
      user object property sheet as tab "RAS dial-in"

    FILE HISTORY:

*/

#include "stdafx.h"
#include <sspi.h>
#include <secext.h>
#include <raserror.h>
#include <adsprop.h>

#include "helper.h"
#include "resource.h"
#include "DlgDial.h"
#include "DlgRoute.h"
#include "profsht.h"
#include "helptable.h"
#include "rasprof.h"
#include "commctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const wchar_t* ALLOW_DIALIN_NAME = L"msNPAllowDialin";
const wchar_t* NP_CALLING_STATION_ID_NAME = L"msNPCallingStationID";
const wchar_t* CALLBACK_NUMBER_NAME = L"msRADIUSCallbackNumber";
const wchar_t* FRAMED_IP_ADDRESS_NAME = L"msRADIUSFramedIPAddress";
const wchar_t* FRAMED_ROUTE_NAME = L"msRADIUSFramedRoute";
const wchar_t* SERVICE_TYPE_NAME = L"msRADIUSServiceType";

/////////////////////////////////////////////////////////////////////////////
// CDlgRASDialinMerge dialog

IMPLEMENT_DYNAMIC(CDlgRASDialinMerge, CPropertyPage)
CDlgRASDialinMerge::~CDlgRASDialinMerge()
{
   Reset();
}

CDlgRASDialinMerge::CDlgRASDialinMerge()
   : CPropertyPage(CDlgRASDialinMerge::IDD),
   CRASUserMerge(RASUSER_ENV_LOCAL, NULL, NULL)
{
   // initialize the memebers
   Reset();
}
CDlgRASDialinMerge::CDlgRASDialinMerge(
                       RasEnvType type,
                       LPCWSTR location,
                       LPCWSTR userPath,
                       HWND notifyObj
                       )
   : CPropertyPage(CDlgRASDialinMerge::IDD),
     CRASUserMerge(type, location, userPath)
{
   if (type == RASUSER_ENV_DS)
   {
      ADSPROPINITPARAMS initParams;
      initParams.dwSize = sizeof (ADSPROPINITPARAMS);
      if (!ADsPropGetInitInfo(notifyObj, &initParams))
      {
         AfxThrowOleException(E_FAIL);
      }
      if (FAILED(initParams.hr))
      {
         AfxThrowOleException(initParams.hr);
      }

      m_pWritableAttrs = initParams.pWritableAttrs;
   }
   else
   {
      m_pWritableAttrs = NULL;
   }

   // initialize the memebers
   Reset();
}

void CDlgRASDialinMerge::Reset()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   //{{AFX_DATA_INIT(CDlgRASDialinMerge)
   m_bApplyStaticRoutes = FALSE;
   m_nCurrentProfileIndex = 0;
   m_bCallingStationId = FALSE;
   m_bOverride = FALSE;
   m_nDialinPermit = -1;
   //}}AFX_DATA_INIT

   // Need to save the original callback pointer because we are replacing
   // it with our own
   m_pfnOriginalCallback = m_psp.pfnCallback;

   m_pEditIPAddress = NULL;

   // init for using IPAddress common control
   INITCOMMONCONTROLSEX INITEX;
   INITEX.dwSize = sizeof(INITCOMMONCONTROLSEX);
   INITEX.dwICC = ICC_INTERNET_CLASSES;
   ::InitCommonControlsEx(&INITEX);

   m_bInitFailed = FALSE;
   m_bModified = FALSE;
}

void CDlgRASDialinMerge::DoDataExchange(CDataExchange* pDX)
{
   if(m_bInitFailed)
      return;

/*
   USHORT
   WINAPI
   CompressPhoneNumber(
      IN  LPWSTR Uncompressed,
       OUT LPWSTR Compressed
      );
*/

   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgRASDialinMerge)
   DDX_Control(pDX, IDC_CHECKSTATICIPADDRESS, m_CheckStaticIPAddress);
   DDX_Control(pDX, IDC_CHECKCALLERID, m_CheckCallerId);
   DDX_Control(pDX, IDC_CHECKAPPLYSTATICROUTES, m_CheckApplyStaticRoutes);
   DDX_Control(pDX, IDC_RADIONOCALLBACK, m_RadioNoCallback);
   DDX_Control(pDX, IDC_RADIOSETBYCALLER, m_RadioSetByCaller);
   DDX_Control(pDX, IDC_RADIOSECURECALLBACKTO, m_RadioSecureCallbackTo);
   DDX_Control(pDX, IDC_EDITCALLERID, m_EditCallerId);
   DDX_Control(pDX, IDC_EDITCALLBACK, m_EditCallback);
   DDX_Control(pDX, IDC_BUTTONSTATICROUTES, m_ButtonStaticRoutes);
   DDX_Check(pDX, IDC_CHECKAPPLYSTATICROUTES, m_bApplyStaticRoutes);
   DDX_Radio(pDX, IDC_RADIONOCALLBACK, m_nCallbackPolicy);
   DDX_Check(pDX, IDC_CHECKCALLERID, m_bCallingStationId);
   DDX_Check(pDX, IDC_CHECKSTATICIPADDRESS, m_bOverride);
   DDX_Radio(pDX, IDC_PERMIT_ALLOW, m_nDialinPermit);
   //}}AFX_DATA_MAP

   DDX_Text(pDX, IDC_EDITCALLERID, m_strCallingStationId);
   DDX_Text(pDX, IDC_EDITCALLBACK, m_strCallbackNumber);
   if(S_OK == HrIsInMixedDomain() || m_type == RASUSER_ENV_LOCAL) // user in mixed domain
   {
      DWORD dwErr = 0;
      typedef USHORT (WINAPI *COMPRESSCALLBACKFUNC)(
                        IN  LPWSTR Uncompressed,
                        OUT LPWSTR Compressed);

      WCHAR tempBuf[RAS_CALLBACK_NUMBER_LEN_NT4 + 2];

      DDV_MaxChars(pDX, m_strCallbackNumber, RAS_CALLBACK_NUMBER_LEN_NT4);

      COMPRESSCALLBACKFUNC    pfnCompressCallback = NULL;
      HMODULE                hMprApiDLL      = NULL;

      hMprApiDLL = LoadLibrary(_T("mprapi.dll"));
      if ( NULL != hMprApiDLL )
      {
         // load the API pointer
         pfnCompressCallback = (COMPRESSCALLBACKFUNC) GetProcAddress(hMprApiDLL, "CompressPhoneNumber");
         if(NULL != pfnCompressCallback)
         {

            dwErr = pfnCompressCallback((LPTSTR)(LPCTSTR)m_strCallbackNumber, tempBuf);
            switch(dwErr)
            {
            case  ERROR_BAD_LENGTH:
               AfxMessageBox(IDS_ERR_CALLBACK_TOO_LONG);
               pDX->Fail();
               break;
            case  ERROR_BAD_CALLBACK_NUMBER:
               AfxMessageBox(IDS_ERR_CALLBACK_INVALID);
               pDX->Fail();
               break;
            }
         }
      }

   }
   else
   {
      DDV_MaxChars(pDX, m_strCallbackNumber, RAS_CALLBACK_NUMBER_LEN);
   }
   if(pDX->m_bSaveAndValidate)      // save data to this class
   {
      // ip adress control
      if(m_pEditIPAddress->SendMessage(IPM_GETADDRESS, 0, (LPARAM)&m_dwFramedIPAddress))
         m_bStaticIPAddress = TRUE;
      else
         m_bStaticIPAddress = FALSE;
   }
   else     // put to dialog
   {
      // ip adress control
      if(m_bStaticIPAddress)
         m_pEditIPAddress->SendMessage(IPM_SETADDRESS, 0, m_dwFramedIPAddress);
      else
         m_pEditIPAddress->SendMessage(IPM_CLEARADDRESS, 0, m_dwFramedIPAddress);
   }
}


BEGIN_MESSAGE_MAP(CDlgRASDialinMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CDlgRASDialinMerge)
   ON_BN_CLICKED(IDC_BUTTONSTATICROUTES, OnButtonStaticRoutes)
   ON_BN_CLICKED(IDC_CHECKAPPLYSTATICROUTES, OnCheckApplyStaticRoutes)
   ON_BN_CLICKED(IDC_CHECKCALLERID, OnCheckCallerId)
   ON_BN_CLICKED(IDC_RADIOSECURECALLBACKTO, OnRadioSecureCallbackTo)
   ON_BN_CLICKED(IDC_RADIONOCALLBACK, OnRadioNoCallback)
   ON_BN_CLICKED(IDC_RADIOSETBYCALLER, OnRadioSetByCaller)
   ON_BN_CLICKED(IDC_CHECKSTATICIPADDRESS, OnCheckStaticIPAddress)
   ON_WM_HELPINFO()
   ON_WM_CONTEXTMENU()
   ON_EN_CHANGE(IDC_EDITCALLBACK, OnChangeEditcallback)
   ON_EN_CHANGE(IDC_EDITCALLERID, OnChangeEditcallerid)
   ON_WM_CREATE()
   ON_BN_CLICKED(IDC_PERMIT_ALLOW, OnPermitAllow)
   ON_BN_CLICKED(IDC_PERMIT_DENY, OnPermitDeny)
   ON_BN_CLICKED(IDC_PERMIT_POLICY, OnPermitPolicy)
   ON_WM_DESTROY()
   ON_NOTIFY(IPN_FIELDCHANGED, IDC_EDITIPADDRESS, OnFieldchangedEditipaddress)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgRASDialinMerge message handlers


// called when static routes button is pressed
void CDlgRASDialinMerge::OnButtonStaticRoutes()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CDlgStaticRoutes  DlgRoutes(m_strArrayFramedRoute, this);

   try{
      if(DlgRoutes.DoModal() == IDOK)
      {
         SetModified();

      };
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
   }

   // uncheck the checkbox if it's empty
   if(m_strArrayFramedRoute.GetSize() == 0)
   {
      m_CheckApplyStaticRoutes.SetCheck(FALSE);
      OnCheckApplyStaticRoutes();
   }
}

// when checkbox -- apply static routes is clicked
void CDlgRASDialinMerge::OnCheckApplyStaticRoutes()
{
   SetModified();
   // if checkbox "Apply static routes" is checked
   m_bApplyStaticRoutes = m_CheckApplyStaticRoutes.GetCheck();

   // Enable / Disable the push button for editing static routes
   m_ButtonStaticRoutes.EnableWindow(m_bApplyStaticRoutes);
   if(m_bApplyStaticRoutes && m_strArrayFramedRoute.GetSize() == 0)
      OnButtonStaticRoutes();
}

// when checkbox -- callerId is clicked
void CDlgRASDialinMerge::OnCheckCallerId()
{
   SetModified();

   // Disable or enable the edit box for caller id
   m_EditCallerId.EnableWindow(m_CheckCallerId.GetCheck());
}

// enable / disable the each items accroding to current state
void CDlgRASDialinMerge::EnableDialinSettings()
{
   BOOL bEnable;
   bEnable = IsPropertyWritable(ALLOW_DIALIN_NAME);
   EnableAccessControl(bEnable);

   // related to caller Id
   bEnable = IsPropertyWritable(NP_CALLING_STATION_ID_NAME);
   EnableCallerId(bEnable);

   // related to callback
   bEnable = IsPropertyWritable(CALLBACK_NUMBER_NAME) &&
             IsPropertyWritable(SERVICE_TYPE_NAME);
   EnableCallback(bEnable);

   // related to Ip address
   bEnable = IsPropertyWritable(FRAMED_IP_ADDRESS_NAME);
   EnableIPAddress(bEnable);

   // related to static routes
   bEnable = IsPropertyWritable(FRAMED_ROUTE_NAME);
   EnableStaticRoutes(bEnable);

   // if user in mixed domain, only allow to set dialin bit and callback options
   if(S_OK == HrIsInMixedDomain())  // user in mixed domain
   {
      GetDlgItem(IDC_PERMIT_POLICY)->EnableWindow(FALSE);

      // calling station id
      GetDlgItem(IDC_CHECKCALLERID)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDITCALLERID)->EnableWindow(FALSE);
      // framed IP address
      GetDlgItem(IDC_CHECKSTATICIPADDRESS)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDITIPADDRESS)->EnableWindow(FALSE);

      // framed route
      GetDlgItem(IDC_CHECKAPPLYSTATICROUTES)->EnableWindow(FALSE);
      GetDlgItem(IDC_BUTTONSTATICROUTES)->EnableWindow(FALSE);
   }
}


// called when  clicked on NoCallback radio button
void CDlgRASDialinMerge::OnRadioNoCallback()
{
   SetModified();
   // disable the edit box for callback
   m_EditCallback.EnableWindow(false);
}

void CDlgRASDialinMerge::OnRadioSetByCaller()
{
   SetModified();
   // disable the edit box for callback
   m_EditCallback.EnableWindow(false);
}

void CDlgRASDialinMerge::OnRadioSecureCallbackTo()
{
   SetModified();
   // enable the edit box for callback
   m_EditCallback.EnableWindow(true);
}

BOOL CDlgRASDialinMerge::IsPropertyWritable(
                            const wchar_t* propName
                            ) const throw ()
{
   return IsFocusOnLocalUser() ||
          ADsPropCheckIfWritable(
             const_cast<wchar_t*>(propName),
             m_pWritableAttrs
             );
}

void CDlgRASDialinMerge::EnableAccessControl(BOOL bEnable)
{
   GetDlgItem(IDC_PERMIT_ALLOW)->EnableWindow(bEnable);
   GetDlgItem(IDC_PERMIT_DENY)->EnableWindow(bEnable);
   GetDlgItem(IDC_PERMIT_POLICY)->EnableWindow(bEnable);
}

void CDlgRASDialinMerge::EnableCallerId(BOOL bEnable)
{
   // checkbox -- caller id
   m_CheckCallerId.EnableWindow(bEnable);

   // edit box -- caller id
   m_EditCallerId.EnableWindow(bEnable && m_CheckCallerId.GetCheck());
}

void CDlgRASDialinMerge::EnableCallback(BOOL bEnable)
{
   // radio button -- no call back
   m_RadioNoCallback.EnableWindow(bEnable);

   // radio button -- set by caller
   m_RadioSetByCaller.EnableWindow(bEnable);

   // radio button -- secure callback to
   m_RadioSecureCallbackTo.EnableWindow(bEnable);

   // edit box -- callback
   m_EditCallback.EnableWindow(m_RadioSecureCallbackTo.GetCheck());
}

void CDlgRASDialinMerge::EnableIPAddress(BOOL bEnable)
{
   m_CheckStaticIPAddress.SetCheck(m_bOverride);
   m_CheckStaticIPAddress.EnableWindow(bEnable);
   m_pEditIPAddress->EnableWindow(bEnable && m_bOverride);
}

void CDlgRASDialinMerge::EnableStaticRoutes(BOOL bEnable)
{
   // check box -- apply static routes
   m_CheckApplyStaticRoutes.EnableWindow(bEnable);

   if(!m_bApplyStaticRoutes)  bEnable = false;

   // push button -- static routes
   m_ButtonStaticRoutes.EnableWindow(bEnable);
}

int CDlgRASDialinMerge::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
   return CPropertyPage::OnCreate(lpCreateStruct);
}

// called when dialog is created
BOOL CDlgRASDialinMerge::OnInitDialog()
{
   HRESULT hr = Load();

   if FAILED(hr)
   {
      ReportError(hr, IDS_ERR_LOADUSER, m_hWnd);
   }
   else if (hr == S_FALSE) // Not the right OS to run
   {
      AfxMessageBox(IDS_ERR_NOTNT5SRV);
   }
   if(hr != S_OK)
   {
      EnableChildControls(GetSafeHwnd(), PROPPAGE_CHILD_HIDE | PROPPAGE_CHILD_DISABLE);
      GetDlgItem(IDC_FAILED_TO_INIT)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_FAILED_TO_INIT)->EnableWindow(TRUE);
      m_bInitFailed = TRUE;
      return TRUE;
   }

   if(m_strArrayCallingStationId.GetSize())
      m_strCallingStationId = *m_strArrayCallingStationId[(INT_PTR)0];

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   m_pEditIPAddress = GetDlgItem(IDC_EDITIPADDRESS);

   CPropertyPage::OnInitDialog();
   SetModified(FALSE);
   EnableDialinSettings();

   return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}

// called when click on OK or Apply button, if modify flag is set
BOOL CDlgRASDialinMerge::OnApply()
{
   HRESULT hr = S_OK;

   if(m_bInitFailed)
      goto L_Exit;

   if (!GetModified())
      return CPropertyPage::OnApply();
   m_dwDefinedAttribMask = 0;

   // dialin bit
   switch(m_nDialinPermit)
   {
      case  0: // allow
         m_dwDialinPermit = 1;
         break;

      case  1: // deny
         m_dwDialinPermit = 0;
         break;
      case  2: // policy decide -- remove the attribute from user object
         m_dwDialinPermit = -1;
         break;
   }

   // caller id
   if(m_bCallingStationId && !m_strCallingStationId.IsEmpty())
      m_dwDefinedAttribMask |= RAS_USE_CALLERID;

   m_strArrayCallingStationId.DeleteAll();
   if(!m_strCallingStationId.IsEmpty())
   {
      CString* pStr = new CString(m_strCallingStationId);
      if(pStr)
         m_strArrayCallingStationId.Add(pStr);
   }


   // callback option
   switch(m_nCallbackPolicy)
   {
   case  0: // no callback
      m_dwDefinedAttribMask |= RAS_CALLBACK_NOCALLBACK;
      break;
   case  1: // set by caller
      m_dwDefinedAttribMask |= RAS_CALLBACK_CALLERSET;
      break;
   case  2: // secure callback
      m_dwDefinedAttribMask |= RAS_CALLBACK_SECURE;
      break;
   }

   // Ip Address
   if(m_bOverride && m_dwFramedIPAddress)
      m_dwDefinedAttribMask |= RAS_USE_STATICIP;

   // Static Routes
   if(m_bApplyStaticRoutes && m_strArrayFramedRoute.GetSize())
      m_dwDefinedAttribMask |= RAS_USE_STATICROUTES;

   // save the user object
   hr = Save();

L_Exit:
   if (FAILED(hr))
   {
      ReportError(hr, IDS_ERR_SAVEUSER, m_hWnd);
   }

   return CPropertyPage::OnApply();
}

void CDlgRASDialinMerge::OnCheckStaticIPAddress()
{
   SetModified();
   m_bStaticIPAddress = m_CheckStaticIPAddress.GetCheck();
   m_pEditIPAddress->EnableWindow(m_bStaticIPAddress);
}

HRESULT CDlgRASDialinMerge::Load()
{
   HRESULT  hr = S_OK;
   // Load the data from DS
   CHECK_HR(hr = CRASUserMerge::Load());
   if(hr != S_OK)
      return hr;

   // dialin bit
   if(m_dwDialinPermit == 1)  //allow dialin
      m_nDialinPermit = 0;
   else if(m_dwDialinPermit == -1)  // Policy defines dialin bit -- not defined per user
      m_nDialinPermit = 2;
   else
      m_nDialinPermit = 1;    //deny dialin

   // in the case of Local User Manager, the Policy defined by profile is disableed
   if(S_OK == HrIsInMixedDomain() && m_nDialinPermit == 2)  // Local case
   {
      m_nDialinPermit = 1; // deny
   }

   // callback policy
   if(!(m_dwDefinedAttribMask & RAS_CALLBACK_MASK))
      m_nCallbackPolicy = 0;
   else if(m_dwDefinedAttribMask & RAS_CALLBACK_CALLERSET)
      m_nCallbackPolicy = 1;
   else if(m_dwDefinedAttribMask & RAS_CALLBACK_SECURE)
      m_nCallbackPolicy = 2;
   else if(m_dwDefinedAttribMask & RAS_CALLBACK_NOCALLBACK)
      m_nCallbackPolicy = 0;


   //=============================================================================
   // change to use dwAllowDialin to hold if static Route, calling station id
   // if ras user object required there is a staic ip

   if(m_dwDefinedAttribMask & RAS_USE_STATICIP)
      m_bOverride = TRUE;

   m_bStaticIPAddress = (m_dwFramedIPAddress != 0);

   // static routes
   m_bApplyStaticRoutes = (m_dwDefinedAttribMask & RAS_USE_STATICROUTES) && (m_strArrayFramedRoute.GetSize() != 0);

   // calling station
   m_bCallingStationId = (m_dwDefinedAttribMask & RAS_USE_CALLERID) && m_strArrayCallingStationId.GetSize() && (m_strArrayCallingStationId[(INT_PTR)0]->GetLength() != 0);

L_ERR:
   return hr;
}

BOOL CDlgRASDialinMerge::OnHelpInfo(HELPINFO* pHelpInfo)
{
   ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_RASDIALIN_MERGE);

   return CPropertyPage::OnHelpInfo(pHelpInfo);
}

void CDlgRASDialinMerge::OnContextMenu(CWnd* pWnd, CPoint point)
{
   ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_RASDIALIN_MERGE);
}


BOOL CDlgRASDialinMerge::OnKillActive()
{
   UINT  ids = 0;
   if(m_bInitFailed)
      return CPropertyPage::OnKillActive();

   if(FALSE == CPropertyPage::OnKillActive()) return FALSE;

   if(m_bCallingStationId && m_strCallingStationId.IsEmpty())
   {
      GotoDlgCtrl( &m_EditCallerId );
      ids = IDS_NEED_CALLER_ID;
      goto L_ERR;
   }

   // callback option
   // always callback to
   if(m_nCallbackPolicy == 2 && m_strCallbackNumber.IsEmpty())
   {
      GotoDlgCtrl( &m_EditCallback );
      ids = IDS_NEED_CALLBACK_NUMBER;
      goto L_ERR;
   }

   // Ip Address
   if(m_bOverride && !m_bStaticIPAddress )
   {
      GotoDlgCtrl( m_pEditIPAddress );
      ids = IDS_NEED_IPADDRESS;
      goto L_ERR;
   }


   // Static Routes
   if(m_bApplyStaticRoutes && m_strArrayFramedRoute.GetSize() == 0)
   {
      GotoDlgCtrl( &m_CheckApplyStaticRoutes );
      goto L_ERR;
   }
   return TRUE;

L_ERR:
   if (ids != 0)
      AfxMessageBox(ids);
   return FALSE;

}


//---------------------------------------------------------------------------
//  This is our self deleting callback function.  If you have more than a
//  a few property sheets, it might be a good idea to implement this in a
//  base class and derive your MFC property sheets from the base class
//
UINT CALLBACK  CDlgRASDialinMerge::PropSheetPageProc
(
  HWND hWnd,                   // [in] Window handle - always null
  UINT uMsg,                 // [in,out] Either the create or delete message
  LPPROPSHEETPAGE pPsp        // [in,out] Pointer to the property sheet struct
)
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  CDlgRASDialinMerge* pMe   = reinterpret_cast<CDlgRASDialinMerge*>(pPsp->lParam);
  ASSERT( NULL != pMe );

  switch( uMsg )
  {
    case PSPCB_CREATE:
      break;

    case PSPCB_RELEASE:
      // Since we are deleting ourselves, save a callback on the stack
      // so we can callback the base class
      LPFNPSPCALLBACK pfnOrig = pMe->m_pfnOriginalCallback;
      delete pMe;
      return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }
  // Must call the base class callback function or none of the MFC
  // message map stuff will work
  return (pMe->m_pfnOriginalCallback)(hWnd, uMsg, pPsp);

} // end PropSheetPageProc()



void CDlgRASDialinMerge::OnChangeEditcallback()
{
   // TODO: If this is a RICHEDIT control, the control will not
   // send this notification unless you override the CPropertyPage::OnInitDialog()
   // function to send the EM_SETEVENTMASK message to the control
   // with the ENM_CHANGE flag ORed into the lParam mask.

   // TODO: Add your control notification handler code here
   SetModified();
}

void CDlgRASDialinMerge::OnChangeEditcallerid()
{
   SetModified();
   // TODO: If this is a RICHEDIT control, the control will not
   // send this notification unless you override the CPropertyPage::OnInitDialog()
   // function to send the EM_SETEVENTMASK message to the control
   // with the ENM_CHANGE flag ORed into the lParam mask.

   // TODO: Add your control notification handler code here
}

void CDlgRASDialinMerge::OnPermitAllow()
{
   SetModified();
}

void CDlgRASDialinMerge::OnPermitDeny()
{
   SetModified();
}

void CDlgRASDialinMerge::OnPermitPolicy()
{
   SetModified();
}

void CDlgRASDialinMerge::OnFieldchangedEditipaddress(NMHDR* pNMHDR, LRESULT* pResult)
{
   SetModified();
   *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgiasadd.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    DlgIASAdd.cpp

Abstract:

   Implementation file for the CDlgIASAddAttr class.

   We implement the class needed to handle the dialog displayed when the user
   hits Add.... from the Advanced tab of the profile sheet.


Revision History:
   byao   - created
   mmaguire 06/01/98 - revamped


--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "stdafx.h"
#include "resource.h"

//
// where we can find declaration for main class in this file:
//
#include "DlgIASAdd.h"
//
//
// where we can find declarations needed in this file:
//
#include "helper.h"
#include "IASHelper.h"

// help table
#include "helptable.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define NOTHING_SELECTED   -1

//////////////////////////////////////////////////////////////////////////////
/*++

AttrCompareFunc

   comparison function for all attribute list control

--*/
//////////////////////////////////////////////////////////////////////////////
int CALLBACK AttrCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
   HRESULT hr;

   std::vector< CComPtr< IIASAttributeInfo > > *   parrAllAttr =
       ( std::vector< CComPtr< IIASAttributeInfo > > * ) lParamSort;

   int iOrder;

   // compare vendor ID first

   LONG lVendorID1, lVendorID2;

   // ISSUE: Shouldn't this be VendorName, not VendorID?

   hr = parrAllAttr->at( (int)lParam1 )->get_VendorID( &lVendorID1 );
   _ASSERTE( SUCCEEDED( hr ) );

   hr = parrAllAttr->at( (int)lParam2 )->get_VendorID( &lVendorID2 );
   _ASSERTE( SUCCEEDED( hr ) );

   iOrder = lVendorID1 - lVendorID2;

   if ( iOrder > 0) iOrder = 1;
   else if ( iOrder < 0 ) iOrder = -1;

   // For the same vendor, compare attribute name
   if ( iOrder == 0 )
   {
      CComBSTR bstrAttributeName1, bstrAttributeName2;

      hr = parrAllAttr->at( (int)lParam1 )->get_AttributeName( &bstrAttributeName1 );
      _ASSERTE( SUCCEEDED( hr ) );

      hr = parrAllAttr->at( (int)lParam2 )->get_AttributeName( &bstrAttributeName2 );
      _ASSERTE( SUCCEEDED( hr ) );

      iOrder = _tcscmp( bstrAttributeName1, bstrAttributeName2 );
   }

   if ( iOrder == 0 )
   {
      // if everything is the same, we just randomly pick an order
      iOrder = -1;
   }
   return iOrder;
}


/////////////////////////////////////////////////////////////////////////////
// CDlgIASAddAttr dialog


BEGIN_MESSAGE_MAP(CDlgIASAddAttr, CDialog)
   //{{AFX_MSG_MAP(CDlgIASAddAttr)
   ON_BN_CLICKED(IDC_IAS_BUTTON_ATTRIBUTE_ADD_SELECTED, OnButtonIasAddSelectedAttribute)
   ON_NOTIFY(NM_SETFOCUS, IDC_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM, OnItemChangedListIasAllAttributes)
   ON_WM_CONTEXTMENU()
   ON_WM_HELPINFO()
   ON_NOTIFY(NM_DBLCLK, IDC_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM, OnDblclkListIasAllattrs)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::CDlgIASAddAttr

   Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CDlgIASAddAttr::CDlgIASAddAttr(CPgIASAdv* pOwner, LONG lAttrFilter,
                        std::vector< CComPtr<IIASAttributeInfo> > * pvecAllAttributeInfos
                       )
           : CDialog(CDlgIASAddAttr::IDD, pOwner)
{
   //{{AFX_DATA_INIT(CDlgIASAddAttr)
   //}}AFX_DATA_INIT

   m_lAttrFilter = lAttrFilter;
   m_pOwner = pOwner;
   m_pvecAllAttributeInfos = pvecAllAttributeInfos;

}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::~CDlgIASAddAttr

   Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CDlgIASAddAttr::~CDlgIASAddAttr()
{
}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CDlgIASAddAttr::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgIASAddAttr)
   DDX_Control(pDX, IDC_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM, m_listAllAttrs);
   //}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::SetSdo

   Set the sdo pointers.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CDlgIASAddAttr::SetSdo(ISdoCollection* pIAttrCollection,
                        ISdoDictionaryOld* pIDictionary)
{
   m_spAttrCollectionSdo = pIAttrCollection;
   m_spDictionarySdo = pIDictionary;

   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::OnInitDialog

   Initialize the dialog.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CDlgIASAddAttr::OnInitDialog()
{
   HRESULT hr = S_OK;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   int iIndex;

   //
   // call the initialization routine of base class
   //
   CDialog::OnInitDialog();

   //
   // first, set the all-attribute list box to 4 columns
   //
   LVCOLUMN lvc;
   int iCol;
   CString strColumnHeader;
   WCHAR   wzColumnHeader[MAX_PATH];

   // initialize the LVCOLUMN structure
   lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.pszText = wzColumnHeader;

   //
   // column header for all attribute list box
   // These string ID should be in consecutive order
   //
   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_NAME);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listAllAttrs.InsertColumn(0, &lvc);

   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_VENDOR);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listAllAttrs.InsertColumn(1, &lvc);

   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_DESCRIPTION);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listAllAttrs.InsertColumn(2, &lvc);

   m_listAllAttrs.SetExtendedStyle(
                  m_listAllAttrs.GetExtendedStyle() | LVS_EX_FULLROWSELECT
                  );

    //
    // Populate the list for all available attributes in the dictionary
    //
   LVITEM lvi;
   WCHAR wszItemText[MAX_PATH];

   int jRow = 0;
   for (iIndex = 0; iIndex < m_pvecAllAttributeInfos->size(); iIndex++)
   {
      LONG lRestriction;
      m_pvecAllAttributeInfos->at(iIndex)->get_AttributeRestriction( &lRestriction );
      if ( lRestriction & m_lAttrFilter )
      {
         //
         // update the profattrlist
         //
         lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

         lvi.state = 0;
         lvi.stateMask = 0;
         lvi.iSubItem = 0;

         lvi.iItem = jRow;

         // We are saving the iIndex in this lParam for this item so that
         // later, when we sort the display of the list, we can still access the
         // orginal ordinal of the item in the list of all attributes.
         lvi.lParam = iIndex;

         CComBSTR bstrName;
         hr = m_pvecAllAttributeInfos->at(iIndex)->get_AttributeName( &bstrName );
         _ASSERTE( SUCCEEDED(hr) );

         lvi.pszText = bstrName;

         if (m_listAllAttrs.InsertItem(&lvi) == -1)
         {
            // return TRUE unless you set the focus to a control
            // EXCEPTION: OCX Property Pages should return FALSE
            return TRUE;
         }

         // vendor

         CComBSTR bstrVendor;
         hr = m_pvecAllAttributeInfos->at(iIndex)->get_VendorName( &bstrVendor );
         _ASSERTE( SUCCEEDED(hr) );

         m_listAllAttrs.SetItemText(jRow, 1, bstrVendor);

         // description
         CComBSTR bstrDescription;
         hr = m_pvecAllAttributeInfos->at(iIndex)->get_AttributeDescription( &bstrDescription );
         _ASSERTE( SUCCEEDED(hr) );
         m_listAllAttrs.SetItemText(jRow, 2, bstrDescription);

         jRow ++;
      } // if

   } // for

   // Set the sorting algorithm for this list control.
   m_listAllAttrs.SortItems( (PFNLVCOMPARE)AttrCompareFunc, (LPARAM)m_pvecAllAttributeInfos);

   // Selected the first one.
   if ( m_pvecAllAttributeInfos->size() > 0 )
   {
      // we have at least one element
//    m_listAllAttrs.SetItemState(m_dAllAttrCurSel, LVIS_FOCUSED, LVIS_FOCUSED);
      m_listAllAttrs.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
   }

   m_listAllAttrs.SetColumnWidth(0, LVSCW_AUTOSIZE);
   m_listAllAttrs.SetColumnWidth(1, LVSCW_AUTOSIZE);
   m_listAllAttrs.SetColumnWidth(2, LVSCW_AUTOSIZE);

   // button status
   UpdateButtonState();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


//+---------------------------------------------------------------------------
//
// Function:  OnButtonIasAddSelectedAttribute
//
// Class:     CDlgIASAddAttr
//
// Synopsis:  The user has clicked the 'Add" button. Add an attribute to the
//         profile
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 3:01:14 PM
//
//+---------------------------------------------------------------------------
void CDlgIASAddAttr::OnButtonIasAddSelectedAttribute()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   HRESULT hr;

   // Get which item is selected in the list.
   int iSelected = GetSelectedItemIndex( m_listAllAttrs );
   if (NOTHING_SELECTED == iSelected )
   {
      // do nothing
      return;
   }

   // Retrieve the original (unsorted) ordinal of the item in the list.
   // We stored this in lParam before we sorted this list.
   LVITEM   lvi;
   lvi.iItem      = iSelected;
   lvi.iSubItem   = 0;
   lvi.mask    = LVIF_PARAM;

   m_listAllAttrs.GetItem(&lvi);
   int iUnsortedSelected = lvi.lParam;

   hr = m_pOwner->AddAttributeToProfile( m_hWnd, iUnsortedSelected );
}


//+---------------------------------------------------------------------------
//
// Function:  UpdateButtonState
//
// Class:     CDlgIASAddAttr
//
// Synopsis:  Enable/Disable Add button
//
// Returns:   Nothing
//
// History:   Created byao 4/7/98 3:32:05 PM
//
//+---------------------------------------------------------------------------
void CDlgIASAddAttr::UpdateButtonState()
{
   // Set button states depending on whether anything is selected.
   int iSelected = GetSelectedItemIndex( m_listAllAttrs );
   if (NOTHING_SELECTED == iSelected )
   {
      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_ADD_SELECTED)->EnableWindow(FALSE);
   }
   else
   {
      // Something is selected.
      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_ADD_SELECTED)->EnableWindow(TRUE);
   }
}


//+---------------------------------------------------------------------------
//
// Function:  OnItemChangedListIasAllAttributes
//
// Class:     CDlgIASAddAttr
//
// Synopsis:  something has changed in All Attribute list box
//         We'll try to get the currently selected one
//
// Arguments: NMHDR* pNMHDR -
//            LRESULT* pResult -
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 3:32:05 PM
//
//+---------------------------------------------------------------------------
void CDlgIASAddAttr::OnItemChangedListIasAllAttributes(NMHDR* pNMHDR, LRESULT* pResult)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   UpdateButtonState();
   *pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::OnContextMenu

--*/
//////////////////////////////////////////////////////////////////////////////
void CDlgIASAddAttr::OnContextMenu(CWnd* pWnd, CPoint point)
{
   ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_IAS_ATTRIBUTE_ADD);
}


/////////////////////////////////////////////////////////////////////////////
/*++

CDlgIASAddAttr::OnHelpInfo

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CDlgIASAddAttr::OnHelpInfo(HELPINFO* pHelpInfo)
{
   ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_IAS_ATTRIBUTE_ADD);

   return CDialog::OnHelpInfo(pHelpInfo);
}


//+---------------------------------------------------------------------------
//
// Function:  CDlgIASAddAttr::OnDblclkListIasAllattrs
//
// Synopsis:  User has double clicked on the All Attribute list. Just add one.
//
// Arguments: NMHDR* pNMHDR -
//            LRESULT* pResult -
//
// Returns:   Nothing
//
// History:   Created Header   byao 2/26/98 2:24:09 PM
//
//+---------------------------------------------------------------------------
void CDlgIASAddAttr::OnDblclkListIasAllattrs(NMHDR* pNMHDR, LRESULT* pResult)
{
   OnButtonIasAddSelectedAttribute();
   *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgiasadd.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

	DlgIASAdd.h

Abstract:

	Header file for the CDlgIASAddAttr class.

	See DlgIASAdd.cpp for implementation.

Revision History:
	byao - created
	mmaguire 06/01/98 - revamped


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ADD_ATTRIBUTE_DIALOG_H_)
#define _IAS_ADD_ATTRIBUTE_DIALOG_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "helper.h"
//
//
// where we can find what this class has or uses:
//
#include "PgIASAdv.h"
#include "iashelper.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

::GetSelectedItemIndex

	Utility function which returns index value of first selected item in list control.

	Returns NOTHING_SELECTED if no item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
inline int GetSelectedItemIndex( CListCtrl & ListCtrl )
{
	int iIndex = 0;
	int iFlags = LVNI_ALL | LVNI_SELECTED;

	// Note: GetNextItem excludes the current item passed in.  So to 
	// find the first item which matches, you must pass in -1.
	iIndex = ListCtrl.GetNextItem( -1, iFlags ); 

	// Note: GetNextItem returns -1 (which is NOTHING_SELECTED for us) if it can't find anything.
	return iIndex;

}



/////////////////////////////////////////////////////////////////////////////
// CDlgIASAddAttr dialog




class CDlgIASAddAttr : public CDialog
{
// Construction
public:
	CDlgIASAddAttr(		  CPgIASAdv * pOwner
						, LONG lAttrFilter
						, std::vector< CComPtr<IIASAttributeInfo> > *	pvecAllAttributeInfos
				  ); 
	~CDlgIASAddAttr();

	HRESULT SetSdo(ISdoCollection* pIAttrCollectionSdo,
				   ISdoDictionaryOld* pIDictionary);

// Dialog Data
	//{{AFX_DATA(CDlgIASAddAttr)
	enum { IDD = IDD_IAS_ATTRIBUTE_ADD };
	CListCtrl	m_listAllAttrs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgIASAddAttr)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void	UpdateButtonState();
	// Generated message map functions
	//{{AFX_MSG(CDlgIASAddAttr)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonIasAddSelectedAttribute();
	afx_msg void OnItemChangedListIasAllAttributes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnDblclkListIasAllattrs(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	std::vector< CComPtr<IIASAttributeInfo> > * m_pvecAllAttributeInfos;
	LONG		m_lAttrFilter;

	CComPtr<ISdoDictionaryOld> m_spDictionarySdo;
	CComPtr<ISdoCollection> m_spAttrCollectionSdo;
	
	CPgIASAdv * m_pOwner;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _IAS_ADD_ATTRIBUTE_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgroute.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   dlgroute.cpp
      Implementation of CDlgStaticRoutes, dialog to show the current static
      routes applied to this dialin client

      Implementation of CDlgAddRoute, dialog to create a new route to the list

    FILE HISTORY:
        
*/

// DlgStaticRoutes.cpp : implementation file
//

#include "stdafx.h"
#include "helper.h"
#include "rasdial.h"
#include "DlgRoute.h"
#include "helptable.h"
#include "iastrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define  MAX_ROUTES  256
/////////////////////////////////////////////////////////////////////////////
// CDlgStaticRoutes dialog


CDlgStaticRoutes::CDlgStaticRoutes(CStrArray& Routes, CWnd* pParent /*=NULL*/)
   : m_strArrayRoute(Routes), CDialog(CDlgStaticRoutes::IDD, pParent)
{
   //{{AFX_DATA_INIT(CDlgStaticRoutes)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT

   m_pNewRoute = NULL;
   m_dwNextRouteID = 1;
}

CDlgStaticRoutes::~CDlgStaticRoutes()
{
   int   count = 0;
   CString* pString;

   if(m_pNewRoute)
      count = m_pNewRoute->GetSize();

   while(count --)
   {
      pString = m_pNewRoute->GetAt(0);
      m_pNewRoute->RemoveAt(0);
      delete pString;
   }
   delete m_pNewRoute;
}

void CDlgStaticRoutes::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgStaticRoutes)
   DDX_Control(pDX, IDC_LISTROUTES, m_ListRoutes);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgStaticRoutes, CDialog)
   //{{AFX_MSG_MAP(CDlgStaticRoutes)
   ON_BN_CLICKED(IDC_BUTTONDELETEROUTE, OnButtonDeleteRoute)
   ON_BN_CLICKED(IDC_BUTTONADDROUTE, OnButtonAddRoute)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTROUTES, OnItemchangedListroutes)
   ON_WM_CONTEXTMENU()
   ON_WM_HELPINFO()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgStaticRoutes message handlers

int CDlgStaticRoutes::AllRouteEntry()
{
   CStrArray*  pRoutes;
   CString* pRouteString;
   pRoutes = m_pNewRoute;
   
   if(!pRoutes)      // no new yet
      pRoutes = &m_strArrayRoute;
   int   count = pRoutes->GetSize();

   m_RouteIDs.RemoveAll();

   m_ListRoutes.DeleteAllItems();
   m_ListRoutes.SetItemCount(count);
   for(long i = 0; i < count; i++)
   {
      pRouteString = pRoutes->GetAt(i);
      ASSERT(pRouteString);
      IASTracePrintf("Route: %d --%s-- \n", i, *pRouteString);
      m_RouteIDs.Add(m_dwNextRouteID);
      AddRouteEntry(i, *pRouteString, m_dwNextRouteID++);
   }
   return count;
}

void CDlgStaticRoutes::AddRouteEntry(int i, CString& string, DWORD ID)
{
   if(!string.GetLength()) return;
   CFramedRoute   Route;
   CString        strTemp;

   Route.SetRoute(&string);

   // dest
   Route.GetDest(strTemp);
   i = m_ListRoutes.InsertItem(i, (LPTSTR)(LPCTSTR)strTemp);
   m_ListRoutes.SetItemData(i, ID);
   m_ListRoutes.SetItemText(i, 0, (LPTSTR)(LPCTSTR)strTemp);
   IASTracePrintf("DEST: %s ", strTemp);

   // prefix length
   Route.GetMask(strTemp);
   m_ListRoutes.SetItemText(i, 1, (LPTSTR)(LPCTSTR)strTemp);
   IASTracePrintf("MASK %s ", strTemp);

   // metric
   Route.GetMetric(strTemp);
   m_ListRoutes.SetItemText(i, 2, (LPTSTR)(LPCTSTR)strTemp);
   IASTracePrintf("METRIC: %s \n", strTemp);
   m_ListRoutes.SetItemState(i, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
   m_ListRoutes.SetFocus();
}

BOOL CDlgStaticRoutes::OnInitDialog() 
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CDialog::OnInitDialog();
   
   // Insert all the columns 
   CString  sDest;
   CString  sPrefixLength;
   CString  sMetric;

   try{
      if(sDest.LoadString(IDS_DESTINATION) && sPrefixLength.LoadString(IDS_MASK) && sMetric.LoadString(IDS_METRIC))
      {
         RECT  rect;
         m_ListRoutes.GetClientRect(&rect);
         m_ListRoutes.InsertColumn(1, sDest, LVCFMT_LEFT, (rect.right - rect.left)* 3/8);
         m_ListRoutes.InsertColumn(2, sPrefixLength, LVCFMT_LEFT, (rect.right - rect.left) * 3/8);
         m_ListRoutes.InsertColumn(3, sMetric, LVCFMT_LEFT, (rect.right - rect.left) * 3/16);
      }

      // Insert all the items
      AllRouteEntry();
      m_ListRoutes.SetItemCount(MAX_ROUTES);
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      TRACEAfxMessageBox(IDS_OUTOFMEMORY);
   }
   
   ListView_SetExtendedListViewStyle(m_ListRoutes.m_hWnd, LVS_EX_FULLROWSELECT);

   GetDlgItem(IDC_BUTTONDELETEROUTE)->EnableWindow(m_ListRoutes.GetSelectedCount() != 0);

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgStaticRoutes::OnButtonDeleteRoute() 
{

   if(!m_pNewRoute)
   {
      m_pNewRoute = new CStrArray(m_strArrayRoute);
      if(!m_pNewRoute)
      {
         TRACEAfxMessageBox(IDS_OUTOFMEMORY);
         return;
      }
   }

   int   count = m_pNewRoute->GetSize();
   DWORD id;
   int      i;
   int      total;
   CString* pString;

   while(count--)
   {
      if(m_ListRoutes.GetItemState(count, LVIS_SELECTED))
      {
         id = m_ListRoutes.GetItemData(count);
         total = m_RouteIDs.GetSize();
         for(i = 0; i < total; i++)
            if(m_RouteIDs[i] == id) break;

         ASSERT(i < total);      // must exist
         m_RouteIDs.RemoveAt(i); // from ID array
         pString = m_pNewRoute->GetAt(i); // from string array
         m_pNewRoute->RemoveAt(i);
         delete pString;

         m_ListRoutes.DeleteItem(count);
      }
   }
   GetDlgItem(IDC_BUTTONDELETEROUTE)->EnableWindow(m_ListRoutes.GetSelectedCount() != 0);

   // change focus when there is nothing to delete
   if(m_ListRoutes.GetSelectedCount() == 0)
      GotoDlgCtrl(GetDlgItem(IDC_BUTTONADDROUTE));
      
}

void CDlgStaticRoutes::OnButtonAddRoute() 
{
   CString* pRouteStr = NULL;

   // it's fine not to catch, MFC function will catch it
   pRouteStr = new CString();

   CDlgAddRoute   dlg(pRouteStr, this);

   if(dlg.DoModal()== IDOK && pRouteStr->GetLength())
   {
      if(!m_pNewRoute)
      {
         try{
            m_pNewRoute = new CStrArray(m_strArrayRoute);
         }
         catch(CMemoryException*)
         {
            delete pRouteStr;
            throw;
         }
      }
      m_RouteIDs.Add(m_dwNextRouteID);
      AddRouteEntry(m_pNewRoute->GetSize(), *pRouteStr, m_dwNextRouteID++);
      m_pNewRoute->Add(pRouteStr);
   }
   else
      delete pRouteStr;
}

void CDlgStaticRoutes::OnOK() 
{
   if(m_pNewRoute)
   {
      // clear the existing one
      int count = m_strArrayRoute.GetSize();
      CString* pString;
      while(count--)
      {
         pString = m_strArrayRoute.GetAt(0);
         m_strArrayRoute.RemoveAt(0);
         delete pString;
      }

      // copy over the new one
      count = m_pNewRoute->GetSize();
      while(count--)
      {
         pString = m_pNewRoute->GetAt(0);
         m_pNewRoute->RemoveAt(0);
         ASSERT(pString);
         m_strArrayRoute.Add(pString);
      }
   }
   
   CDialog::OnOK();
}
/////////////////////////////////////////////////////////////////////////////
// CDlgAddRoute dialog

CDlgAddRoute::CDlgAddRoute(CString* pStr, CWnd* pParent /*=NULL*/)
   : CDialog(CDlgAddRoute::IDD, pParent)
{
   //{{AFX_DATA_INIT(CDlgAddRoute)
   m_nMetric = MIN_METRIC;
   //}}AFX_DATA_INIT

   m_dwDest = 0xffffffff;
   m_dwMask = 0xffffff00;
   m_pStr = pStr;
   m_bInited = false;
}


void CDlgAddRoute::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CDlgAddRoute)
   DDX_Control(pDX, IDC_SPINMETRIC, m_SpinMetric);
   DDX_Text(pDX, IDC_EDITMETRIC, m_nMetric);
   DDV_MinMaxUInt(pDX, m_nMetric, MIN_METRIC, MAX_METRIC);
   //}}AFX_DATA_MAP

   if(pDX->m_bSaveAndValidate)      // save data to this class
   {
      // ip adress control
      SendDlgItemMessage(IDC_EDITDEST, IPM_GETADDRESS, 0, (LPARAM)&m_dwDest);
      SendDlgItemMessage(IDC_EDITMASK, IPM_GETADDRESS, 0, (LPARAM)&m_dwMask);
   }
   else     // put to dialog
   {
      // ip adress control
      if(m_bInited)
      {
         SendDlgItemMessage(IDC_EDITDEST, IPM_SETADDRESS, 0, m_dwDest);
         SendDlgItemMessage(IDC_EDITMASK, IPM_SETADDRESS, 0, m_dwMask);
      }
      else
      {
         SendDlgItemMessage(IDC_EDITDEST, IPM_CLEARADDRESS, 0, m_dwDest);
         SendDlgItemMessage(IDC_EDITMASK, IPM_CLEARADDRESS, 0, m_dwMask);
      }
   }
}


BEGIN_MESSAGE_MAP(CDlgAddRoute, CDialog)
   //{{AFX_MSG_MAP(CDlgAddRoute)
   ON_WM_HELPINFO()
   ON_WM_CONTEXTMENU()
   ON_NOTIFY(IPN_FIELDCHANGED, IDC_EDITMASK, OnFieldchangedEditmask)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgAddRoute message handlers

void CDlgAddRoute::OnOK() 
{
   // TODO: Add extra validation here
   
   if (!UpdateData(TRUE))
   {
      IASTraceString("UpdateData failed during dialog termination.");
      // the UpdateData routine will set focus to correct item
      return;
   }

   // check to see if mask is valid -- no HOLEs
   DWORD mask = m_dwMask;
   DWORD bit = 0x80000000;
   DWORD nPrefixLen = 0;
   UINT  nErrorId = 0;

   // find the # of 1s
   while ( ( bit & mask ) )
   {
      nPrefixLen++;
      bit >>= 1;
   }
   
   if(nPrefixLen > 0 && nPrefixLen <= 32)
   {
      while(bit && ((bit & mask) == 0))
         bit >>= 1;
      if(bit)  // all bit is tested
         nErrorId = IDS_INVALIDMASK;
   }
   else
      nErrorId = IDS_INVALIDMASK;

   if(nErrorId)
   {
      AfxMessageBox(IDS_INVALIDMASK);
      GetDlgItem(IDC_EDITMASK)->SetFocus();
      return;
   }

   // check if subnet address is correct / valid
   if((m_dwDest & m_dwMask) != m_dwDest)
   {
      CString  strError, strError1;

      strError.LoadString(IDS_INVALIDADDR);
      WORD  hi1, lo1;
      hi1 = HIWORD(m_dwDest);    lo1 = LOWORD(m_dwDest);
      WORD  hi2, lo2;
      hi2 = HIWORD(m_dwMask);    lo2 = LOWORD(m_dwMask);
      WORD  hi3, lo3;
      hi3 = HIWORD(m_dwMask & m_dwDest);  lo3 = LOWORD(m_dwMask & m_dwDest);
      strError1.Format(strError, HIBYTE(hi1), LOBYTE(hi1), HIBYTE(lo1), LOBYTE(lo1),
                  HIBYTE(hi2), LOBYTE(hi2), HIBYTE(lo2), LOBYTE(lo2),
                  HIBYTE(hi3), LOBYTE(hi3), HIBYTE(lo3), LOBYTE(lo3),
                  HIBYTE(hi3), LOBYTE(hi3), HIBYTE(lo3), LOBYTE(lo3));

      if(AfxMessageBox(strError1, MB_YESNO) == IDYES)
      {
         m_dwDest = (m_dwMask & m_dwDest);
         UpdateData(FALSE);
      }
      GetDlgItem(IDC_EDITDEST)->SetFocus();
      return;
   }

   // if everything is OK
   {
      WORD  hi1, lo1;
      hi1 = HIWORD(m_dwDest);    lo1 = LOWORD(m_dwDest);
      m_pStr->Format(_T("%-d.%-d.%d.%d/%-d 0.0.0.0 %-d"), 
         HIBYTE(hi1), LOBYTE(hi1), HIBYTE(lo1), LOBYTE(lo1),
         nPrefixLen, m_nMetric);
   }
   EndDialog(IDOK);
}

BOOL CDlgStaticRoutes::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   // Trap Header control codes here
   HD_NOTIFY *phdn = (HD_NOTIFY *)lParam;

   BOOL bIsSet;
   BOOL bResult = SystemParametersInfo( SPI_GETDRAGFULLWINDOWS, 
          0, &bIsSet, 0 ); // if bIsSet == TRUE 
   // NOTE:  If the "show window contents while dragging" display 
   // property is set multiple HDN_ITEMCHANGING and HDN_ITEMCHANGED 
   // messages will be sent and the HDN_TRACK message will not be 
   // sent. If this property is set the opposite will happen.
   // BOOL bResult = SystemParametersInfo( SPI_GETDRAGFULLWINDOWS, 
   // 0, &bIsSet, 0 );  if bIsSet == TRUE "show window contents
   //  while dragging" is set.

   switch( phdn->hdr.code )
   {
      // Trap the HDN_TRACK message
      case HDN_TRACKA:
      case HDN_TRACKW:
         // See note above
         *pResult = 1;
         return( TRUE );  // return FALSE to continue tracking the divider
         break;

      // Trap the HDN_ITEMCHANGING message
      case HDN_ITEMCHANGINGA:
      case HDN_ITEMCHANGINGW:
         // See note above
         *pResult = 1;
         return( TRUE );  // return FALSE to allow changes  
         break;
   }  
   return CDialog::OnNotify(wParam, lParam, pResult);
}

BOOL CDlgAddRoute::OnInitDialog() 
{
   CDialog::OnInitDialog();
   int l, h;

   l = max(MIN_METRIC, UD_MINVAL);
   h = min(MAX_METRIC, UD_MAXVAL);

   m_SpinMetric.SetRange(l, h);

   m_bInited = true;
   
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


void CDlgStaticRoutes::OnItemchangedListroutes(NMHDR* pNMHDR, LRESULT* pResult) 
{
   NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
   GetDlgItem(IDC_BUTTONDELETEROUTE)->EnableWindow(m_ListRoutes.GetSelectedCount() != 0);
   
   *pResult = 0;
}

BOOL CDlgAddRoute::OnHelpInfo(HELPINFO* pHelpInfo) 
{
       ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_ADDROUTE);

   return CDialog::OnHelpInfo(pHelpInfo);
}

void CDlgAddRoute::OnContextMenu(CWnd* pWnd, CPoint point) 
{
      ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_ADDROUTE);
   
}

void CDlgStaticRoutes::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_STATICROUTES);
}

BOOL CDlgStaticRoutes::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)g_aHelpIDs_IDD_STATICROUTES);
   
   return CDialog::OnHelpInfo(pHelpInfo);
}

void CDlgAddRoute::OnFieldchangedEditmask(NMHDR* pNMHDR, LRESULT* pResult) 
{
   // TODO: Add your control notification handler code here
   LPNMIPADDRESS  pNMIpAdd = (LPNMIPADDRESS)pNMHDR;
   CWnd* pIPA = GetDlgItem(IDC_EDITMASK);
   
   BYTE  F[4];
   DWORD address;
   pIPA->SendMessage(IPM_GETADDRESS, 0, (LPARAM)&address);
   
   F[0] = FIRST_IPADDRESS((LPARAM)address);
   F[1] = SECOND_IPADDRESS((LPARAM)address);
   F[2] = THIRD_IPADDRESS((LPARAM)address);
   F[3] = FOURTH_IPADDRESS((LPARAM)address);
   
   if(pNMIpAdd->iValue == 255)
   {
      for ( int i = 0; i < pNMIpAdd->iField; i++)
      {
         F[i] = 255;
      }
      address = MAKEIPADDRESS(F[0], F[1], F[2], F[3]);
      pIPA->SendMessage(IPM_SETADDRESS, 0, (LPARAM)address);
   }
   *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapadd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapadd.cpp
//
// SYNOPSIS
//
//    Defines the class EapAdd.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "eapadd.h"
#include "eapconfig.h"


BEGIN_MESSAGE_MAP(EapAdd, CHelpDialog)
   ON_BN_CLICKED(IDC_BUTTON_EAP_ADD_ADD, OnButtonAdd)
END_MESSAGE_MAP()

EapAdd::EapAdd(CWnd* pParent, EapConfig& eapConfig)
   : CHelpDialog(IDD_EAP_ADD, pParent),
   m_eapConfig(eapConfig),
   m_listBox(NULL)
{
   m_eapConfig.GetEapTypesNotSelected(m_typesNotSelected);
}

EapAdd::~EapAdd()
{
   delete m_listBox;
}


BOOL EapAdd::OnInitDialog()
{
   HRESULT hr = CHelpDialog::OnInitDialog();
   m_listBox = new CStrBox<CListBox>(
                                     this, 
                                     IDC_LIST_EAP_ADD, 
                                     m_typesNotSelected
                                  );

   if (m_listBox == NULL)
   {
      AfxMessageBox(IDS_OUTOFMEMORY);
      return TRUE;  // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
   }

   m_listBox->Fill();

   // Take action based on whether list is empty or not.
   int boxSize = m_typesNotSelected.GetSize();
   if( boxSize > 0 )
   {
      // Select the first element.
      m_listBox->Select(0);
      setButtonStyle(IDCANCEL, BS_DEFPUSHBUTTON, false);
      setButtonStyle(IDC_BUTTON_EAP_ADD_ADD, BS_DEFPUSHBUTTON, true);
      setFocusControl(IDC_BUTTON_EAP_ADD_ADD);
   }
   else
   {
      // We are currently empty.
      GetDlgItem(IDC_BUTTON_EAP_ADD_ADD)->EnableWindow(FALSE);
      setButtonStyle(IDC_BUTTON_EAP_ADD_ADD, BS_DEFPUSHBUTTON, false);
      setButtonStyle(IDCANCEL, BS_DEFPUSHBUTTON, true);
      setFocusControl(IDCANCEL);
   }

   return hr;
}


void EapAdd::OnButtonAdd()
{
   int selected = m_listBox->GetSelected();
   if (selected != LB_ERR)
   {
      m_eapConfig.typesSelected.AddDuplicate(
                                    *m_typesNotSelected.GetAt(selected));
      EndDialog(IDOK);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\dlgroute.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dlgroute.h
		definition of CDlgStaticRoutes, dialog to show the current static
		routes applied to this dialin client

		definition of CDlgAddRoute, add a new route to the route list

    FILE HISTORY:
        
*/

#if !defined(AFX_DLGSTATICROUTES_H__FFB07230_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_)
#define AFX_DLGSTATICROUTES_H__FFB07230_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgStaticRoutes.h : header file
//
#include "stdafx.h"
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CDlgStaticRoutes dialog

class CDlgStaticRoutes : public CDialog
{
// Construction
public:
	CDlgStaticRoutes(CStrArray& Routes, CWnd* pParent = NULL);   // standard constructor
	virtual ~CDlgStaticRoutes(); 

// Dialog Data
	//{{AFX_DATA(CDlgStaticRoutes)
	enum { IDD = IDD_STATICROUTES };
	CListCtrl	m_ListRoutes;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgStaticRoutes)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgStaticRoutes)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonDeleteRoute();
	afx_msg void OnButtonAddRoute();
	virtual void OnOK();
	afx_msg void OnItemchangedListroutes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	
	CStrArray&	m_strArrayRoute;
	CStrArray*	m_pNewRoute;
	CArray<DWORD, DWORD> m_RouteIDs;
	DWORD		m_dwNextRouteID;
	void		AddRouteEntry(int i, CString& string, DWORD routeID);
	int			AllRouteEntry();
};

/////////////////////////////////////////////////////////////////////////////
// CDlgAddRoute dialog

class CDlgAddRoute : public CDialog
{
// Construction
public:
	CDlgAddRoute(CString* pStr, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgAddRoute)
	enum { IDD = IDD_ADDROUTE };
	CSpinButtonCtrl	m_SpinMetric;
	UINT	m_nMetric;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddRoute)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgAddRoute)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnFieldchangedEditmask(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	DWORD	m_dwDest;
	DWORD	m_dwMask;
	CString*	m_pStr;
	bool	m_bInited;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGSTATICROUTES_H__FFB07230_1FFD_11D1_8531_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapprofile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class EapProfile.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPROFILE_H
#define EAPPROFILE_H
#pragma once

// Manages the EAP configuration for a profile.
class EapProfile
{
public:
   struct ConstConfigData
   {
      DWORD length;
      const BYTE* value;
   };

   struct ConfigData
   {
      DWORD length;
      BYTE* value;

      operator const ConstConfigData&() const throw ();
      operator ConstConfigData&() throw ();
   };

   EapProfile() throw ();
   ~EapProfile() throw ();

   HRESULT Assign(const EapProfile& rhs) throw ();

   // Load the profile's state from a VARIANT. The VARIANT is in the format
   // used by the SDOs. This function does not clear the supplied VARIANT.
   HRESULT Load(VARIANT& src) throw ();

   // Store the profile's state to a VARIANT. The VARIANT is in the format used
   // by the SDOs. The caller is responsible for deleting the returned VARIANT.
   HRESULT Store(VARIANT& dst) throw ();

   // Returns the number of types configured.
   size_t Size() const throw ();

   // Returns true if there are no types configured.
   bool IsEmpty() const throw ();

   // Clears all the configuration data.
   void Clear() throw ();

   // Clears all the configuration data except the specified type.
   void ClearExcept(BYTE type) throw ();

   // Erases the config for the specified type. Has no effect if the type is
   // not currently set.
   void Erase(BYTE type) throw ();

   // Retrieves the config for the specified EAP type. The data is in the
   // format used by IEAPProviderConfig2. Returns a zero-length value if the
   // per-profile config is not present for the specified type.
   void Get(BYTE type, ConstConfigData& dst) const throw ();

   // Set the config for the specified EAP type. The data is in the format used
   // by IEAPProviderConfig2.
   HRESULT Set(BYTE type, const ConstConfigData& newConfig) throw ();

   // Pop the the configuration for a single type in the format used by the
   // run-time EAP host.  Caller is responsible for freeing the returned buffer
   // using CoTaskMemFree. Behavior is undefined if IsEmpty() == true.
   void Pop(ConfigData& dst) throw ();

   void Swap(EapProfile& other) throw ();

private:
   // The data type used for the sequence.
   typedef unsigned short SeqNum;
   // Size of the sequence number in bytes.
   static const size_t seqNumSize = 2;
   // Maximum number of chunks that the sequence number can support.
   static const size_t maxChunks = 0x10000;
   // Size of the SDO header: type byte + seqNumSize
   static const size_t sdoHeaderSize = 1 + seqNumSize;

   // Extract/Insert the sequence bytes.
   static SeqNum ExtractSequence(const BYTE* src) throw ();
   static void InsertSequence(SeqNum seq, BYTE* dst) throw ();

   // Concatenates the config chunks from the supplied VARIANTs and appends it
   // to the internal array. The chunks must all be from the same EAP type.
   HRESULT GatherAndAppend(
              const VARIANT* first,
              const VARIANT* last
              ) throw ();

   // Breaks the config into chunks and stores it in dst. dst must point to
   // enough storage to hold the scattered config. Upon return, dst points to
   // the element immediately after the scattered chunks.
   HRESULT Scatter(
              const ConstConfigData& src,
              VARIANT*& dst
              ) throw ();

   // Ensures that the internal array can hold at least newCapacity elements.
   HRESULT Reserve(size_t newCapacity) throw ();

   // Returns the number of chunks required to scatter 'data'.
   static size_t ChunksRequired(const ConstConfigData& data) throw ();

   // Returns the length of the embedded SAFEARRAY of BYTEs. Does not check the
   // validity of 'src'.
   static DWORD ExtractLength(const VARIANT& src) throw ();

   // Returns the data from the embedded SAFEARRAY of BYTEs. Does not check the
   // validity of 'src'.
   static const BYTE* ExtractString(const VARIANT& src) throw ();

   // Used for sorting chunks by type and sequence.
   static bool LessThan(const VARIANT& lhs, const VARIANT& rhs) throw ();

   // Ensures that 'value' contains a valid config chunk.
   static HRESULT ValidateConfigChunk(const VARIANT& value) throw ();

   // The maximum size of a chunk, not counting the type and sequence bytes.
   static const size_t maxChunkSize = 4050;

   // The beginning of the config array. This array is stored in run-time
   // format, e.g., all chunks have been gathered and the value contains a lead
   // type byte, but not a sequence number.
   ConfigData* begin;

   // The end of the configured types.
   ConfigData* end;

   // The capacity of the array.
   size_t capacity;

   // Not implemented.
   EapProfile(const EapProfile&);
   EapProfile& operator=(const EapProfile&);
};


inline EapProfile::ConfigData::operator
const EapProfile::ConstConfigData&() const throw ()
{
   return *reinterpret_cast<const ConstConfigData*>(this);
}


inline EapProfile::ConfigData::operator EapProfile::ConstConfigData&() throw ()
{
   return *reinterpret_cast<ConstConfigData*>(this);
}


inline size_t EapProfile::Size() const throw ()
{
   return end - begin;
}


inline bool EapProfile::IsEmpty() const throw ()
{
   return begin == end;
}

#endif // EAPPROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapconfig.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapconfig.cpp
//
// SYNOPSIS
//
//    Defines the class EapAdd.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "eapconfig.h"

void EapConfig::GetEapTypesNotSelected(CStrArray& typesNotSelected) const
{
   // copy all the types of the machine
   typesNotSelected = types;
   // remove each type already selected
   for (int i = 0; i < typesSelected.GetSize(); ++i)
   {
      int pos = typesNotSelected.Find(*typesSelected.GetAt(i));
      typesNotSelected.DeleteAt(pos);
   }      
}


EapConfig& EapConfig::operator=(const EapConfig& source)
{
   types = source.types;
   ids = source.ids;
   typeKeys = source.typeKeys;
   infoArray.RemoveAll();
   int   count = source.infoArray.GetSize();
   for(int i = 0; i < count; ++i)
   {
      infoArray.Add(source.infoArray[i]);
   }

   typesSelected = source.typesSelected;
   return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapadd.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapadd.h
//
// SYNOPSIS
//
//    Declares the class EapAdd.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef EAPADD_H
#define EAPADD_H

#if _MSC_VER >= 1000
#pragma once
#endif

#include "helptable.h"
#include "pgauthen.h"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EapAdd
//
// DESCRIPTION
//
//    Implements a dialog box to add some new EAP types to the profile.
//
///////////////////////////////////////////////////////////////////////////////
class EapAdd : public CHelpDialog
{
public:
   EapAdd(CWnd* pParent, EapConfig& eapConfig);
   ~EapAdd() throw ();

private:
   virtual BOOL OnInitDialog();

   DECLARE_MESSAGE_MAP()

   afx_msg void OnButtonAdd();

   EapConfig& m_eapConfig;

   CStrBox<CListBox>* m_listBox;
   CStrArray m_typesNotSelected;

   // Not implemented.
   EapAdd(const EapAdd&);
   EapAdd& operator=(const EapAdd&);
};

#endif // EAPADD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapconfig.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapconfig.h
//
// SYNOPSIS
//
//    Declares the class EapConfig.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef EAPCONFIG_H
#define EAPCONFIG_H

#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EapConfig
//
// DESCRIPTION
//
//    
//
///////////////////////////////////////////////////////////////////////////////
class EapConfig
{
public:
   EapConfig(){};

   // Array of EAP types (strings, order constant)
   CStrArray types;
   // array of EAP IDs (order constant, same as types and ids)
   CDWArray ids;
   // array of EAP keys (order constant, sams as types and ids)
   CDWArray typeKeys;
   // array of info about the EAP providers (CLSID for the UI...) 
   // order constant, same as the others
   AuthProviderArray infoArray;
   // Array of strings (come from types) that are selected by the user for 
   // this profile. The order can be changed by the user. 
   CStrArray typesSelected;

   void GetEapTypesNotSelected(CStrArray& typesNotSelected) const;

   EapConfig& operator=(const EapConfig& source);

private:
   // Not implemented.
   EapConfig(const EapConfig&);

};

#endif // EAPCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\helptable.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       helptable.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#include "resource.h"
#include "helptable.h"

// from net\ias\mmc\common
#include "hlptable.h"

const CGlobalHelpTable __pGlobalCSHelpTable[] =
{
	DLG_HELP_ENTRY(IDD_EAP_NEGOCIATE),
	DLG_HELP_ENTRY(IDD_EAP_ADD),
	{0,0}
};

IMPLEMENT_DYNCREATE(CHelpDialog, CDialog)

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CHelpDialog::OnContextMenu(CWnd* pWnd, ::CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CHelpDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (DWORD_PTR)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}

void CHelpDialog::setButtonStyle(int controlId, long flags, bool set)
{
   // Get the button handle.
   HWND button = ::GetDlgItem(m_hWnd, controlId);

   // Retrieve the current style.
   long style = ::GetWindowLong(button, GWL_STYLE);

   // Update the flags.
   if (set)
   {
      style |= flags;
   }
   else
   {
      style &= ~flags;
   }

   // Set the new style.
   ::SendMessage(button, BM_SETSTYLE, LOWORD(style), MAKELPARAM(1,0));
}


void CHelpDialog::setFocusControl(int controlId)
{
   ::SetFocus(::GetDlgItem(m_hWnd, controlId));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapnegotiate.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapnegotiate.h
//
// SYNOPSIS
//
//    Declare the class EapNegotiate.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef EAPNEGOCIATE_H
#define EAPNEGOCIATE_H

#if _MSC_VER >= 1000
#pragma once
#endif

#include "eapprofile.h"
#include "helptable.h"

class EapConfig;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EapNegotiate
//
// DESCRIPTION
//
//    Implements a dialog box to order, add, configure and remove the EAP
//    types that will be negotiated for the profile.
//
///////////////////////////////////////////////////////////////////////////////
class EapNegotiate : public CHelpDialog
{
public:
   EapNegotiate(
                  CWnd* pParent,
                  EapConfig& eapConfig,
                  CRASProfileMerge& profile,
                  bool fromProfile
               );

   ~EapNegotiate() throw ();

   EapProfile m_eapProfile;

private:
   void UpdateProfileTypesSelected();

   virtual BOOL OnInitDialog();

   DECLARE_MESSAGE_MAP()

   virtual void DoDataExchange(CDataExchange* pDX);

   afx_msg void OnItemChangedListEap();
   afx_msg void OnButtonAdd();
   afx_msg void OnButtonEdit();
   afx_msg void OnButtonRemove();
   afx_msg void OnButtonMoveUp();
   afx_msg void OnButtonMoveDown();

   void UpdateButtons();
   void UpdateAddButton();
   void UpdateArrowsButtons(int selectedItem);
   void UpdateEditButton(int selectedItem);
   void UpdateTypesNotSelected();

   EapConfig& m_eapConfig;
   CRASProfileMerge& m_profile;
   CStrArray m_typesNotSelected;

   CStrBox<CListBox>   *m_listBox;

   CButton m_buttonUp;
   CButton m_buttonDown;
   CButton m_buttonAdd;
   CButton m_buttonEdit;
   CButton m_buttonRemove;

   // Not implemented.
   EapNegotiate(const EapNegotiate&);
   EapNegotiate& operator=(const EapNegotiate&);
};


#endif // EAPNEGOCIATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapnegotiate.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapnegotiate.cpp
//
// SYNOPSIS
//
//    Defines the class EapNegotiate.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "eapnegotiate.h"
#include "eapconfig.h"
#include "eapadd.h"
#include "rrascfg.h"

BEGIN_MESSAGE_MAP(EapNegotiate, CHelpDialog)
   ON_LBN_SELCHANGE(IDC_LIST_EAP_SELECTED, OnItemChangedListEap)
   ON_BN_CLICKED(IDC_BUTTON_ADD_EAP_PROVIDER, OnButtonAdd)
   ON_BN_CLICKED(IDC_BUTTON_EDIT_EAP_PROVIDER, OnButtonEdit)
   ON_BN_CLICKED(IDC_BUTTON_REMOVE_EAP_PROVIDER, OnButtonRemove)
   ON_BN_CLICKED(IDC_BUTTON_EAP_UP, OnButtonMoveUp)
   ON_BN_CLICKED(IDC_BUTTON_EAP_DOWN, OnButtonMoveDown)
END_MESSAGE_MAP()

EapNegotiate::EapNegotiate(
                              CWnd* pParent,
                              EapConfig& eapConfig,
                              CRASProfileMerge& profile,
                              bool fromProfile
                          )
   : CHelpDialog(IDD_EAP_NEGOCIATE, pParent),
   m_eapConfig(eapConfig),
   m_profile(profile),
   m_listBox(NULL)
{
   if (fromProfile)
   {
      UpdateProfileTypesSelected();
   }
}

EapNegotiate::~EapNegotiate()
{
   delete m_listBox;
}

// CAUTION: call only from the constructor
void EapNegotiate::UpdateProfileTypesSelected()
{
   m_eapConfig.typesSelected.DeleteAll();

   // Get the eap types that are in the profile
   for (int i = 0; i < m_profile.m_dwArrayEapTypes.GetSize(); ++i)
   {
      int j = m_eapConfig.ids.Find(m_profile.m_dwArrayEapTypes.GetAt(i));
      // if in the list, add it
      if (j != -1)
      {
         m_eapConfig.typesSelected.AddDuplicate(*m_eapConfig.types.GetAt(j));
      }
   }
}


BOOL EapNegotiate::OnInitDialog()
{
   HRESULT hr = CHelpDialog::OnInitDialog();
   m_listBox = new CStrBox<CListBox>(
                                     this,
                                     IDC_LIST_EAP_SELECTED,
                                     m_eapConfig.typesSelected
                                  );

   if (m_listBox == NULL)
   {
      AfxMessageBox(IDS_OUTOFMEMORY);
      return TRUE;  // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
   }

   m_listBox->Fill();

   // Take action based on whether list is empty or not.
   int boxSize = m_eapConfig.typesSelected.GetSize();
   if( boxSize > 0 )
   {
      // Select the first element.
      m_listBox->Select(0);
   }

   UpdateTypesNotSelected();
   UpdateButtons();

   return hr;
}


void EapNegotiate::OnItemChangedListEap()
{
   UpdateButtons();
}


void EapNegotiate::OnButtonAdd()
{
   EapAdd eapAdd(this, m_eapConfig);
   if (eapAdd.DoModal() == IDOK)
   {
      m_listBox->Fill();
      // select the last one (the one just added)
      m_listBox->Select(m_eapConfig.typesSelected.GetSize() - 1);

      UpdateTypesNotSelected();

      // update the buttons...
      UpdateButtons();
   }
}


void EapNegotiate::OnButtonEdit()
{
   // enable / disable configure button based on if the type has config clsID
   int i = m_listBox->GetSelected();
   int position;
   BOOL  bEnableConfig = FALSE;
   if (i != -1)
   {
      // find the type corresponding to the selected item
      position = m_eapConfig.types.Find(*m_eapConfig.typesSelected.GetAt(i));
      bEnableConfig = !(m_eapConfig.infoArray.ElementAt(position)
                           .m_stConfigCLSID.IsEmpty());
   }

   if (!bEnableConfig)
   {
      // bEnableConfig can be false because either:
      // nothing is selected in the list. So the button should be disabled
      // there's no UI to config the EAP provider (CLSID is empty)
      return;
   }

   // everything below should succeed if the EAP provider is properly installed
   // because there is a CLSID to configure it.
   CComPtr<IEAPProviderConfig> spEAPConfig;
   HRESULT hr;
   GUID guid;
   do
   {
      hr = CLSIDFromString((LPTSTR) (LPCTSTR)
                  (m_eapConfig.infoArray.ElementAt(position).m_stConfigCLSID),
                   &guid);
      if (FAILED(hr))
      {
         break;
      }

      // Create the EAP provider object
      hr = CoCreateInstance(
                              guid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              __uuidof(IEAPProviderConfig),
                              (LPVOID *) &spEAPConfig);
      if (FAILED(hr))
      {
         break;
      }

      // Configure this EAP provider
      // EAP configure displays its own error message, so no hr is kept
      DWORD dwId = _wtol(m_eapConfig.infoArray.ElementAt(position).m_stKey);
      ULONG_PTR uConnection = 0;
      if ( SUCCEEDED(spEAPConfig->Initialize(
                                             m_profile.m_strMachineName,
                                             dwId,
                                             &uConnection
                                             )) )
      {
         CComPtr<IEAPProviderConfig2> spEAPConfig2;
         hr = spEAPConfig->QueryInterface(
                              __uuidof(IEAPProviderConfig2),
                              reinterpret_cast<void**>(&spEAPConfig2)
                              );
         if (SUCCEEDED(hr))
         {
            EapProfile::ConstConfigData inData;
            m_eapProfile.Get(static_cast<BYTE>(dwId), inData);
            EapProfile::ConfigData outData = { 0, 0 };
            hr = spEAPConfig2->ServerInvokeConfigUI2(
                                  dwId,
                                  uConnection,
                                  GetSafeHwnd(),
                                  inData.value,
                                  inData.length,
                                  &(outData.value),
                                  &(outData.length)
                                  );
            if (SUCCEEDED(hr))
            {
               hr = m_eapProfile.Set(static_cast<BYTE>(dwId), outData);
               CoTaskMemFree(outData.value);
            }
         }
         else
         {
            // Bring up the configuration UI for this EAP
            hr = spEAPConfig->ServerInvokeConfigUI(
                                 dwId,
                                 uConnection,
                                 GetSafeHwnd(),
                                 0,
                                 0
                                 );
         }

         spEAPConfig->Uninitialize(dwId, uConnection);
      }
   }
   while(false);

   if ( FAILED(hr) )
   {
      // Bring up an error message
      // ------------------------------------------------------------
      ReportError(hr, IDS_ERR_CONFIG_EAP, GetSafeHwnd());
   }
}


void EapNegotiate::OnButtonRemove()
{
   int pos = m_listBox->GetSelected();
   if (pos != -1)
   {
      int idx = m_eapConfig.types.Find(*m_eapConfig.typesSelected.GetAt(pos));
      if (idx != -1)
      {
         m_eapProfile.Erase(m_eapConfig.ids.ElementAt(idx));
      }
   }

   // remove from the UI and from the CStrArray (memory freed)
   m_listBox->DeleteSelected();
   if (m_eapConfig.typesSelected.GetSize() > 0)
   {
      m_listBox->Select(0);
   }

   UpdateTypesNotSelected();
   UpdateButtons();
}


void EapNegotiate::OnButtonMoveUp()
{
   int i = m_listBox->GetSelected();
   if (i != LB_ERR)
   {
      ASSERT(i != 0);

      CString* pString = m_eapConfig.typesSelected.GetAt(i-1);
      m_eapConfig.typesSelected.SetAt(i-1, m_eapConfig.typesSelected.GetAt(i));
      m_eapConfig.typesSelected.SetAt(i, pString);

      m_listBox->Fill();
      m_listBox->Select(i-1);
      UpdateArrowsButtons(i-1);
   }
}


void EapNegotiate::OnButtonMoveDown()
{
   int i = m_listBox->GetSelected();
   if (i != LB_ERR)
   {
      ASSERT(i < (m_eapConfig.idsSelected.GetSize() - 1));

      CString* pString = m_eapConfig.typesSelected.GetAt(i+1);
      m_eapConfig.typesSelected.SetAt(i+1, m_eapConfig.typesSelected.GetAt(i));
      m_eapConfig.typesSelected.SetAt(i, pString);

      m_listBox->Fill();
      m_listBox->Select(i+1);
      UpdateArrowsButtons(i+1);
   }
}


void EapNegotiate::UpdateButtons()
{
   int selected = m_listBox->GetSelected();
   if (selected == LB_ERR)
   {
      m_buttonRemove.EnableWindow(FALSE);
   }
   else
   {
      m_buttonRemove.EnableWindow(TRUE);
   }
   UpdateAddButton();
   UpdateArrowsButtons(selected);
   UpdateEditButton(selected);
}


void EapNegotiate::UpdateAddButton()
{
   if( m_typesNotSelected.GetSize() > 0 )
   {
      m_buttonAdd.EnableWindow(TRUE);
   }
   else
   {
      m_buttonAdd.EnableWindow(FALSE);
   }
}


void EapNegotiate::UpdateArrowsButtons(int selectedItem)
{
   // The focus has to be set to make sure it is not on a
   // disabled control
   HWND hWnd = ::GetFocus();

   if (selectedItem == LB_ERR)
   {
      m_buttonUp.EnableWindow(FALSE);
      m_buttonDown.EnableWindow(FALSE);
      ::SetFocus(GetDlgItem(IDOK)->m_hWnd);
      return;
   }

   int typesInBox = m_eapConfig.typesSelected.GetSize();
   if (typesInBox == 1)
   {
      // one selected but total = 1
      m_buttonUp.EnableWindow(FALSE);
      m_buttonDown.EnableWindow(FALSE);
      ::SetFocus(GetDlgItem(IDOK)->m_hWnd);
   }
   else
   {
      // more than one provider in the box
      if (selectedItem == 0)
      {
         // first one
         m_buttonUp.EnableWindow(FALSE);
         m_buttonDown.EnableWindow(TRUE);
         m_buttonDown.SetFocus();
      }
      else if (selectedItem == (typesInBox - 1) )
      {
         //last one
         m_buttonUp.EnableWindow(TRUE);
         m_buttonUp.SetFocus();
         m_buttonDown.EnableWindow(FALSE);
      }
      else
      {
         // middle
         m_buttonUp.EnableWindow(TRUE);
         m_buttonDown.EnableWindow(TRUE);
      }
   }
}


void EapNegotiate::UpdateEditButton(int selectedItem)
{
   if (selectedItem == LB_ERR)
   {
      m_buttonEdit.EnableWindow(FALSE);
      return;
   }
   int position = m_eapConfig.types.Find(
                     *m_eapConfig.typesSelected.GetAt(selectedItem));

   if (m_eapConfig.infoArray.ElementAt(position).m_stConfigCLSID.IsEmpty())
   {
      m_buttonEdit.EnableWindow(FALSE);
   }
   else
   {
      m_buttonEdit.EnableWindow(TRUE);
   }

   m_buttonRemove.EnableWindow(TRUE);
}


void EapNegotiate::UpdateTypesNotSelected()
{
   m_eapConfig.GetEapTypesNotSelected(m_typesNotSelected);
}

void EapNegotiate::DoDataExchange(CDataExchange* pDX)
{
   CHelpDialog::DoDataExchange(pDX);
   DDX_Control(pDX, IDC_BUTTON_EAP_UP, m_buttonUp);
   DDX_Control(pDX, IDC_BUTTON_EAP_DOWN, m_buttonDown);
   DDX_Control(pDX, IDC_BUTTON_ADD_EAP_PROVIDER, m_buttonAdd);
   DDX_Control(pDX, IDC_BUTTON_EDIT_EAP_PROVIDER, m_buttonEdit);
   DDX_Control(pDX, IDC_BUTTON_REMOVE_EAP_PROVIDER, m_buttonRemove);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\helptable.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       helptable.h
//
//--------------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////

#if !defined FA905F5D_C482_4895_BEBB_973466D0D1DA
#define FA905F5D_C482_4895_BEBB_973466D0D1DA
#pragma once

//=============================================================================
// Global Help Table for many Dialog IDs
//

#include <afxdlgs.h>

#include "hlptable.h"

//=============================================================================
// Dialog that handles Context Help -- uses MFC
//
class CHelpDialog : public CDialog  // talk back to property sheet
{
   DECLARE_DYNCREATE(CHelpDialog)
// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CHelpDialog)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, ::CPoint point);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
   
public:  
   CHelpDialog(UINT nIDTemplate = 0, CWnd* pParent = NULL) : CDialog(nIDTemplate, pParent)
   {
      SET_HELP_TABLE(nIDTemplate);     
   };

   // Set (or reset) style flags associated with a button control.
   void setButtonStyle(int controlId, long flags, bool set = true);

   // Set the focus to a control on the page.
   void setFocusControl(int controlId);

protected:

#ifdef   _DEBUG
   virtual void Dump( CDumpContext& dc ) const
   {
      dc << _T("CHelpDialog");
   };
#endif   

protected:
   const DWORD*            m_pHelpTable;
};


//////////////////////////////////////////////////////////////////////////////

#define  IDH_BUTTON_FROMCLIENT   20000353
#define  IDH_BUTTON_TOCLIENT  20000354
#define  IDH_BUTTONADDROUTE   20000501
#define  IDH_BUTTONDELETEROUTE   20000502
#define  IDH_BUTTONEDITTIMEOFDAY 20000156
#define  IDH_BUTTONSTATICROUTES  20000462
#define  IDH_CHECK_PORTTYPES  20000159
#define  IDH_CHECKAPPLYSTATICROUTES 20000461
#define  IDH_CHECKCALLERID 20000453
#define  IDH_CHECKCALLNUMBER  20000157
#define  IDH_CHECKIDLE  20000150
#define  IDH_CHECKREQUIREBAP  20000307
#define  IDH_CHECKRESTRICTPERIOD 20000154
#define  IDH_CHECKSESSIONLEN  20000152
#define  IDH_CHECKSTATICIPADDRESS   20000459
#define  IDH_COMBOUNIT  20000306
#define  IDH_EDITCALLBACK  20000458
#define  IDH_EDITCALLERID  20000454
#define  IDH_EDITCALLNUMBER   20000158
#define  IDH_EDITDEST   20000000
#define  IDH_EDITIDLETIME  20000151
#define  IDH_EDITIPADDRESS 20000460
#define  IDH_EDITMASK   20000001
#define  IDH_EDITMAXPORTS  20000303
#define  IDH_EDITMAXSESSION   20000153
#define  IDH_EDITMETRIC 20000002
#define  IDH_EDITPERCENT   20000304
#define  IDH_EDITTIME   20000305
#define  IDH_CHECK_ENC_NONE   20000207
#define  IDH_CHECK_ENC_BASIC  20000203
#define  IDH_CHECK_ENC_STRONGEST 20000205
#define  IDH_CHECK_ENC_STRONG 20000204
#define  IDH_ENCRYPTRADIOALLOW   20000201
#define  IDH_ENCRYPTRADIODISALLOW   20000200
#define  IDH_ENCRYPTRADIOREQUIRE 20000202
#define  IDH_IAS_BUTTON_ATTRIBUTE_ADD  20000251
#define  IDH_IAS_BUTTON_ATTRIBUTE_EDIT 20000253
#define  IDH_IAS_BUTTON_ATTRIBUTE_REMOVE  20000252
#define  IDH_IAS_LIST_ATTRIBUTES_IN_PROFILE  20000250
#define  IDH_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM 20000550
#define  IDH_LIST_PORTTYPES   20000160
#define  IDH_LISTROUTES 20000500
#define  IDH_PERMIT_ALLOW  20000450
#define  IDH_PERMIT_DENY   20000451
#define  IDH_PERMIT_POLICY 20000452
#define  IDH_RADIO_MULNK_MULTI   20000302
#define  IDH_RADIO_MULNK_NOTDEFINED 20000300
#define  IDH_RADIO_MULNK_SINGLE  20000301
#define  IDH_RADIOCLIENT   20000351
#define  IDH_RADIODEFAULT  20000352
#define  IDH_RADIONOCALLBACK  20000455
#define  IDH_RADIOSECURECALLBACKTO  20000457
#define  IDH_RADIOSERVER   20000350
#define  IDH_EDIT_FRAMED_IP   20000611
#define  IDH_RADIOSPECIFIC 20000610
#define  IDH_RADIOSETBYCALLER 20000456
#define  IDH_AUTH_CONFIG_EAP  20000052
#define  IDH_CHECKEAP   20000050
#define  IDH_CHECKMD5CHAP  20000055
#define  IDH_CHECKMSCHAP   20000054
#define  IDH_CHECKMSCHAP2  20000053
#define  IDH_CHECKNOAUTHEN 20000058
#define  IDH_CHECKPAP   20000056
#define  IDH_COMBOEAPTYPE  20000051
#define  IDH_SPINPERCENT      30000000
#define  IDH_SPINTIME      30000001
#define  IDH_SPINMAXPORTS  30000002
#define  IDH_CHECK_APC_MSCHAP2   20000612
#define  IDH_CHECK_APC_MSCHAP    20000613
#define  IDH_IAS_BUTTON_ADD_ATTRIB     20000615
#define  IDH_LIST_RESTRICTED     20000614
#define  IDH_LIST_EAP_SELECTED            20000620
#define  IDH_BUTTON_ADD_EAP_PROVIDER      20000621
#define  IDH_BUTTON_EDIT_EAP_PROVIDER     20000622
#define  IDH_BUTTON_REMOVE_EAP_PROVIDER   20000623
#define  IDH_BUTTON_EAP_UP                20000624
#define  IDH_BUTTON_EAP_DOWN              20000625
#define  IDH_LIST_EAP_ADD                 20000626
#define  IDH_EAP_METHODS                  20000627


const DWORD g_aHelpIDs_IDD_ADDROUTE[]=
{
   IDC_EDITMASK,IDH_EDITMASK,
   IDC_EDITMETRIC,IDH_EDITMETRIC,
   IDC_EDITDEST,IDH_EDITDEST,
   0, 0
};

const DWORD g_aHelpIDs_IDD_AUTHENTICATION_MERGE[]=
{
   IDC_CHECKNOAUTHEN,IDH_CHECKNOAUTHEN,
   IDC_CHECKPAP,IDH_CHECKPAP,
   IDC_CHECKMD5CHAP,IDH_CHECKMD5CHAP,
   IDC_CHECKMSCHAP2,IDH_CHECKMSCHAP2,
   IDC_CHECKMSCHAP,IDH_CHECKMSCHAP,
   IDC_CHECKMSCHAPPASS,IDH_CHECK_APC_MSCHAP,
   IDC_CHECKMSCHAP2PASS,IDH_CHECK_APC_MSCHAP2,
   IDC_EAP_METHODS, IDH_EAP_METHODS, 
   0, 0
};

const DWORD g_aHelpIDs_IDD_AUTHENTICATION_MERGE2K[]=
{
   IDC_CHECKNOAUTHEN,IDH_CHECKNOAUTHEN,
   IDC_CHECKPAP,IDH_CHECKPAP,
   IDC_CHECKMD5CHAP,IDH_CHECKMD5CHAP,
   IDC_CHECKMSCHAP2,IDH_CHECKMSCHAP2,
   IDC_CHECKMSCHAP,IDH_CHECKMSCHAP,
   IDC_AUTH_CONFIG_EAP,IDH_AUTH_CONFIG_EAP,
   IDC_COMBOEAPTYPE,IDH_COMBOEAPTYPE,
   IDC_CHECKEAP,IDH_CHECKEAP,
   IDC_CHECKMSCHAPPASS,IDH_CHECK_APC_MSCHAP,
   IDC_CHECKMSCHAP2PASS,IDH_CHECK_APC_MSCHAP2,
   0, 0
};

const DWORD g_aHelpIDs_IDD_CONSTRAINTS_MERGE[]=
{
   IDC_LIST_PORTTYPES,IDH_LIST_PORTTYPES,
   IDC_CHECK_PORTTYPES,IDH_CHECK_PORTTYPES,
   IDC_EDITCALLNUMBER,IDH_EDITCALLNUMBER,
   IDC_BUTTONEDITTIMEOFDAY,IDH_BUTTONEDITTIMEOFDAY,
   IDC_LISTTIMEOFDAY, IDH_LIST_RESTRICTED,
   IDC_CHECKRESTRICTPERIOD,IDH_CHECKRESTRICTPERIOD,
   IDC_CHECKIDLE,IDH_CHECKIDLE,
   IDC_EDITMAXSESSION,IDH_EDITMAXSESSION,
   IDC_CHECKSESSIONLEN,IDH_CHECKSESSIONLEN,
   IDC_EDITIDLETIME,IDH_EDITIDLETIME,
   IDC_CHECKCALLNUMBER,IDH_CHECKCALLNUMBER,
   0, 0
};
   
const DWORD g_aHelpIDs_IDD_ENCRYPTION_MERGE[]=
{
   IDC_CHECK_ENC_NONE,IDH_CHECK_ENC_NONE,
   IDC_CHECK_ENC_BASIC,IDH_CHECK_ENC_BASIC,
   IDC_CHECK_ENC_STRONG,IDH_CHECK_ENC_STRONG,
   IDC_CHECK_ENC_STRONGEST,IDH_CHECK_ENC_STRONGEST,
   0, 0
};

const DWORD g_aHelpIDs_IDD_IAS_ADVANCED_TAB[]=
{
   IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE,IDH_IAS_LIST_ATTRIBUTES_IN_PROFILE,
   IDC_IAS_BUTTON_ATTRIBUTE_ADD,IDH_IAS_BUTTON_ATTRIBUTE_ADD,
   IDC_IAS_BUTTON_ATTRIBUTE_REMOVE,IDH_IAS_BUTTON_ATTRIBUTE_REMOVE,
   IDC_IAS_BUTTON_ATTRIBUTE_EDIT,IDH_IAS_BUTTON_ATTRIBUTE_EDIT,
   0, 0
};

const DWORD g_aHelpIDs_IDD_IAS_ATTRIBUTE_ADD[]=
{
   IDC_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM,IDH_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM,
   IDC_IAS_BUTTON_ATTRIBUTE_ADD_SELECTED,IDH_IAS_BUTTON_ATTRIBUTE_ADD,
   0, 0
};

const DWORD g_aHelpIDs_IDD_MULTILINK_MERGE[]=
{
   IDC_RADIO_MULNK_MULTI,IDH_RADIO_MULNK_MULTI,
   IDC_RADIO_MULNK_SINGLE,IDH_RADIO_MULNK_SINGLE,
   IDC_EDITMAXPORTS,IDH_EDITMAXPORTS,
   IDC_EDITPERCENT,IDH_EDITPERCENT,
   IDC_EDITTIME,IDH_EDITTIME,
   IDC_COMBOUNIT,IDH_COMBOUNIT,
   IDC_CHECKREQUIREBAP,IDH_CHECKREQUIREBAP,
   IDC_RADIO_MULNK_NOTDEFINED,IDH_RADIO_MULNK_NOTDEFINED,
   IDC_SPINPERCENT,IDH_SPINPERCENT,    
   IDC_SPINTIME,IDH_SPINTIME,    
   IDC_SPINMAXPORTS,IDH_SPINMAXPORTS,
   0, 0
};
   
const DWORD g_aHelpIDs_IDD_NETWORKING_MERGE[]=
{
   IDC_BUTTON_FROMCLIENT,IDH_BUTTON_FROMCLIENT,
   IDC_BUTTON_TOCLIENT,IDH_BUTTON_TOCLIENT,
   IDC_RADIODEFAULT,IDH_RADIODEFAULT,
   IDC_RADIOCLIENT,IDH_RADIOCLIENT,
   IDC_RADIOSERVER,IDH_RADIOSERVER,
   IDC_RADIOSTATIC,IDH_RADIOSPECIFIC,
   IDC_EDIT_STATIC_IP_ADDRESS,IDH_EDIT_FRAMED_IP,
   0, 0
};

const DWORD g_aHelpIDs_IDD_RASDIALIN_MERGE[]=
{
   IDC_RADIOSECURECALLBACKTO,IDH_RADIOSECURECALLBACKTO,
   IDC_BUTTONSTATICROUTES,IDH_BUTTONSTATICROUTES,
   IDC_CHECKAPPLYSTATICROUTES,IDH_CHECKAPPLYSTATICROUTES,
   IDC_EDITIPADDRESS,IDH_EDITIPADDRESS,
   IDC_CHECKSTATICIPADDRESS,IDH_CHECKSTATICIPADDRESS,
   IDC_EDITCALLBACK,IDH_EDITCALLBACK,
   IDC_RADIOSETBYCALLER,IDH_RADIOSETBYCALLER,
   IDC_RADIONOCALLBACK,IDH_RADIONOCALLBACK,
   IDC_EDITCALLERID,IDH_EDITCALLERID,
   IDC_CHECKCALLERID,IDH_CHECKCALLERID,
   IDC_PERMIT_POLICY,IDH_PERMIT_POLICY,
   IDC_PERMIT_ALLOW,IDH_PERMIT_ALLOW,
   IDC_PERMIT_DENY,IDH_PERMIT_DENY,
   0, 0
};

const DWORD g_aHelpIDs_IDD_STATICROUTES[]=
{
   IDC_BUTTONDELETEROUTE,IDH_BUTTONDELETEROUTE,
   IDC_LISTROUTES,IDH_LISTROUTES,
   IDC_BUTTONADDROUTE,IDH_BUTTONADDROUTE,
   0, 0
};

//////////
// EAP Pages
//////////
const  DWORD g_aHelpIDs_IDD_EAP_NEGOCIATE[]=
{
   IDC_LIST_EAP_SELECTED, IDH_LIST_EAP_SELECTED, 
   IDC_BUTTON_ADD_EAP_PROVIDER, IDH_BUTTON_ADD_EAP_PROVIDER,
   IDC_BUTTON_EDIT_EAP_PROVIDER, IDH_BUTTON_EDIT_EAP_PROVIDER,
   IDC_BUTTON_REMOVE_EAP_PROVIDER, IDH_BUTTON_REMOVE_EAP_PROVIDER,
   IDC_BUTTON_EAP_UP, IDH_BUTTON_EAP_UP, 
   IDC_BUTTON_EAP_DOWN, IDH_BUTTON_EAP_DOWN, 
   0,0
};

const  DWORD g_aHelpIDs_IDD_EAP_ADD[]=
{
   IDC_LIST_EAP_ADD, IDH_LIST_EAP_ADD,
   0,0
};


#endif // FA905F5D_C482_4895_BEBB_973466D0D1DA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\eapprofile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class EapProfile.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <algorithm>
#include "EapProfile.h"
#include <align.h>


EapProfile::EapProfile() throw ()
   : begin(0),
     end(0),
     capacity(0)
{
}


EapProfile::~EapProfile() throw ()
{
   Clear();
   CoTaskMemFree(begin);
}


HRESULT EapProfile::Assign(const EapProfile& rhs) throw ()
{
   if (this == &rhs)
   {
      return S_OK;
   }

   Clear();
   Reserve(rhs.Size());

   for (const ConfigData* i = rhs.begin; i != rhs.end; ++i)
   {
      end->length = i->length;
      end->value = static_cast<BYTE*>(CoTaskMemAlloc(i->length));
      if (end->value == 0)
      {
         Clear();
         return E_OUTOFMEMORY;
      }
      memcpy(end->value, i->value, i->length);
      ++end;
   }

   return S_OK;
}


HRESULT EapProfile::Load(VARIANT& src) throw ()
{
   HRESULT hr;

   Clear();

   if (V_VT(&src) == VT_EMPTY)
   {
      return S_OK;
   }

   if (V_VT(&src) != (VT_ARRAY | VT_VARIANT))
   {
      return DISP_E_TYPEMISMATCH;
   }

   const SAFEARRAY* sa = V_ARRAY(&src);
   if (sa == 0)
   {
      return E_POINTER;
   }

   // Find the first and last elements of the VARIANT array.
   VARIANT* first = static_cast<VARIANT*>(sa->pvData);
   VARIANT* last = first + sa->rgsabound[0].cElements;

   // Ensure that all the VARIANTs contain a valid config value.
   for (const VARIANT* i = first; i != last; ++i)
   {
      hr = ValidateConfigChunk(*i);
      if (FAILED(hr))
      {
         return hr;
      }
   }

   // Sort the VARIANTs by type and sequence.
   std::sort(first, last, LessThan);

   // Gather the config for each type.
   for (const VARIANT* j = first; j != last; )
   {
      BYTE type = ExtractString(*j)[0];

      // Find the end of the type's config.
      const VARIANT* typeEnd = j + 1;
      while ((typeEnd != last) && (ExtractString(*typeEnd)[0] == type))
      {
         ++typeEnd;
      }

      // Gather the config for this type.
      hr = GatherAndAppend(j, typeEnd);
      if (FAILED(hr))
      {
         return hr;
      }

      // Advance to the next type.
      j = typeEnd;
   }

   return S_OK;
}


HRESULT EapProfile::Store(VARIANT& dst) throw ()
{
   HRESULT hr;

   // Clear the out parameter.
   VariantInit(&dst);

   // Computer the number of VARIANTs required.
   DWORD nelem = 0;
   for (const ConfigData* i = begin; i != end; ++i)
   {
      nelem += ChunksRequired(*i);
   }

   // Allocate the SAFEARRAY for the result.
   SAFEARRAY* sa = SafeArrayCreateVector(VT_VARIANT, 0, nelem);
   if (sa == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Scatter the config into the SAFEARRAY.
   VARIANT* nextValue = static_cast<VARIANT*>(sa->pvData);
   for (const ConfigData* j = begin; j != end; ++j)
   {
      hr = Scatter(*j, nextValue);
      if (FAILED(hr))
      {
         SafeArrayDestroy(sa);
         return hr;
      }
   }

   // Store the result.
   V_VT(&dst) = VT_ARRAY | VT_VARIANT;
   V_ARRAY(&dst) = sa;

   return S_OK;
}


void EapProfile::Clear() throw ()
{
   while (end > begin)
   {
      --end;

      CoTaskMemFree(end->value);
   }
}


void EapProfile::ClearExcept(BYTE type) throw ()
{
   for (ConfigData* i = begin; i != end; )
   {
      if (i->value[0] != type)
      {
         // Free the config.
         CoTaskMemFree(i->value);

         // Decrement the number of elements.
         --end;

         // After Load completes we don't care if the array is sorted so we can
         // just move the last element into the empty slot.
         *i = *end;
      }
      else
      {
         ++i;
      }
   }
}


void EapProfile::Erase(BYTE type) throw ()
{
   for (ConfigData* i = begin; i != end; ++i)
   {
      if (i->value[0] == type)
      {
         // Free the config.
         CoTaskMemFree(i->value);

         // Decrement the number of elements.
         --end;

         // After Load completes we don't care if the array is sorted so we can
         // just move the last element into the empty slot.
         *i = *end;

         break;
      }
   }
}


void EapProfile::Get(BYTE type, ConstConfigData& dst) const throw ()
{
   for (const ConfigData* i = begin; i != end; ++i)
   {
      if (i->value[0] == type)
      {
         // The EAP DLL doesn't want the type byte.
         dst.length = i->length - ALIGN_WORST;
         dst.value = i->value + ALIGN_WORST;
         return;
      }
   }

   dst.length = 0;
   dst.value = 0;
}


HRESULT EapProfile::Set(BYTE type, const ConstConfigData& newConfig) throw ()
{
   if (newConfig.length == 0)
   {
      Erase(type);
      return S_OK;
   }

   if (newConfig.value == 0)
   {
      return E_POINTER;
   }

   if (ChunksRequired(newConfig) > maxChunks)
   {
      return E_INVALIDARG;
   }

   // Ensure that we have room for the new element before we copy the value.
   HRESULT hr = Reserve(Size() + 1);
   if (FAILED(hr))
   {
      return hr;
   }

   // One extra byte for the type tag. Rounded to ALIGN_WORST
   DWORD len = newConfig.length + ALIGN_WORST;
   BYTE* val = static_cast<BYTE*>(CoTaskMemAlloc(len));
   if (val == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Erase any existing config for the type.
   Erase(type);

   // Start with the lead type byte.
   val[0] = type;
   // And then the rest of the configuration.
   memcpy(val + ALIGN_WORST, newConfig.value, newConfig.length);

   // Append the result.
   end->length = len;
   end->value = val;
   ++end;

   return S_OK;
}


void EapProfile::Pop(ConfigData& dst) throw ()
{
   --end;
   dst = *end;
}


void EapProfile::Swap(EapProfile& other) throw ()
{
   std::swap(begin, other.begin);
   std::swap(end, other.end);
   std::swap(capacity, other.capacity);
}


inline EapProfile::SeqNum EapProfile::ExtractSequence(const BYTE* src) throw ()
{
   return (static_cast<SeqNum>(src[0]) << 8) | static_cast<SeqNum>(src[1]);
}


inline void EapProfile::InsertSequence(SeqNum seq, BYTE* dst) throw ()
{
   dst[0] = static_cast<BYTE>((seq >> 8) & 0xFF);
   dst[1] = static_cast<BYTE>(seq & 0xFF);
}


HRESULT EapProfile::GatherAndAppend(
                       const VARIANT* first,
                       const VARIANT* last
                       ) throw ()
{
   HRESULT hr = Reserve(Size() + 1);
   if (FAILED(hr))
   {
      return hr;
   }

   // 1 type byte for the entire config.
   DWORD len = ALIGN_WORST;
   for (const VARIANT* i = first; i != last; ++i)
   {
      // Ignore the SDO header.
      len += ExtractLength(*i) - sdoHeaderSize;
   }

   BYTE* val = static_cast<BYTE*>(CoTaskMemAlloc(len));
   if (val == 0)
   {
      return E_OUTOFMEMORY;
   }

   end->length = len;
   end->value = val;
   ++end;

   // Get the type byte out of the first chunk.
   val[0] = ExtractString(*first)[0];
   // keep the real value aligned 
   val += ALIGN_WORST;

   // Now concatenate the chunks, ignoring the header.
   for (const VARIANT* j = first; j != last; ++j)
   {
      size_t chunkSize = (ExtractLength(*j) - sdoHeaderSize);
      memcpy(val, (ExtractString(*j) + sdoHeaderSize), chunkSize);
      val += chunkSize;
   }

   return S_OK;
}


HRESULT EapProfile::Scatter(
                       const ConstConfigData& src,
                       VARIANT*& dst
                       ) throw ()
{
   BYTE type = src.value[0];
   
   const BYTE* val = src.value + ALIGN_WORST;
   DWORD len = src.length - ALIGN_WORST;

   // Sequence number.
   SeqNum sequence = 0;

   // Keep scattering until it's all gone.
   while (len > 0)
   {
      // Compute the size of this chunk.
      size_t chunkSize = (len > maxChunkSize) ? maxChunkSize : len;

      // Create a SAFEARRAY of BYTEs to hold the data.
      SAFEARRAY* sa = SafeArrayCreateVector(
                         VT_UI1,
                         0,
                         (chunkSize + sdoHeaderSize)
                         );
      if (sa == 0)
      {
         return E_OUTOFMEMORY;
      }

      // Add the type byte and sequence number.
      BYTE* chunk = static_cast<BYTE*>(sa->pvData);
      chunk[0] = type;
      InsertSequence(sequence, chunk + 1);
      memcpy(chunk + sdoHeaderSize, val, chunkSize);

      // Store it in the dst VARIANT.
      V_VT(dst) = VT_ARRAY | VT_UI1;
      V_ARRAY(dst) = sa;
      ++dst;

      // Update our cursor.
      val += chunkSize;
      len -= chunkSize;
      ++sequence;
   }

   return S_OK;
}


HRESULT EapProfile::Reserve(size_t newCapacity) throw ()
{
   if (newCapacity <= capacity)
   {
      return S_OK;
   }

   // Ensure we grow wisely.
   const size_t minGrowth = (capacity < 4) ? 4 : ((capacity * 3) / 2);
   if (newCapacity < minGrowth)
   {
      newCapacity = minGrowth;
   }


   // Allocate the new array.
   size_t nbyte = newCapacity * sizeof(ConfigData);
   ConfigData* newBegin = static_cast<ConfigData*>(
                                          CoTaskMemAlloc(nbyte)
                                          );
   if (newBegin == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Save the existing data.
   memcpy(newBegin, begin, Size() * sizeof(ConfigData));

   // Update the state.
   end = newBegin + Size();
   capacity = newCapacity;

   // Now it's safe to free the old array and swap in the new.
   CoTaskMemFree(begin);
   begin = newBegin;

   return S_OK;
}


inline size_t EapProfile::ChunksRequired(const ConstConfigData& str) throw ()
{
   return ((str.length - ALIGN_WORST) + (maxChunkSize - 1)) / maxChunkSize;
}


inline DWORD EapProfile::ExtractLength(const VARIANT& src) throw ()
{
   return V_ARRAY(&src)->rgsabound[0].cElements;
}


inline const BYTE* EapProfile::ExtractString(const VARIANT& src) throw ()
{
   return static_cast<const BYTE*>(V_ARRAY(&src)->pvData);
}


bool EapProfile::LessThan(const VARIANT& lhs, const VARIANT& rhs) throw ()
{
   const BYTE* val1 = ExtractString(lhs);
   const BYTE* val2 = ExtractString(rhs);

   // Sort first by type, then sequence.
   if (val1[0] < val2[0])
   {
      return true;
   }
   else if (val1[0] == val2[0])
   {
      return ExtractSequence(val1 + 1) < ExtractSequence(val2 + 1);
   }
   else
   {
      return false;
   }
}


HRESULT EapProfile::ValidateConfigChunk(const VARIANT& value) throw ()
{
   if (V_VT(&value) != (VT_ARRAY | VT_UI1))
   {
      return DISP_E_TYPEMISMATCH;
   }

   const SAFEARRAY* sa = V_ARRAY(&value);
   if (sa == 0)
   {
      return E_POINTER;
   }

   // The data has to be big enough for the header and 1 data byte.
   if (sa->rgsabound[0].cElements <= sdoHeaderSize)
   {
      return E_INVALIDARG;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\helper.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   helper.cpp
      Implementation of the following helper classes:

      CDlgHelper -- enable, check, getcheck of dialog items
      CStrArray -- manages an array of CString*
         It doesn't duplicate the string when add
         It deletes the pointers during destruction
         It imports and exports SAFEARRAY of BSTRs
         It has copy operatators
      CManagedPage -- provide a middle layer between CpropertyPage and
         real property page class to manage: readonly, set modify, and
         context help info.

      And global functions:
         BOOL CheckADsError() -- check error code from ADSI
         void DecorateName() -- make new name to "CN=name" for LDAP

    FILE HISTORY:

*/

#include "stdafx.h"
#include <afxtempl.h>
#include <winldap.h>
#include "helper.h"
#include "resource.h"
#include "lm.h"
#include "dsrole.h"
#include "lmserver.h"
#include "iastrace.h"
#include "raseapif.h"

//build a StrArray from a safe array
CBYTEArray::CBYTEArray(SAFEARRAY* pSA)
{
   if(pSA)  AppendSA(pSA);
}


//build a DWArray from another array
CBYTEArray::CBYTEArray(const CBYTEArray& ba)
{
   int   count = ba.GetSize();

   for(int i = 0; i < count; i++)
   {
      try{
         Add(ba[i]);
      }
      catch(CMemoryException*)
      {
         throw;
      }
   }
}

//build a StrArray from a safe array
bool CBYTEArray::AppendSA(SAFEARRAY* pSA)
{
   if(!pSA) return false;

   CString*    pString = NULL;
   long        lIter;
   long        lBound, uBound;
   union {
      VARIANT        v;
      BYTE        b;
   } value;

   bool        bSuc = true;   // ser return value to true;

   USES_CONVERSION;
   VariantInit(&(value.v));

   SafeArrayGetLBound(pSA, 1, &lBound);
   SafeArrayGetUBound(pSA, 1, &uBound);
   for(lIter = lBound; lIter <= uBound; lIter++)
   {
      if(SUCCEEDED(SafeArrayGetElement(pSA, &lIter, &value)))
      {
         if(pSA->cbElements == sizeof(VARIANT))
            Add(V_UI1(&(value.v)));
         else
            Add(value.b);
      }
   }
   return bSuc;
}

// convert an array of CString to SAFEARRAY
CBYTEArray::operator SAFEARRAY*()
{
   USES_CONVERSION;
   int         count = GetSize();
   if(count == 0) return NULL;

   SAFEARRAYBOUND bound[1];
   SAFEARRAY*     pSA = NULL;
   long        l[2];

   VARIANT  v;
   VariantInit(&v);

   bound[0].cElements = count;
   bound[0].lLbound = 0;
   try{
      // creat empty right size array
#ifdef   ARRAY_OF_VARIANT_OF_UI1
      pSA = SafeArrayCreate(VT_VARIANT, 1, bound);
#else
      pSA = SafeArrayCreate(VT_UI1, 1, bound);
#endif
      if(NULL == pSA)   return NULL;

      // put in each element
      for (long i = 0; i < count; i++)
      {
#ifdef   ARRAY_OF_VARIANT_OF_UI1
         V_VT(&v) = VT_UI1;
         V_UI1(&v) = GetAt(i);
         l[0] = i;
         HRESULT hr = SafeArrayPutElement(pSA, l, &v);
         VariantClear(&v);
         if (FAILED(hr))
         {
            throw hr;
         }
#else
         BYTE ele = GetAt(i);
         l[0] = i;
         HRESULT hr = SafeArrayPutElement(pSA, l, &ele);
         if (FAILED(hr))
         {
            throw hr;
         }
#endif
      }
   }
   catch(...)
   {
      SafeArrayDestroy(pSA);
      pSA = NULL;

      VariantClear(&v);

      throw;
   }

   return pSA;
}

// return index if found, otherwise -1;
int CBYTEArray::Find(const BYTE b) const
{
   int   count = GetSize();

   while(count--)
   {
      if(GetAt(count) == b) break;
   }
   return count;
}

CBYTEArray& CBYTEArray::operator = (const CBYTEArray& ba)
{
   int   count;

   RemoveAll();

   // copy new
   count = ba.GetSize();

   for(int i = 0; i < count; i++)
   {
      Add(ba[i]);
   }

   return *this;
}


HRESULT CBYTEArray::AssignBlob(PBYTE pByte, DWORD size)
{
   RemoveAll();

   // copy new
   try{

   for(int i = 0; i < size; i++)
   {
      Add(*pByte++);
   }

   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      RemoveAll();
      return E_OUTOFMEMORY;
   }

   return S_OK;
}

HRESULT  CBYTEArray::GetBlob(PBYTE pByte, DWORD* pSize)
{
   *pSize = GetSize();
   if(pByte == NULL) return S_OK;

   ASSERT(*pSize >= GetSize());
   int i = 0;
   while(i < GetSize() && i < *pSize)
   {
      *pByte++ = GetAt(i++);
   }

   *pSize = i;

   return S_OK;
}


// helper function -- enable a dialog button
void CDlgHelper::EnableDlgItem(CDialog* pDialog, int id, bool bEnable)
{
   CWnd*  pWnd = pDialog->GetDlgItem(id);
   ASSERT(pWnd);
   pWnd->EnableWindow(bEnable);
}

// helper function -- set check status of a dialog button
void CDlgHelper::SetDlgItemCheck(CDialog* pDialog, int id, int nCheck)
{
   CButton*  pButton = (CButton*)pDialog->GetDlgItem(id);
   ASSERT(pButton);
   pButton->SetCheck(nCheck);
}

// helper function -- get check status of a dialog button
int CDlgHelper::GetDlgItemCheck(CDialog* pDialog, int id)
{
   CButton*  pButton = (CButton*)(pDialog->GetDlgItem(id));
   ASSERT(pButton);
   return pButton->GetCheck();
}

CStrArray& CStrArray::operator = (const CStrArray& sarray)
{
   int   count = GetSize();
   CString* pString;

   // remove existing members
   while(count --)
   {
      pString = GetAt(0);
      RemoveAt(0);
      delete pString;
   }

   // copy new
   count = sarray.GetSize();

   for(int i = 0; i < count; i++)
   {
      pString = new CString(*sarray[i]);
      Add(pString);
   }

   return *this;
}

// convert an array of CString to SAFEARRAY
CStrArray::operator SAFEARRAY*()
{
   USES_CONVERSION;
   int         count = GetSize();
   if(count == 0) return NULL;

   SAFEARRAYBOUND bound[1];
   SAFEARRAY*     pSA = NULL;
   CString*    pStr = NULL;
   long        l[2];
   VARIANT  v;
   VariantInit(&v);

   bound[0].cElements = count;
   bound[0].lLbound = 0;
   try{
      // creat empty right size array
      pSA = SafeArrayCreate(VT_VARIANT, 1, bound);
      if(NULL == pSA)   return NULL;

      // put in each element
      for (long i = 0; i < count; i++)
      {
         pStr = GetAt(i);
         V_VT(&v) = VT_BSTR;
         V_BSTR(&v) = T2BSTR((LPTSTR)(LPCTSTR)(*pStr));
         l[0] = i;
         HRESULT hr = SafeArrayPutElement(pSA, l, &v);
         VariantClear(&v);
         if ( FAILED(hr) )
         {
            throw hr;
         }
      }
   }
   catch(...)
   {
      SafeArrayDestroy(pSA);
      pSA = NULL;
      VariantClear(&v);
      throw;
   }

   return pSA;
}

//build a StrArray from another array
CStrArray::CStrArray(const CStrArray& sarray)
{
   CString* pString = NULL;
   for (int i = 0; i < sarray.GetSize(); i++)
   {
      try
      {
         pString = new CString(*sarray[i]);
         Add(pString);
      }
      catch(CMemoryException*)
      {
         delete pString;
         throw;
      }
   }
}

int CStrArray::AddDuplicate(const CString& Str)
{
   CString* pString;

   // no need to set a default value. Will throw if Add fails
   int position;
   try
   {
      pString = new CString(Str);
      position = Add(pString);
   }
   catch(CMemoryException*)
   {
      delete pString;
      throw;
   }
   return position;
}

void CStrArray::DeleteAt(int nIndex)
{
   CString* pString = GetAt(nIndex);
   RemoveAt(nIndex);
   delete pString;
}

//build a StrArray from a safe array
CStrArray::CStrArray(SAFEARRAY* pSA)
{
   if(pSA)  AppendSA(pSA);
}

//remove the elements from the array and delete them
int CStrArray::DeleteAll()
{
   int         ret, count;
   CString* pStr;

   ret = count = GetSize();

   while(count--)
   {
      pStr = GetAt(0);
      RemoveAt(0);
      delete pStr;
   }

   return ret;
}

//build a StrArray from a safe array
bool CStrArray::AppendSA(SAFEARRAY* pSA)
{
   if(!pSA) return false;

   CString*    pString = NULL;
   long        lIter;
   long        lBound, uBound;
   VARIANT        v;
   bool        bSuc = true;   // ser return value to true;

   USES_CONVERSION;
   VariantInit(&v);

   try{

      SafeArrayGetLBound(pSA, 1, &lBound);
      SafeArrayGetUBound(pSA, 1, &uBound);
      for(lIter = lBound; lIter <= uBound; lIter++)
      {
         if(SUCCEEDED(SafeArrayGetElement(pSA, &lIter, &v)))
         {
            if(V_VT(&v) == VT_BSTR)
            {
               pString = new CString;
               (*pString) = (LPCTSTR)W2T(V_BSTR(&v));
               Add(pString);
            }
         }
      }
   }
   catch(CMemoryException*)
   {
      delete pString;
      VariantClear(&v);
      bSuc = false;
      throw;
   }

   return bSuc;
}

//build a StrArray from a safe array
CStrArray::~CStrArray()
{
   DeleteAll();
}

// return index if found, otherwise -1;
int CStrArray::Find(const CString& Str) const
{
   int count = GetSize();

   while(count--)
   {
      if (*GetAt(count) == Str) break;
   }
   return count;
}

//build a StrArray from a safe array
CDWArray::CDWArray(SAFEARRAY* pSA)
{
   if(pSA)  AppendSA(pSA);
}


//build a DWArray from another array
CDWArray::CDWArray(const CDWArray& dwarray)
{
   int   count = dwarray.GetSize();

   for(int i = 0; i < count; i++)
   {
      try{
         Add(dwarray[i]);
      }
      catch(CMemoryException*)
      {
         throw;
      }
   }
}

//build a StrArray from a safe array
bool CDWArray::AppendSA(SAFEARRAY* pSA)
{
   if(!pSA) return false;

   CString*    pString = NULL;
   long        lIter;
   long        lBound, uBound;
   union {
      VARIANT        v;
      DWORD       dw;
   } value;

   bool        bSuc = true;   // ser return value to true;

   USES_CONVERSION;
   VariantInit(&(value.v));

   SafeArrayGetLBound(pSA, 1, &lBound);
   SafeArrayGetUBound(pSA, 1, &uBound);
   for(lIter = lBound; lIter <= uBound; lIter++)
   {
      if(SUCCEEDED(SafeArrayGetElement(pSA, &lIter, &value)))
      {
         if(pSA->cbElements == sizeof(VARIANT))
            Add(V_I4(&(value.v)));
         else
            Add(value.dw);
      }
   }
   return bSuc;
}

// convert an array of CString to SAFEARRAY
CDWArray::operator SAFEARRAY*()
{
   USES_CONVERSION;
   int         count = GetSize();
   if(count == 0) return NULL;

   SAFEARRAYBOUND bound[1];
   SAFEARRAY*     pSA = NULL;
   long        l[2];
#if 1
   VARIANT  v;
   VariantInit(&v);
#endif
   bound[0].cElements = count;
   bound[0].lLbound = 0;
   try{
      // creat empty right size array
      pSA = SafeArrayCreate(VT_VARIANT, 1, bound);
      if(NULL == pSA)   return NULL;

      // put in each element
      for (long i = 0; i < count; i++)
      {
#if 1    // changed to use VT_I4 directly, rather inside a variant
         V_VT(&v) = VT_I4;
         V_I4(&v) = GetAt(i);
         l[0] = i;
         HRESULT hr = SafeArrayPutElement(pSA, l, &v);
         VariantClear(&v);
         if (FAILED(hr))
         {
            throw hr;
         }
#else
         int ele = GetAt(i);
         l[0] = i;
         HRESULT hr = SafeArrayPutElement(pSA, l, &ele);
         if (FAILED(hr))
         {
            throw hr;
         }
#endif
      }
   }
   catch(...)
   {
      SafeArrayDestroy(pSA);
      pSA = NULL;
#if 0
      VariantClear(&v);
#endif
      throw;
   }

   return pSA;
}

// return index if found, otherwise -1;
int CDWArray::Find(const DWORD dw) const
{
   int   count = GetSize();

   while(count--)
   {
      if(GetAt(count) == dw) break;
   }
   return count;
}

CDWArray& CDWArray::operator = (const CDWArray& dwarray)
{
   int   count;

   RemoveAll();

   // copy new
   count = dwarray.GetSize();

   for(int i = 0; i < count; i++)
   {
      Add(dwarray[i]);
   }

   return *this;
}

IMPLEMENT_DYNCREATE(CManagedPage, CPropertyPage)


void CManagedPage::OnContextMenu(CWnd* pWnd, CPoint point)
{
   if (m_pHelpTable)
      ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)m_pHelpTable);
}

BOOL CManagedPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
   if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
   {
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)m_pHelpTable);
   }
    return TRUE;
}

int CManagedPage::MyMessageBox(UINT ids, UINT nType)
{
   CString string;
   string.LoadString(ids);
   return MyMessageBox1(string, NULL, nType);
}

int CManagedPage::MyMessageBox1(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
{
   CString caption;
   if (lpszCaption == NULL)
   {
      GetWindowText(caption);
   }
   else
   {
      caption = lpszCaption;
   }

   return MessageBox(lpszText, caption, nType);
}


//+----------------------------------------------------------------------------
//
//  Function:   CheckADsError
//
//  Sysnopsis:  Checks the result code from an ADSI call.
//
//  Returns:    TRUE if no error.
//
//-----------------------------------------------------------------------------
BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line)
{
   if (SUCCEEDED(hr))
      return TRUE;

   if( hr == E_ADS_PROPERTY_NOT_FOUND && fIgnoreAttrNotFound)
      return TRUE;

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        DWORD dwErr;
        WCHAR wszErrBuf[MAX_PATH+1];
        WCHAR wszNameBuf[MAX_PATH+1];
        ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
        if ((LDAP_RETCODE)dwErr == LDAP_NO_SUCH_ATTRIBUTE && fIgnoreAttrNotFound)
        {
            return TRUE;
        }
        IASTracePrintf("Extended Error 0x%x: %ws %ws (%s @line %d)", dwErr,
                     wszErrBuf, wszNameBuf, file, line);
    }
    else
      IASTracePrintf("Error %08lx (%s @line %d)", hr, file, line);

    return FALSE;
}

void DecorateName(LPWSTR outString, LPCWSTR inString)
{
  wcscpy (outString, L"CN=");
  wcscat(outString, inString);
}

void FindNameByDN(LPWSTR outString, LPCWSTR inString)
{

   LPWSTR   p = wcsstr(inString, L"CN=");
   if(!p)
      p = wcsstr(inString, L"cn=");

   if(!p)
      wcscpy(outString, inString);
   else
   {
      p+=3;
      LPWSTR   p1 = outString;
      while(*p == L' ') p++;
      while(*p != L',')
         *p1++ = *p++;
      *p1 = L'\0';
   }
}

#define MAX_STRING 1024

//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void ReportError(HRESULT hr, int nStr, HWND hWnd)
{
   PTSTR ptzSysMsg;
   int      cch;
   CString  AppStr;
   CString  SysStr;
   CString  ErrTitle;
   CString ErrMsg;

   if(S_OK == hr)
      return;

   IASTracePrintf("*+*+* ReportError called with hr = %lx", hr);
   if (!hWnd)
   {
      hWnd = GetDesktopWindow();
   }

   try{
      if (nStr)
      {
         AppStr.LoadString(nStr);
      }

      if(HRESULT_FACILITY(hr) == FACILITY_WIN32)   // if win32 error code
         cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, HRESULT_CODE(hr), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (PTSTR)&ptzSysMsg, 0, NULL);
      else
         cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (PTSTR)&ptzSysMsg, 0, NULL);

      if (!cch) { //try ads errors
         HMODULE     adsMod;
         adsMod = GetModuleHandle (L"activeds.dll");
         cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                  adsMod, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (PTSTR)&ptzSysMsg, 0, NULL);
      }
      if (!cch)
      {
         CString  str;
         str.LoadString(IDS_ERR_ERRORCODE);
         SysStr.Format(str, hr);
      }
      else
      {
         SysStr = ptzSysMsg;
         LocalFree(ptzSysMsg);
      }

      ErrTitle.LoadString(IDS_ERR_TITLE);

      if(!AppStr.IsEmpty())
      {
         ErrMsg.Format(AppStr, (LPCTSTR)SysStr);
      }
      else
      {
         ErrMsg = SysStr;
      }

      MessageBox(hWnd, (LPCTSTR)ErrMsg, (LPCTSTR)ErrTitle, MB_OK | MB_ICONINFORMATION);
   }catch(CMemoryException* pException)
   {
      pException->Delete();
      MessageBox(hWnd, _T("No enought memory, please close other applications and try again."), _T("ACS Snapin Error"), MB_OK | MB_ICONINFORMATION);
   }
}

/////////////////////////////////////////////////////////////////////////////
// Min Chars Dialog Data Validation

void AFXAPI DDV_MinChars(CDataExchange* pDX, CString const& value, int nChars)
{
    ASSERT(nChars >= 1);        // allow them something
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)
    {
        TCHAR szT[32];
        wsprintf(szT, _T("%d"), nChars);
        CString prompt;
        AfxFormatString1(prompt, IDS_MIN_CHARS, szT);
        AfxMessageBox(prompt, MB_ICONEXCLAMATION, IDS_MIN_CHARS);
        prompt.Empty(); // exception prep
        pDX->Fail();
    }
}

/*!--------------------------------------------------------------------------
   HrIsStandaloneServer
      Returns S_OK if the machine name passed in is a standalone server,
      or if pszMachineName is S_FALSE.

      Returns FALSE otherwise.
   Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT  HrIsStandaloneServer(LPCWSTR pMachineName)
{
   DWORD      netRet = 0;
   HRESULT    hr = S_OK;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdsRole = NULL;

   netRet = DsRoleGetPrimaryDomainInformation(pMachineName, DsRolePrimaryDomainInfoBasic, (LPBYTE*)&pdsRole);

   if(netRet != 0)
   {
      hr = HRESULT_FROM_WIN32(netRet);
      goto L_ERR;
   }

   ASSERT(pdsRole);

   // if the machine is not a standalone server
   if(pdsRole->MachineRole != DsRole_RoleStandaloneServer)
    {
      hr = S_FALSE;
    }

L_ERR:
   if(pdsRole)
      DsRoleFreeMemory(pdsRole);

    return hr;
}

/*!--------------------------------------------------------------------------
      HrIsNTServer
    Author:
 ---------------------------------------------------------------------------*/
HRESULT  HrIsNTServer(LPCWSTR pMachineName)
{
    HRESULT        hr = S_OK;
    SERVER_INFO_102* pServerInfo102 = NULL;
    NET_API_STATUS   netRet = 0;

   netRet = NetServerGetInfo((LPWSTR)pMachineName, 102, (LPBYTE*)&pServerInfo102);

   if(netRet != 0)
   {
      hr = HRESULT_FROM_WIN32(netRet);
      goto L_ERR;
   }

   ASSERT(pServerInfo102);

    if (!(pServerInfo102->sv102_type & SV_TYPE_SERVER_NT))
    {
         hr = S_FALSE;
    }

L_ERR:

   if(pServerInfo102)
      NetApiBufferFree(pServerInfo102);

    return hr;
}


struct EnableChildControlsEnumParam
{
   HWND  m_hWndParent;
   DWORD m_dwFlags;
};

BOOL CALLBACK EnableChildControlsEnumProc(HWND hWnd, LPARAM lParam)
{
   EnableChildControlsEnumParam *   pParam;

   pParam = reinterpret_cast<EnableChildControlsEnumParam *>(lParam);

   // Enable/disable only if this is an immediate descendent
   if (GetParent(hWnd) == pParam->m_hWndParent)
   {
      if (pParam->m_dwFlags & PROPPAGE_CHILD_SHOW)
         ::ShowWindow(hWnd, SW_SHOW);
      else if (pParam->m_dwFlags & PROPPAGE_CHILD_HIDE)
         ::ShowWindow(hWnd, SW_HIDE);

      if (pParam->m_dwFlags & PROPPAGE_CHILD_ENABLE)
         ::EnableWindow(hWnd, TRUE);
      else if (pParam->m_dwFlags & PROPPAGE_CHILD_DISABLE)
         ::EnableWindow(hWnd, FALSE);
   }
   return TRUE;
}

HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags)
{
   EnableChildControlsEnumParam  param;

   param.m_hWndParent = hWnd;
   param.m_dwFlags = dwFlags;

   EnumChildWindows(hWnd, EnableChildControlsEnumProc, (LPARAM) &param);
   return S_OK;
}

HRESULT  LoadEapProviders(HKEY hkeyBase, AuthProviderArray *pProvList, BOOL bStandAlone);

HRESULT  GetEapProviders(LPCWSTR pServerName, AuthProviderArray *pProvList)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   BOOL bStandAlone = ( S_OK == HrIsStandaloneServer(pServerName));

   // Get the list of EAP providers
   // ----------------------------------------------------------------
   HRESULT  hr = S_OK;
   RegKey regkeyEap;
   DWORD dwErr = regkeyEap.Open(
                                   HKEY_LOCAL_MACHINE,
                                   RAS_EAP_REGISTRY_LOCATION,
                                   KEY_ALL_ACCESS,
                                   pServerName
                               );
   if ( ERROR_SUCCESS == dwErr )
   {
         hr = LoadEapProviders(regkeyEap, pProvList, bStandAlone);
   }
   else
   {
      hr = HRESULT_FROM_WIN32(dwErr);
   }

   return hr;
}

/*!--------------------------------------------------------------------------
   DATA_SRV_AUTH::LoadEapProviders
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT  LoadEapProviders(HKEY hkeyBase, AuthProviderArray *pProvList, BOOL bStandAlone)
{
    RegKey      regkeyProviders;
    HRESULT     hr = S_OK;
    HRESULT     hrIter;
    RegKeyIterator regkeyIter;
    CString     stKey;
    RegKey      regkeyProv;
    AuthProviderData  data;
    DWORD      dwErr;
    DWORD      dwData;

    ASSERT(hkeyBase);
    ASSERT(pProvList);

    // Open the providers key
    // ----------------------------------------------------------------
    regkeyProviders.Attach(hkeyBase);

    CHECK_HR(hr = regkeyIter.Init(&regkeyProviders) );

    for ( hrIter=regkeyIter.Next(&stKey); hrIter == S_OK;
        hrIter=regkeyIter.Next(&stKey), regkeyProv.Close() )
    {
      // Open the key
      // ------------------------------------------------------------
      dwErr = regkeyProv.Open(regkeyProviders, stKey, KEY_READ);
      if ( dwErr != ERROR_SUCCESS )
         continue;

      // Initialize the data structure
      // ------------------------------------------------------------
      data.m_stKey = stKey;
      data.m_stTitle.Empty();
      data.m_stConfigCLSID.Empty();
      data.m_stGuid.Empty();
      data.m_fSupportsEncryption = FALSE;
      data.m_stServerTitle.Empty();

      // Read in the values that we require
      // ------------------------------------------------------------
      regkeyProv.QueryValue(RAS_EAP_VALUENAME_FRIENDLY_NAME, data.m_stTitle);
      regkeyProv.QueryValue(
                              RAS_EAP_VALUENAME_CONFIG_CLSID,
                              data.m_stConfigCLSID
                            );
      regkeyProv.QueryValue(RAS_EAP_VALUENAME_ENCRYPTION, dwData);
      data.m_fSupportsEncryption = (dwData != 0);

      if (ERROR_SUCCESS != regkeyProv.QueryValue(
                                         RAS_EAP_VALUENAME_PER_POLICY_CONFIG,
                                         dwData
                                         ))
      {
         dwData = 0;
      }

      if ((dwData != 0) || data.m_stConfigCLSID.IsEmpty())
      {
         data.m_stServerTitle = data.m_stTitle;
      }
      else
      {
         AfxFormatString1(
            data.m_stServerTitle,
            IDS_NO_PER_POLICY_EAP,
            data.m_stTitle
            );
      }

      // Read in the standalone supported value.
      // ------------------------------------------------------------
      if (ERROR_SUCCESS != regkeyProv.QueryValue(
                                        RAS_EAP_VALUENAME_STANDALONE_SUPPORTED,
                                        dwData
                                        ))
      {
         dwData = 1; // the default
      }

      if (dwData || !bStandAlone)
      {
         DWORD role;
         dwErr = regkeyProv.QueryValue(
                               RAS_EAP_VALUENAME_ROLES_SUPPORTED,
                               role
                               );
         if ((dwErr != ERROR_SUCCESS) ||
             (((role & RAS_EAP_ROLE_AUTHENTICATOR) == 1) &&
              ((role & RAS_EAP_ROLE_EXCLUDE_IN_EAP) == 0)))
         {
            pProvList->Add(data);
         }
      }
   }

L_ERR:
   regkeyProviders.Detach();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\helper.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   helper.h
      This file defines the following macros helper classes and functions:

      Macros to check HRESULT
      CDlgHelper -- helper class to Enable/Check dialog Item,
      CManagedPage -- helper class for PropertyPage,
         It manages ReadOnly, SetModified, and ContextHelp
      CStrArray -- an array of pointer to CString
         It does NOT duplicate the string upon Add
         and It deletes the pointer during destruction
         It imports and exports SAFEARRAY

      CReadWriteLock -- class for share read or exclusive write lock

      CStrBox -- wrapper class for CListBox and CComboBox

      CIPAddress -- wrapper for IPAddress

      CFramedRoute -- Wrapper for FramedRoute
      CStrParse -- parses string for TimeOfDay

    FILE HISTORY:

*/
// helper functions for dialog and dialog items
#ifndef _DLGHELPER_
#define _DLGHELPER_

#include "iastrace.h"

#define  SAYOK { return S_OK;}
#define  NOIMP { return  E_NOTIMPL;}

// to reduce the step to set VARIANT
#define  V__BOOL(v, v1)\
   V_VT(v) = VT_BOOL,   V_BOOL(v) = (v1)

#define  V__I4(v, v1)\
   V_VT(v) = VT_I4,  V_I4(v) = (v1)

#define  V__I2(v, v1)\
   V_VT(v) = VT_I2,  V_I2(v) = (v1)

#define  V__UI1(v, v1)\
   V_VT(v) = VT_UI1, V_UI1(v) = (v1)

#define  V__BSTR(v, v1)\
   V_VT(v) = VT_BSTR,   V_BSTR(v) = (v1)

#define  V__ARRAY(v, v1)\
   V_VT(v) = VT_ARRAY,  V_ARRAY(v) = (v1)

#define REPORT_ERROR(hr) \
    IASTracePrintf("**** ERROR RETURN <%s @line %d> -> %08lx", \
                 __FILE__, __LINE__, hr)); \
    ReportError(hr, 0, 0);

#ifdef   _DEBUG
#define  CHECK_HR(hr)\
   {if(!CheckADsError(hr, FALSE, __FILE__, __LINE__)){goto L_ERR;}}
#else
#define  CHECK_HR(hr)\
   if FAILED(hr)  goto L_ERR
#endif

#ifdef   _DEBUG
#define  NOTINCACHE(hr)\
   (CheckADsError(hr, TRUE, __FILE__, __LINE__))
#else
#define  NOTINCACHE(hr)\
   (E_ADS_PROPERTY_NOT_FOUND == (hr))
#endif

BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file, int line);


#ifdef   _DEBUG
#define TRACEAfxMessageBox(id) {\
   IASTracePrintf("AfxMessageBox <%s @line %d> ID: %d", \
                 __FILE__, __LINE__, id); \
    AfxMessageBox(id);}\

#else
#define TRACEAfxMessageBox(id) AfxMessageBox(id)
#endif

// change string Name to CN=Name
void DecorateName(LPWSTR outString, LPCWSTR inString);

// find name from DN for example LDAP://CN=userA,CN=users...  returns userA
void FindNameByDN(LPWSTR outString, LPCWSTR inString);

class CDlgHelper
{
public:
   static void EnableDlgItem(CDialog* pDialog, int id, bool bEnable = true);
   static int  GetDlgItemCheck(CDialog* pDialog, int id);
   static void SetDlgItemCheck(CDialog* pDialog, int id, int nCheck);
};

// class CPageManager and CManagedPage together handle the situation when
// the property sheet need to do some processing when OnApply function is called
// on some of the pages
class CPageManager
{
public:
   CPageManager(){ m_bModified = FALSE; m_bReadOnly = FALSE;};
   BOOL  GetModified(){ return m_bModified;};
   void  SetModified(BOOL bModified){ m_bModified = bModified;};
   void  SetReadOnly(BOOL bReadOnly){ m_bReadOnly = bReadOnly;};
   BOOL  GetReadOnly(){ return m_bReadOnly;};
   virtual BOOL   OnApply()
   {
      if (!GetModified())  return FALSE;

      SetModified(FALSE);  // prevent from doing this more than once
      return TRUE;
   }; // to be implemented by the propertysheet
protected:
   BOOL  m_bModified;
   BOOL  m_bReadOnly;
};

class CManagedPage : public CPropertyPage // talk back to property sheet
{
   DECLARE_DYNCREATE(CManagedPage)
public:
   CManagedPage() : CPropertyPage(){
      m_bModified = FALSE;
      m_bNeedToSave = FALSE;
      m_pManager = NULL;
   };

   CManagedPage(UINT nIDTemplate) : CPropertyPage(nIDTemplate)
   {
      m_bModified = FALSE;
      m_bNeedToSave = FALSE;
      m_pManager = NULL;
   };

   void SetModified( BOOL bModified = TRUE )
   {
      ASSERT(m_pManager);
      if(!m_pManager->GetReadOnly())   // if NOT readonly
      {
         m_bModified = bModified;
         m_bNeedToSave= bModified;
         CPropertyPage::SetModified(bModified);

         // only set change
         if(bModified) m_pManager->SetModified(TRUE);
      }
   };

   BOOL GetModified() { return m_bModified;};

   BOOL OnApply()
   {
      m_bModified = FALSE;
      BOOL  b = TRUE;
      if(m_pManager->GetModified()) // prevent from entering more than once
         b= m_pManager->OnApply();
      return (b && CPropertyPage::OnApply());
   };

   // a page has three states: not dirty, dirty and need to save, and not dirty but need to save
   // m_bModified == dirty flag
   // m_bNeedToSave == need to save flag
   // When m_bNeedToSave && !m_bModified is detected upon on saved failure, the modified flag of the page is set
   BOOL OnSaved(BOOL bSaved)
   {
      if(bSaved)
      {
         m_bModified = FALSE;
         m_bNeedToSave = FALSE;
      }
      else if(m_bNeedToSave && !m_bModified)
         SetModified(TRUE);

      return TRUE;
   };

   void SetManager(CPageManager* pManager) { m_pManager = pManager;};
   CPageManager* GetManager() { return m_pManager;};

protected:

   // help info process
   BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   void OnContextMenu(CWnd* pWnd, ::CPoint point);

   void SetHelpTable(const DWORD* pTable) { m_pHelpTable = pTable;};
   int MyMessageBox(UINT ids, UINT nType = MB_OK);
   int MyMessageBox1(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL, UINT nType = MB_OK);


protected:
   CPageManager*  m_pManager;
   BOOL        m_bModified;
   BOOL        m_bNeedToSave;

   const DWORD*         m_pHelpTable;
};

#include <afxtempl.h>
class CStrArray :  public CArray< ::CString*, ::CString* >
{
public:
   CStrArray(SAFEARRAY* pSA = NULL);
   CStrArray(const CStrArray& sarray);
   int Find(const ::CString& Str) const;
   int DeleteAll();
   virtual ~CStrArray();
   operator SAFEARRAY*();
   CStrArray& operator = (const CStrArray& sarray);
   bool AppendSA(SAFEARRAY* pSA);
   int AddDuplicate(const ::CString& Str);
   void DeleteAt(int nIndex);
};

class CDWArray :  public CArray< DWORD, DWORD >
{
public:
   CDWArray(const CDWArray& dwarray);
   int   Find(const DWORD dw) const;
   int   DeleteAll(){ RemoveAll(); return 0;};
   virtual ~CDWArray(){RemoveAll();};
   CDWArray& operator = (const CDWArray& dwarray);
   operator SAFEARRAY*();
   bool AppendSA(SAFEARRAY* pSA);
   CDWArray(SAFEARRAY* pSA = NULL);
};

class CBYTEArray :  public CArray< BYTE, BYTE >
{
public:
   CBYTEArray(const CBYTEArray& bytearray);
   int   Find(const BYTE byte) const;
   int   DeleteAll(){ RemoveAll(); return 0;};
   virtual ~CBYTEArray(){RemoveAll();};
   CBYTEArray& operator = (const CBYTEArray& bytearray);
   operator SAFEARRAY*();
   bool AppendSA(SAFEARRAY* pSA);
   HRESULT AssignBlob(PBYTE pByte, DWORD size);
   HRESULT  GetBlob(PBYTE pByte, DWORD* pSize);

   CBYTEArray(SAFEARRAY* pSA = NULL);
};

// a lock to allow multiple read access exclusive or only one write access
class CReadWriteLock    // sharable read, exclusive write
{
public:
   CReadWriteLock() : m_nRead(0)
   {
#ifdef   _DEBUG
      d_bWrite = false;
#endif
   };
   void EnterRead()
   {
      IASTraceString("Entering Read Lock ...");
      m_csRead.Lock();
      if (!m_nRead++)
         m_csWrite.Lock();
      m_csRead.Unlock();
      IASTraceString("Entered Read Lock");
   };

   void LeaveRead()
   {
      IASTraceString("Leaving Read Lock ...");
      m_csRead.Lock();
      ASSERT(m_nRead > 0);
      if (!--m_nRead)
         m_csWrite.Unlock();
      m_csRead.Unlock();
      IASTraceString("Left Read Lock");
   };

   void EnterWrite()
   {
      IASTraceString("Entering Write Lock ...");
      m_csWrite.Lock();
      IASTraceString("Entered Write Lock");
#ifdef   _DEBUG
      d_bWrite = true;
#endif
   };
   void LeaveWrite()
   {
#ifdef   _DEBUG
      d_bWrite = false;
#endif
      m_csWrite.Unlock();
      IASTraceString("Left Write Lock");
   };

public:
#ifdef   _DEBUG
   bool  d_bWrite;
#endif

protected:
   CCriticalSection  m_csRead;
   CCriticalSection  m_csWrite;
   int               m_nRead;
};

// to manage a list box/ combo box
template <class CBox>
class CStrBox
{
public:
   CStrBox(CDialog* pDialog, int id, CStrArray& Strings)
      : m_Strings(Strings), m_id(id)
   {
      m_pDialog = pDialog;
      m_pBox = NULL;
   };

   int Fill()
   {
      m_pBox = (CBox*)m_pDialog->GetDlgItem(m_id);
      ASSERT(m_pBox);
      m_pBox->ResetContent();

      int count = (int)m_Strings.GetSize();
      int   index;
      for(int i = 0; i < count; i++)
      {
         index = m_pBox->AddString(*m_Strings[(INT_PTR)i]);
         m_pBox->SetItemDataPtr(index, m_Strings[(INT_PTR)i]);
      }
      return count;
   };

   int DeleteSelected()
   {
      int   index;
      ASSERT(m_pBox);
      index = m_pBox->GetCurSel();

      // if there is any selected
      if( index != LB_ERR )
      {
         CString* pStr;
         pStr = (CString*)m_pBox->GetItemDataPtr(index);
         // remove the entry from the box
         m_pBox->DeleteString(index);

         // find the string in the String array
         int count = static_cast<int>(m_Strings.GetSize());
         for(int i = 0; i < count; i++)
         {
            if (m_Strings[(INT_PTR)i] == pStr)
               break;
         }
         ASSERT(i < count);
         // remove the string from the string array
         m_Strings.RemoveAt(i);
         index = i;
         delete pStr;
      }
      return index;
   };

   int AddString(::CString* pStr)     // the pStr needs to dynamically allocated
   {
      int index;
      ASSERT(m_pBox && pStr);
      index = m_pBox->AddString(*pStr);
      m_pBox->SetItemDataPtr(index, pStr);
      return m_Strings.Add(pStr);
   };

   int Select(int arrayindex)    // the pStr needs to dynamically allocated
   {
      ASSERT(arrayindex < m_Strings.GetSize());
      return m_pBox->SelectString(0, *m_Strings[(INT_PTR)arrayindex]);
   };

   void Enable(BOOL b)     // the pStr needs to dynamically allocated
   {
      ASSERT(m_pBox);
      m_pBox->EnableWindow(b);
   };

   int GetSelected()    // it returns the index where the
   {
      int   index;
      ASSERT(m_pBox);
      index = m_pBox->GetCurSel();

      // if there is any selected
      if( index != LB_ERR )
      {
         ::CString* pStr;
         pStr = (::CString*)m_pBox->GetItemDataPtr(index);

         // find the string in the String array
         int count = (int)m_Strings.GetSize();
         for(int i = 0; i < count; i++)
         {
            if (m_Strings[(INT_PTR)i] == pStr)
               break;
         }
         ASSERT(i < count);
         index = i;
      }
      return index;
   };

   CBox*    m_pBox;
protected:
   int         m_id;
   CStrArray&  m_Strings;
   CDialog* m_pDialog;
};

// class to take care of ip address
class CIPAddress
{
public:
   CIPAddress(DWORD address = 0)
   {
      m_dwAddress = address;
   };

   operator DWORD() { return m_dwAddress;};
   operator ::CString()
   {
      ::CString  str;
      WORD  hi = HIWORD(m_dwAddress);
      WORD  lo = LOWORD(m_dwAddress);
      str.Format(_T("%-d.%-d.%-d.%d"), HIBYTE(hi), LOBYTE(hi), HIBYTE(lo), LOBYTE(lo));
      return str;
   };

   DWORD m_dwAddress;
};

// format of framedroute:  mask dest metric ; mask and dest in dot format
class CFramedRoute
{
public:
   void SetRoute(::CString* pRoute)
   {
      m_pStrRoute = pRoute;
      m_pStrRoute->TrimLeft();
      m_pStrRoute->TrimRight();
      m_iFirstSpace = m_pStrRoute->Find(_T(' '))   ;
      m_iLastSpace = m_pStrRoute->ReverseFind(_T(' '))   ;
   };

   ::CString& GetDest(::CString& dest) const
   {
      int      i = m_pStrRoute->Find(_T('/'));
      if(i == -1)
         i = m_iFirstSpace;

      dest = m_pStrRoute->Left(i);
      return dest;
   };

   ::CString& GetNextStop(::CString& nextStop) const
   {
      nextStop = m_pStrRoute->Mid(m_iFirstSpace + 1, m_iLastSpace - m_iFirstSpace -1 );
      return nextStop;
   };

   ::CString& GetPrefixLength(::CString& prefixLength) const
   {
      int      i = m_pStrRoute->Find(_T('/'));

      if( i != -1)
      {
         prefixLength = m_pStrRoute->Mid(i + 1, m_iFirstSpace - i - 1);
      }
      else
         prefixLength = _T("");

      return prefixLength;
   };

   ::CString& GetMask(::CString& mask) const
   {
      int      i = m_pStrRoute->Find(_T('/'));
      DWORD dwMask = 0;
      DWORD dwBit = 0x80000000;
      DWORD dwPrefixLen;

      if( i != -1)
      {
         mask = m_pStrRoute->Mid(i + 1, m_iFirstSpace - i - 1);
         dwPrefixLen = _ttol((LPCTSTR)mask);

         while(dwPrefixLen--)
         {
            dwMask |= dwBit;
            dwBit >>= 1;
         }
      }
      else
         dwMask = 0;

      WORD  hi1, lo1;
      hi1 = HIWORD(dwMask);   lo1 = LOWORD(dwMask);
      mask.Format(_T("%-d.%-d.%d.%d"),
            HIBYTE(hi1), LOBYTE(hi1), HIBYTE(lo1), LOBYTE(lo1));

      return mask;
   };

   ::CString& GetMetric(::CString& metric) const
   {
      metric = m_pStrRoute->Mid(m_iLastSpace + 1);
      return metric;
   };

protected:

   // WARNING: the string is not copied, so user need to make sure the origin is valid
   ::CString* m_pStrRoute;
   int         m_iFirstSpace;
   int         m_iLastSpace;
};

class CStrParser
{
public:
   CStrParser(LPCTSTR pStr = NULL) : m_pStr(pStr) { }

   // get the current string position
   LPCTSTR  GetStr() const { return m_pStr;};

   void  SetStr(LPCTSTR pStr) { m_pStr = pStr;};

   // find a unsigned interger and return it, -1 == not found
   int GetUINT()
   {
      UINT  ret = 0;
      while((*m_pStr < _T('0') || *m_pStr > _T('9')) && *m_pStr != _T('\0'))
         m_pStr++;

      if(*m_pStr == _T('\0')) return -1;

      while(*m_pStr >= _T('0') && *m_pStr <= _T('9'))
      {
         ret = ret * 10 + *m_pStr - _T('0');
         m_pStr++;
      }

      return ret;
   };

   // find c and skip it
   int   GotoAfter(TCHAR c)
   {
      int   ret = 0;
      // go until find c or end of string
      while(*m_pStr != c && *m_pStr != _T('\0'))
         m_pStr++, ret++;

      // if found
      if(*m_pStr == c)
         m_pStr++, ret++;
      else
         ret = -1;
      return ret;
   };

   // skip blank characters space tab
   void  SkipBlank()
   {
      while((*m_pStr == _T(' ') || *m_pStr == _T('\t')) && *m_pStr != _T('\0'))
         m_pStr++;
   };

   // check to see if the first character is '0'-'6' for Monday(0) to Sunday(6)
   int DayOfWeek() {
      SkipBlank();
      if(*m_pStr >= _T('0') && *m_pStr <= _T('6'))
         return (*m_pStr++ - _T('0'));
      else
         return -1;  // not day of week
   };

protected:
   LPCTSTR  m_pStr;
private:
   ::CString  _strTemp;
};

void ReportError(HRESULT hr, int nStr, HWND hWnd);

// number of characters
void AFXAPI DDV_MinChars(CDataExchange* pDX, ::CString const& value, int nChars);

/*!--------------------------------------------------------------------------
   IsStandaloneServer
      Returns S_OK if the machine name passed in is a standalone server,
      or if pszMachineName is S_FALSE.

      Returns S_FALSE otherwise.
   Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT  HrIsStandaloneServer(LPCTSTR pszMachineName);


HRESULT  HrIsNTServer(LPCWSTR pMachineName);


class CBSTR
{
public:
   CBSTR() : m_bstr(NULL) {};
   CBSTR(LPCSTR cstr) : m_bstr(NULL)
   {
      USES_CONVERSION;
      m_bstr = A2BSTR(cstr);
   };
   CBSTR(LPCWSTR wstr) : m_bstr(NULL)
   {
      USES_CONVERSION;
      m_bstr = W2BSTR(wstr);
   };

   BSTR AssignBlob(const char* pByte, UINT size)
   {
      SysFreeString(m_bstr);
      m_bstr = SysAllocStringByteLen(pByte, size);

      return m_bstr;
   };

   BSTR AssignBSTR(const BSTR bstr)
   {
      return AssignBlob((const char *)bstr, SysStringByteLen(bstr));
   };

   UINT  ByteLen()
   {
      UINT  n = 0;
      if(m_bstr)
         n = SysStringByteLen(m_bstr);
      return n;
   };

   operator BSTR() { return m_bstr;};

   void Clean()
   {
      SysFreeString(m_bstr);
      m_bstr = NULL;
   };

   ~CBSTR()
   {
      Clean();
   };

   BSTR  m_bstr;
};

template<class T> class CNetDataPtr
{
public:
   CNetDataPtr():m_pData(NULL){};

   ~CNetDataPtr()
   {
      NetApiBufferFree(m_pData);
   };

   T** operator&()
   {
      return &m_pData;
   };

   operator T*()
   {
      return m_pData;
   };

   T* operator ->()
   {
      return m_pData;
   };

   T* m_pData;
};

/*!--------------------------------------------------------------------------
   EnableChildControls
      Use this function to enable/disable/hide/show all child controls
      on a page (actually it will work with any child windows, the
      parent does not have to be a property page).
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags);
#define PROPPAGE_CHILD_SHOW      0x00000001
#define PROPPAGE_CHILD_HIDE      0x00000002
#define PROPPAGE_CHILD_ENABLE 0x00000004
#define PROPPAGE_CHILD_DISABLE   0x00000008


/*---------------------------------------------------------------------------
   Struct:  AuthProviderData

   This structure is used to hold information for Authentication AND
   Accounting providers.
 ---------------------------------------------------------------------------*/
struct AuthProviderData
{
   // The following fields will hold data for ALL auth/acct/EAP providers
   ::CString  m_stTitle;
   ::CString  m_stConfigCLSID;  // CLSID for config object
   ::CString  m_stProviderTypeGUID;   // GUID for the provider type

   // These fields are used by auth/acct providers.
   ::CString  m_stGuid;         // the identifying guid

   // This flag is used for EAP providers
   ::CString  m_stKey;       // name of registry key (for this provider)
   BOOL  m_fSupportsEncryption;  // used by EAP provider data
   ::CString m_stServerTitle; // Title displayed on server.
};

typedef CArray<AuthProviderData, AuthProviderData&> AuthProviderArray;

#ifndef IASAPI
#define IASAPI __declspec(dllimport)
#endif


HRESULT IASAPI GetEapProviders(
                                 LPCWSTR machineName,
                                 AuthProviderArray *pProvList
                              );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iastrace.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the API into the IAS trace facility.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <rtutils.h>

//////////
// Flags passed for all trace calls.
//////////
#define IAS_TRACE_FLAGS \
   (0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC | TRACE_USE_DATE)

//////////
// Trace ID for this module.
//////////
DWORD dwTraceID = INVALID_TRACEID;

//////////
// Initialization ref. count.
//////////
LONG lRefCount = 0;

//////////
// Non-zero if the registration code is locked.
//////////
LONG lLocked = 0;

//////////
// Macros to lock/unlock the registration code.
//////////
#define LOCK_TRACE() \
   while (InterlockedExchange(&lLocked, 1)) Sleep(5)

#define UNLOCK_TRACE() \
   InterlockedExchange(&lLocked, 0)

VOID
WINAPI
IASTraceInitialize( VOID )
{
   LONG state;
   DWORD status;
   MEMORY_BASIC_INFORMATION mbi;
   WCHAR filename[MAX_PATH + 1], *basename, *suffix;

   LOCK_TRACE();

   if (++lRefCount == 1)
   {
      // Find the base address of this module.
      if (VirtualQuery(IASTraceInitialize, &mbi, sizeof(mbi)))
      {
         // Get the module filename.
         status = GetModuleFileNameW(
                      (HINSTANCE)mbi.AllocationBase,
                      filename,
                      MAX_PATH
                      );
         if (status != 0)
         {
            // Strip everything before the last backslash.
            basename = wcsrchr(filename, L'\\');
            if (basename == NULL)
            {
               basename = filename;
            }
            else
            {
               ++basename;
            }

            // Strip everything after the last dot.
            suffix = wcsrchr(basename, L'.');
            if (suffix)
            {
               *suffix = L'\0';
            }

            // Convert to uppercase.
            _wcsupr(basename);

            // Register the module.
            dwTraceID = TraceRegisterExW(basename, 0);
         }
      }
   }

   UNLOCK_TRACE();
}


VOID
WINAPI
IASTraceUninitialize( VOID )
{
   LOCK_TRACE();

   if (--lRefCount == 0)
   {
      TraceDeregisterW(dwTraceID);
      dwTraceID = INVALID_TRACEID;
   }

   UNLOCK_TRACE();
}


//////////
// Formats an error message from the system message table.
//////////
DWORD
WINAPI
IASFormatSysErr(
    DWORD dwError,
    PSTR lpBuffer,
    DWORD nSize
    )
{
   DWORD nChar;

   // Attempt to format the message using the system message table.
   nChar = FormatMessageA(
               FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               dwError,
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               lpBuffer,
               nSize,
               NULL
               );

   if (nChar > 0)
   {
      // Format succeeded, so strip any trailing newline and exit.
      if (lpBuffer[nChar - 1] == '\n')
      {
         --nChar;
         lpBuffer[nChar] = '\0';

         if (lpBuffer[nChar - 1] == '\r')
         {
            --nChar;
            lpBuffer[nChar] = '\0';
         }
      }

      goto exit;
   }

   // Only error condition we can handle is when the message is not found.
   if (GetLastError() != ERROR_MR_MID_NOT_FOUND)
   {
      goto exit;
   }

   // Do we have enough space for the fallback error message ?
   if (nSize < 25)
   {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);

      goto exit;
   }

   // No entry in the message table, so just format the raw error code.
   nChar = wsprintfA(lpBuffer, "Unknown error 0x%0lX", dwError);

exit:
   return nChar;
}

VOID
WINAPIV
IASTracePrintf(
    IN PCSTR szFormat,
    ...
    )
{
   va_list marker;
   va_start(marker, szFormat);
   TraceVprintfExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       szFormat,
       marker
       );
   va_end(marker);
}

VOID
WINAPI
IASTraceString(
    IN PCSTR szString
    )
{
   TracePutsExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       szString
       );
}

VOID
WINAPI
IASTraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    )
{
   TraceDumpExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       (LPBYTE)lpbBytes,
       dwByteCount,
       1,
       FALSE,
       NULL
       );
}

VOID
WINAPI
IASTraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    )
{
   CHAR szMessage[256];
   DWORD nChar;

   nChar = IASFormatSysErr(
               dwError,
               szMessage,
               sizeof(szMessage)
               );

   szMessage[nChar] = '\0';

   IASTracePrintf("%s failed: %s", szFunction, szMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iashelper.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   IASHelper.cpp
      Implementation of the following helper classes:
      
      

      And global functions:
      GetSdoInterfaceProperty - Get an interface property from a SDO 
                          through its ISdo interface
         
    FILE HISTORY:
      
      2/18/98        byao     Created
        
*/
#include <limits.h>

#include "stdafx.h"
#include "helper.h"
#include "resource.h"
#include "IASHelper.h"

//+---------------------------------------------------------------------------
//
// Function:  IASGetSdoInterfaceProperty
//
// Synopsis:  Get an interface property from a SDO through its ISdo interface
//
// Arguments: ISdo *pISdo - Pointer to ISdo
//            LONG lPropId - property id
//            REFIID riid - ref iid
//            void ** ppvObject - pointer to the requested interface property
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao   2/12/98 11:12:55 PM
//
//+---------------------------------------------------------------------------
HRESULT IASGetSdoInterfaceProperty(ISdo *pISdo, 
                        LONG lPropID, 
                        REFIID riid, 
                        void ** ppvInterface)
{
   VARIANT var;
   HRESULT hr;

   VariantInit(&var);

   VariantClear(&var);
   V_VT(&var) = VT_DISPATCH;
   V_DISPATCH(&var) = NULL;
   hr = pISdo->GetProperty(lPropID, &var);

   ReportError(hr, IDS_IAS_ERR_SDOERROR_GETPROPERTY, NULL);
   _ASSERTE( V_VT(&var) == VT_DISPATCH );

    // query the dispatch pointer for interface
   hr = V_DISPATCH(&var) -> QueryInterface( riid, ppvInterface);
   ReportError(hr, IDS_IAS_ERR_SDOERROR_QUERYINTERFACE, NULL);
   
   VariantClear(&var);

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
int ShowErrorDialog( 
                 UINT uErrorID = 0
               , BSTR bstrSupplementalErrorString = NULL
               , HRESULT hr = S_OK
               , UINT uTitleID = 0
               , HWND hWnd = NULL
               , UINT uType = MB_OK | MB_ICONEXCLAMATION
            );


Puts up an error dialog with varying degrees of detail

Parameters:

   All parameters are optional -- in the worst case, you can simply call 
      
        ShowErrorDialog();

   to put up a very generic error message.


uErrorID

   The resource ID of the string to be used for the error message.
   Passing in 0 gives causes the default error message to be displayed. 

bstrSupplementalErrorString

   Pass in a string to print as the error message.  Useful if you are
   receiving an error string from some other component you communicate with.

hr

   If there is an HRESULT involved in the error, pass it in here so that 
   a suitable error message based on the HRESULT can be put up.
   Pass in S_OK if the HRESULT doesn't matter to the error.


uTitleID

   The resource ID of the string to be used for the error dialog title.
   Passing in 0 gives causes the default error dialog title to be displayed. 

pConsole

   If you are running within the main MMC context, pass in a valid IConsole pointer
   and ShowErrorDialog will use MMC's IConsole::MessageBox rather than the
   standard system MessageBox.

hWnd
   
   Whatever you pass in here will be passed in as the HWND parameter 
   to the MessageBox call.
   This is not used if you pass in an IConsole pointer.

uType

   Whatever you pass in here will be passed in as the HWND parameter 
   to the MessageBox call.


Return:

   The standard int returned from MedsageBox.

   

--*/
//////////////////////////////////////////////////////////////////////////////
#define IAS_MAX_STRING MAX_PATH

int ShowErrorDialog( 
                 HWND hWnd
               , UINT uErrorID
               , BSTR bstrSupplementalErrorString
               , HRESULT hr
               , UINT uTitleID
               , UINT uType
               )
{
   int iReturnValue;
   TCHAR szError[IAS_MAX_STRING];
   TCHAR szTitle[IAS_MAX_STRING];
   int iLoadStringResult;


   HINSTANCE hInstance = _Module.GetResourceInstance();


   if( 0 == uTitleID )
   {
      uTitleID = IDS_IAS_ERR_ADVANCED;
   
   }

   iLoadStringResult = LoadString(  hInstance, uTitleID, szTitle, IAS_MAX_STRING );
   _ASSERT( iLoadStringResult > 0 );


   if( 1 == uErrorID )
   {
      // Special case.  We have no text to load from the resources.
   }
   else
   {

      if( 0 == uErrorID )
      {
         uErrorID = IDS_IAS_ERR_ADVANCED;
      }

      iLoadStringResult = LoadString(  hInstance, uErrorID, szError, IAS_MAX_STRING );
      _ASSERT( iLoadStringResult > 0 );

      if( NULL != bstrSupplementalErrorString )
      {
         // Add some spacing.
         _tcscat( szError, _T(" ") );
      }

   }
      

   if( NULL != bstrSupplementalErrorString )
   {

      // We were passed a string with supplemental error info.
      _tcscat( szError, bstrSupplementalErrorString );

   }


   if( FAILED( hr ) )
   {
      // The HRESULT contains some information about the kind of failure.

      // We may want to change this later to provide more information
      // information based on the error that was returned.

      // We could have a map which defines relationships between error
      // ID's and the HRESULTS.  That way we could provide the appropriate
      // error message for each HRESULT based on the context of which ID
      // was passed in.

      // For now, just print the error ID.

      TCHAR szErrorNumber[IAS_MAX_STRING];

      _stprintf( szErrorNumber, _T(" 0x%x"), hr );

      // Some spacing.
      _tcscat( szError, _T(" ") );

      _tcscat( szError, szErrorNumber );

   }

   if (!hWnd)
   {
      hWnd = GetDesktopWindow();
   }

   iReturnValue = ::MessageBox( hWnd, szError, szTitle, uType );

   return iReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iastrace.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares he API into the IAS trace facility.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASTRACE_H
#define IASTRACE_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

VOID
WINAPI
IASTraceInitialize( VOID );

VOID
WINAPI
IASTraceUninitialize( VOID );

DWORD
WINAPI
IASFormatSysErr(
    IN DWORD dwError,
    IN PSTR lpBuffer,
    IN DWORD nSize
    );

VOID
WINAPIV
IASTracePrintf(
    IN PCSTR szFormat,
    ...
    );

VOID
WINAPI
IASTraceString(
    IN PCSTR szString
    );

VOID
WINAPI
IASTraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    );

VOID
WINAPI
IASTraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    );

//////////
// This can only be called from inside a C++ catch block. If you call it
// anywhere else you will probably crash the process.
//////////
VOID
WINAPI
IASTraceExcept( VOID );

#ifdef __cplusplus
}

class IASTraceInitializer
{
public:
   IASTraceInitializer() throw ()
   {
      IASTraceInitialize();
   }

   ~IASTraceInitializer() throw ()
   {
      IASTraceUninitialize();
   }

private:
   // Not implemented.
   IASTraceInitializer(const IASTraceInitializer&);
   IASTraceInitializer& operator=(const IASTraceInitializer&);
};


#endif
#endif  // IASTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iashelper.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	helper.h
		This file defines the following macros helper classes and functions:

		IASGetSdoInterfaceProperty()

    FILE HISTORY:

		2/18/98			byao		Created
        
*/

#ifndef _IASHELPER_
#define _IASHELPER_


// SDO helper functions
extern HRESULT IASGetSdoInterfaceProperty(ISdo *pISdo, 
								LONG lPropID, 
								REFIID riid, 
								void ** ppvInterface);


int		ShowErrorDialog( 
					  HWND hWnd = NULL
					, UINT uErrorID = 0
					, BSTR bstrSupplementalErrorString = NULL
					, HRESULT hr = S_OK
					, UINT uTitleID = 0
					, UINT uType = MB_OK | MB_ICONEXCLAMATION
				);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iasprofa.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       iasprofa.cpp
//
//--------------------------------------------------------------------------

// IASProfA.cpp: implementation of the CIASProfileAttribute class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "helper.h"
#include "IASHelper.h"
#include "iasprofa.h"
#include "napmmc.h"
#include "napmmc_i.c"

//////////////////////////////////////////////////////////////////////
// Forward declarations of some utilities used here
//////////////////////////////////////////////////////////////////////

static HRESULT getCLSIDForEditorToUse(      /* in */  IIASAttributeInfo *pIASAttributeInfo
                           , /* in */  VARIANT * pvarValue
                           , /* out */ CLSID &clsid
                        );

static HRESULT SetUpAttributeEditor(     /* in */  IIASAttributeInfo *pIASAttributeInfo
                        , /* in */  VARIANT * pvarValue
                        , /* out */ IIASAttributeEditor ** ppIASAttributeEditor 
                        );

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::CIASProfileAttribute

   Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASProfileAttribute::CIASProfileAttribute(
                       IIASAttributeInfo * pIASAttributeInfo
                     , VARIANT &          varValue
                  )
{
   // Check for preconditions:
   _ASSERTE( pIASAttributeInfo );

   HRESULT hr;

   // The smartpointer calls AddRef on this interface.
   m_spIASAttributeInfo = pIASAttributeInfo;

   // Make a copy of the passed variant.
   hr = VariantCopy( &m_varValue, &varValue );
   if( FAILED( hr ) ) throw hr;

   // ISSUE: Make sure that if anything here fails, m_spIASAttributeInfo gets release.
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::~CIASProfileAttribute

   Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASProfileAttribute::~CIASProfileAttribute()
{
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::Edit

   Call this to ask a profile attribute to edit itself.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASProfileAttribute::Edit()
{
   // Check for preconditions:
   _ASSERTE( m_spIASAttributeInfo );

   CLSID clsidEditorToUse;
   HRESULT hr = S_OK;

   CComPtr<IIASAttributeEditor> spIASAttributeEditor;

   // Get the editor to use.
   hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &m_varValue, &spIASAttributeEditor );
   if( FAILED( hr ) ) return hr;

   // Edit it!
   CComBSTR bstrReserved;
   hr = spIASAttributeEditor->Edit( m_spIASAttributeInfo.p, &m_varValue, &bstrReserved );
   if( FAILED( hr ) ) return hr;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::getAttributeName

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASProfileAttribute::get_AttributeName( BSTR * pbstrVal )
{
   // Check for preconditions:
   _ASSERTE( m_spIASAttributeInfo );

   HRESULT hr = S_OK;
   
   hr = m_spIASAttributeInfo->get_AttributeName( pbstrVal );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::GetDisplayInfo

   Rather than asking the AttributeInfo directly for information
   about the vendor name, this method will use an AttributeEditor
   to ask for this information.  
   
   This is the most generic way of asking for this info as
   for some attributes, e.g. RADIUS Vendor Specific, Vendor Name
   is not stored in the AttributeInfo but is encapsulated in
   the value of the attribute itself.

   So we don't use our own knowledge of the attribute, rather we
   create an editor and ask the editor to give back this 
   information for us.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASProfileAttribute::GetDisplayInfo( BSTR * pbstrVendor, BSTR * pbstrDisplayValue )
{
   // Check for preconditions:
   _ASSERTE( m_spIASAttributeInfo );
   
   HRESULT hr = S_OK;

   CComBSTR bstrVendor, bstrDisplayValue, bstrReserved;

   try
   {
      CComPtr<IIASAttributeEditor> spIASAttributeEditor;

      // Get the editor to use.
      hr = SetUpAttributeEditor( m_spIASAttributeInfo.p, &m_varValue, &spIASAttributeEditor );
      if( FAILED( hr ) ) throw hr;

      hr = spIASAttributeEditor->GetDisplayInfo( m_spIASAttributeInfo.p, &m_varValue, &bstrVendor, &bstrDisplayValue, &bstrReserved );
      if( FAILED( hr ) ) throw hr;
   }
   catch(...)
   {
      // If anything above fails, just fall through -- we will return a pointer to an empty bstr.
      hr = E_FAIL;
   }

   *pbstrVendor = bstrVendor.Copy();
   *pbstrDisplayValue = bstrDisplayValue.Copy();
   
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::get_VarValue

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASProfileAttribute::get_VarValue( VARIANT * pvarVal )
{
   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;
   hr = VariantCopy( pvarVal, &m_varValue );
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CIASProfileAttribute::get_AttributeID

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASProfileAttribute::get_AttributeID( ATTRIBUTEID * pID )
{
   // Check for preconditions:
   _ASSERTE( m_spIASAttributeInfo );

   HRESULT hr = S_OK;
   hr = m_spIASAttributeInfo->get_AttributeID( pID );
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

::getCLSIDForEditorToUse

   The ShemaAttribute for a node stores a ProgID which indicates which 
   editor to use to manipulate an attribute.

   For non-multivalued attributes, we query the schema attribute to find
   out the ProgID for its editor.

   For multivalued attributes, we always create the multivalued editor.  
   When it is used, the multivalued editor is passed the schema attribute which it will
   then use to query for the appropriate editor to pop up for editing 
   each indivdual elements

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT getCLSIDForEditorToUse(       /* in */  IIASAttributeInfo *pIASAttributeInfo
                           , /* in */  VARIANT * pvarValue
                           , /* out */ CLSID &clsid
                        )
{
   // Check for preconditions:
   _ASSERTE( pIASAttributeInfo );

   HRESULT hr = S_OK;

   // Get attribute restrictions to see if multivalued.
   long lRestriction;
   hr = pIASAttributeInfo->get_AttributeRestriction( &lRestriction );

   if( lRestriction & MULTIVALUED )
   {
      _ASSERTE( V_VT(pvarValue) == (VT_ARRAY | VT_VARIANT) || V_VT(pvarValue) == VT_EMPTY );
      
      // Create the multi-attribute editor.
      // It will figure out the appropriate editor to use to
      // edit individual attribute values.
      clsid = CLSID_IASMultivaluedAttributeEditor;
   }
   else
   {
      // Query the schema attribute to see which attribute editor to use.
      
      CComBSTR bstrProgID;

      hr = pIASAttributeInfo->get_EditorProgID( &bstrProgID );
      if( FAILED( hr ) )
      {
         // We could try putting up a default (e.g. hex) editor, but for now:
         return hr;
      }

      hr = CLSIDFromProgID( bstrProgID, &clsid );
      if( FAILED( hr ) )
      {
         // We could try putting up a default (e.g. hex) editor, but for now:
         return hr;
      }
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

::SetUpAttributeEditor

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT SetUpAttributeEditor(   /* in */  IIASAttributeInfo *pIASAttributeInfo
                        , /* in */  VARIANT * pvarValue
                        , /* out */ IIASAttributeEditor ** ppIASAttributeEditor 
                        )
{
   // Check for preconditions:
   _ASSERTE( pIASAttributeInfo );
   _ASSERTE( ppIASAttributeEditor );

   // Initialize the interface pointer to NULL so we know whether we need to release it if there is an error.
   *ppIASAttributeEditor = NULL;

   // Query the schema attribute to see which attribute editor to use.
   CLSID clsidEditorToUse;
   CComBSTR bstrProgID;
   HRESULT hr;

   try
   {
      hr = getCLSIDForEditorToUse( pIASAttributeInfo, pvarValue, clsidEditorToUse );
      if( FAILED( hr ) )
      {
         // We could try putting up a default (e.g. hex) editor, but for now:
         return hr;
      }

      hr = CoCreateInstance( clsidEditorToUse , NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeEditor, (LPVOID *) ppIASAttributeEditor );
      if( FAILED( hr ) )
      {
         return hr;
      }
      if( ! *ppIASAttributeEditor )
      {
         return E_FAIL;
      }
   }
   catch(...)
   {
         // No smart pointers here -- need to make sure we release ourselves.
         if( *ppIASAttributeEditor )
         {
            (*ppIASAttributeEditor)->Release();
            *ppIASAttributeEditor = NULL;
         }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\listctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    lcx.h
//
// History:
//  07/13/96    Abolade Gbadegesin      Created, based on C code by Steve Cobb
//
// Contains declarations for an enhanced list-control.
//============================================================================

#ifndef _LISTCTRL_H_
#define _LISTCTRL_H_


//
// Notification sent by CListCtrlEx when an item's checked state changes.
//

#define LVXN_SETCHECK   (LVN_LAST + 1)


//----------------------------------------------------------------------------
// Structs:     SLcxRow
//              SLcxColumn
//
// Describes rows and columns in customizable list-controls.
//----------------------------------------------------------------------------

struct SLcxRow {

    UINT        uiRowId;
    UINT        idsTitle;
    BOOL        bEnabled;

};

struct SLcxColumn {

    INT         iSubItem;
    UINT        idsTitle;
    INT         cx;
    BOOL        bEnabled;
    INT         iIndex;

};



//----------------------------------------------------------------------------
// Class:       CListCtrlEx
//
// Controls a list-control which has extended capabilities,
// including the ability to show checkboxes next to its items,
// and the ability to maintain row-information in the registry.
//----------------------------------------------------------------------------

class CListCtrlEx : public CListCtrl
{

	DECLARE_DYNAMIC(CListCtrlEx)

public:

	CListCtrlEx()
			: m_pimlChecks(NULL), m_pimlOldState(NULL)
			{ }

	virtual ~CListCtrlEx( );

	enum {
		LCXI_UNCHECKED  = 1,
		LCXI_CHECKED    = 2
	};

	INT	GetColumnCount( );

	BOOL SetColumnText(INT iCol, LPCTSTR pszText, INT fmt = LVCFMT_LEFT );

	BOOL SetColumnText(INT iCol, UINT nID, INT fmt = LVCFMT_LEFT)
	{
		CString sCol;
		sCol.LoadString(nID);
		return SetColumnText(iCol, sCol, fmt);
	}


	//--------------------------------------------------------------------
	// Functions:   InstallChecks
	//              UninstallChecks
	//              GetCheck
	//              SetCheck
	//
	// Checkbox-handling functions.
	//--------------------------------------------------------------------
	
	BOOL InstallChecks( );
    VOID UninstallChecks( );
	BOOL GetCheck(INT iItem );
	VOID SetCheck(  INT iItem, BOOL fCheck );

protected:
	CImageList*     m_pimlChecks;
	CImageList*     m_pimlOldState;
	
	//{{AFX_MSG(CListCtrlEx)
	afx_msg VOID    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnLButtonDown(UINT nFlags, CPoint pt);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


//----------------------------------------------------------------------------
// Function:    AdjustColumnWidth
//
// Called to adjust the width of column 'iCol' so that the string 'pszContent'
// can be displayed in the column without truncation.
//
// If 'NULL' is specified for 'pszContent', the function adjusts the column
// so that the first string in the column is displayed without truncation.
//
// Returns the new width of the column.
//----------------------------------------------------------------------------

INT
AdjustColumnWidth(
    IN      CListCtrl&      listCtrl,
    IN      INT             iCol,
    IN      LPCTSTR         pszContent
    );

INT
AdjustColumnWidth(
    IN  CListCtrl&      listCtrl,
    IN  INT             iCol,
    IN  UINT            idsContent
    );

#endif // _LISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgauthen.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    pgauthen.h
//
// SYNOPSIS
//
//       Definition of CPgAuthentication -- property page to edit
//       profile attributes related to Authenticaion
//
//////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_PGAUTHEN_H__8C28D93F_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PGAUTHEN_H__8C28D93F_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rasdial.h"
#include "eapconfig.h"
// #include "eapnegotiate.h"

/////////////////////////////////////////////////////////////////////////////
// CPgAuthenticationMerge dialog
class CPgAuthenticationMerge : public CManagedPage
{
// Construction
public:
   CPgAuthenticationMerge(CRASProfileMerge& profile);
   ~CPgAuthenticationMerge();
   
// Dialog Data
   //{{AFX_DATA(CPgAuthenticationMerge)
   enum { IDD = IDD_AUTHENTICATION_MERGE };
   BOOL  m_bMD5Chap;
   BOOL  m_bMSChap;
   BOOL  m_bPAP;
   BOOL  m_bMSCHAP2;
   BOOL  m_bUNAUTH;
   BOOL  m_bMSChapPass;
   BOOL  m_bMSChap2Pass;
   //}}AFX_DATA

   BOOL  m_bEAP;

   // original values before edit
   BOOL  m_bOrgEAP;
   BOOL  m_bOrgMD5Chap;
   BOOL  m_bOrgMSChap;
   BOOL  m_bOrgPAP;
   BOOL  m_bOrgMSCHAP2;
   BOOL  m_bOrgUNAUTH;
   BOOL  m_bOrgChapPass;
   BOOL  m_bOrgChap2Pass;
   
   BOOL  m_bAppliedEver;

// Overrides
   // ClassWizard generate virtual function overrides
   //{{AFX_VIRTUAL(CPgAuthenticationMerge)
   public:
   virtual BOOL OnApply();
   virtual void OnOK();
   virtual BOOL OnKillActive();
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL
// Implementation
protected:
   BOOL  TransferDataToProfile();
   
   // Generated message map functions
   //{{AFX_MSG(CPgAuthenticationMerge)
   virtual BOOL OnInitDialog();
   afx_msg void OnCheckmd5chap();
   afx_msg void OnCheckmschap();
   afx_msg void OnCheckpap();
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnAuthConfigEapMethods();
   afx_msg void OnCheckmschap2();
   afx_msg void OnChecknoauthen();
   afx_msg void OnCheckmschapPass();
   afx_msg void OnCheckmschap2Pass();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CRASProfileMerge& m_Profile;
   EapConfig m_eapConfig;
   bool m_fromProfile;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGAUTHEN_H__8C28D93F_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgauthen2k.h ===
//////////////////////////////////////////////////////////////////////////////
// 
//    Copyright(c) Microsoft Corporation
// 
//    pgauthen2k.h
//       Definition of CPgAuthentication2kMerge  -- property page to edit
//       profile attributes related to Authenticaion
// 
//////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_PGAUTHEN2K_H)
#define AFX_PGAUTHEN2K_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rasdial.h"

/////////////////////////////////////////////////////////////////////////////
// CPgAuthentication2kMerge dialog
class CPgAuthentication2kMerge : public CManagedPage
{
// Construction
public:
   CPgAuthentication2kMerge(CRASProfileMerge& profile);
   ~CPgAuthentication2kMerge();

// Dialog Data
   //{{AFX_DATA(CPgAuthentication2kMerge)
   enum { IDD = IDD_AUTHENTICATION2K_MERGE };
   BOOL  m_bEAP;
   BOOL  m_bMD5Chap;
   BOOL  m_bMSChap;
   BOOL  m_bPAP;
   CString  m_strEapType;
   BOOL  m_bMSCHAP2;
   BOOL  m_bUNAUTH;
   //}}AFX_DATA

   // orginal value before edit
   BOOL  m_bOrgEAP;
   BOOL  m_bOrgMD5Chap;
   BOOL  m_bOrgMSChap;
   BOOL  m_bOrgPAP;
   BOOL  m_bOrgMSCHAP2;
   BOOL  m_bOrgUNAUTH;
   
   BOOL  m_bAppliedEver;

// Overrides
   // ClassWizard generate virtual function overrides
   //{{AFX_VIRTUAL(CPgAuthentication2kMerge)
   public:
   virtual BOOL OnApply();
   virtual void OnOK();
   virtual BOOL OnKillActive();
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:
   BOOL  TransferDataToProfile();
   
   // Generated message map functions
   //{{AFX_MSG(CPgAuthentication2kMerge)
   virtual BOOL OnInitDialog();
   afx_msg void OnCheckeap();
   afx_msg void OnCheckmd5chap();
   afx_msg void OnCheckmschap();
   afx_msg void OnCheckpap();
   afx_msg void OnSelchangeComboeaptype();
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnAuthConfigEap();
   afx_msg void OnCheckmschap2();
   afx_msg void OnChecknoauthen();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   CRASProfileMerge& m_Profile;
   bool        m_bInited;

   CStrArray   m_EapTypes;
   CDWArray    m_EapIds;
   CDWArray    m_EapTypeKeys;
   AuthProviderArray m_EapInfoArray;
   
   CStrBox<CComboBox>   *m_pBox;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // AFX_PGAUTHEN2K_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\iasprofa.h ===
/****************************************************************************************
 * NAME: IASProfA.h
 *
 * CLASS:   CIASProfileAttribute
 *
 * OVERVIEW
 *
 *    CIASProfileAttribute class is the encapsulation for attribute node in 
 *    IAS profile. 
 *    
 *    Difference between CIASAttributeNode and CIASProfileAttribute
 *
 *    CIASAttributeNode: a static entity. With Only store general information
 *    CIASProfileAttribute: a dynamic entity. Contains dynamic information such as value 
 *
 * Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 * History: 
 *          2/21/98     Created by  Byao  (using ATL wizard)
 *          06/26/98 Reworked by mmaguire for multivalued editor and to use plugable editors.
 *
 *****************************************************************************************/

#ifndef _IASPROFA_INCLUDED_
#define _IASPROFA_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "napmmc.h"

class CIASProfileAttribute
{
public:

   CIASProfileAttribute(   
               IIASAttributeInfo *pIASAttributeInfo,  // We AddRef on the interface passed.
               VARIANT&       varValue    // We make a copy of variant passed.
            );

   virtual ~CIASProfileAttribute();

   STDMETHOD(Edit)();
   STDMETHOD(get_AttributeName)( BSTR * pbstrVal );
   STDMETHOD(GetDisplayInfo)( BSTR * pbstrVendor, BSTR * pbstrDisplayValue );
   STDMETHOD(get_VarValue)( VARIANT * pvarVal );
   STDMETHOD(get_AttributeID)( ATTRIBUTEID * pID );
   bool isEmpty()
   {
      return V_VT(&m_varValue) == VT_EMPTY;
   }

private:
   
   CComPtr<IIASAttributeInfo> m_spIASAttributeInfo;
   CComVariant             m_varValue;    

};

#endif // _IASPROFA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgauthen.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    pgauthen.cpp
//
// SYNOPSIS
//
//      Implementation of CPgAuthentication -- property page to edit
//      profile attributes related to Authenticaion
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "rrascfg.h"
#include "resource.h"
#include "PgAuthen.h"
#include "helptable.h"
#include <htmlhelp.h>
#include "eapnegotiate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  NO_OLD_VALUE

#define AUTHEN_WARNING_helppath "\\help\\RRASconcepts.chm::/sag_RRAS-Ch1_44.htm"

/////////////////////////////////////////////////////////////////////////////
// CPgAuthenticationMerge message handlers

BEGIN_MESSAGE_MAP(CPgAuthenticationMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CPgAuthenticationMerge)
   ON_BN_CLICKED(IDC_CHECKMD5CHAP, OnCheckmd5chap)
   ON_BN_CLICKED(IDC_CHECKMSCHAP, OnCheckmschap)
   ON_BN_CLICKED(IDC_CHECKPAP, OnCheckpap)
   ON_WM_CONTEXTMENU()
   ON_WM_HELPINFO()
   ON_BN_CLICKED(IDC_EAP_METHODS, OnAuthConfigEapMethods)
   ON_BN_CLICKED(IDC_CHECKMSCHAP2, OnCheckmschap2)
   ON_BN_CLICKED(IDC_CHECKNOAUTHEN, OnChecknoauthen)
   ON_BN_CLICKED(IDC_CHECKMSCHAPPASS, OnCheckmschapPass)
   ON_BN_CLICKED(IDC_CHECKMSCHAP2PASS, OnCheckmschap2Pass)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CPgAuthenticationMerge::CPgAuthenticationMerge(CRASProfileMerge& profile) 
   : CManagedPage(CPgAuthenticationMerge::IDD),
   m_Profile(profile),
   m_fromProfile(true)
{
   //{{AFX_DATA_INIT(CPgAuthenticationMerge)
   m_bMD5Chap = FALSE;
   m_bMSChap = FALSE;
   m_bPAP = FALSE;
   m_bMSCHAP2 = FALSE;
   m_bUNAUTH = FALSE;
   m_bMSChapPass = FALSE;
   m_bMSChap2Pass = FALSE;
   //}}AFX_DATA_INIT

   m_bEAP = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_EAP)!= -1);
   m_bMSChap = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAP) != -1);
   m_bMD5Chap = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MD5CHAP) != -1);
   m_bPAP = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_PAP_SPAP) != -1);
   m_bMSCHAP2 = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAP2) != -1);
   m_bUNAUTH = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_UNAUTHEN) != -1);
   m_bMSChapPass = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAPPASS) != -1);
   m_bMSChap2Pass = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAP2PASS) != -1);

   // original values before edit
   m_bOrgEAP = m_bEAP;
   m_bOrgMD5Chap = m_bMD5Chap;
   m_bOrgMSChap = m_bMSChap;
   m_bOrgPAP = m_bPAP;
   m_bOrgMSCHAP2 = m_bMSCHAP2;
   m_bOrgUNAUTH = m_bUNAUTH;
   m_bOrgChapPass = m_bMSChapPass;
   m_bOrgChap2Pass = m_bMSChap2Pass;

   m_bAppliedEver = FALSE;

   SetHelpTable(g_aHelpIDs_IDD_AUTHENTICATION_MERGE);
}

CPgAuthenticationMerge::~CPgAuthenticationMerge()
{
   // compare the setting with the original ones, 
   // if user turned on more authentication type, 
   // start help
   if(   (!m_bOrgEAP && m_bEAP)
      || (!m_bOrgMD5Chap && m_bMD5Chap)
      || (!m_bOrgMSChap && m_bMSChap)
      || (!m_bOrgChapPass && m_bMSChapPass)
      || (!m_bOrgPAP && m_bPAP)
      || (!m_bOrgMSCHAP2 && m_bMSCHAP2)
      || (!m_bOrgChap2Pass && m_bMSChap2Pass)
      || (!m_bOrgUNAUTH && m_bUNAUTH))
   {
      if ( IDYES== AfxMessageBox(IDS_WARN_MORE_STEPS_FOR_AUTHEN, MB_YESNO))
         HtmlHelpA(NULL, AUTHEN_WARNING_helppath, HH_DISPLAY_TOPIC, 0);
   }
}

void CPgAuthenticationMerge::DoDataExchange(CDataExchange* pDX)
{
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgAuthenticationMerge)
   DDX_Check(pDX, IDC_CHECKMD5CHAP, m_bMD5Chap);
   DDX_Check(pDX, IDC_CHECKMSCHAP, m_bMSChap);
   DDX_Check(pDX, IDC_CHECKMSCHAP2, m_bMSCHAP2);
   DDX_Check(pDX, IDC_CHECKNOAUTHEN, m_bUNAUTH);
   DDX_Check(pDX, IDC_CHECKPAP, m_bPAP);
   DDX_Check(pDX, IDC_CHECKMSCHAPPASS, m_bMSChapPass);
   DDX_Check(pDX, IDC_CHECKMSCHAP2PASS, m_bMSChap2Pass);
   //}}AFX_DATA_MAP

   if (!m_bMSChap)
   {
      m_bMSChapPass = false;
   }

   if (!m_bMSCHAP2)
   {
      m_bMSChap2Pass = false;
   }
}


BOOL CPgAuthenticationMerge::OnInitDialog() 
{
   GetDlgItem(IDC_CHECKMSCHAP2PASS)->EnableWindow(m_bMSCHAP2);
   GetDlgItem(IDC_CHECKMSCHAPPASS)->EnableWindow(m_bMSChap);

   try
   {
      HRESULT hr = m_Profile.GetEapTypeList(
                                                m_eapConfig.types, 
                                                m_eapConfig.ids, 
                                                m_eapConfig.typeKeys, 
                                                &m_eapConfig.infoArray);

      if FAILED(hr)
      {
         ReportError(hr, IDS_ERR_EAPTYPELIST, NULL);
      }
   }
   catch(CMemoryException *pException)
   {
      pException->Delete();
      AfxMessageBox(IDS_OUTOFMEMORY);
      return TRUE;
   }

   CPropertyPage::OnInitDialog();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgAuthenticationMerge::OnCheckmd5chap() 
{
   SetModified();
}

void CPgAuthenticationMerge::OnCheckmschap() 
{
   CButton *Button = reinterpret_cast<CButton*>(GetDlgItem(IDC_CHECKMSCHAP));
   int status = Button->GetCheck();
   switch (status)
   {
   case 1:
      {
         GetDlgItem(IDC_CHECKMSCHAPPASS)->EnableWindow(TRUE);
         break;
      }
   case 0:
      {
         GetDlgItem(IDC_CHECKMSCHAPPASS)->EnableWindow(FALSE);
         break;
      }
   default:
      {
      }
   }
  
   SetModified();
}

void CPgAuthenticationMerge::OnCheckmschapPass() 
{
   SetModified();
}

void CPgAuthenticationMerge::OnCheckmschap2() 
{
   CButton *Button = reinterpret_cast<CButton*>(GetDlgItem(IDC_CHECKMSCHAP2));
   int status = Button->GetCheck();
   switch (status)
   {
   case 1:
      {
         GetDlgItem(IDC_CHECKMSCHAP2PASS)->EnableWindow(TRUE);
         break;
      }
   case 0:
      {
         GetDlgItem(IDC_CHECKMSCHAP2PASS)->EnableWindow(FALSE);
         break;
      }
   default:
      {
      }
   }

   SetModified();
}

void CPgAuthenticationMerge::OnCheckmschap2Pass() 
{
   SetModified();
}

void CPgAuthenticationMerge::OnCheckpap() 
{
   SetModified();
}

BOOL CPgAuthenticationMerge::TransferDataToProfile()
{
   // clear the string in profile
   m_Profile.m_dwArrayAuthenticationTypes.DeleteAll();

   if (m_bEAP || m_bMSChap || m_bMD5Chap || m_bPAP || m_bMSCHAP2 || m_bUNAUTH ||
       m_bMSChapPass || m_bMSChap2Pass)
   {
      m_Profile.m_dwAttributeFlags |=  PABF_msNPAuthenticationType;
   }
   else
   {
      AfxMessageBox(IDS_DATAENTRY_AUTHENTICATIONTYPE);
      return FALSE;
   }

   // EAP
   if (m_bEAP)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(RAS_AT_EAP);
   }
   else
   {
      m_Profile.m_dwAttributeFlags &= ~PABF_msNPAllowedEapType;
      m_Profile.m_dwArrayEapTypes.DeleteAll();
      m_Profile.m_dwArraynEAPTypeKeys.DeleteAll();
   }

   if (m_eapConfig.typesSelected.GetSize() > 0)
   {
      // here the button configure eap.. was pressed and some eap types 
      // were selected. (could be the same as before)
      m_Profile.m_dwAttributeFlags |=  PABF_msNPAllowedEapType;
      
      CDWArray eapTypesSelected;
      CDWArray typeKeysSelected;
      for (int i = 0; i < m_eapConfig.typesSelected.GetSize(); ++i)
      {
         // For each EAP Type Selected (string)
         // position = index in the types, ids and typekeys arrays 
         // corresponding to the EAP type selected
         int position = m_eapConfig.types.Find(
                           *m_eapConfig.typesSelected.GetAt(i));

         eapTypesSelected.Add(m_eapConfig.ids.GetAt(position));
         typeKeysSelected.Add(m_eapConfig.typeKeys.GetAt(position));
      }

      m_Profile.m_dwArrayEapTypes = eapTypesSelected;
      m_Profile.m_dwArraynEAPTypeKeys = typeKeysSelected;
   }
   // else: EAP was enabled when the page was opened. Nothing was changed in 
   // the EAP config. No need to update the list of eap types.
   
   // MS-Chap2
   if(m_bMSCHAP2)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP2);

   // MS-Chap
   if(m_bMSChap)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP);

   // MS-Chap2 Password Change
   if(m_bMSChap2Pass)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP2_CPW);

   // MS-Chap Password Change
   if(m_bMSChapPass)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP_CPW);

   // Chap
   if(m_bMD5Chap)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MD5CHAP);

   // PAP
   if(m_bPAP)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_PAP);
   }

   // UNAUTH
   if(m_bUNAUTH)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_NONE);
   }

   return TRUE;
}

void CPgAuthenticationMerge::OnOK()
{
   CManagedPage::OnOK();
}

BOOL CPgAuthenticationMerge::OnApply() 
{
   if (!GetModified())   
   {
      return TRUE;
   }

   if (!TransferDataToProfile())
   {
      return FALSE;
   }
      
   m_bAppliedEver = TRUE;
   return CManagedPage::OnApply();
}

void CPgAuthenticationMerge::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   CManagedPage::OnContextMenu(pWnd, point);
}

BOOL CPgAuthenticationMerge::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   return CManagedPage::OnHelpInfo(pHelpInfo);
}

BOOL CPgAuthenticationMerge::OnKillActive() 
{
   UpdateData();

   if (!TransferDataToProfile())
   {
      return FALSE;
   }
   
   return CPropertyPage::OnKillActive();
}

void CPgAuthenticationMerge::OnAuthConfigEapMethods()
{
   EapConfig eapConfigBackup;
   eapConfigBackup = m_eapConfig;
   EapNegotiate eapNegotiate(this, m_eapConfig, m_Profile, m_fromProfile);
   HRESULT hr = eapNegotiate.m_eapProfile.Assign(m_Profile.m_eapConfigData);
   if (SUCCEEDED(hr))
   {
      if (eapNegotiate.DoModal() == IDOK)
      {
         m_Profile.m_eapConfigData.Swap(eapNegotiate.m_eapProfile);
         m_bEAP = (m_eapConfig.typesSelected.GetSize() > 0)? TRUE: FALSE;
         SetModified();
         m_fromProfile = false;
      }
   }
   else
   {
      m_eapConfig = eapConfigBackup;
   }
}

void CPgAuthenticationMerge::OnChecknoauthen() 
{
   SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgconst.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   pgconst.cpp
      Implementation of CPgConstraints -- property page to edit
      profile attributes related to constraints

    FILE HISTORY:

*/

// PgConst.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PgConst.h"
#include "helptable.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CPgConstraintsMerge property page

IMPLEMENT_DYNCREATE(CPgConstraintsMerge, CManagedPage)

CPgConstraintsMerge::CPgConstraintsMerge(CRASProfileMerge* profile)
   : CManagedPage(CPgConstraintsMerge::IDD),
   m_pProfile(profile)
{
   //{{AFX_DATA_INIT(CPgConstraintsMerge)
   m_bCallNumber = FALSE;
   m_bRestrictedToPeriod = FALSE;
   m_dwMaxSession = m_pProfile->m_dwSessionTimeout / 60; // sec --> min
   m_dwIdle = m_pProfile->m_dwIdleTimeout / 60;
   m_strCalledNumber = _T("");
   m_bIdle = FALSE;
   m_bSessionLen = FALSE;
   m_bPortTypes = FALSE;
   //}}AFX_DATA_INIT

   m_bSessionLen = ((m_pProfile->m_dwAttributeFlags & PABF_msRADIUSSessionTimeout) != 0);
   if(!m_bSessionLen)      m_dwMaxSession = 1;

   m_bIdle = ((m_pProfile->m_dwAttributeFlags & PABF_msRADIUSIdleTimeout) != 0);
   if(!m_bIdle) m_dwIdle = 1;

   m_bCallNumber = ((m_pProfile->m_dwAttributeFlags & PABF_msNPCalledStationId) != 0);
   if(m_bCallNumber)
      m_strCalledNumber = *(m_pProfile->m_strArrayCalledStationId[(INT_PTR)0]);

   m_bRestrictedToPeriod = ((m_pProfile->m_dwAttributeFlags & PABF_msNPTimeOfDay) != 0);
   m_bPortTypes = ((m_pProfile->m_dwAttributeFlags & PABF_msNPAllowedPortTypes) != 0);
   
   m_bInited = false;

   SetHelpTable(g_aHelpIDs_IDD_CONSTRAINTS_MERGE);

   m_pBox = NULL;
}

CPgConstraintsMerge::~CPgConstraintsMerge()
{
   delete m_pBox;
}

void CPgConstraintsMerge::DoDataExchange(CDataExchange* pDX)
{
   ASSERT(m_pProfile);
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgConstraintsMerge)
   DDX_Control(pDX, IDC_CHECK_PORTTYPES, m_CheckPortTypes);
   DDX_Control(pDX, IDC_LIST_PORTTYPES, m_listPortTypes);
   DDX_Control(pDX, IDC_CHECKSESSIONLEN, m_CheckSessionLen);
   DDX_Control(pDX, IDC_CHECKIDLE, m_CheckIdle);
   DDX_Control(pDX, IDC_BUTTONEDITTIMEOFDAY, m_ButtonEditTimeOfDay);
   DDX_Control(pDX, IDC_LISTTIMEOFDAY, m_ListTimeOfDay);
   DDX_Control(pDX, IDC_SPINMAXSESSION, m_SpinMaxSession);
   DDX_Control(pDX, IDC_SPINIDLETIME, m_SpinIdleTime);
   DDX_Control(pDX, IDC_EDITMAXSESSION, m_EditMaxSession);
   DDX_Control(pDX, IDC_EDITIDLETIME, m_EditIdleTime);
   
   DDX_Check(pDX, IDC_CHECKCALLNUMBER, m_bCallNumber);
   DDX_Check(pDX, IDC_CHECKRESTRICTPERIOD, m_bRestrictedToPeriod);
   DDX_Check(pDX, IDC_CHECKIDLE, m_bIdle);
   DDX_Check(pDX, IDC_CHECKSESSIONLEN, m_bSessionLen);
   DDX_Check(pDX, IDC_CHECK_PORTTYPES, m_bPortTypes);
   
   DDX_Text(pDX, IDC_EDITMAXSESSION, m_dwMaxSession);
   if(m_bSessionLen)
   {
      DDV_MinMaxUInt(pDX, m_dwMaxSession, 1, MAX_SESSIONTIME);
   }

   DDX_Text(pDX, IDC_EDITIDLETIME, m_dwIdle);
   if(m_bIdle)
   {
      DDV_MinMaxUInt(pDX, m_dwIdle, 1, MAX_IDLETIMEOUT);
   }

   DDX_Text(pDX, IDC_EDITCALLNUMBER, m_strCalledNumber);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPgConstraintsMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CPgConstraintsMerge)
   ON_EN_CHANGE(IDC_EDITMAXSESSION, OnChangeEditmaxsession)
   ON_EN_CHANGE(IDC_EDITIDLETIME, OnChangeEditidletime)
   ON_BN_CLICKED(IDC_CHECKCALLNUMBER, OnCheckcallnumber)
   ON_BN_CLICKED(IDC_CHECKRESTRICTPERIOD, OnCheckrestrictperiod)
   ON_WM_HELPINFO()
   ON_BN_CLICKED(IDC_BUTTONEDITTIMEOFDAY, OnButtonedittimeofday)
   ON_EN_CHANGE(IDC_EDITCALLNUMBER, OnChangeEditcallnumber)
   ON_WM_CONTEXTMENU()
   ON_BN_CLICKED(IDC_CHECKIDLE, OnCheckidle)
   ON_BN_CLICKED(IDC_CHECKSESSIONLEN, OnChecksessionlen)
   ON_BN_CLICKED(IDC_CHECK_PORTTYPES, OnCheckPorttypes)
   ON_NOTIFY(LVXN_SETCHECK, IDC_LIST_PORTTYPES, OnItemclickListPorttypes)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgConstraintsMerge message handlers

BOOL CPgConstraintsMerge::OnInitDialog()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   CPropertyPage::OnInitDialog();

   EnableSettings();

   // set spin range
   m_SpinIdleTime.SetRange(1, MAX_IDLETIMEOUT);
   m_SpinMaxSession.SetRange(1, MAX_SESSIONTIME);

   // list box
   // parse the time of day strings to hours bit map
   StrArrayToHourMap(m_pProfile->m_strArrayTimeOfDay, m_TimeOfDayHoursMap);
   // convert value from string to this map

   HourMapToStrArray(m_TimeOfDayHoursMap, m_strArrayTimeOfDayDisplay, TRUE /* localized */);

   try{
      m_pBox = new CStrBox<CListBox>(this, IDC_LISTTIMEOFDAY, m_strArrayTimeOfDayDisplay);
      m_pBox->Fill();
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      delete m_pBox;
      m_pBox = NULL;
      MyMessageBox(IDS_OUTOFMEMORY);
   };

   // Port Types, list box
   CStrArray   portTypeNames;
   CDWArray portTypeIds;

   HRESULT hr = m_pProfile->GetPortTypeList(portTypeNames, portTypeIds);

   if FAILED(hr)
      ReportError(hr, IDS_ERR_PORTTYPELIST, NULL);
   else
   {
      ListView_SetExtendedListViewStyle(m_listPortTypes.GetSafeHwnd(),
                                LVS_EX_FULLROWSELECT);
   
      // Initialize checkbox handling in the list control
      m_listPortTypes.InstallChecks();

      RECT  rect;
      m_listPortTypes.GetClientRect(&rect);
      m_listPortTypes.InsertColumn(0, NULL, LVCFMT_LEFT, (rect.right - rect.left - 24));

   
      int   cRow = 0;
      CString* pStr;
      BOOL     bAllowedType = FALSE;
      
      for(int i = 0; i < portTypeNames.GetSize(); i++)
      {
         pStr = portTypeNames.GetAt(i);

         cRow = m_listPortTypes.InsertItem(0, *pStr);
         m_listPortTypes.SetItemData(cRow, portTypeIds.GetAt(i));

         // check if the current row is an allowed type
         bAllowedType = (-1 != m_pProfile->m_dwArrayAllowedPortTypes.Find(portTypeIds.GetAt(i)));
         m_listPortTypes.SetCheck(cRow, bAllowedType);
      }

      m_listPortTypes.SetItemState(0, LVIS_SELECTED ,LVIF_STATE | LVIS_SELECTED);
   }

   m_listPortTypes.EnableWindow(m_CheckPortTypes.GetCheck());

   m_bInited = true;
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgConstraintsMerge::OnChangeEditmaxsession()
{
   // TODO: If this is a RICHEDIT control, the control will not
   // send this notification unless you override the CPropertyPage::OnInitDialog()
   // function to send the EM_SETEVENTMASK message to the control
   // with the ENM_CHANGE flag ORed into the lParam mask.
   if(m_bInited)  SetModified();
}

void CPgConstraintsMerge::OnChangeEditidletime()
{
   // TODO: If this is a RICHEDIT control, the control will not
   // send this notification unless you override the CPropertyPage::OnInitDialog()
   // function to send the EM_SETEVENTMASK message to the control
   // with the ENM_CHANGE flag ORed into the lParam mask.
   if(m_bInited) SetModified();
}

BOOL CPgConstraintsMerge::OnApply()
{
   if (!GetModified())  return TRUE;

   // get the allowed port(media) type
   m_pProfile->m_dwArrayAllowedPortTypes.DeleteAll();

   int   count = m_listPortTypes.GetItemCount();
   if(m_CheckPortTypes.GetCheck())
   {
      BOOL  bEmpty = TRUE;
      while(count-- > 0)
      {
         if(m_listPortTypes.GetCheck(count))
         {
            m_pProfile->m_dwArrayAllowedPortTypes.Add(m_listPortTypes.GetItemData(count));
            bEmpty = FALSE;
         }
      }
      
      if(bEmpty)
      {
         GotoDlgCtrl(&m_CheckPortTypes);
         MyMessageBox(IDS_ERR_NEEDPORTTYPE);
         return FALSE;
      }

      m_pProfile->m_dwAttributeFlags |= PABF_msNPAllowedPortTypes;
   }
   else
      m_pProfile->m_dwAttributeFlags &= (~PABF_msNPAllowedPortTypes);
   
   if(!m_bIdle)
   {
      m_pProfile->m_dwAttributeFlags &= (~PABF_msRADIUSIdleTimeout);
      m_pProfile->m_dwIdleTimeout = 0;
   }
   else
   {
      m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSIdleTimeout;
      m_pProfile->m_dwIdleTimeout = m_dwIdle * 60;
   }

   if(!m_bSessionLen)
   {
      m_pProfile->m_dwAttributeFlags &= (~PABF_msRADIUSSessionTimeout);
      m_pProfile->m_dwSessionTimeout = 0;
   }
   else
   {
      m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSSessionTimeout;
      m_pProfile->m_dwSessionTimeout = m_dwMaxSession * 60;
   }
   
   // Regure call to this number
   if(m_bCallNumber && m_strCalledNumber.GetLength())
   {
      m_pProfile->m_dwAttributeFlags |= PABF_msNPCalledStationId;
      if(m_pProfile->m_strArrayCalledStationId.GetSize())
         *(m_pProfile->m_strArrayCalledStationId[(INT_PTR)0]) = m_strCalledNumber;
      else
         m_pProfile->m_strArrayCalledStationId.Add(new CString(m_strCalledNumber));
   }
   else
   {
      m_pProfile->m_dwAttributeFlags &= (~PABF_msNPCalledStationId);
      m_pProfile->m_strArrayCalledStationId.DeleteAll();
   }

   if(!m_bRestrictedToPeriod)
   {
      m_pProfile->m_dwAttributeFlags &= (~PABF_msNPTimeOfDay);
      m_pProfile->m_strArrayTimeOfDay.DeleteAll();
   }
   else
   {
      if(m_pProfile->m_strArrayTimeOfDay.GetSize() == 0)
      {
         GotoDlgCtrl(&m_ButtonEditTimeOfDay);
         MyMessageBox(IDS_ERR_NEEDTIMEOFDAY);
         return FALSE;
      }
      
      m_pProfile->m_dwAttributeFlags |= PABF_msNPTimeOfDay;
   }
   
   return CManagedPage::OnApply();
}

void CPgConstraintsMerge::OnCheckcallnumber()
{
   EnableCalledStation(((CButton*)GetDlgItem(IDC_CHECKCALLNUMBER))->GetCheck());
   
   if(m_bInited) SetModified();
}

void CPgConstraintsMerge::OnCheckrestrictperiod()
{
   // TODO: Add your control notification handler code here
   if(((CButton*)GetDlgItem(IDC_CHECKRESTRICTPERIOD))->GetCheck())
   {
      EnableTimeOfDay(TRUE);
      if(!m_pProfile->m_strArrayTimeOfDay.GetSize())
      {
         // there is nothing defined as constraint
         BYTE*    pMap = &(m_TimeOfDayHoursMap[0]);
         memset(m_TimeOfDayHoursMap, 0xff, sizeof(m_TimeOfDayHoursMap));

         HourMapToStrArray(pMap, m_pProfile->m_strArrayTimeOfDay, FALSE);
         // redraw the list box
         HourMapToStrArray(pMap, m_strArrayTimeOfDayDisplay, TRUE /* if localized */);
         m_pBox->Fill();

      }
   }
   else
      EnableTimeOfDay(FALSE);

   if(m_bInited) SetModified();
}

void CPgConstraintsMerge::EnableSettings()
{
   EnableSessionSettings(m_bSessionLen);
   EnableIdleSettings(m_bIdle);
   EnableCalledStation(m_bCallNumber);
   EnableTimeOfDay(m_bRestrictedToPeriod);
}

void CPgConstraintsMerge::EnableCalledStation(BOOL b)
{
   GetDlgItem(IDC_EDITCALLNUMBER)->EnableWindow(b);
}

void CPgConstraintsMerge::EnableMediaSelection(BOOL b)
{
}

void CPgConstraintsMerge::EnableTimeOfDay(BOOL bEnable)
{
   m_ListTimeOfDay.EnableWindow(bEnable);
   m_ButtonEditTimeOfDay.EnableWindow(bEnable);
}


//================================================
// When to edit time of day information

void CPgConstraintsMerge::OnButtonedittimeofday()
{
   CString     dlgTitle;
   dlgTitle.LoadString(IDS_DIALINHOURS);
   BYTE*    pMap = &(m_TimeOfDayHoursMap[0]);

   // parse the time of day strings to hours bit map
   if(S_OK == OpenTimeOfDayDlgEx(m_hWnd, (BYTE**)&pMap, dlgTitle, SCHED_FLAG_INPUT_LOCAL_TIME))
   {
      HourMapToStrArray(pMap, m_pProfile->m_strArrayTimeOfDay, FALSE);
      // redraw the list box
      HourMapToStrArray(pMap, m_strArrayTimeOfDayDisplay, TRUE);
      m_pBox->Fill();
      SetModified();
   }

}

void CPgConstraintsMerge::EnableSessionSettings(BOOL bEnable)
{
   m_EditMaxSession.EnableWindow(bEnable);
   m_SpinMaxSession.EnableWindow(bEnable);
}

void CPgConstraintsMerge::EnableIdleSettings(BOOL bEnable)
{
   m_EditIdleTime.EnableWindow(bEnable);
   m_SpinIdleTime.EnableWindow(bEnable);
}

void CPgConstraintsMerge::OnChangeEditcallnumber()
{
   if(m_bInited)  SetModified();
}

void CPgConstraintsMerge::OnContextMenu(CWnd* pWnd, CPoint point)
{
   CManagedPage::OnContextMenu(pWnd, point);
}
BOOL CPgConstraintsMerge::OnHelpInfo(HELPINFO* pHelpInfo)
{
   return CManagedPage::OnHelpInfo(pHelpInfo);
}



void CPgConstraintsMerge::OnCheckidle()
{
   SetModified();
   EnableIdleSettings(m_CheckIdle.GetCheck());
}

void CPgConstraintsMerge::OnChecksessionlen()
{
   SetModified();
   EnableSessionSettings(m_CheckSessionLen.GetCheck());
}

BOOL CPgConstraintsMerge::OnKillActive()
{
   CButton* pButton = (CButton*)GetDlgItem(IDC_CHECKCALLNUMBER);
   CEdit*      pEdit = (CEdit*)GetDlgItem(IDC_EDITCALLNUMBER);
   int         count;
   int         errID;

   ASSERT(pButton);  // if the IDC is not correct, the return will be NULL
   ASSERT(pEdit);

   if(pButton->GetCheck() && !pEdit->LineLength())
   {
      GotoDlgCtrl( pEdit );
      MyMessageBox(IDS_ERR_NEEDPHONENUMBER);
      return FALSE;
   }
   
   count = m_listPortTypes.GetItemCount();
   if(m_CheckPortTypes.GetCheck())
   {
      BOOL  bEmpty = TRUE;
      while(count-- > 0)
      {
         if(m_listPortTypes.GetCheck(count))
         {
            bEmpty = FALSE;
         }
      }
      
      if(bEmpty)
      {
         GotoDlgCtrl(&m_CheckPortTypes);
         MyMessageBox(IDS_ERR_NEEDPORTTYPE);
         return FALSE;
      }
   }

   return CPropertyPage::OnKillActive();

   MyMessageBox(IDS_ERR_DATAENTRY);
   return FALSE;
}

void CPgConstraintsMerge::OnCheckPorttypes()
{
   // TODO: Add your control notification handler code here
   
   m_listPortTypes.EnableWindow(m_CheckPortTypes.GetCheck());
   m_listPortTypes.SetFocus();
   m_listPortTypes.SetItemState(0, LVIS_FOCUSED | LVIS_SELECTED ,LVIF_STATE);
   SetModified();
}


void CPgConstraintsMerge::OnItemclickListPorttypes(NMHDR* pNMHDR, LRESULT* pResult)
{
   HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;
   // TODO: Add your control notification handler code here
   
   *pResult = 0;

   if(m_bInited)
      SetModified();
}

// hour map ( one bit for an hour of a week )
static BYTE    bitSetting[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};
static LPCTSTR daysOfWeekinDS[7] = {RAS_DOW_SUN, RAS_DOW_MON, RAS_DOW_TUE, RAS_DOW_WED,
            RAS_DOW_THU, RAS_DOW_FRI, RAS_DOW_SAT};
static UINT daysOfWeekIDS[7] = {IDS_SUNDAY, IDS_MONDAY, IDS_TUESDAY, IDS_WEDNESDAY, IDS_THURSDAY,
            IDS_FRIDAY, IDS_SATURDAY};
static UINT daysOfWeekLCType[7] = {LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1 , LOCALE_SABBREVDAYNAME2 , LOCALE_SABBREVDAYNAME3 , LOCALE_SABBREVDAYNAME4 ,
            LOCALE_SABBREVDAYNAME5 , LOCALE_SABBREVDAYNAME6 };

//+---------------------------------------------------------------------------
//====================================================
// convert an Array of Strings to Hour Map
// Strings in following format: 0 1:00-12:00 15:00-17:00
// hour map: a bit for an hour, 7 * 24 hours = 7 * 3 bytes
void StrArrayToHourMap(CStrArray& array, BYTE* map)
{
   CStrParser  Parser;
   int         sh, sm, eh, em = 0;  // start hour, (min), end hour (min)
   int         day;
   BYTE*    pHourMap;
   int         i;

   int count = array.GetSize();
   memset(map, 0, sizeof(BYTE) * 21);
   while(count--)
   {
      Parser.SetStr(*(array[(INT_PTR)count]));

      Parser.SkipBlank();
      day = Parser.DayOfWeek();
      Parser.SkipBlank();
      if(day == -1) continue;

      pHourMap = map + sizeof(BYTE) * 3 * day;

      while(-1 != (sh = Parser.GetUINT())) // sh:sm-eh:em
      {
         Parser.GotoAfter(_T(':'));
         if(-1 == (sm = Parser.GetUINT()))   // min
            break;
         Parser.GotoAfter(_T('-'));
         if(-1 == (eh = Parser.GetUINT()))   // hour
            break;
         if(-1 == (sm = Parser.GetUINT()))   // min
            break;
         sm %= 60; sh %= 24; em %= 60; eh %= 25;   // since we have end hour of 24:00
         for(i = sh; i < eh; i++)
         {
            *(pHourMap + i / 8) |= bitSetting[i % 8];
         }
      }
   }
}

//=====================================================
// convert value from map to strings
void HourMapToStrArray(BYTE* map, CStrArray& array, BOOL bLocalized)
{
   int         sh, eh;  // start hour, (min), end hour (min)
   BYTE*    pHourMap;
   int         i, j;
   CString* pStr;
   CString     tmpStr;
   TCHAR    tempName[MAX_PATH];

   // update the profile table
   pHourMap = map;
   array.DeleteAll();

   for( i = 0; i < 7; i++) // for each day
   {
      // if any value for this day
      if(*pHourMap || *(pHourMap + 1) || *(pHourMap + 2))
      {
         // the string for this day
         try{
            pStr = NULL;
            if(bLocalized) // for display
            {
               int nLen = GetLocaleInfo(LOCALE_USER_DEFAULT, daysOfWeekLCType[i], tempName, MAX_PATH - 1);

               pStr = new CString;
               if(nLen == 0)  // FAILED
               {
                  pStr->LoadString(daysOfWeekIDS[i]);
               }
               else
               {
                  *pStr = tempName;
               }
            }
            else  // when write to DS
               pStr = new CString(daysOfWeekinDS[i]);

            sh = -1; eh = -1; // not start yet
            for(j = 0; j < 24; j++) // for every hour
            {
               int   k = j / 8;
               int m = j % 8;
               if(*(pHourMap + k) & bitSetting[m]) // this hour is on
               {
                  if(sh == -1)   sh = j;        // set start hour is empty
                  eh = j;                    // extend end hour
               }
               else  // this is not on
               {
                  if(sh != -1)      // some hours need to write out
                  {
                     tmpStr.Format(_T(" %02d:00-%02d:00"), sh, eh + 1);
                     *pStr += tmpStr;
                     sh = -1; eh = -1;
                  }
               }
            }
            if(sh != -1)
            {
               tmpStr.Format(_T(" %02d:00-%02d:00"), sh, eh + 1);
               *pStr += tmpStr;
               sh = -1; eh = -1;
            }

            // TRACE(*pStr);
            array.Add(pStr);
         }
         catch(CMemoryException* pException)
         {
            pException->Delete();
            AfxMessageBox(IDS_OUTOFMEMORY);
            delete pStr;
            array.DeleteAll();
            return;
         }
         
      }
      pHourMap += 3;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgauthen2k.cpp ===
//////////////////////////////////////////////////////////////////////////////
// 
//    Copyright(c) Microsoft Corporation
// 
//    pgauthen2k.cpp
//      Implementation of CPgAuthentication -- property page to edit
//      profile attributes related to Authenticaion
// 
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <rrascfg.h>
#include "resource.h"
#include "PgAuthen2k.h"
#include "helptable.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  NO_OLD_VALUE

// help path
#define AUTHEN_WARNING_helppath "\\help\\RRASconcepts.chm::/sag_RRAS-Ch1_44.htm"

/////////////////////////////////////////////////////////////////////////////
// CPgAuthentication2kMerge property page
CPgAuthentication2kMerge::CPgAuthentication2kMerge(CRASProfileMerge& profile) 
   : CManagedPage(CPgAuthentication2kMerge::IDD),
     m_Profile(profile),
     m_pBox(NULL)
{
   //{{AFX_DATA_INIT(CPgAuthentication2kMerge)
   m_bEAP = FALSE;
   m_bMD5Chap = FALSE;
   m_bMSChap = FALSE;
   m_bPAP = FALSE;
   m_strEapType = _T("");
   m_bMSCHAP2 = FALSE;
   m_bUNAUTH = FALSE;
   //}}AFX_DATA_INIT

   m_bEAP = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_EAP)!= -1);
   m_bMSChap = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAP) != -1);
   m_bMD5Chap = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MD5CHAP) != -1);
   m_bPAP = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_PAP_SPAP) != -1);
   m_bMSCHAP2 = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_MSCHAP2) != -1);
   m_bUNAUTH = (m_Profile.m_dwArrayAuthenticationTypes.Find(RAS_AT_UNAUTHEN) != -1);

   // orginal value before edit
   m_bOrgEAP = m_bEAP;
   m_bOrgMD5Chap = m_bMD5Chap;
   m_bOrgMSChap = m_bMSChap;
   m_bOrgPAP = m_bPAP;
   m_bOrgMSCHAP2 = m_bMSCHAP2;
   m_bOrgUNAUTH = m_bUNAUTH;

   m_bAppliedEver = FALSE;


   SetHelpTable(g_aHelpIDs_IDD_AUTHENTICATION_MERGE2K);

   m_bInited = false;
}

CPgAuthentication2kMerge::~CPgAuthentication2kMerge()
{
   delete   m_pBox;

   // compare the setting with the original ones, 
   // if user turned on more authentication type, 
   // start help
   if(
         (!m_bOrgEAP && m_bEAP)
      || (!m_bOrgMD5Chap && m_bMD5Chap)
      || (!m_bOrgMSChap && m_bMSChap)
      || (!m_bOrgPAP && m_bPAP)
      || (!m_bOrgMSCHAP2 && m_bMSCHAP2)
      || (!m_bOrgUNAUTH && m_bUNAUTH))
   {
      if ( IDYES== AfxMessageBox(IDS_WARN_MORE_STEPS_FOR_AUTHEN, MB_YESNO))
         HtmlHelpA(NULL, AUTHEN_WARNING_helppath, HH_DISPLAY_TOPIC, 0);
   }
}

void CPgAuthentication2kMerge::DoDataExchange(CDataExchange* pDX)
{
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgAuthentication2kMerge)
   DDX_Check(pDX, IDC_CHECKEAP, m_bEAP);
   DDX_Check(pDX, IDC_CHECKMD5CHAP, m_bMD5Chap);
   DDX_Check(pDX, IDC_CHECKMSCHAP, m_bMSChap);
   DDX_CBString(pDX, IDC_COMBOEAPTYPE, m_strEapType);
   DDX_Check(pDX, IDC_CHECKMSCHAP2, m_bMSCHAP2);
   DDX_Check(pDX, IDC_CHECKNOAUTHEN, m_bUNAUTH);
   DDX_Check(pDX, IDC_CHECKPAP, m_bPAP);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPgAuthentication2kMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CPgAuthentication2kMerge)
   ON_BN_CLICKED(IDC_CHECKEAP, OnCheckeap)
   ON_BN_CLICKED(IDC_CHECKMD5CHAP, OnCheckmd5chap)
   ON_BN_CLICKED(IDC_CHECKMSCHAP, OnCheckmschap)
   ON_BN_CLICKED(IDC_CHECKPAP, OnCheckpap)
   ON_CBN_SELCHANGE(IDC_COMBOEAPTYPE, OnSelchangeComboeaptype)
   ON_WM_CONTEXTMENU()
   ON_WM_HELPINFO()
   ON_BN_CLICKED(IDC_AUTH_CONFIG_EAP, OnAuthConfigEap)
   ON_BN_CLICKED(IDC_CHECKMSCHAP2, OnCheckmschap2)
   ON_BN_CLICKED(IDC_CHECKNOAUTHEN, OnChecknoauthen)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgAuthentication2kMerge message handlers

BOOL CPgAuthentication2kMerge::OnInitDialog() 
{
   BOOL  bEnableConfig = FALSE;

   CPropertyPage::OnInitDialog();

   // the combobox for eap types
   try
   {
      HRESULT hr = m_Profile.GetEapTypeList(m_EapTypes, m_EapIds, m_EapTypeKeys, &m_EapInfoArray);
      if (FAILED(hr))
      {
         ReportError(hr, IDS_ERR_EAPTYPELIST, NULL);
         return TRUE;
      }

      m_pBox = new CStrBox<CComboBox>(this, IDC_COMBOEAPTYPE, m_EapTypes);

      if(m_pBox == NULL)
      {
         AfxMessageBox(IDS_OUTOFMEMORY);
         return TRUE;   
      }

      m_pBox->Fill();
      GetDlgItem(IDC_COMBOEAPTYPE)->EnableWindow(m_bEAP);
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      AfxMessageBox(IDS_OUTOFMEMORY);
      return TRUE;
   }

   // if there is a value selected from the list
   if(m_EapIds.GetSize())
   {
      // This is win2k so the first id is the right one
      m_pBox->Select(0);
      bEnableConfig = !(m_EapInfoArray.ElementAt(0).m_stConfigCLSID.IsEmpty());
   }

   GetDlgItem(IDC_AUTH_CONFIG_EAP)->EnableWindow(bEnableConfig);
   
   m_bInited = true;
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgAuthentication2kMerge::OnCheckeap() 
{
   BOOL b = ((CButton*)GetDlgItem(IDC_CHECKEAP))->GetCheck();
   // enable / disable configure button based on if the type has config clsID
   int i = m_pBox->GetSelected();
   BOOL  bEnableConfig;

   if (i != -1)
   {
      bEnableConfig = !(m_EapInfoArray.ElementAt(i).m_stConfigCLSID.IsEmpty());
   }
   else
      bEnableConfig = FALSE;

   GetDlgItem(IDC_COMBOEAPTYPE)->EnableWindow(b);
   GetDlgItem(IDC_AUTH_CONFIG_EAP)->EnableWindow(bEnableConfig);

   SetModified(); 
}

void CPgAuthentication2kMerge::OnCheckmd5chap() 
{
   SetModified();
}

void CPgAuthentication2kMerge::OnCheckmschap() 
{
   SetModified();
}

void CPgAuthentication2kMerge::OnCheckmschap2() 
{
   SetModified();
}

void CPgAuthentication2kMerge::OnCheckpap() 
{
   // TODO: Add your control notification handler code here
   SetModified();
}

void CPgAuthentication2kMerge::OnChecknoauthen() 
{
   // TODO: Add your control notification handler code here
   
   SetModified();
}

void CPgAuthentication2kMerge::OnSelchangeComboeaptype() 
{
   // enable / disable configure button based on if the type has config clsID
   int i = m_pBox->GetSelected();
   BOOL  bEnableConfig;
   if (i != -1)
   {
      bEnableConfig = !(m_EapInfoArray.ElementAt(i).m_stConfigCLSID.IsEmpty());
   }
   else
      bEnableConfig = FALSE;

   GetDlgItem(IDC_AUTH_CONFIG_EAP)->EnableWindow(bEnableConfig);
   
   if(m_bInited)  SetModified(); 
}

BOOL CPgAuthentication2kMerge::TransferDataToProfile()
{

   // clear the string in profile
   m_Profile.m_dwArrayAuthenticationTypes.DeleteAll();

   if(m_bEAP || m_bMSChap || m_bMD5Chap || m_bPAP || m_bMSCHAP2 || m_bUNAUTH)
      m_Profile.m_dwAttributeFlags |=  PABF_msNPAuthenticationType;
   else
   {
      AfxMessageBox(IDS_DATAENTRY_AUTHENTICATIONTYPE);
      return FALSE;
   }

   // EAP
   if(m_bEAP)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(RAS_AT_EAP);

      // get the EAP type
      if (m_pBox->GetSelected() != -1)
      {
         m_Profile.m_dwAttributeFlags |=  PABF_msNPAllowedEapType;
         m_Profile.m_dwArrayEapTypes.DeleteAll();
         m_Profile.m_dwArrayEapTypes.Add(m_EapIds.GetAt(m_pBox->GetSelected()));
      }
      else
      {
         GotoDlgCtrl( m_pBox->m_pBox );
         AfxMessageBox(IDS_DATAENTRY_EAPTYPE);
         return FALSE;
      }
   }
   else
   {
      m_Profile.m_dwAttributeFlags &= ~PABF_msNPAllowedEapType;
      m_Profile.m_dwArrayEapTypes.DeleteAll();
   }

   // MS-Chap2
   if(m_bMSCHAP2)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP2);

   // MS-Chap
   if(m_bMSChap)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MSCHAP);

   // Chap
   if(m_bMD5Chap)
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_MD5CHAP);

   // PAP
   if(m_bPAP)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_PAP);
   }

   // UNAUTH
   if(m_bUNAUTH)
   {
      m_Profile.m_dwArrayAuthenticationTypes.Add(IAS_AUTH_NONE);
   }

   return TRUE;
}


void CPgAuthentication2kMerge::OnOK()
{
   CManagedPage::OnOK();

}


BOOL CPgAuthentication2kMerge::OnApply() 
{
   if(!GetModified())   return TRUE;

   if(!TransferDataToProfile())
      return FALSE;
      
   m_bAppliedEver = TRUE;
   return CManagedPage::OnApply();
}

void CPgAuthentication2kMerge::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   CManagedPage::OnContextMenu(pWnd, point);
}

BOOL CPgAuthentication2kMerge::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   return CManagedPage::OnHelpInfo(pHelpInfo);
}

BOOL CPgAuthentication2kMerge::OnKillActive() 
{
   UpdateData();

   if(!TransferDataToProfile())
      return FALSE;
   
   return CPropertyPage::OnKillActive();
}


void CPgAuthentication2kMerge::OnAuthConfigEap() 
{
   // enable / disable configure button based on if the type has config clsID
   int i = m_pBox->GetSelected();
    // Bring up the configuration UI for this EAP
   // ----------------------------------------------------------------
    AuthProviderData *   pData;
   CComPtr<IEAPProviderConfig> spEAPConfig;
   
   GUID        guid;
   HRESULT     hr = S_OK;
   ULONG_PTR   uConnection = 0;
   BOOL  bEnableConfig;
   DWORD   dwId;

   if (i != -1)
   {
      bEnableConfig = !(m_EapInfoArray.ElementAt(i).m_stConfigCLSID.IsEmpty());
   }
   else
   {
      bEnableConfig = FALSE;
   }

    CHECK_HR( hr = CLSIDFromString((LPTSTR) (LPCTSTR)(m_EapInfoArray.ElementAt(i).m_stConfigCLSID), &guid) );

    // Create the EAP provider object
   // ----------------------------------------------------------------
    CHECK_HR( hr = CoCreateInstance(guid,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           __uuidof(IEAPProviderConfig),
                           (LPVOID *) &spEAPConfig) );

    // Configure this EAP provider
   // ----------------------------------------------------------------
   // EAP configure displays its own error message, so no hr is kept
   dwId = _ttol(m_EapInfoArray.ElementAt(i).m_stKey);
   if ( SUCCEEDED(spEAPConfig->Initialize(m_Profile.m_strMachineName, dwId, &uConnection)) )
   {
      spEAPConfig->ServerInvokeConfigUI(dwId, uConnection, GetSafeHwnd(), 0, 0);
      spEAPConfig->Uninitialize(dwId, uConnection);
   }
   
   if ( hr == E_NOTIMPL )
        hr = S_OK;

L_ERR:
    if ( FAILED(hr) )
    {
        // Bring up an error message
      // ------------------------------------------------------------
        ReportError(hr, IDS_ERR_CONFIG_EAP, GetSafeHwnd());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgiasadv.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    PgIASAdv.cpp

Abstract:

   Implementation file for the CPgIASAdv class.

   We implement the class needed to handle the Advanced tab 
   of the profile sheet.


Revision History:
   byao   - created 
   mmaguire 06/01/98 - extensively revamped


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "stdafx.h"
#include "resource.h"

//
// where we can find declaration for main class in this file:
//
#include "PgIASAdv.h"
//
//
// where we can find declarations needed in this file:
//
#include "IASHelper.h"
#include "IASProfA.h"
#include "DlgIASAdd.h"
#include "vendors.h"
#include "napmmc.h"

// help table
#include "helptable.h"
#include "iastrace.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define NOTHING_SELECTED   -1

IMPLEMENT_DYNCREATE(CPgIASAdv, CManagedPage)

BEGIN_MESSAGE_MAP(CPgIASAdv, CPropertyPage)
   //{{AFX_MSG_MAP(CPgIASAdv)
   ON_BN_CLICKED(IDC_IAS_BUTTON_ATTRIBUTE_ADD, OnButtonIasAttributeAdd)
   ON_BN_CLICKED(IDC_IAS_BUTTON_ATTRIBUTE_REMOVE, OnButtonIasAttributeRemove)
   ON_BN_CLICKED(IDC_IAS_BUTTON_ATTRIBUTE_EDIT, OnButtonIasAttributeEdit)
   ON_WM_HELPINFO()
   ON_WM_CONTEXTMENU()
   ON_NOTIFY(NM_DBLCLK, IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE, OnDblclkListIasProfattrs)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE, OnItemChangedListIasProfileAttributes)
   ON_NOTIFY(LVN_KEYDOWN, IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE, OnKeydownIasListAttributesInProfile)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::CPgIASAdv

  Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CPgIASAdv::CPgIASAdv(ISdo* pIProfile, ISdoDictionaryOld* pIDictionary) : 
         CManagedPage(CPgIASAdv::IDD)
{
   m_spProfileSdo = pIProfile;
   m_spDictionarySdo = pIDictionary;
   m_fAllAttrInitialized = FALSE;

   SetHelpTable(g_aHelpIDs_IDD_IAS_ADVANCED_TAB);

   m_bModified = FALSE;
   m_lAttrFilter = 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::CPgIASAdv

  Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CPgIASAdv::~CPgIASAdv()
{
   int iIndex;
    
   // delete all the profiel attribute node
   IASTraceString("Deleting arrProfileAttr list...");
   for (iIndex=0; iIndex<m_vecProfileAttributes.size(); iIndex++)
   {
      delete m_vecProfileAttributes[iIndex];
   }


   // release all the SDO pointers
   for (iIndex=0; iIndex<m_vecProfileSdos.size(); iIndex++)
   {
      if ( m_vecProfileSdos[iIndex] )
      {
         m_vecProfileSdos[iIndex]->Release();
         m_vecProfileSdos[iIndex] = NULL;
      }
   }

}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::DoDataExchange

--*/
//////////////////////////////////////////////////////////////////////////////
void CPgIASAdv::DoDataExchange(CDataExchange* pDX)
{
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgIASAdv)
   DDX_Control(pDX, IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE, m_listProfileAttributes);
   //}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CPgIASAdv message handlers


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPgIASAdv::OnInitDialog() 
{
   HRESULT   hr = S_OK;

   CPropertyPage::OnInitDialog();
   
   //
   // first, set the list box to 3 columns
   //
   LVCOLUMN lvc;
   int iCol;
   CString strColumnHeader;
   WCHAR   wzColumnHeader[MAX_PATH];

   // initialize the LVCOLUMN structure
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.cx = 120;
   lvc.pszText = wzColumnHeader;

   lvc.cx = ATTRIBUTE_NAME_COLUMN_WIDTH;
   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_NAME);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listProfileAttributes.InsertColumn(0, &lvc);

   lvc.cx = ATTRIBUTE_VENDOR_COLUMN_WIDTH;
   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_VENDOR);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listProfileAttributes.InsertColumn(1, &lvc);

   lvc.cx = ATTRIBUTE_VALUE_COLUMN_WIDTH;
   strColumnHeader.LoadString(IDS_IAS_ATTRIBUTES_COLUMN_VALUE);
   wcscpy(wzColumnHeader, strColumnHeader);
   m_listProfileAttributes.InsertColumn(2, &lvc);


   if ( !m_pvecAllAttributeInfos )
   {
      IASTraceString("Empty attribute list!");
      ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADVANCED_EMPTY_ATTRLIST, _T(""), hr);
      return TRUE;
   }
    // 
    // get the attribute collection of this profile
    // 
   hr = IASGetSdoInterfaceProperty(m_spProfileSdo,
                             (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                             IID_ISdoCollection, 
                             (void **) &m_spProfileAttributeCollectionSdo
                            );
   IASTracePrintf("IASGetSdoInterfaceProperty() returned %x", hr);

   if (SUCCEEDED(hr))
   {
      IASTraceString("Initializing profAttr list...");
      hr = InitProfAttrList();
   }

   if (FAILED(hr))
   {
      ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADVANCED_PROFATTRLIST, _T(""), hr);
   }

   if (m_lAttrFilter == ALLOWEDINPROXYPROFILE)
   {
      GetDlgItem(IDC_ADVANCED_RAP)->ShowWindow(SW_HIDE);

      GetDlgItem(IDC_ADVANCED_CRP)->EnableWindow(TRUE);
      GetDlgItem(IDC_ADVANCED_CRP)->ShowWindow(SW_SHOW);
   }
   else
   {
      GetDlgItem(IDC_ADVANCED_CRP)->ShowWindow(SW_HIDE);

      GetDlgItem(IDC_ADVANCED_RAP)->EnableWindow(TRUE);
      GetDlgItem(IDC_ADVANCED_RAP)->ShowWindow(SW_SHOW);
   }

   UpdateButtonState();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE

}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::InitProfAttrList
//
// Synopsis:  initialize the attribute list for this profile
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao   2/22/98 4:40:17 AM
//
//+---------------------------------------------------------------------------
HRESULT CPgIASAdv::InitProfAttrList()
{
   HRESULT              hr = S_OK;
   int                  iIndex;

   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   CComVariant          varAttributeSdo;
   long              ulCount;
   ULONG             ulCountReceived; 
   ATTRIBUTEID          AttrId;
   // 
    // initialize the variant
    // 

   _ASSERTE(m_spProfileAttributeCollectionSdo);

   // We check the count of items in our collection and don't bother getting the 
   // enumerator if the count is zero.  
   // This saves time and also helps us to a void a bug in the the enumerator which
   // causes it to fail if we call next when it is empty.
   m_spProfileAttributeCollectionSdo->get_Count( & ulCount );
   IASTracePrintf("Number of attribute in the profile: %ld", ulCount);

   if( ulCount <= 0 )
   {
      IASTraceString("No profile attributes, now updating the UI list");
      hr = UpdateProfAttrListCtrl();
      return hr;
   }

   // Get the enumerator for the attribute collection.
   hr = m_spProfileAttributeCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
   _ASSERTE( SUCCEEDED( hr ) );

   hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
   spUnknown.Release();

   _ASSERTE( spEnumVariant != NULL );

   // Get the first item.
   hr = spEnumVariant->Next( 1, &varAttributeSdo, &ulCountReceived );
   IASTracePrintf("Next() returned %x", hr);

   while( SUCCEEDED( hr ) && ulCountReceived == 1 )
   {
      // Get an sdo pointer from the variant we received.
      _ASSERTE( V_VT(&varAttributeSdo) == VT_DISPATCH );
      _ASSERTE( V_DISPATCH(&varAttributeSdo) != NULL );

      CComPtr<ISdo> spSdo;
      hr = V_DISPATCH(&varAttributeSdo)->QueryInterface( IID_ISdo, (void **) &spSdo );
      if ( !SUCCEEDED(hr))
      {
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_QUERYINTERFACE, _T(""), hr);
         continue;
      }

      // 
      // get attribute ID
      // 
      CComVariant varAttributeID;
      hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &varAttributeID); 
      if ( !SUCCEEDED(hr) )
      {
         IASTracePrintf("GetProperty(attributeId) failed, err = %x", hr);
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_GETPROPERTY, _T(""), hr);
         continue;
      }
      _ASSERTE( V_VT(&varAttributeID) == VT_I4 );        
      
      AttrId = (ATTRIBUTEID) V_I4(&varAttributeID);

      IASTracePrintf("Attribute ID = %ld", AttrId);

      // search the attribute in the system attribute list
      for (iIndex=0; iIndex<m_pvecAllAttributeInfos->size(); iIndex++)
      {
         // search for this attribute in the profile attribute list
         ATTRIBUTEID id;
         m_pvecAllAttributeInfos->at(iIndex)->get_AttributeID( &id );
         if( AttrId == id ) break;
      }
      
      if ( iIndex < m_pvecAllAttributeInfos->size() )
      {

         LONG lRestriction;
         hr = m_pvecAllAttributeInfos->at(iIndex)->get_AttributeRestriction( &lRestriction );
         _ASSERTE( SUCCEEDED(hr) );
         
         if( lRestriction & m_lAttrFilter )
         { 
            // attribute found in the global list, that means this is a valid ADVANCED IAS 
            // attribute 
            
            // -- add this SDO pointer to the profile SDO list
            spSdo.p->AddRef();
            m_vecProfileSdos.push_back(spSdo);
            
            // -- get attribute value
            IASTraceString("Getting attribute value...");

            CComVariant    varValue;

            hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_VALUE, &varValue); 
            if ( !SUCCEEDED(hr))
            {
               ShowErrorDialog(m_hWnd, 
                           IDS_IAS_ERR_SDOERROR_GETPROPERTY, 
                           _T(""), 
                           hr
                        );
               continue;
            }

            IASTraceString("Valid attribute ID! Creating a new attribute node...");

            IIASAttributeInfo *pAttributeInfo = m_pvecAllAttributeInfos->at(iIndex);
            _ASSERTE(pAttributeInfo);

            CIASProfileAttribute *pProfileAttribute = new CIASProfileAttribute( pAttributeInfo, varValue );
            if( ! pProfileAttribute )
            {
               hr = HRESULT_FROM_WIN32(GetLastError());
               ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADD_ATTR, _T(""), hr);
               continue;
            }
            
            // Add the newly created node to the list of attributes.
            try 
            {
               m_vecProfileAttributes.push_back(pProfileAttribute);
            }  
            catch(...)
            {
               hr = HRESULT_FROM_WIN32(GetLastError());

               IASTracePrintf("Can't add this attribuet node to profile attribute list,  err = %x", hr);
               ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADD_ATTR, _T(""), hr);
               delete pProfileAttribute;
               continue;
            };

         } // if

      } // if

      // ISSUE: Find out why Wei is compiling with atl10 only:    varAttributeSdo.Clear();
      VariantClear( &varAttributeSdo );

      // Get the next item.
      hr = spEnumVariant->Next( 1, &varAttributeSdo, &ulCountReceived );
      IASTracePrintf("Next() returned %x", hr);

      if ( !SUCCEEDED(hr))
      {
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_COLLECTION, _T(""), hr);
         return hr;
      }
   
   } // while

    // 
    // fill in the prof attribute list
    // 
   IASTraceString("We've got all the profile attributes, now updating the UI list");
   hr = UpdateProfAttrListCtrl();
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::UpdateProfAttrListCtrl
//
// Synopsis:  update the profile attribute list control
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao   2/23/98 12:19:11 AM
//
//+---------------------------------------------------------------------------
HRESULT CPgIASAdv::UpdateProfAttrListCtrl()
{
   LVITEM lvi;
   int iItem;

   // 
   // clear up the whole list first
   //
   m_listProfileAttributes.DeleteAllItems();

   // re populate the list again
   for (int iIndex = 0; iIndex < m_vecProfileAttributes.size(); iIndex++)
   {
      CComBSTR bstrName;
      CComBSTR bstrVendor;
      CComBSTR bstrDisplayValue;

      // Set the attribute name (the leftmost column).
      m_vecProfileAttributes[iIndex]->get_AttributeName( &bstrName );
      m_listProfileAttributes.InsertItem(iIndex, bstrName );

      // Set the subitems (the other columns).

      // Vendor and value of variant as a displayable string.
      m_vecProfileAttributes[iIndex]->GetDisplayInfo( &bstrVendor, &bstrDisplayValue );
      m_listProfileAttributes.SetItemText(iIndex, 1, bstrVendor );
      m_listProfileAttributes.SetItemText(iIndex, 2, bstrDisplayValue );
   }

   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  OnButtonIasAttributeAdd
//
// Class:     CPgIASAdv
//
// Synopsis:  User has clicked Add button -- pop up the attribute list
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 5:46:17 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::OnButtonIasAttributeAdd() 
{
   HRESULT hr = S_OK;

   CDlgIASAddAttr *pDlgAddAttr = new CDlgIASAddAttr( this, m_lAttrFilter, m_pvecAllAttributeInfos );

   if (!pDlgAddAttr)
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADVANCED, _T(""), hr);
      return;
   }

   pDlgAddAttr->SetSdo(m_spProfileAttributeCollectionSdo,
                  m_spDictionarySdo);
   
   if( pDlgAddAttr->DoModal() )
   {
      CPropertyPage::SetModified();
      m_bModified = TRUE;

   }  
}


/////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::EditProfileItemInList

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPgIASAdv::EditProfileItemInList( int iIndex )
{
   HRESULT hr = S_OK;

   // Get the specified node.
   CIASProfileAttribute* pProfAttr = m_vecProfileAttributes.at( iIndex );
   if( ! pProfAttr )
   {
      return E_FAIL;
   }
      
   // edit it!
   hr = pProfAttr->Edit();
   if( SUCCEEDED(hr) )
   {
      if (hr == S_FALSE)
      {
         if (pProfAttr->isEmpty())
         {
            // the attribute was deleted (is empty)
            deleteAttribute(iIndex);
         }
         else
         {
            // cancel was pressed
            return hr;
         }
      }
      else
      {
         // Update the UI.
         UpdateProfAttrListItem( iIndex );
      }
      
      CPropertyPage::SetModified();
      m_bModified = TRUE;

   }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::OnApply
//
// Synopsis:  User chose Apply or OK -- commit all changes
//
// Arguments: None
//
// Returns:   BOOL - succeed or not
//
// History:   Created Header    byao   2/23/98 11:09:05 PM
//
//+---------------------------------------------------------------------------
BOOL CPgIASAdv::OnApply() 
{
   HRESULT hr     = S_OK;
   int      iIndex;

   if( ! m_bModified )  
   {
      return TRUE;
   }

   // remove all Advanced attributes SDOs - to repopulate them.
   for (iIndex =0; iIndex<m_vecProfileSdos.size(); iIndex++)
   {
      if ( m_vecProfileSdos[iIndex] != NULL )
      {
         CComPtr<IDispatch> spDispatch;

         hr = m_vecProfileSdos[iIndex]->QueryInterface( IID_IDispatch, (void **) & spDispatch );
         _ASSERTE( SUCCEEDED( hr ) );

         hr = m_spProfileAttributeCollectionSdo->Remove(spDispatch);
         if ( !SUCCEEDED(hr) )
         {
            IASTracePrintf("Remove() failed, err = %x", hr);
            ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_COLLECTION, _T(""),hr);
         }
         m_vecProfileSdos[iIndex]->Release();
         m_vecProfileSdos[iIndex] = NULL;
      }
   }
   m_vecProfileSdos.clear();

   // repopulate the prof-attribute list
   for (iIndex=0; iIndex<m_vecProfileAttributes.size(); iIndex++)
   {

      // create the SDO for this attribute
      CComPtr<IDispatch>   spDispatch;

      spDispatch.p = NULL;

      ATTRIBUTEID ID;

      hr = m_vecProfileAttributes[iIndex]->get_AttributeID( &ID );
      if( FAILED(hr) )
      {
         IASTracePrintf("get_AttributeID() failed, err = %x", hr);
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_CREATEATTR,_T(""), hr);
         continue;
      }

      hr =  m_spDictionarySdo->CreateAttribute( ID, 
                                      (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         IASTracePrintf("CreateAttrbute() failed, err = %x", hr);
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_CREATEATTR,_T(""), hr);
         continue; // go to the next attribute
      }

      _ASSERTE( spDispatch.p != NULL );

      // add this node to profile attribute collection
      hr = m_spProfileAttributeCollectionSdo->Add(NULL, (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         IASTracePrintf("Add() failed, err = %x", hr);
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_CREATEATTR, _T("Add"),hr);
         continue; // go to the next attribute
      }

      // 
      // get the ISdo pointer
      // 
      CComPtr<ISdo> spAttrSdo;
      hr = spDispatch->QueryInterface( IID_ISdo, (void **) &spAttrSdo);
      if (   !SUCCEEDED(hr) )
      {
         IASTracePrintf("QueryInterface() failed, err = %x", hr);
         ShowErrorDialog(m_hWnd,IDS_IAS_ERR_SDOERROR_QUERYINTERFACE,_T(""),hr);
         continue; // go on to the next attribute
      }

      _ASSERTE( spAttrSdo != NULL );
            
      IASTraceString("Created an attribute successfully! Now setting the properties...");

      // set sdo property for this attribute
      CComVariant varValue;

      m_vecProfileAttributes[iIndex]->get_VarValue( &varValue );

      // set value
      IASTraceString("Set value");

      hr = spAttrSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &varValue );

      if ( !SUCCEEDED(hr) )
      {
         IASTracePrintf("PutProperty(value) failed, err = %x", hr);

         CComBSTR bstrTemp;
         m_vecProfileAttributes[iIndex]->get_AttributeName( &bstrTemp );         
         
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_PUTPROPERTY_ATTRIBUTE_VALUE, bstrTemp, hr );
         continue; // go on to the next attribute
      }

      // commit
      hr = spAttrSdo->Apply();
      if ( !SUCCEEDED(hr) )
      {
         IASTracePrintf("Apply() failed, err = %x", hr);
         ShowErrorDialog(m_hWnd, IDS_IAS_ERR_SDOERROR_APPLY, _T(""),hr);
         continue; // go on to the next attribute
      }

      // -- add this SDO pointer to the profile SDO list
      // we must AddRef() first for this SDO pointer because we are to copy it to
      // the array. We don't want the SDO object be released with spAttrSdo;
      spAttrSdo.p->AddRef();
      m_vecProfileSdos.push_back(spAttrSdo);

   } // for

   IASTraceString("Done with this profile !");
   return CPropertyPage::OnApply();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::OnHelpInfo

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPgIASAdv::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   return CManagedPage::OnHelpInfo(pHelpInfo);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::OnContextMenu

--*/
//////////////////////////////////////////////////////////////////////////////
void CPgIASAdv::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   CManagedPage::OnContextMenu(pWnd, point);
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::OnButtonIasAttributeEdit
//
// Synopsis:  edit the currectly selected attribute
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    byao   2/25/98 8:03:38 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::OnButtonIasAttributeEdit() 
{
   HRESULT hr = S_OK;
   
   // 
   // see if there is an item already selected in ProfAttr list
   // 
   int iSelected = GetSelectedItemIndex( m_listProfileAttributes );
   if (NOTHING_SELECTED == iSelected )
   {
      // do nothing
      return;
   }
   EditProfileItemInList( iSelected );
}


void CPgIASAdv::deleteAttribute(int nIndex)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
  if (NOTHING_SELECTED == nIndex )
   {
      // do nothing
      return;
   }
   //
   // get the current node
   //
   CIASProfileAttribute* pProfAttr = m_vecProfileAttributes.at(nIndex);
   _ASSERTE( pProfAttr != NULL );

   // delete the attribute node
   m_vecProfileAttributes.erase( m_vecProfileAttributes.begin() + nIndex);
   delete pProfAttr;

   CPropertyPage::SetModified();
   m_bModified = TRUE;

   // Update the UI.

   // for some reason, the focus is lost within the following, so save it, and restore it later
   HWND  hWnd = ::GetFocus();

   m_listProfileAttributes.DeleteItem(nIndex);

   // Make sure the selection stays on the same position in the list.
   if( ! m_listProfileAttributes.SetItemState( nIndex, LVIS_SELECTED, LVIS_SELECTED) )
   {
      // We failed, probably because the item that was deleted was the last
      // in the list, so try to select the one before the deleted item.
      if (nIndex > 0)
         m_listProfileAttributes.SetItemState( nIndex -1, LVIS_SELECTED, LVIS_SELECTED);
   }

   // restore the focus
   ::SetFocus(hWnd);

   UpdateButtonState();
 
}

//+---------------------------------------------------------------------------
//
// Function:  OnButtonIasAttributeRemove
//
// Class:     CPgIASAdv
//
// Synopsis:  The user has clicked the "Remove" button. Remove an attribute from 
//         the profile
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 3:01:14 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::OnButtonIasAttributeRemove() 
{
   HRESULT hr;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   // 
    // see if there is an item already selected in ProfAttr list
    // 
   int iSelected = GetSelectedItemIndex( m_listProfileAttributes );
   deleteAttribute(iSelected);
}


//+---------------------------------------------------------------------------
//
// Function:  UpdateButtonState
//
// Class:     CPgIASAdv
//
// Synopsis:  Enable/Disable Edit/Remove/Up/Down/Add buttons
//
// Returns:   Nothing
//
// History:   Created byao 4/7/98 3:32:05 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::UpdateButtonState() 
{
   // Set button states depending on whether anything is selected.
   int iSelected = GetSelectedItemIndex( m_listProfileAttributes );
   if (NOTHING_SELECTED == iSelected )
   {
      HWND hFocus = ::GetFocus();

      // move focus
      if(hFocus == GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_REMOVE)->m_hWnd)
         ::SetFocus(GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_ADD)->m_hWnd);

      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_REMOVE)->EnableWindow(FALSE);
      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_EDIT)->EnableWindow(FALSE);
   }
   else
   {
      // Something is selected.

      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_REMOVE)->EnableWindow(TRUE);
      GetDlgItem(IDC_IAS_BUTTON_ATTRIBUTE_EDIT)->EnableWindow(TRUE);
   }
}


//+---------------------------------------------------------------------------
//
// Function:  OnItemChangedListIasProfileAttributes
//
// Class:     CPgIASAdv
//
// Synopsis:  something has changed in Profile Attribute list box
//         We'll try to get the currently selected one
//
// Arguments: NMHDR* pNMHDR - 
//            LRESULT* pResult - 
//
// Returns:   Nothing
//
// History:   Created Header    2/19/98 3:32:05 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::OnItemChangedListIasProfileAttributes(NMHDR* pNMHDR, LRESULT* pResult) 
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   UpdateButtonState();
   *pResult = 0;
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::UpdateProfAttrListItem
//
// Synopsis:  update the No.nItem of the profile attribute list ctrl 
//
// Arguments: int nItem - index of the item to update
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao   2/23/98 2:46:21 PM
//
//+---------------------------------------------------------------------------
HRESULT CPgIASAdv::UpdateProfAttrListItem(int nItem)
{
   // 
   // update the profattrlist
   // 
   LVITEM lvi;
   WCHAR wszItemText[MAX_PATH];

   lvi.mask = LVIF_TEXT | LVIF_STATE;
   lvi.state = 0;
   lvi.stateMask = 0;
   lvi.iSubItem = 0;
      
   lvi.iItem = nItem;

   CComBSTR bstrName;
   CComBSTR bstrVendor;
   CComBSTR bstrDisplayValue;

   // Attribute name.
   m_vecProfileAttributes.at(nItem)->get_AttributeName( &bstrName );
   lvi.pszText = bstrName;
   if (m_listProfileAttributes.SetItem(&lvi) == -1)
   {
      return E_FAIL;
   }

   // Vendor and value of variant as a displayable string.
   m_vecProfileAttributes.at(nItem)->GetDisplayInfo( &bstrVendor, &bstrDisplayValue );
   m_listProfileAttributes.SetItemText(nItem,1, bstrVendor );
   m_listProfileAttributes.SetItemText(nItem,2, bstrDisplayValue );

   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::InsertProfileAttributeListItem
//
// Synopsis:  insert the No.nItem of the profile attribute to the list ctrl 
//
// Arguments: int nItem - index of the item to update
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao   2/23/98 2:46:21 PM
//
//+---------------------------------------------------------------------------
HRESULT CPgIASAdv::InsertProfileAttributeListItem(int nItem)
{
   // 
   // update the profattrlist
   // 
   LVITEM lvi;

   lvi.mask = LVIF_TEXT | LVIF_STATE;
   lvi.state = 0;
   lvi.stateMask = 0;
   lvi.iSubItem = 0;
      
   lvi.iItem = nItem;

   CComBSTR bstrName;
   CComBSTR bstrVendor;
   CComBSTR bstrDisplayValue;

   m_vecProfileAttributes.at(nItem)->get_AttributeName( &bstrName );
   lvi.pszText = bstrName;
   if (m_listProfileAttributes.InsertItem(&lvi) == -1)
   {
      return E_FAIL;
   }

   // Vendor and value of variant as a displayable string.
   m_vecProfileAttributes.at(nItem)->GetDisplayInfo( &bstrVendor, &bstrDisplayValue );
   m_listProfileAttributes.SetItemText(nItem,1, bstrVendor );
   m_listProfileAttributes.SetItemText(nItem,2, bstrDisplayValue );

   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  CPgIASAdv::OnDblclkListIasProfattrs
//
// Synopsis:  user has double clicked on the profile attribute list
//         We need to edit the attribute value using corresponding UI
//
// Arguments: NMHDR* pNMHDR - 
//            LRESULT* pResult - 
//
// Returns:   Nothing
//
// History:   Created Header  byao  2/23/98 5:56:36 PM
//
//+---------------------------------------------------------------------------
void CPgIASAdv::OnDblclkListIasProfattrs(NMHDR* pNMHDR, LRESULT* pResult) 
{
   HRESULT hr = S_OK;

   // 
   // see if there is an item already selected in ProfAttr list
   // 
   int iSelected = GetSelectedItemIndex( m_listProfileAttributes );
   if (NOTHING_SELECTED == iSelected)
   {
      // do nothing
      return;
   }
   
   EditProfileItemInList( iSelected );
   
   *pResult = 0;

}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::AddAttributeToProfile

iItem is the ordinal in m_vecAllAttributeInfos of the attribute to add 
to m_vecProfileAttributes.


Called by external customers of this class, checks to see whether an
attribute at position iItem in m_vecAllAttributeInfos is already in
the profile.  If it is, gives the option to edit it.  If it isn't, 
then calls InternalAddAttributeToProfile, which adds it.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPgIASAdv::AddAttributeToProfile( HWND hWnd, int iItem )
{
   HRESULT hr;
   ATTRIBUTEID ID1;
   hr = m_pvecAllAttributeInfos->at( iItem )->get_AttributeID( &ID1 );
   _ASSERTE( SUCCEEDED( hr ) );
   
    // Check  if this attribute already in the profile.
   for( int iIndex=0; iIndex< m_vecProfileAttributes.size(); iIndex++ )
   {

      ATTRIBUTEID ID2;
      hr = m_vecProfileAttributes.at(iIndex)->get_AttributeID( &ID2 );
      _ASSERTE( SUCCEEDED( hr ) );

      if ( ID1 == ID2 )
      {
         // The selected attribute is already in the profile.
         // Ask the user if they want to edit it.
         
         CString strMessage; 
         strMessage.LoadString(IDS_IAS_ATTRIBUTE_ALREADY_IN_PROFILE);

         CString strTitle; 
         strTitle.LoadString(IDS_IAS_TITLE_ATTRIBUTE_ALREADY_IN_PROFILE);
         
         int iResult = ::MessageBox(hWnd, strMessage, strTitle, MB_YESNO);
         if( iResult == IDYES )
         {
            // Edit the existing profile
            EditProfileItemInList( iIndex );
         }

         // In any case, don't continue with this function.
         return S_FALSE;
      }
   }
   
   // Now we create this attribute, and add it to profile.
   hr = InternalAddAttributeToProfile( iItem );
   
   if ( FAILED(hr) )
   {
      ShowErrorDialog(m_hWnd, IDS_IAS_ERR_ADD_ATTR, _T(""), hr);
      return hr;
   }
   
   // The use may have cancelled out, so don't need to update.
   if( S_OK == hr )
   {
      UpdateButtonState();
      UpdateProfAttrListCtrl();

   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPgIASAdv::InternalAddAttributeToProfile

iItem is the ordinal in m_vecAllAttributeInfos of the attribute to add 
to m_vecProfileAttributes.


Private to this class.  Used to add a new attribute to a profile 
and edit it.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPgIASAdv::InternalAddAttributeToProfile(int nIndex)
{  
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   _ASSERTE( 0<=nIndex && nIndex < m_pvecAllAttributeInfos->size() );
   _ASSERTE( m_pvecAllAttributeInfos->at(nIndex) != NULL );

   HRESULT hr = S_OK;


   // Get the "schema" of the new attributevendor to create.
   IIASAttributeInfo *pAttributeInfo = m_pvecAllAttributeInfos->at(nIndex);
   

   // Create a new attribute, initialized with an empty variant.
   CComVariant varValue;
   CIASProfileAttribute *pProfileAttribute = new CIASProfileAttribute( pAttributeInfo, varValue );
   if( ! pProfileAttribute )
   {
      hr = E_OUTOFMEMORY;
      ReportError(hr, IDS_OUTOFMEMORY, NULL);
      return hr;
   }


   // Edit the value of this profile attribute node.
   hr = pProfileAttribute->Edit();
   if ( hr != S_OK ) 
   {
      // The user hit cancel or there was an error -- don't add.
      return hr;
   }


    // 
    // add this prof attribute node to the list
    // 
   try 
   {
      m_vecProfileAttributes.push_back(pProfileAttribute);  
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      hr = E_OUTOFMEMORY;
      ReportError(hr, IDS_OUTOFMEMORY, NULL);
      return hr;
   }

   
    // Update the UI.
   HRESULT InsertProfileAttributeListItem( m_listProfileAttributes.GetItemCount() );
   
   return S_OK;
}


void CPgIASAdv::OnKeydownIasListAttributesInProfile(NMHDR* pNMHDR, LRESULT* pResult) 
{
   LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
   // TODO: Add your control notification handler code here

   if (pLVKeyDow->wVKey == VK_DELETE)
   {
      // delete the item
      OnButtonIasAttributeRemove();
   }
   
   *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgencryp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation,               **/
/**********************************************************************/

/*
   pgencryp.cpp
      Definition of CPgEncryption -- property page to edit
      profile attributes related to encryption

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "resource.h"
#include "PgEncryp.h"
#include "helptable.h"
#include "profsht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgEncryptionMerge property page

IMPLEMENT_DYNCREATE(CPgEncryptionMerge, CPropertyPage)

#define NO_OLD_ET_VALUE

CPgEncryptionMerge::CPgEncryptionMerge(CRASProfileMerge* profile) 
   : CManagedPage(CPgEncryptionMerge::IDD),
   m_pProfile(profile)
{
   //{{AFX_DATA_INIT(CPgEncryptionMerge)
   m_bBasic = FALSE;
   m_bNone = FALSE;
   m_bStrong = FALSE;
   m_bStrongest = FALSE;
   //}}AFX_DATA_INIT

   m_b128EnabledOnTheMachine = FALSE;

   // default case --- allow everything
   if (((m_pProfile->m_dwAttributeFlags & PABF_msRASAllowEncryption) == 0)
      && ((m_pProfile->m_dwAttributeFlags & PABF_msRASEncryptionType) == 0))
   {
      m_bBasic = TRUE;
      m_bNone = TRUE;
      m_bStrong = TRUE;
      m_bStrongest = TRUE;
   }
   else if (((m_pProfile->m_dwAttributeFlags & PABF_msRASAllowEncryption) != 0)
         && ((m_pProfile->m_dwAttributeFlags & PABF_msRASEncryptionType) != 0))
   {
   
      if (m_pProfile->m_dwEncryptionPolicy == RAS_EP_ALLOW)
         m_bNone = TRUE;   // allow means None is OK

      m_bStrong = ((m_pProfile->m_dwEncryptionType & RAS_ET_STRONG ) != 0);
      m_bBasic = ((m_pProfile->m_dwEncryptionType & RAS_ET_BASIC ) != 0);
      m_bStrongest = ((m_pProfile->m_dwEncryptionType & RAS_ET_STRONGEST ) != 0);
   }
   
   SetHelpTable(g_aHelpIDs_IDD_ENCRYPTION_MERGE);
}

CPgEncryptionMerge::~CPgEncryptionMerge()
{
}

void CPgEncryptionMerge::DoDataExchange(CDataExchange* pDX)
{
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgEncryptionMerge)
   DDX_Check(pDX, IDC_CHECK_ENC_BASIC, m_bBasic);
   DDX_Check(pDX, IDC_CHECK_ENC_NONE, m_bNone);
   DDX_Check(pDX, IDC_CHECK_ENC_STRONG, m_bStrong);
   DDX_Check(pDX, IDC_CHECK_ENC_STRONGEST, m_bStrongest);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPgEncryptionMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CPgEncryptionMerge)
   ON_WM_HELPINFO()
   ON_WM_CONTEXTMENU()
   ON_BN_CLICKED(IDC_CHECK_ENC_BASIC, OnCheckEncBasic)
   ON_BN_CLICKED(IDC_CHECK_ENC_NONE, OnCheckEncNone)
   ON_BN_CLICKED(IDC_CHECK_ENC_STRONG, OnCheckEncStrong)
   ON_BN_CLICKED(IDC_CHECK_ENC_STRONGEST, OnCheckEncStrongest)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgEncryption message handlers

BOOL CPgEncryptionMerge::OnKillActive() 
{
   UpdateData();

   // at least one should be
   if(!(m_bNone || m_bBasic || m_bStrong || m_bStrongest))
   {
      AfxMessageBox(IDS_DATAENTRY_ENCRYPTIONTYPE);
      return FALSE;
   }

   return CPropertyPage::OnKillActive();
}

BOOL CPgEncryptionMerge::OnApply() 
{
   if (!GetModified())  return TRUE;

   // default case -- allow anything, -- remove the attributes
   if (m_bNone && m_bBasic && m_bStrong && m_bStrongest)
   {
      // remove both attributes
      m_pProfile->m_dwAttributeFlags &= (~PABF_msRASAllowEncryption);
      m_pProfile->m_dwAttributeFlags &= (~PABF_msRASEncryptionType);
   }
   else
   {
      // policy
      if (m_bNone)
         m_pProfile->m_dwEncryptionPolicy = RAS_EP_ALLOW;
      else     
         m_pProfile->m_dwEncryptionPolicy = RAS_EP_REQUIRE;
         
      // type
      m_pProfile->m_dwEncryptionType = 0;
      if (m_bBasic)
         m_pProfile->m_dwEncryptionType |= RAS_ET_BASIC;

      if (m_bStrong)
         m_pProfile->m_dwEncryptionType |= RAS_ET_STRONG;

      if (m_bStrongest)
         m_pProfile->m_dwEncryptionType |= RAS_ET_STRONGEST;

      // at least one must be selected
      if (m_pProfile->m_dwEncryptionType == 0 && m_pProfile->m_dwEncryptionPolicy == RAS_EP_REQUIRE)
      {
         AfxMessageBox(IDS_DATAENTRY_ENCRYPTIONTYPE);
         return FALSE;
      }
      
      // set the flags
      m_pProfile->m_dwAttributeFlags |= PABF_msRASAllowEncryption;
      m_pProfile->m_dwAttributeFlags |= PABF_msRASEncryptionType;
   }

   return CManagedPage::OnApply();
}

BOOL CPgEncryptionMerge::OnInitDialog() 
{
   // always true for IAS
   m_b128EnabledOnTheMachine = TRUE;

   CPropertyPage::OnInitDialog();

   CProfileSheetMerge* pSheet = dynamic_cast<CProfileSheetMerge*>(GetManager());

   if (pSheet && (pSheet->m_dwTabFlags & RAS_IAS_PROFILEDLG_SHOW_RASTABS))
   {
      // if 128 bit is enabled
      RAS_NDISWAN_DRIVER_INFO Info;

      ZeroMemory(&Info, sizeof(RAS_NDISWAN_DRIVER_INFO));
      m_pProfile->GetRasNdiswanDriverCaps(&Info);
      if (Info.DriverCaps & RAS_NDISWAN_128BIT_ENABLED)
         m_b128EnabledOnTheMachine = TRUE;
      else
         m_b128EnabledOnTheMachine = FALSE;

      if(m_b128EnabledOnTheMachine)
         GetDlgItem(IDC_CHECK_ENC_STRONGEST)->ShowWindow(SW_SHOW);
      else
         GetDlgItem(IDC_CHECK_ENC_STRONGEST)->ShowWindow(SW_HIDE);
   }
   
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPgEncryptionMerge::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   // TODO: Add your message handler code here and/or call default
   
   return CManagedPage::OnHelpInfo(pHelpInfo);
}

void CPgEncryptionMerge::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   CManagedPage::OnContextMenu(pWnd, point); 
}

BOOL CPgEncryptionMerge::OnSetActive() 
{
   return CPropertyPage::OnSetActive();
}

void CPgEncryptionMerge::OnCheckEncBasic() 
{
   // TODO: Add your control notification handler code here
   SetModified();
   
}

void CPgEncryptionMerge::OnCheckEncNone() 
{
   // TODO: Add your control notification handler code here
   SetModified();
   
}

void CPgEncryptionMerge::OnCheckEncStrong() 
{
   // TODO: Add your control notification handler code here
   SetModified();
   
}

void CPgEncryptionMerge::OnCheckEncStrongest() 
{
   // TODO: Add your control notification handler code here
   SetModified();
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgconst.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	pgconst.h
		Definition of CPgConstraints -- property page to edit
		profile attributes related to constraints

    FILE HISTORY:
        
*/
#if !defined(AFX_PGCONST_H__8C28D93C_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PGCONST_H__8C28D93C_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgConst.h : header file
//
#include "rasdial.h"
#include "resource.h"
#include "listctrl.h"
#include "timeofday.h"

// hour map is an array of bit, each bit maps to a hour
// total 1 week(7 days), 7 * 24 = 21 BYTES
void StrArrayToHourMap(CStrArray& array, BYTE* map);
void HourMapToStrArray(BYTE* map, CStrArray& array, BOOL bLocalized); 

/////////////////////////////////////////////////////////////////////////////
// CPgConstraintsMerge dialog

class CPgConstraintsMerge : public CManagedPage
{
	DECLARE_DYNCREATE(CPgConstraintsMerge)

// Construction
public:
	void EnableSettings();
	CPgConstraintsMerge(CRASProfileMerge* profile = NULL);
	~CPgConstraintsMerge();

// Dialog Data
	//{{AFX_DATA(CPgConstraintsMerge)
	enum { IDD = IDD_CONSTRAINTS_MERGE };
	CButton	m_CheckPortTypes;
	CListCtrlEx		m_listPortTypes;
	CButton	m_CheckSessionLen;
	CButton	m_CheckIdle;
	CButton	m_ButtonEditTimeOfDay;
	CListBox	m_ListTimeOfDay;
	CSpinButtonCtrl	m_SpinMaxSession;
	CSpinButtonCtrl	m_SpinIdleTime;
	CEdit	m_EditMaxSession;
	CEdit	m_EditIdleTime;
	BOOL	m_bCallNumber;
	BOOL	m_bRestrictedToPeriod;
	UINT	m_dwMaxSession;
	UINT	m_dwIdle;
	CString	m_strCalledNumber;
	BOOL	m_bIdle;
	BOOL	m_bSessionLen;
	UINT	m_dwMaxSession1;
	BOOL	m_bPortTypes;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgConstraintsMerge)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnableIdleSettings(BOOL bEnable);
	void EnableSessionSettings(BOOL bEnable);
	void EnableTimeOfDay(BOOL bEnable);
	void EnableMediaSelection(BOOL bEnable);
	void EnableCalledStation(BOOL bEnable);
	// Generated message map functions
	//{{AFX_MSG(CPgConstraintsMerge)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditmaxsession();
	afx_msg void OnChangeEditidletime();
	afx_msg void OnCheckcallnumber();
	afx_msg void OnCheckrestrictperiod();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnButtonedittimeofday();
	afx_msg void OnChangeEditcallnumber();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnCheckidle();
	afx_msg void OnChecksessionlen();
	afx_msg void OnCheckPorttypes();
	afx_msg void OnItemclickListPorttypes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CRASProfileMerge*	m_pProfile;
	bool			m_bInited;
	
	// the hour map timeofday
	BYTE			m_TimeOfDayHoursMap[21];
	// the data array to store the time -- localized
	CStrArray		m_strArrayTimeOfDayDisplay;
	
	CStrBox<CListBox>*	m_pBox;

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGCONST_H__8C28D93C_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgencryp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	pgencryp.h
		Definition of CPgEncryption -- property page to edit
		profile attributes related to encryption

    FILE HISTORY:
        
*/
#if !defined(AFX_PGECRPT1_H__5CE41DC7_2EC5_11D1_853F_00C04FC31FD3__INCLUDED_)
#define AFX_PGECRPT1_H__5CE41DC7_2EC5_11D1_853F_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgEcrpt1.h : header file
//

#include "rasdial.h"

/////////////////////////////////////////////////////////////////////////////
// CPgEncryptionMerge dialog

class CPgEncryptionMerge : public CManagedPage
{
	DECLARE_DYNCREATE(CPgEncryptionMerge)

// Construction
public:
	CPgEncryptionMerge(CRASProfileMerge* profile = NULL);
	~CPgEncryptionMerge();

// Dialog Data
	//{{AFX_DATA(CPgEncryptionMerge)
	enum { IDD = IDD_ENCRYPTION_MERGE };
	BOOL	m_bBasic;
	BOOL	m_bNone;
	BOOL	m_bStrong;
	BOOL	m_bStrongest;
	//}}AFX_DATA

	BOOL	m_b128EnabledOnTheMachine;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgEncryptionMerge)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnableType(BOOL bEnable);
	// Generated message map functions
	//{{AFX_MSG(CPgEncryptionMerge)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSelchangeComboencrypttype();
	afx_msg void OnCheckEncBasic();
	afx_msg void OnCheckEncNone();
	afx_msg void OnCheckEncStrong();
	afx_msg void OnCheckEncStrongest();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CRASProfileMerge*	m_pProfile;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGECRPT1_H__5CE41DC7_2EC5_11D1_853F_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgiasadv.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

   PgIASAdv.h

Abstract:

   Header file for the CPgIASAdv class.

   See PgIASAdv.cpp for implementation.

Revision History:
   byao - created
   mmaguire 06/01/98 - revamped


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_ADVANCED_PAGE_H_)
#define _IAS_ADVANCED_PAGE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "helper.h"
//
//
// where we can find what this class has or uses:
//
#include <vector>
#include "napmmc.h"
#include "IASProfA.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#define ATTRIBUTE_NAME_COLUMN_WIDTH         140
#define ATTRIBUTE_VENDOR_COLUMN_WIDTH      100
#define ATTRIBUTE_VALUE_COLUMN_WIDTH      400
#define ATTRIBUTE_DESCRIPTION_COLUMN_WIDTH      400




/////////////////////////////////////////////////////////////////////////////
// CPgIASAdv dialog

class CPgIASAdv : public CManagedPage
{
   DECLARE_DYNCREATE(CPgIASAdv)

// Construction
public:
   CPgIASAdv(ISdo* pIProfile = NULL, ISdoDictionaryOld* pIDictionary = NULL);
   ~CPgIASAdv();

   HRESULT InitProfAttrList();

   STDMETHOD(AddAttributeToProfile)(HWND hWnd, int nIndex);

   void SetData(LONG lFilter, void* pvData)
   {
      m_lAttrFilter = lFilter;
      try {
         m_pvecAllAttributeInfos = ( std::vector< CComPtr<IIASAttributeInfo> > * ) pvData;
      }
      catch (...)
      {
         m_pvecAllAttributeInfos = NULL;
      }
   };


// Dialog Data
   //{{AFX_DATA(CPgIASAdv)
   enum { IDD = IDD_IAS_ADVANCED_TAB };
   CListCtrl   m_listProfileAttributes;
   //}}AFX_DATA


// Overrides
   // ClassWizard generate virtual function overrides
   //{{AFX_VIRTUAL(CPgIASAdv)
   public:
   virtual BOOL OnApply();
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   HRESULT UpdateProfAttrListCtrl();
   STDMETHOD(EditProfileItemInList)( int iIndex );
   HRESULT UpdateProfAttrListItem(int nItem);
   void   UpdateButtonState();
   HRESULT InsertProfileAttributeListItem(int nItem);
   STDMETHOD(InternalAddAttributeToProfile)(int nIndex);
   void deleteAttribute(int nIndex);


   //
   // protected member variables
   //
   CComPtr<ISdo> m_spProfileSdo;
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;
   CComPtr<ISdoCollection> m_spProfileAttributeCollectionSdo;

   // pointer to the all array list
   std::vector< CComPtr<IIASAttributeInfo> > * m_pvecAllAttributeInfos;

   std::vector< CIASProfileAttribute* >      m_vecProfileAttributes;

   // list of existing profile SDOs -- we need to delete exising ones first
   // before saving the new ones
   std::vector< ISdo* >                  m_vecProfileSdos;

   LONG   m_lAttrFilter;

   // Generated message map functions
   //{{AFX_MSG(CPgIASAdv)
   virtual BOOL OnInitDialog();
   afx_msg void OnButtonIasAttributeAdd();
   afx_msg void OnButtonIasAttributeRemove();
   afx_msg void OnButtonIasAttributeEdit();
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg void OnDblclkListIasProfattrs(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnItemChangedListIasProfileAttributes(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnKeydownIasListAttributesInProfile(NMHDR* pNMHDR, LRESULT* pResult);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()


private:
   BOOL m_fAllAttrInitialized;  // has the attribute list been initialized?

};






//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _IAS_ADVANCED_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgmulnk.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
	pgmulnk.cpp
		Definition of CPgMultilink -- property page to edit
		profile attributes related to multiple connections

    FILE HISTORY:
        
*/
// PgMulnk.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PgMulnk.h"
#include "helptable.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgMultilinkMerge property page

IMPLEMENT_DYNCREATE(CPgMultilinkMerge, CPropertyPage)

CPgMultilinkMerge::CPgMultilinkMerge(CRASProfileMerge* profile) 
	: CManagedPage(CPgMultilinkMerge::IDD),
	m_pProfile(profile)
{
	//{{AFX_DATA_INIT(CPgMultilinkMerge)
	m_nTime =	0;
	m_Unit = -1;
	m_bRequireBAP = FALSE;
	m_nMultilinkPolicy = -1;
	//}}AFX_DATA_INIT

	if(m_pProfile->m_dwBapRequired == RAS_BAP_REQUIRE)
		m_bRequireBAP = TRUE;


	m_nTime = m_pProfile->m_dwBapLineDnTime;
	if(!(m_nTime % 60))		// can user min to represent
	{
		m_nTime /= 60;
		m_Unit = 1;
	}
	else
		m_Unit = 0;

	if(!(m_pProfile->m_dwAttributeFlags & PABF_msRADIUSPortLimit))
	{
		m_nMultilinkPolicy = 0;		// value not set
	}
	else if(m_pProfile->m_dwPortLimit == 1)
	{
		m_nMultilinkPolicy = 1;		// multilink not allowed
	}
	else
	{
		m_nMultilinkPolicy = 2;		// multilink
	}

	SetHelpTable(g_aHelpIDs_IDD_MULTILINK_MERGE);

	m_bInited = false;

}

CPgMultilinkMerge::~CPgMultilinkMerge()
{
}

void CPgMultilinkMerge::DoDataExchange(CDataExchange* pDX)
{
	ASSERT(m_pProfile);
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgMultilinkMerge)
	DDX_Control(pDX, IDC_CHECKREQUIREBAP, m_CheckRequireBAP);
	DDX_Control(pDX, IDC_EDITTIME, m_EditTime);
	DDX_Control(pDX, IDC_EDITMAXPORTS, m_EditPorts);
	DDX_Control(pDX, IDC_EDITPERCENT, m_EditPercent);
	DDX_Control(pDX, IDC_SPINTIME, m_SpinTime);
	DDX_Control(pDX, IDC_SPINPERCENT, m_SpinPercent);
	DDX_Control(pDX, IDC_SPINMAXPORTS, m_SpinMaxPorts);
	DDX_Control(pDX, IDC_COMBOUNIT, m_CBUnit);
	DDX_CBIndex(pDX, IDC_COMBOUNIT, m_Unit);
	DDX_Check(pDX, IDC_CHECKREQUIREBAP, m_bRequireBAP);
	DDX_Radio(pDX, IDC_RADIO_MULNK_NOTDEFINED, m_nMultilinkPolicy);
	DDX_Text(pDX, IDC_EDITTIME, m_nTime);
	if(m_nMultilinkPolicy != 1)
		DDV_MinMaxUInt(pDX, m_nTime, 1, MAX_TIME);
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_EDITPERCENT, m_pProfile->m_dwBapLineDnLimit);
	if(m_nMultilinkPolicy != 1)
		DDV_MinMaxUInt(pDX, m_pProfile->m_dwBapLineDnLimit, 1, 100);
	DDX_Text(pDX, IDC_EDITMAXPORTS, m_pProfile->m_dwPortLimit);
	if(m_nMultilinkPolicy == 2)
		DDV_MinMaxUInt(pDX, m_pProfile->m_dwPortLimit, 2, MAX_PORTLIMIT);
}


BEGIN_MESSAGE_MAP(CPgMultilinkMerge, CPropertyPage)
	//{{AFX_MSG_MAP(CPgMultilinkMerge)
	ON_EN_CHANGE(IDC_EDITMAXPORTS, OnChangeEditmaxports)
	ON_EN_CHANGE(IDC_EDITPERCENT, OnChangeEditpercent)
	ON_EN_CHANGE(IDC_EDITTIME, OnChangeEdittime)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_CBN_SELCHANGE(IDC_COMBOUNIT, OnSelchangeCombounit)
	ON_BN_CLICKED(IDC_CHECKREQUIREBAP, OnCheckrequirebap)
	ON_BN_CLICKED(IDC_RADIO_MULNK_MULTI, OnRadioMulnkMulti)
	ON_BN_CLICKED(IDC_RADIO_MULNK_NOTDEFINED, OnRadioMulnkNotdefined)
	ON_BN_CLICKED(IDC_RADIO_MULNK_SINGLE, OnRadioMulnkSingle)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgMultilinkMerge message handlers

BOOL CPgMultilinkMerge::OnApply() 
{
	if(!GetModified())	return TRUE;

	// # of ports
	switch (m_nMultilinkPolicy)
	{
	case	0:	// remove attribute
		m_pProfile->m_dwAttributeFlags &= (~PABF_msRADIUSPortLimit);
		break;
	case	1:	// 1
		m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSPortLimit;
		m_pProfile->m_dwPortLimit = 1;
		break;
	case	2:	// port limits
		m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSPortLimit;
		break;
	};
	
	if(m_nMultilinkPolicy == 1) // single link
	// remove all the bap attributes
	{
		m_pProfile->m_dwAttributeFlags &= ~PABF_msRASBapRequired;
		m_pProfile->m_dwAttributeFlags &= ~PABF_msRASBapLinednLimit;
		m_pProfile->m_dwAttributeFlags &= ~PABF_msRASBapLinednTime;
	}
	else
	{
		m_pProfile->m_dwAttributeFlags |= PABF_msRASBapLinednLimit;
		m_pProfile->m_dwAttributeFlags |= PABF_msRASBapLinednTime;

		if(m_Unit == 1)	// minutes is selected as the unit
			m_pProfile->m_dwBapLineDnTime = m_nTime * 60;	// change to second
		else
			m_pProfile->m_dwBapLineDnTime = m_nTime;

		if(m_bRequireBAP)
		{
			m_pProfile->m_dwAttributeFlags |= PABF_msRASBapRequired;
			m_pProfile->m_dwBapRequired = RAS_BAP_REQUIRE;
		}
		else	// remove the attribute from the data store
		{
			m_pProfile->m_dwAttributeFlags &= (~PABF_msRASBapRequired);
			m_pProfile->m_dwBapRequired = RAS_DEF_BAPREQUIRED;
		}
	}

	return CManagedPage::OnApply();
}

BOOL CPgMultilinkMerge::OnInitDialog() 
{
	// populate the units
	CString	str;
	CPropertyPage::OnInitDialog();

	str.LoadString(IDS_SEC);
	m_CBUnit.InsertString(0, str);
	str.LoadString(IDS_MIN);
	m_CBUnit.InsertString(1, str);

	UpdateData(FALSE);
	
	// set spin range
	m_SpinMaxPorts.SetRange(2, MAX_PORTLIMIT);
	m_SpinPercent.SetRange(1, MAX_PERCENT);
	m_SpinTime.SetRange(1, MAX_TIME);

	// settings -- d
	EnableSettings();

	m_bInited = true;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgMultilinkMerge::OnChangeEditmaxports() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	if (m_bInited)
	{
		SetModified();
		m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSPortLimit;
	};
}

void CPgMultilinkMerge::OnChangeEditpercent() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	
	if (m_bInited)
	{
		SetModified();
		m_pProfile->m_dwAttributeFlags |= PABF_msRASBapLinednLimit;
	};
}

void CPgMultilinkMerge::OnChangeEdittime() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	// TODO: Add your control notification handler code here
	if (m_bInited)
	{
		SetModified();
		m_pProfile->m_dwAttributeFlags |= PABF_msRASBapLinednTime;
	};
}

void CPgMultilinkMerge::EnableSettings()
{
	EnablePorts();
	EnableBAP();
}

void CPgMultilinkMerge::EnableBAP()
{
	CButton	*pBtn = (CButton*)GetDlgItem(IDC_RADIO_MULNK_SINGLE);
	ASSERT(pBtn);
	BOOL	b = (pBtn->GetCheck() == 0);	// only enable when Single is not selected

	m_CheckRequireBAP.EnableWindow(b);
	// the other BAP info is not affected by the state of the check box

	m_EditPercent.EnableWindow(b);
	m_SpinPercent.EnableWindow(b);
	m_EditTime.EnableWindow(b);
	m_SpinTime.EnableWindow(b);
	GetDlgItem(IDC_COMBOUNIT)->EnableWindow(b);
}

void CPgMultilinkMerge::EnablePorts()
{
	CButton	*pBtn = (CButton*)GetDlgItem(IDC_RADIO_MULNK_MULTI);
	ASSERT(pBtn);
	BOOL	b = pBtn->GetCheck();

	m_EditPorts.EnableWindow(b);
	m_SpinMaxPorts.EnableWindow(b);
}

BOOL CPgMultilinkMerge::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	
	return CManagedPage::OnHelpInfo(pHelpInfo);
}

void CPgMultilinkMerge::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	CManagedPage::OnContextMenu(pWnd, point);
	
}

void CPgMultilinkMerge::OnSelchangeCombounit() 
{
	SetModified();
	m_pProfile->m_dwAttributeFlags |= PABF_msRASBapLinednTime;
}

void CPgMultilinkMerge::OnCheckrequirebap() 
{
	SetModified();	
}

void CPgMultilinkMerge::OnRadioMulnkMulti() 
{
	SetModified();
	EnablePorts();
	EnableBAP();
	if(m_pProfile->m_dwPortLimit == 1)
	{
		m_pProfile->m_dwPortLimit =2;
		CString str = _T("2");
		m_EditPorts.SetWindowText(str);
	}
}

void CPgMultilinkMerge::OnRadioMulnkNotdefined() 
{
	SetModified();
	EnablePorts();
	EnableBAP();
}

void CPgMultilinkMerge::OnRadioMulnkSingle() 
{

	SetModified();
	EnablePorts();
	EnableBAP();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgmulnk.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	pgmulnk.h
		Definition of CPgMultilink -- property page to edit
		profile attributes related to multiple connections

    FILE HISTORY:
        
*/
#if !defined(AFX_PGMULNK_H__8C28D93E_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PGMULNK_H__8C28D93E_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgMulnk.h : header file
//
#include "rasdial.h"

/////////////////////////////////////////////////////////////////////////////
// CPgMultilinkMerge dialog

class CPgMultilinkMerge : public CManagedPage
{
	DECLARE_DYNCREATE(CPgMultilinkMerge)

// Construction
public:
	CPgMultilinkMerge(CRASProfileMerge* profile = NULL);
	~CPgMultilinkMerge();

// Dialog Data
	//{{AFX_DATA(CPgMultilinkMerge)
	enum { IDD = IDD_MULTILINK_MERGE };
	CButton	m_CheckRequireBAP;
	CEdit	m_EditTime;
	CEdit	m_EditPorts;
	CEdit	m_EditPercent;
	CSpinButtonCtrl	m_SpinTime;
	CSpinButtonCtrl	m_SpinPercent;
	CSpinButtonCtrl	m_SpinMaxPorts;
	CComboBox		m_CBUnit;
	UINT	m_nTime;
	int		m_Unit;
	BOOL	m_bRequireBAP;
	int		m_nMultilinkPolicy;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPgMultilinkMerge)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnablePorts();
	void EnableBAP();
	void EnableSettings();
	// Generated message map functions
	//{{AFX_MSG(CPgMultilinkMerge)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditmaxports();
	afx_msg void OnChangeEditpercent();
	afx_msg void OnChangeEdittime();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnCheckmultilink();
	afx_msg void OnCheckmaxlink();
	afx_msg void OnSelchangeCombounit();
	afx_msg void OnCheckrequirebap();
	afx_msg void OnRadioMulnkMulti();
	afx_msg void OnRadioMulnkNotdefined();
	afx_msg void OnRadioMulnkSingle();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CRASProfileMerge*	m_pProfile;
	bool			m_bInited;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGMULNK_H__8C28D93E_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgtunnel.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	pgtunnel.h
		Definition of CPgNetworking -- property page to edit
		profile attributes related to tunneling

    FILE HISTORY:
        
*/
#if !defined(AFX_PGTUNNEL_H__8C28D942_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PGTUNNEL_H__8C28D942_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgTunnel.h : header file
//
#include "rasdial.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGTUNNEL_H__8C28D942_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgnetwk.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   pgnetwk.cpp
      Implemenation of CPgNetworking -- property page to edit
      profile attributes related to inter-networking

    FILE HISTORY:

*/
// PgNetwk.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PgNetwk.h"
#include "helptable.h"
#include "mprapi.h"
#include "std.h"
#include "mprsnap.h"
#include "infobase.h"
#include "router.h"
#include "mprfltr.h"
#include "iasdefs.h"
#include <ipinfoid.h>
#include <fltdefs.h>
#include "iprtinfo.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPgNetworkingMerge property page

IMPLEMENT_DYNCREATE(CPgNetworkingMerge, CManagedPage)

CPgNetworkingMerge::CPgNetworkingMerge(CRASProfileMerge* profile)
   : CManagedPage(CPgNetworkingMerge::IDD),
   m_pProfile(profile),
   m_bInited(false),
   m_dwStaticIP(0)
{
   //{{AFX_DATA_INIT(CPgNetworkingMerge)
   m_nRadioStatic = -1;
   //}}AFX_DATA_INIT

   m_pBox = NULL;
   if(!(m_pProfile->m_dwAttributeFlags & PABF_msRADIUSFramedIPAddress)) // not defined in policy
   {
      m_nRadioStatic = 2;
   }
   else
   {
      m_dwStaticIP = m_pProfile->m_dwFramedIPAddress;

      switch(m_dwStaticIP)
      {
      case  RAS_IP_USERSELECT:
         m_nRadioStatic = 1;
         break;
      case  RAS_IP_SERVERASSIGN:
         m_nRadioStatic = 0;
         break;
      default:
         m_nRadioStatic = 3;
         break;
      }
   }

   // filters
   if((BSTR)m_pProfile->m_cbstrFilters)
   {
      m_cbstrFilters.AssignBSTR(m_pProfile->m_cbstrFilters);
   }

   SetHelpTable(g_aHelpIDs_IDD_NETWORKING_MERGE);
}


CPgNetworkingMerge::~CPgNetworkingMerge()
{
   delete   m_pBox;
}


void CPgNetworkingMerge::DoDataExchange(CDataExchange* pDX)
{
   ASSERT(m_pProfile);
   CPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPgNetworkingMerge)
   DDX_Radio(pDX, IDC_RADIOSERVER, m_nRadioStatic);
   //}}AFX_DATA_MAP


   if(pDX->m_bSaveAndValidate)      // save data to this class
   {
      // ip adress control
      SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_GETADDRESS, 0, (LPARAM)&m_dwStaticIP);
   }
   else     // put to dialog
   {
      // ip adress control
      if(m_bInited)
      {
         SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_SETADDRESS, 0, m_dwStaticIP);
      }
      else
      {
         SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_CLEARADDRESS, 0, m_dwStaticIP);
      }
   }
}

BEGIN_MESSAGE_MAP(CPgNetworkingMerge, CPropertyPage)
   //{{AFX_MSG_MAP(CPgNetworkingMerge)
   ON_BN_CLICKED(IDC_RADIOCLIENT, OnRadioclient)
   ON_BN_CLICKED(IDC_RADIOSERVER, OnRadioserver)
   ON_WM_HELPINFO()
   ON_WM_CONTEXTMENU()
   ON_BN_CLICKED(IDC_RADIODEFAULT, OnRadiodefault)
   ON_BN_CLICKED(IDC_RADIOSTATIC, OnRadioStatic)
   ON_BN_CLICKED(IDC_BUTTON_TOCLIENT, OnButtonToclient)
   ON_BN_CLICKED(IDC_BUTTON_FROMCLIENT, OnButtonFromclient)
   ON_EN_CHANGE(IDC_EDIT_STATIC_IP_ADDRESS, OnStaticIPAddressChanged)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgNetworking message handlers

BOOL CPgNetworkingMerge::OnInitDialog()
{
   // necessary?
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CPropertyPage::OnInitDialog();
   m_bInited = true;

   // should be replaced by a proper init of the control
   CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
   if (IPWnd != NULL)
   {
      IPWnd->EnableWindow(TRUE);
   }
   SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_SETADDRESS, 0, m_dwStaticIP);

   if (m_nRadioStatic == 3)
   {
      CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
      if (IPWnd != NULL)
      {
         IPWnd->EnableWindow(TRUE);
      }
   }
   else
   {
      CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
      if (IPWnd != NULL)
      {
         IPWnd->EnableWindow(FALSE);
      }
   }

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


void CPgNetworkingMerge::OnRadioclient()
{
   CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
   if (IPWnd != NULL)
   {
      IPWnd->EnableWindow(FALSE);
   }

   SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_SETADDRESS, 0, m_dwStaticIP);

   SetModified();
}


void CPgNetworkingMerge::OnRadioserver()
{
   CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
   if (IPWnd != NULL)
   {
      IPWnd->EnableWindow(FALSE);
   }

   SendDlgItemMessage(IDC_EDIT_STATIC_IP_ADDRESS, IPM_SETADDRESS, 0, m_dwStaticIP);

   SetModified();
}


void CPgNetworkingMerge::OnRadiodefault()
{
   CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
   if (IPWnd != NULL)
   {
      IPWnd->EnableWindow(FALSE);
   }

   SetModified();
}


void CPgNetworkingMerge::OnRadioStatic()
{
   if (m_bInited)
   {
      CWnd* IPWnd = GetDlgItem(IDC_EDIT_STATIC_IP_ADDRESS);
      if (IPWnd != NULL)
      {
         IPWnd->EnableWindow(TRUE);
      }
   }

   SetModified();
}


void CPgNetworkingMerge::OnStaticIPAddressChanged()
{
   SetModified();
}


void CPgNetworkingMerge::EnableFilterSettings(BOOL bEnable)
{
   m_pBox->Enable(bEnable);
}


BOOL CPgNetworkingMerge::OnApply()
{
   if (!GetModified()) return TRUE;

   // get the IP policy value
   switch(m_nRadioStatic)
   {
   case 3:
      {
         m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSFramedIPAddress;
         m_pProfile->m_dwFramedIPAddress = m_dwStaticIP;
         break;
      }
   case 2:  // default server settings
      {
         m_pProfile->m_dwFramedIPAddress = 0;
         m_pProfile->m_dwAttributeFlags &= ~PABF_msRADIUSFramedIPAddress;  // not defined in policy
         break;
      }
   case 1:  // client requre
      {
         m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSFramedIPAddress;
         m_pProfile->m_dwFramedIPAddress = RAS_IP_USERSELECT;
         break;   // server assign
      }
   case 0:
      {
         m_pProfile->m_dwAttributeFlags |= PABF_msRADIUSFramedIPAddress;
         m_pProfile->m_dwFramedIPAddress = RAS_IP_SERVERASSIGN;
         break;
      }
   default:
      {
         break;
      }
   }

   // filters
   m_pProfile->m_cbstrFilters.AssignBSTR(m_cbstrFilters);
   m_pProfile->m_nFiltersSize = SysStringByteLen(m_cbstrFilters);

   return CManagedPage::OnApply();
}


BOOL CPgNetworkingMerge::OnHelpInfo(HELPINFO* pHelpInfo)
{
   return CManagedPage::OnHelpInfo(pHelpInfo);
}


void CPgNetworkingMerge::OnContextMenu(CWnd* pWnd, CPoint point)
{
   CManagedPage::OnContextMenu(pWnd, point);
}


void CPgNetworkingMerge::OnButtonToclient()
{
   ConfigureFilter(FILTER_TO_USER);
}


void CPgNetworkingMerge::OnButtonFromclient()
{
   ConfigureFilter(FILTER_FROM_USER);
}


void CPgNetworkingMerge::ConfigureFilter(DWORD dwFilterType) throw ()
{
   HRESULT hr;

   // Create the InfoBase.
   CComPtr<IInfoBase> infoBase;
   hr = CreateInfoBase(&infoBase);
   if (FAILED(hr))
   {
      return;
   }

   // Load the current filters into the InfoBase.
   UINT oldLen = m_cbstrFilters.ByteLen();
   if (oldLen > 0)
   {
      hr = infoBase->LoadFrom(
                        oldLen,
                        reinterpret_cast<BYTE*>(m_cbstrFilters.m_bstr)
                        );
      if (FAILED(hr))
      {
         return;
      }
   }

   // Loop until we have a filter that isn't too big.
   bool tooBig;
   do
   {
      // Bring up the UI.
      hr = MprUIFilterConfigInfoBase(
              m_hWnd,
              infoBase,
              0,
              PID_IP,
              dwFilterType
              );
      if (hr != S_OK)
      {
         return;
      }

      BYTE* newFilter;
      DWORD newFilterLen;

      // check if at least one filter is present.
      BYTE* pfilter;
      if (
           (  (infoBase->GetData(IP_IN_FILTER_INFO, 0, &pfilter) == S_OK) && 
               pfilter &&
             ((FILTER_DESCRIPTOR *) pfilter)->dwNumFilters > 0
           )
           ||
           (
             (infoBase->GetData(IP_OUT_FILTER_INFO, 0, &pfilter) == S_OK) && 
              pfilter &&
             ((FILTER_DESCRIPTOR *) pfilter)->dwNumFilters > 0
           ) 
         )
      {
         // at lease ont filter present
         // Get the new filter.
         hr = infoBase->WriteTo(&newFilter, &newFilterLen);
         if (FAILED(hr))
         {
            return;
         }
      }
      else
      {
         m_cbstrFilters.Clean();
         // Activate the apply button.
         SetModified();
         return;
      }

      if (newFilterLen < MAX_FILTER_SIZE)
      {
         // Filter isn't too big.
         tooBig = false;

         BSTR bstr = SysAllocStringByteLen(
                        reinterpret_cast<char*>(newFilter),
                        newFilterLen
                        );
         if (bstr != 0)
         {
            m_cbstrFilters.Clean();
            m_cbstrFilters.m_bstr = bstr;

            // Activate the apply button.
            SetModified();
         }
      }
      else
      {
         // Filter is too big.
         tooBig = true;

         // Warn the user and let him try again.
         AfxMessageBox(
            IDS_ERROR_IP_FILTER_TOO_BIG,
            (MB_OK | MB_ICONEXCLAMATION)
            );
      }

      CoTaskMemFree(newFilter);
   }
   while(tooBig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgnetwk.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000 **/
/**********************************************************************/

/*
   pgnetwk.h
      Definition of CPgNetworking -- property page to edit
      profile attributes related to inter-networking

    FILE HISTORY:

*/
#if !defined(AFX_PGNETWK_H__8C28D93D_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PGNETWK_H__8C28D93D_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PgNetwk.h : header file
//
#include "rasdial.h"
/////////////////////////////////////////////////////////////////////////////
// CPgNetworkingMerge dialog

class CPgNetworkingMerge : public CManagedPage
{
   DECLARE_DYNCREATE(CPgNetworkingMerge)

// Construction
public:
   CPgNetworkingMerge(CRASProfileMerge* profile = NULL);
   ~CPgNetworkingMerge();

// Dialog Data
   //{{AFX_DATA(CPgNetworkingMerge)
   enum { IDD = IDD_NETWORKING_MERGE };
   int      m_nRadioStatic;
   //}}AFX_DATA

   CBSTR m_cbstrFilters;

// Overrides
   // ClassWizard generate virtual function overrides
   //{{AFX_VIRTUAL(CPgNetworkingMerge)
   public:
   virtual BOOL OnApply();
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:
   void EnableFilterSettings(BOOL bEnable);
   // Generated message map functions
   //{{AFX_MSG(CPgNetworkingMerge)
   virtual BOOL OnInitDialog();
   afx_msg void OnRadioclient();
   afx_msg void OnRadioserver();
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg void OnRadiodefault();
   afx_msg void OnButtonToclient();
   afx_msg void OnButtonFromclient();
   afx_msg void OnRadioStatic();
   afx_msg void OnStaticIPAddressChanged();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   void ConfigureFilter(DWORD dwFilterType) throw ();

   CRASProfileMerge* m_pProfile;

   CStrBox<CListBox>*      m_pBox;
   DWORD  m_dwStaticIP;
   bool   m_bInited;

};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PGNETWK_H__8C28D93D_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\pgtunnel.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	pgtunnel.h
		Definition of CPgNetworking -- property page to edit
		profile attributes related to tunneling

    FILE HISTORY:
        
*/
// PgTunnel.cpp : implementation file
//

#include "stdafx.h"
#include "rasuser.h"
#include "resource.h"
#include "PgTunnel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPgTunneling property page
#ifdef	_TUNNEL
IMPLEMENT_DYNCREATE(CPgTunneling, CPropertyPage)

CPgTunneling::CPgTunneling(CRASProfile* profile) 
	: CManagedPage(CPgTunneling::IDD),
	m_pProfile(profile)
{
	//{{AFX_DATA_INIT(CPgTunneling)
	m_bTunnel = FALSE;
	//}}AFX_DATA_INIT

	m_pTunnelTypeBox = new CStrBox<CComboBox>(this, IDC_COMBOTYPE, CRASProfile::m_TunnelTypes);
	m_pTunnelMediumTypeBox = new CStrBox<CComboBox>(this, IDC_COMBOMEDIA, CRASProfile::m_TunnelMediumTypes);
	m_bTunnel = (m_pProfile->m_dwTunnelType != 0);

	SetHelpTable(IDD_TUNNELING_HelpTable);

	m_bInited = false;
}

CPgTunneling::~CPgTunneling()
{
	delete	m_pTunnelTypeBox;
	delete	m_pTunnelMediumTypeBox;
}

void CPgTunneling::DoDataExchange(CDataExchange* pDX)
{
	ASSERT(m_pProfile);
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPgTunneling)
	DDX_Check(pDX, IDC_CHECKREQUIREVPN, m_bTunnel);
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_EDITPRIVATEGROUPID, m_pProfile->m_strTunnelPrivateGroupId);
	DDX_Text(pDX, IDC_EDITSERVER, m_pProfile->m_strTunnelServerEndpoint);
}


BEGIN_MESSAGE_MAP(CPgTunneling, CPropertyPage)
	//{{AFX_MSG_MAP(CPgTunneling)
	ON_BN_CLICKED(IDC_CHECKREQUIREVPN, OnCheckrequirevpn)
	ON_CBN_SELCHANGE(IDC_COMBOMEDIA, OnSelchangeCombomedia)
	ON_CBN_SELCHANGE(IDC_COMBOTYPE, OnSelchangeCombotype)
	ON_EN_CHANGE(IDC_EDITSERVER, OnChangeEditserver)
	ON_EN_CHANGE(IDC_EDITPRIVATEGROUPID, OnChangeEditprivategroupid)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPgTunneling message handlers

BOOL CPgTunneling::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// tunnel type box
	m_pTunnelTypeBox->Fill();
	if(m_pProfile->m_dwTunnelType)
	{
		for(int i = 0; i < CRASProfile::m_TunnelTypeIds.GetSize(); i++)
		{
			if(CRASProfile::m_TunnelTypeIds[i] == (int)m_pProfile->m_dwTunnelType)
				break;
		}

		if(i < CRASProfile::m_TunnelTypeIds.GetSize())
			m_pTunnelTypeBox->Select(i);
	}

	// tunnel medium type box
	m_pTunnelMediumTypeBox->Fill();
	if(m_pProfile->m_dwTunnelMediumType)
	{
		for(int i = 0; i < CRASProfile::m_TunnelMediumTypeIds.GetSize(); i++)
		{
			if(CRASProfile::m_TunnelMediumTypeIds[i] == (int)m_pProfile->m_dwTunnelMediumType)
				break;
		}

		if(i < CRASProfile::m_TunnelMediumTypeIds.GetSize())
			m_pTunnelMediumTypeBox->Select(i);
	}

	EnableSettings();
	
	m_bInited = true;
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPgTunneling::OnCheckrequirevpn() 
{
	EnableSettings();
	if(m_bInited)	SetModified();
}

void CPgTunneling::OnSelchangeCombomedia() 
{
	if(m_bInited)	SetModified();
}

void CPgTunneling::OnSelchangeCombotype() 
{
	if(m_bInited)	SetModified();
}

void CPgTunneling::OnChangeEditserver() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	if(m_bInited)	SetModified();
}

void CPgTunneling::OnChangeEditprivategroupid() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	if(m_bInited)	SetModified();
}

void CPgTunneling::EnableSettings()
{
	BOOL	b = ((CButton*)GetDlgItem(IDC_CHECKREQUIREVPN))->GetCheck();
	m_pTunnelTypeBox->Enable(b);
	m_pTunnelMediumTypeBox->Enable(b);
	GetDlgItem(IDC_EDITSERVER)->EnableWindow(b);
	GetDlgItem(IDC_EDITPRIVATEGROUPID)->EnableWindow(b);
}

BOOL CPgTunneling::OnApply() 
{
	if (!GetModified()) return TRUE;

	if(!m_bTunnel)		// no tunel is defined
	{
		m_pProfile->m_dwTunnelMediumType = 0;
		m_pProfile->m_dwTunnelType = 0;
		m_pProfile->m_strTunnelPrivateGroupId.Empty();
		m_pProfile->m_strTunnelServerEndpoint.Empty();
	}
	else	// get tunnel type and media type
	{
		int i = m_pTunnelTypeBox->GetSelected();
		if(i != -1)
			m_pProfile->m_dwTunnelType = CRASProfile::m_TunnelTypeIds[i];
		else
			m_pProfile->m_dwTunnelType = 0;


		i = m_pTunnelMediumTypeBox->GetSelected();
		if(i != -1)
			m_pProfile->m_dwTunnelMediumType = CRASProfile::m_TunnelMediumTypeIds[i];
		else
			m_pProfile->m_dwTunnelMediumType = 0;
	}

	return CManagedPage::OnApply();
}

BOOL CPgTunneling::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	return CManagedPage::OnHelpInfo(pHelpInfo);
}

void CPgTunneling::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	CManagedPage::OnContextMenu(pWnd, point);	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\profsht.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   profsht.cpp
      Implementation of CProfileSheet -- property sheet to hold
      profile property pages

    FILE HISTORY:
        
*/
// ProfSht.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "pgconst.h"
#include "pgnetwk.h"
#include "ProfSht.h"
#include "rasprof.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CProfileSheetMerge

IMPLEMENT_DYNAMIC(CProfileSheetMerge, CPropertySheet)

CProfileSheetMerge::CProfileSheetMerge(CRASProfileMerge& profile, bool bSaveOnApply, UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
   :CPropertySheet(nIDCaption, pParentWnd, iSelectPage), 
   m_pProfile(&profile), 
   m_bSaveOnApply(bSaveOnApply),
   m_pgAuthentication(profile),
   m_pgAuthentication2k(profile),
   m_pgConstraints(&profile),
   m_pgEncryption(&profile),
   m_pgMultilink(&profile),
   m_pgNetworking(&profile),
   m_pgIASAdv(profile.m_spIProfile, profile.m_spIDictionary),
   m_dwTabFlags(0)
{
}

CProfileSheetMerge::CProfileSheetMerge(CRASProfileMerge& profile, bool bSaveOnApply, LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
   :CPropertySheet(pszCaption, pParentWnd, iSelectPage),
   m_pProfile(&profile), 
   m_bSaveOnApply(bSaveOnApply),
   m_pgAuthentication(profile),
   m_pgAuthentication2k(profile),
   m_pgConstraints(&profile),
   m_pgEncryption(&profile),
   m_pgMultilink(&profile),
   m_pgNetworking(&profile),
   m_pgIASAdv(profile.m_spIProfile, profile.m_spIDictionary),
   m_dwTabFlags(0)
{
}

#ifdef   __TEST_ADV_PAGE_API
void* pVData;
#endif

void CProfileSheetMerge::PreparePages(DWORD dwTabFlags, void* pvData)
{
   m_bApplied = FALSE;
   AddPage(&m_pgConstraints);
   m_pgConstraints.SetManager(this);

   AddPage(&m_pgNetworking);
   m_pgNetworking.SetManager(this);

   AddPage(&m_pgMultilink);
   m_pgMultilink.SetManager(this);

   // Check if this is a remote admin of a win2k machine 

   m_dwTabFlags = dwTabFlags;
   if(dwTabFlags & RAS_IAS_PROFILEDLG_SHOW_WIN2K)
   {
      AddPage(&m_pgAuthentication2k);
      m_pgAuthentication2k.SetManager(this);
   }
   else
   {
      AddPage(&m_pgAuthentication);
      m_pgAuthentication.SetManager(this);
   }

   AddPage(&m_pgEncryption);
   m_pgEncryption.SetManager(this);

   // Advanced tab
   m_pgIASAdv.SetData(ALLOWEDINPROFILE, pvData);
   AddPage(&m_pgIASAdv);
   m_pgIASAdv.SetManager(this);
   
#ifdef   __TEST_ADV_PAGE_API
   pVData = pvData;
#endif   

   m_hrLastError = S_OK;
}

CProfileSheetMerge::~CProfileSheetMerge()
{
}

BEGIN_MESSAGE_MAP(CProfileSheetMerge, CPropertySheet)
   //{{AFX_MSG_MAP(CProfileSheetMerge)
   ON_WM_HELPINFO()
   ON_WM_CREATE()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProfileSheetMerge message handlers

BOOL CProfileSheetMerge::OnApply()
{
   BOOL     bSaved = TRUE;
   
   if(!CPageManager::OnApply())  return FALSE;

   // for each page this sheet manages, call the OnApply, and then call SetModify to False
   if (m_pgAuthentication.GetModified())
      m_pgAuthentication.OnApply();

   if (m_pgConstraints.GetModified())
      m_pgConstraints.OnApply();

   if (m_pgEncryption.GetModified())
      m_pgEncryption.OnApply();

   if (m_pgMultilink.GetModified())
      m_pgMultilink.OnApply();

   if (m_pgNetworking.GetModified())
      m_pgNetworking.OnApply();
      
   if (m_pgIASAdv.GetModified())
      m_pgIASAdv.OnApply();

   HRESULT  hr = S_OK;
   if(m_bSaveOnApply)
      hr = m_pProfile->Save();

   if(FAILED(hr))
   {
      m_hrLastError = hr;
      ReportError(hr, IDS_ERR_SAVEPROFILE, NULL);
      
      bSaved = FALSE;
   }

   m_bApplied = TRUE;

   m_pgAuthentication.OnSaved(bSaved);
   m_pgConstraints.OnSaved(bSaved);
   m_pgEncryption.OnSaved(bSaved);
   m_pgMultilink.OnSaved(bSaved);
   m_pgNetworking.OnSaved(bSaved);
   m_pgIASAdv.OnSaved(bSaved);

   return bSaved;
}

const DWORD g_aHelpIDs___________[]=
{
   ID_APPLY_NOW, 20000600,
   0, 0
};

BOOL CProfileSheetMerge::OnHelpInfo(HELPINFO* pHelpInfo)
{
   ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                 AfxGetApp()->m_pszHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)g_aHelpIDs___________);
   
   return CPropertySheet::OnHelpInfo(pHelpInfo);
}

void CProfileSheetMerge::OnContextMenu(CWnd* pWnd, CPoint point)
{
   ::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)g_aHelpIDs___________);
}


int CProfileSheetMerge::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
      return -1;
   
   return 0;
}

BOOL CProfileSheetMerge::OnInitDialog() 
{
   BOOL bResult = CPropertySheet::OnInitDialog();
   
   if(CPageManager::GetReadOnly())
      GetDlgItem(IDOK)->EnableWindow(FALSE);

#ifdef   __TEST_ADV_PAGE_API
   HPROPSHEETPAGE hPage = IASCreateProfileAdvancedPage(m_pProfile->m_spIProfile, m_pProfile->m_spIDictionary, ALLOWEDINPROFILE, pVData);
   if(hPage)
      PropSheet_InsertPage(m_hWnd, NULL, hPage);

#endif

   return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\rasdial.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   rasdial.cpp
      Definition of CRASProfile class and CRASUser class

    FILE HISTORY:

*/
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <sspi.h>
#include <secext.h>
#include <dsgetdc.h>
#include "resource.h"
#include "helper.h"
#include "rasdial.h"
#include "rasprof.h"
#include "sharesdo.h"
#include "iastrace.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CRASUserMerge::CRASUserMerge(RasEnvType type, LPCWSTR location, LPCWSTR userPath)
{
   // environment info
   m_type = type;
   m_strMachine = location;
   m_strUserPath = userPath;

   // Ip Addresses
   m_dwFramedIPAddress = 0;
   m_dwDefinedAttribMask = 0;
};


HRESULT  CRASUserMerge::HrGetDCName(CString& DcName)
{
   HRESULT  hr = S_OK;
   VARIANT  v;
   VariantInit(&v);
   CComPtr<IADs>  spIADs;
   CComPtr<IADsObjectOptions> spOps;

   USES_CONVERSION;
   CHECK_HR( hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)m_strUserPath), IID_IADs, (void**)&spIADs));
   ASSERT(spIADs.p);

   CHECK_HR(hr = spIADs->QueryInterface(IID_IADsObjectOptions,(void**)&spOps));

   CHECK_HR(hr = spOps->GetOption(ADS_OPTION_SERVERNAME,&v));

   ASSERT(V_VT(&v) == VT_BSTR);

   DcName = V_BSTR(&v);

   VariantClear(&v);

L_ERR:
   VariantClear(&v);
   return hr;
};


HRESULT  CRASUserMerge::HrIsInMixedDomain()
{
   HRESULT  hr = S_OK;
   VARIANT  v;
   VariantInit(&v);

   if(!m_strMachine.IsEmpty())   // local user, so not
      return S_FALSE;
   else
   {
      // try to use SDO
      IASDOMAINTYPE domainType;
      if((ISdoMachine*)m_spISdoServer != NULL)  // already created
      {
         if(m_spISdoServer->GetDomainType(&domainType) == S_OK)
         {
            if (domainType == DOMAIN_TYPE_MIXED)
               return S_OK;
            else
               return S_FALSE;
         }
      }


      // if for any reason, SDO doesn't provide the information, do it myself
      // Canonical Name Format
      TCHAR szName[MAX_PATH * 2];
      ULONG size = MAX_PATH * 2;
      CString  DomainPath;
      CString strTemp;
      CComPtr<IADs>  spIADs;
      int      i;

      USES_CONVERSION;
      CHECK_HR( hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)m_strUserPath), IID_IADs, (void**)&spIADs));
      ASSERT(spIADs.p);
      CHECK_HR( hr = spIADs->Get(L"distinguishedName", &v));

      ASSERT(V_VT(&v) == VT_BSTR);

      CHECK_HR(hr = ::TranslateName(V_BSTR(&v), NameFullyQualifiedDN, NameCanonical, szName, &size));

      VariantClear(&v);

      strTemp = szName;
      i  = strTemp.Find(_T('/'));

      if(i != -1)
         strTemp = strTemp.Left(i);

      // DN of the domain
      DomainPath = _T("LDAP://");
      DomainPath += strTemp;

      spIADs.Release();

      CHECK_HR(hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)DomainPath), IID_IADs, (void**)&spIADs));
      ASSERT(spIADs.p);
      CHECK_HR(hr = spIADs->Get(L"nTMixedDomain", &v));

      ASSERT(V_VT(&v) == VT_BOOL || V_VT(&v) == VT_I4);

      if(V_BOOL(&v)) hr = S_OK;
      else  hr = S_FALSE;
   }
L_ERR:
   VariantClear(&v);
   return hr;
}


BOOL  CRASUserMerge::IfAccessAttribute(ULONG id)
{
   if(S_OK == HrIsInMixedDomain()) // only allow dialin bit and callback policy
   {
      switch(id)
      {
      case  PROPERTY_USER_IAS_ATTRIBUTE_ALLOW_DIALIN:    // allow dialin or not
      case  PROPERTY_USER_msRADIUSCallbackNumber:        // call back number
      case  PROPERTY_USER_RADIUS_ATTRIBUTE_SERVICE_TYPE: // call back policy
         return TRUE;
      default:
         return FALSE;
      }
   }
   else  // no restriction otherwise
      return TRUE;
}


HRESULT  CRASUserMerge::SetRegistryFootPrint()
{
   if(IsFocusOnLocalUser())
   {
      RegKey   RemoteAccessParames;
      LONG  lRes = RemoteAccessParames.Create(RAS_REG_ROOT, REGKEY_REMOTEACCESS_PARAMS,
               REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, (LPCTSTR)m_strMachine);

      if (lRes != ERROR_SUCCESS)
         return HRESULT_FROM_WIN32(lRes);

      //================================================
      // save the values to the key
      DWORD regValue = REGVAL_VAL_USERSCONFIGUREDWITHMMC;
      lRes = RemoteAccessParames.SetValue(REGVAL_NAME_USERSCONFIGUREDWITHMMC, regValue);
   }

   return S_OK;
}


//====================================================
//
// CRASUserMerge::Load
//
// load RASUser object from DS
// pcwszUserPath: is the ADsPath of the DSuser object, the RASUser object is
// object contained in DSUser object
// when, the RASUser object doesn't exist, load will call
// CreateDefault to create one object for this DSUser
HRESULT CRASUserMerge::Load()
{
   // new function added for no DS machine :   weijiang 12/17/97

   USES_CONVERSION;

   // Load is not expected to be called more than once
   ASSERT(!m_spISdoServer.p);

   VARIANT           var;
   HRESULT           hr = S_OK;
   CComPtr<ISdo>     spSdo;
   CComPtr<IUnknown> spUnk;
   BSTR           bstrMachineName = NULL;
   BSTR           bstrUserPath = NULL;
   UINT           nServiceType = 0;
   IASDATASTORE      storeFlags;
   CComPtr<ISdo>     spIRasUser;

   VariantInit(&var);

   // one more function call to SDOSERver to set machine information
   // Get the user SDO

   if(m_strMachine.IsEmpty()) // focused on DS
   {
      storeFlags = DATA_STORE_DIRECTORY;

      CString sDCName;

      CHECK_HR(hr = HrGetDCName(sDCName));

      CBSTR bstrDomainController(sDCName);
      bstrMachineName = T2BSTR((LPTSTR)(LPCTSTR)sDCName);
   }
   else  // local machine
   {
      storeFlags = DATA_STORE_LOCAL;
      bstrMachineName = T2BSTR((LPTSTR)(LPCTSTR)m_strMachine);
   }

   // connect to server
#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
   // connection will NOT be necessary after SDO changes to RTM version.
   // connect once for each process
   CHECK_HR(hr = m_MarshalSdoServer.GetServer(&m_spISdoServer));
   {
      CWaitCursor wc;

      // if we get the server back from the shareSDO object, we use it to connect
      if ((ISdoMachine*)m_spISdoServer)
      {
         CHECK_HR(hr = m_MarshalSdoServer.Connect());
      }
      // otherwise, we make a new connection
      else
      {
         // try to Connect the old way
         // connect everytime a user page is requested
         CHECK_HR(hr = ConnectToSdoServer(bstrMachineName, NULL, NULL, &m_spISdoServer));
      }
   }

#else
   // connect everytime a user page is requested
   CHECK_HR(hr = ConnectToSdoServer(bstrMachineName, NULL, NULL, &m_spISdoServer));
#endif

   // If for local users, only NT5 servers are allowed to configure using this apge
   if(!m_strMachine.IsEmpty())   // not focused on DS
   {
      IASOSTYPE   OSType;

      CHECK_HR(hr =  m_spISdoServer->GetOSType(&OSType));
      if(OSType != SYSTEM_TYPE_NT5_SERVER)
      {
         hr = S_FALSE;
         goto L_ERR;
      }
   }

   // find the user object
   bstrUserPath = T2BSTR((LPTSTR)(LPCTSTR)m_strUserPath);
   IASTracePrintf("SdoServer::GetUserSDO(%x, %s, %x)", storeFlags, bstrUserPath, &spUnk);
   CHECK_HR(hr = m_spISdoServer->GetUserSDO( storeFlags, bstrUserPath, &spUnk));
   IASTracePrintf(" hr = %8x", hr);
   ASSERT(spUnk.p);

   CHECK_HR(hr = spUnk->QueryInterface(IID_ISdo, (void**)&spIRasUser));
   ASSERT(spIRasUser.p);

   // initialize the wrapper class
   CHECK_HR(hr = m_SdoWrapper.Init((ISdo*)spIRasUser));

   // Get All the properties

   // need to handle the case when the values don't exist

   m_dwDefinedAttribMask = 0;

   // m_dwDialinPermit

   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_IAS_ATTRIBUTE_ALLOW_DIALIN, &var));
   if(V_VT(&var) == VT_I4 || V_VT(&var) == VT_BOOL)
   {
      if(V_BOOL(&var) != 0)
         m_dwDialinPermit = 1;
      else
         m_dwDialinPermit = 0;
   }
   else
      m_dwDialinPermit = -1;  // the value is not defined in the user data, using policy to decide

   // FramedIPAddress
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msRADIUSFramedIPAddress, &var));

   if(V_VT(&var) == VT_I4)
   {
      m_dwDefinedAttribMask |= RAS_USE_STATICIP;
      m_dwFramedIPAddress = V_I4(&var);
   }
   else
   {
      VariantClear(&var);
      CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msSavedRADIUSFramedIPAddress, &var));
      if(V_VT(&var) == VT_I4)
         m_dwFramedIPAddress = V_I4(&var);
      else
         m_dwFramedIPAddress = 0;
   }

   // Service Type -- to hold if this user has callback, if this user allowed to dialin
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_RADIUS_ATTRIBUTE_SERVICE_TYPE, &var));

   if(V_VT(&var) == VT_I4)
   {
      nServiceType = V_I4(&var);
   }

   // call back number
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msRADIUSCallbackNumber, &var));

   if(V_VT(&var) == VT_BSTR)
   {
      m_strCallbackNumber = V_BSTR(&var);
      if(nServiceType == RADUIS_SERVICETYPE_CALLBACK_FRAME && m_strCallbackNumber.IsEmpty())
         m_dwDefinedAttribMask |= RAS_CALLBACK_CALLERSET;
      else if (nServiceType == RADUIS_SERVICETYPE_CALLBACK_FRAME)
         m_dwDefinedAttribMask |= RAS_CALLBACK_SECURE;
   }
   else
   {
      if(nServiceType == RADUIS_SERVICETYPE_CALLBACK_FRAME)
         m_dwDefinedAttribMask |= RAS_CALLBACK_CALLERSET;
      else
         m_dwDefinedAttribMask |= RAS_CALLBACK_NOCALLBACK;

      VariantClear(&var);
      CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msSavedRADIUSCallbackNumber, &var));
      if(V_VT(&var) == VT_BSTR)
         m_strCallbackNumber = V_BSTR(&var);
   }

   // calling station id
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msNPCallingStationID, &var));

   if(V_VT(&var) & VT_ARRAY)
   {
      m_strArrayCallingStationId = V_ARRAY(&var);
      m_dwDefinedAttribMask |= RAS_USE_CALLERID;
   }
   else
   {
      VariantClear(&var);
      CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msSavedNPCallingStationID, &var));
      if(V_VT(&var) & VT_ARRAY)
         m_strArrayCallingStationId = V_ARRAY(&var);
   }

   // framed routes
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msRADIUSFramedRoute, &var));

   if(V_VT(&var) & VT_ARRAY)
   {
      m_strArrayFramedRoute = V_ARRAY(&var);
      m_dwDefinedAttribMask |= RAS_USE_STATICROUTES;
   }
   else
   {
      VariantClear(&var);
      CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_USER_msSavedRADIUSFramedRoute, &var));
      if(V_VT(&var) & VT_ARRAY)
         m_strArrayFramedRoute = V_ARRAY(&var);
   }

L_ERR:
   IASTracePrintf("hr = %8x", hr);
   VariantClear(&var);
   SysFreeString(bstrMachineName);
   SysFreeString(bstrUserPath);

   return hr;
}


//====================================================
// CRASUserMerge::Save
//
// save ths RASUser object

HRESULT CRASUserMerge::Save()
{
   HRESULT     hr = S_OK;
   VARIANT     var;

   USES_CONVERSION;

   // restore SDO user from
   // otherwise, we could overwrite the other properties in usrparams field
   // fix bug: 86968
   m_SdoWrapper.Commit(FALSE);

   VariantInit(&var);

   //==========================
   // Dialin bit
   VariantClear(&var);
   V_VT(&var) = VT_BOOL;
   switch(m_dwDialinPermit)
   {
   case  1: // allow
   case  0: // deny
      if(m_dwDialinPermit == 1)
         V_I4(&var) = VARIANT_TRUE; // Variant TRUE
      else
         V_I4(&var) = VARIANT_FALSE;

      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_IAS_ATTRIBUTE_ALLOW_DIALIN, &var));

      break;

   case  -1:   // decide by policy -- remove attribute
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_IAS_ATTRIBUTE_ALLOW_DIALIN));
      break;

   default:
      ASSERT(0);  // if need to provide new code

   }

   //==========================
   // Service Type -- callback policy
   if(m_dwDefinedAttribMask & (RAS_CALLBACK_SECURE | RAS_CALLBACK_CALLERSET))
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = RADUIS_SERVICETYPE_CALLBACK_FRAME;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_RADIUS_ATTRIBUTE_SERVICE_TYPE, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_RADIUS_ATTRIBUTE_SERVICE_TYPE));

   //==========================
   // call back number
   if (!m_strCallbackNumber.IsEmpty() && (m_dwDefinedAttribMask & RAS_CALLBACK_SECURE))
   {
      VariantClear(&var);
      V_VT(&var) = VT_BSTR;
      V_BSTR(&var) = T2BSTR((LPTSTR)(LPCTSTR)m_strCallbackNumber);
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msRADIUSCallbackNumber, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msRADIUSCallbackNumber));

   if(S_OK != HrIsInMixedDomain())
   {
      //==========================
      // call back number
      if(!m_strCallbackNumber.IsEmpty())
      {
         VariantClear(&var);
         V_VT(&var) = VT_BSTR;
         V_BSTR(&var) = T2BSTR((LPTSTR)(LPCTSTR)m_strCallbackNumber);
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msSavedRADIUSCallbackNumber, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msSavedRADIUSCallbackNumber));

      //==========================
      // FramedIPAddress
      if(m_dwFramedIPAddress) // need to back up the data, no matter if it's used
      {
         VariantClear(&var);
         V_VT(&var) = VT_I4;
         V_I4(&var) = m_dwFramedIPAddress;
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msSavedRADIUSFramedIPAddress, &var));
      }
      else  // remove it
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msSavedRADIUSFramedIPAddress));

      if(m_dwFramedIPAddress && (m_dwDefinedAttribMask & RAS_USE_STATICIP))
      {
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msRADIUSFramedIPAddress, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msRADIUSFramedIPAddress));

   }

   //==========================
   // calling station id
   if(S_OK != HrIsInMixedDomain())
   {
      if(m_strArrayCallingStationId.GetSize())
      {
         VariantClear(&var);
         V_VT(&var) = VT_VARIANT | VT_ARRAY;
         V_ARRAY(&var) = (SAFEARRAY*)m_strArrayCallingStationId;
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msSavedNPCallingStationID, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msSavedNPCallingStationID));

      if(m_strArrayCallingStationId.GetSize() && (m_dwDefinedAttribMask & RAS_USE_CALLERID))
      {
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msNPCallingStationID, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msNPCallingStationID));

      //==========================
      // framed routes
      if(m_strArrayFramedRoute.GetSize())
      {
         VariantClear(&var);
         V_VT(&var) = VT_VARIANT | VT_ARRAY;
         V_ARRAY(&var) = (SAFEARRAY*)m_strArrayFramedRoute;
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msSavedRADIUSFramedRoute, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msSavedRADIUSFramedRoute));

      if(m_strArrayFramedRoute.GetSize() && (m_dwDefinedAttribMask & RAS_USE_STATICROUTES))
      {
         CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_USER_msRADIUSFramedRoute, &var));
      }
      else
         CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_USER_msRADIUSFramedRoute));

   }
   CHECK_HR(hr = m_SdoWrapper.Commit());

   // touch the registry to make connection UI know.
   SetRegistryFootPrint();
L_ERR:
   VariantClear(&var);


   return hr;
}


// to detect if driver level support 128 bit encryption,
HRESULT  CRASProfileMerge::GetRasNdiswanDriverCaps(RAS_NDISWAN_DRIVER_INFO *pInfo)
{
   HANDLE     hConn;
   RAS_NDISWAN_DRIVER_INFO   pDriverInfo;

   DWORD dwErr = RasRpcConnectServer((LPTSTR)(LPCTSTR)m_strMachineName, &hConn);

   if (dwErr != NOERROR)
      return HRESULT_FROM_WIN32(dwErr);

   dwErr = RasGetNdiswanDriverCaps(hConn, pInfo);

   RasRpcDisconnectServer(hConn);

   return HRESULT_FROM_WIN32(dwErr);
}

#define  EAP_TLS_ID     13

HRESULT  CRASProfileMerge::GetEapTypeList(
                                 CStrArray&        EapTypes,
                                 CDWArray&         EapIds,
                                 CDWArray&         EAPTypeKeys,
                                 AuthProviderArray*   pProvList)
{
   AuthProviderArray __tmpArray;
   if (!pProvList)   // if not provided
   {
      pProvList = &__tmpArray;
   }

   HRESULT hr = S_OK;
   CHECK_HR(hr = GetEapProviders(m_strMachineName, pProvList));

   // fill in the buffers for name, Id, and keys

   CString* pStr = NULL;
   for (int i = 0; i < pProvList->GetSize(); i++)
   {
      AuthProviderData* pProv = &(pProvList->ElementAt(i));

      try
      {
         pStr = new CString(pProv->m_stServerTitle);
         DWORD dwID = _ttol(pProv->m_stKey);
         DWORD dwKey = pProv->m_fSupportsEncryption;

         // put the above to the arrays
         EapIds.Add(dwID);
         EAPTypeKeys.Add(dwKey);
         EapTypes.Add(pStr);
      }
      catch(CMemoryException* pException)
      {
         pException->Delete();
         EapIds.DeleteAll();
         EAPTypeKeys.DeleteAll();
         EapTypes.DeleteAll();
         CHECK_HR(hr = E_OUTOFMEMORY);
      }
   }
L_ERR:
   return hr;
}


HRESULT  CRASProfileMerge::GetPortTypeList(CStrArray& Names, CDWArray& MediumIds)
{
   ASSERT(m_spIDictionary.p);

   VARIANT  vNames;
   VARIANT  vIds;

   VariantInit(&vNames);
   VariantInit(&vIds);

   HRESULT     hr = S_OK;

   CHECK_HR(hr = m_spIDictionary->EnumAttributeValues((ATTRIBUTEID)PROPERTY_PROFILE_msNPAllowedPortTypes, &vIds, &vNames));

   ASSERT(V_VT(&vNames) & VT_ARRAY);
   ASSERT(V_VT(&vIds) & VT_ARRAY);

   try{
      Names = (SAFEARRAY*)V_ARRAY(&vNames);
      MediumIds = (SAFEARRAY*)V_ARRAY(&vIds);
   }
   catch(CMemoryException* pException)
   {
      pException->Delete();
      hr = E_OUTOFMEMORY;
   }

   ASSERT(MediumIds.GetSize() == Names.GetSize());    // they need to be in pairs
   if(MediumIds.GetSize() != Names.GetSize())
      hr = E_FAIL;

L_ERR:
   return hr;
}


//====================================================
//
// CRASProfileMerge::Load
//
// pcwszRelativePath -- the relative name for the profile object
//
HRESULT CRASProfileMerge::Load()
{
   ASSERT(m_spIProfile.p);
   ASSERT(m_spIDictionary.p);

   VARIANT     var;
   HRESULT     hr = S_OK;

   // Init the flags to NULL, each bit of the flag is used tell if a particular
   // attribute is defined
   m_dwAttributeFlags = 0;

   VariantInit(&var);

   //==================================================
   // constraints dialog

   /*
   // Constraints Dialog
      PROPERTY_PROFILE_msNPTimeOfDay
      PROPERTY_PROFILE_msNPCalledStationId
      PROPERTY_PROFILE_msNPAllowedPortTypes
      PROPERTY_PROFILE_msRADIUSIdleTimeout
      PROPERTY_PROFILE_msRADIUSSessionTimeout
   */

   // Sessions Allowed
   CHECK_HR(hr = m_SdoWrapper.Init(PROPERTY_PROFILE_ATTRIBUTES_COLLECTION, m_spIProfile, m_spIDictionary));

   // Time Of Day
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msNPTimeOfDay, &var));

   if(V_VT(&var) & VT_ARRAY)
   {
      m_strArrayTimeOfDay = V_ARRAY(&var);
      m_dwAttributeFlags |= PABF_msNPTimeOfDay;
   }
   else
      m_strArrayTimeOfDay.DeleteAll();

   // called station id
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msNPCalledStationId, &var));

   if(V_VT(&var) & VT_ARRAY)
   {
      m_strArrayCalledStationId = V_ARRAY(&var);
      m_dwAttributeFlags |= PABF_msNPCalledStationId;
   }
   else
      m_strArrayCalledStationId.DeleteAll();

   // allowed port types
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msNPAllowedPortTypes, &var));
   if(V_VT(&var) & VT_ARRAY)
   {
      m_dwArrayAllowedPortTypes = V_ARRAY(&var);
      m_dwAttributeFlags |= PABF_msNPAllowedPortTypes;
   }
   else
      m_dwArrayAllowedPortTypes.DeleteAll();

   // idle timeout
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRADIUSIdleTimeout, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwIdleTimeout = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRADIUSIdleTimeout;
   }
   else
      m_dwIdleTimeout = RAS_DEF_IDLETIMEOUT;

   // session time out
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRADIUSSessionTimeout, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwSessionTimeout = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRADIUSSessionTimeout;
   }
   else
      m_dwSessionTimeout = RAS_DEF_SESSIONTIMEOUT;

   //============================================
   // networking
   /*
   // Networking Dialog
      PROPERTY_PROFILE_msRADIUSFramedIPAddress
   */

   // framedIPAddress -- ip address assignment poilcy
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRADIUSFramedIPAddress, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwFramedIPAddress = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRADIUSFramedIPAddress;
   }
   else
      m_dwFramedIPAddress = RAS_DEF_IPADDRESSPOLICY;

   // filters
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASFilter, &var));
   if(V_VT(&var) & VT_ARRAY)
   {
      CBYTEArray ba((SAFEARRAY*)V_ARRAY(&var));

      DWORD i = ba.GetSize();
      if(i > 0)
      {
         PBYTE pByte = (PBYTE)malloc(i);
         if(pByte == NULL)
            CHECK_HR(hr = E_OUTOFMEMORY); // jmp to error handling here

         DWORD j = i;
         ba.GetBlob(pByte, &i);
         ASSERT( i == j);
         m_cbstrFilters.AssignBlob((const char *)pByte, i);

         free(pByte);

         if((BSTR)m_cbstrFilters == NULL)
            CHECK_HR(hr = E_OUTOFMEMORY);

         m_nFiltersSize = i;
         m_dwAttributeFlags |= PAFB_msRASFilter;
      }
   }
   else
   {
      m_cbstrFilters.Clean();
      m_nFiltersSize = 0;
   }

   //==============================================
   // multilink

   /*
   // Multilink Dialog
      PROPERTY_PROFILE_msRADIUSPortLimit
      PROPERTY_PROFILE_msRASBapLinednLimit
      PROPERTY_PROFILE_msRASBapLinednTime
      PROPERTY_PROFILE_msRASBapRequired
   */

   // port limit
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRADIUSPortLimit, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwPortLimit = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRADIUSPortLimit;
   }
   else
      m_dwPortLimit = RAS_DEF_PORTLIMIT;

   // BAP required
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASBapRequired, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwBapRequired = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRASBapRequired;
   }
   else
      m_dwBapRequired = RAS_DEF_BAPREQUIRED;

   // line down limit
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASBapLinednLimit, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwBapLineDnLimit = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRASBapLinednLimit;
   }
   else
      m_dwBapLineDnLimit = RAS_DEF_BAPLINEDNLIMIT;

   // line down time
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASBapLinednTime, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwBapLineDnTime = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRASBapLinednTime;
   }
   else
      m_dwBapLineDnTime = RAS_DEF_BAPLINEDNTIME;

   //==================================
   // authentication
   /*
   // Authentication Dialog
      PROPERTY_PROFILE_msNPAuthenticationType
      PROPERTY_PROFILE_msNPAllowedEapType
   */

   // authentication type
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msNPAuthenticationType, &var));
   if (V_VT(&var) & VT_ARRAY)
   {
      m_dwArrayAuthenticationTypes = V_ARRAY(&var);
      m_dwAttributeFlags |= PABF_msNPAuthenticationType;
   }
   else
   {
      m_dwArrayAuthenticationTypes.DeleteAll();
   }

   // eap type
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msNPAllowedEapType, &var));

   if (V_VT(&var) & VT_ARRAY)
   {
      m_dwArrayEapTypes = V_ARRAY(&var);
      m_dwAttributeFlags |= PABF_msNPAllowedEapType;
   }
   else
   {
      m_dwArrayEapTypes.DeleteAll();
   }

   // EAP Configuration
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(IAS_ATTRIBUTE_EAP_CONFIG, &var));
   if (V_VT(&var) != VT_ERROR)
   {
      CHECK_HR(hr = m_eapConfigData.Load(var));
   }

   //=====================================
   // encryption

   /*
   // Encryption Dialog
      PROPERTY_PROFILE_msRASAllowEncryption
      PROPERTY_PROFILE_msRASEncryptionType
   */

   // encryption type
   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASEncryptionType, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwEncryptionType = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRASEncryptionType;
   }
   else
      m_dwEncryptionType = RAS_DEF_ENCRYPTIONTYPE;

   VariantClear(&var);
   CHECK_HR(hr = m_SdoWrapper.GetProperty(PROPERTY_PROFILE_msRASAllowEncryption, &var));
   if(V_VT(&var) == VT_I4)
   {
      m_dwEncryptionPolicy = V_I4(&var);
      m_dwAttributeFlags |= PABF_msRASAllowEncryption;
   }
   else
      m_dwEncryptionPolicy = RAS_DEF_ENCRYPTIONPOLICY;

   // specail code for error path
L_ERR:
   VariantClear(&var);

   return hr;
}


//====================================================
//
// CRASProfile::Save
//
//
HRESULT CRASProfileMerge::Save()
{
   ASSERT(m_spIProfile.p);
   ASSERT(m_spIDictionary.p);

   VARIANT     var;
   HRESULT     hr = S_OK;

   VariantInit(&var);

   USES_CONVERSION;

   //==================================================
   // constraints dialog

   /*
   // Constraints Dialog
      PROPERTY_PROFILE_msNPTimeOfDay
      PROPERTY_PROFILE_msNPCalledStationId
      PROPERTY_PROFILE_msNPAllowedPortTypes
      PROPERTY_PROFILE_msRADIUSIdleTimeout
      PROPERTY_PROFILE_msRADIUSSessionTimeout
   */

   // idleTimeout
   if (m_dwAttributeFlags & PABF_msRADIUSIdleTimeout)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwIdleTimeout;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRADIUSIdleTimeout, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRADIUSIdleTimeout));

   // sessionTimeout
   if (m_dwAttributeFlags & PABF_msRADIUSSessionTimeout)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwSessionTimeout;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRADIUSSessionTimeout, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRADIUSSessionTimeout));

   // timeOfDay -- multivalue
   if (m_dwAttributeFlags & PABF_msNPTimeOfDay)
   {
      VariantClear(&var);
      V_VT(&var) =  VT_VARIANT | VT_ARRAY;
      V_ARRAY(&var) = (SAFEARRAY*)m_strArrayTimeOfDay;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msNPTimeOfDay, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msNPTimeOfDay));

   // calledStationId -- multivalue
   if (m_dwAttributeFlags & PABF_msNPCalledStationId)
   {
      VariantClear(&var);
      V_VT(&var) =  VT_VARIANT | VT_ARRAY;
      V_ARRAY(&var) = (SAFEARRAY*)m_strArrayCalledStationId;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msNPCalledStationId, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msNPCalledStationId));

   // allowedPortTypes
   if (m_dwAttributeFlags & PABF_msNPAllowedPortTypes)
   {
      VariantClear(&var);
      V_VT(&var) =  VT_VARIANT | VT_ARRAY;
      V_ARRAY(&var) = (SAFEARRAY*)m_dwArrayAllowedPortTypes;

      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msNPAllowedPortTypes, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msNPAllowedPortTypes));


   //==================================
   // authentication

   /*
   // Authentication Dialog
      PROPERTY_PROFILE_msNPAuthenticationType
      PROPERTY_PROFILE_msNPAllowedEapType
   */

   // authentication type -- must
   VariantClear(&var);
   if (m_dwAttributeFlags & PABF_msNPAuthenticationType)
   {
      VariantClear(&var);
      V_VT(&var) =  VT_VARIANT | VT_ARRAY;
      V_ARRAY(&var) = (SAFEARRAY*)m_dwArrayAuthenticationTypes;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msNPAuthenticationType, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msNPAllowedEapType));
   }

   if (m_dwArrayAuthenticationTypes.Find(RAS_AT_EAP) != -1)
   {
      VariantClear(&var);
      V_VT(&var) =  VT_VARIANT | VT_ARRAY;
      V_ARRAY(&var) = (SAFEARRAY*)m_dwArrayEapTypes;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msNPAllowedEapType, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msNPAllowedEapType));
   }

   if (m_eapConfigData.IsEmpty())
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(IAS_ATTRIBUTE_EAP_CONFIG));
   }
   else
   {
      VariantClear(&var);
      CHECK_HR(hr = m_eapConfigData.Store(var));
      CHECK_HR(hr = m_SdoWrapper.PutProperty(IAS_ATTRIBUTE_EAP_CONFIG, &var));
   }

   //=====================================
   // encryption

   /*
   // Encryption Dialog
      PROPERTY_PROFILE_msRASAllowEncryption
      PROPERTY_PROFILE_msRASEncryptionType
   */

   // encryption type -- must
   if (m_dwAttributeFlags & PABF_msRASEncryptionType)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwEncryptionType;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASEncryptionType, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASEncryptionType));
   }

   if (m_dwAttributeFlags & PABF_msRASAllowEncryption)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwEncryptionPolicy;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASAllowEncryption, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASAllowEncryption));
   }

   //=====================================
   // networking

   /*
   // Networking Dialog
      PROPERTY_PROFILE_msRADIUSFramedIPAddress
   */

   // framedIPAddress -- ip address assignment poilcy, must
   if (m_dwAttributeFlags & PABF_msRADIUSFramedIPAddress)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwFramedIPAddress;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRADIUSFramedIPAddress, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRADIUSFramedIPAddress));

   // RAS filter
   if ((BSTR)m_cbstrFilters && m_nFiltersSize > 0)
   {
      VariantClear(&var);
      {
         CBYTEArray  ba;

         ba.AssignBlob((PBYTE)(BSTR)m_cbstrFilters, m_nFiltersSize);
         V_VT(&var) = VT_ARRAY | VT_UI1;
         V_ARRAY(&var) = (SAFEARRAY*)ba;
      }
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASFilter, &var));
      VariantInit(&var);   // the CBSTR will clean the memory
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASFilter));


   //=====================================
   // multilink

   /*
   // Multilink Dialog
      PROPERTY_PROFILE_msRADIUSPortLimit
      PROPERTY_PROFILE_msRASBapLinednLimit
      PROPERTY_PROFILE_msRASBapLinednTime
      PROPERTY_PROFILE_msRASBapRequired
   */

   //port limit
   if (m_dwAttributeFlags & PABF_msRADIUSPortLimit)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwPortLimit;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRADIUSPortLimit, &var));
   }
   else
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRADIUSPortLimit));

   // BAP
   if (m_dwAttributeFlags & PABF_msRASBapRequired)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwBapRequired;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASBapRequired, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASBapRequired));
   }

   // line down limit
   if (m_dwAttributeFlags & PABF_msRASBapLinednLimit)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwBapLineDnLimit;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASBapLinednLimit, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASBapLinednLimit));
   }

   // line down time
   if (m_dwAttributeFlags & PABF_msRASBapLinednTime)
   {
      VariantClear(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = m_dwBapLineDnTime;
      CHECK_HR(hr = m_SdoWrapper.PutProperty(PROPERTY_PROFILE_msRASBapLinednTime, &var));
   }
   else
   {
      CHECK_HR(hr = m_SdoWrapper.RemoveProperty(PROPERTY_PROFILE_msRASBapLinednTime));
   }

   // specail code for error path
L_ERR:
   VariantClear(&var);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\rasdial.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   rasdial.h
      Definition of CRASProfile class and CRASUser class

      CRASProfile handles operations related to profile object in DS,
         including: load, save, enumerate all the profiles

      CRASUser handles operations related to RASUser object in DS,
         including: load, save

    FILE HISTORY:

*/
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RASPROFILE_H__484FE2B0_20A8_11D1_8531_00C04FC31FD3__INCLUDED_)
#define AFX_RASPROFILE_H__484FE2B0_20A8_11D1_8531_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <dialinusr.h>
#include "eapprofile.h"
#include "helper.h"
#include <sdowrap.h>
#include "sharesdo.h"
#include <rtutils.h>

class   CRASUSER;
class   CRASProfile;

// constant definitions for the dialogs
#define MIN_METRIC     1
#define MAX_METRIC     0x7fffffff
#define MIN_PREFIXLEN  1
#define MAX_PREFIXLEN   32

// constraint dialog
#define MAX_LOGINS     (UD_MAXVAL - 1)
#define MAX_IDLETIMEOUT   (UD_MAXVAL - 1)
#define MAX_SESSIONTIME   (UD_MAXVAL - 1)

#define MAX_PORTLIMIT   (UD_MAXVAL - 1)
#define MAX_PERCENT    100
#define MAX_TIME     (UD_MAXVAL - 1)


enum RasEnvType
{
   RASUSER_ENV_LOCAL = 1,
   RASUSER_ENV_DS
};

// Port Types definition
struct CName_Code{
   LPCTSTR  m_pszName;
   int      m_nCode;
};

extern CName_Code PortTypes[];
#ifdef   _TUNNEL
extern CName_Code TunnelTypes[];
extern CName_Code TunnelMediumTypes[];
#endif
// enumeration buffer size
#define  MAX_ENUM_IADS  20

//
//
// CRASProfile class encapsulate the RASProfile object in DS
//
// Data type mapping:
//    interger32 --> DWORD,   BSTR (String) --> CString
//    BSTR (String) multi-value --> CStrArray
//    BOOLEAN  --> BOOL
//
// Member Functions:
//    Load(LPCWSTR      pcswzUserPath)
//       Purpose:    Load the data from DS, and fill the data members
//       pcswzUserPath: the ADsPath to the user object that contains
//    Save(LPCWSTR   pcswzUserPath)
//       Purpose:    Save the data to DS under specified user object
//       pcswzUserPath: the ADsPath for the container, when NULL, the ADsPath
//                   used for loading is used.
//

// profile attribute bit flags PABF
#define     PABF_msNPTimeOfDay            0x00000002
#define     PABF_msNPCalledStationId      0x00000004
#define     PABF_msNPAllowedPortTypes     0x00000008
#define     PABF_msRADIUSIdleTimeout      0x00000010
#define     PABF_msRADIUSSessionTimeout      0x00000020
#define     PABF_msRADIUSFramedIPAddress  0x00000040
#define     PABF_msRADIUSPortLimit        0x00000080
#define     PABF_msRASBapRequired         0x00000100
#define     PABF_msRASBapLinednLimit      0x00000200
#define     PABF_msRASBapLinednTime       0x00000400
#define     PABF_msNPAuthenticationType      0x00000800
#define     PABF_msNPAllowedEapType       0x00001000
#define     PABF_msRASEncryptionType      0x00002000
#define     PABF_msRASAllowEncryption     0x00004000
#define     PAFB_msRASFilter           0x00008000

class CRASProfileMerge
{
public:
   HRESULT Save();   // To SDO
   HRESULT Load();   // Using SDO

   CRASProfileMerge(ISdo* pIProfile, ISdoDictionaryOld* pIDictionary)
   {
      ASSERT(pIProfile);
      ASSERT(pIDictionary);
      m_spIProfile = pIProfile;
      m_spIDictionary = pIDictionary;
      m_dwAttributeFlags = 0;
      m_nFiltersSize = 0;
   }

   virtual ~CRASProfileMerge()
   {
   }

public:
   // BIT flag for each attribute
   DWORD    m_dwAttributeFlags;

   // networking page
   DWORD    m_dwFramedIPAddress;
   CBSTR    m_cbstrFilters;
   UINT     m_nFiltersSize;   // in bytes

   // constraints page
   CDWArray m_dwArrayAllowedPortTypes;
   DWORD    m_dwSessionTimeout;
   DWORD    m_dwIdleTimeout;
   CStrArray   m_strArrayCalledStationId;
   DWORD    m_dwSessionAllowed;
   CStrArray   m_strArrayTimeOfDay;

   // authentication page
   CDWArray m_dwArrayAuthenticationTypes;
   CDWArray m_dwArrayEapTypes;
   EapProfile m_eapConfigData;

   // multilink page
   DWORD    m_dwPortLimit;
   DWORD    m_dwBapLineDnLimit;
   DWORD    m_dwBapLineDnTime;
   BOOL     m_dwBapRequired;

   // encryption page
   DWORD      m_dwEncryptionType;
   DWORD      m_dwEncryptionPolicy;

public:
   // EAP type list -- !!! Need to implement
   HRESULT  GetEapTypeList(CStrArray& EapTypes, CDWArray& EapIds, CDWArray& EapTypeKeys, AuthProviderArray* pProvList);

   // to detect if driver level support 128 bit encryption,
   HRESULT  GetRasNdiswanDriverCaps(RAS_NDISWAN_DRIVER_INFO *pInfo);

   // Medium Type list -- !! Need to implement
   HRESULT  GetPortTypeList(CStrArray& Names, CDWArray& MediumIds);
   void  SetMachineName(LPCWSTR pMachineName){ m_strMachineName = pMachineName;};
   // the management key of the current EAP type, empty means not set
   CDWArray    m_dwArraynEAPTypeKeys;

public:
   CComPtr<ISdo>     m_spIProfile;
   CComPtr<ISdoDictionaryOld>    m_spIDictionary;
   CSdoWrapper       m_SdoWrapper;
   CString           m_strMachineName;
};

//
// CRASUser class encapsulate the RASUser object contained in user objectin DS
//
// Data type mapping:
//    interger32 --> DWORD,   BSTR (String) --> CString
//    BSTR (String) multi-value --> CStrArray
//    BOOLEAN  --> BOOL
//
// Member Functions:
//    Load(LPCWSTR pcswzUserPath)
//       Purpose:    Load the data from DS, and fill the data members
//       pcswzUserPath: the ADsPath to the user object that contains
//    Save(LPCWSTR pcswzUserPath)
//       Purpose:    Save the data to DS under specified user object
//       pcswzUserPath: the ADsPath for the container, when NULL, the ADsPath
//                   used for loading is used.
//    ChangeProfile(LPCWSTR pcswzProfilePath)
//       Purpose:    use profile specified in the path
//       pcswzProfilePath: the ADsPath of the profile
//
class CMarshalSdoServer;
class CRASUserMerge
{
public:
   CRASUserMerge(RasEnvType type, LPCWSTR location, LPCWSTR userPath);

   ~CRASUserMerge()
   {
      // to test if problem is within here, to explicitly
      m_spISdoServer.Release();
   };

   // read or write information from DS
   virtual HRESULT Load();
   virtual HRESULT   Save();

#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
   CMarshalSdoServer*   GetMarshalSdoServerHolder() { return &m_MarshalSdoServer;};
#endif

   HRESULT  HrGetDCName(CString& DcName);
protected:
   BOOL   IfAccessAttribute(ULONG id);
   HRESULT   SetRegistryFootPrint();
   HRESULT   HrIsInMixedDomain();
   BOOL IsFocusOnLocalUser() const throw ()
   {
      return (!m_strMachine.IsEmpty());
   }

protected:
   // data members for the RAS User attribute defined in DS

   // this defines if dialin is allowed, and also the policy for callback
   // RAS_CALLBACK_CALLERSET, RAS_CALLBACK_SECURE is the mask
   DWORD    m_dwDialinPermit; //1: allow, 0: deny, -1: not defined
   DWORD    m_dwDefinedAttribMask;

   // static IP address
   // when m_bStaticIPAddress == false,  m_dwFramedIPAddress is invalide
   // m_bStaticIPAddress is not an attribute in DS
   DWORD      m_dwFramedIPAddress;

   // CALLBACK
   CString     m_strCallbackNumber;

   // the static routes
   CStrArray   m_strArrayFramedRoute;

   // caller id
   CStrArray   m_strArrayCallingStationId;

protected:
   CComPtr<ISdoMachine>   m_spISdoServer;
   CUserSdoWrapper         m_SdoWrapper;
   CString        m_strUserPath; // the container's ADsPath
   CString        m_strMachine;  // when it's for a machine with NO DS, this will be useful
   RasEnvType     m_type;
#ifdef SINGLE_SDO_CONNECTION  // for share the same sdo connection for multiple users
   CMarshalSdoServer m_MarshalSdoServer;
#endif
};

#endif // !defined(AFX_RASPROFILE_H__484FE2B0_20A8_11D1_8531_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\profsht.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   profsht.h
      Definition of CProfileSheet -- property sheet to hold
      profile property pages

    FILE HISTORY:
        
*/
#if !defined(AFX_PROFSHT_H__8C28D93B_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
#define AFX_PROFSHT_H__8C28D93B_2A69_11D1_853E_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProfSht.h : header file
//

#include "pgconst.h"
#include "pgnetwk.h"
#include "pgmulnk.h"
#include "pgtunnel.h"
#include "pgauthen.h"
#include "pgauthen2k.h"
#include "pgencryp.h"
#include "rasdial.h"
#include "pgencryp.h"
#include "pgiasadv.h"

/////////////////////////////////////////////////////////////////////////////
// CProfileSheetMerge

class CProfileSheetMerge : public CPropertySheet, public CPageManager
{
   DECLARE_DYNAMIC(CProfileSheetMerge)

// Construction
public:
   CProfileSheetMerge(CRASProfileMerge& Profile, bool bSaveOnApply, UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
   CProfileSheetMerge(CRASProfileMerge& Profile, bool bSaveOnApply, LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

   // abstract function OnApply
   virtual BOOL   OnApply();

   BOOL  IsApplied() { return m_bApplied;};
   BOOL  m_bApplied;       // the Applied button has been pressed

   void  PreparePages(DWORD dwTabFlags, void* pvData);

   DWORD m_dwTabFlags;

   
// Attributes
public:

// Operations
public:

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CProfileSheetMerge)
   public:
   virtual BOOL OnInitDialog();
   //}}AFX_VIRTUAL

// Implementation
public:
   virtual ~CProfileSheetMerge();
   HRESULT  GetLastError() { return m_hrLastError;};

   CRASProfileMerge* m_pProfile;

   CPgConstraintsMerge  m_pgConstraints;
   CPgNetworkingMerge   m_pgNetworking;
   CPgMultilinkMerge m_pgMultilink;
   CPgAuthenticationMerge  m_pgAuthentication;
   CPgAuthentication2kMerge   m_pgAuthentication2k;
   CPgEncryptionMerge   m_pgEncryption;

   // the advanced page for IAS
   CPgIASAdv      m_pgIASAdv;
   
   bool        m_bSaveOnApply;

   HRESULT        m_hrLastError;
   
   // Generated message map functions
protected:
   //{{AFX_MSG(CProfileSheetMerge)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROFSHT_H__8C28D93B_2A69_11D1_853E_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\rasprof.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       rasprof.h
//
//--------------------------------------------------------------------------

#ifndef	_RAS_IAS_PROFILE_H_
#define	_RAS_IAS_PROFILE_H_

//========================================
//
// Open profile UI API -- expose advanced page
//
// create a profile advanced page
DllExport HPROPSHEETPAGE
WINAPI
IASCreateProfileAdvancedPage(
    ISdo* pProfile,		
    ISdoDictionaryOld* pDictionary,
    LONG lFilter,          // Mask used to test which attributes will be included.
    void* pvData          // Contains std::vector< CComPtr<  IIASAttributeInfo > > *
    );


//========================================
//
// Open profile UI API -- expose advanced page
//
// clean up the resources used by C++ object
DllExport BOOL
WINAPI
IASDeleteProfileAdvancedPage(
	HPROPSHEETPAGE	hPage
    );

//========================================
//
// Open profile UI API
//

DllExport HRESULT OpenRAS_IASProfileDlg(
	LPCWSTR	pMachineName,
	ISdo*	pProfile, 		// profile SDO pointer
	ISdoDictionaryOld *	pDictionary, 	// dictionary SDO pointer
	BOOL	bReadOnly, 		// if the dlg is for readonly
	DWORD	dwTabFlags,		// what to show
	void	*pvData			// additional data

);
    

#endif //	_RAS_IAS_PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\rasuser.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    rasuser.cpp
//
// SYNOPSIS
//
//  Define and Implement the application class for RASUser component 
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "rasdial.h"
#include "Dialin.h"
#include "sharesdo.h"

// tfscore -- for registering extension snapin
#include "std.h"
#include "compont.h"
#include "compdata.h"
#include "register.h"

#include <atlimpl.cpp>
#include <ntverp.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_RasDialin, CRasDialin)
END_OBJECT_MAP()

class CRasdialApp : public CWinApp
{
public:
   virtual BOOL InitInstance();
   virtual int ExitInstance();
};

CRasdialApp theApp;

BOOL CRasdialApp::InitInstance()
{
   _Module.Init(ObjectMap, m_hInstance);

   g_pSdoServerPool = NULL;
   return CWinApp::InitInstance();
}

int CRasdialApp::ExitInstance()
{
   _Module.Term();
   
   return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

/* extern */ const CLSID CLSID_LocalUser =
{  /* 5d6179c8-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c8,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};
/* extern */ const GUID NODETYPE_User =
{ /* 5d6179cc-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179cc,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const GUID NODETYPE_LocalSecRootFolder =
{  /* 5d6179d3-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179d3,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const GUID NODETYPE_DsAdminDomain = 
{ /* 19195a5b-6da0-11d0-afd3-00c04fd930c9 */
   0x19195a5b,
   0x6da0,
   0x11d0,
   {0xaf, 0xd3, 0x00, 0xc0, 0x4f, 0xd9, 0x30, 0xc9}

};


STDAPI DllRegisterServer(void)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // registers object, typelib and all interfaces in typelib
   HRESULT hr = _Module.RegisterServer(FALSE);
   if (FAILED(hr))
   {
      return hr;
   }
   
   // registers the object with Admin property page for User Object
#ifdef   _REGDS
   if(S_OK == hr)
      hr = CRasDialin::RegisterAdminPropertyPage(true);
#endif

   hr = SELFREG_E_CLASS;
   CString strDesc;
   BOOL loaded = strDesc.LoadString(IDS_SNAPIN_DESC);
   if (!loaded)
   {
      return hr;
   }

   CString strIndirectPrefix = L"@rasuser.dll,-";
   CString strIndirectPostFix;
   wchar_t postFix[33];
   _ltow(IDS_SNAPIN_DESC, postFix, 10);
   CString strIndirect = strIndirectPrefix + postFix;

   // register it as extension to localsecurity snapin
   //
   hr = RegisterSnapinGUID(&CLSID_RasDialin, 
                  &CLSID_RasDialin,    // fake, no about for now
                  &CLSID_RasDialin, 
                  strDesc, 
                  LVER_PRODUCTVERSION_STR, 
                  FALSE,
                  strIndirect
                  );
   if (FAILED(hr))
   {
      return hr;
   }
   
   hr = RegisterAsRequiredExtensionGUID(
                     &NODETYPE_User, 
                     &CLSID_RasDialin, 
                     strDesc,
                     EXTENSION_TYPE_PROPERTYSHEET,
                     NULL
                     ); 
   if (FAILED(hr))
   {
      return hr;
   }
                     
   hr = RegisterAsRequiredExtensionGUID(
                     &NODETYPE_LocalSecRootFolder, 
                     &CLSID_RasDialin, 
                     strDesc,
                     EXTENSION_TYPE_NAMESPACE,
                     NULL
                     ); 
   if (FAILED(hr))
   {
      return hr;
   }
                     
   hr = RegisterAsRequiredExtensionGUID(
                     &NODETYPE_DsAdminDomain, 
                     &CLSID_RasDialin, 
                     strDesc,
                     EXTENSION_TYPE_NAMESPACE,
                     NULL
                     ); 
                    
   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
   // Note: on purpose, the snapin nodes are not unregistered because 
   // they are part of the OS (dialin tab).
   _Module.UnregisterServer();
#ifdef   _REGDS
   if(FAILED(CRasDialin::RegisterAdminPropertyPage(false)))
      return SELFREG_E_CLASS;
#endif      

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\resource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//////////////////////////////////////////////////////////////////////////////

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rasuser.rc
//
#define IDS_PROJNAME                    100
#define IDS_FAILREADDC                  101
#define IDR_RASDIALIN                   102
#define IDS_FAILGETDOMAINPATH           102
#define IDS_FAILBINDTOCONFIGURE         103
#define IDS_OUTOFMEMORY                 105
#define IDS_DESTINATION                 109
#define IDS_MASK                        110
#define IDS_METRIC                      111
#define IDS_EDITDIALINPROFILE           112
#define IDS_UNLIMITED                   113
#define IDS_ERR_NEEDPORTTYPE            114
#define IDS_ERR_NEEDTIMEOFDAY           115
#define IDS_ERR_NOTNT5SRV               116
#define IDS_MIN_CHARS                   150
#define IDS_ERR_ERRORCODE               154
#define IDS_ERR_TITLE                   155
#define IDS_ERR_PROPERTYPAGE            162
#define IDS_ERR_LOADLOGHOURDLL          163
#define IDS_ERR_FINDLOGHOURSAPI         164
#define IDS_ERR_CALLBACK_TOO_LONG       165
#define IDS_ERR_CALLBACK_INVALID        166
#define IDD_STATICROUTES                202
#define IDD_ADDROUTE                    203
#define IDC_CHECKCALLERID               204
#define IDC_EDITCALLERID                205
#define IDD_CONSTRAINTS_MERGE           205
#define IDC_RADIONOCALLBACK             206
#define IDC_RADIOSETBYCALLER            207
#define IDC_RADIOSECURECALLBACKTO       208
#define IDC_EDITIPADDRESS               210
#define IDC_CHECKAPPLYSTATICROUTES      212
#define IDC_BUTTONSTATICROUTES          213
#define IDC_EDITCALLBACK                214
#define IDD_RASDIALIN_MERGE             214
#define IDI_ICON1                       215
#define IDD_IAS_ATTRIBUTE_ADD           216
#define IDD_IAS_ADVANCED_TAB            217
#define IDD_MULTILINK_MERGE             218
#define IDD_NETWORKING_MERGE            219
#define IDC_EDITMETRIC                  220
#define IDD_AUTHENTICATION_MERGE        220
#define IDC_SPINMETRIC                  221
#define IDD_ENCRYPTION_MERGE            221
#define IDC_EDITIDLETIME                228
#define IDC_SPINIDLETIME                229
#define IDC_EDITMAXSESSION              230
#define IDC_SPINMAXSESSION              231
#define IDC_CHECKCALLNUMBER             232
#define IDC_EDITCALLNUMBER              233
#define IDC_CHECKRESTRICTPERIOD         235
#define IDC_RADIOSERVER                 245
#define IDC_RADIOCLIENT                 247
#define IDC_EDITMAXPORTS                248
#define IDC_SPINMAXPORTS                249
#define IDC_EDITPERCENT                 250
#define IDC_SPINPERCENT                 251
#define IDC_EDITTIME                    252
#define IDC_SPINTIME                    253
#define IDC_CHECKEAP                    261
#define IDC_CHECKMSCHAP                 262
#define IDC_CHECKMD5CHAP                263
#define IDC_CHECKPAP                    264
#define IDC_CHECKMSCHAP2                265
#define IDC_CHECKNOAUTHEN               267
#define IDC_CHECKMSCHAPPASS             268
#define IDC_CHECKMSCHAP2PASS            269
#define IDC_COMBOEAPTYPE                277
#define IDC_CHECKSTATICIPADDRESS        282
#define IDC_EDITDEST                    283
#define IDC_EDITMASK                    284
#define IDC_BUTTONEDITTIMEOFDAY         304
#define IDC_LISTTIMEOFDAY               305
#define IDC_CHECKSESSIONLEN             321
#define IDC_CHECKIDLE                   322
#define IDC_COMBOUNIT                   327
#define IDC_LIST_PORTTYPES              331
#define IDC_RADIODEFAULT                332
#define IDC_IAS_LIST_ATTRIBUTES_IN_PROFILE 336
#define IDC_IAS_LIST_ATTRIBUTES_TO_CHOOSE_FROM 337
#define IDC_LISTROUTES                  342
#define IDC_BUTTONADDROUTE              343
#define IDC_BUTTONDELETEROUTE           344
#define IDC_CHECK_PORTTYPES             363
#define IDC_PERMIT_ALLOW                364
#define IDC_PERMIT_DENY                 365
#define IDC_PERMIT_POLICY               366
#define IDC_CHECKREQUIREBAP             367
#define IDC_RADIO_MULNK_NOTDEFINED      368
#define IDC_RADIO_MULNK_SINGLE          369
#define IDC_RADIO_MULNK_MULTI           370
#define IDC_BUTTON_FROMCLIENT           371
#define IDC_BUTTON_TOCLIENT             372
#define IDC_FAILED_TO_INIT              373
#define IDC_AUTH_CONFIG_EAP             374
#define IDC_EAP_METHODS                 375
#define IDC_CHECK_ENC_NONE              377
#define IDC_CHECK_ENC_BASIC             378
#define IDC_CHECK_ENC_STRONG            379
#define IDC_CHECK_ENC_STRONGEST         380
#define IDD_AUTHENTICATION2K_MERGE      381
#define IDS_PREFIXLENGTH                891
#define IDS_DIALINHOURS                 892
#define IDS_FAILED_LOAD_PROFILE         897
#define IDS_FAILED_FIND_PROFILE         898
#define IDS_FAILED_SAVE_RASUSEROBJ      905
#define IDS_FAILED_SAVE_RASPROFILEOBJ   906
#define IDS_DATAENTRY_INCOMPLETE        909
#define IDS_MONDAY                      910
#define IDS_TUESDAY                     911
#define IDS_WEDNESDAY                   912
#define IDS_THURSDAY                    913
#define IDS_FRIDAY                      914
#define IDS_SATURDAY                    915
#define IDS_SUNDAY                      916
#define IDS_INVALIDADDR                 917
#define IDS_ERR_NEEDPHONENUMBER         918
#define IDS_DATAENTRY_ENCRYPTIONTYPE    919
#define IDS_NO_PER_POLICY_EAP           920
#define IDS_ERR_SAVEPROFILE             57345
#define IDS_DATAENTRY_NOTEMPTY          57346
#define IDS_DATAENTRY_EAPTYPE           57347
#define IDS_DATAENTRY_STATICROUTE       57348
#define IDS_INVALIDMASK                 57349
#define IDS_ERR_PORTTYPELIST            57350
#define IDS_ERR_SAVEUSER                57351
#define IDS_IAS_ATTRIBUTES_COLUMN_NAME  57352
#define IDS_IAS_ATTRIBUTES_COLUMN_VENDOR 57353
#define IDS_IAS_ATTRIBUTES_COLUMN_VALUE 57354
#define IDS_IAS_ATTRIBUTES_COLUMN_DESCRIPTION 57355
#define IDS_IAS_ERR_ADVANCED            57356
#define IDS_ERR_DATAENTRY               57357
#define IDS_IAS_ERR_CHANGEVALUETYPE     57358
#define IDS_IAS_ERR_ADVANCED_LISTCTRL   57359
#define IDS_IAS_ERR_SDOERROR_GETATTRINFO 57360
#define IDS_IAS_ERR_SDOERROR_QUERYINTERFACE 57361
#define IDS_IAS_ERR_SDOERROR_CREATEATTR 57362
#define IDS_IAS_ERR_SDOERROR_GETPROPERTY 57363
#define IDS_IAS_ERR_SDOERROR_PUTPROPERTY 57364
#define IDS_IAS_ERR_INVALIDBOOL         57365
#define IDS_IAS_ERR_INVALIDINTEGER      57366
#define IDS_ERR_CONFIG_EAP              57367
#define IDS_ERR_EAPTYPELIST             57368
#define IDS_DATAENTRY_AUTHENTICATIONTYPE 57369
#define IDS_ERR_LOADUSER                57370
#define IDS_IAS_ERR_INVALIDDATATYPE     57371
#define IDS_IAS_ERR_SDOERROR_APPLY      57372
#define IDS_IAS_ERR_SDOERROR_COLLECTION 57373
#define IDS_IAS_ERR_ADD_ATTR            57375
#define IDS_IAS_ERR_ADVANCED_EMPTY_ATTRLIST 57376
#define IDS_IAS_ERR_ADVANCED_PROFATTRLIST 57377
#define IDS_IAS_ERR_SDOERROR_PUTPROPERTY_ATTRIBUTE_VALUE 57383
#define IDS_IAS_ATTRIBUTE_ALREADY_IN_PROFILE 57384
#define IDC_IAS_BUTTON_ATTRIBUTE_ADD    57385
#define IDS_RASSPECIFIC                 57385
#define IDC_IAS_BUTTON_ATTRIBUTE_EDIT   57386
#define IDC_IAS_BUTTON_ATTRIBUTE_REMOVE 57387
#define IDC_IAS_BUTTON_ATTRIBUTE_ADD_SELECTED 58000
#define IDS_IAS_TITLE_ATTRIBUTE_ALREADY_IN_PROFILE 58001
#define IDS_WARN_MORE_STEPS_FOR_AUTHEN  58002
#define IDS_NEED_CALLER_ID          58003
#define IDS_NEED_CALLBACK_NUMBER    58004
#define IDS_NEED_IPADDRESS          58005
#define IDS_MIN                     58006
#define IDS_SEC                     58007
#define IDC_RADIOSTATIC             58008
#define IDC_EDIT_STATIC_IP_ADDRESS  58009
#define IDD_EAP_NEGOCIATE                 58010
#define IDC_BUTTON_ADD_EAP_PROVIDER       58011
#define IDC_BUTTON_EDIT_EAP_PROVIDER      58012
#define IDC_BUTTON_REMOVE_EAP_PROVIDER    58013
#define IDC_LIST_EAP_SELECTED             58014
#define IDC_BUTTON_EAP_UP                 58015
#define IDC_BUTTON_EAP_DOWN               58016
#define IDD_EAP_ADD                       58017
#define IDC_LIST_EAP_ADD                  58018
#define IDC_BUTTON_EAP_ADD_ADD            58019
#define IDC_BUTTON_EAP_ADD_CANCEL         58020
#define IDC_ADVANCED_RAP                  58021
#define IDC_ADVANCED_CRP                  58022
#define IDS_SNAPIN_DESC                   58023
#define IDS_ERROR_IP_FILTER_TOO_BIG       58024

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         378
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\rasprof.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       rasprof.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "rasdial.h"
#include "rasprof.h"
#include "profsht.h"
#include "pgiasadv.h"

//========================================
//
// Open profile UI API -- expose advanced page
//
// critical section protected pointer map
class CAdvPagePointerMap
{
public:
	~CAdvPagePointerMap()
	{
		HPROPSHEETPAGE hPage = NULL;
		CPgIASAdv* pPage = NULL;
		m_cs.Lock();
		POSITION	pos = m_mPointers.GetStartPosition();
		while(pos)
		{
			m_mPointers.GetNextAssoc(pos, hPage, pPage);
			if(pPage)
				delete pPage;
		}
		m_mPointers.RemoveAll();
		m_cs.Unlock();
	};

	BOOL AddItem(HPROPSHEETPAGE hPage, CPgIASAdv* pPage)
	{
		BOOL bRet = TRUE;
		
		if(!pPage || !hPage)
			return FALSE;
		m_cs.Lock();
		
		try{
			m_mPointers.SetAt(hPage, pPage);
		}catch(...)
		{
			bRet = FALSE;
		}
		
		m_cs.Unlock();

		return bRet;
	};
	
	CPgIASAdv* FindAndRemoveItem(HPROPSHEETPAGE hPage)
	{
		CPgIASAdv* pPage = NULL;
		if (!hPage)
			return NULL;
		m_cs.Lock();
		m_mPointers.Lookup(hPage, pPage);
		m_mPointers.RemoveKey(hPage);
		m_cs.Unlock();

		return pPage;
	};

protected:
	CMap<HPROPSHEETPAGE, HPROPSHEETPAGE, CPgIASAdv*, CPgIASAdv*>	m_mPointers;
	CCriticalSection	m_cs;
} AdvancedPagePointerMap;

//========================================
//
// Open profile UI API -- expose advanced page
//
// create a profile advanced page
DllExport HPROPSHEETPAGE
WINAPI
IASCreateProfileAdvancedPage(
    ISdo* pProfile,		
    ISdoDictionaryOld* pDictionary,
    LONG lFilter,          // Mask used to test which attributes will be included.
    void* pvData          // Contains std::vector< CComPtr<  IIASAttributeInfo > > *
    )
{
	HPROPSHEETPAGE	hPage = NULL;
	CPgIASAdv* pPage = NULL;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	try{
		pPage = new CPgIASAdv(pProfile, pDictionary);

		if(pPage)
		{
			pPage->SetData(lFilter, pvData);
			hPage = ::CreatePropertySheetPage(&pPage->m_psp);

			if (!hPage)
				delete pPage;
			else
				AdvancedPagePointerMap.AddItem(hPage, pPage);
		}
	}
	catch (...)
	{ 
		SetLastError(ERROR_OUTOFMEMORY);
		if(pPage)
		{
			delete pPage;
			pPage = NULL;
			hPage = NULL;
		}
	}

	return hPage;
}

//========================================
//
// Open profile UI API -- expose advanced page
//
// clean up the resources used by C++ object
DllExport BOOL
WINAPI
IASDeleteProfileAdvancedPage(
	HPROPSHEETPAGE	hPage
    )
{
	CPgIASAdv* pPage = AdvancedPagePointerMap.FindAndRemoveItem(hPage);

	if (!pPage)	return FALSE;
	
	delete pPage;

	return TRUE;
}

//========================================
//
// Open profile UI API
//

DllExport HRESULT OpenRAS_IASProfileDlg(
	LPCWSTR	pMachineName,
	ISdo*	pProfile, 		// profile SDO pointer
	ISdoDictionaryOld *	pDictionary, 	// dictionary SDO pointer
	BOOL	bReadOnly, 		// if the dlg is for readonly
	DWORD	dwTabFlags,		// what to show
	void	*pvData			// additional data

)
{
	HRESULT		hr = S_OK;

	if(!pProfile || !pDictionary)
		return E_INVALIDARG;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CRASProfileMerge	profile(pProfile, pDictionary);

	profile.SetMachineName(pMachineName);

	hr = profile.Load();

	if(!FAILED(hr))
	{
		CProfileSheetMerge	sh(profile, true, IDS_EDITDIALINPROFILE);

		sh.SetReadOnly(bReadOnly);
		sh.PreparePages(dwTabFlags, pvData);
	
		if(IDOK == sh.DoModal())
		{
			if(sh.GetLastError() != S_OK)
				hr = sh.GetLastError();
			else if(!sh.IsApplied())
				hr = S_FALSE;
		}
		else
			hr = S_FALSE;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\vendors.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Vendors.cpp

Abstract:

	Implementation file for NAS Vendor ID info.

	This will be moved into the SDO's at some point so that the server core 
	can access this information as well.


Author:

    Michael A. Maguire 02/19/98

Revision History:
	mmaguire 02/19/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined( _IAS_VENDORS_H_ )
#define _IAS_VENDORS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// The structure which has the vendors.
typedef
struct tag_Vendor
{
	DWORD dwID;
	TCHAR * szName;
} Vendor;


// The array of Vendor structures.
extern Vendor g_aVendors[];
extern int	  g_iVendorNum;

// invalid vendorid
#define INVALID_VENDORID	-1


// Searches for a given vendor ID and returns its position in the array of vendors.
int VendorIDToOrdinal( DWORD dwID );



#endif // _IAS_VENDORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\sdowrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       sdowrap.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "rasdial.h"
#include "sdowrap.h"
#include "profsht.h"
#include "iastrace.h"

//========================================
//
// CSdoWrapper Class Implementation
//
CSdoWrapper::~CSdoWrapper()
{
   // clear the map
   POSITION pos = m_mapProperties.GetStartPosition();

   ULONG id;
   ISdo* pSdo = NULL;

   while(pos)
   {
      pSdo = NULL;
      m_mapProperties.GetNextAssoc(pos, id, pSdo);
      
      if(pSdo)
         pSdo->Release();
   }

   m_mapProperties.RemoveAll();
}

// Initialize the map of the attribute collection object
HRESULT  CSdoWrapper::Init(ULONG collectionId, ISdo* pISdo, ISdoDictionaryOld* pIDic)
{
   HRESULT     hr = S_OK;
   VARIANT     var;
   VARIANT* pVar = NULL;
   CComPtr<IEnumVARIANT>   spEnum;
   CComPtr<IUnknown>    spIUnk;
   ULONG    count = 0;

   VariantInit(&var);

   // it must be new
   ASSERT(!m_spISdoCollection.p);
   ASSERT(!m_spIDictionary.p);
   ASSERT(!m_spISdo.p);

   // must be valid
   ASSERT(pISdo && pIDic);

   m_spISdo = pISdo;

   CHECK_HR(hr = pISdo->GetProperty(collectionId, &var));

   ASSERT(V_VT(&var) & VT_DISPATCH);

   CHECK_HR(hr = V_DISPATCH(&var)->QueryInterface(IID_ISdoCollection, (void**)&m_spISdoCollection));

   ASSERT(m_spISdoCollection.p);
   
   m_spIDictionary = pIDic;

   // prepare the existing property ( in the collection) to map
   CHECK_HR(hr = m_spISdoCollection->get__NewEnum((IUnknown**)&spIUnk));
   CHECK_HR(hr = spIUnk->QueryInterface(IID_IEnumVARIANT, (void**)&spEnum));

   // get the list of variant
   CHECK_HR(hr = m_spISdoCollection->get_Count((long*)&count));

   if(count > 0)
   {
      try
      {
         pVar = new VARIANT[count];

         for(ULONG i = 0; i < count; i++)
            VariantInit(pVar + i);

         if(!pVar)
         {
            CHECK_HR(hr = E_OUTOFMEMORY);
         }
         
         CHECK_HR(hr = spEnum->Reset());
         CHECK_HR(hr = spEnum->Next(count, pVar, &count));

         // prepare the map
         {
            ISdo* pISdo = NULL;
            ULONG id;
            VARIANT  var;

            VariantInit(&var);
            
            for(ULONG i = 0; i < count; i++)
            {
               CHECK_HR(hr = V_DISPATCH(pVar + i)->QueryInterface(IID_ISdo, (void**)&pISdo));
               CHECK_HR(hr = pISdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var));

               ASSERT(V_VT(&var) == VT_I4);

               m_mapProperties[V_I4(&var)] = pISdo;
               pISdo->AddRef();
            }
         }
      }
      catch(CMemoryException* pException)
      {
         pException->Delete();
         pVar = NULL;
         CHECK_HR(hr = E_OUTOFMEMORY);
      }
   }
   
L_ERR:   
   delete[] pVar;
   VariantClear(&var);
   return hr;
}

// set a property based on ID
HRESULT  CSdoWrapper::PutProperty(ULONG id, VARIANT* pVar)
{
   ASSERT(m_spISdoCollection.p);
   ASSERT(m_spIDictionary.p);
   
   ISdo*    pProp = NULL;
   IDispatch*  pDisp = NULL;
   HRESULT     hr = S_OK;

   int      ref = 0;
   IASTracePrintf("PutProperty %d", id);

   if(!m_mapProperties.Lookup(id, pProp)) // no ref change to pProp
   {
      IASTracePrintf("IDictionary::CreateAttribute %d", id);
      CHECK_HR(hr = m_spIDictionary->CreateAttribute((ATTRIBUTEID)id, &pDisp));
      IASTracePrintf("hr = %8x", hr);
      ASSERT(pDisp);

      // since pDisp is both in, out parameter, we assume the Ref is added within the function call
      IASTracePrintf("ISdoCollection::Add %x", pDisp);
      CHECK_HR(hr = m_spISdoCollection->Add(NULL, (IDispatch**)&pDisp));      // pDisp AddRef
      IASTracePrintf("hr = %8x", hr);
      // 
      ASSERT(pDisp);

      CHECK_HR(hr = pDisp->QueryInterface(IID_ISdo, (void**)&pProp));   // one ref add
      ASSERT(pProp);
      // after we have the pProp, the pDisp can be released
      pDisp->Release();

      // add to the wrapper's map
      m_mapProperties[id] = pProp;  // no need to addref again, since there is one already
   }

   IASTracePrintf("ISdo::PutProperty PROPERTY_ATTRIBUTE_VALUE %x", pVar);
   CHECK_HR(hr = pProp->PutProperty(PROPERTY_ATTRIBUTE_VALUE, pVar));
   IASTracePrintf("hr = %8x", hr);
   // for debug, ensure each attribute can be commited
#ifdef WEI_SPECIAL_DEBUG      
   ASSERT(S_OK == Commit(TRUE));
#endif   

L_ERR:   

   IASTracePrintf("hr = %8x", hr);
   return hr;
}

// get property based on ID
HRESULT CSdoWrapper::GetProperty(ULONG id, VARIANT* pVar)
{
   ISdo*    pProp;
   HRESULT     hr = S_OK;

   IASTracePrintf("Enter CSdoWrapper::GetProperty %d", id);

   if(m_mapProperties.Lookup(id, pProp))  // no ref change to pProp
   {
      ASSERT(pProp);
      CHECK_HR(hr = pProp->GetProperty(PROPERTY_ATTRIBUTE_VALUE, pVar));
   }
   else
   {
      V_VT(pVar) = VT_ERROR;
      V_ERROR(pVar) = DISP_E_PARAMNOTFOUND;
   }

L_ERR:   
   
   return hr;
}

// remove a property based on ID
HRESULT  CSdoWrapper::RemoveProperty(ULONG id)
{
   ASSERT(m_spISdoCollection.p);
   ISdo*    pProp;
   HRESULT     hr = S_OK;

   IASTracePrintf("RemoveProperty %d", id);

   if(m_mapProperties.Lookup(id, pProp))  // no ref change to pProp
   {
      ASSERT(pProp);
      CHECK_HR(hr = m_spISdoCollection->Remove((IDispatch*)pProp));
      m_mapProperties.RemoveKey(id);
      pProp->Release();

      // for debug, ensure each attribute can be commited
      ASSERT(S_OK == Commit(TRUE));

   }
   else
      hr = S_FALSE;

L_ERR:   
   IASTracePrintf("hr = %8x", hr);
   
   return hr;
}

// commit changes to the properties
HRESULT  CSdoWrapper::Commit(BOOL bCommit)
{
   HRESULT     hr = S_OK;

   IASTracePrintf("Commit %d", bCommit);

   if(bCommit)
   {
      CHECK_HR(hr = m_spISdo->Apply());
   }
   else
   {
      CHECK_HR(hr = m_spISdo->Restore());
   }
L_ERR:   

   IASTracePrintf("hr = %8x", hr);
   return hr;
}


//========================================
//
// CSdoUserWrapper Class Implementation
//

// set a property based on ID
HRESULT  CUserSdoWrapper::PutProperty(ULONG id, VARIANT* pVar)
{
   ASSERT(m_spISdo.p);

   IASTracePrintf("PutProperty %d", id);
   HRESULT hr = m_spISdo->PutProperty(id, pVar);
   IASTracePrintf("hr = %8x", hr);
   return hr;
}

// get property based on ID
HRESULT CUserSdoWrapper::GetProperty(ULONG id, VARIANT* pVar)
{
   IASTracePrintf("GetProperty %d", id);
   HRESULT hr = m_spISdo->GetProperty(id, pVar);
   IASTracePrintf("hr = %8x", hr);
   return hr;
}

// remove a property based on ID
HRESULT  CUserSdoWrapper::RemoveProperty(ULONG id)
{
   VARIANT     v;
   VariantInit(&v);
   V_VT(&v) = VT_EMPTY;

   IASTracePrintf("RemoveProperty %d", id);
   HRESULT hr = m_spISdo->PutProperty(id, &v);
   IASTracePrintf("hr = %8x", hr);
   return hr;
}

// commit changes to the properties
HRESULT  CUserSdoWrapper::Commit(BOOL bCommit)
{
   HRESULT     hr = S_OK;

   IASTracePrintf("Commit %d", bCommit);

   if(bCommit)
   {
      CHECK_HR(hr = m_spISdo->Apply());
   }
   else
   {
      CHECK_HR(hr = m_spISdo->Restore());
   }
L_ERR:   

   IASTracePrintf("hr = %8x", hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_)
#define AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef IASAPI
#define IASAPI __declspec(dllexport)
#endif

#include <afx.h>
#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxmt.h>
#include <afxdlgs.h>

#include <commctrl.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <shlobj.h>
#include <dsclient.h>
#include <mmc.h>
#include <lm.h>

#define  NO_OLD_VALUE


#define  SINGLE_SDO_CONNECTION
#include <mprapi.h>
extern "C"
{
#include "rasman.h"
};

#include "tregkey.h"

// SDO header file
#include "sdoias.h"
#include "rasdial.h"
#include "sharesdo.h"
#include "iastrace.h"

#include "eapconfig.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\sdowrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       sdowrap.h
//
//--------------------------------------------------------------------------

#ifndef  _RAS_SDO_WRAPPER_H_
#define  _RAS_SDO_WRAPPER_H_


#pragma warning( disable : 4786 )  

class CSdoWrapper
{
public:
   CSdoWrapper(){};
   ~CSdoWrapper();

   virtual HRESULT   Init(ULONG collectionId, ISdo* pISdo, ISdoDictionaryOld* pIDic);
   virtual HRESULT   PutProperty(ULONG id, VARIANT* pVar);
   virtual HRESULT GetProperty(ULONG id, VARIANT* pVar);
   virtual HRESULT   RemoveProperty(ULONG id);
   virtual HRESULT   Commit(BOOL bCommit = TRUE);
   operator ISdo*() { return (ISdo*)m_spISdo;};
   operator ISdoCollection*() { return (ISdoCollection*)m_spISdoCollection;};
   operator ISdoDictionaryOld*() { return (ISdoDictionaryOld*)m_spIDictionary;};

protected:
   // the two interfaces for the object
   CComPtr<ISdo>        m_spISdo;
   CComPtr<ISdoCollection> m_spISdoCollection;

   // dictioanry object
   CComPtr<ISdoDictionaryOld> m_spIDictionary;

   CMap<ULONG, ULONG, ISdo*, ISdo*> m_mapProperties;
};

class CUserSdoWrapper
{
public:
   CUserSdoWrapper(){};
   ~CUserSdoWrapper()
   {
      // to test if the AV is here, so do it explicitly
      m_spISdo.Release();
   };

   virtual HRESULT   Init(ISdo* pISdo)
   {
      ASSERT(pISdo);
      m_spISdo = pISdo;
      return S_OK;
   };
   virtual HRESULT   PutProperty(ULONG id, VARIANT* pVar);
   virtual HRESULT GetProperty(ULONG id, VARIANT* pVar);
   virtual HRESULT   RemoveProperty(ULONG id);
   virtual HRESULT   Commit(BOOL bCommit = TRUE);
   operator ISdo*() { return (ISdo*)m_spISdo;};

protected:
   // the two interfaces for the object
   CComPtr<ISdo>        m_spISdo;
};

#define PROPERTY_USER_IAS_ATTRIBUTE_ALLOW_DIALIN   PROPERTY_USER_ALLOW_DIALIN
#define  PROPERTY_USER_msRADIUSFramedIPAddress     PROPERTY_USER_RADIUS_FRAMED_IP_ADDRESS
#define  PROPERTY_USER_msSavedRADIUSFramedIPAddress  PROPERTY_USER_SAVED_RADIUS_FRAMED_IP_ADDRESS
#define  PROPERTY_USER_msRADIUSCallbackNumber      PROPERTY_USER_RADIUS_CALLBACK_NUMBER
#define  PROPERTY_USER_msSavedRADIUSCallbackNumber   PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER
#define  PROPERTY_USER_msNPCallingStationID          PROPERTY_USER_CALLING_STATION_ID
#define  PROPERTY_USER_msSavedNPCallingStationID     PROPERTY_USER_SAVED_CALLING_STATION_ID
#define  PROPERTY_USER_msRADIUSFramedRoute         PROPERTY_USER_RADIUS_FRAMED_ROUTE
#define  PROPERTY_USER_msSavedRADIUSFramedRoute      PROPERTY_USER_SAVED_RADIUS_FRAMED_ROUTE
#define  PROPERTY_USER_RADIUS_ATTRIBUTE_SERVICE_TYPE  PROPERTY_USER_SERVICE_TYPE

   // profile
   
   // Constraints Dialog
#define  PROPERTY_PROFILE_msNPTimeOfDay            IAS_ATTRIBUTE_NP_TIME_OF_DAY
#define  PROPERTY_PROFILE_msNPCalledStationId      IAS_ATTRIBUTE_NP_CALLED_STATION_ID
#define  PROPERTY_PROFILE_msNPAllowedPortTypes     IAS_ATTRIBUTE_NP_ALLOWED_PORT_TYPES
#define  PROPERTY_PROFILE_msRADIUSIdleTimeout      RADIUS_ATTRIBUTE_IDLE_TIMEOUT
#define  PROPERTY_PROFILE_msRADIUSSessionTimeout      RADIUS_ATTRIBUTE_SESSION_TIMEOUT
   
   // Networking Dialog
#define  PROPERTY_PROFILE_msRADIUSFramedIPAddress  RADIUS_ATTRIBUTE_FRAMED_IP_ADDRESS
#define  PROPERTY_PROFILE_msRASFilter           MS_ATTRIBUTE_FILTER

   // Multilink Dialog
#define  PROPERTY_PROFILE_msRADIUSPortLimit        RADIUS_ATTRIBUTE_PORT_LIMIT
#define  PROPERTY_PROFILE_msRASBapLinednLimit      RAS_ATTRIBUTE_BAP_LINE_DOWN_LIMIT
#define  PROPERTY_PROFILE_msRASBapLinednTime       RAS_ATTRIBUTE_BAP_LINE_DOWN_TIME
#define  PROPERTY_PROFILE_msRASBapRequired         RAS_ATTRIBUTE_BAP_REQUIRED

   // Authentication Dialog
#define  PROPERTY_PROFILE_msNPAuthenticationType      IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE
#define  PROPERTY_PROFILE_msNPAllowedEapType       IAS_ATTRIBUTE_NP_ALLOWED_EAP_TYPE

   // Encryption Dialog
#define  PROPERTY_PROFILE_msRASAllowEncryption     RAS_ATTRIBUTE_ENCRYPTION_POLICY
#define  PROPERTY_PROFILE_msRASEncryptionType      RAS_ATTRIBUTE_ENCRYPTION_TYPE

#endif //   _RAS_SDO_WRAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\sharesdo.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   sharesdo.cpp
      implement classes for sharing SdoServer among property pages for 
      different users and snapins

    FILE HISTORY:
        
*/
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <rtutils.h>
#include "rasdial.h"
#include "sharesdo.h"
#include "iastrace.h"

// the server pool pointer used to share SdoServer among pages and snapins
CSdoServerPool*         g_pSdoServerPool;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// DO SDO Attach -- real
HRESULT ConnectToSdoServer(BSTR machine, BSTR user, BSTR passwd,ISdoMachine** ppServer)
{
   ASSERT(ppServer);
   if(!ppServer)  return E_INVALIDARG;
   else
      *ppServer = NULL;

   HRESULT  hr = S_OK;
   
      // connect to the new one
   IASTraceString("CoCreateInstance SdoServer");

   CHECK_HR(hr = CoCreateInstance(  CLSID_SdoMachine, 
                           NULL, 
                           CLSCTX_INPROC_SERVER,
                           IID_ISdoMachine,
                           (void**)ppServer));

   IASTracePrintf(" hr = %8x\r\n", hr);
   ASSERT(*ppServer);

   IASTracePrintf("SdoServer::Attach(%s, %s, %s);", machine, user, passwd);
   CHECK_HR(hr = (*ppServer)->Attach(machine));
   IASTracePrintf(" hr = %8x\r\n", hr);

L_ERR:
   if(FAILED(hr) && *ppServer)
   {
      (*ppServer)->Release();
      *ppServer = NULL;
   }
      
   return hr;
}


// When using Single connection, get the marshaled interface from the stream
HRESULT GetSharedSdoServer(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd,  bool* pbConnect, CMarshalSdoServer* pServer)
{
   static   CCriticalSection  cs;
   HRESULT  hr = S_OK;

   if(cs.Lock())  // locked
   {
      if(NULL ==  g_pSdoServerPool)
      {
         try{
            g_pSdoServerPool = new CSdoServerPool;
         }catch(CMemoryException* pException)
         {
            pException->Delete();
            hr = E_OUTOFMEMORY;
         }
      }
      cs.Unlock();
   }
   else
   {
      IASTraceString("ERROR: GetSharedSdoServer, CS lock failed");
      return E_FAIL;
   }

   if(FAILED(hr))
      return hr;
   return g_pSdoServerPool->GetMarshalServer(machine, user, passwd, pbConnect, pServer);
}

//======================================================
// class CSharedSdoServerImp
// implementation class of shared server
CSharedSdoServerImp::CSharedSdoServerImp(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd)
: strMachine(machine), strUser(user), strPasswd(passwd), bConnected(false)
{};

// to make this class element of collection, provide following member functions 
bool CSharedSdoServerImp::IsFor(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd) const
{
// Compare order, ServerName, UserName, Passwd, and RetriveType
   CString  strM(machine);
   CString  strU(user);
   CString  strP(passwd);
   return (
      strMachine.CompareNoCase(strM) == 0 && 
      strUser.Compare(strU) == 0 && 
      strPasswd.Compare(strP) == 0
      );
};

// CoCreate SdoServer object
HRESULT     CSharedSdoServerImp::CreateServer()
{
   // cannot create twice!
   ASSERT(!(ISdoMachine*)spServer);
   if((ISdoMachine*)spServer) return S_OK;
   
   HRESULT  hr = S_OK;

   // connect to the new one
   IASTraceString("CoCreateInstance SdoServer");

   hr = CoCreateInstance(  CLSID_SdoMachine, 
                     NULL, 
                     CLSCTX_INPROC_SERVER,
                     IID_ISdoMachine,
                     (void**)&spServer);

   IASTracePrintf(" hr = %8x\r\n", hr);
   threadId = ::GetCurrentThreadId();
   return hr;
};

// get marshal stream, can specify, if immediate connection is required.
HRESULT     CSharedSdoServerImp::GetMarshalStream(LPSTREAM *ppStream, bool* pbConnect  /* both input and output */)
{
   ASSERT(ppStream);
   DWORD tid = ::GetCurrentThreadId();

   if (tid != threadId)
      return E_FAIL; // make sure the interface should be marshaled from the same thread

   HRESULT  hr = S_OK;

   cs.Lock();
   if(pbConnect)
   {
      if(*pbConnect && !bConnected) 
      {
         *pbConnect = false;
         CHECK_HR(hr = Connect(NULL));
         *pbConnect = true;
      }
      else
      {
         *pbConnect = bConnected;
      }
   }

   // Marshal the interface
   CHECK_HR(hr = CoMarshalInterThreadInterfaceInStream(IID_ISdoMachine, (ISdoMachine*)spServer, ppStream));
L_ERR:
   cs.Unlock();
   return hr;
};

// Connect the server to the a machine
HRESULT     CSharedSdoServerImp::Connect(ISdoMachine* pServer)
// pServer, marshaled pointer, passed in from a different thread ( than the spServer in the object)
{
   cs.Lock();
   HRESULT     hr = S_OK;
   DWORD    tid = ::GetCurrentThreadId();

   USES_CONVERSION;
   if(!bConnected)
   {
      ASSERT((ISdoMachine*)spServer);
      BSTR  bstrM = NULL;
      BSTR  bstrU = NULL;
      BSTR  bstrP = NULL;
      if(!strMachine.IsEmpty())
         bstrM = T2BSTR((LPTSTR)(LPCTSTR)strMachine);
      if(!strUser.IsEmpty())
         bstrM = T2BSTR((LPTSTR)(LPCTSTR)strUser);
      if(!strPasswd.IsEmpty())
         bstrP = T2BSTR((LPTSTR)(LPCTSTR)strPasswd);

      IASTracePrintf("SdoServer::Connect(%s, %s, %s );", bstrM, bstrU, bstrP);

      if(!pServer)
      {
         // this function should be called within the same thread
         // if the request if from a different thread, then this should NOT be NULL
         ASSERT(tid == threadId);
         pServer = (ISdoMachine*)spServer;
      }
      hr = pServer->Attach(bstrM);
      IASTracePrintf(" hr = %8x\r\n", hr);
      bConnected = (hr == S_OK);
      SysFreeString(bstrM);
      SysFreeString(bstrU);
      SysFreeString(bstrP);
   }
   cs.Unlock();

   return hr;
};

HRESULT  CSharedSdoServerImp::GetServerNReleaseStream(LPSTREAM pStream, ISdoMachine** ppServer)
{
#ifdef   _DEBUG
   DWORD __tid = ::GetCurrentThreadId();
#endif   
   return CoGetInterfaceAndReleaseStream(pStream, IID_ISdoMachine, (LPVOID*) ppServer);
};


// if connection is needed, should call the connec of CSharedSdoServer, rather than ISdoServer::Connect
HRESULT  CMarshalSdoServer::GetServer(ISdoMachine** ppServer)     
{
   HRESULT     hr = S_OK;

   if(!(ISdoMachine*)spServer)
   {
      if((IStream*)spStm)
      {
         CHECK_HR(hr = CSharedSdoServerImp::GetServerNReleaseStream((IStream*)spStm, (ISdoMachine**)&spServer));
      }
      spStm.p = NULL;   // need to manually clean this, since the above API already Release the COM interface
   }
   else
      CHECK_HR(hr = E_FAIL);

   if((ISdoMachine*)spServer)
   {
      *ppServer = (ISdoMachine*)spServer;
      (*ppServer)->AddRef();
   }

L_ERR:

   return hr;  // not valid to call at this point
};

// make SDO connect when / if NOT already done so. Note: multiple thread safe
HRESULT  CMarshalSdoServer::Connect()
{
   ASSERT(pImp);  // should not happen
   return pImp->Connect(spServer);
};

void CMarshalSdoServer::Release()
{
   pImp = NULL;
   spServer.Release();
   spStm.Release();
};

CMarshalSdoServer::CMarshalSdoServer(): pImp(NULL)
{};

// estiblish an entry in the pool, if it's new
// get marshaServer object from the thread pool
HRESULT  CSdoServerPool::GetMarshalServer(LPCTSTR machineName, LPCTSTR userName, LPCTSTR passwd, bool* pbConnect, CMarshalSdoServer* pServer)
{
   ASSERT(pServer);

   CSharedSdoServerImp* pImp = NULL;
   HRESULT              hr = S_OK;
   std::list<CSharedSdoServerImp*>::iterator i;
   // search if the server is already exist
   cs.Lock();
   for(i = listServers.begin(); i != listServers.end(); i++)
   {
      if((*i)->IsFor( machineName, userName, passwd))
      {
         pImp = (*i);
         break;
      }
   }

   // if not, then create one
   if(!pImp)
   {
      try{
         pImp = new CSharedSdoServerImp( machineName, userName, passwd);
      }catch(...)
      {
         CHECK_HR(hr = E_OUTOFMEMORY);
      }

      ASSERT(pImp);
      CHECK_HR(hr = pImp->CreateServer());
      listServers.push_front(pImp);
   }

   // marshal it. bConnect will be filled
   pServer->Release();
   {
   CComPtr<IStream> spStm;
   CHECK_HR(hr = pImp->GetMarshalStream(&spStm, pbConnect));

   // fill the information to the provided buffer
   pServer->SetInfo((IStream*)spStm, pImp);
   }
   
L_ERR:
   cs.Unlock();
   return hr;
};

// clean the POOL
CSdoServerPool::~CSdoServerPool()
{
#ifdef   _DEBUG
   DWORD __tid = ::GetCurrentThreadId();
#endif
   std::list<CSharedSdoServerImp*>::iterator i;
   
   for(i = listServers.begin(); i != listServers.end(); i++)
   {
      delete (*i);
   }
   listServers.erase(listServers.begin(), listServers.end());
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\vendors.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Vendors.cpp

Abstract:

	Implementation file for NAS Vendor ID info.


Author:

    Michael A. Maguire 02/19/98

Revision History:
	mmaguire	02/19/98	created
	byao		3/13/98		Modified.  use '0' for RADIUS
	
--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find declaration for main class in this file:
//
#include "stdafx.h"
#include "Vendors.h"
//
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



// Vendor ID constants and names.

Vendor g_aVendors[] = 
	{
		// make sure this list is sorted!!!  otherwise we will have to do
		// a search whenever use picks something in VSS list
		{ 0x2b, _T("3Com") }
		, { 0x5, _T("ACC") }
		, { 0xb5, _T("ADC Kentrox") }
		, { 0x211, _T("Ascend Communications Inc.") }
		, { 0xe, _T("BBN") }
		, { 0x110, _T("BinTec Computers") }
		, { 0x34, _T("Cabletron") }
		, { 0x9, _T("Cisco") }
		, { 0x14c, _T("Digiboard") }
		, { 0x1b2, _T("EICON Technologies") }
		, { 0x40, _T("Gandalf") }
		, { 0x157, _T("Intel") }
		, { 0xf4, _T("Lantronix") }
		, { 0x133, _T("Livingston Enterprises, Inc.") }
		, { 0x137, _T("Microsoft RAS") }
		, { 0x1, _T("Proteon") }
		, { 0x0, _T("RADIUS proxy or Any") } 
		, { 0xa6, _T("Shiva") }
		, { 0x75, _T("Telebit") }
		, { 0x1ad, _T("U.S. Robotics, Inc.") }
		, { 0xf, _T("XLogics") }
	};
int  g_iVendorNum = 21;

// Searches for a given vendor ID and returns its position in the array of vendors.
int VendorIDToOrdinal( DWORD dwID )
{
	for (int i = 0; i < g_iVendorNum ; i++)
	{
		if( dwID == g_aVendors[i].dwID )
		{
			return i;
		}
	}
	// Error case.
	return INVALID_VENDORID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dialinusr\sharesdo.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sharesdo.h
		defines classes for sharing SdoServer among property pages for different users and snapins

    FILE HISTORY:
        
*/
//////////////////////////////////////////////////////////////////////

#if !defined(__SHARE_SDO_H__)
#define __SHARE_SDO_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <list>


// this class is used to build a map of the connected SDO servers being used
// the consumer of the class may NOT call ISdoMachine::Connect directly, should use Connect function
// defined in this class
class CSharedSdoServerPool;
class CSharedSdoServerImp;
class CSharedSdoServer;

// implementation class of shared server
// used by CSdoServerPool and CMarshalSdoServer
class CSharedSdoServerImp
{
	friend class CSdoServerPool;
	friend class CMarshalSdoServer;

protected:	// only be used by friends and derived ones
	CSharedSdoServerImp(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd);
	~CSharedSdoServerImp()
	{
		// no longer check this, this could be different
		// ASSERT(threadId == GetCurrentThreadId());
		spServer.Release();
	};
	
	// to make this class element of collection, provide following member functions 
	bool IsFor(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd) const;
	
	// CoCreate SdoServer object
	HRESULT	CreateServer();

	// get marshal stream, can specify, if immediate connection is required.
	HRESULT	GetMarshalStream(LPSTREAM *ppStream, bool* pbConnect	/* both input and output */);

	// Connect the server to the a machine
	HRESULT	Connect(ISdoMachine* pMarshaledServer	/* NULL, when calling from the same thread */);

	// Used by different thread, to retrived marshaled interface out of the stream
	static	HRESULT GetServerNReleaseStream(LPSTREAM pStream, ISdoMachine** ppServer);
	
private:	
	CString		strMachine;		// name of the serve to connect to 
	CString		strUser;		// user id used to connect
	CString		strPasswd;		// user's passwd
	
	CComPtr<ISdoMachine>	spServer;	// ISdoInterface, created(not yet connected), or connected
	bool		bConnected;
	
	CCriticalSection	cs;
	
	DWORD				threadId;	// the thread ID of the creating thread
};

// used between thread which managed the SdoServerPool and consumer of the pool
class CMarshalSdoServer
{
	friend	CSdoServerPool;
public:
	CMarshalSdoServer();
	~CMarshalSdoServer()
	{
		spServer.Release();
		spStm.Release();
		pImp = NULL;
	};
	// if connection is needed, should call the connec of CSharedSdoServer, rather than ISdoMachine::Connect
	// this should be used by a different thread to get marshaled interface
	HRESULT	GetServer(ISdoMachine** ppServer);

	// connect the sdo server
	HRESULT	Connect();

	// release the data members
	void Release();
	
protected:
	void SetInfo(IStream* pStream, CSharedSdoServerImp* pImp1)
	{
		spStm.Release();
		spStm = pStream;
		pImp = pImp1;
	};
		
private:
	CComPtr<ISdoMachine>		spServer;
	CComPtr<IStream>		spStm;		//
	CSharedSdoServerImp*	pImp;		// the pointer is kept in global list, no need to free it
};

// class used to manage a shared SdoServerPool
class CSdoServerPool
{
public:
	// find a server in the pool, if there isn't, create an entry in the pool
	// this need bo called in the main thread
	HRESULT	GetMarshalServer(LPCTSTR machineName, LPCTSTR userName, LPCTSTR passwd, bool* pbConnect, CMarshalSdoServer* pServer);

	~CSdoServerPool();
private:
	std::list<CSharedSdoServerImp*>	listServers;
	CCriticalSection	cs;
};

// the server pool pointer used to share SdoServer among pages and snapins
extern CSdoServerPool*			g_pSdoServerPool;

HRESULT ConnectToSdoServer(BSTR machineName, BSTR userName, BSTR passwd, ISdoMachine** ppServer);
HRESULT GetSharedSdoServer(LPCTSTR machine, LPCTSTR user, LPCTSTR passwd, bool* pbConnect, CMarshalSdoServer* pServer);

#endif // !defined(__SHARE_SDO_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\idl\cfgobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Thu Apr 23 17:06:35 1998
 */
/* Compiler settings for cfgobj.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cfgobj_h__
#define __cfgobj_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRouterProtocolConfig_FWD_DEFINED__
#define __IRouterProtocolConfig_FWD_DEFINED__
typedef interface IRouterProtocolConfig IRouterProtocolConfig;
#endif 	/* __IRouterProtocolConfig_FWD_DEFINED__ */


#ifndef __IAuthenticationProviderConfig_FWD_DEFINED__
#define __IAuthenticationProviderConfig_FWD_DEFINED__
typedef interface IAuthenticationProviderConfig IAuthenticationProviderConfig;
#endif 	/* __IAuthenticationProviderConfig_FWD_DEFINED__ */


#ifndef __IAccountingProviderConfig_FWD_DEFINED__
#define __IAccountingProviderConfig_FWD_DEFINED__
typedef interface IAccountingProviderConfig IAccountingProviderConfig;
#endif 	/* __IAccountingProviderConfig_FWD_DEFINED__ */


#ifndef __IEAPProviderConfig_FWD_DEFINED__
#define __IEAPProviderConfig_FWD_DEFINED__
typedef interface IEAPProviderConfig IEAPProviderConfig;
#endif 	/* __IEAPProviderConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "router.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_cfgobj_0000 */
/* [local] */ 

typedef BYTE __RPC_FAR *PBYTE;



extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0000_v0_0_s_ifspec;

#ifndef __IRouterProtocolConfig_INTERFACE_DEFINED__
#define __IRouterProtocolConfig_INTERFACE_DEFINED__

/* interface IRouterProtocolConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IRouterProtocolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB16-D706-11D0-A37B-00C04FC9DA04")
    IRouterProtocolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IRouterInfo __RPC_FAR *pRouter,
            /* [in] */ DWORD dwReserved1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IRouterInfo __RPC_FAR *pRouter,
            /* [in] */ DWORD dwReserved1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRouterProtocolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IRouterInfo __RPC_FAR *pRouter,
            /* [in] */ DWORD dwReserved1);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IRouterInfo __RPC_FAR *pRouter,
            /* [in] */ DWORD dwReserved1);
        
        END_INTERFACE
    } IRouterProtocolConfigVtbl;

    interface IRouterProtocolConfig
    {
        CONST_VTBL struct IRouterProtocolConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRouterProtocolConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRouterProtocolConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRouterProtocolConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRouterProtocolConfig_AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,dwReserved1)	\
    (This)->lpVtbl -> AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,dwReserved1)

#define IRouterProtocolConfig_RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,dwReserved1)	\
    (This)->lpVtbl -> RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,dwReserved1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_AddProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IRouterInfo __RPC_FAR *pRouter,
    /* [in] */ DWORD dwReserved1);


void __RPC_STUB IRouterProtocolConfig_AddProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_RemoveProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IRouterInfo __RPC_FAR *pRouter,
    /* [in] */ DWORD dwReserved1);


void __RPC_STUB IRouterProtocolConfig_RemoveProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRouterProtocolConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cfgobj_0041 */
/* [local] */ 

#define DeclareIRouterProtocolConfigMembers(IPURE) \
	STDMETHOD(AddProtocol)(THIS_ LPCOLESTR pszMachineName,\
					   DWORD dwTransportId,\
					   DWORD dwProtocolId,\
					   HWND hWnd,\
					   DWORD dwFlags,\
					   IRouterInfo *pRouter,\
					   DWORD dwReserved1);\
	STDMETHOD(RemoveProtocol)(THIS_ LPCOLESTR pszMachineName,\
						 DWORD dwTransportId,\
						 DWORD dwProtocolId,\
						 HWND hWnd,\
						 DWORD dwFlags,\
						 IRouterInfo *pRouter,\
						 DWORD dwReserved2);\
 


extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0041_v0_0_s_ifspec;

#ifndef __IAuthenticationProviderConfig_INTERFACE_DEFINED__
#define __IAuthenticationProviderConfig_INTERFACE_DEFINED__

/* interface IAuthenticationProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAuthenticationProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB17-D706-11D0-A37B-00C04FC9DA04")
    IAuthenticationProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigChangeNotification( 
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticationProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigChangeNotification )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        END_INTERFACE
    } IAuthenticationProviderConfigVtbl;

    interface IAuthenticationProviderConfig
    {
        CONST_VTBL struct IAuthenticationProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticationProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticationProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticationProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticationProviderConfig_Initialize(This,pszMachineName)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName)

#define IAuthenticationProviderConfig_Configure(This,hWnd,dwFlags,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Configure(This,hWnd,dwFlags,dwReserved1,dwReserved2)

#define IAuthenticationProviderConfig_ConfigChangeNotification(This,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> ConfigChangeNotification(This,dwReserved1,dwReserved2)

#define IAuthenticationProviderConfig_Activate(This,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Activate(This,dwReserved1,dwReserved2)

#define IAuthenticationProviderConfig_Deactivate(This,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Deactivate(This,dwReserved1,dwReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Initialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName);


void __RPC_STUB IAuthenticationProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Configure_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_ConfigChangeNotification_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAuthenticationProviderConfig_ConfigChangeNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Activate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Deactivate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticationProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cfgobj_0043 */
/* [local] */ 

#define DeclareIAuthenticationProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ LPCOLESTR pszMachineName) IPURE; \
	 \
	STDMETHOD(Configure)(THIS_ HWND hWnd, \
						  DWORD dwFlags, \
						  DWORD dwReserved1, \
						  DWORD dwReserved2) IPURE; \
 \
	STDMETHOD(ConfigChangeNotification)(THIS_ DWORD dwReserved1, \
										 DWORD dwReserved2) IPURE; \
	STDMETHOD(Activate)(THIS_ \
						 DWORD dwReserved1, \
						 DWORD dwReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						   DWORD dwReserved1, \
						   DWORD dwReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0043_v0_0_s_ifspec;

#ifndef __IAccountingProviderConfig_INTERFACE_DEFINED__
#define __IAccountingProviderConfig_INTERFACE_DEFINED__

/* interface IAccountingProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAccountingProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB18-D706-11D0-A37B-00C04FC9DA04")
    IAccountingProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountingProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        END_INTERFACE
    } IAccountingProviderConfigVtbl;

    interface IAccountingProviderConfig
    {
        CONST_VTBL struct IAccountingProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountingProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountingProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountingProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountingProviderConfig_Initialize(This,pszMachineName)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName)

#define IAccountingProviderConfig_Configure(This,hWnd,dwFlags,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Configure(This,hWnd,dwFlags,dwReserved1,dwReserved2)

#define IAccountingProviderConfig_Activate(This,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Activate(This,dwReserved1,dwReserved2)

#define IAccountingProviderConfig_Deactivate(This,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Deactivate(This,dwReserved1,dwReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Initialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName);


void __RPC_STUB IAccountingProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Configure_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAccountingProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Activate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAccountingProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Deactivate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IAccountingProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountingProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cfgobj_0045 */
/* [local] */ 

#define DeclareIAccountingProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ LPCOLESTR pszMachineName) IPURE; \
	STDMETHOD(Configure)(THIS_ HWND hWnd, \
						  DWORD dwFlags, \
						  DWORD dwReserved1, \
						  DWORD dwReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						 DWORD dwReserved1, \
						 DWORD dwReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						   DWORD dwReserved1, \
						   DWORD dwReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0045_v0_0_s_ifspec;

#ifndef __IEAPProviderConfig_INTERFACE_DEFINED__
#define __IEAPProviderConfig_INTERFACE_DEFINED__

/* interface IEAPProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IEAPProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB19-D706-11D0-A37B-00C04FC9DA04")
    IEAPProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEAPProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwReserved1,
            /* [in] */ DWORD dwReserved2);
        
        END_INTERFACE
    } IEAPProviderConfigVtbl;

    interface IEAPProviderConfig
    {
        CONST_VTBL struct IEAPProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEAPProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEAPProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEAPProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEAPProviderConfig_Initialize(This,pszMachineName)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName)

#define IEAPProviderConfig_Configure(This,hWnd,dwReserved1,dwReserved2)	\
    (This)->lpVtbl -> Configure(This,hWnd,dwReserved1,dwReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Initialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName);


void __RPC_STUB IEAPProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Configure_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwReserved1,
    /* [in] */ DWORD dwReserved2);


void __RPC_STUB IEAPProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEAPProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cfgobj_0047 */
/* [local] */ 

#define DeclareIEAPProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ LPCOLESTR pszMachineName) IPURE; \
	STDMETHOD(Configure)(THIS_ HWND hWnd, DWORD dwRes1, DWORD dwRes2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cfgobj_0047_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\actpol.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Main Mode Policy node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "ActPol.h"



// magic strings
#define IPSEC_SERVICE_NAME TEXT("policyagent")
#define GPEXT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")
TCHAR   pcszGPTIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\GPTIPSECPolicy");
TCHAR   pcszGPTIPSecName[]   = TEXT("DSIPSECPolicyName");
TCHAR   pcszGPTIPSecFlags[]  = TEXT("DSIPSECPolicyFlags");
TCHAR   pcszGPTIPSecPath[]   = TEXT("DSIPSECPolicyPath");
TCHAR   pcszLocIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Local");
TCHAR   pcszLocIPSecPol[]    = TEXT("ActivePolicy");
TCHAR   pcszCacheIPSecKey[]  = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Cache");
TCHAR   pcszIPSecPolicy[]    = TEXT("ipsecPolicy");
TCHAR   pcszIPSecName[]      = TEXT("ipsecName");
TCHAR   pcszIPSecDesc[]      = TEXT("description");
TCHAR   pcszIPSecTimestamp[] = TEXT("whenChanged");


TCHAR   pcszIpsecClsid[] = TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}");


UINT ActPolItems[] = {
	IDS_ACTPOL_POLNAME,
	IDS_ACTPOL_POLDESCR,
	IDS_ACTPOL_LASTMODF,
	IDS_ACTPOL_POLSTORE,
	IDS_ACTPOL_POLPATH,
	IDS_ACTPOL_OU,
	IDS_ACTPOL_GPONAME
};




/*---------------------------------------------------------------------------
    Class CActPolHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CActPolHandler::CActPolHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CActPolHandler::~CActPolHandler()
{
}

/*!--------------------------------------------------------------------------
    CActPolHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CActPolHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_ACTIVE_POLICY);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_ACTIVEPOL);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_ACTIVEPOL][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_ACTIVEPOL][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CActPolHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CActPolHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CActPolHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    
    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CActPolHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CActPolHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    
	
    i = sizeof(ActPolItems)/sizeof(UINT);

	UpdateActivePolicyInfo();
	    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));
    
Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CActPolHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CActPolHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hrFalse;
}

/*---------------------------------------------------------------------------
    CActPolHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CActPolHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;

    if (!fSelect)
	{
        return hr;
	}

    // Get the current count
    i = sizeof(ActPolItems)/sizeof(UINT);

    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_IKESTATS_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrFalse;
}

/*!--------------------------------------------------------------------------
    CActPolHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CActPolHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return hrFalse;
}


/*---------------------------------------------------------------------------
    CActPolHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CActPolHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CActPolHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_POLICY;
}

/*---------------------------------------------------------------------------
    CActPolHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CActPolHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_IKESTATS]))
		return NULL;
	
	

    switch (aColumns[IPSECMON_ACTIVEPOL][nCol])
    {
        case IDS_ACTPOL_ITEM:
			strTemp.LoadString(ActPolItems[nIndex]);
			return strTemp;
			break;

        case IDS_ACTPOL_DESCR:
			switch(ActPolItems[nIndex])
			{
			case IDS_ACTPOL_POLNAME:
				if(m_PolicyInfo.iPolicySource == PS_NO_POLICY)
					strTemp.LoadString(IDS_ACTPOL_NOACTPOL);
				else
				    strTemp = m_PolicyInfo.pszPolicyName;
				break;
			case IDS_ACTPOL_POLDESCR:
				if(m_PolicyInfo.iPolicySource == PS_NO_POLICY)
					strTemp.LoadString(IDS_ACTPOL_NA);
				else
				    strTemp = m_PolicyInfo.pszPolicyDesc;
				break;
			case IDS_ACTPOL_LASTMODF:
				if(m_PolicyInfo.iPolicySource == PS_NO_POLICY)
					strTemp.LoadString(IDS_ACTPOL_NA);
				else if(m_PolicyInfo.timestamp)
					FormatTime(m_PolicyInfo.timestamp, strTemp);
				break;
			case IDS_ACTPOL_POLSTORE:
				if(m_PolicyInfo.iPolicySource == PS_DS_POLICY)
					strTemp.LoadString(IDS_ACTPOL_DOMAIN);
				else if(m_PolicyInfo.iPolicySource == PS_DS_POLICY_CACHED)
					strTemp.LoadString(IDS_ACTPOL_DOMAIN_CACHED);
				else if(m_PolicyInfo.iPolicySource == PS_LOC_POLICY)
					strTemp.LoadString(IDS_ACTPOL_LOCAL);
				else
				    strTemp.LoadString(IDS_ACTPOL_NA);
				break;
			case IDS_ACTPOL_POLPATH:
				if((m_PolicyInfo.iPolicySource == PS_DS_POLICY) || (m_PolicyInfo.iPolicySource == PS_DS_POLICY_CACHED))
				    strTemp = m_PolicyInfo.pszPolicyPath;
				else
                    strTemp.LoadString(IDS_ACTPOL_NA);
				break;
			case IDS_ACTPOL_OU:
				if((m_PolicyInfo.iPolicySource == PS_DS_POLICY) || (m_PolicyInfo.iPolicySource == PS_DS_POLICY_CACHED))
				    strTemp = m_PolicyInfo.pszOU;
				else
                    strTemp.LoadString(IDS_ACTPOL_NA);
				break;
			case IDS_ACTPOL_GPONAME:
				if((m_PolicyInfo.iPolicySource == PS_DS_POLICY) || (m_PolicyInfo.iPolicySource == PS_DS_POLICY_CACHED))
				    strTemp = m_PolicyInfo.pszGPOName;
				else
                    strTemp.LoadString(IDS_ACTPOL_NA);
				break;
			}
			return strTemp;
            break;

        default:
            Panic0("CActPolHandler::GetVirtualString - Unknown column!\n");
            break;
    }


    return NULL;
}

/*---------------------------------------------------------------------------
    CActPolHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CActPolHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CActPolHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
/*STDMETHODIMP 
CActPolHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_POLICY]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_POLICY][nColumn];

	hr = m_spSpdInfo->SortMmPolicies(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}*/

/*!--------------------------------------------------------------------------
    CActPolHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CActPolHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CActPolHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CActPolHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CActPolHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CActPolHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CActPolHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CActPolHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

	i = sizeof(ActPolItems)/sizeof(UINT);

	UpdateActivePolicyInfo();

    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CActPolHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CActPolHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{
	HRESULT hr = hrOK;
    m_spSpdInfo.Set(pSpdInfo);

	m_spSpdInfo->GetComputerName(&m_strCompName);

	UpdateActivePolicyInfo();
	
    return hr;

}

/********************************************************************
	FUNCTION: getPolicyInfo

	PURPOSE:  gets information about currently assigned policy 
	          into m_PolicyInfo structure
	INPUT:    none

	RETURNS:  HRESULT. Will return ERROR_SUCCESS if everything is fine.
*********************************************************************/

HRESULT CActPolHandler::getPolicyInfo ( )
{
	HKEY    hRegKey=NULL, hRegHKey=NULL;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx
	TCHAR   pszBuf[STRING_TEXT_SIZE];
	DWORD dwError;
	DWORD dwValue;
	DWORD dwLength = sizeof(DWORD);

	//Initialize the m_PolicyInfo as PS_NO_POLICY assigned
	m_PolicyInfo.iPolicySource = PS_NO_POLICY;
	m_PolicyInfo.pszPolicyPath[0] = 0;
	m_PolicyInfo.pszPolicyName[0] = 0;
	m_PolicyInfo.pszPolicyDesc[0] = 0;

	
	dwError = RegConnectRegistry( m_strCompName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	BAIL_ON_WIN32_ERROR(dwError);

	dwError = RegOpenKeyEx( hRegHKey,
							pcszGPTIPSecKey,
							0,
							KEY_READ,
							&hRegKey);

	if(ERROR_SUCCESS == dwError)
	{
	
		// query for flags, if flags aint' there or equal to 0, we don't have domain policy
		dwError = RegQueryValueEx(hRegKey,
								  pcszGPTIPSecFlags,
								  NULL,
								  &dwType,
								  (LPBYTE)&dwValue,
								  &dwLength);
					
		if (dwValue == 0)
			dwError = ERROR_FILE_NOT_FOUND;
			

		// now get name
		if (dwError == ERROR_SUCCESS)
		{
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError = RegQueryValueEx( hRegKey,
									   pcszGPTIPSecName,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
		}
	}
	

	if (dwError == ERROR_SUCCESS)
	{
		PSPD_POLICY_STATE pPolicyState;
		QuerySpdPolicyState((LPTSTR)(LPCTSTR)m_strCompName, 0, &pPolicyState, 0);
		if (pPolicyState->PolicyLoadState == SPD_STATE_CACHE_APPLY_SUCCESS) {
			m_PolicyInfo.iPolicySource = PS_DS_POLICY_CACHED;
		} else {
			m_PolicyInfo.iPolicySource = PS_DS_POLICY;
		}
		m_PolicyInfo.pszPolicyPath[0] = 0;
		_tcscpy(m_PolicyInfo.pszPolicyName, pszBuf);

		dwBufLen = MAXSTRLEN*sizeof(TCHAR);
		dwError = RegQueryValueEx( hRegKey,
								   pcszGPTIPSecPath,
								   NULL,
								   &dwType, // will be REG_SZ
								   (LPBYTE) pszBuf,
								   &dwBufLen);
		if (dwError == ERROR_SUCCESS)
		{
			_tcscpy(m_PolicyInfo.pszPolicyPath, pszBuf);
		}

		dwError = ERROR_SUCCESS;
		goto error;
	}
	else
	{
		RegCloseKey(hRegKey);
		hRegKey = NULL;
		if (dwError == ERROR_FILE_NOT_FOUND)
		{   
			// DS reg key not found, check local
			dwError = RegOpenKeyEx( hRegHKey,
									pcszLocIPSecKey,
									0,
									KEY_READ,
									&hRegKey);

			BAIL_ON_WIN32_ERROR(dwError);
			
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError = RegQueryValueEx( hRegKey,
									   pcszLocIPSecPol,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
			
			
			if (dwError == ERROR_SUCCESS)
			{	
				// read it
				RegCloseKey(hRegKey);
				hRegKey = NULL;
				dwError = RegOpenKeyEx( hRegHKey,
										pszBuf,
										0,
										KEY_READ,
										&hRegKey);
				_tcscpy(m_PolicyInfo.pszPolicyPath, pszBuf);
				if (dwError == ERROR_SUCCESS)
				{
					dwBufLen = MAXSTRLEN*sizeof(TCHAR);
					dwError = RegQueryValueEx( hRegKey,
											   pcszIPSecName,
											   NULL,
											   &dwType, // will be REG_SZ
											   (LPBYTE) pszBuf,
											   &dwBufLen);
				}

				
				if (dwError == ERROR_SUCCESS)
				{	// found it
					m_PolicyInfo.iPolicySource = PS_LOC_POLICY;
					_tcscpy(m_PolicyInfo.pszPolicyName, pszBuf);
				}

				dwError = ERROR_SUCCESS;
			}
		}
		
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (hRegHKey)
	{
		RegCloseKey(hRegHKey);
	}
	
	return (HRESULT) dwError;

}


/********************************************************************
	FUNCTION: getMorePolicyInfo

	PURPOSE:  gets additional information about currently assigned policy 
	          into m_PolicyInfo structure
	INPUT:    none, uses  m_PolicyInfo structure
	          particularly
			    iPolicySource
				pszPolicyName
				pszPolicyPath
			  fields

	RETURNS:  HRESULT. Will return ERROR_SUCCESS if everything is fine.
	          Currently fills pszPolicyDesc and timestamp fields of the global structure

    NOTES:    This is separate from getPolicyInfo routine for two reasons
	             a) the information obtained here is optional and error during this particular routine
				    is not considered fatal
				 b) the code structure is simpler as this routine is "built on top" of what getPolicyInfo provides
*********************************************************************/

HRESULT CActPolHandler::getMorePolicyInfo ( )
{
	DWORD   dwError = ERROR_SUCCESS;
	HKEY    hRegKey = NULL, hRegHKey = NULL;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx
	DWORD   dwValue;
	DWORD   dwLength = sizeof(DWORD);
	TCHAR   pszBuf[STRING_TEXT_SIZE];

	PTCHAR* ppszExplodeDN = NULL;

	// set some default values
    m_PolicyInfo.pszPolicyDesc[0] = 0;
	m_PolicyInfo.timestamp  = 0;

	dwError = RegConnectRegistry( m_strCompName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	BAIL_ON_WIN32_ERROR(dwError);

	switch (m_PolicyInfo.iPolicySource)
	{
		case PS_LOC_POLICY:
			// open the key
			dwError = RegOpenKeyEx( hRegHKey,
									m_PolicyInfo.pszPolicyPath,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			m_PolicyInfo.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(m_PolicyInfo.pszPolicyDesc, pszBuf);

			break;

		case PS_DS_POLICY:
		case PS_DS_POLICY_CACHED:
			// get the policy name from DN
			_tcscpy(pszBuf, pcszCacheIPSecKey);
			ppszExplodeDN = ldap_explode_dn(m_PolicyInfo.pszPolicyPath, 1);
			if (!ppszExplodeDN)
			{
				goto error;
			}
			_tcscat(pszBuf, TEXT("\\"));
			_tcscat(pszBuf, ppszExplodeDN[0]);

			// open the regkey
			dwError = RegOpenKeyEx( hRegHKey,
									pszBuf,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			// get the more correct name info
			dwBufLen = sizeof(pszBuf);
			dwError = RegQueryValueEx( hRegKey,
									   pcszIPSecName,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
			if (dwError == ERROR_SUCCESS)
			{
				_tcscpy(m_PolicyInfo.pszPolicyName, pszBuf);
			}

			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			m_PolicyInfo.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(m_PolicyInfo.pszPolicyDesc, pszBuf);
			
			break;
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (hRegHKey)
	{
		RegCloseKey(hRegHKey);
	}
	if (ppszExplodeDN)
	{
		ldap_value_free(ppszExplodeDN);
	}
	return (HRESULT) dwError;
}


HRESULT CActPolHandler::UpdateActivePolicyInfo()
{
	HRESULT hr;
	
	hr = getPolicyInfo();


	if( hr == ERROR_SUCCESS )
	{
		switch (m_PolicyInfo.iPolicySource)
		{
		case PS_NO_POLICY:
			break;

		case PS_DS_POLICY:
		case PS_DS_POLICY_CACHED:
			{
				PGROUP_POLICY_OBJECT pGPO;
				pGPO = NULL;
				getMorePolicyInfo();
				pGPO = getIPSecGPO();
				if (pGPO)
				{
					PGROUP_POLICY_OBJECT pLastGPO = pGPO;
					
					while ( 1 )
					{
						if ( pLastGPO->pNext )
							pLastGPO = pLastGPO->pNext;
						else
							break;
					}
					lstrcpy(m_PolicyInfo.pszOU,pLastGPO->lpLink);
					lstrcpy(m_PolicyInfo.pszGPOName, pLastGPO->lpDisplayName);
					FreeGPOList (pGPO);
				}
			}
			break;

		case PS_LOC_POLICY:
			getMorePolicyInfo();
			break;
		}
	}

	return hr;
}


/********************************************************************
	FUNCTION: getIPSecGPO

	PURPOSE:  returns GPO that is assigning IPSec Policy
	INPUT:    none

	RETURNS: pointer to GROUP_POLICY_OBJECT structure
	         NULL if policy is not assigned or if GPO information is not retrievable
	NOTES:   Tested only with domain GPOs
	         Behaves unpredictably when run for the computer 
			   that does not have active Directory IPSec policy assigned
			 CALLER is responsible for freeing the memory!
*********************************************************************/
/*PGROUP_POLICY_OBJECT CActPolHandler::getIPSecGPO ( )
{
    HKEY hKey, hSubKey, hRegHKey;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    TCHAR szName[50];
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO, pGPOTemp;
	PGROUP_POLICY_OBJECT pGPOReturn = NULL;
	DWORD dwResult;

    //
    // Enumerate the extensions
    //

	lResult = RegConnectRegistry( m_strCompName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	if(lResult != ERROR_SUCCESS)
	{
		return NULL;
	}

    lResult = RegOpenKeyEx (hRegHKey, GPEXT_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

        while ((dwResult = RegEnumKeyEx (hKey, dwIndex++, szName, &dwNameSize, NULL, NULL,
                          NULL, NULL)) == ERROR_SUCCESS)
        {

	        dwNameSize = 50;

            //
            // Skip the registry extension since we did it above
            //

            if (lstrcmpi(TEXT("{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"), szName))
            {

                //
                // Get the list of GPOs this extension applied
                //

                StringToGuid(szName, &guid);

                lResult = GetAppliedGPOList (GPO_LIST_FLAG_MACHINE, m_strCompName, NULL,
                                             &guid, &pGPO);

                if (lResult == ERROR_SUCCESS)
                {
                    if (pGPO)
                    {
                        //
                        // Get the extension's friendly display name
                        //

                        lResult = RegOpenKeyEx (hKey, szName, 0, KEY_READ, &hSubKey);

                        if (lResult == ERROR_SUCCESS)
                        {
							if (!lstrcmpi(TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}"), szName))
                            {
                               // found IPSec
								return pGPO;
                            }
							else
							{
								FreeGPOList(pGPO);
							}
						}
					}
				}
			}
		}
	}

	return pGPOReturn;
}*/

PGROUP_POLICY_OBJECT CActPolHandler::getIPSecGPO ( )
{
    HKEY hKey = NULL;
	HKEY hRegHKey = NULL;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    TCHAR szName[50];
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO = NULL;
	DWORD dwResult;

    //
    // Enumerate the extensions
    //

	lResult = RegConnectRegistry( m_strCompName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	if(lResult != ERROR_SUCCESS)
	{
		return NULL;
	}

	CString strGPExt;

	strGPExt = GPEXT_KEY;
	strGPExt += TEXT("\\");
	strGPExt += pcszIpsecClsid;
    lResult = RegOpenKeyEx (hRegHKey, strGPExt, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

		lstrcpy(szName,pcszIpsecClsid);
				
        StringToGuid(szName, &guid);

        lResult = GetAppliedGPOList (GPO_LIST_FLAG_MACHINE, m_strCompName, NULL,
                                             &guid, &pGPO);
        
	}

	if( hKey )
		RegCloseKey(hKey);

	if( hRegHKey )
		RegCloseKey(hRegHKey);

	
	return pGPO;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::FormatTime
//
//  Purpose:    convert time_t to a string. 
//
//  Returns:    error code
//
//  Note:       _wasctime has some localization problems. So we do the formatting ourselves
HRESULT CActPolHandler::FormatTime(time_t t, CString & str)
{
    time_t timeCurrent = time(NULL);
    LONGLONG llTimeDiff = 0;
    FILETIME ftCurrent = {0};
    FILETIME ftLocal = {0};
    SYSTEMTIME SysTime;
    WCHAR szBuff[256] = {0};


    str = L"";

    GetSystemTimeAsFileTime(&ftCurrent);

    llTimeDiff = (LONGLONG)t - (LONGLONG)timeCurrent;

    llTimeDiff *= 10000000; 

    *((LONGLONG UNALIGNED64 *)&ftCurrent) += llTimeDiff;

    if (!FileTimeToLocalFileTime(&ftCurrent, &ftLocal ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!FileTimeToSystemTime( &ftLocal, &SysTime ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (0 == GetDateFormat(LOCALE_USER_DEFAULT, 
                        0, 
                        &SysTime, 
                        NULL,
                        szBuff, 
                        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    str = szBuff;
    str += L" ";

    ZeroMemory(szBuff, sizeof(szBuff));
    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    str += szBuff;

    return S_OK;
}


//*************************************************************
//
//  StringToGuid()
//
//  Purpose:    Converts a GUID in string format to a GUID structure
//
//  Parameters: szValue - guid in string format
//              pGuid   - guid structure receiving the guid
//
//
//  Return:     void
//
//*************************************************************

void CActPolHandler::StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    TCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == TEXT('{') )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = _tcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)_tcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)_tcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)_tcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)_tcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)_tcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\actpol.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	ActPol.h

    FILE HISTORY:
        
*/

#ifndef _ACTPOL_H
#define _ACTPOL_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

// BAIL_xx defines
#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
        goto error; \
    }

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

#define MAXSTRLEN	(1024) 
#define  STRING_TEXT_SIZE 4096

typedef struct 
{
	int     iPolicySource;            // one of the three constants mentioned above
	TCHAR   pszPolicyName[MAXSTRLEN]; // policy name
	TCHAR   pszPolicyDesc[MAXSTRLEN]; // policy description
	TCHAR   pszPolicyPath[MAXSTRLEN]; // policy path (DN or RegKey)
	TCHAR   pszOU[MAXSTRLEN];         // OU or GPO
	TCHAR   pszGPOName[MAXSTRLEN];    // policy path (DN or RegKey)
	time_t  timestamp;                // last updated time
} POLICY_INFO, *PPOLICY_INFO;

// policy source constants
#define PS_NO_POLICY        0
#define PS_DS_POLICY        1
#define PS_DS_POLICY_CACHED 2
#define PS_LOC_POLICY       3


/*---------------------------------------------------------------------------
	Class:	CActPolHandler
 ---------------------------------------------------------------------------*/
class CActPolHandler : public CIpsmHandler
{
public:
    CActPolHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CActPolHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	/*STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);*/

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
	
    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmActivePolNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);

    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
	POLICY_INFO         m_PolicyInfo;
	CString             m_strCompName;

	HRESULT UpdateActivePolicyInfo();
	HRESULT getPolicyInfo();
	HRESULT getMorePolicyInfo();
	PGROUP_POLICY_OBJECT getIPSecGPO();
	HRESULT FormatTime(time_t t, CString & str);
	void StringToGuid( TCHAR * szValue, GUID * pGuid );
};




#endif _IKESTATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\dlgaddm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

// dlgaddm.cpp : implementation file
//

#include "stdafx.h"
#include "dlgaddm.h"
#include "shlobj.h"  // shell 32 version

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg dialog


CAddMachineDlg::CAddMachineDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAddMachineDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddMachineDlg)
	m_strMachineName = _T("");
	//}}AFX_DATA_INIT
}


void CAddMachineDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddMachineDlg)
	DDX_Text(pDX, IDC_REMOTENAME, m_strMachineName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddMachineDlg, CDialog)
	//{{AFX_MSG_MAP(CAddMachineDlg)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg message handlers

void CAddMachineDlg::OnBrowse() 
{
    BROWSEINFO BrowseInfo;
    LPITEMIDLIST pidlComputer;
    TCHAR szRemoteName[4096];
    IMalloc * pMalloc;

    BrowseInfo.hwndOwner = GetSafeHwnd();
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = szRemoteName;
    BrowseInfo.lpszTitle = _T("Click on the computer you want to connect to.");//LoadDynamicString(IDS_COMPUTERBROWSETITLE);
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) 
    {
        SHGetMalloc(&pMalloc);
        pMalloc->Free(pidlComputer);
        pMalloc->Release();

        Trace1("User selected %s\n", szRemoteName);

        GetDlgItem(IDC_REMOTENAME)->SetWindowText(szRemoteName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\addserv.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    EditUser.h   
        Edit Users dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddServ dialog

class CAddServ : public CBaseDialog
{
// Construction
public:
	CAddServ(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddServ)
	enum { IDD = IDD_ADD_COMPUTER };
	CEdit m_editComputerName;
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_ADD_COMPUTER[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddServ)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddServ)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowse();
	afx_msg void OnRadioBtnClicked();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
public:
	CString m_stComputerName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\dlgaddm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

#if !defined(AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_)
#define AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// dlgaddm.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddMachineDlg dialog

class CAddMachineDlg : public CDialog
{
// Construction
public:
	CAddMachineDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddMachineDlg)
	enum { IDD = IDD_ADD_MACHINE };
	CString	m_strMachineName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddMachineDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddMachineDlg)
	afx_msg void OnBrowse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDM_H__C2A9C6F6_5628_11D1_9AA9_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\addserv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    edituser.h
        Edit user dialog implementation file

	FILE HISTORY:

*/

#include "stdafx.h"
#include "AddServ.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddServ dialog


CAddServ::CAddServ(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddServ::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddServ)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAddServ::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddServ)
	DDX_Control(pDX, IDC_ADD_EDIT_NAME, m_editComputerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddServ, CBaseDialog)
	//{{AFX_MSG_MAP(CAddServ)
	ON_BN_CLICKED(IDC_BTN_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(IDC_ADD_LOCAL, OnRadioBtnClicked)
	ON_BN_CLICKED(IDC_ADD_OTHER, OnRadioBtnClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddServ message handlers

BOOL CAddServ::OnInitDialog()
{
	CBaseDialog::OnInitDialog();

	CheckDlgButton(IDC_ADD_OTHER, BST_CHECKED);

	m_editComputerName.SetFocus();
	
	OnRadioBtnClicked();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CAddServ::OnButtonBrowse()
{
    CGetComputer getComputer;

	if (!getComputer.GetComputer(GetSafeHwnd()))
        return;

	CString strTemp = getComputer.m_strComputerName;

	m_editComputerName.SetWindowText(strTemp);
}


void CAddServ::OnRadioBtnClicked()
{
	BOOL fEnable = IsDlgButtonChecked(IDC_ADD_OTHER);

	m_editComputerName.EnableWindow(fEnable);
	GetDlgItem(IDC_BTN_BROWSE)->EnableWindow(fEnable);
}

void CAddServ::OnOK()
{
	DWORD dwLength;

	if (IsDlgButtonChecked(IDC_ADD_OTHER))
	{
		dwLength = m_editComputerName.GetWindowTextLength() + 1;
		if (dwLength <= 1)
		{
			AfxMessageBox(IDS_ERR_EMPTY_NAME);
			return;
		}

		m_editComputerName.GetWindowText(m_stComputerName.GetBuffer(dwLength), dwLength);
	}
	else
	{
		dwLength = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerName(m_stComputerName.GetBuffer(dwLength), &dwLength);
	}

	m_stComputerName.ReleaseBuffer();

	CBaseDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\fltrnode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Filter node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "FltrNode.h"
#include "SpdUtil.h"
#include "fltrpp.h"
#include "srchfltr.h"

/*---------------------------------------------------------------------------
    Class CFilterHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CFilterHandler::CFilterHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData), 
	m_FltrType(FILTER_TYPE_ANY)		//by default we display both transport and tunnel filters

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CFilterHandler::~CFilterHandler()
{
}

/*!--------------------------------------------------------------------------
    CFilterHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CFilterHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_FILTER_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_FILTER);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_FILTER][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_FILTER][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CFilterHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CFilterHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CFilterHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CFilterHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

	if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
	{
		strMenuItem.LoadString(IDS_VIEW_ALL_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_ALL_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_ANY == m_FltrType) ? MF_CHECKED : 0 );

		strMenuItem.LoadString(IDS_VIEW_TRANSPORT_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_TRANSPORT_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_TRANSPORT == m_FltrType) ? MF_CHECKED : 0 );

		strMenuItem.LoadString(IDS_VIEW_TUNNEL_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_TUNNEL_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_TUNNEL == m_FltrType) ? MF_CHECKED : 0 );
		ASSERT( SUCCEEDED(hr) );
	}


    return hr;
}

 /*!--------------------------------------------------------------------------
    CFilterHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CFilterHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    CORg(m_spSpdInfo->EnumQmFilters());

    m_spSpdInfo->ChangeQmFilterViewType(m_FltrType);
    i = m_spSpdInfo->GetQmFilterCountOfCurrentViewType();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));


Error:
	return hr;
}


/*---------------------------------------------------------------------------
    CFilterHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//handle the scope context menu commands here

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	FILTER_TYPE NewFltrType = m_FltrType;

	// handle result context menu and view menus here
	switch (nCommandID)
    {
        case IDS_VIEW_ALL_FLTR:
			NewFltrType = FILTER_TYPE_ANY;
            break;

        case IDS_VIEW_TRANSPORT_FLTR:
			NewFltrType = FILTER_TYPE_TRANSPORT;
            break;

		case IDS_VIEW_TUNNEL_FLTR:
			NewFltrType = FILTER_TYPE_TUNNEL;
			break;

        default:
            break;
    }

	//Update the views if a different view is selected.
	if (NewFltrType != m_FltrType)
	{
		m_FltrType = NewFltrType;
		UpdateViewType(spNode, m_FltrType);
	}
    return hr;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CFilterHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpSA != NULL);

    //return pServerProp->CreateModelessSheet(lpSA, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CFilterHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CFilterHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_QM_FILTER)) {
            CORg(m_spSpdInfo->EnumQmFilters());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_FILTER);
            //m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_SP_FILTER);
        }
        m_spSpdInfo->SetActiveInfo(MON_QM_FILTER);


        // Get the current count
        i = m_spSpdInfo->GetQmFilterCountOfCurrentViewType();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 


		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			pConsole2->SetStatusText((LPOLESTR) (LPCTSTR) strTemp);
		    pConsole2->Release();
		}
    }

	
    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_FILTER_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
		bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CFilterHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;
	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CFilterInfo FltrInfo;
	CFilterProperties * pFilterProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetFilterInfo(nIndex, &FltrInfo));

	pFilterProp = new CFilterProperties(
												spNode,
												spComponentData,
												m_spTFSCompData,
												&FltrInfo,
												m_spSpdInfo,
												NULL);

	hr = pFilterProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CFilterHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CFilterHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CFilterHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CFilterHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CFilterHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_FILTER]))
		return NULL;
	
	CFilterInfo filter;
	CORg(m_spSpdInfo->GetFilterInfo(nIndex, &filter));

    switch (aColumns[IPSECMON_FILTER][nCol])
    {
        case IDS_COL_FLTR_NAME:
			{
			strTemp = filter.m_stName;
			
			if( filter.m_dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY )
			{
				AfxFormatString1(strTemp, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) filter.m_stName);
			}
				
						
			return strTemp;
            break;
			}

        case IDS_COL_FLTR_SRC:
			AddressToString(filter.m_SrcAddr, &strTemp);
			return strTemp;
            break;

        case IDS_COL_FLTR_DEST:
			AddressToString(filter.m_DesAddr, &strTemp);
			return strTemp;
            break;

		case IDS_COL_FLTR_SRC_PORT:
			PortToString(filter.m_SrcPort, &strTemp);
			return strTemp;
			break;
		
		case IDS_COL_FLTR_DEST_PORT:
			PortToString(filter.m_DesPort, &strTemp);
			return strTemp;
			break;

		case IDS_COL_FLTR_SRC_TNL:
			TnlEpToString(filter.m_FilterType,
						  filter.m_MyTnlAddr,
						  &strTemp
						  );
			return strTemp;
			break;

		case IDS_COL_FLTR_DEST_TNL:
			TnlEpToString(filter.m_FilterType,
						  filter.m_PeerTnlAddr,
						  &strTemp
						  );

			return strTemp;
			break;

		case IDS_COL_FLTR_PROT:
			ProtocolToString(filter.m_Protocol, &strTemp);
			return strTemp;
			break;

		case IDS_COL_QM_POLICY:
			strTemp = filter.m_stPolicyName;
			return strTemp;
			break;

		case IDS_COL_IF_TYPE:
			InterfaceTypeToString(filter.m_InterfaceType, &strTemp);
			return strTemp;
			break;

		case IDS_COL_FLTR_OUT_FLAG:
			FilterFlagToString(filter.m_OutboundFilterAction, &strTemp);
			return strTemp;
			break;

		case IDS_COL_FLTR_IN_FLAG:
			FilterFlagToString(filter.m_InboundFilterAction, &strTemp);
			return strTemp;
			break;

        default:
            Panic0("CFilterHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CFilterHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CFilterHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CFilterHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_FILTER]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD	dwIndexType = aColumns[IPSECMON_FILTER][nColumn];

	hr = m_spSpdInfo->SortFilters(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}

/*!--------------------------------------------------------------------------
    CFilterHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CFilterHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CFilterHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CFilterHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CFilterHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}

/*---------------------------------------------------------------------------
    CFilterHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CFilterHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CFilterHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    m_spSpdInfo->ChangeQmFilterViewType(m_FltrType);
    i = m_spSpdInfo->GetQmFilterCountOfCurrentViewType();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CFilterHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CFilterHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}


HRESULT 
CFilterHandler::UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType)
{
	// clear the listbox then set the size

    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    SPIConsole          spConsole;
    IDataObject*        pDataObject;
    SPIDataObject       spDataObject;
    LONG_PTR            command;               
    int i;

    COM_PROTECT_TRY
    {
		m_FltrType = NewFltrType;

		//tell the spddb to update its index manager for QM filter
		m_spSpdInfo->ChangeQmFilterViewType(m_FltrType);

        i = m_spSpdInfo->GetQmFilterCountOfCurrentViewType();

		m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    
		//update the result pane virtual list
        CORg ( spConsole->UpdateAllViews(spDataObject, i, RESULT_PANE_CLEAR_VIRTUAL_LB) ); 

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\fltrnode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _FLTRNODE_H
#define _FLTRNODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

/*---------------------------------------------------------------------------
	Class:	CFilterHandler
 ---------------------------------------------------------------------------*/
class CFilterHandler : public CIpsmHandler
{
public:
    CFilterHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CFilterHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);


    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmFilterNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);
	HRESULT UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType);



private:
    SPISpdInfo  m_spSpdInfo;
	FILTER_TYPE	m_FltrType;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\fltrpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "fltrpp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CFilterProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CFilterProperties::CFilterProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
	CFilterInfo *		pFilterInfo,
    ISpdInfo *          pSpdInfo,
    LPCTSTR             pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_FltrInfo = *pFilterInfo;

	m_bTheme = TRUE;
}

CFilterProperties::~CFilterProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CFilterGenProp property page

IMPLEMENT_DYNCREATE(CFilterGenProp, CPropertyPageBase)

CFilterGenProp::CFilterGenProp() : CPropertyPageBase(CFilterGenProp::IDD)
{
    //{{AFX_DATA_INIT(CFilterGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CFilterGenProp::~CFilterGenProp()
{
}

void CFilterGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilterGenProp)
    DDX_Control(pDX, IDC_LIST_SPECIFIC, m_listSpecificFilters);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CFilterGenProp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterGenProp message handlers

BOOL CFilterGenProp::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CPropertyPageBase::OnInitDialog();
    
	PopulateFilterInfo();	
	LoadSpecificFilters();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CFilterGenProp::PopulateFilterInfo()
{
	CString st;
	CString stMask;
	
	CFilterProperties * pFltrProp;
	CFilterInfo * pFltrInfo;
	
	
	pFltrProp = (CFilterProperties *) GetHolder();
	Assert(pFltrProp);

	pFltrProp->GetFilterInfo(&pFltrInfo);

	
	BOOL fSrcIsName = FALSE;
	BOOL fHideMask = FALSE;
	BOOL fUseEditForAddr = FALSE; 
	int iIDSrcAddr = IDC_FLTR_SRC_ADDR;

	switch (pFltrInfo->m_SrcAddr.AddrType)
	{
	case IP_ADDR_UNIQUE:
		if (IP_ADDRESS_ME == pFltrInfo->m_SrcAddr.uIpAddr)
		{
			st.LoadString(IDS_ADDR_ME);
			fHideMask = TRUE;
			
		}
		else
		{
			AddressToString(pFltrInfo->m_SrcAddr, &st, &fSrcIsName);
			if (fSrcIsName)
			{
				fUseEditForAddr = TRUE;
				fHideMask = TRUE;
			}
			else
			{
				stMask = c_szSingleAddressMask;
				IpToString(pFltrInfo->m_SrcAddr.uIpAddr, &st);
			}
		}

		break;

	case IP_ADDR_DNS_SERVER:
	case IP_ADDR_WINS_SERVER:
	case IP_ADDR_DHCP_SERVER:
	case IP_ADDR_DEFAULT_GATEWAY:
		AddressToString(pFltrInfo->m_SrcAddr, &st);
		break;

	case IP_ADDR_SUBNET:
		if (SUBNET_ADDRESS_ANY == pFltrInfo->m_SrcAddr.uSubNetMask)
		{
			st.LoadString(IDS_ADDR_ANY);
			fHideMask = TRUE;
		}
		else
		{
			IpToString(pFltrInfo->m_SrcAddr.uIpAddr, &st);
			IpToString(pFltrInfo->m_SrcAddr.uSubNetMask, &stMask);
		}
		break;
	}

	//Populate the SRC info to the controls now
	if (fHideMask)
	{
		GetDlgItem(IDC_FLTR_SRC_MASK)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_SRC_MASK)->ShowWindow(SW_HIDE);
	}
	else
	{
		GetDlgItem(IDC_FLTR_SRC_MASK)->SetWindowText(stMask);
	}

	if (fUseEditForAddr)
	{
		iIDSrcAddr = IDC_FLTR_SRC_ADDR_EDIT;
		GetDlgItem(IDC_FLTR_SRC_ADDR)->ShowWindow(SW_HIDE);
	}
	else
	{
		iIDSrcAddr = IDC_FLTR_SRC_ADDR;
		GetDlgItem(IDC_FLTR_SRC_ADDR_EDIT)->ShowWindow(SW_HIDE);
	}

	GetDlgItem(iIDSrcAddr)->SetWindowText(st);



	//Start handling the destination now
	BOOL fDestDns = FALSE;
	int iIDDestAddr = IDC_FLTR_DEST_ADDR;
	fUseEditForAddr = FALSE;
	fHideMask = FALSE;
	st.Empty();
	stMask.Empty();

	switch (pFltrInfo->m_DesAddr.AddrType)
	{
	case IP_ADDR_UNIQUE:
		if (IP_ADDRESS_ME == pFltrInfo->m_DesAddr.uIpAddr)
		{
			st.LoadString(IDS_ADDR_ME);
			fHideMask = TRUE;
		}
		else
		{
			AddressToString(pFltrInfo->m_DesAddr, &st, &fDestDns);
			if (fDestDns)
			{
				fHideMask = TRUE;
				fUseEditForAddr = TRUE;
			}
			else
			{
				stMask = c_szSingleAddressMask;
				IpToString(pFltrInfo->m_DesAddr.uIpAddr, &st);
			}
		}

		break;

	case IP_ADDR_DNS_SERVER:
	case IP_ADDR_WINS_SERVER:
	case IP_ADDR_DHCP_SERVER:
	case IP_ADDR_DEFAULT_GATEWAY:
		AddressToString(pFltrInfo->m_DesAddr, &st);
		break;

	case IP_ADDR_SUBNET:
		if (SUBNET_ADDRESS_ANY == pFltrInfo->m_DesAddr.uSubNetMask)
		{
			st.LoadString(IDS_ADDR_ANY);
			fHideMask = TRUE;
		}
		else
		{
			IpToString(pFltrInfo->m_DesAddr.uIpAddr, &st);
			IpToString(pFltrInfo->m_DesAddr.uSubNetMask, &stMask);
		}
		break;
	}

	if (fHideMask)
	{
		GetDlgItem(IDC_FLTR_DEST_MASK)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_DEST_MASK)->ShowWindow(SW_HIDE);
	}
	else
	{
		GetDlgItem(IDC_FLTR_DEST_MASK)->SetWindowText(stMask);
	}

	if (fUseEditForAddr)
	{
		GetDlgItem(IDC_FLTR_DEST_ADDR)->ShowWindow(SW_HIDE);
		iIDDestAddr = IDC_FLTR_DEST_ADDR_EDIT;
	}
	else
	{
		GetDlgItem(IDC_FLTR_DEST_ADDR_EDIT)->ShowWindow(SW_HIDE);
		iIDDestAddr = IDC_FLTR_DEST_ADDR;
	}
	GetDlgItem(iIDDestAddr)->SetWindowText(st);
	//We are done with the destination now



	PortToString(pFltrInfo->m_SrcPort, &st);
	GetDlgItem(IDC_FLTR_SRC_PORT)->SetWindowText(st);

	PortToString(pFltrInfo->m_DesPort, &st);
	GetDlgItem(IDC_FLTR_DEST_PORT)->SetWindowText(st);

	FilterFlagToString(pFltrInfo->m_InboundFilterAction, &st);
	GetDlgItem(IDC_FLTR_IN_FLAG)->SetWindowText(st);

	FilterFlagToString(pFltrInfo->m_OutboundFilterAction, &st);
	GetDlgItem(IDC_FLTR_OUT_FLAG)->SetWindowText(st);

	ProtocolToString(pFltrInfo->m_Protocol, &st);
	GetDlgItem(IDC_FLTR_PROTOCOL)->SetWindowText(st);

	InterfaceTypeToString(pFltrInfo->m_InterfaceType, &st);
	GetDlgItem(IDC_FLTR_IF_TYPE)->SetWindowText(st);

	BoolToString(pFltrInfo->m_bCreateMirror, &st);
	GetDlgItem(IDC_FLTR_MIRROR)->SetWindowText(st);

	st = pFltrInfo->m_stPolicyName;
	GetDlgItem(IDC_FLTR_POLICY)->SetWindowText(st);
}

void CFilterGenProp::LoadSpecificFilters()
{
	CFilterProperties * pFltrProp;
	CFilterInfo * pFltrInfo;
	CFilterInfoArray arraySpFilters;
	
	int nWidth;
	int nRows;
	CString st;


	pFltrProp = (CFilterProperties *) GetHolder();

	SPISpdInfo		spSpdInfo;
	pFltrProp->GetSpdInfo(&spSpdInfo);

	pFltrProp->GetFilterInfo(&pFltrInfo);
	spSpdInfo->EnumSpecificFilters(
					&pFltrInfo->m_guidFltr,
					&arraySpFilters,
					pFltrInfo->m_FilterType
					);

	
	nWidth = m_listSpecificFilters.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_FILTER_PP_COL_SRC);
	m_listSpecificFilters.InsertColumn(0, st,  LVCFMT_LEFT, nWidth);

	nWidth = m_listSpecificFilters.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_FILTER_PP_COL_DEST);
	m_listSpecificFilters.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTR_DIR_OUT);
	nWidth = m_listSpecificFilters.GetStringWidth((LPCTSTR)st) + 20;
	st.LoadString(IDS_FILTER_PP_COL_DIRECTION);
	m_listSpecificFilters.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_NEG_SEC);
	nWidth = m_listSpecificFilters.GetStringWidth(st) + 20;
	st.LoadString(IDS_FILTER_PP_COL_FLAG);
	m_listSpecificFilters.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_WEIGHT);
	nWidth = m_listSpecificFilters.GetStringWidth((LPCTSTR)st) + 20;
	m_listSpecificFilters.InsertColumn(4, st,  LVCFMT_LEFT, nWidth);
	
	nRows = 0;
	for (int i = 0; i < arraySpFilters.GetSize(); i++)
	{
		nRows = m_listSpecificFilters.InsertItem(nRows, _T(""));
		if (-1 != nRows)
		{
			AddressToString(arraySpFilters[i]->m_SrcAddr, &st);
			m_listSpecificFilters.SetItemText(nRows, 0, st);

			AddressToString(arraySpFilters[i]->m_DesAddr, &st);
			m_listSpecificFilters.SetItemText(nRows, 1, st);

			DirectionToString(arraySpFilters[i]->m_dwDirection, &st);
			m_listSpecificFilters.SetItemText(nRows, 2, st);

			FilterFlagToString((FILTER_DIRECTION_INBOUND == arraySpFilters[i]->m_dwDirection) ?
							arraySpFilters[i]->m_InboundFilterAction : 
							arraySpFilters[i]->m_OutboundFilterAction,
							&st
							);
			m_listSpecificFilters.SetItemText(nRows, 3, st);

			st.Format(_T("%d"), arraySpFilters[i]->m_dwWeight);
			m_listSpecificFilters.SetItemText(nRows, 4, st);

			m_listSpecificFilters.SetItemData(nRows, i);
		}
		nRows++;
	}

    if ( nRows > 0 )
    {
        //select the first item
        m_listSpecificFilters.SetFocus();
        m_listSpecificFilters.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }

	::FreeItemsAndEmptyArray(arraySpFilters);
}

BOOL CFilterGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//TODO
	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CFilterGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\gtusrdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corporation, 1992 - 2002   **/
/**********************************************************************/

/*
    GetUser.h

    This file contains the definitions for the User Browser "C" API

    FILE HISTORY:
        AndyHe  11-Oct-1992     Created

*/

#ifndef _GETUSER_H_
#define _GETUSER_H_

//#include <ntseapi.h>

typedef HANDLE    HUSERBROW;        // handle type returned by OpenUserBrowser

//
//   Parameter structure passed to OpenUserBrowser
//
typedef struct tagUSLT {    // uslt
    ULONG             ulStructSize;
    BOOL              fUserCancelled;   // Set if user cancelled
    BOOL              fExpandNames;     // TRUE if full names should be returned
    HWND              hwndOwner;        // Window handle to use for dialog
    WCHAR           * pszTitle;         // Dialog title (or NULL)
    WCHAR           * pszInitialDomain; // NULL for local machine or prefix
                                        // with "\\" for server
    DWORD             Flags;            // Defined below
    ULONG             ulHelpContext;    // Help context for the main dialog
    WCHAR           * pszHelpFileName;  // Help file name
}  USERBROWSER, *LPUSERBROWSER, * PUSERBROWSER;

//
// Bit values for Flags field
//

//
//  Indicates the user accounts should be shown as if the user pressed
//  the "Show Users" button.  The button will be hidden if this flag is
//  set.  The USRBROWS_SHOW_USERS flag must also be set.

#define USRBROWS_EXPAND_USERS       (0x00000008)

//
//  Passing this will prevent the computer name from showing up in the
//  combo box.
//

#define USRBROWS_DONT_SHOW_COMPUTER (0x00000100)

//
//  Allow the user to only select a single item from the listbox (not all
//  SHOW_* combinations are supported with this option).
//

#define USRBROWS_SINGLE_SELECT	    (0x00001000)

//
//  These manifests determine which well known Sids are included in the list.
//
#define USRBROWS_INCL_REMOTE_USERS  (0x00000010)
#define USRBROWS_INCL_INTERACTIVE   (0x00000020)
#define USRBROWS_INCL_EVERYONE      (0x00000040)
#define USRBROWS_INCL_CREATOR       (0x00000080)
#define USRBROWS_INCL_SYSTEM        (0x00010000)
#define USRBROWS_INCL_ALL           (USRBROWS_INCL_REMOTE_USERS |\
                                     USRBROWS_INCL_INTERACTIVE  |\
                                     USRBROWS_INCL_EVERYONE     |\
                                     USRBROWS_INCL_CREATOR      |\
                                     USRBROWS_INCL_SYSTEM)

//
//  These manifests determine which type of accounts to display
//
//  Note: currently, if you display groups, you must display users
//		     if you display aliases (local groups), you must display
//			   groups and users
//
#define USRBROWS_SHOW_ALIASES	    (0x00000001)
#define USRBROWS_SHOW_GROUPS	    (0x00000002)
#define USRBROWS_SHOW_USERS	    (0x00000004)
#define USRBROWS_SHOW_ALL	    (USRBROWS_SHOW_ALIASES |\
				     USRBROWS_SHOW_GROUPS  |\
				     USRBROWS_SHOW_USERS)


//
// The caller should provide the name of a help file containing four
// help contexts.  The first help context is for the main User Browser
// dialog, the next three are for the Local Group Membership, Global Group
// Membership, and Find Account subdialogs, respectively.
//
#define USRBROWS_HELP_OFFSET_LOCALGROUP  1
#define USRBROWS_HELP_OFFSET_GLOBALGROUP 2
#define USRBROWS_HELP_OFFSET_FINDUSER    3

//
//  User Details structure returned by user browser enumeration
//
typedef struct tagUSDT {    // usdt
    enum _SID_NAME_USE    UserType;
    PSID                  psidUser;
    PSID                  psidDomain;
    WCHAR               * pszFullName;
    WCHAR               * pszAccountName;
    WCHAR               * pszDisplayName;
    WCHAR               * pszDomainName;
    WCHAR               * pszComment;
    ULONG                 ulFlags;          // User account flags
} USERDETAILS, * LPUSERDETAILS, * PUSERDETAILS;


// Function definitions for the GetUser API...

HUSERBROW WINAPI OpenUserBrowser( LPUSERBROWSER lpUserParms );

BOOL WINAPI EnumUserBrowserSelection( HUSERBROW hHandle,
                                      LPUSERDETAILS lpUser,
                                      DWORD *plBufferSize );

BOOL WINAPI CloseUserBrowser( HUSERBROW hHandle );

#endif //_GETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\fltrpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358A__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358A__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CFilterGenProp dialog

class CFilterGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CFilterGenProp)

// Construction
public:
    CFilterGenProp();
    ~CFilterGenProp();

// Dialog Data
    //{{AFX_DATA(CFilterGenProp)
    enum { IDD = IDP_FILTER_GENERAL };
    CListCtrl	m_listSpecificFilters;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDP_FILTER_GENERAL[0]; }


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFilterGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CFilterGenProp)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void LoadSpecificFilters();
	void PopulateFilterInfo();
};


class CFilterProperties : public CPropertyPageHolderBase
{
    friend class CFilterGenProp;

public:
    CFilterProperties(ITFSNode *         pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      CFilterInfo *       pFltrInfo,
					  ISpdInfo *          pSpdInfo,
                      LPCTSTR             pszSheetName);
    virtual ~CFilterProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetFilterInfo(CFilterInfo **ppFltrInfo)
	{
		Assert(ppFltrInfo);
		*ppFltrInfo = &m_FltrInfo;
		return hrOK;
	}

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }



public:
    CFilterGenProp			   m_pageGeneral;

protected:
	SPITFSComponentData     m_spTFSCompData;
	CFilterInfo				m_FltrInfo;
	SPISpdInfo             m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\guids.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	guids.cpp
		IPSecMon snapin GUID definitions

	FILE HISTORY:
        
*/
#include "stdafx.h"


// MMC required node types

// {E26D02A0-4C1F-11d1-9AA1-00C04FC3357A}
static const CLSID CLSID_IpsmSnapin = 
{ 0x57c596d0, 0x9370, 0x40c0, { 0xba, 0x0d, 0xab, 0x49, 0x1b, 0x63, 0x25, 0x5d } };

static const CLSID CLSID_IpsmSnapinExtension = 
{ 0xa17da8d0, 0xf67d, 0x47a0, { 0x9e, 0xc4, 0x19, 0xc4, 0x86, 0x38, 0x32, 0x06 } };

static const GUID CLSID_IpsmSnapinAbout = 
{ 0x8229782, 0x89c8, 0x4028, { 0xbb, 0x74, 0x75, 0xbb, 0x58, 0xef, 0x14, 0x88 } };

//
// Scope pane node types
//

static const GUID GUID_IpsmRootNodeType = 
{ 0x3ed3afec, 0x2ff1, 0x45ac, { 0x84, 0xc7, 0xa5, 0xd3, 0x43, 0x04, 0x0e, 0xbb } };

static const GUID GUID_IpsmServerNodeType = 
{ 0x52f8357f, 0x01ab, 0x40fd, { 0xb3, 0x9d, 0x2f, 0xb2, 0x82, 0x1b, 0x82, 0x3b } };

static const GUID GUID_IpsmFilterNodeType = 
{ 0xaa5029d5, 0x734e, 0x4aee, { 0x91, 0x4d, 0xdf, 0x5d, 0xad, 0xc6, 0x23, 0x04 } };


//
// result pane item GUIDs
//

static const GUID GUID_IpsmSpecificFilterNodeType = 
{ 0x3a1f6f83, 0xcb76, 0x4a01, { 0xa1, 0x6d, 0xb7, 0x9c, 0x79, 0x9b, 0x0c, 0xfa } };

static const GUID GUID_IpsmMmPolicyNodeType = 
{ 0xd7e75f1f, 0x26e0, 0x4cb4, { 0x83, 0xf9, 0xf9, 0xb1, 0x2e, 0xfb, 0xad, 0x12 } };

static const GUID GUID_QmNodeType = 
{ 0xef66d1e4, 0x4639, 0x457d, { 0x95, 0x6c, 0x49, 0xd5, 0x91, 0x7f, 0xaf, 0xb2 } };

static const GUID GUID_MmNodeType = 
{ 0x27cee91e, 0xc392, 0x4f37, { 0xab, 0x06, 0xa2, 0x59, 0xed, 0x06, 0x00, 0xde } };

//
//  GUID for our fake ISpdInfo object
//
static const GUID IID_ISpdInfo = 
{ 0xdb97bada, 0x14b4, 0x4498, { 0xad, 0x39, 0x2e, 0x79, 0x1d, 0x11, 0xca, 0x2d } };

static const GUID GUID_IpsmQmSANodeType = 
{ 0xdda95245, 0x05e5, 0x4584, { 0xb5, 0xed, 0x28, 0xd8, 0xa0, 0x2b, 0x20, 0x98 } };

static const GUID GUID_IpsmQmPolicyNodeType = 
{ 0x436c37a3, 0x4312, 0x452d, { 0x99, 0x1f, 0x88, 0xbd, 0xc4, 0x00, 0xbc, 0x86 } };

static const GUID GUID_IpsmMmFilterNodeType = 
{ 0xff4f6a1a, 0x0f2b, 0x4570, { 0x91, 0x16, 0x28, 0x57, 0x16, 0xa3, 0x56, 0xc0 } };

static const GUID GUID_IpsmMmSpFilterNodeType = 
{ 0xb510e5fd, 0xef94, 0x4b4f, { 0x8b, 0x67, 0xf1, 0x7f, 0x5d, 0x76, 0x6d, 0xc8 } };

static const GUID GUID_IpsmMmSANodeType = 
{ 0xac5721aa, 0xcfa6, 0x40c7, { 0x9c, 0xa7, 0x7f, 0x11, 0x65, 0x57, 0xab, 0x3a } };


static const GUID GUID_IpsmMmIkeStatsNodeType = 
{ 0x62665ec0, 0xc924, 0x49e6, { 0x8b, 0xd6, 0x50, 0xbf, 0xa1, 0xa, 0xff, 0x20 } };

static const GUID GUID_IpsmMmIpsecStatsNodeType = 
{ 0x7945347d, 0xe45f, 0x4dfc, { 0x9e, 0xee, 0x69, 0xf9, 0x5b, 0xdf, 0x30, 0xa } };

static const GUID GUID_IpsmActivePolNodeType = 
{ 0xaa29aee0, 0xd672, 0x4136, { 0x83, 0xd8, 0x7c, 0xaf, 0xa1, 0xf8, 0x3f, 0x81 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipctrl.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1996 - 2002   **/
/**********************************************************************/

//============================================================================
// History:
//              Tony Romano             Created.
//  06/17/96    Abolade Gbadegesin      Revised.
//
// Implements the C++ class encapsulating the IP-address custom control.
//============================================================================

#include "stdafx.h"
extern "C" {
#include "ipaddr.h"
};

#include "ipctrl.h"




IPControl::IPControl( ) { m_hIPaddr = 0; }

IPControl::~IPControl( ) { }



BOOL
IPControl::Create(
    HWND        hParent,
    UINT        nID
    ) {

    ASSERT(IsWindow(hParent));

    if (hParent)    
        m_hIPaddr   = GetDlgItem(hParent, nID);

    return m_hIPaddr != NULL;   
}



LRESULT
IPControl::SendMessage(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
    ) {

    ASSERT(IsWindow(m_hIPaddr));

    return ::SendMessage(m_hIPaddr, uMsg, wParam, lParam);
}



BOOL
IPControl::IsBlank(
    ) {

    return (BOOL)SendMessage(IP_ISBLANK, 0, 0);
}



VOID
IPControl::SetAddress(
    DWORD       ardwAddress[4]
    ) {

    SendMessage(
        IP_SETADDRESS, 0,
        MAKEIPADDRESS(
            ardwAddress[0], ardwAddress[1], ardwAddress[2], ardwAddress[3]
            )
        );
}



VOID
IPControl::SetAddress(
    DWORD       a1,
    DWORD       a2,
    DWORD       a3,
    DWORD       a4
    ) {

    SendMessage(IP_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}



VOID
IPControl::SetAddress(
    LPCTSTR     lpszString
    ) {

    if (!lpszString) { ClearAddress(); }

    SendMessage(WM_SETTEXT, 0, (LPARAM)lpszString);
}


INT
IPControl::GetAddress(
    DWORD       *a1,
    DWORD       *a2,
    DWORD       *a3,
    DWORD       *a4
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    ASSERT(a1 && a2 && a3 && a4);

    if ((nSet = SendMessage(IP_GETADDRESS,0,(LPARAM)&dwAddress)) == 0) {

        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else {

        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    DWORD       ardwAddress[4]
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    if ((nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress )) == 0) {

        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else {

        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    CString&    address
    ) {

    INT_PTR c, nSet;
    DWORD dwAddress;

    nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress);

    address.ReleaseBuffer((int)(c = SendMessage(WM_GETTEXT, 256, (LPARAM)address.GetBuffer(256))));

    return (INT)nSet;
}


VOID
IPControl::SetFocusField(
    DWORD       dwField
    ) {

    SendMessage(IP_SETFOCUS, dwField, 0);
}


VOID
IPControl::ClearAddress(
    ) {

    SendMessage(IP_CLEARADDRESS, 0, 0);
}


VOID
IPControl::SetFieldRange(
    DWORD       dwField,
    DWORD       dwMin,
    DWORD       dwMax
    ) {

    SendMessage(IP_SETRANGE, dwField, MAKERANGE(dwMin,dwMax));
}

#if 0
WCHAR *
inet_ntoaw(
    struct in_addr  dwAddress
    ) {

    static WCHAR szAddress[16];

    mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);

    return szAddress;
}


DWORD
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\harray.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2002   **/
/**********************************************************************/

/*
	harray.h
		Index mgr for IPSecmon

	FILE HISTORY:
    Nov 29  1999    Ning Sun     Created        

*/

#ifndef _HARRAY_H__
#define _HARRAY_H__


#include "afxmt.h"


extern const DWORD INDEX_TYPE_DEFAULT;

typedef enum _SORT_OPTIONS
{
	SORT_DESCENDING	= 0x00,
	SORT_ASCENDING	= 0x01

} SORT_OPTIONS;



typedef CArray<void *, void *> CIndexArray;
typedef int (__cdecl *PCOMPARE_FUNCTION)(const void *elem1, const void *elem2);

class CColumnIndex : public CIndexArray
{
public:
	CColumnIndex(DWORD dwIndexType, PCOMPARE_FUNCTION pfnCompare);

public:
	HRESULT Sort();
	VOID SetSortOption(DWORD dwSortOption) { m_dwSortOption = dwSortOption; }
	DWORD GetSortOption() { return m_dwSortOption; }
	DWORD GetType() { return m_dwIndexType; }
	void* GetIndexedItem(int nIndex);

protected:
	DWORD m_dwIndexType;
	DWORD m_dwSortOption;
	PCOMPARE_FUNCTION m_pfnCompare;
};

typedef CList<CColumnIndex*, CColumnIndex*> CIndexArrayList;

class CIndexManager
{
public:
	CIndexManager();
	virtual ~CIndexManager();

protected:
	CColumnIndex m_DefaultIndex;
	CIndexArrayList m_listIndicies;
	POSITION m_posCurrentIndex;

public:
	void Reset();

	int AddItem(void * pItem);
	int GetItemCount() { return (int)m_DefaultIndex.GetSize(); }

	void * GetItemData(int nIndex);

	virtual HRESULT Sort(
				DWORD SortType, 
				DWORD dwSortOption
				) { return hrOK; }
	
	DWORD GetCurrentIndexType();
	DWORD GetCurrentSortOption();
};

class CIndexMgrFilter : public CIndexManager
{
public:
	CIndexMgrFilter() : CIndexManager() {}

public:
    HRESULT SortFilters(
				DWORD SortType, 
				DWORD dwSortOption
				);
};

class CIndexMgrMmFilter : public CIndexManager
{
public:
	CIndexMgrMmFilter() : CIndexManager() {}

public:
    HRESULT SortMmFilters(
				DWORD SortType, 
				DWORD dwSortOption
				);
};

class CIndexMgrMmPolicy : public CIndexManager
{
public:
	CIndexMgrMmPolicy() : CIndexManager() {}

public:
	HRESULT Sort(
			   DWORD dwSortType,
			   DWORD dwSortOption
			   );
};

class CIndexMgrQmPolicy : public CIndexManager
{
public:
	CIndexMgrQmPolicy() : CIndexManager() {}

public:
	HRESULT Sort(
			   DWORD dwSortType,
			   DWORD dwSortOption
			   );

};

class CIndexMgrMmSA : public CIndexManager
{
public:
	CIndexMgrMmSA() : CIndexManager() {}

public:
	HRESULT Sort(
				DWORD dwSortType,
				DWORD dwSortOption
				);
};

class CIndexMgrQmSA : public CIndexManager
{
public:
	CIndexMgrQmSA() : CIndexManager() {}

public:
	HRESULT Sort(
				DWORD dwSortType,
				DWORD dwSortOption
				);
};

#endif //_HARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipctrl.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1996 - 2002   **/
/**********************************************************************/

//============================================================================
// History:
//  ??/??/??    Tony Romano         Created.
//  05/16/96    Abolade Gbadegesin  Revised.
//============================================================================

#ifndef __IPCTRL_H
#define __IPCTRL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//----------------------------------------------------------------------------
// Class:       IPControl
//
// Controls an IP-address edit-control.
//----------------------------------------------------------------------------

class IPControl {
    
    public:

        IPControl( );
        ~IPControl( );
    
        BOOL
        Create(
            HWND        hParent,
            UINT        nID );

        VOID
        Create(HWND hwnd)
        {
            m_hIPaddr = hwnd;
        }

        operator
        HWND( ) { ASSERT(m_hIPaddr); return m_hIPaddr; }
    
        BOOL
        IsBlank( );

        VOID
        SetFocusField(
            DWORD       dwField );

        VOID
        SetFieldRange(
            DWORD       dwField,
            DWORD       dwMin,
            DWORD       dwMax );

        VOID
        ClearAddress( );
    
        VOID
        SetAddress(
            DWORD       ardwAddress[4] );

        VOID
        SetAddress(
            DWORD       a1,
            DWORD       a2,
            DWORD       a3,
            DWORD       a4 );

        VOID
        SetAddress(
            LPCTSTR     lpszString );
    
        INT 
        GetAddress(
            DWORD       ardwAddress[4] );

        INT 
        GetAddress(
            DWORD*      a1,
            DWORD*      a2,
            DWORD*      a3,
            DWORD*      a4 );

        INT
        GetAddress(
            CString&    address );
    
        LRESULT
        SendMessage(
            UINT        uMsg,
            WPARAM      wParam,
            LPARAM      lParam );
    
    public:

        HWND            m_hIPaddr;
};



//----------------------------------------------------------------------------
// Macro:   MAKEADDR
//
// Given an a, b, c, and d, constructs a network-order DWORD corresponding
// to the IP-address a.b.c.d
//----------------------------------------------------------------------------

#define MAKEADDR(a, b, c, d) \
    (((a) & 0xff) | (((b) & 0xff) << 8) | (((c) & 0xff) << 16) | (((d) & 0xff) << 24))


//----------------------------------------------------------------------------
// Macros:      INET_NTOA
//              INET_ADDR
//
// Generic-text macros for IP-address conversion.
//----------------------------------------------------------------------------

/*
#ifndef UNICODE
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addr
#else
#define INET_NTOA(a)    inet_ntoaw(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addrw
#endif
*/

//----------------------------------------------------------------------------
// Macro:       INET_CMP
//
// Comparison macro for IP addresses.
//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument
//----------------------------------------------------------------------------

inline int INET_CMP(DWORD a, DWORD b)
{
	DWORD	t;
	
	return ((t = ((a & 0x000000ff) - (b & 0x000000ff))) ? t :  
	((t = ((a & 0x0000ff00) - (b & 0x0000ff00))) ? t :   
	((t = ((a & 0x00ff0000) - (b & 0x00ff0000))) ? t :  
	((t = (((a>>8) & 0x00ff0000) - ((b>>8) & 0x00ff0000)))))));
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    ipsmcomp.cpp
        This file contains the derived implementations from CComponent
        and CComponentData for the IPSecMon snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "server.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD gdwIpsmSnapVersion;

UINT aColumns[IPSECMON_NODETYPE_MAX][MAX_COLUMNS] =
{
    {IDS_ROOT_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {IDS_SERVER_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{IDS_COL_QM_SA_SRC, IDS_COL_QM_SA_DEST, IDS_COL_QM_SA_PROT, IDS_COL_QM_SA_SRC_PORT, IDS_COL_QM_SA_DES_PORT, IDS_COL_QM_SA_POL, IDS_COL_QM_SA_AUTH, IDS_COL_QM_SA_CONF, IDS_COL_QM_SA_INTEGRITY, IDS_COL_QM_SA_MY_TNL, IDS_COL_QM_SA_PEER_TNL, 0, 0, 0},  //IPSECMON_QM_SA
	{IDS_COL_FLTR_NAME, IDS_COL_FLTR_SRC, IDS_COL_FLTR_DEST, IDS_COL_FLTR_SRC_PORT,	IDS_COL_FLTR_DEST_PORT, IDS_COL_FLTR_SRC_TNL, IDS_COL_FLTR_DEST_TNL, IDS_COL_FLTR_PROT, IDS_COL_FLTR_IN_FLAG, IDS_COL_FLTR_OUT_FLAG, IDS_COL_QM_POLICY, IDS_COL_IF_TYPE, 0, 0}, // IPSMSNAP_FILTER
	{IDS_COL_FLTR_NAME, IDS_COL_FLTR_SRC, IDS_COL_FLTR_DEST, IDS_COL_FLTR_SRC_PORT,	IDS_COL_FLTR_DEST_PORT, IDS_COL_FLTR_SRC_TNL, IDS_COL_FLTR_DEST_TNL, IDS_COL_FLTR_PROT, IDS_COL_FLTR_FLAG, IDS_COL_FLTR_DIR, IDS_COL_QM_POLICY, IDS_COL_FLTR_WEIGHT, 0, 0}, // IPSECMON_SPECIFIC_FILTER
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0},	//IPSECMON_QUICK_MODE
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0},	//IPSECMON_MAIN_MODE
	{IDS_COL_MM_POL_NAME,IDS_COL_MM_POL_OFFER,0,0,0,0,0,0,0,0,0,0,0,0},	//IPSECMON_MM_POLICY
	{IDS_COL_QM_POL_NAME,IDS_COL_QM_POL_OFFER,0,0,0,0,0,0,0,0,0,0,0,0},	//IPSECMON_QM_POLICY
	{IDS_COL_FLTR_NAME, IDS_COL_FLTR_SRC, IDS_COL_FLTR_DEST, IDS_COL_MM_FLTR_POL, IDS_COL_MM_FLTR_AUTH,IDS_COL_IF_TYPE,0,0,0,0,0,0,0,0}, // IPSMSNAP_MM_FILTER
	{IDS_COL_FLTR_NAME, IDS_COL_FLTR_SRC, IDS_COL_FLTR_DEST,IDS_COL_FLTR_DIR,IDS_COL_MM_FLTR_POL,IDS_COL_MM_FLTR_AUTH,IDS_COL_FLTR_WEIGHT,0,0,0,0,0,0,0}, // IPSMSNAP_MM_SP_FILTER
	{IDS_COL_MM_SA_ME, IDS_COL_MM_SA_MYID,IDS_COL_MM_SA_PEER, IDS_COL_MM_SA_PEERID, IDS_COL_MM_SA_AUTH,IDS_COL_MM_SA_ENCRYPITON,IDS_COL_MM_SA_INTEGRITY,IDS_COL_MM_SA_DH,0,0,0,0,0,0},	//IPSECMON_MM_SA
	{IDS_STATS_NAME,IDS_STATS_DATA,0,0,0,0,0,0,0,0,0,0,0,0},//IPSECMON_MM_IKESTATS
	{IDS_STATS_NAME,IDS_STATS_DATA,0,0,0,0,0,0,0,0,0,0,0,0},//IPSECMON_QM_IPSECSTATS
	{IDS_ACTPOL_ITEM,IDS_ACTPOL_DESCR,0,0,0,0,0,0,0,0,0,0,0,0},//IPSECMON_ACTIVE_POL
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int aColumnWidths[IPSECMON_NODETYPE_MAX][MAX_COLUMNS] =
{   
    {200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSMSNAP_ROOT
    {200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSMSNAP_SERVER
    {150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_QM_SA
	{150       ,150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_FILTER
	{150       ,150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_SPECIFIC_FILTER
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_QUICK_MODE
	{AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_MAIN_MODE
	{150	   ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_MM_POLICY
	{150	   ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_QM_POLICY
	{150       ,150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_MM_FILTER
	{150       ,150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_MM_SP_FILTER
	{150       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // IPSECMON_MM_SA
	{300,150,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, //IPSECMON_MM_IKESTATS
	{300,150,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, //IPSECMON_QM_IPSECSTATS
	{300,150,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, //IPSECMON_ACTIVE_POL
	{AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, 
};

#define HI HIDDEN
#define EN ENABLED

MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
    MMC_VERB_OPEN,
    MMC_VERB_COPY,
    MMC_VERB_PASTE,
    MMC_VERB_DELETE,
    MMC_VERB_PROPERTIES,
    MMC_VERB_RENAME,
    MMC_VERB_REFRESH,
    MMC_VERB_PRINT
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStates[IPSECMON_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_ROOT
    {HI, HI, HI, EN, EN, HI, HI, HI}, // IPSMSNAP_SERVER
    {HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_SA
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_SPECIFIC_FILTER
	{HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_QUICK_MODE,
	{HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_MAIN_MODE,
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_POLICY
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_POLICY
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_SP_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_SA
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_IKESTATS
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_IPSECSTATS
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_ACTIVE_POL
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_QM_SA_ITEM,
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_FILTER_ITEM
	{HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_SPECIFIC_FILTER_ITEM,
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_POLICY_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_QM_POLICY_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_FILTER_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_SP_FILTER_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_SA_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_IKESTATS_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_QM_IPSECSTATS_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}  // IPSECMON_ACTIVE_POL_ITEM
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[IPSECMON_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_ROOT
    {HI, HI, HI, EN, EN, HI, HI, HI}, // IPSMSNAP_SERVER
    {HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_SA
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_SPECIFIC_FILTER
	{HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_QUICK_MODE,
	{HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_MAIN_MODE,
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_POLICY
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_POLICY
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_SP_FILTER
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_SA
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_MM_IKESTATS
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_QM_IPSECSTATS
	{HI, HI, HI, EN, HI, HI, EN, HI}, // IPSECMON_ACTIVE_POL
    {HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_QM_SA_ITEM,
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_FILTER_ITEM
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_SPECIFIC_FILTER_ITEM,
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_MM_POLICY_ITEM
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_QM_POLICY_ITEM
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_MM_FILTER_ITEM
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_MM_SP_FILTER_ITEM
	{HI, HI, HI, EN, HI, HI, HI, HI}, // IPSECMON_MM_SA_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_MM_IKESTATS_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}, // IPSECMON_QM_IPSECSTATS_ITEM
	{HI, HI, HI, HI, EN, HI, HI, HI}  // IPSECMON_ACTIVE_POL_ITEM
};

//TODO
// Help ID array for help on scope items
DWORD g_dwMMCHelp[IPSECMON_NODETYPE_MAX] =
{
    IPSMSNAP_HELP_ROOT,                // IPSMSNAP_ROOT
    IPSMSNAP_HELP_SERVER,              // IPSMSNAP_SERVER
    IPSMSNAP_HELP_PROVIDER,            // IPSECMON_QM_SA
	IPSMSNAP_HELP_ROOT,				   // IPSECMON_FILTAER
    IPSMSNAP_HELP_DEVICE,              // IPSECMON_QM_SA_ITEM
};

// icon defines
UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,        ICON_IDX_SERVER},
    {IDI_ICON02,        ICON_IDX_SERVER_BUSY},
    {IDI_ICON03,        ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON04,        ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON05,        ICON_IDX_MACHINE},
    {IDI_ICON06,        ICON_IDX_FOLDER_CLOSED},
    {IDI_ICON07,        ICON_IDX_FOLDER_OPEN},
    {IDI_IPSECMON_SNAPIN,   ICON_IDX_PRODUCT},
	{IDI_IPSM_FILTER,   ICON_IDX_FILTER},
	{IDI_IPSM_POLICY,   ICON_IDX_POLICY},
    {0, 0}
};

/*!--------------------------------------------------------------------------
    GetSystemMessage
        Use FormatMessage() to get a system error message
    Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
GetSystemMessage 
(
    UINT    nId,
    TCHAR * chBuffer,
    int     cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  dhcp server error messages.
    //

	if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? 0 : ::GetLastError() ;
}

/*!--------------------------------------------------------------------------
    LoadMessage
        Loads the error message from the correct DLL.
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT    nIdPrompt,
    TCHAR * chMsg,
    int     nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
	if (nIdPrompt == RPC_S_UNKNOWN_IF)
	{
		nIdPrompt = IDS_ERR_SPD_DOWN;
	}
	else if (nIdPrompt == RPC_S_SERVER_UNAVAILABLE
			|| nIdPrompt == RPC_S_INVALID_BINDING
			)
	{
		nIdPrompt = IDS_ERR_SPD_UNAVAILABLE;
	}
    

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MESG_MAX)
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize ) != 0 ;
    }
    else
    {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, DimensionOf(chBuff) ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}

/*!--------------------------------------------------------------------------
    IpsmMessageBox
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
IpsmMessageBox 
(
    UINT            nIdPrompt,
    UINT            nType,
    const TCHAR *   pszSuffixString,
    UINT            nHelpContext 
)
{
    TCHAR chMesg [4000] = {0};
    BOOL bOk ;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
    IpsmMessageBoxEx
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
IpsmMessageBoxEx
(
    UINT        nIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000] = {0};
    CString     strMessage;
    BOOL        bOk;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}

/*---------------------------------------------------------------------------
    Class CIpsmComponent implementation
 ---------------------------------------------------------------------------*/
CIpsmComponent::CIpsmComponent()
{
    m_pbmpToolbar = NULL;
}

CIpsmComponent::~CIpsmComponent()
{
    if (m_pbmpToolbar)
    {
        delete m_pbmpToolbar;
        m_pbmpToolbar = NULL;
    }
}

STDMETHODIMP CIpsmComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponent::QueryDataObject
        Implementation of IComponent::QueryDataObject.  We need this for
        virtual listbox support.  MMC calls us back normally with the cookie
        we handed it...  In the case of the VLB, it hands us the index of 
        the item.  So, we need to do some extra checking...
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::QueryDataObject
(
    MMC_COOKIE              cookie, 
    DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spSelectedNode;
    SPITFSResultHandler spResultHandler;
    long                lViewOptions;
    LPOLESTR            pViewType;
    CDataObject *       pDataObject;

    COM_PROTECT_TRY
    {
        // check to see what kind of result view type the selected node has
        CORg (GetSelectedNode(&spSelectedNode));
        CORg (spSelectedNode->GetResultHandler(&spResultHandler));
   
        CORg (spResultHandler->OnGetResultViewType(this, spSelectedNode->GetData(TFS_DATA_COOKIE), &pViewType, &lViewOptions));

        if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ||
             (cookie == MMC_MULTI_SELECT_COOKIE) )
        {
            if (cookie == MMC_MULTI_SELECT_COOKIE)
            {
                // this is a special case for multiple select.  We need to build a list
                // of GUIDs and the code to do this is in the handler...
                spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
            }
            else
            {
                // this node has a virtual listbox for the result pane.  Gerenate
                // a special data object using the selected node as the cookie
                Assert(m_spComponentData != NULL);
                CORg (m_spComponentData->QueryDataObject(reinterpret_cast<MMC_COOKIE>((ITFSNode *) spSelectedNode), type, ppDataObject));
            }

            pDataObject = reinterpret_cast<CDataObject *>(*ppDataObject);
            pDataObject->SetVirtualIndex((int) cookie);
        }
        else
        {
            // just forward this to the component data
            Assert(m_spComponentData != NULL);
            CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmComponent::CompareObjects
		Implementation of IComponent::CompareObjects
		MMC calls this to compare two objects
        We override this for the virtual listbox case.  With a virtual listbox,
        the cookies are the same, but the index in the internal structs 
        indicate which item the dataobject refers to.  So, we need to look
        at the indicies instead of just the cookies.
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::CompareObjects
(
	LPDATAOBJECT lpDataObjectA, 
	LPDATAOBJECT lpDataObjectB
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL spA;
    SPINTERNAL spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{
		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectB);

		if (spA != NULL && spB != NULL)
        {
			if (spA->m_cookie != spB->m_cookie)
			{
				hr = S_FALSE;
			}
			else
			{
				if (spA->HasVirtualIndex() && spB->HasVirtualIndex())
				{
					hr = (spA->GetVirtualIndex() == spB->GetVirtualIndex()) ? S_OK : S_FALSE;
				}
				else
				{
					hr = S_OK;
				}
			}
        }
	}
	COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
    CIpsmComponentData::SetControlbar
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmComponent::SetControlbar
(
    LPCONTROLBAR    pControlbar
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    if (pControlbar)
    {
    }

    // store the control bar away for future use
    m_spControlbar.Set(pControlbar);

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::ControlbarNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::ControlbarNotify
(
    MMC_NOTIFY_TYPE event, 
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnSnapinHelp
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::OnSnapinHelp
(
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

	//TODO add the help info here
    HtmlHelpA(NULL, "ipsecconcepts.chm", HH_DISPLAY_TOPIC, 0);

    return hr;
}

/*---------------------------------------------------------------------------
    Class CIpsmComponentData implementation
 ---------------------------------------------------------------------------*/
CIpsmComponentData::CIpsmComponentData()
{
    gdwIpsmSnapVersion = IPSMSNAP_VERSION;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnInitialize
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIpsmComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnDestroy
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIpsmComponentData::OnDestroy()
{
    m_spNodeMgr.Release();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnInitializeNodeMgr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnInitializeNodeMgr
(
    ITFSComponentData * pTFSCompData, 
    ITFSNodeMgr *       pNodeMgr
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // For now create a new node handler for each new node,
    // this is rather bogus as it can get expensive.  We can
    // consider creating only a single node handler for each
    // node type.
    CIpsmRootHandler *  pHandler = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode;
    HRESULT             hr = hrOK;

    try
    {
        pHandler = new CIpsmRootHandler(pTFSCompData);

        // Do this so that it will get released correctly
        spHandler = pHandler;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    // Create the root node for this sick puppy
    CORg( CreateContainerTFSNode(&spNode,
                                 &GUID_IpsmRootNodeType,
                                 pHandler,
                                 pHandler,       /* result handler */
                                 pNodeMgr) );

    // Need to initialize the data for the root node
    pHandler->InitializeNode(spNode);   

    CORg( pNodeMgr->SetRootNode(spNode) );
    m_spRootNode.Set(spNode);

	pTFSCompData->SetHTMLHelpFileName(_T("ipsecsnp.chm"));

Error:  
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnCreateComponent
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnCreateComponent
(
    LPCOMPONENT *ppComponent
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
    
    HRESULT           hr = hrOK;
    CIpsmComponent *  pComp = NULL;

    try
    {
        pComp = new CIpsmComponent;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pComp && FHrSucceeded(hr) )
    {
        pComp->Construct(m_spNodeMgr,
                        static_cast<IComponentData *>(this),
                        m_spTFSComponentData);

        *ppComponent = static_cast<IComponent *>(pComp);
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::GetCoClassID
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CIpsmComponentData::GetCoClassID()
{
    return &CLSID_IpsmSnapin;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnCreateDataObject
(
    MMC_COOKIE          cookie, 
    DATA_OBJECT_TYPES   type, 
    IDataObject **      ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

    CDataObject *   pObject = NULL;
    SPIDataObject   spDataObject;
    
    pObject = new CDataObject;
    spDataObject = pObject; // do this so that it gets released correctly
                        
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

    pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CIpsmComponentData::GetClassID
(
    CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IpsmSnapin;

    return hrOK;
}

STDMETHODIMP 
CIpsmComponentData::IsDirty()
{
    HRESULT hr = hrFalse;

    if (m_spRootNode->GetData(TFS_DATA_DIRTY))
    {
        hr = hrOK;
    }
    
    return hr;
}

STDMETHODIMP 
CIpsmComponentData::Load
(
    IStream *pStm
)
{
    HRESULT     hr = hrOK;
    DWORD       dwSavedVersion;
    CString     str;
    int         i, j;
    
    ASSERT(pStm);

    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;

    ASSERT(pStm);
    
    CIpsmRootHandler * pRootHandler = GETHANDLER(CIpsmRootHandler, m_spRootNode);

    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    DWORD dwFileVersion;
    CORg(xferStream.XferDWORD(IPSMSTRM_TAG_VERSION, &dwFileVersion));
    if (dwFileVersion < IPSMSNAP_FILE_VERSION)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxMessageBox(IDS_ERR_OLD_CONSOLE_FILE);
        return hr;
    }

    // Read the version # of the admin tool
    CORg(xferStream.XferDWORD(IPSMSTRM_TAG_VERSIONADMIN, &dwSavedVersion));
    if (dwSavedVersion < gdwIpsmSnapVersion)
    {
        // File is an older version.  Warn the user and then don't
        // load anything else
        Assert(FALSE);
    }

    // now read all of the server information
    CORg(xferStream.XferCStringArray(IPSMSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));
    CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_OPTIONS, &dwArrayOptions));

    // now load the column information
    for (i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

        for (j = 0; j < MAX_COLUMNS; j++)
        {
            aColumnWidths[i][j] = dwArrayColumnInfo[j];
        }

    }

    // now create the servers based on the information
    for (i = 0; i < strArrayName.GetSize(); i++)
    {
        //
        // now create the server object
        //
        pRootHandler->AddServer(NULL, 
                                strArrayName[i],
                                FALSE, 
                                dwArrayOptions[i], 
                                dwArrayRefreshInterval[i],
                                FALSE,
                                0,
                                0);
    }

Error:
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CIpsmComponentData::Save
(
    IStream *pStm, 
    BOOL     fClearDirty
)
{
    HRESULT hr = hrOK;
    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    
    CString str;

    // Write the version # of the file format
    DWORD dwFileVersion = IPSMSNAP_FILE_VERSION;
    xferStream.XferDWORD(IPSMSTRM_TAG_VERSION, &dwFileVersion);
    
    // Write the version # of the admin tool
    xferStream.XferDWORD(IPSMSTRM_TAG_VERSIONADMIN, &gdwIpsmSnapVersion);

    //
    // Build our array of servers
    //
    int nNumServers = 0, nVisibleCount = 0;
    hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

    strArrayName.SetSize(nNumServers);
    dwArrayRefreshInterval.SetSize(nNumServers);
    dwArrayOptions.SetSize(nNumServers);
    dwArrayColumnInfo.SetSize(MAX_COLUMNS);
    

    //
    // loop and save off all the server's attributes
    //
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
    int nCount = 0;

    m_spRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        CIpsmServer * pServer = GETHANDLER(CIpsmServer, spCurrentNode);

        // query the server for it's options:
        // auto refresh
        dwArrayRefreshInterval[nCount] = pServer->GetAutoRefreshInterval();
        dwArrayOptions[nCount] = pServer->GetOptions();

        // put the information in our array
        strArrayName[nCount] = pServer->GetName();

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
    }

    // now write out all of the server information
    xferStream.XferCStringArray(IPSMSTRM_TAG_SERVER_NAME, &strArrayName);
    xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval);
    xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_OPTIONS, &dwArrayOptions);

    // now save the column information
    for (int i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        for (int j = 0; j < MAX_COLUMNS; j++)
        {
            dwArrayColumnInfo[j] = aColumnWidths[i][j];
        }

        xferStream.XferDWORDArray(IPSMSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo);
    }


    if (fClearDirty)
    {
        m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
    }

    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CIpsmComponentData::GetSizeMax
(
    ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10000);

    return S_OK;
}

STDMETHODIMP 
CIpsmComponentData::InitNew()
{
    return hrOK;
}

HRESULT 
CIpsmComponentData::FinalConstruct()
{
    HRESULT             hr = hrOK;
    
    hr = CComponentData::FinalConstruct();
    
    if (FHrSucceeded(hr))
    {
        m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
    }
    return hr;
}

void 
CIpsmComponentData::FinalRelease()
{
    CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\harray.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2002   **/
/**********************************************************************/

/*
	hArray.cpp	
		Index manager for IPSecMon

	FILE HISTORY:
    Nov 29  1999    Ning Sun     Created

*/

#include "stdafx.h"
#include "spddb.h"
#include "harray.h"
#include "mbstring.h"
#include "spdutil.h"

extern const DWORD INDEX_TYPE_DEFAULT = 0;

int __cdecl CompareFilterName(const void *elem1, const void *elem2);
int __cdecl CompareFilterSourceAddr(const void *elem1, const void *elem2);
int __cdecl CompareFilterDestAddr(const void *elem1, const void *elem2);
int __cdecl CompareFilterSrcPort(const void *elem1, const void *elem2);
int __cdecl CompareFilterDestPort(const void *elem1, const void *elem2);
int __cdecl CompareFilterProtocol(const void *elem1, const void *elem2);
int __cdecl CompareFilterDirection(const void *elem1, const void *elem2);
int __cdecl CompareFilterWeight(const void *elem1, const void *elem2);
int __cdecl CompareFilterPolicyName(const void *elem1, const void *elem2);
int __cdecl CompareFilterIfType(const void *elem1, const void *elem2);
int __cdecl CompareFilterInboundFlag(const void *elem1, const void *elem2);
int __cdecl CompareFilterOutboundFlag(const void *elem1, const void *elem2);
int __cdecl CompareFilterFlag(const void *elem1, const void *elem2);

int __cdecl CompareMmFilterName(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterSourceAddr(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterDestAddr(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterDirection(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterWeight(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterPolicyName(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterAuth(const void *elem1, const void *elem2);
int __cdecl CompareMmFilterIfType(const void *elem1, const void *elem2);
int __cdecl CompareMmPolicyName(const void *elem1, const void *elem2);
int __cdecl CompareMmPolicyOfferNumber(const void *elem1, const void *elem2);
int __cdecl CompareQmPolicyName(const void *elem1, const void *elem2);
int __cdecl CompareQmPolicyOfferNumber(const void *elem1, const void *elem2);

int __cdecl CompareMmSAMeAddr(const void *elem1, const void *elem2);
int __cdecl CompareMmSAPeerAddr(const void *elem1, const void *elem2);
int __cdecl CompareMmSAAuth(const void *elem1, const void *elem2);
int __cdecl CompareMmSAEncryption(const void *elem1, const void *elem2);
int __cdecl CompareMmSAIntegrity(const void *elem1, const void *elem2);
int __cdecl CompareMmSADhGroup(const void *elem1, const void *elem2);

int __cdecl CompareQmSAPolicyName(const void *elem1, const void *elem2);
int __cdecl CompareQmSAAuth(const void *elem1, const void *elem2);
int __cdecl CompareQmSAConf(const void *elem1, const void *elem2);
int __cdecl CompareQmSAIntegrity(const void *elem1, const void *elem2);
int __cdecl CompareQmSASrc(const void *elem1, const void *elem2);
int __cdecl CompareQmSADest(const void *elem1, const void *elem2);
int __cdecl CompareQmSAProtocol(const void *elem1, const void *elem2);
int __cdecl CompareQmSASrcPort(const void *elem1, const void *elem2);
int __cdecl CompareQmSADestPort(const void *elem1, const void *elem2);
int __cdecl CompareQmSAMyTnlEp(const void *elem1, const void *elem2);
int __cdecl CompareQmSAPeerTnlEp(const void *elem1, const void *elem2);
int __cdecl CompareFilterSrcTnl(const void *elem1, const void *elem2);
int __cdecl CompareFilterDestTnl(const void *elem1, const void *elem2);

typedef int (__cdecl *PFNCompareProc)(const void *, const void *);

//This structure saves the pair of sort type and sort function
struct SortTypeAndCompareProcPair
{
	DWORD			dwType;
	PFNCompareProc	pCompareProc;
};

SortTypeAndCompareProcPair TypeProcMmFilter[] = 
{
	{IDS_COL_FLTR_NAME, CompareMmFilterName},
	{IDS_COL_FLTR_SRC, CompareMmFilterSourceAddr},
	{IDS_COL_FLTR_DEST, CompareMmFilterDestAddr},
	{IDS_COL_FLTR_DIR, CompareMmFilterDirection},
	{IDS_COL_MM_FLTR_POL, CompareMmFilterPolicyName},
	{IDS_COL_MM_FLTR_AUTH, CompareMmFilterAuth},
	{IDS_COL_IF_TYPE, CompareMmFilterIfType},
	{IDS_COL_FLTR_WEIGHT, CompareMmFilterWeight},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

SortTypeAndCompareProcPair TypeProcMmPolicy[] = 
{
	{IDS_COL_MM_POL_NAME, CompareMmPolicyName},
	{IDS_COL_MM_POL_OFFER, CompareMmPolicyOfferNumber},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

//SortTypeAndCompareProcPair
SortTypeAndCompareProcPair TypeProcMmSA[] =
{
	{IDS_COL_MM_SA_ME, CompareMmSAMeAddr},
	{IDS_COL_MM_SA_PEER, CompareMmSAPeerAddr},	
	{IDS_COL_MM_SA_AUTH, CompareMmSAAuth},	
	{IDS_COL_MM_SA_ENCRYPITON, CompareMmSAEncryption},
	{IDS_COL_MM_SA_INTEGRITY, CompareMmSAIntegrity},
	{IDS_COL_MM_SA_DH, CompareMmSADhGroup},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

SortTypeAndCompareProcPair TypeProcQmFilter[] = 
{
	{IDS_COL_FLTR_NAME, CompareFilterName},
	{IDS_COL_FLTR_SRC, CompareFilterSourceAddr},
	{IDS_COL_FLTR_SRC_PORT, CompareFilterSrcPort},
	{IDS_COL_FLTR_DEST, CompareFilterDestAddr},
	{IDS_COL_FLTR_DEST_PORT, CompareFilterDestPort},
	{IDS_COL_FLTR_SRC_TNL, CompareFilterSrcTnl},
	{IDS_COL_FLTR_DEST_TNL, CompareFilterDestTnl},
	{IDS_COL_FLTR_PROT, CompareFilterProtocol},
	{IDS_COL_FLTR_DIR, CompareFilterDirection},
	{IDS_COL_QM_POLICY, CompareFilterPolicyName},
	{IDS_COL_IF_TYPE, CompareFilterIfType},
	{IDS_COL_FLTR_WEIGHT, CompareFilterWeight},
	{IDS_COL_FLTR_OUT_FLAG, CompareFilterOutboundFlag},
	{IDS_COL_FLTR_IN_FLAG, CompareFilterInboundFlag},
	{IDS_COL_FLTR_FLAG, CompareFilterFlag},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

SortTypeAndCompareProcPair TypeProcQmPolicy[] =
{
	{IDS_COL_QM_POL_NAME, CompareQmPolicyName},
	{IDS_COL_QM_POL_OFFER, CompareQmPolicyOfferNumber},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

SortTypeAndCompareProcPair TypeProcQmSA[] =
{
	{IDS_COL_QM_SA_POL, CompareQmSAPolicyName},
	{IDS_COL_QM_SA_AUTH, CompareQmSAAuth},
	{IDS_COL_QM_SA_CONF, CompareQmSAConf},
	{IDS_COL_QM_SA_INTEGRITY, CompareQmSAIntegrity},
	{IDS_COL_QM_SA_SRC, CompareQmSASrc},
	{IDS_COL_QM_SA_DEST, CompareQmSADest},
	{IDS_COL_QM_SA_PROT, CompareQmSAProtocol},
	{IDS_COL_QM_SA_SRC_PORT, CompareQmSASrcPort},
	{IDS_COL_QM_SA_DES_PORT, CompareQmSADestPort},
	{IDS_COL_QM_SA_MY_TNL, CompareQmSAMyTnlEp},
	{IDS_COL_QM_SA_PEER_TNL, CompareQmSAPeerTnlEp},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};


CColumnIndex::CColumnIndex(DWORD dwIndexType, PCOMPARE_FUNCTION pfnCompare)
 :	CIndexArray(),
	m_dwIndexType(dwIndexType),
	m_pfnCompare(pfnCompare),
	m_dwSortOption(SORT_ASCENDING)
{
}


HRESULT CColumnIndex::Sort()
{
	if (NULL != m_pfnCompare)
	{
		qsort(GetData(), (size_t)GetSize(), sizeof(void *), m_pfnCompare);
	}

	return S_OK;
}

void* CColumnIndex::GetIndexedItem(int nIndex)
{
	return ((m_dwSortOption & SORT_ASCENDING)) ? GetAt(GetSize() - nIndex -1) : GetAt(nIndex);
}


CIndexManager::CIndexManager()
 :	m_DefaultIndex(INDEX_TYPE_DEFAULT, NULL), //NULL means do nothing during sort
    m_posCurrentIndex(NULL)
{
}

CIndexManager::~CIndexManager()
{
	Reset();
}


void
CIndexManager::Reset()
{
	while (m_listIndicies.GetCount() > 0)
	{
		delete m_listIndicies.RemoveHead();
	}

	m_posCurrentIndex = NULL;

	m_DefaultIndex.RemoveAll();
}

int
CIndexManager::AddItem(void *pItem)
{
	return (int)m_DefaultIndex.Add(pItem);
}


void * CIndexManager::GetItemData(int nIndex)
{
	CColumnIndex * pIndex = NULL;

	if (NULL == m_posCurrentIndex)
	{
		//use the default index
		pIndex = &m_DefaultIndex;
	}
	else
	{
		pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
	}

	Assert(pIndex);

	if (nIndex < pIndex->GetSize() && nIndex >= 0)
	{
		return pIndex->GetIndexedItem(nIndex);
	}
	else
	{
		Panic0("We dont have that index!");
		return NULL;
	}

}

DWORD CIndexManager::GetCurrentIndexType()
{
	DWORD dwIndexType;
	
	if (m_posCurrentIndex)
	{
		CColumnIndex * pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
		dwIndexType = pIndex->GetType();
	}
	else
	{
		dwIndexType = m_DefaultIndex.GetType();
	}

	return dwIndexType;
}

DWORD CIndexManager::GetCurrentSortOption()
{
	DWORD dwSortOption;
	
	if (m_posCurrentIndex)
	{
		CColumnIndex * pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
		dwSortOption = pIndex->GetSortOption();
	}
	else
	{
		dwSortOption = m_DefaultIndex.GetSortOption();
	}

	return dwSortOption;
}


HRESULT
CIndexMgrFilter::SortFilters(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{
	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcQmFilter); i++)
	{
		if (TypeProcQmFilter[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcQmFilter[i].pCompareProc);
			break;
		}
	}

    Assert(pNewIndex);
	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}


HRESULT
CIndexMgrMmFilter::SortMmFilters(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{
	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcMmFilter); i++)
	{
		if (TypeProcMmFilter[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcMmFilter[i].pCompareProc);
			break;
		}
	}

    Assert(pNewIndex);

	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}


HRESULT
CIndexMgrMmPolicy::Sort(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{
	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcMmPolicy); i++)
	{
		if (TypeProcMmPolicy[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcMmPolicy[i].pCompareProc);
			break;
		}
	}

    Assert(pNewIndex);

	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}


HRESULT
CIndexMgrQmPolicy::Sort(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{
	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcQmPolicy); i++)
	{
		if (TypeProcQmPolicy[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcQmPolicy[i].pCompareProc);
			break;
		}
	}


    Assert(pNewIndex);

	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}

HRESULT
CIndexMgrMmSA::Sort(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{
	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcMmSA); i++)
	{
		if (TypeProcMmSA[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcMmSA[i].pCompareProc);
			break;
		}
	}

    Assert(pNewIndex);

	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}


HRESULT
CIndexMgrQmSA::Sort(
	DWORD dwSortType, 
	DWORD dwSortOptions
	)
{

	HRESULT hr = hrOK;

	POSITION posLast;
	POSITION pos;
	DWORD    dwIndexType;
	
	pos = m_listIndicies.GetHeadPosition();
	while (pos)
	{
		posLast = pos;
		CColumnIndex * pIndex = m_listIndicies.GetNext(pos);

		dwIndexType = pIndex->GetType();

        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
		{
			pIndex->SetSortOption(dwSortOptions);

			m_posCurrentIndex = posLast;
		
			return hrOK;
		}
    }

    // if not, create one
	CColumnIndex * pNewIndex = NULL;
	for (int i = 0; i < DimensionOf(TypeProcQmSA); i++)
	{
		if (TypeProcQmSA[i].dwType == dwSortType)
		{
			pNewIndex = new CColumnIndex(dwSortType, TypeProcQmSA[i].pCompareProc);
			break;
		}
	}

    Assert(pNewIndex);

	if (NULL == pNewIndex)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	

    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

	m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);


    return hr;
}


int __cdecl CompareFilterName(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	return pFilter1->m_stName.CompareNoCase(pFilter2->m_stName);
}

int __cdecl CompareFilterSourceAddr(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	CString str1;
	CString str2;

	AddressToString(pFilter1->m_SrcAddr, &str1);
	AddressToString(pFilter2->m_SrcAddr, &str2);
	return str1.CompareNoCase(str2);
}

int __cdecl CompareFilterDestAddr(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	CString str1;
	CString str2;

	AddressToString(pFilter1->m_DesAddr, &str1);
	AddressToString(pFilter2->m_DesAddr, &str2);
	return str1.CompareNoCase(str2);
}

int __cdecl CompareFilterSrcPort(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	return (int)pFilter1->m_SrcPort.wPort - (int)pFilter2->m_SrcPort.wPort;
}

int __cdecl CompareFilterDestPort(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	return (int)pFilter1->m_DesPort.wPort - (int)pFilter2->m_DesPort.wPort;
}

int __cdecl CompareFilterSrcTnl(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	CString str1;
	CString str2;

	TnlEpToString(pFilter1->m_FilterType, pFilter1->m_MyTnlAddr, &str1);
	TnlEpToString(pFilter2->m_FilterType, pFilter2->m_MyTnlAddr, &str2);

	return str1.CompareNoCase(str2);
}

int __cdecl CompareFilterDestTnl(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	CString str1;
	CString str2;

	TnlEpToString(pFilter1->m_FilterType, pFilter1->m_PeerTnlAddr, &str1);
	TnlEpToString(pFilter2->m_FilterType, pFilter2->m_PeerTnlAddr, &str2);

	return str1.CompareNoCase(str2);
}

int __cdecl CompareFilterProtocol(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	CString st1;
	CString st2;

	ProtocolToString(pFilter1->m_Protocol, &st1);
	ProtocolToString(pFilter2->m_Protocol, &st2);
	
	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterDirection(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	CString st1;
	CString st2;
	DirectionToString(pFilter1->m_dwDirection, &st1);
	DirectionToString(pFilter2->m_dwDirection, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterPolicyName(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	return pFilter1->m_stPolicyName.CompareNoCase(pFilter2->m_stPolicyName);
}

int __cdecl CompareFilterIfType(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	CString st1;
	CString st2;

	InterfaceTypeToString(pFilter1->m_InterfaceType, &st1);
	InterfaceTypeToString(pFilter2->m_InterfaceType, &st2);
	
	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterOutboundFlag(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	CString st1;
	CString st2;

	FilterFlagToString(pFilter1->m_OutboundFilterAction, &st1);
	FilterFlagToString(pFilter2->m_OutboundFilterAction, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterInboundFlag(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	CString st1;
	CString st2;

	FilterFlagToString(pFilter1->m_InboundFilterAction, &st1);
	FilterFlagToString(pFilter2->m_InboundFilterAction, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterFlag(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);
	
	CString st1;
	CString st2;

	FilterFlagToString(
					(FILTER_DIRECTION_INBOUND == pFilter1->m_dwDirection) ?
						pFilter1->m_InboundFilterAction : pFilter1->m_OutboundFilterAction,
					&st1
					);

	FilterFlagToString(
					(FILTER_DIRECTION_INBOUND == pFilter2->m_dwDirection) ?
						pFilter2->m_InboundFilterAction : pFilter2->m_OutboundFilterAction,
					&st2
					);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareFilterWeight(const void *elem1, const void *elem2)
{
	CFilterInfo *pFilter1;
	CFilterInfo *pFilter2;
	pFilter1 = *((CFilterInfo**)elem1);
	pFilter2 = *((CFilterInfo**)elem2);

	return (int)pFilter1->m_dwWeight - (int)pFilter2->m_dwWeight;
}

int __cdecl CompareMmFilterName(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	return pFilter1->m_stName.CompareNoCase(pFilter2->m_stName);
}

int __cdecl CompareMmFilterSourceAddr(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	CString str1;
	CString str2;

	AddressToString(pFilter1->m_SrcAddr, &str1);
	AddressToString(pFilter2->m_SrcAddr, &str2);
	return str1.CompareNoCase(str2);
}

int __cdecl CompareMmFilterDestAddr(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	CString str1;
	CString str2;

	AddressToString(pFilter1->m_DesAddr, &str1);
	AddressToString(pFilter2->m_DesAddr, &str2);
	return str1.CompareNoCase(str2);
}

int __cdecl CompareMmFilterDirection(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	CString st1;
	CString st2;

	DirectionToString(pFilter1->m_dwDirection, &st1);
	DirectionToString(pFilter2->m_dwDirection, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmFilterWeight(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	return (int)pFilter1->m_dwWeight - (int)pFilter2->m_dwWeight;
}

int __cdecl CompareMmFilterPolicyName(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	return pFilter1->m_stPolicyName.CompareNoCase(pFilter2->m_stPolicyName);
}

int __cdecl CompareMmFilterAuth(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);

	return pFilter1->m_stAuthDescription.CompareNoCase(pFilter2->m_stAuthDescription);
}

int __cdecl CompareMmFilterIfType(const void *elem1, const void *elem2)
{
	CMmFilterInfo *pFilter1;
	CMmFilterInfo *pFilter2;
	pFilter1 = *((CMmFilterInfo**)elem1);
	pFilter2 = *((CMmFilterInfo**)elem2);
	CString str1;
	CString str2;

	InterfaceTypeToString(pFilter1->m_InterfaceType, &str1);
	InterfaceTypeToString(pFilter2->m_InterfaceType, &str2);

	return str1.CompareNoCase(str2);
}

int __cdecl CompareMmPolicyName(const void *elem1, const void *elem2)
{
	CMmPolicyInfo * pPolicy1;
	CMmPolicyInfo * pPolicy2;

	pPolicy1 = *((CMmPolicyInfo**)elem1);
	pPolicy2 = *((CMmPolicyInfo**)elem2);

	return pPolicy1->m_stName.CompareNoCase(pPolicy2->m_stName);
}

int __cdecl CompareMmPolicyOfferNumber(const void *elem1, const void *elem2)
{
	CMmPolicyInfo * pPolicy1;
	CMmPolicyInfo * pPolicy2;

	pPolicy1 = *((CMmPolicyInfo**)elem1);
	pPolicy2 = *((CMmPolicyInfo**)elem2);

	return pPolicy1->m_dwOfferCount - pPolicy2->m_dwOfferCount;
}

int __cdecl CompareQmPolicyName(const void *elem1, const void *elem2)
{
	CQmPolicyInfo * pPolicy1;
	CQmPolicyInfo * pPolicy2;

	pPolicy1 = *((CQmPolicyInfo**)elem1);
	pPolicy2 = *((CQmPolicyInfo**)elem2);

	return pPolicy1->m_stName.CompareNoCase(pPolicy2->m_stName);
}

int __cdecl CompareQmPolicyOfferNumber(const void *elem1, const void *elem2)
{
	CQmPolicyInfo * pPolicy1;
	CQmPolicyInfo * pPolicy2;

	pPolicy1 = *((CQmPolicyInfo**)elem1);
	pPolicy2 = *((CQmPolicyInfo**)elem2);

	return (int)(pPolicy1->m_arrOffers.GetSize() - pPolicy2->m_arrOffers.GetSize());
}

int __cdecl CompareMmSAMeAddr(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	AddressToString(pSA1->m_MeAddr, &st1);
	AddressToString(pSA2->m_MeAddr, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmSAPeerAddr(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	AddressToString(pSA1->m_PeerAddr, &st1);
	AddressToString(pSA2->m_PeerAddr, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmSAAuth(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	MmAuthToString(pSA1->m_Auth, &st1);
	MmAuthToString(pSA2->m_Auth, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmSAEncryption(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	DoiEspAlgorithmToString(pSA1->m_SelectedOffer.m_EncryptionAlgorithm, &st1);
	DoiEspAlgorithmToString(pSA2->m_SelectedOffer.m_EncryptionAlgorithm, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmSAIntegrity(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	DoiAuthAlgorithmToString(pSA1->m_SelectedOffer.m_HashingAlgorithm, &st1);
	DoiAuthAlgorithmToString(pSA2->m_SelectedOffer.m_HashingAlgorithm, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareMmSADhGroup(const void *elem1, const void *elem2)
{
	CMmSA * pSA1;
	CMmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CMmSA**)elem1);
	pSA2 = *((CMmSA**)elem2);

	DhGroupToString(pSA1->m_SelectedOffer.m_dwDHGroup, &st1);
	DhGroupToString(pSA2->m_SelectedOffer.m_dwDHGroup, &st2);

	return st1.CompareNoCase(st2);
}


int __cdecl CompareQmSAPolicyName(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	return pSA1->m_stPolicyName.CompareNoCase(pSA2->m_stPolicyName);
}

int __cdecl CompareQmSAAuth(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	QmAlgorithmToString(QM_ALGO_AUTH, &pSA1->m_SelectedOffer, &st1);
	QmAlgorithmToString(QM_ALGO_AUTH, &pSA2->m_SelectedOffer, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSAConf(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	QmAlgorithmToString(QM_ALGO_ESP_CONF, &pSA1->m_SelectedOffer, &st1);
	QmAlgorithmToString(QM_ALGO_ESP_CONF, &pSA2->m_SelectedOffer, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSAIntegrity(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	QmAlgorithmToString(QM_ALGO_ESP_INTEG, &pSA1->m_SelectedOffer, &st1);
	QmAlgorithmToString(QM_ALGO_ESP_INTEG, &pSA2->m_SelectedOffer, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSASrc(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	AddressToString(pSA1->m_QmDriverFilter.m_SrcAddr, &st1);
	AddressToString(pSA2->m_QmDriverFilter.m_SrcAddr, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSADest(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	AddressToString(pSA1->m_QmDriverFilter.m_DesAddr, &st1);
	AddressToString(pSA2->m_QmDriverFilter.m_DesAddr, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSAProtocol(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	ProtocolToString(pSA1->m_QmDriverFilter.m_Protocol, &st1);
	ProtocolToString(pSA2->m_QmDriverFilter.m_Protocol, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSASrcPort(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	PortToString(pSA1->m_QmDriverFilter.m_SrcPort, &st1);
	PortToString(pSA2->m_QmDriverFilter.m_SrcPort, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSADestPort(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	PortToString(pSA1->m_QmDriverFilter.m_DesPort, &st1);
	PortToString(pSA2->m_QmDriverFilter.m_DesPort, &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSAMyTnlEp(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	TnlEpToString(pSA1->m_QmDriverFilter.m_Type, 
				   pSA1->m_QmDriverFilter.m_MyTunnelEndpt, 
				   &st1);
	TnlEpToString(pSA2->m_QmDriverFilter.m_Type, 
				   pSA2->m_QmDriverFilter.m_MyTunnelEndpt, 
				   &st2);

	return st1.CompareNoCase(st2);
}

int __cdecl CompareQmSAPeerTnlEp(const void *elem1, const void *elem2)
{
	CQmSA * pSA1;
	CQmSA * pSA2;

	CString st1;
	CString st2;

	pSA1 = *((CQmSA**)elem1);
	pSA2 = *((CQmSA**)elem2);

	TnlEpToString(pSA1->m_QmDriverFilter.m_Type, 
				   pSA1->m_QmDriverFilter.m_PeerTunnelEndpt, 
				   &st1);
	TnlEpToString(pSA2->m_QmDriverFilter.m_Type, 
				   pSA2->m_QmDriverFilter.m_PeerTunnelEndpt, 
				   &st2);
	return st1.CompareNoCase(st2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    ipsmcomp.h
        This file contains the derived prototypes from CComponent
        and CComponentData for the IPSECMON snapin.

    FILE HISTORY:
        
*/

#ifndef _IPSMCOMP_H
#define _IPSMCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#define COLORREF_PINK   0x00FF00FF

//  Use FormatMessage() to get a system error message
LONG GetSystemMessage ( UINT nId, TCHAR * chBuffer, int cbBuffSize ) ;

BOOL LoadMessage (UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);

//  Surrogate AfxMessageBox replacement for error message filtering.
int IpsmMessageBox(UINT nIdPrompt, 
                   UINT nType = MB_OK, 
                   const TCHAR * pszSuffixString = NULL,
                   UINT nHelpContext = -1);

int IpsmMessageBoxEx(UINT    nIdPrompt, 
                     LPCTSTR pszPrefixMessage,
                     UINT    nType = MB_OK, 
                     UINT    nHelpContext = -1);

enum IPSMSTRM_TAG
{
    IPSMSTRM_TAG_VERSION =                  XFER_TAG(1, XFER_DWORD),
    IPSMSTRM_TAG_VERSIONADMIN =             XFER_TAG(2, XFER_DWORD),
    IPSMSTRM_TAG_SERVER_NAME =              XFER_TAG(3, XFER_STRING_ARRAY),
    IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL =  XFER_TAG(4, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_COLUMN_INFO =              XFER_TAG(5, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_OPTIONS =           XFER_TAG(6, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_LINE_SIZE =         XFER_TAG(7, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_PHONE_SIZE =        XFER_TAG(8, XFER_DWORD_ARRAY)
};

/////////////////////////////////////////////////////////////////////////////
// CIpsmComponentData

class CIpsmComponentData :
    public CComponentData,
    public CComObjectRoot
{
public:
    
BEGIN_COM_MAP(CIpsmComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
            
    // These are the interfaces that we MUST implement

    // We will implement our common behavior here, with the derived
    // classes implementing the specific behavior.
    DeclareIPersistStreamInitMembers(IMPL)
    DeclareITFSCompDataCallbackMembers(IMPL)

    CIpsmComponentData();

    HRESULT FinalConstruct();
    void FinalRelease();
    
protected:
    SPITFSNodeMgr   m_spNodeMgr;
    SPITFSNode      m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CIpsmComponent
class CIpsmComponent : 
    public TFSComponent
{
public:
    CIpsmComponent();
    ~CIpsmComponent();

    STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param); 
    STDMETHOD(QueryDataObject)(MMC_COOKIE           cookie, 
                               DATA_OBJECT_TYPES    type,
                               LPDATAOBJECT*        ppDataObject);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
    SPIToolbar          m_spToolbar;    // Toolbar
    CBitmap*            m_pbmpToolbar;  // Imagelist for toolbar
};

/*---------------------------------------------------------------------------
    This is how the DHCP snapin implements its extension functionality.
    It actually exposes two interfaces that are CoCreate-able.  One is the 
    primary interface, the other the extension interface.
    
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CIpsmComponentDataPrimary : public CIpsmComponentData,
    public CComCoClass<CIpsmComponentDataPrimary, &CLSID_IpsmSnapin>
{
public:
    DECLARE_REGISTRY(CIpsmComponentDataPrimary, 
                     _T("TelephonySnapin.TelephonySnapin.1"), 
                     _T("TelephonySnapin.TelephonySnapin"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_IpsmSnapin; }
};


class CIpsmComponentDataExtension : public CIpsmComponentData,
    public CComCoClass<CIpsmComponentDataExtension, &CLSID_IpsmSnapinExtension>
{
public:
    DECLARE_REGISTRY(CIpsmComponentDataExtension, 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension.1"), 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_IpsmSnapinExtension; }
};


/*---------------------------------------------------------------------------
    This is the derived class for handling the IAbout interface from MMC
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CIpsmAbout : 
    public CAbout,
    public CComCoClass<CIpsmAbout, &CLSID_IpsmSnapinAbout>
{
public:
DECLARE_REGISTRY(CIpsmAbout, _T("IpsecMonSnapin.About.1"), 
                             _T("IpsecMonSnapin.About"), 
                             IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CIpsmAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
    COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CIpsmAbout)

// these must be overridden to provide values to the base class
protected:
    virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
    virtual UINT GetAboutProviderId()    { return IDS_ABOUT_PROVIDER; }
    virtual UINT GetAboutVersionId()     { return IDS_ABOUT_VERSION; }
    virtual UINT GetAboutIconId()        { return IDI_IPSECMON_SNAPIN; }

    virtual UINT GetSmallRootId()        { return IDB_ROOT_SMALL; }
    virtual UINT GetSmallOpenRootId()    { return IDB_ROOT_SMALL; }
    virtual UINT GetLargeRootId()        { return IDB_ROOT_LARGE; }
    virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};
    

#endif _IPSMCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmhand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	IPSMhand.h
		Header file for IPSecMon specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _IPSMHAND_H
#define _IPSMHAND_H

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

extern const TCHAR g_szDefaultHelpTopic[];

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
    virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CIpsmHandler
 ---------------------------------------------------------------------------*/
class CIpsmHandler : 
        public CHandler,
		public CHandlerEx
{
public:
	CIpsmHandler(ITFSComponentData *pCompData) : 
		CHandler(pCompData),
		m_verbDefault(MMC_VERB_OPEN) {};
	~CIpsmHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
	
	MMC_CONSOLE_VERB	m_verbDefault;

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);

public:
};

/*---------------------------------------------------------------------------
	Class:	CMTIpsmHandler
 ---------------------------------------------------------------------------*/
class CMTIpsmHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTIpsmHandler(ITFSComponentData *pCompData) : 
		CMTHandler(pCompData),
		m_verbDefault(MMC_VERB_OPEN) 
		{ m_nState = notLoaded; m_bSelected = FALSE; }
	~CMTIpsmHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

protected:
	virtual void OnChangeState(ITFSNode* pNode);
    virtual void GetErrorPrefix(ITFSNode * pNode, CString * pstrPrefix) { };
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CIpsmMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);
    void    ExpandNode(ITFSNode * pNode, BOOL fExpand);

	MMC_CONSOLE_VERB	m_verbDefault;
protected:
    BOOL        m_bSelected;
};

/*---------------------------------------------------------------------------
	Class:	CIpsmQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CIpsmQueryObj : public CNodeQueryObject
{
public:
	CIpsmQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) : m_dwErr(0)
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
	DWORD				 m_dwErr;
};

#endif _IPSMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmhand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	ipsmhand.cpp
		IPSecMon specifc handler base classes

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipsmhand.h"
#include "snaputil.h"  // For CGUIDArray
#include "extract.h"   // For ExtractInternalFormat

//TODO the help file
const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\ipsecconcepts.chm::/sag_IPSECtopnode.htm");

/*---------------------------------------------------------------------------
	CMTIpsmHandler::OnChangeState
		Description
	Author: NSun
 ---------------------------------------------------------------------------*/
void CMTIpsmHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position
	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                if (m_dwErr)
                {
                    CString strPrefix;
                    GetErrorPrefix(pNode, &strPrefix);
                    if (!strPrefix.IsEmpty())
                        ::IpsmMessageBoxEx(m_dwErr, strPrefix);
                }
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));
    }

    // Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::UpdateStandardVerbs
(
    ITFSNode *  pNode,
    LONG_PTR    dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     reinterpret_cast<MMC_COOKIE>(pNode), 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnCreateDataObject
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTIpsmHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CMTIpsmHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pConstGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pConstGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pConstGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::SaveColumns
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMTIpsmHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMTIpsmHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    SPINTERNAL		spInternal;
    BOOL            bMultiSelect = FALSE;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    m_bSelected = bSelect;

   	Trace1("CMTIpsmHandler::OnResultSelect select = %d\n", bSelect);
 
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMTIpsmHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT   pDataObject, 
    LPARAM         data, 
    LPARAM         hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        spNode.Set(reinterpret_cast<ITFSNode *>(data));

        UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE));
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMTIpsmHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::UpdateStandardVerbs
		Updates the standard verbs depending upon the state of the node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::EnableVerbs
		Enables the verb buttons
	Author: NSun
 ---------------------------------------------------------------------------*/
void 
CMTIpsmHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMTIpsmHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::ExpandNode
		Expands/compresses this node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    m_spNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 

Error:
    return;
}


/*---------------------------------------------------------------------------
	Class:	CIpsmHandler
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIpsmHandler::SaveColumns
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth = 0;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }
         
        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnCreateDataObject
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE      	cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CIpsmHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pConstGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pConstGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pConstGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

 /*---------------------------------------------------------------------------
	CIpsmHandler::OnResultDelete
		Description
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE  	cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CIpsmHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM	    	arg, 
	LPARAM		    lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

   	Trace1("CIpsmHandler::OnResultSelect select = %d\n", bSelect);
    //m_bSelected = bSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CMTIpsmHandler::EnableVerbs
		Enables the verb buttons
	Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    ipsmsnap.cpp
        IPSecMon snapin entry points/registration functions
        
        Note: Proxy/Stub Information
            To build a separate proxy/stub DLL, 
            run nmake -f Snapinps.mak in the project directory.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "initguid.h"
#include "ncglobal.h"  // network console global defines
#include "cmptrmgr.h"   // computer menagement snapin stuff
#include "winipsec.h"
#include "spdutil.h"

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

const TCHAR c_szHelpFile[] = _T("ipsecsnp.hlp");

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IpsmSnapin, CIpsmComponentDataPrimary)
    OBJECT_ENTRY(CLSID_IpsmSnapinExtension, CIpsmComponentDataExtension)
    OBJECT_ENTRY(CLSID_IpsmSnapinAbout, CIpsmAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CIpsmSnapinApp
//
BEGIN_MESSAGE_MAP(CIpsmSnapinApp, CWinApp)
    //{{AFX_MSG_MAP(CIpsmSnapinApp)
    //ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    //ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    //ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    //ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpFinder)
    ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()

CIpsmSnapinApp theApp;

BOOL CIpsmSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);

	SHFusionInitializeFromModuleID (m_hInstance, 2);

    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;
    
    //
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
        Trace0("InitInstance: Winsock initialized!\n");
    }
    else
    {
        m_bWinsockInited = FALSE;
    }

    if (m_pszHelpFilePath)
        free((void*)m_pszHelpFilePath);

    m_pszHelpFilePath=_tcsdup(c_szHelpFile);
    
    return CWinApp::InitInstance();
}

int CIpsmSnapinApp::ExitInstance()
{
	SHFusionUninitialize();

    _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNTS;

    //
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR   szModuleFileName[MAX_PATH * 2 + 1] = {0};
    size_t uiModuleFileNameLength = 0;
    
    BOOL fGotModuleName = TRUE;

	uiModuleFileNameLength = ::GetModuleFileName(
								_Module.GetModuleInstance(),
								szModuleFileName,
								DimensionOf(szModuleFileName) - 1
								);
	szModuleFileName[uiModuleFileNameLength] = _TEXT('\0');
	fGotModuleName = (uiModuleFileNameLength != 0);

    //
    // registers object, typelib and all interfaces in typelib
    //
    HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stName;
    CString stNameStringIndirect;

    stName.LoadString(IDS_SNAPIN_NAME);
    stNameStringIndirect.Format(L"@%s,-%-d", szModuleFileName, IDS_SNAPIN_DESC);
    //
    // register the snapin into the console snapin list
    //
    hr = RegisterSnapinGUID(&CLSID_IpsmSnapin, 
                        &GUID_IpsmRootNodeType, 
                        &CLSID_IpsmSnapinAbout,
                        (LPCTSTR) stName, 
                        _T("1.0"), 
                        TRUE,
                        fGotModuleName ? (LPCTSTR)stNameStringIndirect : NULL);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stExtensionName;
    CString stExtensionNameIndirect;
    stExtensionName.LoadString(IDS_SNAPIN_EXTENSION);
    stExtensionNameIndirect.Format(L"@%s,-%-d", szModuleFileName, IDS_SNAPIN_EXTENSION);

    hr = RegisterSnapinGUID(&CLSID_IpsmSnapinExtension, 
                            NULL, 
                            &CLSID_IpsmSnapinAbout,
                            (LPCTSTR) stExtensionName, 
                            _T("1.0"), 
                            FALSE,
                            fGotModuleName ? (LPCTSTR)stExtensionNameIndirect : NULL);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    //
    // register the snapin nodes into the console node list
    //
    hr = RegisterNodeTypeGUID(&CLSID_IpsmSnapin, 
                              &GUID_IpsmRootNodeType, 
                              _T("Root of Manager"));
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_IpsmSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &GUID_NetConsRootNodeType);   // doesn't matter what this is, just 
                                                                       // needs to be non-null guid

    ASSERT(SUCCEEDED(hr));
#endif

    hr = RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_IpsmSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS);  // NULL makes it not dynamic
    ASSERT(SUCCEEDED(hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;
    
    // un register the snapin 
    //
    hr = UnregisterSnapinGUID(&CLSID_IpsmSnapin);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    hr = UnregisterSnapinGUID(&CLSID_IpsmSnapinExtension);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    // unregister the snapin nodes 
    //
    hr = UnregisterNodeTypeGUID(&GUID_IpsmRootNodeType);
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    
    hr = UnregisterAsExtensionGUID(&GUID_NetConsRootNodeType, 
                                   &CLSID_IpsmSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));
#endif

    hr = UnregisterAsExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                   &CLSID_IpsmSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CSpdInfo);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmhelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    ipsmhelp.h  
        help IDs for context sensitive help

    FILE HISTORY:
    
*/

// IPSMSNAP Identifiers 
// Dialogs (IDD_*) 
 
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipsmsnap.rc
//

//IP Security Statistics dialog-Refresh button
#define IDH_STATS_REFRESH               8

//Server properties dialog
#define IDH_CHECK_ENABLE_STATS          360
#define IDH_EDIT_MINUTES                361
#define IDH_SPIN_MINUTES                364
#define IDH_STATIC_MINUTES              365
#define IDH_EDIT_SECONDS                362
#define IDH_SPIN_SECONDS                366

#define IDH_BUTTON_ADD_ADMIN            354
#define IDH_BUTTON_REMOVE_ADMIN         355
#define IDH_LIST_USERS                  356
#define IDH_EDIT_NAME                   357
#define IDH_EDIT_PASSWORD               358

#define IDH_CHECK_ENABLE_SERVER         367
#define IDH_LIST_ADMINS                 368
#define IDH_BUTTON_CHOOSE_USER          371
#define IDH_STATIC_ADMINS               372
#define IDH_STATIC_ACCOUNT              373
#define IDH_STATIC_USERNAME             374
#define IDH_STATIC_PASSWORD             375
#define IDH_STATIC_NOTE                 376
#define IDH_STATIC_LISTBOX              377

#define IDH_LIST_DRIVERS                380
#define IDH_BUTTON_EDIT_DRIVER          381
#define IDH_LIST_NEW_DRIVERS            382
#define IDH_BUTTON_ADD_DRIVER           384
#define IDH_BUTTON_REMOVE_DRIVER        386
#define IDH_BUTTON_ADD_USER             387
#define IDH_BUTTON_REMOVE_USER          388
#define IDH_BUTTON_ADD_NEW_DRIVER       389
#define IDH_STATIC_ACCOUNT_INFO         390
#define IDH_EDIT_INFO                   393
#define IDH_LIST_SPECIFIC               394
#define IDH_FLTR_SRC_ADDR               396
#define IDH_STATIC_SRC_MASK             397
#define IDH_STATIC_DEST_MASK            398

#define IDH_MM_POL_GEN_LIST             399
#define IDH_MM_POL_GEN_PROP             400
#define IDH_FLTR_SRC_MASK               401
#define IDH_LIST_MM_POL_AUTH            470
#define IDH_FLTR_IN_FLAG                402
#define IDH_MM_AUTH_DETAIL              403
#define IDH_FLTR_SRC_PORT               404
#define IDH_SRCH_SRC_ANY                405
#define IDH_SRCH_SRC_SPEC               406
#define IDH_FLTR_PROTOCOL               407
#define IDH_SRCH_SRC_EDIT               408
#define IDH_FLTR_IF_TYPE                409
#define IDH_SRCH_DEST_ANY               410
#define IDH_FLTR_MIRROR                 411
#define IDH_SRCH_DEST_SPEC              412
#define IDH_FLTR_POLICY                 413
#define IDH_SRCH_DEST_EDIT              414
#define IDH_FLTR_OUT_FLAG               415
#define IDH_SRCH_PROTO                  416
#define IDH_FLTR_DEST_ADDR              417
#define IDH_SRCH_SRC_PORT               418
#define IDH_FLTR_DEST_MASK              419
#define IDH_SRCH_DEST_PORT              420
#define IDH_FLTR_DEST_PORT              421
#define IDH_SRCH_LIST                   422
#define IDH_QM_POL_GEN_LIST             423
#define IDH_SRCH_PROTO2                 424
#define IDH_MM_STATIC_SRC_MASK          425
#define IDH_MM_FLTR_SRC_ADDR            426
#define IDH_SRCH_INBOUND                427
#define IDH_MM_FLTR_SRC_MASK            428
#define IDH_SRCH_OUTBOUND               429
#define IDH_MM_FLTR_IF_TYPE             430
#define IDH_SEARCH                      431
#define IDH_MM_FLTR_MIRROR              432
#define IDH_SRCH_SRC_IP                 433
#define IDH_MM_FLTR_POLICY              434
#define IDH_SRCH_DEST_IP                435
#define IDH_MM_STATIC_DEST_MASK         436
#define IDH_SRCH_RADIO_BEST             437
#define IDH_MM_FLTR_DEST_ADDR           438
#define IDH_SRCH_RADIO_ALL              439
#define IDH_MM_FLTR_DEST_MASK           440
#define IDH_MM_SRCH_RADIO_BEST          441
#define IDH_MM_LIST_SPECIFIC            442
#define IDH_MM_SRCH_RADIO_ALL           443
#define IDH_MM_SRCH_SRC_ANY             445
#define IDH_MM_SRCH_SRC_SPEC            448
#define IDH_ADD_LOCAL                   449
#define IDH_STATS_QM_LIST               450
#define IDH_MM_SRCH_SRC_IP              451
#define IDH_ADD_OTHER                   452
#define IDH_MM_SRCH_DEST_ANY            453
#define IDH_ADD_EDIT_NAME               454
#define IDH_MM_SRCH_DEST_SPEC           455
#define IDH_BTN_BROWSE                  456
#define IDH_MM_SRCH_DEST_IP             457
#define IDH_MM_SRCH_INBOUND             459
#define IDH_STATS_MM_LIST               460
#define IDH_MM_SRCH_OUTBOUND            461
#define IDH_MM_SEARCH                   462
#define IDH_MM_SRCH_LIST                463

#define IDH_SRCH_PROTO_NUMBER 464
#define IDH_SRCH_SRC_ANYPORT 465
#define IDH_SRCH_SRC_SPPORT 466
#define IDH_SRCH_DEST_ANYPORT 467
#define IDH_SRCH_DEST_SPPORT 468

#define IDH_MMSA_IKE_POL                481
#define IDH_MMSA_LIST_QM                482
#define IDH_MMSA_AUTH                   483
#define IDH_MMSA_CONF                   484
#define IDH_MMSA_INTEG                  485
#define IDH_MMSA_KEYLIFE                486
#define IDH_MMSA_DH_GRP                 487
#define IDH_QMSA_PFS_ENABLE             488
#define IDH_MMSA_ME                     490
#define IDH_MMSA_PEER                   491

#define IDH_QMSA_AUTH                   492
#define IDH_QMSA_ESP_CONF               493

#define IDH_QMSA_KEYLIFE                494

#define IDH_QMSA_PFS_GRP                495
#define IDH_QMSA_PROT                   496
#define IDH_QMSA_NEGPOL                 498
#define IDH_QMSA_ME_TNL                 499
#define IDH_QMSA_PEER_TNL               500

#define IDH_QMSA_SRC_PORT               501
#define IDH_QMSA_DEST_PORT              502
#define IDH_QMSA_DEST                   503
#define IDH_QMSA_SRC                    504
#define IDH_QMSA_ESP_INTEG              505

#define IDH_STATIC_MMSA_OFFER			506
#define IDH_STATIC_QMSA_OFFER			507

#define IDH_CHECK_ENABLE_DNS            510


#define IDH_MM_SRCH_SRC_ME              562
#define IDH_MM_SRCH_DST_ME              563
#define IDH_MM_SRCH_SRC_ME_COMBO        566
#define IDH_MM_SRCH_DST_ME_COMBO        567



#define IDH_SRCH_SRC_ME                 568
#define IDH_SRCH_DST_ME                 569
#define IDH_SRCH_SRC_ME_COMBO           570
#define IDH_SRCH_DST_ME_COMBO           571


//ipsec log prop - default page
#define IDH_CHK_IKELOG_ENABLE           591
#define IDH_STATIC_IKELOG_LOGLEVEL      592
#define IDH_CHK_IKELOG_INFO             593
#define IDH_CHK_IKELOG_WARN             594
#define IDH_CHK_IKELOG_ERR              595
#define IDH_CHK_IKELOG_SEND             596
#define IDH_CHK_IKELOG_RECV             597
#define IDH_CHK_IKELOG_RESEND           598
#define IDH_EDIT_IKELOG_SIZE            599



//ipsec log prop - advanced page
#define IDH_COMBO_IKEADV_SRC_ADDRTYPE   600
#define IDH_COMBO_IKEADV_DEST_ADDRTYPE  601
#define IDH_COMBO_IKEADV_SRCME          602
#define IDH_COMBO_IKEADV_DSTME          603
#define IDH_STATIC_IKEADV_SRCIP         604
#define IDH_IKEADV_SRCIP                605
#define IDH_STATIC_IKEADV_SRCIPMSK      606
#define IDH_IKEADV_SRCIPMSK             607
#define IDH_STATIC_IKEADV_DSTIP         608
#define IDH_IKEADV_DSTIP                609
#define IDH_STATIC_IKEADV_DSTIPMSK      610
#define IDH_IKEADV_DSTIPMSK             611
#define IDH_STATIC_IKEADV_SRCDNS        612
#define IDH_EDIT_IKEADV_SRC_DNS         613
#define IDH_STATIC_IKEADV_DESTDNS       614
#define IDH_EDIT_IKEADV_DEST_DNS        615
#define IDH_BTN_IKEADV_SRC_DNSRES       616
#define IDH_BTN_IKEADV_DEST_DNSRES      617



//ikelogprop
#define IDH_IKELOGPROP_SRC              619
#define IDH_IKELOGPROP_DEST             620
#define IDH_IKELOGPROP_CATG             623
#define IDH_IKELOGPROP_TIMEST           624
#define IDH_IKELOGPROP_DETAIL           625
#define IDH_BTN_IKELOGPROP_MOVE_UP      626
#define IDH_BTN_IKELOGPROP_MOVE_DOWN    627
#define IDH_IKELOGPROP_COOKIE           628
#define IDH_IKELOGPROP_QMMESGID         629
#define IDH_IKELOGPROP_PARSER_TREE      630





//customize view - default page
#define IDH_CHK_IKEVDLOG_INFO           632
#define IDH_CHK_IKEVDLOG_ERR            633
#define IDH_CHK_IKEVDLOG_WARN           634
#define IDH_CHK_IKEVDLOG_SEND           635
#define IDH_CHK_IKEVDLOG_RECV           636
#define IDH_CHK_IKEVDLOG_RESEND         637



//customize view - advance page
#define IDH_COMBO_LOGVADV_SRC_ADDRTYPE  640
#define IDH_COMBO_LOGVADV_DEST_ADDRTYPE 642
#define IDH_STATIC_LOGVADV_SRCIP        643
#define IDH_LOGVADV_SRCIP               645
#define IDH_STATIC_LOGVADV_SRCMASK      646
#define IDH_LOGVADV_SRCMASK             648
#define IDH_STATIC_LOGVADV_DESTIP       649
#define IDH_LOGVADV_DESTIP              651
#define IDH_STATIC_LOGVADV_DESTMASK     652
#define IDH_LOGVADV_DESTMASK            654
#define IDH_COMBO_LOGVADV_SRCME         655
#define IDH_COMBO_LOGVADV_DESTME        656
#define IDH_STATIC_LOGVADV_DESTDNS      657
#define IDH_EDIT_LOGVADV_DEST_DNS       658
#define IDH_BTN_LOGVADV_DEST_DNSRES     659
#define IDH_EDIT_LOGVADV_SRC_DNS        660
#define IDH_BTN_LOGVADV_SRC_DNSRES      661
#define IDH_STATIC_LOGVADV_SRCDNS       662


const DWORD g_aHelpIDs_IDP_FILTER_GENERAL[]=
{
	IDC_STATIC_FLTR_SRC, -1,
	IDC_STATIC_FLTR_DEST, -1,
		
	IDC_STATIC_FLTR_SRC_PORT, IDH_FLTR_SRC_PORT,
	IDC_FLTR_SRC_PORT, IDH_FLTR_SRC_PORT,

	IDC_STATIC_FLTR_SRC_ADDR, IDH_FLTR_SRC_ADDR,
	IDC_FLTR_SRC_ADDR, IDH_FLTR_SRC_ADDR,
	IDC_FLTR_SRC_ADDR_EDIT, IDH_FLTR_SRC_ADDR,

	IDC_STATIC_SRC_MASK, IDH_STATIC_SRC_MASK,
	IDC_FLTR_SRC_MASK, IDH_FLTR_SRC_MASK,

	IDC_STATIC_FLTR_DEST_PORT, IDH_FLTR_DEST_PORT,
	IDC_FLTR_DEST_PORT, IDH_FLTR_DEST_PORT,

	IDC_STATIC_FLTR_DEST_ADDR, IDH_FLTR_DEST_ADDR,
	IDC_FLTR_DEST_ADDR, IDH_FLTR_DEST_ADDR,
	IDC_FLTR_DEST_ADDR_EDIT, IDH_FLTR_DEST_ADDR,

	IDC_STATIC_DEST_MASK, IDH_STATIC_DEST_MASK,
	IDC_FLTR_DEST_MASK, IDH_FLTR_DEST_MASK,

	IDC_STATIC_FLTR_PROTOCOL, IDH_FLTR_PROTOCOL,
	IDC_FLTR_PROTOCOL, IDH_FLTR_PROTOCOL,

	IDC_STATIC_FLTR_IN_FLAG, IDH_FLTR_IN_FLAG,
	IDC_FLTR_IN_FLAG, IDH_FLTR_IN_FLAG,

	IDC_STATIC_FLTR_OUT_FLAG, IDH_FLTR_OUT_FLAG,
	IDC_FLTR_OUT_FLAG, IDH_FLTR_OUT_FLAG,

	IDC_STATIC_FLTR_IF_TYPE, IDH_FLTR_IF_TYPE,
	IDC_FLTR_IF_TYPE, IDH_FLTR_IF_TYPE,

	IDC_STATIC_FLTR_MIRROR, IDH_FLTR_MIRROR,
	IDC_FLTR_MIRROR, IDH_FLTR_MIRROR,

	IDC_STATIC_FLTR_POLICY, IDH_FLTR_POLICY,
	IDC_FLTR_POLICY, IDH_FLTR_POLICY,
	
	IDC_LIST_SPECIFIC, IDH_LIST_SPECIFIC,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_FILTER_GENERAL[]=
{
	IDC_STATIC_MM_FLTR_SRC, -1,
	IDC_STATIC_MM_FLTR_DEST, -1,
	
	IDC_STATIC_MM_FLTR_SRC_ADDR, IDH_MM_FLTR_SRC_ADDR,
	IDC_MM_FLTR_SRC_ADDR, IDH_MM_FLTR_SRC_ADDR,
	IDC_MM_FLTR_SRC_ADDR_EDIT, IDH_MM_FLTR_SRC_ADDR,

	IDC_MM_STATIC_SRC_MASK, IDH_MM_STATIC_SRC_MASK,
	IDC_MM_FLTR_SRC_MASK, IDH_MM_FLTR_SRC_MASK,

	IDC_STATIC_MM_FLTR_DEST_ADDR, IDH_MM_FLTR_DEST_ADDR,
	IDC_MM_FLTR_DEST_ADDR, IDH_MM_FLTR_DEST_ADDR,
	IDC_MM_FLTR_DEST_ADDR_EDIT, IDH_MM_FLTR_DEST_ADDR,

	IDC_MM_STATIC_DEST_MASK, IDH_MM_STATIC_DEST_MASK,
	IDC_MM_FLTR_DEST_MASK, IDH_MM_FLTR_DEST_MASK,

	IDC_STATIC_MM_FLTR_IF_TYPE, IDH_MM_FLTR_IF_TYPE,
	IDC_MM_FLTR_IF_TYPE, IDH_MM_FLTR_IF_TYPE,

	IDC_STATIC_MM_FLTR_MIRROR, IDH_MM_FLTR_MIRROR,
	IDC_MM_FLTR_MIRROR, IDH_MM_FLTR_MIRROR,

	IDC_STATIC_MM_FLTR_POLICY, IDH_MM_FLTR_POLICY,
	IDC_MM_FLTR_POLICY, IDH_MM_FLTR_POLICY,
	
	IDC_MM_LIST_SPECIFIC, IDH_MM_LIST_SPECIFIC,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_POLICY_GENERAL[]=
{
	IDC_MM_POL_GEN_LIST, IDH_MM_POL_GEN_LIST,
	IDC_MM_POL_GEN_PROP, IDH_MM_POL_GEN_PROP,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_SA_GENERAL[]=
{
	IDC_STATIC_MMSA_ME, IDH_MMSA_ME,
	IDC_MMSA_ME, IDH_MMSA_ME,

	IDC_STATIC_MMSA_PEER, IDH_MMSA_PEER,
	IDC_MMSA_PEER, IDH_MMSA_PEER,

	IDC_STATIC_MMSA_AUTH, IDH_MMSA_AUTH,
	IDC_MMSA_AUTH, IDH_MMSA_AUTH,

	IDC_STATIC_MMSA_IKE_POL, IDH_MMSA_IKE_POL,
	IDC_MMSA_IKE_POL, IDH_MMSA_IKE_POL,

	IDC_STATIC_MMSA_OFFER, IDH_STATIC_MMSA_OFFER,

	IDC_STATIC_MMSA_CONF, IDH_MMSA_CONF,
	IDC_MMSA_CONF, IDH_MMSA_CONF,

	IDC_STATIC_MMSA_INTEG, IDH_MMSA_INTEG,
	IDC_MMSA_INTEG, IDH_MMSA_INTEG,

	IDC_STATIC_MMSA_DH_GRP, IDH_MMSA_DH_GRP,
	IDC_MMSA_DH_GRP, IDH_MMSA_DH_GRP,

	IDC_STATIC_MMSA_KEYLIFE, IDH_MMSA_KEYLIFE,
	IDC_MMSA_KEYLIFE, IDH_MMSA_KEYLIFE,

	IDC_MMSA_LIST_QM, IDH_MMSA_LIST_QM,
	0, 0
};

const DWORD g_aHelpIDs_IDP_QM_SA_GENERAL[]=
{
	IDC_STATIC_QMSA_SRC, IDH_QMSA_SRC,
	IDC_QMSA_SRC, IDH_QMSA_SRC,

	IDC_STATIC_QMSA_DEST, IDH_QMSA_DEST,
	IDC_QMSA_DEST, IDH_QMSA_DEST,

	IDC_STATIC_QMSA_SRC_PORT, IDH_QMSA_SRC_PORT,
	IDC_QMSA_SRC_PORT, IDH_QMSA_SRC_PORT,

	IDC_STATIC_QMSA_DEST_PORT, IDH_QMSA_DEST_PORT,
	IDC_QMSA_DEST_PORT, IDH_QMSA_DEST_PORT,

	IDC_STATIC_QMSA_PROT, IDH_QMSA_PROT,
	IDC_QMSA_PROT, IDH_QMSA_PROT,

	IDC_STATIC_QMSA_OFFER, IDH_STATIC_QMSA_OFFER,

	IDC_STATIC_QMSA_AUTH, IDH_QMSA_AUTH,
	IDC_QMSA_AUTH, IDH_QMSA_AUTH,

	IDC_STATIC_QMSA_ESP_CONF, IDH_QMSA_ESP_CONF,
	IDC_QMSA_ESP_CONF, IDH_QMSA_ESP_CONF,

	IDC_STATIC_QMSA_ESP_INTEG, IDH_QMSA_ESP_INTEG, 
	IDC_QMSA_ESP_INTEG, IDH_QMSA_ESP_INTEG, 

	IDC_STATIC_QMSA_KEYLIFE, IDH_QMSA_KEYLIFE,
	IDC_QMSA_KEYLIFE, IDH_QMSA_KEYLIFE,

	IDC_STATIC_QMSA_PFS_ENABLE, IDH_QMSA_PFS_ENABLE,
	IDC_QMSA_PFS_ENABLE, IDH_QMSA_PFS_ENABLE,

	IDC_STATIC_QMSA_PFS_GRP, IDH_QMSA_PFS_GRP,
	IDC_QMSA_PFS_GRP, IDH_QMSA_PFS_GRP,

	IDC_STATIC_QMSA_NEGPOL, IDH_QMSA_NEGPOL,  
	IDC_QMSA_NEGPOL, IDH_QMSA_NEGPOL,  

	IDC_STATIC_QMSA_ME_TNL, IDH_QMSA_ME_TNL,   
	IDC_QMSA_ME_TNL, IDH_QMSA_ME_TNL,   

	IDC_STATIC_QMSA_PEER_TNL, IDH_QMSA_PEER_TNL,
	IDC_QMSA_PEER_TNL, IDH_QMSA_PEER_TNL,

	0, 0
};

const DWORD g_aHelpIDs_IDP_QM_POLICY_GENERAL[]=
{
	IDC_QM_POL_GEN_LIST, IDH_QM_POL_GEN_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDP_SERVER_REFRESH[]=
{
	IDC_CHECK_ENABLE_STATS, IDH_CHECK_ENABLE_STATS,

	IDC_STATIC_INTERVAL, -1,
	IDC_EDIT_MINUTES, IDH_EDIT_MINUTES,
	IDC_SPIN_MINUTES, IDH_SPIN_MINUTES,
	IDC_STATIC_MINUTES, -1,
	

	IDC_EDIT_SECONDS, IDH_EDIT_SECONDS,
	IDC_SPIN_SECONDS, IDH_SPIN_SECONDS,
	IDC_STATIC_SECONDS, -1,
	IDC_CHECK_ENABLE_DNS, IDH_CHECK_ENABLE_DNS,
	
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_AUTH[]=
{
	IDC_LIST_MM_POL_AUTH, IDH_LIST_MM_POL_AUTH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SRCH_FLTRS[]=
{
	IDC_SRCH_SRC_ANY, IDH_SRCH_SRC_ANY,
	IDC_SRCH_SRC_SPEC, IDH_SRCH_SRC_SPEC,
	IDC_SRCH_SRC_IP, IDH_SRCH_SRC_IP,
	IDC_SRCH_DEST_ANY, IDH_SRCH_DEST_ANY,
	IDC_SRCH_DEST_SPEC, IDH_SRCH_DEST_SPEC,
	IDC_SRCH_DEST_IP, IDH_SRCH_DEST_IP,
	IDC_SRCH_PROTO, IDH_SRCH_PROTO,
	IDC_SRCH_PROTO_NUMBER, IDH_SRCH_PROTO_NUMBER,
	IDC_SRCH_PROTO_SPIN, IDH_SRCH_PROTO_NUMBER,
	IDC_SRCH_SRC_ANYPORT, IDH_SRCH_SRC_ANYPORT,
	IDC_SRCH_SRC_SPPORT, IDH_SRCH_SRC_SPPORT,
	IDC_SRCH_DEST_ANYPORT, IDH_SRCH_DEST_ANYPORT,
	IDC_SRCH_DEST_SPPORT, IDH_SRCH_DEST_SPPORT,
	IDC_SRCH_SRC_PORT, IDH_SRCH_SRC_PORT,
	IDC_SRCH_DEST_PORT, IDH_SRCH_DEST_PORT,
	IDC_SRCH_INBOUND, IDH_SRCH_INBOUND,
	IDC_SRCH_OUTBOUND, IDH_SRCH_OUTBOUND,
	IDC_SEARCH, IDH_SEARCH,
	IDC_SRCH_LIST, IDH_SRCH_LIST,
	IDC_SRCH_RADIO_BEST, IDH_SRCH_RADIO_BEST,
	IDC_SRCH_RADIO_ALL, IDH_SRCH_RADIO_ALL,
	IDC_SRCH_SRC_ME, IDH_SRCH_SRC_ME,
	IDC_SRCH_DST_ME, IDH_SRCH_DST_ME,
	IDC_SRCH_SRC_ME_COMBO, IDH_SRCH_SRC_ME_COMBO,
	IDC_SRCH_DST_ME_COMBO, IDH_SRCH_DST_ME_COMBO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MM_SRCH_FLTRS[]=
{
	IDC_MM_SRCH_SRC_ANY, IDH_MM_SRCH_SRC_ANY,
	IDC_MM_SRCH_SRC_SPEC, IDH_MM_SRCH_SRC_SPEC,
	IDC_MM_SRCH_SRC_IP, IDH_MM_SRCH_SRC_IP,
	IDC_MM_SRCH_DEST_ANY, IDH_MM_SRCH_DEST_ANY,
	IDC_MM_SRCH_DEST_SPEC, IDH_MM_SRCH_DEST_SPEC,
	IDC_MM_SRCH_DEST_IP, IDH_MM_SRCH_DEST_IP,
	IDC_MM_SRCH_INBOUND, IDH_MM_SRCH_INBOUND,
	IDC_MM_SRCH_OUTBOUND, IDH_MM_SRCH_OUTBOUND,
	IDC_MM_SEARCH, IDH_MM_SEARCH,
	IDC_MM_SRCH_LIST, IDH_MM_SRCH_LIST,
	IDC_MM_SRCH_RADIO_BEST, IDH_MM_SRCH_RADIO_BEST,
	IDC_MM_SRCH_RADIO_ALL, IDH_MM_SRCH_RADIO_ALL,
	IDC_MM_SRCH_SRC_ME, IDH_MM_SRCH_SRC_ME,
	IDC_MM_SRCH_DST_ME, IDH_MM_SRCH_DST_ME,
	IDC_MM_SRCH_SRC_ME_COMBO, IDH_MM_SRCH_SRC_ME_COMBO,
	IDC_MM_SRCH_DST_ME_COMBO, IDH_MM_SRCH_DST_ME_COMBO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ADD_COMPUTER[]=
{
	IDC_ADD_LOCAL, IDH_ADD_LOCAL,
	IDC_ADD_OTHER, IDH_ADD_OTHER,
	IDC_ADD_EDIT_NAME, IDH_ADD_EDIT_NAME,
	IDC_BTN_BROWSE, IDH_BTN_BROWSE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPSM_STATS[]=
{
	IDC_STATS_MM_LIST, IDH_STATS_MM_LIST,
	IDC_STATS_QM_LIST, IDH_STATS_QM_LIST,
	IDC_STATS_REFRESH, IDH_STATS_REFRESH,
	0, 0
};


const DWORD g_aHelpIDs_IDP_IKELOG_DEF[]=
{
	IDC_CHK_IKELOG_ENABLE, IDH_CHK_IKELOG_ENABLE,
    IDC_STATIC_IKELOG_LOGLEVEL, IDH_STATIC_IKELOG_LOGLEVEL,
    IDC_CHK_IKELOG_INFO, IDH_CHK_IKELOG_INFO,
    IDC_CHK_IKELOG_WARN, IDH_CHK_IKELOG_WARN,      
    IDC_CHK_IKELOG_ERR, IDH_CHK_IKELOG_ERR,     
    IDC_CHK_IKELOG_SEND, IDH_CHK_IKELOG_SEND,
    IDC_CHK_IKELOG_RECV, IDH_CHK_IKELOG_RECV,
    IDC_CHK_IKELOG_RESEND, IDH_CHK_IKELOG_RESEND,
    IDC_EDIT_IKELOG_SIZE, IDH_EDIT_IKELOG_SIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDP_IKELOG_ADV[]=
{
     IDC_COMBO_IKEADV_SRC_ADDRTYPE, IDH_COMBO_IKEADV_SRC_ADDRTYPE,
     IDC_COMBO_IKEADV_DEST_ADDRTYPE, IDH_COMBO_IKEADV_DEST_ADDRTYPE,
     IDC_COMBO_IKEADV_SRCME, IDH_COMBO_IKEADV_SRCME,
     IDC_COMBO_IKEADV_DSTME, IDH_COMBO_IKEADV_DSTME,
     IDC_STATIC_IKEADV_SRCIP, IDH_STATIC_IKEADV_SRCIP,
     IDC_IKEADV_SRCIP, IDH_IKEADV_SRCIP,
     IDC_STATIC_IKEADV_SRCIPMSK, IDH_STATIC_IKEADV_SRCIPMSK,
     IDC_IKEADV_SRCIPMSK, IDH_IKEADV_SRCIPMSK,
     IDC_STATIC_IKEADV_DSTIP, IDH_STATIC_IKEADV_DSTIP,
     IDC_IKEADV_DSTIP, IDH_IKEADV_DSTIP,
     IDC_STATIC_IKEADV_DSTIPMSK, IDH_STATIC_IKEADV_DSTIPMSK,
     IDC_IKEADV_DSTIPMSK, IDH_IKEADV_DSTIPMSK,
     IDC_STATIC_IKEADV_SRCDNS, IDH_STATIC_IKEADV_SRCDNS,
     IDC_EDIT_IKEADV_SRC_DNS, IDH_EDIT_IKEADV_SRC_DNS,
     IDC_STATIC_IKEADV_DESTDNS, IDH_STATIC_IKEADV_DESTDNS,
     IDC_EDIT_IKEADV_DEST_DNS, IDH_EDIT_IKEADV_DEST_DNS,
     IDC_BTN_IKEADV_SRC_DNSRES, IDH_BTN_IKEADV_SRC_DNSRES,
     IDC_BTN_IKEADV_DEST_DNSRES, IDH_BTN_IKEADV_DEST_DNSRES,
     0, 0
};

const DWORD g_aHelpIDs_IDP_IKELOGPROP[]=
{
    IDC_IKELOGPROP_SRC, IDH_IKELOGPROP_SRC,
    IDC_IKELOGPROP_DEST, IDH_IKELOGPROP_DEST,
    IDC_IKELOGPROP_CATG, IDH_IKELOGPROP_CATG,
    IDC_IKELOGPROP_TIMEST, IDH_IKELOGPROP_TIMEST,
    IDC_IKELOGPROP_DETAIL, IDH_IKELOGPROP_DETAIL,
    IDC_BTN_IKELOGPROP_MOVE_UP, IDH_BTN_IKELOGPROP_MOVE_UP,
    IDC_BTN_IKELOGPROP_MOVE_DOWN, IDH_BTN_IKELOGPROP_MOVE_DOWN,
    IDC_IKELOGPROP_COOKIE, IDH_IKELOGPROP_COOKIE,
    IDC_IKELOGPROP_QMMESGID, IDH_IKELOGPROP_QMMESGID,
    IDC_IKELOGPROP_PARSER_TREE, IDH_IKELOGPROP_PARSER_TREE,
    0, 0
};

const DWORD g_aHelpIDs_IDP_CUSTOMLOGVW_DEF[]=
{
    IDC_CHK_IKEVDLOG_INFO, IDH_CHK_IKEVDLOG_INFO,
    IDC_CHK_IKEVDLOG_ERR, IDH_CHK_IKEVDLOG_ERR,
    IDC_CHK_IKEVDLOG_WARN, IDH_CHK_IKEVDLOG_WARN,
    IDC_CHK_IKEVDLOG_SEND, IDH_CHK_IKEVDLOG_SEND, 
    IDC_CHK_IKEVDLOG_RECV, IDH_CHK_IKEVDLOG_RECV, 
    IDC_CHK_IKEVDLOG_RESEND, IDH_CHK_IKEVDLOG_RESEND,
    0, 0
};

const DWORD g_aHelpIDs_IDP_CUSTOMLOGVW_ADV[]=
{
    IDC_COMBO_LOGVADV_SRC_ADDRTYPE, IDH_COMBO_LOGVADV_SRC_ADDRTYPE,
    IDC_COMBO_LOGVADV_DEST_ADDRTYPE, IDH_COMBO_LOGVADV_DEST_ADDRTYPE,
    IDC_STATIC_LOGVADV_SRCIP, IDH_STATIC_LOGVADV_SRCIP,
    IDC_LOGVADV_SRCIP, IDH_LOGVADV_SRCIP,
    IDC_STATIC_LOGVADV_SRCMASK, IDH_STATIC_LOGVADV_SRCMASK,
    IDC_LOGVADV_SRCMASK, IDH_LOGVADV_SRCMASK,
    IDC_STATIC_LOGVADV_DESTIP, IDH_STATIC_LOGVADV_DESTIP,
    IDC_LOGVADV_DESTIP, IDH_LOGVADV_DESTIP,
    IDC_STATIC_LOGVADV_DESTMASK, IDH_STATIC_LOGVADV_DESTMASK,
    IDC_LOGVADV_DESTMASK, IDH_LOGVADV_DESTMASK,
    IDC_COMBO_LOGVADV_SRCME, IDH_COMBO_LOGVADV_SRCME,
    IDC_COMBO_LOGVADV_DESTME, IDH_COMBO_LOGVADV_DESTME,
    IDC_STATIC_LOGVADV_DESTDNS, IDH_STATIC_LOGVADV_DESTDNS,
    IDC_EDIT_LOGVADV_DEST_DNS, IDH_EDIT_LOGVADV_DEST_DNS,
    IDC_BTN_LOGVADV_DEST_DNSRES, IDH_BTN_LOGVADV_DEST_DNSRES,
    IDC_EDIT_LOGVADV_SRC_DNS, IDH_EDIT_LOGVADV_SRC_DNS,
    IDC_BTN_LOGVADV_SRC_DNSRES, IDH_BTN_LOGVADV_SRC_DNSRES,
    IDC_STATIC_LOGVADV_SRCDNS, IDH_STATIC_LOGVADV_SRCDNS,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mdlsdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    MdlsDlg.cpp
		The class to handle modelss dialog in the snapin

	FILE HISTORY:

*/

#include "stdafx.h"
#include "modeless.h"
#include "MdlsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg dialog


CModelessDlg::CModelessDlg()
	: CBaseDialog()
{
	//{{AFX_DATA_INIT(CModelessDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_hEventThreadKilled = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	Assert(m_hEventThreadKilled);
}

CModelessDlg::~CModelessDlg()
{
	if (m_hEventThreadKilled)
		::CloseHandle(m_hEventThreadKilled);
	m_hEventThreadKilled = 0;
}

void CModelessDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CModelessDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CModelessDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CModelessDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg message handlers

void CModelessDlg::OnOK()
{
	DestroyWindow();

	// Explicitly kill this thread.
	AfxPostQuitMessage(0);
}


void CModelessDlg::OnCancel()
{
	DestroyWindow();

	// Explicitly kill this thread.
	AfxPostQuitMessage(0);
}


void CreateModelessDlg(CModelessDlg * pDlg,
					   HWND hWndParent,
                       UINT  nIDD)
{                         
   ModelessThread *  pMT;

   // If the dialog is still up, don't create a new one
   if (pDlg->GetSafeHwnd())
   {
      ::SetActiveWindow(pDlg->GetSafeHwnd());
      return;
   }

   pMT = new ModelessThread(hWndParent,
                      nIDD,
                      pDlg->GetSignalEvent(),
                      pDlg);
   pMT->CreateThread();
}

void WaitForModelessDlgClose(CModelessDlg *pDlg)
{
   if (pDlg->GetSafeHwnd())
   {
      // Post a cancel to that window
      // Do an explicit post so that it executes on the other thread
      pDlg->PostMessage(WM_COMMAND, IDCANCEL, 0);

      // Now we need to wait for the event to be signalled so that
      // its memory can be cleaned up
      WaitForSingleObject(pDlg->GetSignalEvent(), INFINITE);
   }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\ipsmsnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	global.h
		Global defines for the IPSecMon snapin


	FILE HISTORY:
        
*/

const TCHAR PA_SERVICE_NAME[] = _T("PolicyAgent");

// Defines for help from the help menu and F1 help for scope pane items
#define IPSMSNAP_HELP_BASE				    0xA0000000
#define IPSMSNAP_HELP_SNAPIN			    IPSMSNAP_HELP_BASE + 1
#define IPSMSNAP_HELP_ROOT				    IPSMSNAP_HELP_BASE + 2
#define IPSMSNAP_HELP_SERVER 			    IPSMSNAP_HELP_BASE + 3
#define IPSMSNAP_HELP_PROVIDER 		        IPSMSNAP_HELP_BASE + 4
#define IPSMSNAP_HELP_DEVICE  			    IPSMSNAP_HELP_BASE + 5

// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// macro to get the handler for a node. This is a IPSecMon snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

// HRESULT Mapping
#define WIN32_FROM_HRESULT(hr)         (0x0000FFFF & (hr))

// Version Suff
#define IPSMSNAP_VERSION         0x00010000

extern DWORD gdwIpsmSnapVersion;

#define IPSMSNAP_FILE_VERSION	 0x00000001

// constants for time conversion
#define MILLISEC_PER_SECOND			1000
#define MILLISEC_PER_MINUTE			(60 * MILLISEC_PER_SECOND)
#define MILLISEC_PER_HOUR			(60 * MILLISEC_PER_MINUTE)

#define IPSECMON_REFRESH_INTERVAL_DEFAULT	(45 * MILLISEC_PER_SECOND) // 45 seconds

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// some global defines we need
#define STRING_LENGTH_MAX		 256

// Note - These are offsets into my image list
typedef enum _ICON_INDICIES
{
	ICON_IDX_SERVER,
	ICON_IDX_SERVER_BUSY,
	ICON_IDX_SERVER_CONNECTED,
	ICON_IDX_SERVER_LOST_CONNECTION,
	ICON_IDX_MACHINE,
	ICON_IDX_FOLDER_OPEN,
	ICON_IDX_FOLDER_CLOSED,
	ICON_IDX_PRODUCT,
	ICON_IDX_FILTER,
	ICON_IDX_POLICY,
	ICON_IDX_MAX
} ICON_INDICIES, * LPICON_INDICIES;

// Sample folder types
enum NODETYPES
{
// scope pane items
    IPSMSNAP_ROOT,
    IPSMSNAP_SERVER,
    IPSECMON_QM_SA,
	IPSECMON_FILTER,
	IPSECMON_SPECIFIC_FILTER,
	IPSECMON_QUICK_MODE,
	IPSECMON_MAIN_MODE,
	IPSECMON_MM_POLICY,
	IPSECMON_QM_POLICY,
	IPSECMON_MM_FILTER,
	IPSECMON_MM_SP_FILTER,
	IPSECMON_MM_SA,
	IPSECMON_MM_IKESTATS,
	IPSECMON_QM_IPSECSTATS,
	IPSECMON_ACTIVEPOL,
// result pane items
    IPSECMON_QM_SA_ITEM,
	IPSECMON_FILTER_ITEM,
	IPSECMON_SPECIFIC_FILTER_ITEM,
	IPSECMON_MM_POLICY_ITEM,
	IPSECMON_QM_POLICY_ITEM,
	IPSECMON_MM_FILTER_ITEM,
	IPSECMON_MM_SP_FILTER_ITEM,
	IPSECMON_MM_SA_ITEM,
	IPSECMON_MM_IKESTATS_ITEM,
	IPSECMON_QM_IPSECSTATS_ITEM,
	IPSECMON_ACTIVEPOL_ITEM,
    IPSECMON_NODETYPE_MAX,
};

//  GUIDs are defined in guids.cpp
extern const CLSID      CLSID_IpsmSnapin;				// In-Proc server GUID
extern const CLSID      CLSID_IpsmSnapinExtension;		// In-Proc server GUID
extern const CLSID      CLSID_IpsmSnapinAbout;			// In-Proc server GUID
extern const GUID       GUID_IpsmRootNodeType;			// Root NodeType GUID 
extern const GUID       GUID_IpsmServerNodeType;		// Server NodeType GUID
extern const GUID       GUID_IpsmFilterNodeType;		// Filters NodeType GUID
extern const GUID       GUID_IpsmSpecificFilterNodeType;		// Specific Filters NodeType GUID
extern const GUID       GUID_QmNodeType;			// Quick Mode NodeType GUID
extern const GUID       GUID_MmNodeType;			// Main Mode NodeType GUID

extern const GUID       GUID_IpsmMmPolicyNodeType;		// Main Mode Policy GUID 
extern const GUID       GUID_IpsmQmPolicyNodeType;		// Quick Mode Policy GUID
extern const GUID       GUID_IpsmMmFilterNodeType;		// Main Mode Filter GUID  
extern const GUID       GUID_IpsmMmSANodeType;			// Main Mode SA GUID
extern const GUID       GUID_IpsmMmSpFilterNodeType;	// Main Mode Specific Filter GUID
extern const GUID		GUID_IpsmMmIkeStatsNodeType;
extern const GUID		GUID_IpsmMmIpsecStatsNodeType;

extern const GUID       IID_ISpdInfo;
extern const GUID       GUID_IpsmQmSANodeType;
extern const GUID       GUID_IpsmActivePolNodeType;

const int MAX_COLUMNS = 14;
const int NUM_SCOPE_ITEMS = 3;
const int NUM_CONSOLE_VERBS = 8;

// arrays used to hold all of the result pane column information
extern UINT aColumns[IPSECMON_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[IPSECMON_NODETYPE_MAX][MAX_COLUMNS];


// arrays for console verbs
extern MMC_CONSOLE_VERB g_ConsoleVerbs[NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[IPSECMON_NODETYPE_MAX][NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[IPSECMON_NODETYPE_MAX][NUM_CONSOLE_VERBS];

// array for help
extern DWORD g_dwMMCHelp[IPSECMON_NODETYPE_MAX];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

// CIpsmSnapinApp definition
class CIpsmSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

    DECLARE_MESSAGE_MAP()

public:
	BOOL m_bWinsockInited;
};

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
	{ SHActivateContext (&m_ulActivationCookie); }
	
    ~CThemeContextActivator()
	{ SHDeactivateContext (m_ulActivationCookie); }
	
private:
    ULONG_PTR m_ulActivationCookie;
};

extern CIpsmSnapinApp theApp;

#define IPSECMON_UPDATE_STATUS ( 0x10000000 )


//Macros for convering ip to text form
// 0,1,2,3 : count of bytes from MSB to LSB in host order
#define BYTE0(l) ((BYTE)((DWORD)(l) >> 24))
#define BYTE1(l) ((BYTE)((DWORD)(l) >> 16))
#define BYTE2(l) ((BYTE)((DWORD)(l) >> 8))
#define BYTE3(l) ((BYTE)((DWORD)(l)))
 
// Handy macro to use in printf statements
#define BYTES0123(l) BYTE0(l), BYTE1(l), BYTE2(l), BYTE3(l)
 
// 0,1,2,3 : count of bytes from MSB to LSB in network order
#define NETORDER_BYTE0(l) ((BYTE)((BYTE *) &l)[0])
#define NETORDER_BYTE1(l) ((BYTE)((BYTE *) &l)[1])
#define NETORDER_BYTE2(l) ((BYTE)((BYTE *) &l)[2])
#define NETORDER_BYTE3(l) ((BYTE)((BYTE *) &l)[3])
 
// Handy macro to use in printf statements
#define NETORDER_BYTES0123(l)                   \
    NETORDER_BYTE0(l), NETORDER_BYTE1(l),       \
    NETORDER_BYTE2(l), NETORDER_BYTE3(l)
 
#define GET_SOCKADDR(pAddr)    NETORDER_BYTES0123(pAddr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mdlsdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    SrchFltr.h   
        Search Filter dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_

#include "spddb.h"
#include "ipctrl.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg dialog

class CModelessDlg : public CBaseDialog
{
// Construction
public:
	CModelessDlg();   // standard constructor
	virtual ~CModelessDlg();

	HANDLE GetSignalEvent() { return m_hEventThreadKilled; }

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchFilters)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	virtual void OnOK();
	virtual void OnCancel();

	// Generated message map functions
	//{{AFX_MSG(CModelessDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// This is used by the thread and the handler (the thread signals
   // the handler that it has cleaned up after itself).
   HANDLE   m_hEventThreadKilled;

};

void CreateModelessDlg(CModelessDlg * pDlg,
					   HWND hWndParent,
                       UINT  nIDD);

void WaitForModelessDlgClose(CModelessDlg *pWndStats);

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmauthpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	MmOffer.cpp
		dialog to IPSec Main Mode Offers
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "spddb.h"
#include "spdutil.h"
#include "mmauthpp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAuthGenPage message handlers

IMPLEMENT_DYNCREATE(CAuthGenPage, CPropertyPageBase)

CAuthGenPage::CAuthGenPage()
	: CPropertyPageBase(CAuthGenPage::IDD)
{
	//{{AFX_DATA_INIT(CAuthGenPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CAuthGenPage::~CAuthGenPage()
{
}

void CAuthGenPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAuthGenPage)
	DDX_Control(pDX, IDC_LIST_MM_POL_AUTH, m_listAuth);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAuthGenPage, CPropertyPageBase)
	//{{AFX_MSG_MAP(CAuthGenPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAuthGenPage message handlers

BOOL CAuthGenPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	PopulateAuthInfo();	
	return TRUE;  
}


void CAuthGenPage::PopulateAuthInfo()
{
	CString st;
	int nWidth;
	int nRows;

	Assert(m_pAuthMethods);

	ListView_SetExtendedListViewStyle(m_listAuth.GetSafeHwnd(),
                                      LVS_EX_FULLROWSELECT);

	st.LoadString(IDS_MM_AUTH_METHOD);
	nWidth = m_listAuth.GetStringWidth(st) + 50;
	m_listAuth.InsertColumn(0, st, LVCFMT_LEFT, nWidth);

	RECT rect;
	m_listAuth.GetClientRect(&rect);

	st.LoadString(IDS_MM_AUTH_DETAIL);
	nWidth = rect.right - nWidth;
	m_listAuth.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	nRows = 0;
	for (int i = 0; i < (int)m_pAuthMethods->m_arrAuthInfo.GetSize(); i++)
	{
		nRows = m_listAuth.InsertItem(nRows, _T(""));

		if (-1 != nRows)
		{
			MmAuthToString(m_pAuthMethods->m_arrAuthInfo[i]->m_AuthMethod, &st);
			m_listAuth.SetItemText(nRows, 0, st);

			st.Empty();

			switch(m_pAuthMethods->m_arrAuthInfo[i]->m_AuthMethod)
			{
			case IKE_PRESHARED_KEY:
				st = (LPCTSTR) m_pAuthMethods->m_arrAuthInfo[i]->m_pAuthInfo;
				break;
			case IKE_DSS_SIGNATURE:
				//not valid yet
				break;
			case IKE_RSA_SIGNATURE:
				st = (LPCTSTR) m_pAuthMethods->m_arrAuthInfo[i]->m_pAuthInfo;
				break;
			case IKE_RSA_ENCRYPTION:
				//not valid yet
				break;
			case IKE_SSPI:
				break;
			}
			m_listAuth.SetItemText(nRows, 1, st);
		}

		nRows++;
	}
}


BOOL CAuthGenPage::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmauthpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

#ifndef _MM_OFFER_HEADER
#define _MM_OFFER_HEADER

class CAuthGenPage : public CPropertyPageBase
{

	DECLARE_DYNCREATE(CAuthGenPage)

// Construction
public:
	CAuthGenPage();   // standard constructor
	virtual ~CAuthGenPage();


// Dialog Data
	//{{AFX_DATA(CAuthGenPage)
	enum { IDD = IDP_MM_AUTH };
	CListCtrl	m_listAuth;
	//}}AFX_DATA

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

	// Context Help Support
    virtual DWORD * GetHelpMap() 
	{ 
		return (DWORD *) &g_aHelpIDs_IDP_MM_AUTH[0]; 
	}


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAuthGenPage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAuthGenPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void    PopulateAuthInfo();

public:
	CMmAuthMethods * m_pAuthMethods;

public:
	void InitData(CMmAuthMethods * pAuthMethods) { m_pAuthMethods = pAuthMethods; }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmfltr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Filter node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "MmFltr.h"
#include "SpdUtil.h"
#include "MmFltrpp.h"

/*---------------------------------------------------------------------------
    Class CMmFilterHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CMmFilterHandler::CMmFilterHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CMmFilterHandler::~CMmFilterHandler()
{
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmFilterHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_MM_FILTER_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_MM_FILTER);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_MM_FILTER][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_MM_FILTER][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CMmFilterHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmFilterHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmFilterHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmFilterHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));
	
	CORg(m_spSpdInfo->EnumMmFilters());
        
    i = m_spSpdInfo->GetMmFilterCount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));

Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;

    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_MM_FILTER)) {
            CORg(m_spSpdInfo->EnumMmFilters());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_FILTER);
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_SP_FILTER);
        }
        m_spSpdInfo->SetActiveInfo(MON_MM_FILTER);


        // Get the current count
        i = m_spSpdInfo->GetMmFilterCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
		
		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_FILTER_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;

		m_verbDefault = MMC_VERB_PROPERTIES; 
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CMmFilterHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;
	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CMmFilterInfo FltrInfo;
	CMmFilterProperties * pFilterProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetMmFilterInfo(nIndex, &FltrInfo));

	pFilterProp = new CMmFilterProperties(
												spNode,
												spComponentData,
												m_spTFSCompData,
												&FltrInfo,
												m_spSpdInfo,
												NULL);

	hr = pFilterProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CMmFilterHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmFilterHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CMmFilterHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;
	
	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_FILTER]))
		return NULL;
	
	CMmFilterInfo fltr;
	CORg(m_spSpdInfo->GetMmFilterInfo(nIndex, &fltr));

    switch (aColumns[IPSECMON_MM_FILTER][nCol])
    {
        case IDS_COL_FLTR_NAME:
			strTemp = fltr.m_stName;
			return strTemp;
            break;

        case IDS_COL_FLTR_SRC:
			AddressToString(fltr.m_SrcAddr, &strTemp);
			return strTemp;
            break;

        case IDS_COL_FLTR_DEST:
			AddressToString(fltr.m_DesAddr, &strTemp);
			return strTemp;
            break;

		case IDS_COL_MM_FLTR_POL:
			{
				strTemp = fltr.m_stPolicyName;
				if( fltr.m_dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY )
				{
					AfxFormatString1(strTemp, IDS_POL_DEFAULT, (LPCTSTR) fltr.m_stPolicyName);
				}
								
				return strTemp;
				break;
			}

		case IDS_COL_MM_FLTR_AUTH:
			strTemp = fltr.m_stAuthDescription;
			return strTemp;
			break;

		case IDS_COL_IF_TYPE:
			InterfaceTypeToString(fltr.m_InterfaceType, &strTemp);
			return strTemp;
			break;

        default:
            Panic0("CMmFilterHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CMmFilterHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmFilterHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_FILTER]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_FILTER][nColumn];

	hr = m_spSpdInfo->SortMmFilters(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmFilterHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMmFilterHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}


/*!--------------------------------------------------------------------------
    CMmFilterHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CMmFilterHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmFilterHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CMmFilterHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmFilterHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CMmFilterHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetMmFilterCount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmFilterHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmFilterHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmfltrpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "mmfltrpp.h"
#include "mmauthpp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CMmFilterProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMmFilterProperties::CMmFilterProperties
(
    ITFSNode *				pNode,
    IComponentData *		pComponentData,
    ITFSComponentData *		pTFSCompData,
	CMmFilterInfo *	pFilterInfo,
    ISpdInfo *				pSpdInfo,
    LPCTSTR					pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pageAuth);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_FltrInfo = *pFilterInfo;
	
	//$REVIEW there is very remote possibility that this routin will fail:
	m_spSpdInfo->GetMmAuthMethodsInfoByGuid(m_FltrInfo.m_guidAuthID, &m_AuthMethods);
	m_pageAuth.InitData(&m_AuthMethods);

	m_bTheme = TRUE;
}

CMmFilterProperties::~CMmFilterProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageAuth, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CMmFilterGenProp property page

IMPLEMENT_DYNCREATE(CMmFilterGenProp, CPropertyPageBase)

CMmFilterGenProp::CMmFilterGenProp() : CPropertyPageBase(CMmFilterGenProp::IDD)
{
    //{{AFX_DATA_INIT(CMmFilterGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMmFilterGenProp::~CMmFilterGenProp()
{
}

void CMmFilterGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMmFilterGenProp)
    DDX_Control(pDX, IDC_MM_LIST_SPECIFIC, m_listSpecificFilters);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMmFilterGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CMmFilterGenProp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMmFilterGenProp message handlers

BOOL CMmFilterGenProp::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
	PopulateFilterInfo();	
	LoadSpecificFilters();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CMmFilterGenProp::PopulateFilterInfo()
{
	CString st;
	CString stMask;
	
	CMmFilterProperties * pFltrProp;
	CMmFilterInfo * pFltrInfo;

	pFltrProp = (CMmFilterProperties *) GetHolder();
	Assert(pFltrProp);

	pFltrProp->GetFilterInfo(&pFltrInfo);

	int iIdAddr = IDC_MM_FLTR_SRC_ADDR;
	BOOL fUseEditForAddr = FALSE;
	BOOL fHideMask = FALSE;
	BOOL fDnsAddr = FALSE;
	switch (pFltrInfo->m_SrcAddr.AddrType)
	{
	case IP_ADDR_UNIQUE:
		if (IP_ADDRESS_ME == pFltrInfo->m_SrcAddr.uIpAddr)
		{
			st.LoadString(IDS_ADDR_ME);
			fHideMask = TRUE;
		}
		else
		{
			AddressToString(pFltrInfo->m_SrcAddr, &st, &fDnsAddr);
			if (fDnsAddr)
			{
				fUseEditForAddr = TRUE;
				fHideMask = TRUE;
			}
			else
			{
				stMask = c_szSingleAddressMask;
				IpToString(pFltrInfo->m_SrcAddr.uIpAddr, &st);
			}
		}

		break;

	case IP_ADDR_DNS_SERVER:
	case IP_ADDR_WINS_SERVER:
	case IP_ADDR_DHCP_SERVER:
	case IP_ADDR_DEFAULT_GATEWAY:
		AddressToString(pFltrInfo->m_SrcAddr, &st);
		break;

	case IP_ADDR_SUBNET:
		if (SUBNET_ADDRESS_ANY == pFltrInfo->m_SrcAddr.uSubNetMask)
		{
			st.LoadString(IDS_ADDR_ANY);
			fHideMask = TRUE;
		}
		else
		{
			IpToString(pFltrInfo->m_SrcAddr.uIpAddr, &st);
			
			IpToString(pFltrInfo->m_SrcAddr.uSubNetMask, &stMask);
		}
		break;
	}

	if (fHideMask)
	{
		GetDlgItem(IDC_MM_FLTR_SRC_MASK)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_MM_STATIC_SRC_MASK)->ShowWindow(SW_HIDE);
	}
	else
	{
		GetDlgItem(IDC_MM_FLTR_SRC_MASK)->SetWindowText(stMask);
	}

	if (fUseEditForAddr)
	{
		iIdAddr = IDC_MM_FLTR_SRC_ADDR_EDIT;
		GetDlgItem(IDC_MM_FLTR_SRC_ADDR)->ShowWindow(SW_HIDE);
	}
	else
	{
		iIdAddr = IDC_MM_FLTR_SRC_ADDR;
		GetDlgItem(IDC_MM_FLTR_SRC_ADDR_EDIT)->ShowWindow(SW_HIDE);
	}

	GetDlgItem(iIdAddr)->SetWindowText(st);

	//now populate the destination info
	iIdAddr = IDC_MM_FLTR_DEST_ADDR;
	fUseEditForAddr = FALSE;
	fHideMask = FALSE;
	fDnsAddr = FALSE;
	st = _T("");
	stMask= _T("");

	switch (pFltrInfo->m_DesAddr.AddrType)
	{
	case IP_ADDR_UNIQUE:
		if (IP_ADDRESS_ME == pFltrInfo->m_DesAddr.uIpAddr)
		{
			st.LoadString(IDS_ADDR_ME);
			fHideMask = TRUE;
		}
		else
		{
			AddressToString(pFltrInfo->m_DesAddr, &st, &fDnsAddr);
			if (fDnsAddr)
			{
				fUseEditForAddr = TRUE;
				fHideMask = TRUE;
			}
			else
			{
				stMask = c_szSingleAddressMask;
				IpToString(pFltrInfo->m_DesAddr.uIpAddr, &st);
			}
		}
		break;

	case IP_ADDR_DNS_SERVER:
	case IP_ADDR_WINS_SERVER:
	case IP_ADDR_DHCP_SERVER:
	case IP_ADDR_DEFAULT_GATEWAY:
		AddressToString(pFltrInfo->m_DesAddr, &st);
		break;
    
	case IP_ADDR_SUBNET:
		if (SUBNET_ADDRESS_ANY == pFltrInfo->m_DesAddr.uSubNetMask)
		{
			st.LoadString(IDS_ADDR_ANY);
			fHideMask = TRUE;
		}
		else
		{
			IpToString(pFltrInfo->m_DesAddr.uIpAddr, &st);
			IpToString(pFltrInfo->m_DesAddr.uSubNetMask, &stMask);
		}
		break;
	}

	if (fHideMask)
	{
		GetDlgItem(IDC_MM_FLTR_DEST_MASK)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_MM_STATIC_DEST_MASK)->ShowWindow(SW_HIDE);
	}
	else
	{
		GetDlgItem(IDC_MM_FLTR_DEST_MASK)->SetWindowText(stMask);
	}

	if (fUseEditForAddr)
	{
		iIdAddr = IDC_MM_FLTR_DEST_ADDR_EDIT;
		GetDlgItem(IDC_MM_FLTR_DEST_ADDR)->ShowWindow(SW_HIDE);
	}
	else
	{
		iIdAddr = IDC_MM_FLTR_DEST_ADDR;
		GetDlgItem(IDC_MM_FLTR_DEST_ADDR_EDIT)->ShowWindow(SW_HIDE);
	}

	GetDlgItem(iIdAddr)->SetWindowText(st);
	//we are done with the destination address now

	InterfaceTypeToString(pFltrInfo->m_InterfaceType, &st);
	GetDlgItem(IDC_MM_FLTR_IF_TYPE)->SetWindowText(st);

	BoolToString(pFltrInfo->m_bCreateMirror, &st);
	GetDlgItem(IDC_MM_FLTR_MIRROR)->SetWindowText(st);

	SPISpdInfo spSpdInfo;
	pFltrProp->GetSpdInfo(&spSpdInfo);

	DWORD dwNumPol,dwIndex;
	st = pFltrInfo->m_stPolicyName;
	dwNumPol = spSpdInfo->GetMmPolicyCount();
	for(dwIndex=0; dwIndex<dwNumPol; dwIndex++)
	{
		CMmPolicyInfo MmPol;
	    if(ERROR_SUCCESS == spSpdInfo->GetMmPolicyInfo(dwIndex, &MmPol))
		{
			if(IsEqualGUID(MmPol.m_guidID, pFltrInfo->m_guidPolicyID) && 
				(MmPol.m_dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) )
			{
				AfxFormatString1(st, IDS_POL_DEFAULT, (LPCTSTR) pFltrInfo->m_stPolicyName);
				break;
			}
		}
	}
	
	GetDlgItem(IDC_MM_FLTR_POLICY)->SetWindowText(st);
}

void CMmFilterGenProp::LoadSpecificFilters()
{
	CMmFilterProperties * pFltrProp;
	CMmFilterInfo * pFltrInfo;
	CMmFilterInfoArray arraySpFilters;
	
	int nWidth;
	int nRows;
	CString st;


	pFltrProp = (CMmFilterProperties *) GetHolder();

	SPISpdInfo		spSpdInfo;
	pFltrProp->GetSpdInfo(&spSpdInfo);

	pFltrProp->GetFilterInfo(&pFltrInfo);
	spSpdInfo->EnumMmSpecificFilters(
					&pFltrInfo->m_guidFltr,
					&arraySpFilters
					);

	
	nWidth = m_listSpecificFilters.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_FILTER_PP_COL_SRC);
	m_listSpecificFilters.InsertColumn(0, st,  LVCFMT_LEFT, nWidth);

	nWidth = m_listSpecificFilters.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_FILTER_PP_COL_DEST);
	m_listSpecificFilters.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTR_DIR_OUT);
	nWidth = m_listSpecificFilters.GetStringWidth((LPCTSTR)st) + 20;
	st.LoadString(IDS_FILTER_PP_COL_DIRECTION);
	m_listSpecificFilters.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_WEIGHT);
	nWidth = m_listSpecificFilters.GetStringWidth((LPCTSTR)st) + 20;
	m_listSpecificFilters.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);
	
	nRows = 0;
	for (int i = 0; i < arraySpFilters.GetSize(); i++)
	{
		nRows = m_listSpecificFilters.InsertItem(nRows, _T(""));
		if (-1 != nRows)
		{
			AddressToString(arraySpFilters[i]->m_SrcAddr, &st);
			m_listSpecificFilters.SetItemText(nRows, 0, st);

			AddressToString(arraySpFilters[i]->m_DesAddr, &st);
			m_listSpecificFilters.SetItemText(nRows, 1, st);

			DirectionToString(arraySpFilters[i]->m_dwDirection, &st);
			m_listSpecificFilters.SetItemText(nRows, 2, st);

			st.Format(_T("%d"), arraySpFilters[i]->m_dwWeight);
			m_listSpecificFilters.SetItemText(nRows, 3, st);

			m_listSpecificFilters.SetItemData(nRows, i);
		}
		nRows++;
	}

	::FreeItemsAndEmptyArray(arraySpFilters);

    if ( nRows > 0 )
    {
        //select the first item
        m_listSpecificFilters.SetFocus();
        m_listSpecificFilters.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }

}

BOOL CMmFilterGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//TODO
	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CMmFilterGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmfltr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _MMFLTR_H
#define _MMFLTR_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CMmFilterHandler
 ---------------------------------------------------------------------------*/
class CMmFilterHandler : public CIpsmHandler
{
public:
    CMmFilterHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CMmFilterHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmFilterNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmfltrpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#include "MmAuthPp.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CMmFilterGenProp dialog

class CMmFilterGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CMmFilterGenProp)

// Construction
public:
    CMmFilterGenProp();
    ~CMmFilterGenProp();

// Dialog Data
    //{{AFX_DATA(CMmFilterGenProp)
    enum { IDD = IDP_MM_FILTER_GENERAL };
    CListCtrl	m_listSpecificFilters;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() 
	{ 
		return (DWORD *) &g_aHelpIDs_IDP_MM_FILTER_GENERAL[0]; 
	}


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMmFilterGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMmFilterGenProp)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void LoadSpecificFilters();
	void PopulateFilterInfo();
};


class CMmFilterProperties : public CPropertyPageHolderBase
{
    friend class CMmFilterGenProp;

public:
    CMmFilterProperties(ITFSNode *    pNode,
                      IComponentData *		pComponentData,
                      ITFSComponentData *	pTFSCompData,
                      CMmFilterInfo * pFltrInfo,
					  ISpdInfo *			pSpdInfo,
                      LPCTSTR				pszSheetName);
    virtual ~CMmFilterProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetFilterInfo(CMmFilterInfo **ppFltrInfo)
	{
		Assert(ppFltrInfo);
		*ppFltrInfo = &m_FltrInfo;
		return hrOK;
	}

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }



public:
    CMmFilterGenProp	m_pageGeneral;
	CAuthGenPage		m_pageAuth;

protected:
	SPITFSComponentData    m_spTFSCompData;
	CMmFilterInfo		   m_FltrInfo;
	CMmAuthMethods		   m_AuthMethods;
	SPISpdInfo             m_spSpdInfo;
    
    BOOL                   m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmpol.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Main Mode Policy node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "MmPol.h"
#include "MmPolpp.h"
#include "SpdUtil.h"


/*---------------------------------------------------------------------------
    Class CMmPolicyHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CMmPolicyHandler::CMmPolicyHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CMmPolicyHandler::~CMmPolicyHandler()
{
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmPolicyHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_MM_POL_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_MM_POLICY);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_MM_POLICY][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_MM_POLICY][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CMmPolicyHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmPolicyHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmPolicyHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

	CORg(m_spSpdInfo->EnumMmPolicies());
        
    i = m_spSpdInfo->GetMmPolicyCount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));
    
Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpSA != NULL);

    //return pServerProp->CreateModelessSheet(lpSA, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;


    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_MM_POLICY)) {
            CORg(m_spSpdInfo->EnumMmPolicies());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_POLICY);
        }
        m_spSpdInfo->SetActiveInfo(MON_MM_POLICY);

        // Get the current count
        i = m_spSpdInfo->GetMmPolicyCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 

		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_POLICY_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CMmPolicyHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;

	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CMmPolicyInfo PolInfo;
	CMmPolicyProperties * pMmPolProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetMmPolicyInfo(nIndex, &PolInfo));

	pMmPolProp = new CMmPolicyProperties(
												spNode,
												spComponentData,
												m_spTFSCompData,
												&PolInfo,
												m_spSpdInfo,
												NULL);

	hr = pMmPolProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmPolicyHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_POLICY;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CMmPolicyHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_POLICY]))
		return NULL;
	
	CMmPolicyInfo MmPol;
	CORg(m_spSpdInfo->GetMmPolicyInfo(nIndex, &MmPol));

    switch (aColumns[IPSECMON_MM_POLICY][nCol])
    {
        case IDS_COL_MM_POL_NAME:
			if( MmPol.m_dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) {
				 AfxFormatString1(strTemp, IDS_POL_DEFAULT, (LPCTSTR) MmPol.m_stName);
			} else {
                 strTemp = MmPol.m_stName;
			}
			return strTemp;
            break;

        case IDS_COL_MM_POL_OFFER:
			strTemp.Format(_T("%d"), MmPol.m_dwOfferCount);
			return strTemp;
            break;

        default:
            Panic0("CMmPolicyHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CMmPolicyHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmPolicyHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_POLICY]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_POLICY][nColumn];

	hr = m_spSpdInfo->SortMmPolicies(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmPolicyHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMmPolicyHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CMmPolicyHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CMmPolicyHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmPolicyHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CMmPolicyHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmPolicyHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CMmPolicyHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetMmPolicyCount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmPolicyHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmPolicyHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmpolpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "mmpolpp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CMmPolicyProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMmPolicyProperties::CMmPolicyProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
	CMmPolicyInfo *		pPolInfo,
    ISpdInfo *          pSpdInfo,
    LPCTSTR             pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_PolInfo = *pPolInfo;

	m_bTheme = TRUE;

}

CMmPolicyProperties::~CMmPolicyProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CMmPolGenProp property page

IMPLEMENT_DYNCREATE(CMmPolGenProp, CPropertyPageBase)

CMmPolGenProp::CMmPolGenProp() : CPropertyPageBase(CMmPolGenProp::IDD)
{
    //{{AFX_DATA_INIT(CMmPolGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMmPolGenProp::~CMmPolGenProp()
{
}

void CMmPolGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMmPolGenProp)
    DDX_Control(pDX, IDC_MM_POL_GEN_LIST, m_listOffers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMmPolGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CMmPolGenProp)
	ON_BN_CLICKED(IDC_MM_POL_GEN_PROP, OnProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMmPolGenProp message handlers

BOOL CMmPolGenProp::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
	PopulateOfferInfo();	

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CMmPolGenProp::PopulateOfferInfo()
{
	CString st;
	int nRows;
	int nWidth;
	
	CMmPolicyProperties * pPolProp;
	CMmPolicyInfo * pPolInfo;

	pPolProp = (CMmPolicyProperties *) GetHolder();
	Assert(pPolProp);

	pPolProp->GetPolicyInfo(&pPolInfo);

	ListView_SetExtendedListViewStyle(m_listOffers.GetSafeHwnd(),
                                      LVS_EX_FULLROWSELECT);

	st.LoadString(IDS_MM_POL_GEN_ENCRYPTION);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(0, st, LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_MM_POL_GEN_AUTH);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_MM_POL_GEN_DH);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_MM_POL_GEN_QMLMT);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_MM_POL_GEN_KEY_LIFE);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(4, st,  LVCFMT_LEFT, nWidth);

	nRows = 0;
	for (int i = 0; i < (int)pPolInfo->m_dwOfferCount; i++)
	{
		nRows = m_listOffers.InsertItem(nRows, _T(""));

		if (-1 != nRows)
		{
			DoiEspAlgorithmToString(pPolInfo->m_arrOffers[i]->m_EncryptionAlgorithm, &st);
			m_listOffers.SetItemText(nRows, 0, st);

			DoiAuthAlgorithmToString(pPolInfo->m_arrOffers[i]->m_HashingAlgorithm, &st);
			m_listOffers.SetItemText(nRows, 1, st);

			DhGroupToString(pPolInfo->m_arrOffers[i]->m_dwDHGroup, &st);
			m_listOffers.SetItemText(nRows, 2, st);

			st.Format(_T("%d"), pPolInfo->m_arrOffers[i]->m_dwQuickModeLimit);
			m_listOffers.SetItemText(nRows, 3, st);

			KeyLifetimeToString(pPolInfo->m_arrOffers[i]->m_Lifetime, &st);
			m_listOffers.SetItemText(nRows, 4, st);
		}

		nRows++;
	}

    if ( nRows > 0 )
    {
        //select the first item
        m_listOffers.SetFocus();
        m_listOffers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }
}


void CMmPolGenProp::OnProperties() 
{
	CMmPolicyInfo * pPolInfo;

	CMmPolicyProperties * pPolProp;
	pPolProp = (CMmPolicyProperties *) GetHolder();
	Assert(pPolProp);

	pPolProp->GetPolicyInfo(&pPolInfo);

	int nIndex = m_listOffers.GetNextItem(-1, LVNI_SELECTED);

	if (-1 != nIndex)
	{
/*
		CMmOfferProperties dlgOfferProp(pPolInfo->m_arrOffers[nIndex], IDS_MM_OFFER_PROP);

		dlgOfferProp.DoModal();
*/
	}
}

BOOL CMmPolGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CMmPolGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmpol.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _MMPOLNODE_H
#define _MMPOLNODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CMmPolicyHandler
 ---------------------------------------------------------------------------*/
class CMmPolicyHandler : public CIpsmHandler
{
public:
    CMmPolicyHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CMmPolicyHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
	
    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmPolicyNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmsa.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _MMSA_H
#define _MMSA_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CMmSAHandler
 ---------------------------------------------------------------------------*/
class CMmSAHandler : public CIpsmHandler
{
public:
    CMmSAHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CMmSAHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmSANodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmsapp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_MMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_)
#define AFX_MMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CMmSAGenProp dialog

class CMmSAGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CMmSAGenProp)

// Construction
public:
    CMmSAGenProp();
    ~CMmSAGenProp();

// Dialog Data
    //{{AFX_DATA(CMmSAGenProp)
    enum { IDD = IDP_MM_SA_GENERAL };
    CListCtrl	m_listQmSAs;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() 
	{ 
		return (DWORD *) &g_aHelpIDs_IDP_MM_SA_GENERAL[0]; 
	}


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMmSAGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMmSAGenProp)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void LoadQmSAs();
	void PopulateSAInfo();
};


class CMmSAProperties : public CPropertyPageHolderBase
{
    friend class CMmSAGenProp;

public:
    CMmSAProperties(ITFSNode *    pNode,
                      IComponentData *		pComponentData,
                      ITFSComponentData *	pTFSCompData,
                      CMmSA *				pSA,
					  ISpdInfo *			pSpdInfo,
                      LPCTSTR				pszSheetName);
    virtual ~CMmSAProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetSAInfo(CMmSA ** ppSA)
	{
		Assert(ppSA);
		*ppSA = &m_SA;
		return hrOK;
	}

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }



public:
    CMmSAGenProp			   m_pageGeneral;

protected:
	SPITFSComponentData     m_spTFSCompData;
	CMmSA					m_SA;
	SPISpdInfo				m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_MMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmpolpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358B__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358B__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CMmPolGenProp dialog

class CMmPolGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CMmPolGenProp)

// Construction
public:
    CMmPolGenProp();
    ~CMmPolGenProp();

// Dialog Data
    //{{AFX_DATA(CMmPolGenProp)
    enum { IDD = IDP_MM_POLICY_GENERAL };
    CListCtrl	m_listOffers;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDP_MM_POLICY_GENERAL[0]; }


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMmPolGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMmPolGenProp)
    virtual BOOL OnInitDialog();
	afx_msg void OnProperties();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void PopulateOfferInfo();
};


class CMmPolicyProperties : public CPropertyPageHolderBase
{
    friend class CMmPolGenProp;

public:
    CMmPolicyProperties(ITFSNode *         pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      CMmPolicyInfo * pFltrInfo,
					  ISpdInfo *          pSpdInfo,
                      LPCTSTR             pszSheetName);
    virtual ~CMmPolicyProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetPolicyInfo(CMmPolicyInfo **ppPolInfo)
	{
		Assert(ppPolInfo);
		*ppPolInfo = &m_PolInfo;
		return hrOK;
	}


public:
    CMmPolGenProp			   m_pageGeneral;

protected:
	SPITFSComponentData     m_spTFSCompData;
	CMmPolicyInfo			m_PolInfo;
	SPISpdInfo				m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmsa.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Main Mode SA node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "MmSA.h"
#include "MmSApp.h"
#include "SpdUtil.h"

/*---------------------------------------------------------------------------
    Class CMmSAHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CMmSAHandler::CMmSAHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CMmSAHandler::~CMmSAHandler()
{
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSAHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_MM_SA_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_MM_SA);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_MM_SA][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_MM_SA][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CMmSAHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmSAHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmSAHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSAHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

	CORg(m_spSpdInfo->EnumMmSAs());
        
    i = m_spSpdInfo->GetMmSACount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));
    
Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //handle the scope context menu commands here
    return S_OK;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {

        DWORD dwInitInfo;
        
        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_MM_SA)) {
            CORg(m_spSpdInfo->EnumMmSAs());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_SA);
        }
        m_spSpdInfo->SetActiveInfo(MON_MM_SA);

        // Get the current count
        i = m_spSpdInfo->GetMmSACount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) );
		
		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_SA_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CMmSAHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;

	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CMmSA sa;
	CMmSAProperties * pProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetMmSAInfo(nIndex, &sa));

	pProp = new CMmSAProperties(
									spNode,
									spComponentData,
									m_spTFSCompData,
									&sa,
									m_spSpdInfo,
									NULL);

	hr = pProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CMmSAHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmSAHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CMmSAHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_SA]))
		return NULL;

	CMmSA sa;
	CORg(m_spSpdInfo->GetMmSAInfo(nIndex, &sa));

    switch (aColumns[IPSECMON_MM_SA][nCol])
    {
	case IDS_COL_MM_SA_ME:
		AddressToString(sa.m_MeAddr, &strTemp);
		return strTemp;
		break;

	case IDS_COL_MM_SA_PEER:
		AddressToString(sa.m_PeerAddr, &strTemp);
		return strTemp;
		break;

    case IDS_COL_MM_SA_MYID:
        strTemp = sa.m_stMyId;
        return strTemp;
        break;

    case IDS_COL_MM_SA_PEERID:
        strTemp = sa.m_stPeerId;
        return strTemp;
        break;

	case IDS_COL_MM_SA_AUTH:
		MmAuthToString(sa.m_Auth, &strTemp);
		return strTemp;
		break;

	case IDS_COL_MM_SA_ENCRYPITON:
		DoiEspAlgorithmToString(sa.m_SelectedOffer.m_EncryptionAlgorithm, &strTemp);
		return strTemp;
		break;

	case IDS_COL_MM_SA_INTEGRITY:
		DoiAuthAlgorithmToString(sa.m_SelectedOffer.m_HashingAlgorithm, &strTemp);
		return strTemp;
		break;

	case IDS_COL_MM_SA_DH:
		DhGroupToString(sa.m_SelectedOffer.m_dwDHGroup, &strTemp);
		return strTemp;
		break;

    default:
        Panic0("CMmSAHandler::GetVirtualString - Unknown column!\n");
        break;
    }

COM_PROTECT_ERROR_LABEL;

    return NULL;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CMmSAHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSAHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_SA]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_SA][nColumn];

	m_spSpdInfo->SortMmSAs(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CMmSAHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMmSAHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CMmSAHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CMmSAHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSAHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CMmSAHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSAHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CMmSAHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetMmSACount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmSAHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSAHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmsapp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "mmsapp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CMmSAProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMmSAProperties::CMmSAProperties
(
    ITFSNode *				pNode,
    IComponentData *		pComponentData,
    ITFSComponentData *		pTFSCompData,
	CMmSA *					pSA,
    ISpdInfo *				pSpdInfo,
    LPCTSTR					pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_SA = *pSA;

	m_bTheme = TRUE;

}

CMmSAProperties::~CMmSAProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CMmSAGenProp property page

IMPLEMENT_DYNCREATE(CMmSAGenProp, CPropertyPageBase)

CMmSAGenProp::CMmSAGenProp() : CPropertyPageBase(CMmSAGenProp::IDD)
{
    //{{AFX_DATA_INIT(CMmSAGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMmSAGenProp::~CMmSAGenProp()
{
}

void CMmSAGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMmSAGenProp)
    DDX_Control(pDX, IDC_MMSA_LIST_QM, m_listQmSAs);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMmSAGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CMmSAGenProp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMmSAGenProp message handlers

BOOL CMmSAGenProp::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
	PopulateSAInfo();	
	LoadQmSAs();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CMmSAGenProp::PopulateSAInfo()
{
	CString st;
	
	CMmSAProperties * pSAProp;
	CMmSA	*	pSA;
	CMmFilterInfo * pFltrInfo;

	pSAProp = (CMmSAProperties *) GetHolder();
	Assert(pSAProp);

	pSAProp->GetSAInfo(&pSA);

	AddressToString(pSA->m_MeAddr, &st);
	GetDlgItem(IDC_MMSA_ME)->SetWindowText(st);

	AddressToString(pSA->m_PeerAddr, &st);
	GetDlgItem(IDC_MMSA_PEER)->SetWindowText(st);

	MmAuthToString(pSA->m_Auth, &st);
	GetDlgItem(IDC_MMSA_AUTH)->SetWindowText(st);

    st = pSA->m_stPolicyName;
    if ( pSA->m_dwPolFlags & IPSEC_MM_POLICY_DEFAULT_POLICY )
	{
		AfxFormatString1(st, IDS_POL_DEFAULT, (LPCTSTR) pSA->m_stPolicyName);
    }
	GetDlgItem(IDC_MMSA_IKE_POL)->SetWindowText(st);

	DoiEspAlgorithmToString(pSA->m_SelectedOffer.m_EncryptionAlgorithm, &st);
	GetDlgItem(IDC_MMSA_CONF)->SetWindowText(st);

	DoiAuthAlgorithmToString(pSA->m_SelectedOffer.m_HashingAlgorithm, &st);
	GetDlgItem(IDC_MMSA_INTEG)->SetWindowText(st);

	DhGroupToString(pSA->m_SelectedOffer.m_dwDHGroup, &st);
	GetDlgItem(IDC_MMSA_DH_GRP)->SetWindowText(st);

	KeyLifetimeToString(pSA->m_SelectedOffer.m_Lifetime, &st);
	GetDlgItem(IDC_MMSA_KEYLIFE)->SetWindowText(st);

}

void CMmSAGenProp::LoadQmSAs()
{
	int nWidth;
	CString st;
	
	st.LoadString(IDS_COL_QM_SA_SRC);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(0, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_DEST);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_SRC_PORT);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_DES_PORT);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_PROT);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(4, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_POL);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(5, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_AUTH);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(6, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_CONF);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(7, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_INTEGRITY);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(8, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_MY_TNL);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(9, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_QM_SA_PEER_TNL);
	nWidth = m_listQmSAs.GetStringWidth((LPCTSTR)st) + 20;
	m_listQmSAs.InsertColumn(10, st,  LVCFMT_LEFT, nWidth);

	CMmSAProperties * pSAProp;
	CMmSA	*	pSA;

	pSAProp = (CMmSAProperties *) GetHolder();
	Assert(pSAProp);

	pSAProp->GetSAInfo(&pSA);

	SPISpdInfo spSpdInfo;
	pSAProp->GetSpdInfo(&spSpdInfo);

	CQmSAArray arrQmSAs;
	spSpdInfo->EnumQmSAsFromMmSA(*pSA, &arrQmSAs);

	int nRows = 0;
	for (int i = 0; i < arrQmSAs.GetSize(); i++)
	{
		nRows = m_listQmSAs.InsertItem(nRows, _T(""));

		if (-1 != nRows)
		{
			AddressToString(arrQmSAs[i]->m_QmDriverFilter.m_SrcAddr, &st);
			m_listQmSAs.SetItemText(nRows, 0, st);

			AddressToString(arrQmSAs[i]->m_QmDriverFilter.m_DesAddr, &st);
			m_listQmSAs.SetItemText(nRows, 1, st);

			PortToString(arrQmSAs[i]->m_QmDriverFilter.m_SrcPort, &st);
			m_listQmSAs.SetItemText(nRows, 2, st);

			PortToString(arrQmSAs[i]->m_QmDriverFilter.m_DesPort, &st);
			m_listQmSAs.SetItemText(nRows, 3, st);

			ProtocolToString(arrQmSAs[i]->m_QmDriverFilter.m_Protocol, &st);
			m_listQmSAs.SetItemText(nRows, 4, st);

			st = arrQmSAs[i]->m_stPolicyName;
            if ( arrQmSAs[i]->m_dwPolFlags & IPSEC_QM_POLICY_DEFAULT_POLICY )
            {
                AfxFormatString1(st, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) arrQmSAs[i]->m_stPolicyName);
            }
			m_listQmSAs.SetItemText(nRows, 5, st);

			QmAlgorithmToString(QM_ALGO_AUTH, &arrQmSAs[i]->m_SelectedOffer, &st);
			m_listQmSAs.SetItemText(nRows, 6, st);

			QmAlgorithmToString(QM_ALGO_ESP_CONF, &arrQmSAs[i]->m_SelectedOffer, &st);
			m_listQmSAs.SetItemText(nRows, 7, st);

			QmAlgorithmToString(QM_ALGO_ESP_INTEG, &arrQmSAs[i]->m_SelectedOffer, &st);
			m_listQmSAs.SetItemText(nRows, 8, st);

			TnlEpToString(arrQmSAs[i]->m_QmDriverFilter.m_Type, 
						arrQmSAs[i]->m_QmDriverFilter.m_MyTunnelEndpt, 
						&st);
			m_listQmSAs.SetItemText(nRows, 9, st);

			TnlEpToString(arrQmSAs[i]->m_QmDriverFilter.m_Type, 
						arrQmSAs[i]->m_QmDriverFilter.m_PeerTunnelEndpt, 
						&st);
			m_listQmSAs.SetItemText(nRows, 10, st);
		}

		nRows++;
	}

    if ( nRows > 0 )
    {
        //select the first item
        m_listQmSAs.SetFocus();
        m_listQmSAs.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }

	FreeItemsAndEmptyArray(arrQmSAs);
}

BOOL CMmSAGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//TODO
	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CMmSAGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmspfltr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Filter node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "MmSpFltr.h"
#include "SpdUtil.h"


/*---------------------------------------------------------------------------
    Class CMmSpFilterHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CMmSpFilterHandler::CMmSpFilterHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData),
	m_pDlgSrchFltr(NULL)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CMmSpFilterHandler::~CMmSpFilterHandler()
{
	if (m_pDlgSrchFltr)
	{
		WaitForModelessDlgClose(m_pDlgSrchFltr);
		delete m_pDlgSrchFltr; //this will also close the window
	}
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSpFilterHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_MM_SP_FILTER_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_MM_SP_FILTER);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_MM_SP_FILTER][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_MM_SP_FILTER][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CMmSpFilterHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmSpFilterHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_MM_FLTR_SEARCH);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_MM_FLTR_SEARCH,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     0 );
            ASSERT( SUCCEEDED(hr) );

        }
        
    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSpFilterHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    CORg(m_spSpdInfo->EnumMmFilters());
    
    i = m_spSpdInfo->GetMmSpecificFilterCount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));

Error:
	return hr;
}


/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
	CThemeContextActivator m_activator;

	//handle the scope context menu commands here
	switch(nCommandId)
	{
	case IDS_MM_FLTR_SEARCH:

		
		if (NULL == m_pDlgSrchFltr)
		{
			m_pDlgSrchFltr = new CSearchMMFilters(m_spSpdInfo);
			Assert(m_pDlgSrchFltr);

			if (NULL == m_pDlgSrchFltr)
				break;
		}

		CreateModelessDlg(m_pDlgSrchFltr,
					   NULL,
					   IDD_MM_SRCH_FLTRS);
		break;

    }    

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hrFalse;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;
        
        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_MM_SP_FILTER)) {
            CORg(m_spSpdInfo->EnumMmFilters());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_SP_FILTER);
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_MM_FILTER);
            
        }
        m_spSpdInfo->SetActiveInfo(MON_MM_SP_FILTER);


        // Get the current count
        i = m_spSpdInfo->GetMmSpecificFilterCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
		
		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_SP_FILTER_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		m_verbDefault = MMC_VERB_NONE;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrFalse;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CMmSpFilterHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return hrFalse;
}


/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CMmSpFilterHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CMmSpFilterHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_SP_FILTER]))
		return NULL;
	
	CMmFilterInfo fltr;
	CORg(m_spSpdInfo->GetMmSpecificFilterInfo(nIndex, &fltr));

    switch (aColumns[IPSECMON_MM_SP_FILTER][nCol])
    {
        case IDS_COL_FLTR_NAME:
			strTemp = fltr.m_stName;
			return strTemp;
            break;

        case IDS_COL_FLTR_SRC:
			AddressToString(fltr.m_SrcAddr, &strTemp);
			return strTemp;
            break;

        case IDS_COL_FLTR_DEST:
			AddressToString(fltr.m_DesAddr, &strTemp);
			return strTemp;
            break;

		case IDS_COL_FLTR_DIR:
			DirectionToString(fltr.m_dwDirection, &strTemp);
			return strTemp;
			break;

		case IDS_COL_MM_FLTR_POL:
			{
				strTemp = fltr.m_stPolicyName;
				if( fltr.m_dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY )
				{
					AfxFormatString1(strTemp, IDS_POL_DEFAULT, (LPCTSTR) fltr.m_stPolicyName);
				}
					
				
				return strTemp;
				break;
			}

		case IDS_COL_MM_FLTR_AUTH:
			strTemp = fltr.m_stAuthDescription;
			return strTemp;
			break;

		case IDS_COL_FLTR_WEIGHT:
			strTemp.Format(_T("%d"), fltr.m_dwWeight);
			return strTemp;
			break;

        default:
            Panic0("CMmSpFilterHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMmSpFilterHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_SP_FILTER]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_SP_FILTER][nColumn];

	hr = m_spSpdInfo->SortMmSpecificFilters(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR

    return hr;
}

/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMmSpFilterHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}


/*!--------------------------------------------------------------------------
    CMmSpFilterHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CMmSpFilterHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmSpFilterHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CMmSpFilterHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSpFilterHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CMmSpFilterHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetMmSpecificFilterCount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CMmSpFilterHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmSpFilterHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\mmspfltr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _MMSPFLTR_H
#define _MMSPFLTR_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#include "SrchMFlt.h"

/*---------------------------------------------------------------------------
	Class:	CMmSpFilterHandler
 ---------------------------------------------------------------------------*/
class CMmSpFilterHandler : public CIpsmHandler
{
public:
    CMmSpFilterHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CMmSpFilterHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmFilterNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
	CSearchMMFilters *  m_pDlgSrchFltr;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\modenode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	ModeNode.cpp
		This file contains all of the "Main Mode" and "Quick Mode" 
		objects that appear in the scope pane of the MMC framework.
		The objects are:

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipsmhand.h"
#include "spddb.h"
#include "FltrNode.h"
#include "SFltNode.h"
#include "ModeNode.h"
#include "MmPol.h"
#include "QmPol.h"
#include "MmFltr.h"
#include "MmSpFltr.h"
#include "MmSA.h"
#include "QmSA.h"
#include "Stats.h"


/*---------------------------------------------------------------------------
    CQmNodeHandler::CQmNodeHandler
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CQmNodeHandler::CQmNodeHandler(ITFSComponentData *pCompData) : 
	CIpsmHandler(pCompData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
}

/*!--------------------------------------------------------------------------
    CQmNodeHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmNodeHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;
    strTemp.LoadString(IDS_QUICK_MODE_NODENAME);

    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
	pNode->SetData(TFS_DATA_TYPE, IPSECMON_QUICK_MODE);

    return hrOK;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    CQmNodeHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
/*
STDMETHODIMP_(LPCTSTR) 
CQmNodeHandler::GetString
(
    ITFSNode *  pNode, 
    int         nCol
)
{
	if (nCol == 0 || nCol == -1)
        return GetDisplayName();
    else
        return NULL;
}

*/

/*---------------------------------------------------------------------------
    CQmNodeHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmNodeHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

	int iVisibleCount = 0;
    int iTotalCount = 0;
	pNode->GetChildCount(&iVisibleCount, &iTotalCount);
	
	if (0 == iTotalCount)
	{
		{
		// add the filters node
		SPITFSNode spFilterNode;
		CFilterHandler * pFilterHandler = new CFilterHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spFilterNode,
							   &GUID_IpsmFilterNodeType,
							   pFilterHandler,
							   pFilterHandler,
							   m_spNodeMgr);
		pFilterHandler->InitData(m_spSpdInfo);
		pFilterHandler->InitializeNode(spFilterNode);
		pFilterHandler->Release();
		pNode->AddChild(spFilterNode);
		}

		{
		// add Specific filters node
		SPITFSNode spSpecificFilterNode;
		CSpecificFilterHandler * pSpecificFilterHandler = new CSpecificFilterHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spSpecificFilterNode,
							   &GUID_IpsmSpecificFilterNodeType,
							   pSpecificFilterHandler,
							   pSpecificFilterHandler,
							   m_spNodeMgr);
		pSpecificFilterHandler->InitData(m_spSpdInfo);
		pSpecificFilterHandler->InitializeNode(spSpecificFilterNode);
		pSpecificFilterHandler->Release();
		pNode->AddChild(spSpecificFilterNode);
		}

		{
		// add Quick mode policy node
		SPITFSNode spQmPolicyNode;
		CQmPolicyHandler * pQmPolicyHandler = new CQmPolicyHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spQmPolicyNode,
							   &GUID_IpsmQmPolicyNodeType,
							   pQmPolicyHandler,
							   pQmPolicyHandler,
							   m_spNodeMgr);
		pQmPolicyHandler->InitData(m_spSpdInfo);
		pQmPolicyHandler->InitializeNode(spQmPolicyNode);
		pQmPolicyHandler->Release();
		pNode->AddChild(spQmPolicyNode);
		}

		{
		// add the IPSEC stats node
		SPITFSNode spSANode;
		CIpsecStatsHandler *pIpsecHandler = new CIpsecStatsHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spSANode,
							   &GUID_IpsmMmIpsecStatsNodeType,
							   pIpsecHandler,
							   pIpsecHandler,
							   m_spNodeMgr);
		pIpsecHandler->InitData(m_spSpdInfo);
		pIpsecHandler->InitializeNode(spSANode);
		pIpsecHandler->Release();
		pNode->AddChild(spSANode);
		}

		{
		// add the SA node
		SPITFSNode spSANode;
		CQmSAHandler *pSAHandler = new CQmSAHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spSANode,
							   &GUID_IpsmQmSANodeType,
							   pSAHandler,
							   pSAHandler,
							   m_spNodeMgr);
		pSAHandler->InitData(m_spSpdInfo);
		pSAHandler->InitializeNode(spSANode);
		pSAHandler->Release();
		pNode->AddChild(spSANode);
		}
	}

    return hr;
}

/*---------------------------------------------------------------------------
    CQmNodeHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmNodeHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}

HRESULT 
CQmNodeHandler::UpdateStatus
(
	ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    Trace0("CQmNodeHandler::UpdateStatus");

	//We got a refresh notification from the background thread
	//The Mode node is just a container. Simply pass the update status
	//notification to the child nodes
    
	SPITFSNodeEnum      spNodeEnum;
    SPITFSNode          spCurrentNode;
    ULONG               nNumReturned;

	CORg(pNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		LONG_PTR dwDataType = spCurrentNode->GetData(TFS_DATA_TYPE);

		switch (dwDataType)
		{
			case IPSECMON_FILTER:
			{
				CFilterHandler * pFltrHandler = GETHANDLER(CFilterHandler, spCurrentNode);
				pFltrHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_SPECIFIC_FILTER:
			{
				CSpecificFilterHandler * pSpFilterHandler = GETHANDLER(CSpecificFilterHandler, spCurrentNode);
				pSpFilterHandler->UpdateStatus(spCurrentNode);
			}
			break;
			
 			case IPSECMON_QM_SA:
			{
				CQmSAHandler * pSaHandler = GETHANDLER(CQmSAHandler, spCurrentNode);
				pSaHandler->UpdateStatus(spCurrentNode);
			}
			break;

 			case IPSECMON_QM_POLICY:
			{
				CQmPolicyHandler * pQmPolHandler = GETHANDLER(CQmPolicyHandler, spCurrentNode);
				pQmPolHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_QM_IPSECSTATS:
			{
				CIpsecStatsHandler * pIpsecStatsHandler = GETHANDLER(CIpsecStatsHandler, spCurrentNode);
				pIpsecStatsHandler->UpdateStatus(spCurrentNode);
			}
			break;

			default:
				Trace0("CQmNodeHandler::UpdateStatus Unknow data type of the child node.");
			break;
		}
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	COM_PROTECT_ERROR_LABEL;

	return hr;
}

/*---------------------------------------------------------------------------
    CMmNodeHandler::CMmNodeHandler
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CMmNodeHandler::CMmNodeHandler(ITFSComponentData *pCompData) : 
	CIpsmHandler(pCompData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
}

/*!--------------------------------------------------------------------------
    CMmNodeHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmNodeHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;
    strTemp.LoadString(IDS_MAIN_MODE_NODENAME);

    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
	pNode->SetData(TFS_DATA_TYPE, IPSECMON_MAIN_MODE);

    return hrOK;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    CMmNodeHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMmNodeHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

	int iVisibleCount = 0;
    int iTotalCount = 0;
	pNode->GetChildCount(&iVisibleCount, &iTotalCount);
	
	if (0 == iTotalCount)
	{
		{
		// add the MM Filter node
		SPITFSNode spMmFltrNode;
		CMmFilterHandler * pMmFltrHandler = new CMmFilterHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spMmFltrNode,
							   &GUID_IpsmMmFilterNodeType,
							   pMmFltrHandler,
							   pMmFltrHandler,
							   m_spNodeMgr);
		pMmFltrHandler->InitData(m_spSpdInfo);
		pMmFltrHandler->InitializeNode(spMmFltrNode);
		pMmFltrHandler->Release();
		pNode->AddChild(spMmFltrNode);
		}

		{
		// add the MM Specific Filter node
		SPITFSNode spMmSpFltrNode;
		CMmSpFilterHandler * pMmSpFltrHandler = new CMmSpFilterHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spMmSpFltrNode,
							   &GUID_IpsmMmSpFilterNodeType,
							   pMmSpFltrHandler,
							   pMmSpFltrHandler,
							   m_spNodeMgr);
		pMmSpFltrHandler->InitData(m_spSpdInfo);
		pMmSpFltrHandler->InitializeNode(spMmSpFltrNode);
		pMmSpFltrHandler->Release();
		pNode->AddChild(spMmSpFltrNode);
		}

		{
		// add the MM Policy node
		SPITFSNode spMmPolNode;
		CMmPolicyHandler * pMmPolHandler = new CMmPolicyHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spMmPolNode,
							   &GUID_IpsmMmPolicyNodeType,
							   pMmPolHandler,
							   pMmPolHandler,
							   m_spNodeMgr);
		pMmPolHandler->InitData(m_spSpdInfo);
		pMmPolHandler->InitializeNode(spMmPolNode);
		pMmPolHandler->Release();
		pNode->AddChild(spMmPolNode);
		}

/* TODO completely remove auth node
		{
		// add the MM Auth node
		SPITFSNode spMmAuthNode;
		CMmAuthHandler * pMmAuthHandler = new CMmAuthHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spMmAuthNode,
							   &GUID_IpsmMmAuthNodeType,
							   pMmAuthHandler,
							   pMmAuthHandler,
							   m_spNodeMgr);
		pMmAuthHandler->InitData(m_spSpdInfo);
		pMmAuthHandler->InitializeNode(spMmAuthNode);
		pMmAuthHandler->Release();
		pNode->AddChild(spMmAuthNode);
		}
*/

		{
		// add the IKE stats node
		SPITFSNode spSANode;
		CIkeStatsHandler *pIkeHandler = new CIkeStatsHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spSANode,
							   &GUID_IpsmMmIkeStatsNodeType,
							   pIkeHandler,
							   pIkeHandler,
							   m_spNodeMgr);
		pIkeHandler->InitData(m_spSpdInfo);
		pIkeHandler->InitializeNode(spSANode);
		pIkeHandler->Release();
		pNode->AddChild(spSANode);
		}

		{
		// add the MM SA node
		SPITFSNode spMmSANode;
		CMmSAHandler * pMmSAHandler = new CMmSAHandler(m_spTFSCompData);
		CreateContainerTFSNode(&spMmSANode,
							   &GUID_IpsmMmSANodeType,
							   pMmSAHandler,
							   pMmSAHandler,
							   m_spNodeMgr);
		pMmSAHandler->InitData(m_spSpdInfo);
		pMmSAHandler->InitializeNode(spMmSANode);
		pMmSAHandler->Release();
		pNode->AddChild(spMmSANode);
		}

	}

    return hr;
}

/*---------------------------------------------------------------------------
    CMmNodeHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMmNodeHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}

HRESULT 
CMmNodeHandler::UpdateStatus
(
	ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    Trace0("CMmNodeHandler::UpdateStatus");

	//We got a refresh notification from the background thread
	//The Mode node is just a container. Simply pass the update status
	//notification to the child nodes
    
	SPITFSNodeEnum      spNodeEnum;
    SPITFSNode          spCurrentNode;
    ULONG               nNumReturned;

	CORg(pNode->GetEnum(&spNodeEnum));

	CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
	while (nNumReturned)
	{
		LONG_PTR dwDataType = spCurrentNode->GetData(TFS_DATA_TYPE);

		//update child nodes here
		switch (dwDataType)
		{
			//update child nodes here
			case IPSECMON_MM_POLICY:
			{
				CMmPolicyHandler * pMmPolHandler = GETHANDLER(CMmPolicyHandler, spCurrentNode);
				pMmPolHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_MM_FILTER:
			{
				CMmFilterHandler * pMmFltrHandler = GETHANDLER(CMmFilterHandler, spCurrentNode);
				pMmFltrHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_MM_SP_FILTER:
			{
				CMmSpFilterHandler * pMmSpFltrHandler = GETHANDLER(CMmSpFilterHandler, spCurrentNode);
				pMmSpFltrHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_MM_SA:
			{
				CMmSAHandler * pMmSaHandler = GETHANDLER(CMmSAHandler, spCurrentNode);
				pMmSaHandler->UpdateStatus(spCurrentNode);
			}
			break;

			case IPSECMON_MM_IKESTATS:
			{
				CIkeStatsHandler * pIkeStatsHandler = GETHANDLER(CIkeStatsHandler, spCurrentNode);
				pIkeStatsHandler->UpdateStatus(spCurrentNode);
			}
			break;

			default:
				Trace0("CMmNodeHandler::UpdateStatus Unknow data type of the child node.");
			break;

		}

		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	COM_PROTECT_ERROR_LABEL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmpol.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _QMPOLNODE_H
#define _QMPOLNODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CQmPolicyHandler
 ---------------------------------------------------------------------------*/
class CQmPolicyHandler : public CIpsmHandler
{
public:
    CQmPolicyHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CQmPolicyHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVER