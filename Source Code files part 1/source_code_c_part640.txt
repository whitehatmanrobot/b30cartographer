efault:
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                          _iNextState );

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            break;  // switch for wcEscape
        }

        default:
            iNext = _iNextState;

            Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                      _iNextState );

            //
            // In non-EGREP (DOS) syntax dot '.' is funny.  It will match
            // a dot, but if you're at the end of string it will also match
            // end.  So *.txt will look for strings with zero or more
            // characters followed by '.txt' but *. will find any names
            // without an extension and with no trailing dot.
            //

            if ( *wcs == wcDOSDot )
            {
                Get( iCurrent )->AddTransition( symEndLine, _iNextState );
            }

            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;
        }
    }

    //
    // non-EGREP (DOS) regex match entire string.
    //

    if ( wcHalt == 0 && *(wcs-1) != wcAnyMultiple )
    {
        iNext = _iNextState;
        Get( iCurrent )->AddTransition( symEndLine, _iNextState );
        iLocalStart = 0;
        wcsLocalStart = _wcsNull;
        _iNextState++;
        iCurrent = iNext;
    }

    //
    // If we haven't had an OR clause yet, then set iEnd
    //

    if ( *iEnd == 0 )
    {
        //
        // First part of OR clause.
        //

        *iEnd = Get( iCurrent )->StateNumber();
    }
    else
    {
        //
        // Subsequent OR clause.  Epsilon link to end
        //

        Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
    }

    if ( pwcsEnd )
    {
        *pwcsEnd = wcs + 1;             // Eat halt character.
    }

    if( *wcs != wcHalt )
    {
        throw ERROR_INVALID_PARAMETER;
    }
}

void CNFA::ParseRepeat( WCHAR const * & wcs, unsigned & cRepeat1, unsigned & cRepeat2 )
{
    cRepeat1 = 0;
    cRepeat2 = 0;

    for ( ; *wcs && isdigit(*wcs); wcs++ )
    {
        cRepeat1 *= 10;
        cRepeat1 += *wcs - '0';
    }

    if ( cRepeat1 == 0 || cRepeat1 > 255 )
    {
        throw ERROR_INVALID_PARAMETER;
    }

    if ( *wcs == ',' )
    {
        wcs++;

        if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
        {
            wcs++;
        }
        else
        {
            for ( ; *wcs && isdigit(*wcs); wcs++ )
            {
                cRepeat2 *= 10;
                cRepeat2 += *wcs - '0';
            }

            if ( cRepeat2 == 0 || cRepeat2 > 255 )
            {
               throw ERROR_INVALID_PARAMETER;
            }

            if ( *wcs != wcEscape || *(wcs+1) != wcEndRepeat )
            {
               throw ERROR_INVALID_PARAMETER;
            }
            else
            {
                wcs++;
            }
        }
    }
    else if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
    {
        wcs++;
        cRepeat2 = cRepeat1;
    }
    else
    {
        throw ERROR_INVALID_PARAMETER;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Constructs a DFA from a NFA.
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [fCaseSens] -- true if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( WCHAR const * pwcs, bool fCaseSens )
        : _nfa( pwcs, fCaseSens ),
          _xs( _nfa.NumStates() ),
          _cState( _nfa.NumStates() ),
          _pStateTrans( 0 ),
          _pStateFinal( 0 )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [fCaseSens] -- true if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( CDFA const & src )
        : _nfa( src._nfa ),
          _xs( src._nfa.NumStates() ),
          _cState( src._nfa.NumStates() ),
          _pStateTrans( 0 ),
          _pStateFinal( 0 )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CommonCtor, private
//
//  Synopsis:   Code common to both constructors.
//
//  History:    13-Jul-95 KyleP     Snarfed from constructor
//
//--------------------------------------------------------------------------

void CDFA::CommonCtor()
{
    //
    // Add initial state.
    //

    CStateSet ss;

    _nfa.EpsClosure( _nfa.StartState(), ss );

    _stateStart = _xs.XlatToOne( ss );

    //
    // Intialize translation table.
    //

    int cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

    _pStateTrans = new UINT [ cEntries ];
    _pStateFinal = new bool [ _cState + 1 ];

    memset( _pStateTrans, 0xFF, cEntries * sizeof(_pStateTrans[0]) );
    RtlZeroMemory( _pStateFinal, (_cState + 1) * sizeof(_pStateFinal[0]) );

    for ( int i = _cState; i >= 0; i-- )
    {
        AddTransition( i, 0, stateUndefined );
    }

    Add( _stateStart, _nfa.IsFinal( ss ) );


}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::~CDFA, public
//
//  Synopsis:   Clean up DFA.  Free state tables.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::~CDFA()
{
    delete _pStateTrans;
    delete _pStateFinal;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Recognize, public
//
//  Arguments:  [wcs] -- Input string.
//
//  Returns:    true if [wcs] is matched by the regular expression.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

bool CDFA::Recognize( WCHAR * wcs )
{
    //////////
    // Modified from original version to handle a NULL string.
    //////////
    if (!wcs) { return false; }

    UINT CurrentState     = _stateStart;
    UINT LastState        = CurrentState;
    bool fFinal        = IsFinal( CurrentState );
    WCHAR wcCurrent       = symBeginLine;

    while ( !fFinal )
    {
        UINT NextState = Move( CurrentState, wcCurrent );

        if ( NextState == stateUncomputed )
        {
            CStateSet ssCurrent;
            CStateSet ssNew;
            CStateSet ssClosed;

            _xs.XlatToMany( CurrentState, ssCurrent );

            _nfa.Move( ssCurrent, ssNew, wcCurrent );

            if ( ssNew.Count() == 0 )
            {
                NextState = stateUndefined;
                AddTransition( CurrentState, wcCurrent, NextState );
            }
            else
            {
                _nfa.EpsClosure( ssNew, ssClosed );

                NextState = _xs.XlatToOne( ssClosed );

                if ( !IsComputed( NextState ) )
                {
                    Add( NextState, _nfa.IsFinal( ssClosed ) );
                }

                AddTransition( CurrentState, wcCurrent, NextState );

            }

        }

        if ( NextState == stateUndefined )
        {
            return( false );
        }

        LastState    = CurrentState;
        CurrentState = NextState;

        fFinal =       IsFinal( CurrentState );


        //
        // If we ran out of string then just keep going, appending
        // end-of-string symbols.  Unfortunately the string is conceptually
        // a set of characters followed by an arbitrary number of
        // end-of-string symbols.  In non-EGREP the end-of-string symbol
        // may actually cause multiple state transitions before reaching
        // a final state.  In non-EGREP (DOS) mode we stop only when we
        // are no longer 'making progress' (moving to new states) on
        // end-of-string.  I haven't completely convinced myself this
        // algorithm is guaranteed to terminate.
        //

        if ( wcCurrent == symEndLine )
        {
            if ( LastState == CurrentState )
                break;
        }
        else
        {
            wcCurrent = *wcs++;

            //
            // After we've exhausted the string, append the special
            // end-of-line character.
            //

            if ( wcCurrent == 0 )
            {
                wcCurrent = symEndLine;
            }
            else
            {
                wcCurrent = (WCHAR)_nfa.Translate().Translate( wcCurrent );
            }
        }

    }

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Add, private
//
//  Synopsis:   Adds a new state the the DFA.
//
//  Arguments:  [state]  -- State number
//              [fFinal] -- true if state is a final state.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      All transitions for the new state are initially uncomputed.
//
//--------------------------------------------------------------------------

void CDFA::Add( UINT state, bool fFinal )
{
    if ( state > _cState )
    {
        //
        // Since the number of states required will probably grow at
        // a slow rate, increase the size of the array in a linear
        // fashion.

        UINT const DeltaState = 10;

        UINT *    oldStateTrans = _pStateTrans;
        bool * oldStateFinal = _pStateFinal;
        UINT      oldcState = _cState;
        UINT      oldcEntries = (_cState + 1) *
            ( _nfa.Translate().NumClasses() + 1 );

        _cState += DeltaState;
        UINT cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

        _pStateTrans = new UINT [ cEntries ];
        _pStateFinal = new bool [ _cState + 1 ];

        //
        // Initilize new state tables...
        //

        memcpy( _pStateTrans, oldStateTrans, oldcEntries * sizeof( UINT ) );
        memcpy( _pStateFinal, oldStateFinal, oldcState * sizeof( bool ) );

        memset( _pStateTrans + oldcEntries, 0xFF, (cEntries - oldcEntries)*sizeof(_pStateTrans[0]) );
        RtlZeroMemory( _pStateFinal + oldcState, (_cState + 1 - oldcState)*sizeof(_pStateFinal[0]) );


        for ( UINT i = _cState - DeltaState + 1; i <= _cState; i++ )
        {
            AddTransition( i, 0, stateUndefined );
        }

        //
        // ...and destroy the old
        //

        delete oldStateTrans;
        delete oldStateFinal;
    }

    //
    // All states are set to stateUncomputed above, except the 'undefined' flag-state.
    //

    AddTransition( state, 0, stateUncomputed );
    _pStateFinal[state] = fFinal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\regex\state.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       State.cxx
//
//  Contents:   Finite automata state classes
//
//  Classes:
//
//  History:    01-21-92  KyleP     Created
//              03-11-97  arunk     Modified for Kessel
//--------------------------------------------------------------------------


// Local includes:
#include <state.hxx>
#include <stateset.hxx>
#include <string.h>


//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::CNFAState, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CNFAState::CNFAState( CNFAState const & src )
        : CFAState( src ),
          _pmoveRest( 0 ),
          _cmoveRest( src._cmoveRest ),
          _cMove( src._cMove )
{
    if ( _cmoveRest > 0 )
    {
        _pmoveRest = new CMove [_cmoveRest];
      //  RtlCopyMemory( _pmoveRest, src._pmoveRest, _cmoveRest * sizeof(_pmoveRest[0]) );
      memcpy( _pmoveRest, src._pmoveRest, _cmoveRest * sizeof(_pmoveRest[0]) );
    }

    //RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
	memcpy( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Init, public
//
//  Synopsis:   Copy initializer
//
//  Arguments:  [src] -- Source
//
//  History:    15-Jul-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Init( CNFAState & src )
{
    CFAState::Init( src.StateNumber() );

    if ( src.IsFinal() )
        MakeFinal();

    _cMove = src._cMove;
    //RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
    memcpy( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
    _cmoveRest = src._cmoveRest;
    _pmoveRest = src._pmoveRest;

    src._cMove = 0;
    src._cmoveRest = 0;
    src._pmoveRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::operator =, public
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

inline void * operator new( size_t, CNFAState * pthis )
{
    return pthis;
}

#if  _MSC_VER >= 1200
inline void operator delete(void *, CNFAState*)
{ }
#endif

CNFAState & CNFAState::operator =( CNFAState const & src )
{
    CNFAState::~CNFAState();

    new (this) CNFAState( src );

    return *this;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::AddTransition, public
//
//  Synopsis:   Add new state transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::AddTransition( UINT symbol, UINT StateNum )
{
    //
    // First look for an exact match.  If this transition exists
    // then don't add it again.
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                return;
            }
        }
    }

    //
    // New transition.  Add it.
    //

    if ( _cMove < CNFAState_cFirst )
    {
        //
        // Fits in the first (object based) set of moves.
        //

        _moveFirst[_cMove] = CMove( symbol, StateNum );
    }
    else
    {
        //
        // Overflow set of moves.
        //

        if ( _cMove - CNFAState_cFirst >= _cmoveRest )
        {
            CMove * oldpmoveRest = _pmoveRest;
            UINT    oldcmoveRest = _cmoveRest;

            _cmoveRest = (_cmoveRest == 0) ? 2 : _cmoveRest + 5;

            _pmoveRest = (CMove *) new char [ _cmoveRest * sizeof( CMove ) ];

            memcpy( _pmoveRest, oldpmoveRest, oldcmoveRest * sizeof( CMove ) );
            delete oldpmoveRest;
        }

        _pmoveRest[_cMove - CNFAState_cFirst] = CMove( symbol, StateNum );
    }

    ++_cMove;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::RemoveTransition, public
//
//  Synopsis:   Removes a transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::RemoveTransition( UINT symbol, UINT StateNum )
{
    //
    // Find the transition
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            //
            // Move the last transition to this place.
            //

            if ( _cMove > CNFAState_cFirst )
            {
                _moveFirst[i] = _pmoveRest[_cMove - CNFAState_cFirst - 1];
            }
            else
            {
                _moveFirst[i] = _moveFirst[ _cMove - 1 ];
            }

            _cMove--;

            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                _pmoveRest[i] = _pmoveRest[ _cMove - CNFAState_cFirst - 1 ];

                _cMove--;

                return;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Move, public
//
//  Effects:    Adds to [ss] the set of states that can be reached from
//              this state on [symbol].
//
//  Arguments:  [ss]     -- Output state set.
//              [symbol] -- Input symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Move( CStateSet & ss, UINT symbol )
{
    for ( int i = (_cMove <= CNFAState_cFirst) ? _cMove-1 : CNFAState_cFirst-1;
            i >= 0;
            i--)
    {
        if ( _moveFirst[i]._symbol == symbol ||
             ( _moveFirst[i]._symbol == symAny &&
               symbol != symEpsilon ))
        {
            ss.Add( _moveFirst[i]._iState );
        }
    }

    for ( i = _cMove - CNFAState_cFirst - 1; i >= 0; i-- )
    {
        if ( _pmoveRest[i]._symbol == symbol ||
             ( _pmoveRest[i]._symbol == symAny &&
               symbol != symEpsilon &&
               symbol != symDot ))
        {
            ss.Add( _pmoveRest[i]._iState );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\regex\stateset.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       StateSet.cxx
//
//  Contents:
//
//  Classes:
//
//  History:    01-20-92  KyleP     Created
//              03-11-97  arunk     Modified for regex lib
//--------------------------------------------------------------------------

// Local includes:
#include <stateset.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Clear, public
//
//  Synopsis:   Re-initializes a state set to empty.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Clear()
{
    delete _puiRest;

    _cStates = 0;
    _cRest = 0;
    _puiRest = 0;
    _cuiRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Add, public
//
//  Synopsis:   Adds a state to the state set.
//
//  Arguments:  [state] -- State to add.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Add( UINT state )
{
    if ( IsMember( state ) )
        return;

    if ( _cStates < CStateSet_cFirst )
    {
        _auiFirst[ _cStates ] = state;
    }
    else
    {
        if ( _cRest >= _cuiRest )
        {
            UINT * oldpuiRest = _puiRest;
            UINT   oldcuiRest = _cuiRest;

            _cuiRest += 10;
            _puiRest = new UINT [ _cuiRest ];
            memcpy( _puiRest, oldpuiRest, oldcuiRest * sizeof( UINT ) );

            delete oldpuiRest;
        }

        _puiRest[ _cRest ] = state;
        ++_cRest;
    }

    ++_cStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::State, public
//
//  Arguments:  [iState] -- Index of state to return.
//
//  Returns:    The [iState] state in the state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CStateSet::State( UINT iState ) const
{
    if ( iState <= CStateSet_cFirst )
    {
        return( _auiFirst[ iState - 1 ] );
    }
    else
    {
        return( _puiRest[ iState - CStateSet_cFirst - 1 ] );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::IsMember, public
//
//  Arguments:  [state] -- State to look for.
//
//  Returns:    true if [state] is in set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CStateSet::IsMember( UINT state )
{
    if ( _cStates == 0 )
        return( false );

    //
    // Naive implementation.  As long as state sets are small this
    // will work fine.
    //

    for ( int i = min( _cStates, CStateSet_cFirst) - 1;
          i >= 0;
          i-- )
    {
        if( _auiFirst[ i ] == state )
            return( true );
    }

    if ( _cStates > CStateSet_cFirst )
    {
        for ( int i = _cStates - CStateSet_cFirst - 1;
              i >= 0;
              i-- )
        {
            if( _puiRest[ i ] == state )
                return( true );
        }
    }

    return( false );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\inc\factory.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Factory.h
//
// SYNOPSIS
//
//    This file declares the classes Factory and FactoryCache.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//    04/16/1998    Removed FactoryCache::theCache.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _FACTORY_H_
#define _FACTORY_H_

#include <guard.h>
#include <nocopy.h>
#include <set>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Factory
//
// DESCRIPTION
//
//    This class facilitates storing a (ProgID, IClassFactory) tuple in a
//    collection.  It is primarily for use by the FactoryCache, but it is
//    suitable for stand-alone use.
//
///////////////////////////////////////////////////////////////////////////////
class Factory
{
public:
   // Constructors.
   Factory(PCWSTR progID, IClassFactory* classFactory);
   Factory(const Factory& f);

   // Assignment operator.
   Factory& operator=(const Factory& f);

   // Destructor.
   ~Factory() throw ();

   // Create an object with the factory.
   void createInstance(IUnknown* pUnkOuter,
                       REFIID riid,
                       void** ppvObject) const
   {
      using _com_util::CheckError;
      CheckError(factory->CreateInstance(pUnkOuter, riid, ppvObject));
   }

   // Returns the factory for the class. Caller is responsible for releasing.
   IClassFactory* getFactory(IClassFactory** f) const throw ()
   {
      factory->AddRef();
      return factory;
   }

   // Returns the prog ID for the class.
   PCWSTR getProgID() const throw ()
   { return name; }

   /////////
   // Comparison operators to allow factories to be stored in collections.
   /////////

   bool operator<(const Factory& f) const throw ()
   { return wcscmp(name, f.name) < 0; }

   bool operator==(const Factory& f) const throw ()
   { return wcscmp(name, f.name) == 0; }

protected:
   PWSTR name;                       // The ProgID of the factory.
   mutable IClassFactory* factory;   // The class factory.
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    FactoryCache
//
// DESCRIPTION
//
//    This class maintains a cache of Class Factory objects. It is intended
//    for situations where large numbers of various object must be created
//    dynamically. Generally, there should be only one cache per process.
//
//    The class also has the concept of a default ProgID prefix. When an
//    object is created. The cache first checks for "defaultPrefix.ProgID".
//    If this fails, it then tries "ProgID".
//
///////////////////////////////////////////////////////////////////////////////
class FactoryCache
   : NonCopyable, Guardable
{
public:
   FactoryCache(PCWSTR defaultPrefix = NULL);
   ~FactoryCache() throw ();

   void clear() throw ();
   void createInstance(PCWSTR progID,
                       IUnknown* pUnkOuter,
                       REFIID riid,
                       void** ppvObject);

   // Returns the prefix for the cache. May be null.
   PCWSTR getPrefix() const throw ()
   { return prefix; }

protected:
   // Converts a progID to a class ID using the algorithm described above.
   void CLSIDFromProgID(PCWSTR progID, LPCLSID pclsid) const;

   std::set<Factory> factories;   // The cache of class factories.
   DWORD prefixLen;               // The length of the prefix in characters.
   PWSTR prefix;                  // The default prefix (may be NULL).
};

//////////
// The global factory cache.
//////////
extern FactoryCache theFactoryCache;

#endif  // _FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\regex\xlatchar.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       XlatChar.cxx
//
//  Contents:   Character translation class.
//
//  Classes:    CXlatChar
//
//  History:    02-13-92  KyleP     Created
//              03-11-97  arunk     Modified for regex lib
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <search.h>

// Local includes:
#include <XlatChar.hxx>

#define TOUPPER towupper


//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Initializes character mapping (no char classes).
//
//  Arguments:  [fCaseSens] -- true if case sensitive mapping.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( bool fCaseSens )
        : _cAllocation( 31 ),
          _cRange( 1 ),
          _iPrevRange( 0 ),
          _fCaseSens( fCaseSens )
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];

    *_pwcRangeEnd = (WCHAR)-1;  // Largest possible character.

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( CXlatChar const & src )
        : _cRange( src._cRange ),
          _cAllocation( src._cAllocation ),
          _iPrevRange( src._iPrevRange ),
          _fCaseSens( src._fCaseSens )
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    RtlCopyMemory( _pwcRangeEnd, src._pwcRangeEnd, _cAllocation*sizeof(_pwcRangeEnd[0]) );

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::AddRange, public
//
//  Synopsis:   Adds range as a new equivalance class.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

void CXlatChar::AddRange( WCHAR wcStart, WCHAR wcEnd )
{

    if ( !_fCaseSens )
    {
        wcStart = TOUPPER( wcStart );
        wcEnd = TOUPPER( wcEnd );
    }

    //
    // Make sure there's room for start and end of range in array.
    //

    if ( _cAllocation - _cRange < 2 )
        _Realloc();

    _pwcRangeEnd[_cRange++] = wcStart - 1;
    _pwcRangeEnd[_cRange++] = wcEnd;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Translate, public
//
//  Synopsis:   Maps character to its equivalence class.
//
//  Arguments:  [wc] -- Character to map.
//
//  Returns:    The equivalence class of character.
//
//  Algorithm:  Binary search array until the correct bin is found.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::Translate( WCHAR wc )
{

    if ( !_fCaseSens )
        wc = TOUPPER( wc );

    if ( wc == '.' )
        return( symDot );

    UINT i    = _cAllocation / 2;
    UINT step = (_cAllocation + 3) / 4;
    WCHAR wcCurrent = _pwcRangeEnd[i];

    while ( step != 0 )
    {
        if ( wcCurrent == wc )
        {
            break;
        }
        else if( wcCurrent < wc )
        {
            i += step;
        }
        else
        {
            i -= step;
        }

        step = step / 2;

        wcCurrent = _pwcRangeEnd[i];
    }

    //
    // If we can't go anywhere, then either i or i + 1 is correct.
    //

    if ( wcCurrent < wc )
    {
        i++;
    }

    return( i + 1 + cSpecialCharClasses );

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::TranslateRange, public
//
//  Synopsis:   Iterator mapping character range to set of equivalence
//              classes.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  Returns:    If [wcStart] is 0 then the next class in the most
//              recently specified range is returned.  Otherwise the
//              first class in the new range is returned.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::TranslateRange( WCHAR wcStart, WCHAR wcEnd )
{
    if ( !_fCaseSens )
    {
        wcStart = TOUPPER( wcStart );
        wcEnd = TOUPPER( wcEnd );
    }

    if ( wcStart > wcEnd )
    {
        throw ERROR_INVALID_PARAMETER;
    }

    if ( wcStart != 0 )
    {
        _iPrevRange = Translate( wcStart );

    }
    else
    {
        if ( _iPrevRange - cSpecialCharClasses >= _cRange )
        {
            return( 0 );
        }
        else
        {
            if ( _pwcRangeEnd[_iPrevRange-1-cSpecialCharClasses] >= wcEnd )
            {
                _iPrevRange = 0;
            }
            else
            {
                _iPrevRange++;
            }

        }
    }

    return( _iPrevRange );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Prepares class for translation.
//
//  Requires:   All equivalance classes must be added before prepare is
//              called.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

int _cdecl CompareFn( void const * Elt1, void const * Elt2 )
{
    return( *(WCHAR *)Elt1 - *(WCHAR *)Elt2 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Called after ranges added to prepare for searching.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::Prepare()
{
    //
    // Sort and then remove duplicates from the array.
    //

    qsort( _pwcRangeEnd, _cRange, sizeof( *_pwcRangeEnd ), CompareFn );

    UINT iGood, iCurrent;

    for ( iGood = 0, iCurrent = 1; iCurrent < _cRange; iCurrent++ )
    {
        if ( _pwcRangeEnd[iGood] != _pwcRangeEnd[iCurrent] )
        {
            _pwcRangeEnd[++iGood] = _pwcRangeEnd[iCurrent];
        }
    }

    _cRange = iGood + 1;

    //
    // Make all the extra entries at the end look like the maximum
    // possible character so the binary search works.
    //

    memset( _pwcRangeEnd + _cRange,
            0xFF,
            (_cAllocation - _cRange) * sizeof( WCHAR ) );


}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::_Realloc, private
//
//  Synopsis:   Grows the character array.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::_Realloc()
{
    WCHAR * oldRangeEnd = _pwcRangeEnd;
    UINT    oldcAllocation = _cAllocation;

    _cAllocation = (_cAllocation + 1) * 2 - 1;
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    memcpy( _pwcRangeEnd, oldRangeEnd, oldcAllocation * sizeof( WCHAR ) );
    delete oldRangeEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\regex\xlatstat.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       XlatStat.cxx
//
//  Contents:   State translation class.
//
//  Classes:    CXlatState
//
//  History:    01-20-92  KyleP     Created
//              03-11-97  arunk     Modified for regex lib
//
//--------------------------------------------------------------------------

// Local includes:
#include <xlatstat.hxx>
#include <stateset.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::CXlatState, public
//
//  Synopsis:   Initialize state translator (no states)
//
//  Arguments:  [MaxState] -- Largest ordinal of any state that may
//                            appear in an equivalence class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::CXlatState( UINT MaxState )
        : _cUsed( 0 ),
          _pulStates( 0 ),
          _cStates( 0 )
{
    //
    // Compute the number of DWords / state, assuring at least 1 dword is
    // always allocated.
    //

    _StateSize = (MaxState + sizeof(ULONG) * 8 ) / (sizeof( ULONG ) * 8);
    _Realloc();

};

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::~CXlatState, public
//
//  Synopsis:   Destroys class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::~CXlatState()
{
    delete _pulStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToOne, public
//
//  Synopsis:   Maps a state set to its single state equivalent. If
//              there is no mapping, then one is created.
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    The single state equivalent.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::XlatToOne( CStateSet const & ss )
{
    UINT state = _Search( ss );

    if ( state == 0 )
    {
        state = _Create( ss );
    }

    return( state );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToMany, public
//
//  Synopsis:   Maps a state to its matching state set.
//
//  Arguments:  [iState] -- State to map.
//              [ss]     -- On return contains the mapped state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::XlatToMany( UINT iState, CStateSet & ss )
{
    if ( iState <= _cUsed )
    {
       ULONG * pState = _pulStates + iState * _StateSize;

       for ( int i = _StateSize * sizeof(ULONG) * 8 - 1; i >= 0; i-- )
       {
           if ( pState[i / (sizeof(ULONG) * 8) ] &
                   ( 1L << i % (sizeof(ULONG) * 8 ) ) )
           {
               ss.Add( i+1 );
           }
       }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Search, private
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    Single state mapping for [ss] or 0 if none.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      The first state set is used as temp space.
//
//--------------------------------------------------------------------------

UINT CXlatState::_Search( CStateSet const & ss )
{
    memset( _pulStates, 0, _StateSize * sizeof(ULONG) );
    _BuildState( _pulStates, ss );

    UINT cState = 1;

    while ( cState <= _cUsed )
    {
        if ( memcmp( _pulStates + cState * _StateSize,
                     _pulStates,
                     _StateSize * sizeof(ULONG) ) == 0 )
        {
            return( cState );
        }
        else
        {
            ++cState;
        }
    }

    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Create, private
//
//  Synopsis:   Adds new state set to array.
//
//  Arguments:  [ss] -- State set to add.
//
//  Returns:    Single state mapping for [ss]
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::_Create( CStateSet const & ss )
{
    //
    // _cStates-1 because the first state is temp space.
    //

    if ( _cStates-1 == _cUsed )
        _Realloc();

    ++_cUsed;
    _BuildState( _pulStates + _cUsed * _StateSize, ss );

    return( _cUsed );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_BuildState, private
//
//  Synopsis:   Formats state set.
//
//  Arguments:  [ss]     -- Format state set...
//              [pState] --   into this memory.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::_BuildState( ULONG * pState, CStateSet const & ss )
{
    for ( UINT i = ss.Count(); i > 0; i-- )
    {
        UINT StateNum = ss.State( i ) - 1;
        pState[ StateNum / (sizeof(ULONG) * 8) ] |=
                1L << StateNum % (sizeof(ULONG) * 8);
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Realloc, private
//
//  Synopsis:   Grows state set array.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      Grows linearly, since the number of state sets is likely
//              to be small and we don't want to waste space.
//
//--------------------------------------------------------------------------

void CXlatState::_Realloc()
{
    UINT    oldcStates   = _cStates;
    ULONG * oldpulStates = _pulStates;

    _cStates += 10;
    _pulStates = new ULONG [ _cStates * _StateSize ];

    memcpy( _pulStates,
            oldpulStates,
            oldcStates * _StateSize * sizeof( ULONG ) );

    memset( _pulStates + oldcStates * _StateSize,
            0,
            (_cStates - oldcStates) * _StateSize * sizeof(ULONG) );

    delete [] oldpulStates;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\tree\buildtree.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    BuildTree.cpp
//
// SYNOPSIS
//
//    This file defines IASBuildExpression.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//    04/17/1998    Add Release in extractCondition to fix leak.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <BuildTree.h>
#include <Tokens.h>
#include <VarVec.h>

#include <new>

using _com_util::CheckError;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    extractCondition
//
// DESCRIPTION
//
//    Extracts an ICondition* from a VARIANT.
//
///////////////////////////////////////////////////////////////////////////////
inline ICondition* extractCondition(VARIANT* pv)
{
   ICondition* cond;
   IUnknown* unk = V_UNKNOWN(pv);

   if (unk)
   {
      CheckError(unk->QueryInterface(__uuidof(ICondition), (PVOID*)&cond));

      // We don't need to hold a reference since it's still in the VARIANT.
      cond->Release();
   }
   else
   {
      _com_issue_error(E_POINTER);
   }

   return cond;
}

//////////
// We'll use IAS_LOGICAL_NUM_TOKENS to indicate a condition token.
//////////
#define IAS_CONDITION IAS_LOGICAL_NUM_TOKENS

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    getTokenType
//
// DESCRIPTION
//
//    Determines what type of token is contained in the VARIANT.
//
///////////////////////////////////////////////////////////////////////////////
inline IAS_LOGICAL_TOKEN getTokenType(VARIANT* pv)
{
   // If it's an object pointer, it must be a condition.
   if (V_VT(pv) == VT_UNKNOWN || V_VT(pv) == VT_DISPATCH)
   {
      return IAS_CONDITION;
   }

   // Convert to a long ...
   CheckError(VariantChangeType(pv, pv, 0, VT_I4));

   // ... and see if its a valid operator.
   if (V_I4(pv) < 0 || V_I4(pv) >= IAS_LOGICAL_NUM_TOKENS)
   {
      _com_issue_error(E_INVALIDARG);
   }

   return (IAS_LOGICAL_TOKEN)V_I4(pv);
}


//////////
// Prototype for growBranch below.
//////////
ICondition* growBranch(VARIANT*& pcur, VARIANT* pend);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    getOperand
//
// DESCRIPTION
//
//    Retrieves the next operand from the expression array.
//
///////////////////////////////////////////////////////////////////////////////
ICondition* getOperand(VARIANT*& pcur, VARIANT* pend)
{
   // If we've reached the end of the expression, something's gone wrong.
   if (pcur >= pend)
   {
      _com_issue_error(E_INVALIDARG);
   }

   // Tokens that represent the start of an operand ...
   switch (getTokenType(pcur))
   {
      case IAS_LOGICAL_LEFT_PAREN:
         return growBranch(++pcur, pend);

      case IAS_LOGICAL_NOT:
         return new NotOperator(getOperand(++pcur, pend));

      case IAS_CONDITION:
         return extractCondition(pcur++);

      case IAS_LOGICAL_TRUE:
         ++pcur;
         return new ConstantCondition<VARIANT_TRUE>;

      case IAS_LOGICAL_FALSE:
         ++pcur;
         return new ConstantCondition<VARIANT_FALSE>;
   }

   // ... anything else is an error.
   _com_issue_error(E_INVALIDARG);

   return NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    growBranch
//
// DESCRIPTION
//
//    Recursively grows a complete branch of the logic tree.
//
///////////////////////////////////////////////////////////////////////////////
ICondition* growBranch(VARIANT*& pcur, VARIANT* pend)
{
   // All branches must start with an operand.
   IConditionPtr node(getOperand(pcur, pend));

   // Loop until we hit the end.
   while (pcur < pend)
   {
      // At this point we must either have a binary operator or a right ).
      switch(getTokenType(pcur))
      {
         case IAS_LOGICAL_AND:
            node = new AndOperator(node, getOperand(++pcur, pend));
            break;

         case IAS_LOGICAL_OR:
            node = new OrOperator(node, getOperand(++pcur, pend));
            break;

         case IAS_LOGICAL_XOR:
            node = new XorOperator(node, getOperand(++pcur, pend));
            break;

         case IAS_LOGICAL_RIGHT_PAREN:
            ++pcur;
            return node.Detach();

         default:
            _com_issue_error(E_INVALIDARG);
      }
   }

   return node.Detach();
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASBuildExpression
//
// DESCRIPTION
//
//    Builds a logic tree from an expression array.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASBuildExpression(
    IN VARIANT* pv,
    OUT ICondition** ppExpression
    )
{
   if (pv == NULL || ppExpression == NULL) { return E_POINTER; }

   *ppExpression = NULL;

   try
   {
      CVariantVector<VARIANT> av(pv);

      // Get the start ...
      VARIANT* pcur = av.data();

      // ... and end of the tree.
      VARIANT* pend = pcur + av.size();

      // Grow the root branch.
      *ppExpression = growBranch(pcur, pend);
   }
   catch (const _com_error& ce)
   {
      return ce.Error();
   }
   catch (std::bad_alloc)
   {
      return E_OUTOFMEMORY;
   }
   catch (...)
   {
      return E_FAIL;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\tree\tokens.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    Tokens.h
//
// SYNOPSIS
//
//    This file defines the various boolean token classes.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TOKENS_H_
#define _TOKENS_H_

#include <algorithm>
#include <nap.h>
#include <nocopy.h>

//////////
// An abstract token.
//////////
class Token :
   public ICondition, NonCopyable
{
public:
   Token() throw ()
      : refCount(0)
   { }

   virtual ~Token() throw ()
   { }

   //////////
   // IUnknown implementation.
   //////////

   STDMETHOD_(ULONG, AddRef)()
   {
      return InterlockedIncrement(&refCount);
   }

   STDMETHOD_(ULONG, Release)()
   {
      LONG l = InterlockedDecrement(&refCount);
      if (l == 0) { delete this; }
      return l;
   }

   STDMETHOD(QueryInterface)(const IID& iid, void** ppv)
   {
      if (iid == __uuidof(IUnknown))
      {
         *ppv = static_cast<IUnknown*>(this);
      }
      else if (iid == __uuidof(ICondition))
      {
         *ppv = static_cast<ICondition*>(this);
      }
      else
      {
         return E_NOINTERFACE;
      }

      InterlockedIncrement(&refCount);

      return S_OK;
   }

protected:
   LONG refCount;
};


//////////
// A Boolean constant.
//////////
template <VARIANT_BOOL Value>
class ConstantCondition : public Token
{
public:
   STDMETHOD(IsTrue)(/*[in]*/ IRequest*,
                     /*[out, retval]*/ VARIANT_BOOL *pVal)
   {
      *pVal = Value;
      return S_OK;
   }
};


//////////
// A unary operator in the logic tree.
//////////
class UnaryOperator : public Token
{
public:
   UnaryOperator(ICondition* cond)
      : operand(cond)
   {
      if (operand)
      {
         operand->AddRef();
      }
      else
      {
         _com_issue_error(E_POINTER);
      }
   }

   ~UnaryOperator() throw ()
   {
      operand->Release();
   }

protected:
   ICondition* operand;
};


//////////
// A binary operator in the logic tree.
//////////
class BinaryOperator : public Token
{
public:
   BinaryOperator(ICondition* left, ICondition* right)
      : left_operand(left), right_operand(right)
   {
      if (left_operand && right_operand)
      {
         left_operand->AddRef();
         right_operand->AddRef();
      }
      else
      {
         _com_issue_error(E_POINTER);
      }
   }

   ~BinaryOperator() throw ()
   {
      left_operand->Release();
      right_operand->Release();
   }

protected:
   ICondition *left_operand, *right_operand;
};


//////////
// AND Operator
//////////
class AndOperator : public BinaryOperator
{
public:
   AndOperator(ICondition* left, ICondition* right)
      : BinaryOperator(left, right)
   { }

   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal)
   {
      HRESULT hr = left_operand->IsTrue(pRequest, pVal);

      if (SUCCEEDED(hr) && *pVal != VARIANT_FALSE)
      {
         hr = right_operand->IsTrue(pRequest, pVal);

         if (*pVal == VARIANT_FALSE)
         {
            // We should have tried the right operand first, so let's swap
            // them and maybe we'll get lucky next time.
            std::swap(left_operand, right_operand);
         }
      }

      return hr;
   }
};


//////////
// OR Operator
//////////
class OrOperator : public BinaryOperator
{
public:
   OrOperator(ICondition* left, ICondition* right)
      : BinaryOperator(left, right)
   { }

   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal)
   {
      HRESULT hr = left_operand->IsTrue(pRequest, pVal);

      if (SUCCEEDED(hr) && *pVal == VARIANT_FALSE)
      {
         hr = right_operand->IsTrue(pRequest, pVal);

         if (*pVal != VARIANT_FALSE)
         {
            // We should have tried the right operand first, so let's swap
            // them and maybe we'll get lucky next time.
            std::swap(left_operand, right_operand);
         }
      }

      return hr;
   }
};


//////////
// XOR Operator
//////////
class XorOperator : public BinaryOperator
{
public:
   XorOperator(ICondition* left, ICondition* right)
      : BinaryOperator(left, right)
   { }

   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal)
   {
      HRESULT hr = left_operand->IsTrue(pRequest, pVal);

      if (SUCCEEDED(hr))
      {
         BOOL b1 = (*pVal != VARIANT_FALSE);

         hr = right_operand->IsTrue(pRequest, pVal);

         if (SUCCEEDED(hr))
         {
            BOOL b2 = (*pVal != VARIANT_FALSE);

            *pVal = ((b1 && !b2) || (!b1 && b2)) ? VARIANT_TRUE
                                                 : VARIANT_FALSE;
         }
      }

      return hr;
   }
};


//////////
// NOT Operator
//////////
class NotOperator : public UnaryOperator
{
public:
   NotOperator(ICondition* cond)
      : UnaryOperator(cond)
   { }

   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal)
   {
      HRESULT hr = operand->IsTrue(pRequest, pVal);

      if (SUCCEEDED(hr))
      {
         *pVal = (*pVal != VARIANT_FALSE) ? VARIANT_FALSE : VARIANT_TRUE;
      }

      return hr;
   }
};

#endif  //_TOKENS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\authbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    AuthBase.cpp
//
// SYNOPSIS
//
//    This file defines the class AuthBase.
//
// MODIFICATION HISTORY
//
//    02/12/1998    Original version.
//    03/27/1998    Prevent attribute leak when component fails to initialize.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <sdoias.h>

#include <authbase.h>

HRESULT AuthBase::initialize() throw ()
{
   return S_OK;
}

void AuthBase::finalize() throw ()
{
}

void AuthBase::onAccept(IASRequest& request, HANDLE token)
{
   DWORD returnLength;

   //////////
   // Determine the needed buffer size.
   //////////

   BOOL success = GetTokenInformation(
                      token,
                      TokenGroups,
                      NULL,
                      0,
                      &returnLength
                      );

   DWORD status = GetLastError();

   // Should have failed with ERROR_INSUFFICIENT_BUFFER.
   if (success || status != ERROR_INSUFFICIENT_BUFFER)
   {
      IASTraceFailure("GetTokenInformation", status);
      _w32_issue_error(status);
   }

   //////////
   // Allocate an attribute.
   //////////

   IASAttribute groups(true);

   //////////
   // Allocate a buffer to hold the TOKEN_GROUPS array.
   //////////

   groups->Value.OctetString.lpValue = (PBYTE)CoTaskMemAlloc(returnLength);
   if (!groups->Value.OctetString.lpValue)
   {
      _com_issue_error(E_OUTOFMEMORY);
   }

   //////////
   // Get the Token Groups info.
   //////////

   GetTokenInformation(
       token,
       TokenGroups,
       groups->Value.OctetString.lpValue,
       returnLength,
       &groups->Value.OctetString.dwLength
       );

   //////////
   // Set the id and type of the initialized attribute.
   //////////

   groups->dwId = IAS_ATTRIBUTE_TOKEN_GROUPS;
   groups->Value.itType = IASTYPE_OCTET_STRING;

   //////////
   // Inject the Token-Groups into the request.
   //////////

   groups.store(request);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\acctinfo.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    acctinfo.h
//
// SYNOPSIS
//
//    Declares the class AccountInfo.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ACCTINFO_H_
#define _ACCTINFO_H_
#if _MSC_VER >= 1000
#pragma once
#endif

class LockoutKey;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AccountInfo
//
// DESCRIPTION
//
//
//
///////////////////////////////////////////////////////////////////////////////
class AccountInfo
{
public:
   // Open the AccountInfo object for a user.
   // Returns NULL if the lockout feature is disabled.
   static AccountInfo* open(PCWSTR domain, PCWSTR username) throw ();

   // Close an AccountInfo object; 'info' may be NULL.
   static void close(AccountInfo* info) throw ();

   // Accessors for user's domain and username.
   PCWSTR getDomain() const throw ()
   { return identity; }
   PCWSTR getUserName() const throw ()
   { return delim + 1; }

   // Increment the denial count.
   void incrementDenials() throw ()
   { ++denials; persist(); }

   // Reset the denial count.
   void reset() throw ()
   { denials = 0; persist(); }

   // Returns 'true' if the denial count is zero.
   bool isClean() const throw ()
   { return denials == 0; }

   // Returns 'true' if the account is currently locked out.
   bool isLockedOut() const throw ();

   // Signals that the account's dial-in privilege has been revoked. This
   // should be called after the privilege has been successfully revoked in
   // the user's account database.
   void revoke() throw ()
   { denials = DIALIN_REVOKED; persist(); }

   // Returns 'true' if the account's dial-in privilege has been revoked.
   bool isRevoked() const throw ()
   { return denials == DIALIN_REVOKED; }

   // API lifecycle.
   static void initialize() throw ();
   static void finalize() throw ();

protected:
   AccountInfo(PCWSTR domain, PCWSTR username) throw ();
   ~AccountInfo() throw ();

   // Persists the account data to the registry.
   void persist() throw ();

   enum {
      // Magic denial value that indicates dialin privilege has been revoked.
      DIALIN_REVOKED = MAXDWORD
   };

private:
   HKEY hKey;           // Registry key for the account (if any).
   DWORD denials;       // Number of denials recorded.
   PWCHAR delim;        // Pointer to the delimeter in identity.
   WCHAR identity[1];   // Identity of the account.

   // Shared LockoutKey object.
   static LockoutKey root;

   // Not implemented.
   AccountInfo(const AccountInfo&);
   AccountInfo& operator=(const AccountInfo&);
};

#endif  // _ACCTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\acctinfo.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    acctinfo.cpp
//
// SYNOPSIS
//
//    Defines the class AccountInfo.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <lm.h>
#include <acctinfo.h>
#include <lockkey.h>
#include <new>

// Registry value names.
const WCHAR VALUE_NAME_DENIALS[]       = L"Denials";

// Delimeter used for account names (registry won't allow backslash).
const WCHAR ACCOUNT_NAME_DELIMETER = L':';

// The shared LockoutKey.
LockoutKey AccountInfo::root;

AccountInfo* AccountInfo::open(PCWSTR domain, PCWSTR username) throw ()
{
   // If account lockout is disabled or the input parameters are invalid,
   // we return NULL.
   if (root.getMaxDenials() == 0 || domain == NULL || username == NULL)
   {
      return NULL;
   }

   // Calculate the memory needed.
   size_t nbyte = sizeof(AccountInfo) +
                  sizeof(WCHAR) * (wcslen(domain) + wcslen(username));

   // Allocate a chunk.
   PVOID p = malloc(nbyte);

   // Construct the object in place.
   return p ? new (p) AccountInfo(domain, username) : NULL;
}

// Close an AccountInfo object; 'info' may be NULL.
void AccountInfo::close(AccountInfo* info) throw ()
{
   if (info)
   {
      // Invoke the destructor.
      info->~AccountInfo();

      // Free the memory.
      free(info);
   }
}

bool AccountInfo::isLockedOut() const throw ()
{
   DWORD maxDenials = root.getMaxDenials();

   return maxDenials && maxDenials <= denials;
}

void AccountInfo::initialize() throw ()
{
   root.initialize();
}

void AccountInfo::finalize() throw ()
{
   root.finalize();
}

AccountInfo::AccountInfo(PCWSTR domain, PCWSTR username) throw ()
   : denials(0)
{
   // Copy in the domain.
   size_t len = wcslen(domain);
   memcpy(identity, domain, len * sizeof(WCHAR));

   // Set the delimiter.
   delim = identity + len;
   *delim = ACCOUNT_NAME_DELIMETER;

   // Copy in the username.
   wcscpy(delim + 1, username);

   // Open the registry entry.
   hKey = root.openEntry(identity);

   // Reset the delimeter for the getDomain and getUserName accessors.
   *delim = L'\0';

   if (hKey)
   {
      // The key exists, so read the denials.
      DWORD type, data, cb = sizeof(DWORD);
      LONG result = RegQueryValueExW(
                        hKey,
                        VALUE_NAME_DENIALS,
                        NULL,
                        &type,
                        (LPBYTE)&data,
                        &cb
                        );

      if (result == NO_ERROR && type == REG_DWORD && cb == sizeof(DWORD))
      {
         denials = data;
      }

      // If the denials are zero, persist will delete the key.
      if (denials == 0) { persist(); }
   }
}

AccountInfo::~AccountInfo() throw ()
{
   if (hKey) { RegCloseKey(hKey); }
}

void AccountInfo::persist() throw ()
{
   if (denials > 0)
   {
      // Make sure we have a key to write to.
      if (!hKey)
      {
         *delim = ACCOUNT_NAME_DELIMETER;
         hKey = root.createEntry(identity);
         *delim = L'\0';
      }

      // Update the value.
      RegSetValueExW(
          hKey,
          VALUE_NAME_DENIALS,
          0,
          REG_DWORD,
          (CONST BYTE*)&denials,
          sizeof(DWORD)
          );
   }
   else if (hKey)
   {
      // We never store zero denials, so close the key ...
      RegCloseKey(hKey);
      hKey = NULL;

      // ... and delete.
      *delim = ACCOUNT_NAME_DELIMETER;
      root.deleteEntry(identity);
      *delim = L'\0';
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\tree\buildtree.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    BuildTree.h
//
// SYNOPSIS
//
//    This file declares the function IASBuildExpression.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BUILDTREE_H_
#define _BUILDTREE_H_

#include <nap.h>

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
WINAPI
IASBuildExpression(
    IN VARIANT* pv,
    OUT ICondition** ppExpression
    );

#ifdef __cplusplus
}
#endif
#endif // _BUILDTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\authbase.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    authbase.h
//
// SYNOPSIS
//
//    This file declares the class AuthBase.
//
// MODIFICATION HISTORY
//
//    02/12/1998    Original version.
//    03/27/1998    Change exception specification for onAccept.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _AUTHBASE_H_
#define _AUTHBASE_H_

#include <samutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AuthBase
//
// DESCRIPTION
//
//    Base class for all NT-SAM authentication sub-handlers.
//
///////////////////////////////////////////////////////////////////////////////
class AuthBase :
   public NtSamHandler
{
public:
   virtual HRESULT initialize() throw ();
   virtual void finalize() throw ();

protected:
   IASAttribute authType;

   // Must be overridden by sub-classes to return their Authentication-Type.
   virtual DWORD getAuthenticationType() const throw () = 0;

   // Called by sub-classes whenever a user has been accepted.
   void onAccept(IASRequest& request, HANDLE token);
};

#endif  // _AUTHBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\blob.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    blob.cpp
//
// SYNOPSIS
//
//    Defines the various 'blob' classes.
//
// MODIFICATION HISTORY
//
//    08/24/1998    Original version.
//    10/25/1998    New symbolic constants for ARAP.
//    11/10/1998    Added isLmPresent().
//    01/04/1999    MSChapError::insert takes a PPP error code.
//    01/25/1999    MS-CHAP v2
//    05/04/1999    New reason codes.
//    05/11/1999    Fix RADIUS encryption.
//    05/28/1999    Fix MS-MPPE-Keys format.
//    02/17/2000    Key encryption is now handled by the protocol.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <sdoias.h>
#include <align.h>

#include <algorithm>
#include <cstdio>

#include <samutil.h>
#include <blob.h>

bool MSChapResponse::isLmPresent() const throw ()
{
   const BYTE* p = get().lmResponse + _LM_RESPONSE_LENGTH;

   do { } while (--p >= get().lmResponse && *p == 0);

   return p >= get().lmResponse;
}

bool MSChapCPW2::isLmPresent() const throw ()
{
   // Do we have either an LM response or an LM hash.
   if ((get().flags[1] & 0x3) != 0x1) { return true; }

   // Now make sure the LM fields are zeroed out.
   const BYTE* p = get().oldLmHash +
                   _ENCRYPTED_LM_OWF_PASSWORD_LENGTH + _LM_RESPONSE_LENGTH;

   do { } while (--p >= get().oldLmHash && *p == 0);

   return p >= get().oldLmHash;
}

//////////
// Retrieves and assembles an MS-CHAP encrypted password. Returns 'true' if
// the password is present, false otherwise.
//////////
BOOL MSChapEncPW::getEncryptedPassword(
                      IASRequest& request,
                      DWORD dwId,
                      PBYTE buf
                      )
{
   //////////
   // Are there any attribute with the desired ID ?
   //////////

   IASAttributeVectorWithBuffer<8> attrs;
   if (attrs.load(request, dwId) == 0)
   {
      return false;
   }

   //////////
   // Allocate space on the stack for the blobs.
   //////////

   MSChapEncPW* begin = IAS_STACK_NEW(MSChapEncPW, attrs.size());
   MSChapEncPW* end   = begin;

   //////////
   // Convert the attributes to password chunks and determine the total length.
   //////////

   DWORD length = 0;
   IASAttributeVector::iterator i;
   for (i = attrs.begin(); i != attrs.end(); ++i, ++end)
   {
      *end = blob_cast<MSChapEncPW>(i->pAttribute);

      length += end->getStringLength();
   }

   //////////
   // Do we have the right length ?
   //////////

   if (length != _SAMPR_ENCRYPTED_USER_PASSWORD_LENGTH)
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   //////////
   // Sort the chunks ...
   //////////

   std::sort(begin, end);

   //////////
   // ... then concatenate the strings into the buffer.
   //////////

   for ( ; begin != end; ++begin)
   {
      memcpy(buf, begin->get().string, begin->getStringLength());

      buf += begin->getStringLength();
   }

   return true;
}

void MSChapDomain::insert(
                       IASRequest& request,
                       BYTE ident,
                       PCWSTR domain
                       )
{
   //////////
   // Allocate an attribute.
   //////////

   IASAttribute attr(true);

   //////////
   // Allocate memory for the blob.
   //////////

   int len = WideCharToMultiByte(CP_ACP, 0, domain, -1, 0, 0, 0, 0);
   Layout* val = (Layout*)CoTaskMemAlloc(len + sizeof(Layout));
   if (val == NULL) { _com_issue_error(E_OUTOFMEMORY); }

   //////////
   // Initialize the blob.
   //////////

   val->ident = ident;
   WideCharToMultiByte(CP_ACP, 0, domain, -1, (PSTR)val->string, len, 0, 0);

   //////////
   // Initialize the attribute and store.
   //////////

   attr->dwId = MS_ATTRIBUTE_CHAP_DOMAIN;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)val;
   attr->Value.OctetString.dwLength = len + sizeof(Layout) - 1;
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   attr.store(request);
}

void MSChapError::insert(
                      IASRequest& request,
                      BYTE ident,
                      DWORD errorCode
                      )
{
   //////////
   // Allocate an attribute.
   //////////

   IASAttribute attr(true);

   //////////
   // Format the error message.
   //////////

   CHAR buffer[32];
   sprintf(buffer, "E=%lu R=0 V=3", errorCode);

   //////////
   // Allocate memory for the blob.
   //////////

   ULONG len = strlen(buffer);
   Layout* val = (Layout*)CoTaskMemAlloc(len + sizeof(Layout));
   if (val == NULL) { _com_issue_error(E_OUTOFMEMORY); }

   //////////
   // Initialize the blob.
   //////////

   val->ident = ident;
   memcpy(val->string, buffer, len);

   //////////
   // Initialize the attribute and store.
   //////////

   attr->dwId = MS_ATTRIBUTE_CHAP_ERROR;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)val;
   attr->Value.OctetString.dwLength = len + sizeof(Layout);
   attr->dwFlags = IAS_INCLUDE_IN_REJECT;

   attr.store(request);
}

void MSChapMPPEKeys::insert(
                         IASRequest& request,
                         PBYTE lmKey,
                         PBYTE ntKey,
                         PBYTE challenge
                         )
{
   //////////
   // Allocate an attribute.
   //////////

   IASAttribute attr(true);

   //////////
   // Allocate memory for the value.
   //////////

   Layout* val = (Layout*)CoTaskMemAlloc(sizeof(Layout));
   if (val == NULL) { _com_issue_error(E_OUTOFMEMORY); }

   //////////
   // Initialize the blob.
   //////////

   memcpy(val->lmKey,     lmKey,     sizeof(val->lmKey));
   memcpy(val->ntKey,     ntKey,     sizeof(val->ntKey));
   memcpy(val->challenge, challenge, sizeof(val->challenge));

   //////////
   // Initialize the attribute and store.
   //////////

   attr->dwId = MS_ATTRIBUTE_CHAP_MPPE_KEYS;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)val;
   attr->Value.OctetString.dwLength = sizeof(Layout);
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   attr.store(request);
}

// Convert a number to a hex representation.
inline BYTE num2Digit(BYTE num) throw ()
{
   return (num < 10) ? num + '0' : num + ('A' - 10);
}

void MSChap2Success::insert(
                         IASRequest& request,
                         BYTE ident,
                         PBYTE authenticatorResponse
                         )
{
   //////////
   // Allocate an attribute.
   //////////

   IASAttribute attr(true);

   //////////
   // Allocate memory for the value.
   //////////

   Layout* val = (Layout*)CoTaskMemAlloc(sizeof(Layout));
   if (val == NULL) { _com_issue_error(E_OUTOFMEMORY); }

   //////////
   // Initialize the blob.
   //////////

   val->ident = ident;
   PBYTE p = val->string;
   *p++ = 'S';
   *p++ = '=';
   for (size_t i = 0; i < 20; ++i)
   {
      *p++ = num2Digit(authenticatorResponse[i] >> 4);
      *p++ = num2Digit(authenticatorResponse[i] & 0xF);
   }

   //////////
   // Initialize the attribute and store.
   //////////

   attr->dwId = MS_ATTRIBUTE_CHAP2_SUCCESS;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)val;
   attr->Value.OctetString.dwLength = sizeof(Layout);
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   attr.store(request);
}

void MSMPPEKey::insert(
                    IASRequest& request,
                    ULONG keyLength,
                    PBYTE key,
                    BOOL isSendKey
                    )
{
   //////////
   // Allocate an attribute.
   //////////

   IASAttribute attr(true);

   //////////
   // Allocate memory for the value.
   //////////

   ULONG nbyte = ROUND_UP_COUNT(keyLength + 1, 16) + 2;
   Layout* val = (Layout*)CoTaskMemAlloc(nbyte);
   if (val == NULL) { _com_issue_error(E_OUTOFMEMORY); }
   memset(val, 0, nbyte);

   //////////
   // Initialize the blob.
   //////////

   val->keyLength = (BYTE)keyLength;
   memcpy(val->key, key, keyLength);

   //////////
   // Initialize the attribute, encrypt, and store.
   //////////

   attr->dwId = isSendKey ? MS_ATTRIBUTE_MPPE_SEND_KEY
                          : MS_ATTRIBUTE_MPPE_RECV_KEY;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)val;
   attr->Value.OctetString.dwLength = nbyte;
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   attr.store(request);
}

void ArapChallengeResponse::insert(
                                IASRequest& request,
                                DWORD NTResponse1,
                                DWORD NTResponse2
                                )
{
   // Allocate an attribute.
   IASAttribute attr(true);

   // Pack the fields.  These are already in network order.
   Layout value;
   memcpy(value.ntResponse1, &NTResponse1, 4);
   memcpy(value.ntResponse2, &NTResponse2, 4);

   // Store the value.
   attr.setOctetString(sizeof(value), (const BYTE*)&value);

   // Initialize the remaining fields.
   attr->dwId    = RADIUS_ATTRIBUTE_ARAP_CHALLENGE_RESPONSE;
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   // Insert the attribute into the request.
   attr.store(request);
}

void ArapFeatures::insert(
                       IASRequest& request,
                       DWORD PwdCreationDate,
                       DWORD PwdExpiryDelta,
                       DWORD CurrentTime
                       )
{
   // Allocate an attribute.
   IASAttribute attr(true);

   // Pack the fields.
   Layout value;
   value.changePasswordAllowed = 1;  // Change password always allowed.
   value.minPasswordLength     = 3;  // Arbitrary.

   // These are already in network order.
   memcpy(value.pwdCreationDate, &PwdCreationDate, 4);
   memcpy(value.pwdExpiryDelta,  &PwdExpiryDelta,  4);
   memcpy(value.currentTime,     &CurrentTime,     4);

   // Store the value.
   attr.setOctetString(sizeof(value), (const BYTE*)&value);

   // Initialize the rest of the fields.
   attr->dwId    = RADIUS_ATTRIBUTE_ARAP_FEATURES;
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;

   // Insert the attribute into the request.
   attr.store(request);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\changepwd.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    changepwd.h
//
// SYNOPSIS
//
//    Declares the class ChangePassword.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CHANGEPWD_H
#define CHANGEPWD_H

#include <iastl.h>

namespace IASTL
{
   class IASRequest;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ChangePassword
//
// DESCRIPTION
//
//    Implements the MS-CHAP Change Password handler.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE ChangePassword
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<ChangePassword, &__uuidof(ChangePassword)>
{
public:

IAS_DECLARE_REGISTRY(ChangePassword, 1, 0, IASTypeLibrary)

   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();

private:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   static bool tryMsChapCpw1(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  PBYTE challenge
                  );

   static bool tryMsChapCpw2(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  PBYTE challenge
                  );

   static void doMsChapCpw(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  IAS_OCTET_STRING& msChapChallenge
                  );

   static void doMsChap2Cpw(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  IAS_OCTET_STRING& msChapChallenge
                  );

   static void doChangePassword(
                  IASTL::IASRequest& request,
                  DWORD authType
                  );
};

#endif  // CHANGEPWD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\blob.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    blob.h
//
// SYNOPSIS
//
//    This file declares structs for extracting blobs from IAS_OCTET_STRING's.
//
// MODIFICATION HISTORY
//
//    08/24/1998    Original version.
//    11/10/1998    Added isLmPresent().
//    01/25/1999    MS-CHAP v2
//    05/21/1999    Remove MSChapChallenge.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BLOB_H_
#define _BLOB_H_

#include <iaspolcy.h>
#include <iaslsa.h>
#include <iastlutl.h>
#include <iasutil.h>

using namespace IASTL;

// nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable:4200)

//////////
// Safely extracts a blob from an IASATTRIBUTE.
//////////
template <class T>
T& blob_cast(PIASATTRIBUTE a)
{
   T& blob = (T&)(a->Value.OctetString);

   if (a->Value.itType != IASTYPE_OCTET_STRING || !blob.isValid())
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   return blob;
}

///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    (BLOB)
//
// DESCRIPTION
//
//    Each blob struct inherits from IAS_OCTET_STRING. It in turn has a nested
//    struct called 'Layout' which defines the wire format of the bytes. It
//    also defines an isValid method that tests whether the IAS_OCTET_STRING
//    can be safely downcast.
//
///////////////////////////////////////////////////////////////////////////////

struct MSChapResponse : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ident;
      BYTE flags;
      BYTE lmResponse[_LM_RESPONSE_LENGTH];
      BYTE ntResponse[_NT_RESPONSE_LENGTH];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return dwLength == sizeof(Layout);
   }

   bool isLmPresent() const throw ();

   bool isNtPresent() const throw ()
   {
      return (get().flags & 0x1) != 0;
   }
};

struct MSChapCPW1 : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE code;
      BYTE ident;
      BYTE lmOldPwd[_ENCRYPTED_LM_OWF_PASSWORD_LENGTH];
      BYTE lmNewPwd[_ENCRYPTED_LM_OWF_PASSWORD_LENGTH];
      BYTE ntOldPwd[_ENCRYPTED_NT_OWF_PASSWORD_LENGTH];
      BYTE ntNewPwd[_ENCRYPTED_NT_OWF_PASSWORD_LENGTH];
      BYTE newLmPwdLen[2];
      BYTE flags[2];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return (dwLength == sizeof(Layout)) && (get().code == 5);
   }

   WORD getNewLmPwdLen() const throw ()
   {
      return IASExtractWORD(get().newLmPwdLen);
   }

   bool isNtPresent() const throw ()
   {
      return (get().flags[1] & 0x1) != 0;
   }
};

struct MSChapCPW2 : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE code;
      BYTE ident;
      BYTE oldNtHash[_ENCRYPTED_NT_OWF_PASSWORD_LENGTH];
      BYTE oldLmHash[_ENCRYPTED_LM_OWF_PASSWORD_LENGTH];
      BYTE lmResponse[_LM_RESPONSE_LENGTH];
      BYTE ntResponse[_NT_RESPONSE_LENGTH];
      BYTE flags[2];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return (dwLength == sizeof(Layout)) && (get().code == 6);
   }

   bool isLmPresent() const throw ();

   bool isLmHashValid() const throw ()
   {
      return (get().flags[1] & 0x2) != 0;
   }

   bool isNtResponseValid() const throw ()
   {
      return (get().flags[1] & 0x1) != 0;
   }
};

struct MSChapEncPW : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE code;
      BYTE ident;
      BYTE sequence[2];
      BYTE string[0];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return (dwLength >= sizeof(Layout)) && (get().code == 6);
   }

   DWORD getStringLength() const throw ()
   {
      return dwLength - FIELD_OFFSET(Layout, string);
   }

   WORD getSequence() const throw ()
   {
      return IASExtractWORD(get().sequence);
   }

   bool operator<(const MSChapEncPW& pw) const throw ()
   {
      return getSequence() < pw.getSequence();
   }
   static BOOL getEncryptedPassword(
                   IASRequest& request,
                   DWORD dwId,
                   PBYTE buf
                   );
};

struct MSChapDomain : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ident;
      BYTE string[0];
   };

   static void insert(
                   IASRequest& request,
                   BYTE ident,
                   PCWSTR domain
                   );
};

struct MSChapError : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ident;
      BYTE string[0];
   };

   static void insert(
                   IASRequest& request,
                   BYTE ident,
                   DWORD errorCode
                   );
};

struct MSChapMPPEKeys : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE lmKey[8];
      BYTE ntKey[16];
      BYTE challenge[8];
   };

   static void insert(
                   IASRequest& request,
                   PBYTE lmKey,
                   PBYTE ntKey,
                   PBYTE challenge
                   );
};

struct MSChap2Response : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ident;
      BYTE flags;
      BYTE peerChallenge[16];
      BYTE reserved[8];
      BYTE response[_NT_RESPONSE_LENGTH];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return dwLength == sizeof(Layout);
   }
};

struct MSChap2Success : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ident;
      BYTE string[42];
   };

   static void insert(
                   IASRequest& request,
                   BYTE ident,
                   PBYTE authenticatorResponse
                   );
};

struct MSMPPEKey : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE salt[2];
      BYTE keyLength;
      BYTE key[0];
   };

   static void insert(
                   IASRequest& request,
                   ULONG keyLength,
                   PBYTE key,
                   BOOL isSendKey
                   );
};

struct MSChap2CPW : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE code;
      BYTE ident;
      BYTE encryptedHash[_ENCRYPTED_NT_OWF_PASSWORD_LENGTH];
      BYTE peerChallenge[16];
      BYTE reserved[8];
      BYTE response[_NT_RESPONSE_LENGTH];
      BYTE flags[2];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return (dwLength == sizeof(Layout)) && (get().code == 7);
   }
};

struct ArapChallenge : IAS_OCTET_STRING
{
   struct Layout
   {
      DWORD ntChallenge1;
      DWORD ntChallenge2;
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return dwLength == sizeof(Layout);
   }

};

struct ArapPassword : IAS_OCTET_STRING
{
   struct Layout
   {
      DWORD macChallenge1;
      DWORD macChallenge2;
      DWORD macResponse1;
      DWORD macResponse2;
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ()
   {
      return dwLength == sizeof(Layout);
   }
};

struct ArapChallengeResponse : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE ntResponse1[4];
      BYTE ntResponse2[4];
   };

   static void insert(
                   IASRequest& request,
                   DWORD NTResponse1,
                   DWORD NTResponse2
                   );
};

struct ArapFeatures : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE changePasswordAllowed;
      BYTE minPasswordLength;
      BYTE pwdCreationDate[4];
      BYTE pwdExpiryDelta[4];
      BYTE currentTime[4];
   };

   static void insert(
                   IASRequest& request,
                   DWORD PwdCreationDate,
                   DWORD PwdExpiryDelta,
                   DWORD CurrentTime
                   );
};

#endif  // _BLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\lockkey.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    lockkey.cpp
//
// SYNOPSIS
//
//    Defines the class LockoutKey.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//    11/04/1998    Fix bug in computing key expiration.
//    01/14/1999    Move initialization code out of constructor.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <lm.h>
#include <lockkey.h>
#include <yvals.h>

//////////
// Registry key and value names.
//////////
const WCHAR KEY_NAME_ACCOUNT_LOCKOUT[] = L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout";
const WCHAR VALUE_NAME_LOCKOUT_COUNT[] = L"MaxDenials";
const WCHAR VALUE_NAME_RESET_TIME[]    = L"ResetTime (mins)";

//////////
// Registry value defaults.
//////////
const DWORD DEFAULT_LOCKOUT_COUNT = 0;
const DWORD DEFAULT_RESET_TIME    = 48 * 60;  // 48 hours.

/////////
// Helper function that reads a DWORD registry value. If the value isn't set
// or is corrupt, then a default value is written to the registry.
/////////
DWORD
WINAPI
RegQueryDWORDWithDefault(
    HKEY hKey,
    PCWSTR lpValueName,
    DWORD dwDefault
    )
{
   LONG result;
   DWORD type, data, cb;

   cb = sizeof(DWORD);
   result = RegQueryValueExW(
                hKey,
                lpValueName,
                NULL,
                &type,
                (LPBYTE)&data,
                &cb
                );

   if (result == NO_ERROR && type == REG_DWORD && cb == sizeof(DWORD))
   {
      return data;
   }

   if (result == NO_ERROR || result == ERROR_FILE_NOT_FOUND)
   {
      RegSetValueExW(
          hKey,
          lpValueName,
          0,
          REG_DWORD,
          (CONST BYTE*)&dwDefault,
          sizeof(DWORD)
          );
   }

   return dwDefault;
}

LockoutKey::LockoutKey() throw ()
   : maxDenials(DEFAULT_LOCKOUT_COUNT),
     refCount(0),
     hLockout(NULL),
     hChangeEvent(NULL),
     hRegisterWait(NULL),
     ttl(DEFAULT_RESET_TIME),
     lastCollection(0)
{ }

void LockoutKey::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   if (refCount == 0)
   {
      // Create or open the lockout key.
      LONG result;
      DWORD disposition;
      result = RegCreateKeyEx(
                   HKEY_LOCAL_MACHINE,
                   KEY_NAME_ACCOUNT_LOCKOUT,
                   NULL,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   NULL,
                   &hLockout,
                   &disposition
                   );

      // Event used for signalling changes to the registry.
      hChangeEvent = CreateEventW(NULL, FALSE, FALSE, NULL);

      // Register for change notifications.
      RegNotifyChangeKeyValue(
          hLockout,
          FALSE,
          REG_NOTIFY_CHANGE_LAST_SET,
          hChangeEvent,
          TRUE
          );

      // Read the initial values.
      readValues();

      // Register the event.
      RegisterWaitForSingleObject(
                          &hRegisterWait,
                          hChangeEvent,
                          onChange,
                          this,
                          INFINITE,
                          0
                          );
   }

   ++refCount;
}

void LockoutKey::finalize() throw ()
{
   IASGlobalLockSentry sentry;

   if (--refCount == 0)
   {
      UnregisterWait(hRegisterWait);

      if (hLockout) { RegCloseKey(hLockout); }

      CloseHandle(hChangeEvent);
   }
}

HKEY LockoutKey::createEntry(PCWSTR subKeyName) throw ()
{
   HKEY hKey = NULL;
   DWORD disposition;
   RegCreateKeyEx(
       hLockout,
       subKeyName,
       NULL,
       NULL,
       REG_OPTION_NON_VOLATILE,
       KEY_ALL_ACCESS,
       NULL,
       &hKey,
       &disposition
       );

   // Whenever we grow the registry, we'll also clean up old entries.
   if (ttl) { collectGarbage(); }

   return hKey;
}

HKEY LockoutKey::openEntry(PCWSTR subKeyName) throw ()
{
   LONG result;
   HKEY hKey = NULL;
   result = RegOpenKeyEx(
                hLockout,
                subKeyName,
                0,
                KEY_ALL_ACCESS,
                &hKey
                );

   if (result == NO_ERROR && ttl)
   {
      // We retrieved a key, but we need to make sure it hasn't expired.
      ULARGE_INTEGER lastWritten;
      result = RegQueryInfoKey(
                   hKey,
                   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                   (LPFILETIME)&lastWritten
                   );
      if (result == NO_ERROR)
      {
         ULARGE_INTEGER now;
         GetSystemTimeAsFileTime((LPFILETIME)&now);

         if (now.QuadPart - lastWritten.QuadPart >= ttl)
         {
            // It's expired, so close the key ...
            RegCloseKey(hKey);
            hKey = NULL;

            // ... and delete.
            deleteEntry(subKeyName);
         }
      }
   }

   return hKey;
}

void LockoutKey::clear() throw ()
{
   // Get the number of sub-keys.
   LONG result;
   DWORD index;
   result = RegQueryInfoKey(
                hLockout,
                NULL, NULL, NULL,
                &index,
                NULL, NULL, NULL, NULL, NULL, NULL, NULL
                );
   if (result != NO_ERROR) { return; }

   // Iterate through the keys in reverse order so we can delete them
   // without throwing off the indices.
   while (index)
   {
      --index;

      WCHAR name[DNLEN + UNLEN + 2];
      DWORD cbName = sizeof(name) / sizeof(WCHAR);
      result = RegEnumKeyEx(
                   hLockout,
                   index,
                   name,
                   &cbName,
                   NULL,
                   NULL,
                   NULL,
                   NULL
                   );

      if (result == NO_ERROR) { RegDeleteKey(hLockout, name); }
   }
}

void LockoutKey::collectGarbage() throw ()
{
   // Flag that indicates whether another thread is collecting.
   static LONG inProgress;

   // Save the TTL to a local variable, so we don't have to worry about it
   // changing will we're executing.
   ULONGLONG localTTL = ttl;

   // If the reset time is not configured, then bail.
   if (localTTL == 0) { return; }

   // We won't collect more frequently than the TTL.
   ULARGE_INTEGER now;
   GetSystemTimeAsFileTime((LPFILETIME)&now);
   if (now.QuadPart - lastCollection < localTTL) { return; }

   // If another thread is alreay collecting, then bail.
   if (InterlockedExchange(&inProgress, 1)) { return; }

   // Save the new collection time.
   lastCollection = now.QuadPart;

   // Get the number of sub-keys.
   LONG result;
   DWORD index;
   result = RegQueryInfoKey(
                hLockout,
                NULL, NULL, NULL,
                &index,
                NULL, NULL, NULL, NULL, NULL, NULL, NULL
                );
   if (result == NO_ERROR)
   {
      // We iterate through the keys in reverse order so we can delete them
      // without throwing off the indices.
      while (index)
      {
         --index;

         // Get the lastWritten time for the key ...
         WCHAR name[DNLEN + UNLEN + 2];
         DWORD cbName = sizeof(name) / sizeof(WCHAR);
         ULARGE_INTEGER lastWritten;
         result = RegEnumKeyEx(
                      hLockout,
                      index,
                      name,
                      &cbName,
                      NULL,
                      NULL,
                      NULL,
                      (LPFILETIME)&lastWritten
                      );

         // ... and delete if it's expired.
         if (result == NO_ERROR &&
             now.QuadPart - lastWritten.QuadPart >= localTTL)
         {
            RegDeleteKey(hLockout, name);
         }
      }
   }

   // Collection is no longer in progress.
   InterlockedExchange(&inProgress, 0);
}

void LockoutKey::readValues() throw ()
{
   /////////
   // Note: This isn't synchronized. The side-effects of an inconsistent state
   //       are pretty minor, so we'll just take our chances.
   /////////

   // Read max. denials.
   maxDenials = RegQueryDWORDWithDefault(
                    hLockout,
                    VALUE_NAME_LOCKOUT_COUNT,
                    DEFAULT_LOCKOUT_COUNT
                    );

   // Read Time-To-Live.
   ULONGLONG newTTL = RegQueryDWORDWithDefault(
                          hLockout,
                          VALUE_NAME_RESET_TIME,
                          DEFAULT_RESET_TIME
                          );
   newTTL *= 600000000ui64;
   ttl = newTTL;

   if (maxDenials == 0)
   {
      // If account lockout is disabled, clean up all the keys.
      clear();
   }
   else
   {
      // Otherwise, the TTL may have changed, so collect garbage.
      collectGarbage();
   }
}

VOID NTAPI LockoutKey::onChange(PVOID context, BOOLEAN flag) throw ()
{
   // Re-read the values.
   ((LockoutKey*)context)->readValues();

   // Re-register the notification.
   RegNotifyChangeKeyValue(
       ((LockoutKey*)context)->hLockout,
       FALSE,
       REG_NOTIFY_CHANGE_LAST_SET,
       ((LockoutKey*)context)->hChangeEvent,
       TRUE
       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\mschaperror.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    mschaperror.cpp
//
// SYNOPSIS
//
//    Defines the class MSChapErrorReporter.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <blob.h>
#include <mschaperror.h>

/////////
// Returns the PPP CHAP Identifier for the request.
/////////
BYTE
WINAPI
GetMSChapIdent(
    IAttributesRaw* request
    ) throw ()
{
   PIASATTRIBUTE attr;

   /////////
   // Check the attributes in decreasing order of probability.
   /////////

   attr = IASPeekAttribute(
              request,
              MS_ATTRIBUTE_CHAP_RESPONSE,
              IASTYPE_OCTET_STRING
              );
   if (attr && attr->Value.OctetString.dwLength > 0)
   {
      return *(attr->Value.OctetString.lpValue);
   }

   attr = IASPeekAttribute(
              request,
              MS_ATTRIBUTE_CHAP_CPW2,
              IASTYPE_OCTET_STRING
              );
   if (attr && attr->Value.OctetString.dwLength > 1)
   {
      return *(attr->Value.OctetString.lpValue + 1);
   }

   attr = IASPeekAttribute(
              request,
              MS_ATTRIBUTE_CHAP_CPW1,
              IASTYPE_OCTET_STRING
              );
   if (attr && attr->Value.OctetString.dwLength > 1)
   {
      return *(attr->Value.OctetString.lpValue + 1);
   }

   // If we can't read the identifier, we'll just use zero.
   return (BYTE)0;
}

IASREQUESTSTATUS MSChapErrorReporter::onSyncRequest(
                                          IRequest* pRequest
                                          ) throw ()
{
   try
   {
      IASRequest request(pRequest);

      PIASATTRIBUTE attr;

      // If it doesn't have an MS-CHAP-Challenge then we're not interested.
      attr = IASPeekAttribute(
                 request,
                 MS_ATTRIBUTE_CHAP_CHALLENGE,
                 IASTYPE_OCTET_STRING
                 );
      if (!attr) { return IAS_REQUEST_STATUS_CONTINUE; }

      // If it already has an MS-CHAP-Error, then there's nothing to do.
      attr = IASPeekAttribute(
                 request,
                 MS_ATTRIBUTE_CHAP_ERROR,
                 IASTYPE_OCTET_STRING
                 );
      if (attr) { return IAS_REQUEST_STATUS_CONTINUE; }

      // Map the reason code to an MS-CHAP error code.
      DWORD errorCode;
      switch (request.get_Reason())
      {
         case IAS_INVALID_LOGON_HOURS:
            errorCode = 646;   // ERROR_RESTRICTED_LOGON_HOURS
            break;

         case IAS_ACCOUNT_DISABLED:
            errorCode = 647;   // ERROR_ACCT_DISABLED
            break;

         case IAS_PASSWORD_MUST_CHANGE:
            errorCode = 648;   // ERROR_PASSWD_EXPIRED
            break;

         case IAS_LM_NOT_ALLOWED:
         case IAS_NO_POLICY_MATCH:
         case IAS_DIALIN_LOCKED_OUT:
         case IAS_DIALIN_DISABLED:
         case IAS_INVALID_AUTH_TYPE:
         case IAS_INVALID_CALLING_STATION:
         case IAS_INVALID_DIALIN_HOURS:
         case IAS_INVALID_CALLED_STATION:
         case IAS_INVALID_PORT_TYPE:
         case IAS_DIALIN_RESTRICTION:
         case IAS_CPW_NOT_ALLOWED:
            errorCode = 649;   // ERROR_NO_DIALIN_PERMISSION
            break;

         case IAS_CHANGE_PASSWORD_FAILURE:
            errorCode = 709;   // ERROR_CHANGING_PASSWORD;
            break;

         default:
            errorCode = 691;   // ERROR_AUTHENTICATION_FAILURE
      }

      // Insert the MS-CHAP-Error VSA.
      MSChapError::insert(request, GetMSChapIdent(request), errorCode);
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();

      // If we can't populate the MS-CHAP-Error VSA, then we can't send a
      // compliant response, so we should abort.
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, ce.Error());
   }

   return IAS_REQUEST_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\lockout.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    lockout.cpp
//
// SYNOPSIS
//
//    Defines the account lockout API.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//    11/10/1998    Do not revoke dialin privilege.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlb.h>
#include <iaslsa.h>
#include <acctinfo.h>
#include <lockout.h>

DWORD
WINAPI
AccountLockoutInitialize( VOID )
{
   AccountInfo::initialize();

   return NO_ERROR;
}

VOID
WINAPI
AccountLockoutShutdown( VOID )
{
   AccountInfo::finalize();
}

BOOL
WINAPI
AccountLockoutOpenAndQuery(
    IN  PCWSTR pszUser,
    IN  PCWSTR pszDomain,
    OUT PHANDLE phAccount
    )
{
   // Check the arguments.
   if (phAccount == NULL) { return ERROR_INVALID_PARAMETER; }

   // Open the AccountInfo object for this user.
   AccountInfo* info = AccountInfo::open(pszDomain, pszUser);

   // Return it to the caller as an opaque handle.
   *phAccount = (HANDLE)info;

   // If the info doesn't exist, it's not an error; it just means account
   // lockout is disabled.
   return info && info->isLockedOut() ? TRUE : FALSE;
}

VOID
WINAPI
AccountLockoutUpdatePass(
    IN HANDLE hAccount
    )
{
   if (hAccount)
   {
      // The logon succeeded, so reset the lockout count.
      ((AccountInfo*)hAccount)->reset();
   }
}

VOID
WINAPI
AccountLockoutUpdateFail(
    IN HANDLE hAccount
    )
{
   if (hAccount)
   {
      IASTraceString("Authentication failed; incrementing lockout count.");

      AccountInfo* info = (AccountInfo*)hAccount;

      // Is this the first denial ?
      if (info->isClean())
      {
         IASTraceString("Validating account name for new entry.");

         // Yes, so make sure it's a valid account. We don't want to create a
         // lot of registry keys for bogus accounts.
         DWORD status = IASValidateUserName(
                            info->getUserName(),
                            info->getDomain()
                            );

         if (status != NO_ERROR)
         {
            IASTraceFailure("IASValidateUserName", status);
            return;
         }

         IASTraceString("Account name is valid.");
      }

      // Bump up the denial count.
      info->incrementDenials();
   }
}

VOID
WINAPI
AccountLockoutClose(
    IN HANDLE hAccount
    )
{
   AccountInfo::close((AccountInfo*)hAccount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\changepwd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class ChangePassword.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <changepwd.h>
#include <blob.h>
#include <iaslsa.h>
#include <iastlutl.h>
#include <ntsamauth.h>
#include <samutil.h>


STDMETHODIMP ChangePassword::Initialize()
{
   DWORD error = IASLsaInitialize();
   return HRESULT_FROM_WIN32(error);
}


STDMETHODIMP ChangePassword::Shutdown()
{
   IASLsaUninitialize();
   return S_OK;
}


IASREQUESTSTATUS ChangePassword::onSyncRequest(IRequest* pRequest) throw ()
{
   try
   {
      IASTL::IASRequest request(pRequest);

      // Only process change password requests.
      IASTL::IASAttribute authType;
      if (authType.load(
                      request,
                      IAS_ATTRIBUTE_AUTHENTICATION_TYPE,
                      IASTYPE_ENUM
                      ))
      {
         switch (authType->Value.Enumerator)
         {
            case IAS_AUTH_MSCHAP_CPW:
               // Fall through.
            case IAS_AUTH_MSCHAP2_CPW:
               doChangePassword(request, authType->Value.Enumerator);
               break;

            default:
               // Do nothing.
               break;
         }
      }
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      IASProcessFailure(pRequest, ce.Error());
   }

   return IAS_REQUEST_STATUS_CONTINUE;
}


bool ChangePassword::tryMsChapCpw1(
                        IASTL::IASRequest& request,
                        PCWSTR domainName,
                        PCWSTR username,
                        PBYTE challenge
                        )
{
   // Is the MS-CHAP-CPW-1 VSA present?
   IASTL::IASAttribute attr;
   if (!attr.load(
                request,
                MS_ATTRIBUTE_CHAP_CPW1,
                IASTYPE_OCTET_STRING
                ))
   {
      return false;
   }
   MSChapCPW1& cpw1 = blob_cast<MSChapCPW1>(attr);

   IASTraceString("Processing MS-CHAP-CPW-1.");

   // Is LM Authentication allowed?
   if (NTSamAuthentication::enforceLmRestriction(request))
   {
      // Change the password.
      BYTE newNtResponse[_NT_RESPONSE_LENGTH];
      BYTE newLmResponse[_LM_RESPONSE_LENGTH];
      DWORD status;
      status = IASChangePassword1(
                  username,
                  domainName,
                  challenge,
                  cpw1.get().lmOldPwd,
                  cpw1.get().lmNewPwd,
                  cpw1.get().ntOldPwd,
                  cpw1.get().ntNewPwd,
                  cpw1.getNewLmPwdLen(),
                  cpw1.isNtPresent(),
                  newNtResponse,
                  newLmResponse
                  );
      if (status == NO_ERROR)
      {
         IASTraceString("Password successfully changed.");

         // Password was successfully changed, so authenticate the user.
         NTSamAuthentication::doMsChapAuthentication(
                                 request,
                                 domainName,
                                 username,
                                 cpw1.get().ident,
                                 challenge,
                                 newNtResponse,
                                 newLmResponse
                                 );
      }
      else
      {
         IASTraceFailure("IASChangePassword1", status);

         if (status == ERROR_ACCESS_DENIED)
         {
            status = IAS_CHANGE_PASSWORD_FAILURE;
         }
         else
         {
            status = IASMapWin32Error(status, IAS_CHANGE_PASSWORD_FAILURE);
         }

         IASProcessFailure(request, status);
      }
   }

   return true;
}


bool ChangePassword::tryMsChapCpw2(
                        IASTL::IASRequest& request,
                        PCWSTR domainName,
                        PCWSTR username,
                        PBYTE challenge
                        )
{
   // Is the MS-CHAP-CPW-2 VSA present?
   IASAttribute attr;
   if (!attr.load(
                request,
                MS_ATTRIBUTE_CHAP_CPW2,
                IASTYPE_OCTET_STRING
                ))
   {
      return false;
   }
   MSChapCPW2& cpw2 = blob_cast<MSChapCPW2>(attr);

   IASTraceString("Processing MS-CHAP-CPW-2.");

   // Check LM Authentication.
   if (!cpw2.isLmPresent() ||
       NTSamAuthentication::enforceLmRestriction(request))
   {
      //////////
      // Assemble the encrypted passwords.
      //////////

      BYTE ntEncPW[_SAMPR_ENCRYPTED_USER_PASSWORD_LENGTH];
      if (!MSChapEncPW::getEncryptedPassword(
                            request,
                            MS_ATTRIBUTE_CHAP_NT_ENC_PW,
                            ntEncPW
                            ))
      {
         _com_issue_error(IAS_MALFORMED_REQUEST);
      }

      BOOL lmPresent = FALSE;
      BYTE lmEncPW[_SAMPR_ENCRYPTED_USER_PASSWORD_LENGTH];
      if (cpw2.isLmHashValid())
      {
         lmPresent = MSChapEncPW::getEncryptedPassword(
                                      request,
                                      MS_ATTRIBUTE_CHAP_LM_ENC_PW,
                                      lmEncPW
                                      );
      }

      //////////
      // Change the password.
      //////////

      DWORD status;
      status = IASChangePassword2(
                   username,
                   domainName,
                   cpw2.get().oldNtHash,
                   cpw2.get().oldLmHash,
                   ntEncPW,
                   lmPresent ? lmEncPW : NULL,
                   cpw2.isLmHashValid()
                   );

      if (status == NO_ERROR)
      {
         IASTraceString("Password successfully changed.");

         // Password was successfully changed, so authenticate the user.
         PBYTE ntResponse;
         if (cpw2.isNtResponseValid())
         {
            ntResponse = cpw2.get().ntResponse;
         }
         else
         {
            ntResponse = NULL;
         }
         NTSamAuthentication::doMsChapAuthentication(
                                 request,
                                 domainName,
                                 username,
                                 cpw2.get().ident,
                                 challenge,
                                 ntResponse,
                                 cpw2.get().lmResponse
                                 );
      }
      else
      {
         IASTraceFailure("IASChangePassword2", status);

         if (status == ERROR_ACCESS_DENIED)
         {
            status = IAS_CHANGE_PASSWORD_FAILURE;
         }
         else
         {
            status = IASMapWin32Error(status, IAS_CHANGE_PASSWORD_FAILURE);
         }

         IASProcessFailure(request, status);
      }
   }

   return true;
}


void ChangePassword::doMsChapCpw(
                        IASTL::IASRequest& request,
                        PCWSTR domainName,
                        PCWSTR username,
                        IAS_OCTET_STRING& msChapChallenge
                        )
{
   if (msChapChallenge.dwLength != _MSV1_0_CHALLENGE_LENGTH)
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   PBYTE challenge = msChapChallenge.lpValue;

   if (!tryMsChapCpw2(request, domainName, username, challenge) &&
       !tryMsChapCpw1(request, domainName, username, challenge))
   {
      _com_issue_error(IAS_INTERNAL_ERROR);
   }
}


void ChangePassword::doMsChap2Cpw(
                        IASTL::IASRequest& request,
                        PCWSTR domainName,
                        PCWSTR username,
                        IAS_OCTET_STRING& msChapChallenge
                        )
{
   IASTraceString("Processing MS-CHAP v2 change password.");

   // Is the necessary attribute present ?
   IASAttribute attr;
   if (!attr.load(
                request,
                MS_ATTRIBUTE_CHAP2_CPW,
                IASTYPE_OCTET_STRING
                ))
   {
      _com_issue_error(IAS_INTERNAL_ERROR);
   }
   MSChap2CPW& cpw = blob_cast<MSChap2CPW>(attr);

   //////////
   // Assemble the encrypted password.
   //////////

   BYTE encPW[_SAMPR_ENCRYPTED_USER_PASSWORD_LENGTH];
   if (!MSChapEncPW::getEncryptedPassword(
                         request,
                         MS_ATTRIBUTE_CHAP_NT_ENC_PW,
                         encPW
                         ))
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   //////////
   // Change the password.
   //////////

   DWORD status;
   status = IASChangePassword3(
                username,
                domainName,
                cpw.get().encryptedHash,
                encPW
                );

   if (status == NO_ERROR)
   {
      IASTraceString("Password successfully changed.");

      // Password was successfully changed, so authenticate the user.
      NTSamAuthentication::doMsChap2Authentication(
                              request,
                              domainName,
                              username,
                              cpw.get().ident,
                              msChapChallenge,
                              cpw.get().response,
                              cpw.get().peerChallenge
                              );
   }
   else
   {
      IASTraceFailure("IASChangePassword3", status);

      if (status == ERROR_ACCESS_DENIED)
      {
         status = IAS_CHANGE_PASSWORD_FAILURE;
      }
      else
      {
         status = IASMapWin32Error(status, IAS_CHANGE_PASSWORD_FAILURE);
      }

      IASProcessFailure(request, status);
   }
}


void ChangePassword::doChangePassword(
                        IASTL::IASRequest& request,
                        DWORD authType
                        )
{
   IASTL::IASAttribute identity;
   if (!identity.load(
                    request,
                    IAS_ATTRIBUTE_NT4_ACCOUNT_NAME,
                    IASTYPE_STRING
                    ))
   {
      _com_issue_error(IAS_INTERNAL_ERROR);
   }

   // Convert the User-Name to SAM format.
   SamExtractor extractor(*identity);
   PCWSTR domain = extractor.getDomain();
   PCWSTR username = extractor.getUsername();

   IASAttribute msChapChallenge;
   if (!msChapChallenge.load(
                           request,
                           MS_ATTRIBUTE_CHAP_CHALLENGE,
                           IASTYPE_OCTET_STRING
                           ))
   {
      _com_issue_error(IAS_INTERNAL_ERROR);
   }

   switch (authType)
   {
      case IAS_AUTH_MSCHAP_CPW:
         doMsChapCpw(
            request,
            domain,
            username,
            msChapChallenge->Value.OctetString
            );
         break;

      case IAS_AUTH_MSCHAP2_CPW:
         doMsChap2Cpw(
            request,
            domain,
            username,
            msChapChallenge->Value.OctetString
            );
         break;

      default:
         _com_issue_error(IAS_INTERNAL_ERROR);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\lockkey.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    lockkey.h
//
// SYNOPSIS
//
//    Declares the class LockoutKey.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//    01/14/1999    Removed destructor.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _LOCKKEY_H_
#define _LOCKKEY_H_
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LockoutKey
//
// DESCRIPTION
//
//    Provides a wrapper around the AccountLockout registry key.
//
///////////////////////////////////////////////////////////////////////////////
class LockoutKey
{
public:
   LockoutKey() throw ();

   void initialize() throw ();
   void finalize() throw ();

   // Returns the max. number of denials until a user is locked out.
   // If zero, then account lockout is disabled.
   DWORD getMaxDenials() const throw ()
   { return maxDenials; }

   // Create and return a new sub-key.
   HKEY createEntry(PCWSTR subKeyName) throw ();

   // Open and return an existing sub-key.
   HKEY openEntry(PCWSTR subKeyName) throw ();

   // Delete a sub-key.
   void deleteEntry(PCWSTR subKeyName) throw ()
   { RegDeleteKey(hLockout, subKeyName); }

protected:
   // Deletes all sub-keys.
   void clear() throw ();

   // Deletes all expired sub-keys if the collection interval has passed.
   void collectGarbage() throw ();

   // Read the key's values.
   void readValues() throw ();

private:
   DWORD maxDenials;           // Max. number of denials.
   DWORD refCount;             // Initialization ref. count.
   HKEY hLockout;              // Registry key.
   HANDLE hChangeEvent;        // Change notification event.
   HANDLE hRegisterWait;       // RTL event registration.
   ULONGLONG ttl;              // Time-To-Live for sub-keys.
   ULONGLONG lastCollection;   // Last time we collected garbage.

   // Key change notification routine.
   static VOID NTAPI onChange(PVOID context, BOOLEAN flag) throw ();

   // Not implemented.
   LockoutKey(const LockoutKey&);
   LockoutKey& operator=(const LockoutKey&);
};

#endif  // _LOCKKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\mschaperror.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    mschaperror.h
//
// SYNOPSIS
//
//    Declares the class MSChapErrorReporter.
//
// MODIFICATION HISTORY
//
//    12/03/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MSCHAPERROR_H_
#define _MSCHAPERROR_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iastl.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    MSChapErrorReporter
//
// DESCRIPTION
//
//    Implements a request handler for populating MS-CHAP-Error VSAs.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE MSChapErrorReporter
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<MSChapErrorReporter, &__uuidof(MSChapErrorReporter)>
{
public:

IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_MSCHAP_ERROR)
IAS_DECLARE_REGISTRY(MSChapErrorReporter, 1, 0, IASTypeLibrary)

BEGIN_IAS_RESPONSE_MAP()
   IAS_RESPONSE_ENTRY(IAS_RESPONSE_ACCESS_REJECT)
END_IAS_RESPONSE_MAP()

protected:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();
};

#endif  // _MSCHAPERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\ntsamauth.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ntsamauth.h
//
// SYNOPSIS
//
//    Declares the class NTSamAuthentication.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef NTSAMAUTH_H
#define NTSAMAUTH_H

#include <iastl.h>

namespace IASTL
{
   class IASRequest;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTSamAuthentication
//
// DESCRIPTION
//
//    This class implements a request handler for authenticating users against
//    the SAM database.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NTSamAuthentication
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<NTSamAuthentication, &__uuidof(NTSamAuthentication)>
{
public:

IAS_DECLARE_REGISTRY(NTSamAuthentication, 1, 0, IASTypeLibrary)

   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

   // These functions are public so they can be used for change password.
   static bool enforceLmRestriction(
                  IASTL::IASRequest& request
                  );
   static void doMsChapAuthentication(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  BYTE identity,
                  PBYTE challenge,
                  PBYTE ntResponse,
                  PBYTE lmResponse
                  );
   static void doMsChap2Authentication(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  BYTE identity,
                  IAS_OCTET_STRING& challenge,
                  PBYTE response,
                  PBYTE peerChallenge
                  );

private:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   // Helper functions to store various attributes.
   static void storeAuthenticationType(
                  IASTL::IASRequest& request,
                  DWORD authType
                  );
   static void storeLogonResult(
                  IASTL::IASRequest& request,
                  DWORD status,
                  HANDLE token,
                  const LARGE_INTEGER& kickOffTime
                  );
   static void storeTokenGroups(
                  IASTL::IASRequest& request,
                  HANDLE token
                  );

   // Various flavors of MS-CHAPv1
   static bool tryMsChap(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  PBYTE challenge
                  );
   static bool tryMsChapCpw1(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  PBYTE challenge
                  );
   static bool tryMsChapCpw2(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  PBYTE challenge
                  );

   // Various flavors of MS-CHAPv2
   static bool tryMsChap2(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  IAS_OCTET_STRING& challenge
                  );
   static bool tryMsChap2Cpw(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username,
                  IAS_OCTET_STRING& challenge
                  );

   // Various authentication types supported by NTLM.
   static bool tryMd5Chap(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );
   static bool tryMsChapAll(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );
   static bool tryMsChap2All(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );
   static bool tryPap(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );

   static bool allowLM;
};

#endif  // NTSAMAUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\ntsamauth.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class NTSamAuthentication.
//
///////////////////////////////////////////////////////////////////////////////
#include <ias.h>
#include <ntsamauth.h>
#include <autohdl.h>
#include <blob.h>
#include <iaslsa.h>
#include <iastlutl.h>
#include <lockout.h>
#include <mbstring.h>
#include <samutil.h>
#include <sdoias.h>

bool NTSamAuthentication::allowLM;

STDMETHODIMP NTSamAuthentication::Initialize()
{
   DWORD error = IASLsaInitialize();
   if (error == NO_ERROR)
   {
      AccountLockoutInitialize();
   }

   return HRESULT_FROM_WIN32(error);
}


STDMETHODIMP NTSamAuthentication::Shutdown()
{
   AccountLockoutShutdown();
   IASLsaUninitialize();
   return S_OK;
}


STDMETHODIMP NTSamAuthentication::PutProperty(LONG Id, VARIANT *pValue)
{
   if (Id == PROPERTY_NTSAM_ALLOW_LM_AUTHENTICATION &&
       pValue != NULL &&
       V_VT(pValue) == VT_BOOL)
   {
      allowLM = V_BOOL(pValue) ? true : false;
      IASTracePrintf(
         "Setting LM Authentication allowed to %s.",
         (allowLM ? "TRUE" : "FALSE")
         );
   }

   return S_OK;
}


bool NTSamAuthentication::enforceLmRestriction(
                             IASTL::IASRequest& request
                             )
{
   if (!allowLM)
   {
      IASTraceString("LanManager authentication is not enabled.");
      IASProcessFailure(request, IAS_LM_NOT_ALLOWED);
   }

   return allowLM;
}


void NTSamAuthentication::doMsChapAuthentication(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             BYTE identity,
                             PBYTE challenge,
                             PBYTE ntResponse,
                             PBYTE lmResponse
                             )
{
   DWORD status;
   auto_handle<> token;
   IAS_MSCHAP_PROFILE profile;
   status = IASLogonMSCHAP(
               username,
               domainName,
               challenge,
               ntResponse,
               lmResponse,
               &profile,
               &token
               );

   if (status == NO_ERROR)
   {
      MSChapMPPEKeys::insert(
                         request,
                         profile.LanmanSessionKey,
                         profile.UserSessionKey,
                         challenge
                         );
      MSChapDomain::insert(
                       request,
                       identity,
                       profile.LogonDomainName
                       );
   }

   storeLogonResult(request, status, token, profile.KickOffTime);
}


void NTSamAuthentication::doMsChap2Authentication(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             BYTE identity,
                             IAS_OCTET_STRING& challenge,
                             PBYTE response,
                             PBYTE peerChallenge
                             )
{
   //////////
   // Get the hash username.
   //////////

   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            IAS_ATTRIBUTE_ORIGINAL_USER_NAME,
                            IASTYPE_OCTET_STRING
                            );
   if (!attr)
   {
      attr = IASPeekAttribute(
                 request,
                 RADIUS_ATTRIBUTE_USER_NAME,
                 IASTYPE_OCTET_STRING
                 );
      if (!attr)
      {
         _com_issue_error(IAS_MALFORMED_REQUEST);
      }
   }

   PCSTR rawUserName = IAS_OCT2ANSI(attr->Value.OctetString);
   PCSTR hashUserName = (PCSTR)_mbschr((const BYTE*)rawUserName, '\\');
   hashUserName = hashUserName ? (hashUserName + 1) : rawUserName;

   //////////
   // Authenticate the user.
   //////////

   DWORD status;
   auto_handle<> token;
   IAS_MSCHAP_V2_PROFILE profile;
   status = IASLogonMSCHAPv2(
                username,
                domainName,
                hashUserName,
                challenge.lpValue,
                challenge.dwLength,
                response,
                peerChallenge,
                &profile,
                &token
                );

   //////////
   // Process the result.
   //////////

   if (status == NO_ERROR)
   {
      MSMPPEKey::insert(
                     request,
                     sizeof(profile.RecvSessionKey),
                     profile.RecvSessionKey,
                     FALSE
                     );

      MSMPPEKey::insert(
                     request,
                     sizeof(profile.SendSessionKey),
                     profile.SendSessionKey,
                     TRUE
                     );

      MSChap2Success::insert(
                          request,
                          identity,
                          profile.AuthResponse
                          );

      MSChapDomain::insert(
                        request,
                        identity,
                        profile.LogonDomainName
                        );
   }

   storeLogonResult(request, status, token, profile.KickOffTime);
}


IASREQUESTSTATUS NTSamAuthentication::onSyncRequest(IRequest* pRequest) throw ()
{
   HANDLE hAccount = 0;

   try
   {
      IASTL::IASRequest request(pRequest);

      //////////
      // Extract the NT4-Account-Name attribute.
      //////////

      IASTL::IASAttribute identity;
      if (!identity.load(
                       request,
                       IAS_ATTRIBUTE_NT4_ACCOUNT_NAME,
                       IASTYPE_STRING
                       ))
      {
         return IAS_REQUEST_STATUS_CONTINUE;
      }

      //////////
      // Convert the User-Name to SAM format.
      //////////

      SamExtractor extractor(*identity);
      PCWSTR domain = extractor.getDomain();
      PCWSTR username = extractor.getUsername();

      IASTracePrintf(
         "NT-SAM Authentication handler received request for %S\\%S.",
         domain,
         username
         );

      //////////
      // Check if the account has been locked out.
      //////////

      if (AccountLockoutOpenAndQuery(
              username,
              domain,
              &hAccount
              ))
      {
         IASTraceString("Account has been locked out locally -- rejecting.");
         AccountLockoutClose(hAccount);
         request.SetResponse(IAS_RESPONSE_ACCESS_REJECT, IAS_DIALIN_LOCKED_OUT);
         return IAS_REQUEST_STATUS_CONTINUE;
      }

      // Try each authentication type.
      if (!tryMsChap2All(request, domain, username) &&
          !tryMsChapAll(request, domain, username) &&
          !tryMd5Chap(request, domain, username) &&
          !tryPap(request, domain, username))
      {
         // Since the EAP request handler is invoked after policy
         // evaluation, we have to set the auth type here.
         if (IASPeekAttribute(
                 request,
                 RADIUS_ATTRIBUTE_EAP_MESSAGE,
                 IASTYPE_OCTET_STRING
                 ))
         {
            storeAuthenticationType(request, IAS_AUTH_EAP);
         }
         else
         {
            // Otherwise, the auth type is "Unauthenticated".
            storeAuthenticationType(request, IAS_AUTH_NONE);
         }
      }

      //////////
      // Update the lockout database based on the results.
      //////////

      if (request.get_Response() == IAS_RESPONSE_ACCESS_ACCEPT)
      {
         AccountLockoutUpdatePass(hAccount);
      }
      else if (request.get_Reason() == IAS_AUTH_FAILURE)
      {
         AccountLockoutUpdateFail(hAccount);
      }
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      IASProcessFailure(pRequest, ce.Error());
   }

   AccountLockoutClose(hAccount);

   return IAS_REQUEST_STATUS_CONTINUE;
}


void NTSamAuthentication::storeAuthenticationType(
                             IASTL::IASRequest& request,
                             DWORD authType
                             )
{
   IASTL::IASAttribute attr(true);
   attr->dwId = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
   attr->Value.itType = IASTYPE_ENUM;
   attr->Value.Enumerator = authType;
   attr.store(request);
}


void NTSamAuthentication::storeLogonResult(
                             IASTL::IASRequest& request,
                             DWORD status,
                             HANDLE token,
                             const LARGE_INTEGER& kickOffTime
                             )
{
   if (status == ERROR_SUCCESS)
   {
      IASTraceString("LogonUser succeeded.");
      storeTokenGroups(request, token);
      request.SetResponse(IAS_RESPONSE_ACCESS_ACCEPT, S_OK);

      // Add the Session-Timeout attribute to the request if it is not infinite
      // it'll be carried over to the response later on.
      InsertInternalTimeout(request, kickOffTime);
   }
   else
   {
      IASTraceFailure("LogonUser", status);
      IASProcessFailure(request, IASMapWin32Error(status, IAS_AUTH_FAILURE));
   }
}


void NTSamAuthentication::storeTokenGroups(
                             IASTL::IASRequest& request,
                             HANDLE token
                             )
{
   DWORD returnLength;

   //////////
   // Determine the needed buffer size.
   //////////

   BOOL success = GetTokenInformation(
                      token,
                      TokenGroups,
                      NULL,
                      0,
                      &returnLength
                      );

   DWORD status = GetLastError();

   // Should have failed with ERROR_INSUFFICIENT_BUFFER.
   if (success || status != ERROR_INSUFFICIENT_BUFFER)
   {
      IASTraceFailure("GetTokenInformation", status);
      _com_issue_error(HRESULT_FROM_WIN32(status));
   }

   //////////
   // Allocate an attribute.
   //////////

   IASTL::IASAttribute groups(true);

   //////////
   // Allocate a buffer to hold the TOKEN_GROUPS array.
   //////////

   groups->Value.OctetString.lpValue = (PBYTE)CoTaskMemAlloc(returnLength);
   if (!groups->Value.OctetString.lpValue)
   {
      _com_issue_error(E_OUTOFMEMORY);
   }

   //////////
   // Get the Token Groups info.
   //////////

   GetTokenInformation(
       token,
       TokenGroups,
       groups->Value.OctetString.lpValue,
       returnLength,
       &groups->Value.OctetString.dwLength
       );

   //////////
   // Set the id and type of the initialized attribute.
   //////////

   groups->dwId = IAS_ATTRIBUTE_TOKEN_GROUPS;
   groups->Value.itType = IASTYPE_OCTET_STRING;

   //////////
   // Inject the Token-Groups into the request.
   //////////

   groups.store(request);
}


bool NTSamAuthentication::tryMsChap(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             PBYTE challenge
                             )
{
   // Is the necessary attribute present?
   IASAttribute attr;
   if (!attr.load(
                request,
                MS_ATTRIBUTE_CHAP_RESPONSE,
                IASTYPE_OCTET_STRING
                ))
   {
      return false;
   }
   MSChapResponse& response = blob_cast<MSChapResponse>(attr);

   IASTraceString("Processing MS-CHAP v1 authentication.");
   storeAuthenticationType(request, IAS_AUTH_MSCHAP);

   if (!response.isLmPresent() || enforceLmRestriction(request))
   {
      doMsChapAuthentication(
         request,
         domainName,
         username,
         response.get().ident,
         challenge,
         (response.isNtPresent() ? response.get().ntResponse : NULL),
         (response.isLmPresent() ? response.get().lmResponse : NULL)
         );
   }

   return true;
}


bool NTSamAuthentication::tryMsChapCpw1(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             PBYTE challenge
                             )
{
   // Is the necessary attribute present ?
   IASAttribute attr;
   bool present = attr.load(
                          request,
                          MS_ATTRIBUTE_CHAP_CPW1,
                          IASTYPE_OCTET_STRING
                          );
   if (present)
   {
      IASTraceString("Deferring MS-CHAP-CPW-1.");
      storeAuthenticationType(request, IAS_AUTH_MSCHAP_CPW);
   }

   return present;
}


bool NTSamAuthentication::tryMsChapCpw2(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             PBYTE challenge
                             )
{
   // Is the necessary attribute present ?
   IASAttribute attr;
   bool present = attr.load(
                          request,
                          MS_ATTRIBUTE_CHAP_CPW2,
                          IASTYPE_OCTET_STRING
                          );
   if (present)
   {
      IASTraceString("Deferring MS-CHAP-CPW-2.");
      storeAuthenticationType(request, IAS_AUTH_MSCHAP_CPW);
   }

   return present;
}


bool NTSamAuthentication::tryMsChap2(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             IAS_OCTET_STRING& challenge
                             )
{
   // Is the necessary attribute present?
   IASAttribute attr;
   if (!attr.load(
                request,
                MS_ATTRIBUTE_CHAP2_RESPONSE,
                IASTYPE_OCTET_STRING
                ))
   {
      return false;
   }
   MSChap2Response& response = blob_cast<MSChap2Response>(attr);

   IASTraceString("Processing MS-CHAP v2 authentication.");
   storeAuthenticationType(request, IAS_AUTH_MSCHAP2);

   //////////
   // Authenticate the user.
   //////////

   doMsChap2Authentication(
      request,
      domainName,
      username,
      response.get().ident,
      challenge,
      response.get().response,
      response.get().peerChallenge
      );

   return true;
}


bool NTSamAuthentication::tryMsChap2Cpw(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username,
                             IAS_OCTET_STRING& challenge
                             )
{
   // Is the necessary attribute present ?
   IASAttribute attr;
   bool present = attr.load(
                          request,
                          MS_ATTRIBUTE_CHAP2_CPW,
                          IASTYPE_OCTET_STRING
                          );
   if (present)
   {
      IASTraceString("Deferring MS-CHAP v2 change password.");
      storeAuthenticationType(request, IAS_AUTH_MSCHAP2_CPW);
   }

   return present;
}


bool NTSamAuthentication::tryMd5Chap(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username
                             )
{
   // Is the necessary attribute present?
   IASTL::IASAttribute chapPassword;
   if (!chapPassword.load(
                        request,
                        RADIUS_ATTRIBUTE_CHAP_PASSWORD,
                        IASTYPE_OCTET_STRING
                        ))
   {
      return false;
   }

   IASTraceString("Processing MD5-CHAP authentication.");
   storeAuthenticationType(request, IAS_AUTH_MD5CHAP);

   // validate length of the octetstring is 17
   DWORD chapPasswordLength = chapPassword->Value.OctetString.dwLength;

   if (chapPasswordLength != (_CHAP_RESPONSE_SIZE + 1))
   {
      IASTracePrintf("Malformed request: Length of CHAP_PASSWORD is %ld",
                     chapPasswordLength);
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   //////////
   // Split up the CHAP-Password attribute.
   //////////

   // The ID is the first byte of the value ...
   BYTE challengeID = *(chapPassword->Value.OctetString.lpValue);

   // ... and the password is the rest.
   PBYTE password = chapPassword->Value.OctetString.lpValue + 1;

   //////////
   // Use the CHAP-Challenge if available, request authenticator otherwise.
   //////////

   IASTL::IASAttribute chapChallenge, radiusHeader;
   if (!chapChallenge.load(
                         request,
                         RADIUS_ATTRIBUTE_CHAP_CHALLENGE,
                         IASTYPE_OCTET_STRING
                         ) &&
       !radiusHeader.load(
                        request,
                        IAS_ATTRIBUTE_CLIENT_PACKET_HEADER,
                        IASTYPE_OCTET_STRING
                        ))
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   PBYTE challenge;
   DWORD challengeLength;

   if (chapChallenge)
   {
      challenge = chapChallenge->Value.OctetString.lpValue;
      challengeLength = chapChallenge->Value.OctetString.dwLength;
   }
   else
   {
      challenge = radiusHeader->Value.OctetString.lpValue + 4;
      challengeLength = 16;
   }


   //////////
   // Try to logon the user.
   //////////

   IAS_CHAP_PROFILE profile;
   auto_handle<> token;
   DWORD status = IASLogonCHAP(
                     username,
                     domainName,
                     challengeID,
                     challenge,
                     challengeLength,
                     password,
                     &token,
                     &profile
                     );

   //////////
   // Store the results.
   //////////
   storeLogonResult(request, status, token, profile.KickOffTime);

   return true;
}


bool NTSamAuthentication::tryMsChapAll(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username
                             )
{
   // Do we have the necessary attribute?
   IASTL::IASAttribute msChapChallenge;
   if (!msChapChallenge.load(
                           request,
                           MS_ATTRIBUTE_CHAP_CHALLENGE,
                           IASTYPE_OCTET_STRING
                           ))
   {
      return false;
   }

   if (msChapChallenge->Value.OctetString.dwLength != _MSV1_0_CHALLENGE_LENGTH)
   {
      _com_issue_error(IAS_MALFORMED_REQUEST);
   }

   PBYTE challenge = msChapChallenge->Value.OctetString.lpValue;

   return tryMsChap(request, domainName, username, challenge) ||
          tryMsChapCpw2(request, domainName, username, challenge) ||
          tryMsChapCpw1(request, domainName, username, challenge);
}


bool NTSamAuthentication::tryMsChap2All(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username
                             )
{
   // Do we have the necessary attribute?
   IASTL::IASAttribute msChapChallenge;
   if (!msChapChallenge.load(
                           request,
                           MS_ATTRIBUTE_CHAP_CHALLENGE,
                           IASTYPE_OCTET_STRING
                           ))
   {
      return false;
   }

   IAS_OCTET_STRING& challenge = msChapChallenge->Value.OctetString;

   return tryMsChap2(request, domainName, username, challenge) ||
          tryMsChap2Cpw(request, domainName, username, challenge);
}


bool NTSamAuthentication::tryPap(
                             IASTL::IASRequest& request,
                             PCWSTR domainName,
                             PCWSTR username
                             )
{
   // Do we have the necessary attribute?
   IASTL::IASAttribute password;
   if (!password.load(
                    request,
                    RADIUS_ATTRIBUTE_USER_PASSWORD,
                    IASTYPE_OCTET_STRING
                    ))
   {
      return false;
   }

   IASTraceString("Processing PAP authentication.");
   storeAuthenticationType(request, IAS_AUTH_PAP);

   //////////
   // Convert the password to a string.
   //////////

   PSTR userPwd = IAS_OCT2ANSI(password->Value.OctetString);

   //////////
   // Try to logon the user.
   //////////

   IAS_PAP_PROFILE profile;
   auto_handle<> token;
   DWORD status = IASLogonPAP(
                     username,
                     domainName,
                     userPwd,
                     &token,
                     &profile
                     );

   //////////
   // Store the results.
   //////////
   storeLogonResult(request, status, token, profile.KickOffTime);

   return true;
}

void InsertInternalTimeout(
        IASTL::IASRequest& request,
        const LARGE_INTEGER& kickOffTime
        )

{
   if ((kickOffTime.QuadPart < MAXLONGLONG) && (kickOffTime.QuadPart >= 0))
   {
      LONGLONG now;
      GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&now));

      // Compute the interval in seconds.
      LONGLONG interval = (kickOffTime.QuadPart - now) / 10000000i64;
      if (interval <= 0)
      {
         interval = 1;
      }

      if (interval < 0xFFFFFFFF)
      {
         IASAttribute sessionTimeout(true);
         sessionTimeout->dwId = MS_ATTRIBUTE_SESSION_TIMEOUT;
         sessionTimeout->Value.itType = IASTYPE_INTEGER;
         sessionTimeout->Value.Integer = static_cast<DWORD>(interval);
         sessionTimeout.store(request);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\basecamp.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class BaseCampHostBase and its children.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef BASECAMP_H
#define BASECAMP_H
#pragma once

#include "authif.h"

#include "iastl.h"
#include "iastlutl.h"
using namespace IASTL;

#include "vsafilter.h"

#include "ExtensionPoint.h"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    BaseCampHostBase
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE BaseCampHostBase : public IASRequestHandlerSync
{
public:
   BaseCampHostBase(RADIUS_EXTENSION_POINT extensionPoint) throw ();

   // Use compiler-generated version.
   // ~BaseCampHostBase() throw ();

   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();

protected:
   // Main request processing routine.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

private:
   VSAFilter filter;
   RADIUS_EXTENSION_POINT point;
   RadiusExtensionPoint extensions;

   // Not implemented.
   BaseCampHostBase(const BaseCampHostBase&);
   BaseCampHostBase& operator=(const BaseCampHostBase&);
};


inline BaseCampHostBase::BaseCampHostBase(
                            RADIUS_EXTENSION_POINT extensionPoint
                            ) throw ()
   : point(extensionPoint)
{
}


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    BaseCampHost
//
// DESCRIPTION
//
//    Host for Authentication DLLs.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE BaseCampHost :
   public BaseCampHostBase,
   public CComCoClass<BaseCampHost, &__uuidof(BaseCampHost)>
{
public:

IAS_DECLARE_REGISTRY(BaseCampHost, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)
IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_BASECAMP_HOST)

   BaseCampHost() throw ()
      : BaseCampHostBase(repAuthentication)
   { }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AuthorizationHost
//
// DESCRIPTION
//
//    Host for Authorization DLLs.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE AuthorizationHost :
   public BaseCampHostBase,
   public CComCoClass<AuthorizationHost, &__uuidof(AuthorizationHost)>
{
public:

IAS_DECLARE_REGISTRY(AuthorizationHost, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)
IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_AUTHORIZATION_HOST)

   AuthorizationHost() throw ()
      : BaseCampHostBase(repAuthorization)
   { }
};

#endif  // BASECAMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\basecamp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class BaseCampHostBase.
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "ias.h"
#include "basecamp.h"
#include "ControlBlock.h"

STDMETHODIMP BaseCampHostBase::Initialize()
{
   DWORD error = extensions.Load(point);
   return HRESULT_FROM_WIN32(error);
}

STDMETHODIMP BaseCampHostBase::Shutdown()
{
   extensions.Clear();
   return S_OK;
}

IASREQUESTSTATUS BaseCampHostBase::onSyncRequest(IRequest* pRequest) throw ()
{
   // Early return if there aren't any extensions,
   if (extensions.IsEmpty())
   {
      return IAS_REQUEST_STATUS_CONTINUE;
   }

   try
   {
      IASRequest request(pRequest);

      // Convert VSAs to RADIUS format.
      filter.radiusFromIAS(request);

      // Invoke the extensions.
      extensions.Process(ControlBlock(point, request).Get());

      // Convert VSAs back to internal format.
      filter.radiusToIAS(request);
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
   }

   return IAS_REQUEST_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\controlblock.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class RadiusRequest
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "ias.h"
#include "ControlBlock.h"

namespace
{
   DWORD AsWindowsError(const _com_error& ce) throw ()
   {
      HRESULT error = ce.Error();
      if (HRESULT_FACILITY(error) == FACILITY_WIN32)
      {
         return error & 0x0000FFFF;
      }
      else
      {
         return error;
      }
   }
}

Attribute::Attribute(
              const ATTRIBUTEPOSITION& iasAttr,
              DWORD authIfId
              )
   : ias(iasAttr)
{
   LoadAuthIfFromIas(authIfId);

   // Convert the ratProvider enumeration if necessary.
   if (authIf.dwAttrType == ratProvider)
   {
      switch (ias.getAttribute()->Value.Integer)
      {
         case IAS_PROVIDER_NONE:
         {
            authIf.dwValue = rapNone;
            break;
         }

         case IAS_PROVIDER_WINDOWS:
         {
            authIf.dwValue = rapWindowsNT;
            break;
         }

         case IAS_PROVIDER_RADIUS_PROXY:
         {
            authIf.dwValue = rapProxy;
            break;
         }

         case IAS_PROVIDER_EXTERNAL_AUTH:
         {
            authIf.dwValue = rapProxy;
            break;
         }

         default:
         {
            authIf.dwValue = rapUnknown;
            break;
         }
      }
   }
}


Attribute::Attribute(
              const ATTRIBUTEPOSITION& iasAttr,
              const RADIUS_ATTRIBUTE& authIfAttr
              ) throw ()
   : authIf(authIfAttr),
     ias(iasAttr)
{
}


Attribute::Attribute(
              const RADIUS_ATTRIBUTE& authIfAttr,
              DWORD flags,
              DWORD iasId
              )
{
   // First create a new IAS attribute.
   IASAttribute newAttr(true);
   newAttr->dwFlags = flags;
   newAttr->dwId = iasId;

   switch (authIfAttr.fDataType)
   {
      case rdtAddress:
      {
         newAttr->Value.itType = IASTYPE_INET_ADDR;
         newAttr->Value.InetAddr = authIfAttr.dwValue;
         break;
      }

      case rdtInteger:
      case rdtTime:
      {
         newAttr->Value.itType = IASTYPE_INTEGER;
         newAttr->Value.InetAddr = authIfAttr.dwValue;
         break;
      }

      case rdtString:
      {
         if (IsIasString(newAttr->dwId))
         {
            newAttr.setString(
                       authIfAttr.cbDataLength,
                       reinterpret_cast<const BYTE*>(authIfAttr.lpValue)
                       );
         }
         else
         {
            newAttr.setOctetString(
                       authIfAttr.cbDataLength,
                       reinterpret_cast<const BYTE*>(authIfAttr.lpValue)
                       );
         }
         break;
      }

      default:
      {
         issue_error(E_INVALIDARG);
         break;
      }
   }

   ias = newAttr;

   // Initialize our AuthIf attribute from the IAS attribute. This ensures that
   // we're referencing the copied memory instead of the caller supplied
   // memory.
   LoadAuthIfFromIas(authIfAttr.dwAttrType);

   // Convert the ratProvider enumeration if necessary.
   if (authIf.dwAttrType == ratProvider)
   {
      switch (authIf.dwValue)
      {
         case rapNone:
         {
            ias.getAttribute()->Value.Integer = IAS_PROVIDER_NONE;
            break;
         }

         case rapWindowsNT:
         {
            ias.getAttribute()->Value.Integer = IAS_PROVIDER_WINDOWS;
            break;
         }

         case rapProxy:
         {
            ias.getAttribute()->Value.Integer = IAS_PROVIDER_RADIUS_PROXY;
            break;
         }

         default:
         {
            issue_error(E_INVALIDARG);
            break;
         }
      }
   }
}


void Attribute::LoadAuthIfFromIas(DWORD authIfId)
{
   authIf.dwAttrType = authIfId;

   IASATTRIBUTE* src = ias.getAttribute();

   switch (src->Value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      {
         authIf.fDataType = rdtInteger;
         authIf.cbDataLength = sizeof(DWORD);
         authIf.dwValue = src->Value.Integer;
         break;
      }

      case IASTYPE_INET_ADDR:
      {
         authIf.fDataType = rdtAddress;
         authIf.cbDataLength = sizeof(DWORD);
         authIf.dwValue = src->Value.InetAddr;
         break;
      }

      case IASTYPE_STRING:
      {
         DWORD error = IASAttributeAnsiAlloc(src);
         if (error != NO_ERROR)
         {
            issue_error(HRESULT_FROM_WIN32(error));
         }
         authIf.fDataType = rdtString;
         authIf.cbDataLength = strlen(src->Value.String.pszAnsi) + 1;
         authIf.lpValue = src->Value.String.pszAnsi;
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         authIf.fDataType = rdtString;
         authIf.cbDataLength = src->Value.OctetString.dwLength;
         authIf.lpValue = reinterpret_cast<const char*>(
                             src->Value.OctetString.lpValue
                             );
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         DWORDLONG val;

         // Move in the high DWORD.
         val = src->Value.UTCTime.dwHighDateTime;
         val <<= 32;

         // Move in the low DWORD.
         val |= src->Value.UTCTime.dwLowDateTime;

         // Convert to the UNIX epoch.
         val -= 116444736000000000ui64;

         // Convert to seconds.
         val /= 10000000;

         authIf.fDataType = rdtTime;
         authIf.cbDataLength = sizeof(DWORD);
         authIf.dwValue = static_cast<DWORD>(val);
         break;
      }

      default:
      {
         // This is some IAS data type that AuthIf extensions don't know about;
         // just give them an empty attribute.
         authIf.fDataType = rdtString;
         authIf.cbDataLength = 0;
         authIf.lpValue = 0;
         break;
      }
   }
}


bool Attribute::IsIasString(DWORD iasId) throw ()
{
   bool isString;

   switch (iasId)
   {
      // RADIUS attributes are always stored as octet strings, so we only have
      // to worry about internal attributes.
      case IAS_ATTRIBUTE_NT4_ACCOUNT_NAME:
      case IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME:
      case IAS_ATTRIBUTE_NP_NAME:
      {
         isString = true;
         break;
      }

      default:
      {
         isString = false;
         break;
      }
   }

   return isString;
}


AttributeArray::AttributeArray(IASRequest& request)
   : source(request),
     name(0),
     wasCracked(false)
{
   vtbl.cbSize = sizeof(vtbl);
   vtbl.Add = Add;
   vtbl.AttributeAt = AttributeAt;
   vtbl.GetSize = GetSize;
   vtbl.InsertAt = InsertAt;
   vtbl.RemoveAt = RemoveAt;
   vtbl.SetAt = SetAt;
}


void AttributeArray::Assign(
                        const char* arrayName,
                        RADIUS_CODE arrayType,
                        const IASAttributeVector& attrs
                        )
{
   // Reset the array.
   array.clear();

   name = arrayName;

   // Determine our flags based on the array type.
   switch (arrayType)
   {
      case rcAccessAccept:
         flags = IAS_INCLUDE_IN_ACCEPT;
         break;

      case rcAccessReject:
         flags = IAS_INCLUDE_IN_REJECT;
         break;

      case rcAccessChallenge:
         flags = IAS_INCLUDE_IN_CHALLENGE;
         break;

      default:
         flags = 0;
         break;
   }

   // Select our attributes and add them to the array.
   for (IASAttributeVector::const_iterator i = attrs.begin();
        i != attrs.end();
        ++i)
   {
      const IASATTRIBUTE& attr = *(i->pAttribute);
      if (Classify(attr) == arrayType)
      {
         switch (attr.dwId)
         {
            case RADIUS_ATTRIBUTE_USER_NAME:
            {
               AppendUserName(attrs, *i);
               break;
            }

            case IAS_ATTRIBUTE_CLIENT_PACKET_HEADER:
            {
               AppendPacketHeader(attrs, *i);
               break;
            }

            case IAS_ATTRIBUTE_NT4_ACCOUNT_NAME:
            {
               wasCracked = true;
               // Fall through.
            }
            default:
            {
               DWORD authIfId = ConvertIasToAuthIf(attr.dwId);
               if (authIfId != ratMinimum)
               {
                  Append(*i, authIfId);
               }
               break;
            }
         }
      }
   }

   // If this is a request array, add the ratUniqueId if necessary.
   if ((arrayType == rcAccessRequest) && (Find(ratUniqueId) == 0))
   {
      static long nextId;

      RADIUS_ATTRIBUTE uniqueId;
      uniqueId.dwAttrType = ratUniqueId;
      uniqueId.fDataType = rdtInteger;
      uniqueId.cbDataLength = sizeof(DWORD);
      uniqueId.dwValue = static_cast<DWORD>(InterlockedIncrement(&nextId));

      array.push_back(Attribute(uniqueId, 0, IAS_ATTRIBUTE_REQUEST_ID));
   }
}


RADIUS_CODE AttributeArray::Classify(const IASATTRIBUTE& attr) throw ()
{
   if (attr.dwId < 256)
   {
      if ((attr.dwFlags & IAS_INCLUDE_IN_ACCEPT) != 0)
      {
         return rcAccessAccept;
      }

      if ((attr.dwFlags & IAS_INCLUDE_IN_REJECT) != 0)
      {
         return rcAccessReject;
      }

      if ((attr.dwFlags & IAS_INCLUDE_IN_CHALLENGE) != 0)
      {
         return rcAccessChallenge;
      }
   }

   return rcAccessRequest;
}


DWORD AttributeArray::ConvertIasToAuthIf(DWORD iasId) throw ()
{
   DWORD authIfId;

   if (iasId < 256)
   {
      authIfId = iasId;
   }
   else
   {
      switch (iasId)
      {
         case IAS_ATTRIBUTE_CLIENT_IP_ADDRESS:
            authIfId = ratSrcIPAddress;
            break;

         case IAS_ATTRIBUTE_CLIENT_UDP_PORT:
            authIfId = ratSrcPort;
            break;

         case IAS_ATTRIBUTE_ORIGINAL_USER_NAME:
            authIfId = ratUserName;
            break;

         case IAS_ATTRIBUTE_NT4_ACCOUNT_NAME:
            authIfId = ratStrippedUserName;
            break;

         case IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME:
            authIfId = ratFQUserName;
            break;

         case IAS_ATTRIBUTE_NP_NAME:
            authIfId = ratPolicyName;
            break;

         case IAS_ATTRIBUTE_PROVIDER_TYPE:
            authIfId = ratProvider;
            break;

         case IAS_ATTRIBUTE_EXTENSION_STATE:
            authIfId = ratExtensionState;
            break;

         default:
            authIfId = ratMinimum;
            break;
      }
   }

   return authIfId;
}


DWORD AttributeArray::ConvertAuthIfToIas(DWORD authIfId) throw ()
{
   DWORD iasId;

   if (authIfId < 256)
   {
      iasId = authIfId;
   }
   else
   {
      switch (authIfId)
      {
         case ratSrcIPAddress:
             iasId = IAS_ATTRIBUTE_CLIENT_IP_ADDRESS;
            break;

         case ratSrcPort:
            iasId = IAS_ATTRIBUTE_CLIENT_UDP_PORT;
            break;

         case ratFQUserName:
            iasId = IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME;
            break;

         case ratPolicyName:
            iasId = IAS_ATTRIBUTE_NP_NAME;
            break;

         case ratExtensionState:
            iasId = IAS_ATTRIBUTE_EXTENSION_STATE;
            break;

         default:
            iasId = ATTRIBUTE_UNDEFINED;
            break;
      }
   }

   return iasId;
}


bool AttributeArray::IsReadOnly(DWORD authIfId) throw ()
{
   bool retval;

   if (authIfId < 256)
   {
      retval = false;
   }
   else
   {
      switch (authIfId)
      {
         case ratCode:
         case ratIdentifier:
         case ratAuthenticator:
         case ratSrcIPAddress:
         case ratSrcPort:
         case ratUniqueId:
            retval = true;
            break;

         default:
            retval = false;
            break;
      }
   }

   return retval;
}


inline void AttributeArray::Append(
                               const ATTRIBUTEPOSITION& attr,
                               DWORD authIfId
                               )
{
   array.push_back(Attribute(attr, authIfId));
}


void AttributeArray::AppendUserName(
                        const IASAttributeVector& attrs,
                        const ATTRIBUTEPOSITION& attr
                        )
{
   // For IAS, RADIUS_ATTRIBUTE_USER_NAME contains the RADIUS User-Name with
   // any attribute manipulation rules applied.

   // For AuthIf, ratUserName must contain the original RADIUS User-Name sent
   // by the client, and ratStrippedUserName must contain the User-Name after
   // attribute manipulation *and* name cracking.

   if (!attrs.contains(IAS_ATTRIBUTE_ORIGINAL_USER_NAME))
   {
      // The User-Name hasn't been stripped, so the RADIUS_ATTRIBUTE_USER_NAME
      // is the ratUserName.
      Append(attr, ratUserName);
   }
   else if (!attrs.contains(IAS_ATTRIBUTE_NT4_ACCOUNT_NAME))
   {
      // The User-Name has been stripped, but it hasn't been cracked, so the
      // RADIUS_ATTRIBUTE_USER_NAME is the ratStrippedUserName.
      Append(attr, ratStrippedUserName);
   }
   // Otherwise, the User-Name has been stripped and cracked, so
   // RADIUS_ATTRIBUTE_USER_NAME is ignored. In this case, ratUserName contains
   // IAS_ATTRIBUTE_ORIGINAL_USER_NAME, and ratStrippedUserName contains
   // IAS_ATTRIBUTE_NT4_ACCOUNT_NAME.
}


void AttributeArray::AppendPacketHeader(
                        const IASAttributeVector& attrs,
                        const ATTRIBUTEPOSITION& attr
                        )
{
   RADIUS_ATTRIBUTE authIfAttr;

   // Get the RADIUS identifier from the header.
   authIfAttr.dwAttrType = ratIdentifier;
   authIfAttr.fDataType = rdtInteger;
   authIfAttr.cbDataLength = sizeof(DWORD);
   authIfAttr.dwValue = *static_cast<const BYTE*>(
                            attr.pAttribute->Value.OctetString.lpValue + 1
                            );

   array.push_back(Attribute(attr, authIfAttr));

   // If the request doesn't contain a Chap-Challenge, then get the
   // authenticator from the header.
   if (!attrs.contains(RADIUS_ATTRIBUTE_CHAP_CHALLENGE))
   {
      authIfAttr.dwAttrType = ratAuthenticator;
      authIfAttr.fDataType = rdtString;
      authIfAttr.cbDataLength = 16;
      authIfAttr.lpValue = reinterpret_cast<const char*>(
                              attr.pAttribute->Value.OctetString.lpValue + 4
                              );
      array.push_back(Attribute(attr, authIfAttr));
   }
}


inline const AttributeArray* AttributeArray::Narrow(
                                                const RADIUS_ATTRIBUTE_ARRAY* p
                                                ) throw ()
{
   return reinterpret_cast<const AttributeArray*>(p);
}


inline AttributeArray* AttributeArray::Narrow(
                                          RADIUS_ATTRIBUTE_ARRAY* p
                                          ) throw ()
{
   return reinterpret_cast<AttributeArray*>(p);
}


const Attribute* AttributeArray::Find(DWORD authIfId) const throw ()
{
   for (std::vector<Attribute>::const_iterator i = array.begin();
        i != array.end();
        ++i)
   {
      if (i->AsAuthIf()->dwAttrType == authIfId)
      {
         return i;
      }
   }

   return 0;
}


void AttributeArray::StripUserNames() throw ()
{
   // An extension is stripping the User-Name, so preserve any existing
   // RADIUS_ATTRIBUTE_USER_NAME attributes.
   for (std::vector<Attribute>::iterator i = array.begin();
        i != array.end();
        ++i)
   {
      if (i->AsIas()->pAttribute->dwId == RADIUS_ATTRIBUTE_USER_NAME)
      {
         i->AsIas()->pAttribute->dwId = IAS_ATTRIBUTE_ORIGINAL_USER_NAME;
      }
   }
}


void AttributeArray::UnstripUserNames() throw ()
{
   // An extension is unstripping the User-Name, so revert any existing
   // IAS_ATTRIBUTE_ORIGINAL_USER_NAME attributes.
   for (std::vector<Attribute>::iterator i = array.begin();
        i != array.end();
        ++i)
   {
      if (i->AsIas()->pAttribute->dwId == IAS_ATTRIBUTE_ORIGINAL_USER_NAME)
      {
         i->AsIas()->pAttribute->dwId = RADIUS_ATTRIBUTE_USER_NAME;
      }
   }
}


inline void AttributeArray::Add(const RADIUS_ATTRIBUTE& attr)
{
   InsertAt(array.size(), attr);
}


inline const RADIUS_ATTRIBUTE* AttributeArray::AttributeAt(
                                                  DWORD dwIndex
                                                  ) const throw ()
{
   return (dwIndex < array.size()) ? array[dwIndex].AsAuthIf() : 0;
}


inline DWORD AttributeArray::GetSize() const throw ()
{
   return array.size();
}


void AttributeArray::InsertAt(
                        DWORD dwIndex,
                        const RADIUS_ATTRIBUTE& attr
                        )
{
   if (dwIndex > array.size())
   {
      issue_error(E_INVALIDARG);
   }

   // Determine the IAS id for this attribute.
   DWORD iasId;
   if (attr.dwAttrType == ratStrippedUserName)
   {
      if (Find(ratStrippedUserName) != 0)
      {
         // We can't have two stripped usernames.
         issue_error(E_ACCESSDENIED);
      }

      if (wasCracked)
      {
         iasId = IAS_ATTRIBUTE_NT4_ACCOUNT_NAME;
      }
      else
      {
         StripUserNames();
         iasId = RADIUS_ATTRIBUTE_USER_NAME;
      }
   }
   else if (attr.dwAttrType == ratUserName)
   {
      // If there's already a ratUserName attribute, then this attribute should
      // use the same ID (either RADIUS_ATTRIBUTE_USER_NAME or
      // IAS_ATTRIBUTE_ORIGINAL_USER_NAME). Otherwise, its the first
      // ratUserName, so it always goes to RADIUS_ATTRIBUTE_USER_NAME.
      const Attribute* existing = Find(ratUserName);
      iasId = (existing != 0) ? existing->AsIas()->pAttribute->dwId
                              : RADIUS_ATTRIBUTE_USER_NAME;
   }
   else if (IsReadOnly(attr.dwAttrType))
   {
      issue_error(E_ACCESSDENIED);
   }
   else
   {
      iasId = ConvertAuthIfToIas(attr.dwAttrType);
      if (iasId == ATTRIBUTE_UNDEFINED)
      {
         issue_error(E_INVALIDARG);
      }
   }

   Attribute newAttr(attr, flags, iasId);
   if (dwIndex == array.size())
   {
      source.AddAttributes(1, newAttr.AsIas());
      array.push_back(newAttr);
   }
   else
   {
      source.InsertBefore(newAttr.AsIas(), array[dwIndex].AsIas());
      array.insert(array.begin() + dwIndex, newAttr);
   }
}


void AttributeArray::RemoveAt(DWORD dwIndex)
{
   if (dwIndex >= array.size())
   {
      issue_error(E_INVALIDARG);
   }

   Attribute& target = array[dwIndex];

   if (target.AsAuthIf()->dwAttrType == ratStrippedUserName)
   {
      if (target.AsIas()->pAttribute->dwId == RADIUS_ATTRIBUTE_USER_NAME)
      {
         UnstripUserNames();
      }
      // Otherwise, extension is removing IAS_ATTRIBUTE_NT4_ACCOUNT_NAME.
   }
   else if (IsReadOnly(target.AsAuthIf()->dwAttrType))
   {
      issue_error(E_ACCESSDENIED);
   }

   source.RemoveAttributes(1, array[dwIndex].AsIas());
   array.erase(array.begin() + dwIndex);
}


inline void AttributeArray::SetAt(
                               DWORD dwIndex,
                               const RADIUS_ATTRIBUTE& attr
                               )
{
   RemoveAt(dwIndex);
   InsertAt(dwIndex, attr);
}


DWORD AttributeArray::Add(
                         RADIUS_ATTRIBUTE_ARRAY* This,
                         const RADIUS_ATTRIBUTE *pAttr
                         ) throw ()
{
   if ((This == 0) || (pAttr == 0))
   {
      return ERROR_INVALID_PARAMETER;
   }

   IASTracePrintf(
      "RADIUS_ATTRIBUTE_ARRAY.Add(%s, %lu)",
      Narrow(This)->name,
      pAttr->dwAttrType
      );

   try
   {
      Narrow(This)->Add(*pAttr);
   }
   catch (const std::bad_alloc&)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   catch (const _com_error& ce)
   {
      return AsWindowsError(ce);
   }

   return NO_ERROR;
}


const RADIUS_ATTRIBUTE* AttributeArray::AttributeAt(
                                           const RADIUS_ATTRIBUTE_ARRAY* This,
                                           DWORD dwIndex
                                           ) throw ()
{
   return (This != 0) ? Narrow(This)->AttributeAt(dwIndex) : 0;
}


DWORD AttributeArray::GetSize(
                         const RADIUS_ATTRIBUTE_ARRAY* This
                         ) throw ()
{
   return (This != 0) ? Narrow(This)->GetSize() : 0;
}


DWORD AttributeArray::InsertAt(
                         RADIUS_ATTRIBUTE_ARRAY* This,
                         DWORD dwIndex,
                         const RADIUS_ATTRIBUTE* pAttr
                         ) throw ()
{
   if ((This == 0) || (pAttr == 0))
   {
      return ERROR_INVALID_PARAMETER;
   }

   IASTracePrintf(
      "RADIUS_ATTRIBUTE_ARRAY.InsertAt(%s, %lu, %lu)",
      Narrow(This)->name,
      dwIndex,
      pAttr->dwAttrType
      );

   try
   {
      Narrow(This)->InsertAt(dwIndex, *pAttr);
   }
   catch (const std::bad_alloc&)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   catch (const _com_error& ce)
   {
      return AsWindowsError(ce);
   }

   return NO_ERROR;
}


DWORD AttributeArray::RemoveAt(
                         RADIUS_ATTRIBUTE_ARRAY* This,
                         DWORD dwIndex
                         ) throw ()
{
   if (This == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   IASTracePrintf(
      "RADIUS_ATTRIBUTE_ARRAY.RemoveAt(%s, %lu)",
      Narrow(This)->name,
      dwIndex
      );

   try
   {
      Narrow(This)->RemoveAt(dwIndex);
   }
   catch (const std::bad_alloc&)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   catch (const _com_error& ce)
   {
      return AsWindowsError(ce);
   }

   return NO_ERROR;
}


DWORD AttributeArray::SetAt(
                         RADIUS_ATTRIBUTE_ARRAY* This,
                         DWORD dwIndex,
                         const RADIUS_ATTRIBUTE *pAttr
                         ) throw ()
{
   if ((This == 0) || (pAttr == 0))
   {
      return ERROR_INVALID_PARAMETER;
   }

   IASTracePrintf(
      "RADIUS_ATTRIBUTE_ARRAY.SetAt(%s, %lu, %lu)",
      Narrow(This)->name,
      dwIndex,
      pAttr->dwAttrType
      );

   try
   {
      Narrow(This)->SetAt(dwIndex, *pAttr);
   }
   catch (const std::bad_alloc&)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   catch (const _com_error& ce)
   {
      return AsWindowsError(ce);
   }

   return NO_ERROR;
}


ControlBlock::ControlBlock(
                 RADIUS_EXTENSION_POINT point,
                 IASRequest& request
                 )
   : source(request),
     requestAttrs(request),
     acceptAttrs(request),
     rejectAttrs(request),
     challengeAttrs(request)
{
   ecb.cbSize = sizeof(ecb);
   ecb.dwVersion = RADIUS_EXTENSION_VERSION;
   ecb.repPoint = point;

   // Friendly names for arrays.
   const char* requestName;
   const char* successName;

   // Set the request type.
   switch (source.get_Request())
   {
      case IAS_REQUEST_ACCESS_REQUEST:
         ecb.rcRequestType = rcAccessRequest;
         requestName = "rcAccessRequest";
         successName = "rcAccessAccept";
         break;

      case IAS_REQUEST_ACCOUNTING:
         ecb.rcRequestType = rcAccountingRequest;
         requestName = "rcAccountingRequest";
         successName = "rcAccountingResponse";
         break;

      default:
         ecb.rcRequestType = rcUnknown;
         requestName = "rcUnknown";
         successName = "rcAccessAccept";
         break;
   }

   // Set the response type.
   switch (source.get_Response())
   {
      case IAS_RESPONSE_ACCESS_ACCEPT:
         ecb.rcResponseType = rcAccessAccept;
         break;

      case IAS_RESPONSE_ACCESS_REJECT:
         ecb.rcResponseType = rcAccessReject;
         break;

      case IAS_RESPONSE_ACCESS_CHALLENGE:
         ecb.rcResponseType = rcAccessChallenge;
         break;

      case IAS_RESPONSE_ACCOUNTING:
         ecb.rcResponseType = rcAccountingResponse;
         break;

      case IAS_RESPONSE_DISCARD_PACKET:
         ecb.rcResponseType = rcDiscard;
         break;

      default:
         ecb.rcResponseType = rcUnknown;
         break;
   }

   // Fill in the vtbl.
   ecb.GetRequest = GetRequest;
   ecb.GetResponse = GetResponse;
   ecb.SetResponseType = SetResponseType;

   // Initialize the attribute vectors.
   IASAttributeVector attrs;
   attrs.load(source);
   requestAttrs.Assign(requestName, rcAccessRequest, attrs);
   acceptAttrs.Assign(successName, rcAccessAccept,attrs);
   rejectAttrs.Assign("rcAccessReject", rcAccessReject, attrs);
   challengeAttrs.Assign("rcAccessChallenge", rcAccessChallenge, attrs);
}


inline ControlBlock* ControlBlock::Narrow(
                                      RADIUS_EXTENSION_CONTROL_BLOCK* p
                                      ) throw ()
{
   return reinterpret_cast<ControlBlock*>(p);
}


void ControlBlock::AddAuthType()
{
   // First, remove any existing auth type because now the extension is making
   // the authoritative decision.
   DWORD attrId = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
   source.RemoveAttributesByType(1, &attrId);

   IASAttribute authType(true);
   authType->dwId = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
   authType->Value.itType = IASTYPE_ENUM;
   authType->Value.Enumerator = IAS_AUTH_CUSTOM;

   authType.store(source);
}


inline RADIUS_ATTRIBUTE_ARRAY* ControlBlock::GetRequest() throw ()
{
   return requestAttrs.Get();
}


inline RADIUS_ATTRIBUTE_ARRAY* ControlBlock::GetResponse(
                                                RADIUS_CODE rcResponseType
                                                ) throw ()
{
   switch (MAKELONG(ecb.rcRequestType, rcResponseType))
   {
      case MAKELONG(rcAccessRequest, rcAccessAccept):
         // Fall through.
      case MAKELONG(rcAccountingRequest, rcAccessAccept):
         // Fall through.
      case MAKELONG(rcAccountingRequest, rcAccountingResponse):
         // Fall through.
      case MAKELONG(rcAccountingRequest, rcUnknown):
         return acceptAttrs.Get();

      case MAKELONG(rcAccountingRequest, rcAccessReject):
         // Fall through.
      case MAKELONG(rcAccessRequest, rcAccessReject):
         return rejectAttrs.Get();

      case MAKELONG(rcAccessRequest, rcAccessChallenge):
         return challengeAttrs.Get();

      default:
         // like (anything, rcUnknown). Should not happen
         return 0;   
   }
}


DWORD ControlBlock::SetResponseType(RADIUS_CODE rcResponseType) throw ()
{
   if (rcResponseType == ecb.rcResponseType)
   {
      return NO_ERROR;
   }

   switch (MAKELONG(ecb.rcRequestType, rcResponseType))
   {
      case MAKELONG(rcAccessRequest, rcAccessAccept):
         source.SetResponse(
                   IAS_RESPONSE_ACCESS_ACCEPT,
                   S_OK
                   );
         AddAuthType();
         break;

      case MAKELONG(rcAccountingRequest, rcAccountingResponse):
         source.SetResponse(
                   IAS_RESPONSE_ACCOUNTING,
                   S_OK
                   );
         break;

      case MAKELONG(rcAccessRequest, rcAccessReject):
         source.SetResponse(
                   IAS_RESPONSE_ACCESS_REJECT,
                   IAS_EXTENSION_REJECT
                   );
         AddAuthType();
         break;

      case MAKELONG(rcAccessRequest, rcAccessChallenge):
         source.SetResponse(
                   IAS_RESPONSE_ACCESS_CHALLENGE,
                   S_OK
                   );
         break;

      case MAKELONG(rcAccessRequest, rcDiscard):
         // fall through.
      case MAKELONG(rcAccountingRequest, rcDiscard):
         source.SetResponse(
                   IAS_RESPONSE_DISCARD_PACKET,
                   IAS_EXTENSION_DISCARD
                   );
         break;

      default:
         return ERROR_INVALID_PARAMETER;
   }

   ecb.rcResponseType = rcResponseType;
   return NO_ERROR;
}


RADIUS_ATTRIBUTE_ARRAY* ControlBlock::GetRequest(
                                         RADIUS_EXTENSION_CONTROL_BLOCK* This
                                         ) throw ()
{
   return (This != 0) ? Narrow(This)->GetRequest() : 0;
}


RADIUS_ATTRIBUTE_ARRAY* ControlBlock::GetResponse(
                                         RADIUS_EXTENSION_CONTROL_BLOCK* This,
                                         RADIUS_CODE rcResponseType
                                         ) throw ()
{
   return (This != 0) ? Narrow(This)->GetResponse(rcResponseType) : 0;
}


DWORD ControlBlock::SetResponseType(
                       RADIUS_EXTENSION_CONTROL_BLOCK* This,
                       RADIUS_CODE rcResponseType
                       ) throw ()
{
   if (This == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   IASTracePrintf(
      "RADIUS_EXTENSION_CONTROL_BLOCK.SetResponseType(%lu)",
      rcResponseType
      );

   return Narrow(This)->SetResponseType(rcResponseType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\ntsamuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class AccountValidation.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <ntsamuser.h>
#include <autohdl.h>
#include <iaslsa.h>
#include <iasntds.h>
#include <iastlutl.h>
#include <lmaccess.h>
#include <samutil.h>
#include <sdoias.h>

//////////
// Attributes that should be retrieved for each user.
//////////
const PCWSTR PER_USER_ATTRS[] =
{
   L"userAccountControl",
   L"accountExpires",
   L"logonHours",
   L"tokenGroups",
   L"objectSid",
   NULL
};


//////////
//
// Process an LDAP response.
//
// Based on the empirical evidence, it seems that userAccountControl and
// accountExpires are always present while logonHours is optional. However,
// none of these attributes are marked as mandatory in the LDAP schema.  Since
// we have already done a rudimentary access check at bind, we will allow any
// of these attributes to be absent.
//
//////////
inline
DWORD
ValidateLdapResponse(
    IASTL::IASRequest& request,
    LDAPMessage* msg
    )
{
   // Retrieve the connection for this message.
   LDAP* ld = ldap_conn_from_msg(NULL, msg);

   PWCHAR *str;
   PLDAP_BERVAL *data1, *data2;

   // There is exactly one entry.
   LDAPMessage* e = ldap_first_entry(ld, msg);

   //////////
   // Check the UserAccountControl flags.
   //////////

   ULONG userAccountControl;
   str = ldap_get_valuesW(ld, e, L"userAccountControl");
   if (str)
   {
      userAccountControl = (ULONG)_wtoi64(*str);
      ldap_value_freeW(str);

      if (userAccountControl & UF_ACCOUNTDISABLE)
      {
         return ERROR_ACCOUNT_DISABLED;
      }

      if (userAccountControl & UF_LOCKOUT)
      {
         return ERROR_ACCOUNT_LOCKED_OUT;
      }
   }

   //////////
   // Retrieve AccountExpires.
   //////////

   LARGE_INTEGER accountExpires;
   str = ldap_get_valuesW(ld, e, L"accountExpires");
   if (str)
   {
      accountExpires.QuadPart = _wtoi64(*str);
      ldap_value_freeW(str);
   }
   else
   {
      accountExpires.QuadPart = 0;
   }

   //////////
   // Retrieve LogonHours.
   //////////

   IAS_LOGON_HOURS logonHours;
   data1 = ldap_get_values_lenW(ld, e, L"logonHours");
   if (data1 != NULL)
   {
      logonHours.UnitsPerWeek = 8 * (USHORT)data1[0]->bv_len;
      logonHours.LogonHours = (PUCHAR)data1[0]->bv_val;
   }
   else
   {
      logonHours.UnitsPerWeek = 0;
      logonHours.LogonHours = NULL;
   }

   //////////
   // Check the account restrictions.
   //////////

   DWORD status;
   LARGE_INTEGER sessionTimeout;
   status = IASCheckAccountRestrictions(
                &accountExpires,
                &logonHours,
                &sessionTimeout
                );

   InsertInternalTimeout(request, sessionTimeout);

   ldap_value_free_len(data1);

   if (status != NO_ERROR) { return status; }

   //////////
   // Retrieve tokenGroups and objectSid.
   //////////

   data1 = ldap_get_values_lenW(ld, e, L"tokenGroups");
   data2 = ldap_get_values_lenW(ld, e, L"objectSid");

   PTOKEN_GROUPS allGroups;
   ULONG length;
   if (data1 && data2)
   {
      // Allocate memory for the TOKEN_GROUPS struct.
      ULONG numGroups = ldap_count_values_len(data1);
      PTOKEN_GROUPS tokenGroups =
         (PTOKEN_GROUPS)_alloca(
                           FIELD_OFFSET(TOKEN_GROUPS, Groups) +
                           sizeof(SID_AND_ATTRIBUTES) * numGroups
                           );

      // Store the number of groups.
      tokenGroups->GroupCount = numGroups;

      // Store the group SIDs.
      for (ULONG i = 0; i < numGroups; ++i)
      {
         tokenGroups->Groups[i].Sid = (PSID)data1[i]->bv_val;
         tokenGroups->Groups[i].Attributes = SE_GROUP_ENABLED;
      }

      // Expand the group membership locally.
      status = IASGetAliasMembership(
                   (PSID)data2[0]->bv_val,
                   tokenGroups,
                   CoTaskMemAlloc,
                   &allGroups,
                   &length
                   );
   }
   else
   {
      status = ERROR_ACCESS_DENIED;
   }

   ldap_value_free_len(data1);
   ldap_value_free_len(data2);

   if (status != NO_ERROR) { return status; }

   //////////
   // Initialize and store the attribute.
   //////////

   IASTL::IASAttribute attr(true);
   attr->dwId = IAS_ATTRIBUTE_TOKEN_GROUPS;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.dwLength = length;
   attr->Value.OctetString.lpValue = (PBYTE)allGroups;

   attr.store(request);

   return NO_ERROR;
}


HRESULT AccountValidation::Initialize()
{
   return IASNtdsInitialize();
}


HRESULT AccountValidation::Shutdown() throw ()
{
   IASNtdsUninitialize();
   return S_OK;
}


IASREQUESTSTATUS AccountValidation::onSyncRequest(IRequest* pRequest) throw ()
{
   try
   {
      IASTL::IASRequest request(pRequest);

      //////////
      // Only process requests that don't have Token-Groups already.
      //////////

      IASTL::IASAttribute tokenGroups;
      if (!tokenGroups.load(
                         request,
                         IAS_ATTRIBUTE_TOKEN_GROUPS,
                         IASTYPE_OCTET_STRING
                         ))
      {
         //////////
         // Extract the NT4-Account-Name attribute.
         //////////

         IASTL::IASAttribute identity;
         if (identity.load(
                         request,
                         IAS_ATTRIBUTE_NT4_ACCOUNT_NAME,
                         IASTYPE_STRING
                         ))
         {
            //////////
            // Convert the User-Name to SAM format.
            //////////

            SamExtractor extractor(*identity);
            PCWSTR domain = extractor.getDomain();
            PCWSTR username = extractor.getUsername();

            IASTracePrintf(
               "Validating Windows account %S\\%S.",
               domain,
               username
               );

            //////////
            // Validate the account.
            //////////

            if (!tryNativeMode(request, domain, username))
            {
               doDownlevel(request, domain, username);
            }
         }
      }
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      IASProcessFailure(pRequest, ce.Error());
   }

   return IAS_REQUEST_STATUS_CONTINUE;
}


void AccountValidation::doDownlevel(
                           IASTL::IASRequest& request,
                           PCWSTR domainName,
                           PCWSTR username
                           )
{
   IASTraceString("Using downlevel APIs to validate account.");

   //////////
   // Inject the user's groups.
   //////////

   IASTL::IASAttribute groups(true);

   DWORD status;
   LARGE_INTEGER sessionTimeout;
   status = IASGetGroupsForUser(
               username,
               domainName,
               &CoTaskMemAlloc,
               (PTOKEN_GROUPS*)&groups->Value.OctetString.lpValue,
               &groups->Value.OctetString.dwLength,
               &sessionTimeout
               );

   InsertInternalTimeout(request, sessionTimeout);

   if (status == NO_ERROR)
   {
      // Insert the groups.
      groups->dwId = IAS_ATTRIBUTE_TOKEN_GROUPS;
      groups->Value.itType = IASTYPE_OCTET_STRING;
      groups.store(request);

      IASTraceString("Successfully validated account.");
   }
   else
   {
      IASTraceFailure("IASGetGroupsForUser", status);
      status = IASMapWin32Error(status, IAS_SERVER_UNAVAILABLE);
      IASProcessFailure(request, status);
   }
}


bool AccountValidation::tryNativeMode(
                           IASTL::IASRequest& request,
                           PCWSTR domainName,
                           PCWSTR username
                           )
{
   //////////
   // Only handle domain users.
   //////////

   if (IASGetRole() != IAS_ROLE_DC && IASIsDomainLocal(domainName))
   {
      return false;
   }

   //////////
   // Query the DS.
   //////////

   DWORD error;
   IASNtdsResult result;
   error = IASNtdsQueryUserAttributes(
               domainName,
               username,
               LDAP_SCOPE_BASE,
               const_cast<PWCHAR*>(PER_USER_ATTRS),
               &result
               );

   switch (error)
   {
      case NO_ERROR:
      {
         // We got something back, so validate the response.
         error = ValidateLdapResponse(request, result.msg);
         if (error == NO_ERROR)
         {
            IASTraceString("Successfully validated account.");
            return true;
         }

         IASTraceFailure("ValidateLdapResponse", error);
         break;
      }

      case ERROR_DS_NOT_INSTALLED:
      case ERROR_INVALID_DOMAIN_ROLE:
      {
         // No DS, so we can't handle.
         return false;
      }

      default:
      {
         // We have a DS for this user, but we can't talk to it.
         break;
      }
   }

   IASProcessFailure(
      request,
      IASMapWin32Error(error, IAS_DOMAIN_UNAVAILABLE)
      );

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\controlblock.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class RadiusRequest
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CONTROLBLOCK_H
#define CONTROLBLOCK_H
#pragma once

#include "authif.h"
#include "iastlutl.h"
#include <vector>

using namespace IASTL;


// Binds a RADIUS_ATTRIBUTE to an ATTRIBUTEPOSITION. Any dynamically allocated
// memory always belongs to the IASATTRIBUTE contained in the
// ATTRIBUTEPOSITION. The RADIUS_ATTRIBUTE lpValue member simply references
// this memory.
class Attribute
{
public:
   // Create from an existing IAS attribute.
   Attribute(
      const ATTRIBUTEPOSITION& iasAttr,
      DWORD authIfId
      );

   // Create from an existing IAS attribute, but the caller controls the
   // conversion. Any memory referenced by authIfAttr is not copied and thus
   // must reference memory contained within the IAS attribute.
   Attribute(
      const ATTRIBUTEPOSITION& iasAttr,
      const RADIUS_ATTRIBUTE& authIfAttr
      ) throw ();

   // Create from a RADIUS_ATTRIBUTE specified by an extension DLL, allocating
   // a new IAS attribute in the process. Any memory referenced by authIfAttr
   // is copied.
   Attribute(
      const RADIUS_ATTRIBUTE& authIfAttr,
      DWORD flags,
      DWORD iasId
      );

   // Use compiler-generated versions.
   // Attribute(const Attribute&);
   // ~Attribute() throw ();
   // Attribute& operator=(const Attribute&);

   RADIUS_ATTRIBUTE* AsAuthIf() throw ();
   const RADIUS_ATTRIBUTE* AsAuthIf() const throw ();

   ATTRIBUTEPOSITION* AsIas() throw ();
   const ATTRIBUTEPOSITION* AsIas() const throw ();

private:
   // Initialize the fields of 'authIf' from the fields of 'ias'.
   void LoadAuthIfFromIas(DWORD authIfId);

   // Returns true if the specified IAS has type IASTYPE_STRING.
   static bool IsIasString(DWORD iasId) throw ();

   RADIUS_ATTRIBUTE authIf;
   IASAttributePosition ias;
};


// Implements the RADIUS_ATTRIBUTE_ARRAY interface passed to extensions.
class AttributeArray
{
public:
   AttributeArray(IASRequest& request);

   // Assign the attributes that will be managed by this array. The arrayName
   // is used solely for tracing. The arrayType determines which attributes
   // will be selected from the IASAttributeVector.
   void Assign(
           const char* arrayName,
           RADIUS_CODE arrayType,
           const IASAttributeVector& attrs
           );

   RADIUS_ATTRIBUTE_ARRAY* Get() throw ();

private:
   // Determine which array type the attribute belongs to.
   static RADIUS_CODE Classify(const IASATTRIBUTE& attr) throw ();

   // Various dictionary functions.
   static DWORD ConvertIasToAuthIf(DWORD iasId) throw ();
   static DWORD ConvertAuthIfToIas(DWORD authIfId) throw ();
   static bool IsReadOnly(DWORD authIdId) throw ();

   // Append a new attribute to the array.
   void Append(
           const ATTRIBUTEPOSITION& attr,
           DWORD authIfId
           );

   // Some IAS attributes have to be special-cased.
   void AppendUserName(
           const IASAttributeVector& attrs,
           const ATTRIBUTEPOSITION& attr
           );
   void AppendPacketHeader(
           const IASAttributeVector& attrs,
           const ATTRIBUTEPOSITION& attr
           );

   // Convert extension structs to the implementation class.
   static const AttributeArray* Narrow(
                                   const RADIUS_ATTRIBUTE_ARRAY* p
                                   ) throw ();
   static AttributeArray* Narrow(
                             RADIUS_ATTRIBUTE_ARRAY* p
                             ) throw ();

   // Find an attribute based on the AuthIf ID.
   const Attribute* Find(DWORD authIfId) const throw ();

   // Convert between original and stripped user names.
   void StripUserNames() throw ();
   void UnstripUserNames() throw ();

   // The RADIUS_ATTRIBUTE_ARRAY interface.
   void Add(const RADIUS_ATTRIBUTE& attr);
   const RADIUS_ATTRIBUTE* AttributeAt(DWORD dwIndex) const throw ();
   DWORD GetSize() const throw ();
   void InsertAt(DWORD dwIndex, const RADIUS_ATTRIBUTE& attr);
   void RemoveAt(DWORD dwIndex);
   void SetAt(DWORD dwIndex, const RADIUS_ATTRIBUTE& attr);

   // Callback functions passed to extensions.
   static DWORD Add(
                   RADIUS_ATTRIBUTE_ARRAY* This,
                   const RADIUS_ATTRIBUTE *pAttr
                   ) throw ();
   static const RADIUS_ATTRIBUTE* AttributeAt(
                                     const RADIUS_ATTRIBUTE_ARRAY* This,
                                     DWORD dwIndex
                                     ) throw ();
   static DWORD GetSize(
                   const RADIUS_ATTRIBUTE_ARRAY* This
                   ) throw ();
   static DWORD InsertAt(
                   RADIUS_ATTRIBUTE_ARRAY* This,
                   DWORD dwIndex,
                   const RADIUS_ATTRIBUTE* pAttr
                   ) throw ();
   static DWORD RemoveAt(
                   RADIUS_ATTRIBUTE_ARRAY* This,
                   DWORD dwIndex
                   ) throw ();
   static DWORD SetAt(
                   RADIUS_ATTRIBUTE_ARRAY* This,
                   DWORD dwIndex,
                   const RADIUS_ATTRIBUTE *pAttr
                   ) throw ();

   // 'vtbl' must be the first member variable, so that we can cast from a
   // RADIUS_ATTRIBUTE_ARRAY* to an AttributeArray*.
   RADIUS_ATTRIBUTE_ARRAY vtbl;
   IASRequest source;
   const char* name;
   // Flags that will be used for new attributes.
   DWORD flags;
   std::vector<Attribute> array;
   // true if the username was cracked, i.e., it has been processed by the
   // names handler and contains IAS_ATTRIBUTE_NT4_ACCOUNT_NAME.
   bool wasCracked;
};


// Implements the RADIUS_EXTENSION_CONTROL_BLOCK interface passed to
// extensions.
class ControlBlock
{
public:
   ControlBlock(RADIUS_EXTENSION_POINT point, IASRequest& request);

   RADIUS_EXTENSION_CONTROL_BLOCK* Get() throw ();

private:
   // Convert extension structs to the implementation class.
   static ControlBlock* Narrow(RADIUS_EXTENSION_CONTROL_BLOCK* p) throw ();

   // Add the Extension authentication type to the request.
   void AddAuthType();

   // The RADIUS_EXTENSION_CONTROL_BLOCK interface.
   RADIUS_ATTRIBUTE_ARRAY* GetRequest() throw ();
   RADIUS_ATTRIBUTE_ARRAY* GetResponse(RADIUS_CODE rcResponseType) throw ();
   DWORD SetResponseType(RADIUS_CODE rcResponseType) throw ();

   // Callback functions passed to extensions.
   static RADIUS_ATTRIBUTE_ARRAY* GetRequest(
                                     RADIUS_EXTENSION_CONTROL_BLOCK* This
                                     ) throw ();
   static RADIUS_ATTRIBUTE_ARRAY* GetResponse(
                                     RADIUS_EXTENSION_CONTROL_BLOCK* This,
                                     RADIUS_CODE rcResponseType
                                     ) throw ();
   static DWORD SetResponseType(
                   RADIUS_EXTENSION_CONTROL_BLOCK* This,
                   RADIUS_CODE rcResponseType
                   ) throw ();

   RADIUS_EXTENSION_CONTROL_BLOCK ecb;  // Must be the first member variable.
   IASRequest source;
   AttributeArray requestAttrs;
   AttributeArray acceptAttrs;
   AttributeArray rejectAttrs;
   AttributeArray challengeAttrs;
};


inline RADIUS_ATTRIBUTE* Attribute::AsAuthIf() throw ()
{
   return &authIf;
}


inline const RADIUS_ATTRIBUTE* Attribute::AsAuthIf() const throw ()
{
   return &authIf;
}


inline ATTRIBUTEPOSITION* Attribute::AsIas() throw ()
{
   return &ias;
}


inline const ATTRIBUTEPOSITION* Attribute::AsIas() const throw ()
{
   return &ias;
}


inline RADIUS_ATTRIBUTE_ARRAY* AttributeArray::Get() throw ()
{
   return &vtbl;
}


inline RADIUS_EXTENSION_CONTROL_BLOCK* ControlBlock::Get() throw ()
{
   return &ecb;
}

#endif // CONTROLBLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\auth\ntsamuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ntsamuser.h
//
// SYNOPSIS
//
//    Declares the class AccountValidation.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef NTSAMUSER_H
#define NTSAMUSER_H

#include <iastl.h>

namespace IASTL
{
   class IASRequest;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AccountValidation
//
// DESCRIPTION
//
//    Implements the NT-SAM Account Validation and Groups handler.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE AccountValidation
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<AccountValidation, &__uuidof(AccountValidation)>
{
public:

IAS_DECLARE_REGISTRY(AccountValidation, 1, 0, IASTypeLibrary)

   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();

private:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   static void doDownlevel(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );

   static bool tryNativeMode(
                  IASTL::IASRequest& request,
                  PCWSTR domainName,
                  PCWSTR username
                  );
};

#endif  // NTSAMUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\extension.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class RadiusExtension
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EXTENSION_H
#define EXTENSION_H
#pragma once

#include "authif.h"

// Wrapper around an extension DLL.
class RadiusExtension
{
public:
   RadiusExtension() throw ();
   ~RadiusExtension() throw ();

   // Load the extension DLL.
   DWORD Load(const wchar_t* dllPath) throw ();

   // Process a request.
   DWORD Process(RADIUS_EXTENSION_CONTROL_BLOCK* ecb) const throw ();

private:
   wchar_t* name;      // Module name; used for tracing.
   HINSTANCE module;   // Module handle.
   bool initialized;   // Has the module been successfully initialized ?

   // DLL entry points.
   PRADIUS_EXTENSION_INIT RadiusExtensionInit;
   PRADIUS_EXTENSION_TERM RadiusExtensionTerm;
   PRADIUS_EXTENSION_PROCESS RadiusExtensionProcess;
   PRADIUS_EXTENSION_PROCESS_EX RadiusExtensionProcessEx;
   PRADIUS_EXTENSION_FREE_ATTRIBUTES RadiusExtensionFreeAttributes;
   PRADIUS_EXTENSION_PROCESS_2 RadiusExtensionProcess2;

   // Flags to indicate which actions are allowed by old-style extensions.
   static const unsigned acceptAllowed = 0x1;
   static const unsigned rejectAllowed = 0x2;

   // Functions to create the attribute arrays used by old-style extensions.
   static RADIUS_ATTRIBUTE* CreateExtensionAttributes(
                               RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                               ) throw ();
   static RADIUS_ATTRIBUTE* CreateAuthorizationAttributes(
                               RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                               ) throw ();

   // Not implemented.
   RadiusExtension(const RadiusExtension&);
   RadiusExtension& operator=(const RadiusExtension&);
};

// Helper function to extract just the file name from a path.
const wchar_t* ExtractFileNameFromPath(const wchar_t* path) throw ();

#endif  // EXTENSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\extension.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class RadiusExtension
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "ias.h"
#include "new"
#include "extension.h"

RadiusExtension::RadiusExtension() throw ()
   : name(0),
     module(0),
     initialized(false),
     RadiusExtensionInit(0),
     RadiusExtensionTerm(0),
     RadiusExtensionProcess(0),
     RadiusExtensionProcessEx(0),
     RadiusExtensionFreeAttributes(0),
     RadiusExtensionProcess2(0)

{
}


RadiusExtension::~RadiusExtension() throw ()
{
   if (initialized && (RadiusExtensionTerm != 0))
   {
      RadiusExtensionTerm();
   }

   if (module != 0)
   {
      FreeLibrary(module);
   }

   delete[] name;
}


// Load the extension DLL.
DWORD RadiusExtension::Load(const wchar_t* dllPath) throw ()
{
   IASTracePrintf("Loading extension %S", dllPath);

   // Save the name of the module.
   const wchar_t* fileName = ExtractFileNameFromPath(dllPath);
   name = new (std::nothrow) wchar_t[wcslen(fileName) + 1];
   if (name == 0)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   wcscpy(name, fileName);

   // Load the extension DLL.
   module = LoadLibraryW(dllPath);
   if (module == 0)
   {
      DWORD error = GetLastError();
      IASTraceFailure("LoadLibraryW", error);
      return error;
   }

   // Look-up the entry points.
   RadiusExtensionInit =
      reinterpret_cast<PRADIUS_EXTENSION_INIT>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_INIT
            )
         );
   RadiusExtensionTerm =
      reinterpret_cast<PRADIUS_EXTENSION_TERM>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_TERM
            )
         );
   RadiusExtensionProcess =
      reinterpret_cast<PRADIUS_EXTENSION_PROCESS>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_PROCESS
            )
         );
   RadiusExtensionProcessEx =
      reinterpret_cast<PRADIUS_EXTENSION_PROCESS_EX>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_PROCESS_EX
            )
         );
   RadiusExtensionFreeAttributes =
      reinterpret_cast<PRADIUS_EXTENSION_FREE_ATTRIBUTES>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_FREE_ATTRIBUTES
            )
         );
   RadiusExtensionProcess2 =
      reinterpret_cast<PRADIUS_EXTENSION_PROCESS_2>(
         GetProcAddress(
            module,
            RADIUS_EXTENSION_PROCESS2
            )
         );

   // Validate the entry points.
   if ((RadiusExtensionProcess == 0) &&
       (RadiusExtensionProcessEx == 0) &&
       (RadiusExtensionProcess2 == 0))
   {
      IASTraceString(
         "Either RadiusExtensionProcess, RadiusExtensionProcessEx, or "
         "RadiusExtensionProcess2 must be defined."
         );
      return ERROR_PROC_NOT_FOUND;
   }
   if ((RadiusExtensionProcessEx != 0) && (RadiusExtensionFreeAttributes == 0))
   {
      IASTraceString(
         "RadiusExtensionFreeAttributes must be defined if "
         "RadiusExtensionProcessEx is defined."
         );
      return ERROR_PROC_NOT_FOUND;
   }

   // Initialize the DLL.
   if (RadiusExtensionInit != 0)
   {
      DWORD error = RadiusExtensionInit();
      if (error != NO_ERROR)
      {
         IASTraceFailure("RadiusExtensionInit", error);
         return error;
      }
   }

   initialized = true;

   return NO_ERROR;
}


DWORD RadiusExtension::Process(
                          RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                          ) const throw ()
{
   IASTracePrintf("Invoking extension %S", name);

   DWORD retval;

   if (RadiusExtensionProcess2 != 0)
   {
      retval = RadiusExtensionProcess2(ecb);
      IASTracePrintf("RadiusExtensionProcess2 returned %lu", retval);
      return retval;
   }

   // Determine the allowed actions and attributes for an old-style extension.
   unsigned allowedActions = 0;
   RADIUS_ATTRIBUTE* inAttrs = 0;
   switch (MAKELONG(ecb->repPoint, ecb->rcResponseType))
   {
      case MAKELONG(repAuthentication, rcUnknown):
      {
         allowedActions = (acceptAllowed | rejectAllowed);
         inAttrs = CreateExtensionAttributes(ecb);
         break;
      }

      case MAKELONG(repAuthorization, rcAccessAccept):
      {
         allowedActions = rejectAllowed;
         inAttrs = CreateAuthorizationAttributes(ecb);
         break;
      }

      case MAKELONG(repAuthentication, rcAccountingResponse):
      {
         inAttrs = CreateExtensionAttributes(ecb);
         break;
      }

      case MAKELONG(repAuthorization, rcAccountingResponse):
      {
         inAttrs = CreateAuthorizationAttributes(ecb);
         break;
      }

      case MAKELONG(repAuthorization, rcUnknown):
      {
         ecb->SetResponseType(ecb, rcAccountingResponse);
         inAttrs = CreateAuthorizationAttributes(ecb);
         break;
      }

      default:
      {
         // This is one of the combinations that doesn't get sent to old-style
         // extensions.
         // old-style Authorization dlls are called only when the return
         // type is known 
         return NO_ERROR;
      }
   }

   if (inAttrs == 0)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   RADIUS_ATTRIBUTE* outAttrs = 0;

   RADIUS_ACTION action = raContinue;
   RADIUS_ACTION* pAction = (allowedActions != 0) ? &action : 0;

   if (RadiusExtensionProcessEx != 0)
   {
      retval = RadiusExtensionProcessEx(inAttrs, &outAttrs, pAction);
      IASTracePrintf("RadiusExtensionProcessEx returned %lu", retval);
   }
   else
   {
      retval = RadiusExtensionProcess(inAttrs, pAction);
      IASTracePrintf("RadiusExtensionProcess returned %lu", retval);
   }

   delete[] inAttrs;

   if (retval != NO_ERROR)
   {
      return retval;
   }

   // Process the action code.
   RADIUS_CODE outAttrDst;
   if ((action == raAccept) && ((allowedActions & acceptAllowed) != 0))
   {
      ecb->SetResponseType(ecb, rcAccessAccept);
      outAttrDst = rcAccessAccept;
   }
   else if ((action == raReject) && ((allowedActions & rejectAllowed) != 0))
   {
      ecb->SetResponseType(ecb, rcAccessReject);
      outAttrDst = rcAccessReject;
   }
   else
   {
      outAttrDst = rcAccessAccept;
   }

   // Insert the returned attributes.
   if (outAttrs != 0)
   {
      RADIUS_ATTRIBUTE_ARRAY* array = ecb->GetResponse(ecb, outAttrDst);
      
      for (RADIUS_ATTRIBUTE* outAttrsIter = outAttrs;
           outAttrsIter->dwAttrType != ratMinimum; 
           ++outAttrsIter)
      {
         retval = array->Add(array, outAttrsIter);
         if (retval != NO_ERROR)
         {
            break;
         }
      }

      RadiusExtensionFreeAttributes(outAttrs);
   }

   return retval;
}


RADIUS_ATTRIBUTE* RadiusExtension::CreateExtensionAttributes(
                                      RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                                      ) throw ()
{
   // ExtensionDLLs just get incoming attributes.
   RADIUS_ATTRIBUTE_ARRAY* request = ecb->GetRequest(ecb);
   size_t numRequestAttrs = request->GetSize(request);

   // Allocate extra space for ratCode and the array terminator.
   size_t numAttrs = numRequestAttrs + 2;
   RADIUS_ATTRIBUTE* attrs = new (std::nothrow) RADIUS_ATTRIBUTE[numAttrs];
   if (attrs == 0)
   {
      return 0;
   }

   RADIUS_ATTRIBUTE* dst = attrs;

   // New style extensions don't use ratCode, so we have to add it ourself.
   dst->dwAttrType = ratCode;
   dst->fDataType = rdtInteger;
   dst->cbDataLength = sizeof(DWORD);
   dst->dwValue = ecb->rcRequestType;
   ++dst;

   // Now add the rest of the incoming attributes.
   for (size_t i = 0; i < numRequestAttrs; ++i)
   {
      *dst = *(request->AttributeAt(request, i));
      ++dst;
   }

   // Finally, add the array terminator.
   dst->dwAttrType = ratMinimum;

   return attrs;
}


RADIUS_ATTRIBUTE* RadiusExtension::CreateAuthorizationAttributes(
                                      RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                                      ) throw ()
{
   // AuthorizationDLLs get internal attributes from the request ...
   RADIUS_ATTRIBUTE_ARRAY* request = ecb->GetRequest(ecb);
   // We're not going to use all the request attributes, but it's easier to
   // just allocate the extra space, rather than looping through the attributes
   // to determine how many we will really use.
   size_t numRequestAttrs = request->GetSize(request);

   // ... and any outgoing attributes.
   RADIUS_ATTRIBUTE_ARRAY* response = ecb->GetResponse(
                                              ecb,
                                              ecb->rcResponseType
                                              );

   // passed a valid type, shoude get an array back
   _ASSERT(response);

   size_t numResponseAttrs = response->GetSize(response);

   // Save space for ratCode and the array terminator.
   size_t numAttrs = numRequestAttrs + numResponseAttrs + 2;
   RADIUS_ATTRIBUTE* attrs = new (std::nothrow) RADIUS_ATTRIBUTE[numAttrs];
   if (attrs == 0)
   {
      return 0;
   }

   RADIUS_ATTRIBUTE* dst = attrs;

   // New style extensions don't use ratCode, so we have to add it ourself.
   dst->dwAttrType = ratCode;
   dst->fDataType = rdtInteger;
   dst->cbDataLength = sizeof(DWORD);
   dst->dwValue = ecb->rcResponseType;
   ++dst;

   // Add internal attributes from the request.
   for (size_t i = 0; i < numRequestAttrs; ++i)
   {
      const RADIUS_ATTRIBUTE* attr = request->AttributeAt(request, i);
      if (attr->dwAttrType > 255)
      {
         *dst = *attr;
         ++dst;
      }
   }

   // Add response attributes.
   for (size_t i = 0; i < numResponseAttrs; ++i)
   {
      *dst = *(response->AttributeAt(response, i));
      ++dst;
   }

   // Finally, add the array terminator.
   dst->dwAttrType = ratMinimum;

   return attrs;
}


const wchar_t* ExtractFileNameFromPath(const wchar_t* path) throw ()
{
   const wchar_t* lastSlash = wcsrchr(path, L'\\');
   return (lastSlash == 0) ? path : (lastSlash + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\extensionpoint.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class RadiusExtensionPoint
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EXTENSIONPOINT_H
#define EXTENSIONPOINT_H
#pragma once

#include "authif.h"

class RadiusExtension;

class RadiusExtensionPoint
{
public:
   RadiusExtensionPoint() throw ();
   ~RadiusExtensionPoint() throw ();

   // Returns true if no extensions are registered for this point.
   bool IsEmpty() const throw ();

   // Loads the specified extension DLLs.
   DWORD Load(RADIUS_EXTENSION_POINT whichDlls) throw ();

   // Process a request.
   void Process(RADIUS_EXTENSION_CONTROL_BLOCK* ecb) const throw ();

   // Unloads the extension DLLs.
   void Clear() throw ();

private:
   // Determines if an extension should only be loaded under NT4.
   static bool IsNT4Only(const wchar_t* path) throw ();

   const wchar_t* name;
   RadiusExtension* begin;
   RadiusExtension* end;

   // Not implemented.
   RadiusExtensionPoint(const RadiusExtensionPoint&);
   RadiusExtensionPoint& operator=(const RadiusExtensionPoint&);
};


inline bool RadiusExtensionPoint::IsEmpty() const throw ()
{
   return begin == end;
}

#endif  // EXTENSIONPOINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\precompiled.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) Microsoft Corporation
//
// SYNOPSIS
//
//      Precompiled Header
//
//////////////////////////////////////////////////////////////////////////////

#ifndef PRECOMPILED_H
#define PRECOMPILED_H
#pragma once

#include "ias.h"
#include "Extension.h"
#include "ControlBlock.h"

#endif  // PRECOMPILED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\basecamp\extensionpoint.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class RadiusExtensionPoint
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "ias.h"
#include "ExtensionPoint.h"
#include "Extension.h"
#include <new>


RadiusExtensionPoint::RadiusExtensionPoint() throw ()
   : name(L""),
     begin(0),
     end(0)
{
}


RadiusExtensionPoint::~RadiusExtensionPoint() throw ()
{
   delete[] begin;
}


DWORD RadiusExtensionPoint::Load(RADIUS_EXTENSION_POINT whichDlls) throw ()
{
   DWORD status = NO_ERROR;
   HKEY key = 0;
   bool ignoreFindNotFound = true;

   do
   {
      name = (whichDlls == repAuthentication) ? AUTHSRV_EXTENSIONS_VALUE_W
                                              : AUTHSRV_AUTHORIZATION_VALUE_W;

      IASTracePrintf("Loading %S", name);

      // Open the registry key.
      status = RegOpenKeyW(
                  HKEY_LOCAL_MACHINE,
                  AUTHSRV_PARAMETERS_KEY_W,
                  &key
                  );
      if (status != NO_ERROR)
      {
         if (status == ERROR_FILE_NOT_FOUND)
         {
            IASTracePrintf(
               "%S doesn't exist; no extensions loaded.",
               AUTHSRV_PARAMETERS_KEY_W
               );
         }
         else
         {
            IASTracePrintf(
               "RegOpenKeyW for %S failed with error %ld.",
               AUTHSRV_PARAMETERS_KEY_W,
               status
               );
         }

         break;
      }

      // Allocate a buffer to hold the value.
      DWORD type, length;
      status = RegQueryValueExW(
                  key,
                  name,
                  0,
                  &type,
                  0,
                  &length
                  );
      if (status != NO_ERROR)
      {
         IASTracePrintf(
            "RegQueryValueExW for %S failed with error %ld.",
            name,
            status
            );
         break;
      }
      BYTE* data = static_cast<BYTE*>(_alloca(length));

      // Read the registry value.
      status = RegQueryValueExW(
                  key,
                  name,
                  0,
                  &type,
                  data,
                  &length
                  );
      if (status != NO_ERROR)
      {
         IASTracePrintf(
            "RegQueryValueExW for %S failed with error %ld.",
            name,
            status
            );
         break;
      }

      // Make sure it's the right type.
      if (type != REG_MULTI_SZ)
      {
         IASTracePrintf(
            "%S registry value is not of type REG_MULTI_SZ.",
            name
            );
         status = ERROR_INVALID_DATA;
         break;
      }

      // Count the number of strings.
      size_t numExtensions = 0;
      const wchar_t* path;
      for (path = reinterpret_cast<const wchar_t*>(data);
           *path != L'\0';
           path += (wcslen(path) + 1))
      {
         if (!IsNT4Only(path))
         {
            ++numExtensions;
         }
      }

      // If there are no extensions, then we're done.
      if (numExtensions == 0)
      {
         IASTraceString("No extensions registered.");
         break;
      }

      // Allocate memory to hold the extensions.
      begin = new (std::nothrow) RadiusExtension[numExtensions];
      if (begin == 0)
      {
         status = ERROR_NOT_ENOUGH_MEMORY;
         break;
      }

      // Load the DLL's.
      end = begin;
      for (path = reinterpret_cast<const wchar_t*>(data);
           *path != L'\0';
           path += (wcslen(path) + 1))
      {
         if (!IsNT4Only(path))
         {
            status = end->Load(path);
            if (status != NO_ERROR)
            {
               ignoreFindNotFound = false;
               // Clear any partial result.
               Clear();
               break;
            }
            ++end;
         }
      }
   } while (false);

   // Close the registry.
   if (key != 0)
   {
      RegCloseKey(key);
   }

   // If no extensions are registered, then it's not really an error.
   if (ignoreFindNotFound && (status == ERROR_FILE_NOT_FOUND))
   {
      status = NO_ERROR;
   }

   return status;
}


void RadiusExtensionPoint::Process(
                              RADIUS_EXTENSION_CONTROL_BLOCK* ecb
                              ) const throw ()
{
   IASTracePrintf("Invoking %S", name);

   for (const RadiusExtension* i = begin; i != end; ++i)
   {
      DWORD result = i->Process(ecb);
      if (result != NO_ERROR)
      {
         ecb->SetResponseType(ecb, rcDiscard);
      }
   }
}


void RadiusExtensionPoint::Clear() throw ()
{
   delete[] begin;

   begin = 0;
   end = 0;
}


bool RadiusExtensionPoint::IsNT4Only(const wchar_t* path) throw ()
{
   // Is this the authsam extension?
   return _wcsicmp(ExtractFileNameFromPath(path), L"AUTHSAM.DLL") == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\dll\iassam.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

#include <newop.cpp>

CComModule _Module;
#include <atlimpl.cpp>

#include <ChangePwd.h>
#include <MSChapError.h>
#include <NTSamAuth.h>
#include <NTSamNames.h>
#include <NTSamPerUser.h>
#include <NTSamUser.h>
#include <EAP.h>
#include <BaseCamp.h>
#include "externalauthnames.h"

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY( __uuidof(NTSamAuthentication),
                 IASRequestHandlerObject<NTSamAuthentication> )
   OBJECT_ENTRY( __uuidof(NTSamNames),
                 IASRequestHandlerObject<NTSamNames> )
   OBJECT_ENTRY( __uuidof(AccountValidation),
                 IASRequestHandlerObject<AccountValidation> )
   OBJECT_ENTRY( __uuidof(NTSamPerUser),
                 IASRequestHandlerObject<NTSamPerUser> )
   OBJECT_ENTRY( __uuidof(EAP),
                 IASRequestHandlerObject<EAP> )
   OBJECT_ENTRY( __uuidof(MSChapErrorReporter),
                 IASRequestHandlerObject<MSChapErrorReporter> )
   OBJECT_ENTRY( __uuidof(BaseCampHost),
                 IASRequestHandlerObject<BaseCampHost> )
   OBJECT_ENTRY( __uuidof(AuthorizationHost),
                 IASRequestHandlerObject<AuthorizationHost> )
   OBJECT_ENTRY( __uuidof(ChangePassword),
                 IASRequestHandlerObject<ChangePassword> )
   OBJECT_ENTRY( __uuidof(ExternalAuthNames),
                 IASRequestHandlerObject<ExternalAuthNames> )
END_OBJECT_MAP()


//////////
// DLL Entry Point
//////////
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
  return  _Module.RegisterServer(FALSE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
  return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class EAP.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iaslsa.h>
#include <iastlutl.h>

#include <eap.h>
#include <eapdnary.h>
#include <eapstate.h>
#include <eaptypes.h>
#include <vector>

//////////
// Define static members.
//////////
EAPTypes EAP::theTypes;

STDMETHODIMP EAP::Initialize()
{
   HRESULT hr;

   // Initialize the LSA API.
   DWORD error = IASLsaInitialize();
   if (error)
   {
      hr = HRESULT_FROM_WIN32(error);
      goto lsa_failed;
   }

   // Initialize the sessions.
   hr = EAPSession::initialize();
   if (FAILED(hr))
   {
      goto sessions_failed;
   }

   // Initialize the IAS <--> RAS translator.
   hr = EAPTranslator::initialize();
   if (FAILED(hr))
   {
      goto translator_failed;
   }

   // The rest can't fail.
   EAPState::initialize();
   theTypes.initialize();

   // Everything succeeded, so we're done.
   return S_OK;

translator_failed:
   EAPSession::finalize();

sessions_failed:
   IASLsaUninitialize();

lsa_failed:
   return hr;
}

STDMETHODIMP EAP::Shutdown()
{
   // Clear out any remaining sessions.
   sessions.clear();

   // Shutdown our sub-systems.
   theTypes.finalize();
   EAPTranslator::finalize();
   EAPSession::finalize();
   IASLsaUninitialize();

   return S_OK;
}

STDMETHODIMP EAP::PutProperty(LONG Id, VARIANT* pValue)
{
   if (pValue == NULL) { return E_INVALIDARG; }

   switch (Id)
   {
      case PROPERTY_EAP_SESSION_TIMEOUT:
      {
         if (V_VT(pValue) != VT_I4) { return DISP_E_TYPEMISMATCH; }
         if (V_I4(pValue) <= 0) { return E_INVALIDARG; }

         IASTracePrintf("Setting EAP session timeout to %ld msec.", V_I4(pValue));

         sessions.setSessionTimeout(V_I4(pValue));
         break;
      }

      case PROPERTY_EAP_MAX_SESSIONS:
      {
         if (V_VT(pValue) != VT_I4) { return DISP_E_TYPEMISMATCH; }
         if (V_I4(pValue) <= 0) { return E_INVALIDARG; }

         IASTracePrintf("Setting max. EAP sessions to %ld.", V_I4(pValue));

         sessions.setMaxSessions(V_I4(pValue));
         break;
      }

      default:
      {
         return DISP_E_MEMBERNOTFOUND;
      }
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    EAP::onSyncRequest
//
// DESCRIPTION
//
//    Processes a request. Note that this method does only enough work to
//    retrieve or create a session object. Once this has been accomplished
//    the main processing logic takes place inside EAPSession (q.v.).
//
///////////////////////////////////////////////////////////////////////////////
IASREQUESTSTATUS EAP::onSyncRequest(IRequest* pRequest) throw ()
{
   EAPSession* session = NULL;

   try
   {
      IASRequest request(pRequest);

      //////////
      // Does the request contain an EAP-Message?
      //////////

      DWORD attrID = RADIUS_ATTRIBUTE_EAP_MESSAGE;
      IASAttributeVectorWithBuffer<16> eapMessage;
      if (!eapMessage.load(request, 1, &attrID))
      {
         // If not, we're not interested.
         return IAS_REQUEST_STATUS_CONTINUE;
      }

      IASTraceString("NT-SAM EAP handler received request.");

      //////////
      // Concatenate the RADIUS EAP-Message attributes into a single packet.
      //////////

      IASAttributeVector::iterator it;
      DWORD pktlen = 0;
      for (it = eapMessage.begin(); it != eapMessage.end(); ++it)
      {
         pktlen += it->pAttribute->Value.OctetString.dwLength;
      }

      PBYTE p = (PBYTE)_alloca(pktlen);
      PPPP_EAP_PACKET recvPkt = (PPPP_EAP_PACKET)p;
      for (it = eapMessage.begin(); it != eapMessage.end(); ++it)
      {
         memcpy(p,
                it->pAttribute->Value.OctetString.lpValue,
                it->pAttribute->Value.OctetString.dwLength);
         p += it->pAttribute->Value.OctetString.dwLength;
      }

      //////////
      // Ensure that the packet is valid.
      //////////

      if (pktlen < 5 || IASExtractWORD(recvPkt->Length) != pktlen)
      {
         IASTraceString("Assembled EAP-Message has invalid length.");

         request.SetResponse(IAS_RESPONSE_DISCARD_PACKET,
                             IAS_MALFORMED_REQUEST);
         return IAS_REQUEST_STATUS_ABORT;
      }

      //////////
      // Get a session object to handle this request.
      //////////

      IASREQUESTSTATUS retval;
      IASAttribute state;
      if (state.load(request, RADIUS_ATTRIBUTE_STATE, IASTYPE_OCTET_STRING))
      {
         //////////
         // If the State attribute exists, this is an ongoing session.
         //////////

         EAPState& s = (EAPState&)(state->Value.OctetString);

         if (!s.isValid())
         {
            IASTraceString("State attribute is present, but unrecognized.");

            // We don't recognize this state attribute, so it must belong
            // to someone else.
            return IAS_REQUEST_STATUS_CONTINUE;
         }

         // Retrieve the object for this session ID.
         session = sessions.remove(s.getSessionID());

         if (!session)
         {
            IASTraceString("Session timed-out. Discarding packet.");

            // The session is already complete.
            request.SetResponse(IAS_RESPONSE_DISCARD_PACKET,
                                IAS_SESSION_TIMEOUT);
            return IAS_REQUEST_STATUS_ABORT;
         }

         IASTracePrintf("Successfully retrieved session state for user %S.",
                        session->getAccountName());

         retval = session->process(request, recvPkt);
      }
      else
      {
         IASTraceString("No State attribute present. Creating new session.");

         //////////
         // No state attribute, so this is a new session.
         // Does the request contain an NT4-Account-Name ?
         //////////

         IASAttribute identity;
         if (!identity.load(request,
                            IAS_ATTRIBUTE_NT4_ACCOUNT_NAME,
                            IASTYPE_STRING))
         {
            IASTraceString("SAM account name not found.");

            // We only handle SAM users.
            return IAS_REQUEST_STATUS_CONTINUE;
         }

         //////////
         // Find out which EAP provider to use.
         //////////

         // Load the EAP Types attributes into the vector.
         IASAttributeVectorWithBuffer<8> eapTypes;
         if (!eapTypes.load(request, IAS_ATTRIBUTE_NP_ALLOWED_EAP_TYPE))
         {
            IASTraceString("EAP not authorized for this user.");

            // Since we don't have an EAP-Type attribute, the user is not
            // allowed to use EAP.
            request.SetResponse(IAS_RESPONSE_ACCESS_REJECT,
                                IAS_INVALID_AUTH_TYPE);
            return IAS_REQUEST_STATUS_HANDLED;
         }

         //////////
         // Retrieve the provider for each EAP type.
         //////////

         // Fill the vector of providers
         std::vector<EAPType*> providers;
         providers.reserve(eapTypes.size());
         for (IASAttributeVector::iterator i = eapTypes.begin();
              i != eapTypes.end();
              ++i)
         {
            IASTracePrintf(
               "Allowed EAP type: %d",
               i->pAttribute->Value.Integer
               );

            EAPType* provider = theTypes[i->pAttribute->Value.Enumerator];
            if (!provider)
            {
               // We can't handle this EAP type. This is an internal error.
               // Lets try the other types.
               IASTraceString("Ignoring EAP type.");
            }
            else
            {
               providers.push_back(provider);
            }
         }

         // pass a vector of providers
         if (!providers.empty())
         {
            session = new EAPSession(identity, providers);
            _ASSERT(session);

            IASTracePrintf(
               "Successfully created new EAP session for user %S.",
               session->getAccountName()
               );

            retval = session->begin(request, recvPkt);
         }
         else
         {
            IASTraceString("No authorized EAP types could be loaded.");

            // Since we don't have an EAP-Type attribute, the user is not
            // allowed to use EAP.
            request.SetResponse(
                       IAS_RESPONSE_DISCARD_PACKET,
                       IAS_EAP_NEGOTIATION_FAILED
                       );
            return IAS_REQUEST_STATUS_ABORT;
         }
      }

      // Save it for later.
      sessions.insert(session);

      return retval;
   }
   catch (const _com_error& )
   {
      IASTraceExcept();
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
   }
   catch (const std::bad_alloc&)
   {
      IASTraceExcept();
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
   }

   // If we have any errors, we'll delete the session.
   delete session;

   return IAS_REQUEST_STATUS_ABORT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\dll\samutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the functions IASEncryptAttribute & IASProcessFailure.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <lm.h>
#include <ntdsapi.h>
#include <sdoias.h>

#include <samutil.h>

HRESULT
WINAPI
IASStoreFQUserName(
    IAttributesRaw* request,
    DS_NAME_FORMAT format,
    PCWSTR fqdn
    ) throw ()
{
   // Check the arguments.
   if (!request || !fqdn) { return E_POINTER; }

   // Convert DN's to canonical names.
   PDS_NAME_RESULTW result = NULL;
   if (format == DS_FQDN_1779_NAME)
   {
      DWORD err = DsCrackNamesW(
                      NULL,
                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                      format,
                      DS_CANONICAL_NAME,
                      1,
                      &fqdn,
                      &result
                      );
      if (err == NO_ERROR &&
          result->cItems == 1 &&
          result->rItems[0].status == DS_NAME_NO_ERROR)
      {
         fqdn = result->rItems[0].pName;
      }
   }

   HRESULT hr;

   // Allocate an attribute.
   PIASATTRIBUTE attr;
   if (IASAttributeAlloc(1, &attr) == NO_ERROR)
   {
      // Allocate memory for the string.
      ULONG nbyte = (wcslen(fqdn) + 1) * sizeof(WCHAR);
      attr->Value.String.pszWide = (PWSTR)CoTaskMemAlloc(nbyte);

      if (attr->Value.String.pszWide)
      {
         // Copy in the value.
         memcpy(attr->Value.String.pszWide, fqdn, nbyte);
         attr->Value.String.pszAnsi = NULL;

         // Set the other fields of the struct.
         attr->Value.itType = IASTYPE_STRING;
         attr->dwId = IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME;

         // Remove any existing attributes of this type.
         request->RemoveAttributesByType(1, &attr->dwId);

         // Store the attribute in the request.
         ATTRIBUTEPOSITION pos = { 0, attr };
         hr = request->AddAttributes(1, &pos);
      }
      else
      {
         // CoTaskMemAlloc failed.
         hr = E_OUTOFMEMORY;
      }

      // Free up the attribute.
      IASAttributeRelease(attr);
   }
   else
   {
      // IASAttributeAlloc failed.
      hr = E_OUTOFMEMORY;
   }

   DsFreeNameResult(result);

   return hr;
}

VOID
WINAPI
IASEncryptBuffer(
    IAttributesRaw* request,
    BOOL salted,
    PBYTE buf,
    ULONG buflen
    ) throw ()
{
   /////////
   // Do we have the attributes required for encryption.
   /////////

   PIASATTRIBUTE secret, header;

   secret = IASPeekAttribute(
                request,
                IAS_ATTRIBUTE_SHARED_SECRET,
                IASTYPE_OCTET_STRING
                );

   header = IASPeekAttribute(
                request,
                IAS_ATTRIBUTE_CLIENT_PACKET_HEADER,
                IASTYPE_OCTET_STRING
                );

   if (secret && header)
   {
      IASRadiusCrypt(
          TRUE,
          salted,
          secret->Value.OctetString.lpValue,
          secret->Value.OctetString.dwLength,
          header->Value.OctetString.lpValue + 4,
          buf,
          buflen
          );
   }
}

IASREQUESTSTATUS
WINAPI
IASProcessFailure(
    IRequest* pRequest,
    HRESULT hrError
    )
{
   if (pRequest == NULL)
   {
      return IAS_REQUEST_STATUS_CONTINUE;
   }

   IASRESPONSE response;
   switch (hrError)
   {
      // Errors which cause a reject.
      case IAS_NO_SUCH_DOMAIN:
      case IAS_NO_SUCH_USER:
      case IAS_AUTH_FAILURE:
      case IAS_CHANGE_PASSWORD_FAILURE:
      case IAS_UNSUPPORTED_AUTH_TYPE:
      case IAS_NO_CLEARTEXT_PASSWORD:
      case IAS_LM_NOT_ALLOWED:
      case IAS_LOCAL_USERS_ONLY:
      case IAS_PASSWORD_MUST_CHANGE:
      case IAS_ACCOUNT_DISABLED:
      case IAS_ACCOUNT_EXPIRED:
      case IAS_ACCOUNT_LOCKED_OUT:
      case IAS_INVALID_LOGON_HOURS:
      case IAS_ACCOUNT_RESTRICTION:
      case IAS_EAP_NEGOTIATION_FAILED:
      {
         response = IAS_RESPONSE_ACCESS_REJECT;
         break;
      }

      case HRESULT_FROM_WIN32(ERROR_MORE_DATA):
      {
         hrError = IAS_MALFORMED_REQUEST;
         response = IAS_RESPONSE_DISCARD_PACKET;
         break;
      }

      // Everything else we discard.
      default:
      {
         // Make sure we report an appropriate reason code.
         if ((hrError == IAS_SUCCESS) || (hrError >= IAS_MAX_REASON_CODE))
         {
            hrError = IAS_INTERNAL_ERROR;
         }

         response = IAS_RESPONSE_DISCARD_PACKET;
         break;
      }
   }

   pRequest->SetResponse(response,  hrError);
   return IAS_REQUEST_STATUS_CONTINUE;
}


SamExtractor::SamExtractor(const IASATTRIBUTE& identity)
{
   if (identity.Value.itType != IASTYPE_STRING)
   {
      IASTL::issue_error(E_INVALIDARG);
   }

   // This is conceptually a const operation since we're not really changing
   // the value of the attribute.
   DWORD error = IASAttributeUnicodeAlloc(
                    const_cast<IASATTRIBUTE*>(&identity)
                    );
   if (error != NO_ERROR)
   {
      IASTL::issue_error(HRESULT_FROM_WIN32(error));
   }

   begin = identity.Value.String.pszWide;
   delim = wcschr(begin, L'\\');
   if (delim != 0)
   {
      *delim = L'\0';
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eap.h ===
/////////////////////////////////////////////////////////////////////////////// //
// FILE
//
//    EAP.h
//
// SYNOPSIS
//
//    This file declares the class EAP.
//
// MODIFICATION HISTORY
//
//    02/12/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAP_H_
#define _EAP_H_

#include <sdoias.h>
#include <iastl.h>
using namespace IASTL;

#include <eapsessiontable.h>

class EAPTypes;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAP
//
// DESCRIPTION
//
//    This class implements the EAP request handler.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE EAP
   : public IASRequestHandlerSync,
     public CComCoClass<EAP, &__uuidof(EAP)>
{
public:

IAS_DECLARE_REGISTRY(EAP, 1, 0, IASTypeLibrary)
IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_EAP)

BEGIN_IAS_RESPONSE_MAP()
   IAS_RESPONSE_ENTRY(IAS_RESPONSE_INVALID)
END_IAS_RESPONSE_MAP()

//////////
// IIasComponent.
//////////
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

protected:
   // Main request processing routine.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   EAPSessionTable sessions;  // Active sessions.
   static EAPTypes theTypes;  // EAP extension DLL's.

   // Give access to the static member variable theTypes
   friend void EAPType::storeNameId(IASRequest& request);
};

#endif  //_EAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapfsm.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// SYNOPSIS
//
//   Defines the class EAPFSM.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "iasutil.h"
#include "eapfsm.h"


EAPType* EAPFSM::onBegin() throw ()
{
   return types.front();
}


void EAPFSM::onDllEvent(
                 PPP_EAP_ACTION action,
                 const PPP_EAP_PACKET& sendPkt
                 ) throw ()
{
   switch (action)
   {
      case EAPACTION_NoAction:
      {
         lastSendCode = 0;
         break;
      }

      case EAPACTION_Done:
      case EAPACTION_SendAndDone:
      {
         state = STATE_DONE;
         break;
      }

      case EAPACTION_Send:
      case EAPACTION_SendWithTimeout:
      case EAPACTION_SendWithTimeoutInteractive:
      {
         lastSendCode = sendPkt.Code;
         lastSendId = sendPkt.Id;
         break;
      }
   }
}


EAPFSM::Action EAPFSM::onReceiveEvent(
                           const PPP_EAP_PACKET& recvPkt,
                           EAPType*& newType
                           ) throw ()
{
   // Default is to discard.
   Action action = DISCARD;

   // And type doesn't change.
   newType = 0;

   switch (state)
   {
      case STATE_INITIAL:
      {
         // In the initial state we only accept Response/Identity.
         if ((recvPkt.Code == EAPCODE_Response) && (recvPkt.Data[0] == 1))
         {
            action = MAKE_MESSAGE;
            state = STATE_NEGOTIATING;
         }
         break;
      }

      case STATE_NEGOTIATING:
      {
         if (isRepeat(recvPkt))
         {
            action = REPLAY_LAST;
            break;
         }

         if (!isExpected(recvPkt))
         {
            action = DISCARD;
            break;
         }

         // In the negotiating state, NAK's are allowed.
         if (recvPkt.Data[0] == 3)
         {
            // Did the client propose a type?
            BYTE proposal =
               (IASExtractWORD(recvPkt.Length) > 5) ? recvPkt.Data[1] : 0;

            // Select a new type.
            action = selectNewType(proposal, newType);
         }
         else if (recvPkt.Data[0] == eapType)
         {
            // Once the client agrees to our type; he's locked in.
            action = MAKE_MESSAGE;
            state = STATE_ACTIVE;
         }
         else
         {
            action = FAIL_NEGOTIATE;
            state = STATE_DONE;
         }

         break;
      }

      case STATE_ACTIVE:
      {
         if (recvPkt.Code == EAPCODE_Request)
         {
            action = MAKE_MESSAGE;
         }
         else if (recvPkt.Data[0] == 3)
         {
            action = DISCARD;
         }
         else if (isRepeat(recvPkt))
         {
            action = REPLAY_LAST;
         }
         else if (isExpected(recvPkt))
         {
            action = MAKE_MESSAGE;
         }

         break;
      }

      case STATE_DONE:
      {
         // The session is over, so all we do is replay repeats.
         if (isRepeat(recvPkt))
         {
            action = REPLAY_LAST;
         }
      }
   }

   // If the packet made it through our filters, then we count it as the
   // last received.
   if (action == MAKE_MESSAGE)
   {
      lastRecvCode = recvPkt.Code;
      lastRecvId = recvPkt.Id;
      lastRecvType = recvPkt.Data[0];
   }

   return action;
}


inline BOOL EAPFSM::isExpected(const PPP_EAP_PACKET& recvPkt) const throw ()
{
   return (lastSendCode == EAPCODE_Request) &&
          (recvPkt.Code == EAPCODE_Response) &&
          (recvPkt.Id == lastSendId);
}


inline BOOL EAPFSM::isRepeat(const PPP_EAP_PACKET& recvPkt) const throw ()
{
   return (recvPkt.Code == lastRecvCode) &&
          (recvPkt.Id == lastRecvId) &&
          (recvPkt.Data[0] == lastRecvType);
}


EAPFSM::Action EAPFSM::selectNewType(
                          BYTE proposal,
                          EAPType*& newType
                          ) throw ()
{
   // The peer NAK'd our previous offer, so he's not allowed to use it
   // again.
   types.erase(types.begin());

   if (proposal != 0)
   {
      IASTracePrintf("EAP NAK; proposed type = %hd", proposal);

      // Find the proposed type in the list of allowed types.
      for (std::vector<EAPType*>::iterator i = types.begin();
            i != types.end();
            ++i)
      {
         if ((*i)->dwEapTypeId == proposal)
         {
            IASTraceString("Accepting proposed type.");

            // change the current type
            newType = *i;
            eapType = newType->dwEapTypeId;

            // change the state to active: any NAK received now will fail
            state = STATE_ACTIVE;
            return MAKE_MESSAGE;
         }
      }
   }
   else
   {
      IASTraceString("EAP NAK; no type proposed");
   }

   // If the server list is empty, then nothing else can be negotiated.
   if (types.empty())
   {
      IASTraceString("EAP negotiation failed; no types remaining.");
      state = STATE_DONE;
      return FAIL_NEGOTIATE;
   }

   // negotiate the next one from the server's list
   newType = types.front();
   eapType = newType->dwEapTypeId;

   IASTracePrintf("EAP authenticator offering type %hd", eapType);

   return MAKE_MESSAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapdnary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPDnary.h
//
// SYNOPSIS
//
//    This file declares the class EAPTranslator.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    05/08/1998    Do not restrict to attributes defined in raseapif.h.
//                  Allow filtering of translated attributes.
//    08/26/1998    Converted to a namespace.
//    04/09/1999    Fix leak when converting outgoing attributes.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlb.h>
#include <iasutil.h>

#include <hashmap.h>

#include <eapdnary.h>

namespace EAPTranslator
{
   typedef hash_map < DWORD, IASTYPE, identity<DWORD> > TypeMap;

   long theRefCount;            // Initialization refCount.
   TypeMap theTypeMap(0x200);   // Maps attribute ID's to IASTYPE's.
}


HRESULT EAPTranslator::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   if (theRefCount > 0)
   {
      // We're already initialized, so just bump the ref count.
      ++theRefCount;
      return S_OK;
   }

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] =
      {
            L"ID",
            L"Syntax",
            NULL
      };

      // Open the attributes table.
      IASTL::IASDictionary dnary(COLUMNS);

      // Iterate through the attributes and populate our dictionary.
      while (dnary.next())
      {
         DWORD id = (DWORD)dnary.getLong(0);
         IASTYPE type = (IASTYPE)dnary.getLong(1);

         theTypeMap[id] = type;
      }
   }
   catch (std::bad_alloc)
   {
      theTypeMap.clear();
      return E_OUTOFMEMORY;
   }
   catch (const _com_error& ce)
   {
      theTypeMap.clear();
      return ce.Error();
   }

   // We made it so increase the refCount.
   ++theRefCount;

   return S_OK;
}


void EAPTranslator::finalize() throw ()
{
   IASGlobalLockSentry sentry;

   if (--theRefCount == 0)
   {
      theTypeMap.clear();
   }
}

BOOL EAPTranslator::translate(
                        IASAttribute& dst,
                        const RAS_AUTH_ATTRIBUTE& src
                        )
{
   dst->dwId = (DWORD)src.raaType;

   const TypeMap::value_type* val = theTypeMap.find(dst->dwId);

   IASTYPE itType = val ? val->second : IASTYPE_INVALID;

   switch (itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         switch (src.dwLength)
         {
            case 4:
            case 2:
            case 1:
               dst->Value.Integer = PtrToUlong(src.Value);
               break;
            default:
               _com_issue_error(E_INVALIDARG);
         }
         break;
      }

      case IASTYPE_STRING:
      {
         dst.setString(src.dwLength, (const BYTE*)src.Value);
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         dst.setOctetString(src.dwLength, (const BYTE*)src.Value);
         break;
      }

      default:
         return FALSE;
   }

   dst->Value.itType = itType;

   return TRUE;
}


BOOL EAPTranslator::translate(
                        RAS_AUTH_ATTRIBUTE& dst,
                        const IASATTRIBUTE& src
                        )
{
   dst.raaType = (RAS_AUTH_ATTRIBUTE_TYPE)src.dwId;

   switch (src.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         dst.dwLength = sizeof(DWORD);
         dst.Value = UlongToPtr(src.Value.Integer);
         break;
      }

      case IASTYPE_STRING:
      {
         DWORD dwErr = IASAttributeAnsiAlloc(const_cast<PIASATTRIBUTE>(&src));
         if (dwErr != NO_ERROR)
         {
            issue_error(HRESULT_FROM_WIN32(dwErr));
         }

         if (src.Value.String.pszAnsi)
         {
            dst.dwLength = (DWORD)strlen(src.Value.String.pszAnsi) + 1;
            dst.Value = (PVOID)src.Value.String.pszAnsi;
         }
         else
         {
            dst.dwLength = 0;
            dst.Value = NULL;
         }
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         dst.dwLength = src.Value.OctetString.dwLength;
         dst.Value = (PVOID)src.Value.OctetString.lpValue;
         break;
      }

      default:
        return FALSE;
   }

   return TRUE;
}

void EAPTranslator::translate(
                        IASAttributeVector& dst,
                        const RAS_AUTH_ATTRIBUTE* src
                        )
{
   IASAttribute attr;

   const RAS_AUTH_ATTRIBUTE* i;
   for (i = src; i->raaType != raatMinimum; ++i)
   {
      attr.alloc();

      if (translate(attr, *i))
      {
         dst.push_back(attr, false);

         attr.detach();
      }
   }
}

void EAPTranslator::translate(
                        PRAS_AUTH_ATTRIBUTE dst,
                        const IASAttributeVector& src,
                        DWORD filter
                        )
{
   PRAS_AUTH_ATTRIBUTE next = dst;

   IASAttributeVector::const_iterator i;
   for (i = src.begin(); i != src.end(); ++i)
   {
      if ((i->pAttribute->dwFlags & filter) != 0 &&
          translate(*next, *(i->pAttribute)))
      {
         ++next;
      }
   }

   next->raaType = raatMinimum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapdnary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapdnary.h
//
// SYNOPSIS
//
//    This file declares the namespace EAPTranslator.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    05/08/1998    Do not restrict to attributes defined in raseapif.h.
//                  Allow filtering of translated attributes.
//    08/26/1998    Converted to a namespace.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPDNARY_H_
#define _EAPDNARY_H_

#include <raseapif.h>

#include <iastlutl.h>
using namespace IASTL;

///////////////////////////////////////////////////////////////////////////////
//
// NAMESPACE
//
//    EAPTranslator
//
// DESCRIPTION
//
//    This namespace contains methods for translating attributes between IAS
//    and RAS format.
//
///////////////////////////////////////////////////////////////////////////////
namespace EAPTranslator
{

   // Must be called prior to using any of the translate methods.
   HRESULT initialize() throw ();
   void finalize() throw ();

   //////////
   // Methods to translate a single attribute.
   //////////
   BOOL translate(
            IASAttribute& dst,
            const RAS_AUTH_ATTRIBUTE& src
            );

   BOOL translate(
            RAS_AUTH_ATTRIBUTE& dst,
            const IASATTRIBUTE& src
            );

   //////////
   // Methods to translate an array of attributes.
   //////////
   void translate(
            IASAttributeVector& dst,
            const RAS_AUTH_ATTRIBUTE* src
            );

   void translate(
            PRAS_AUTH_ATTRIBUTE dst,
            const IASAttributeVector& src,
            DWORD filter = 0xFFFFFFFF
            );
}

#endif  // _EAPDNARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapsession.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    This file defines the class EAPSession.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "iaslsa.h"
#include "lockout.h"
#include "samutil.h"
#include "sdoias.h"

#include "eapdnary.h"
#include "eapsession.h"
#include "eapstate.h"
#include "eaptype.h"
#include "eap.h"
#include "align.h"

// Default value for the Framed-MTU attribute.
const DWORD FRAMED_MTU_DEFAULT  = 1500;

// Minimum allowed value for the Framed-MTU attribute.
const DWORD FRAMED_MTU_MIN = 64;

// The maximum length of the frame header. i.e. max(2,4).
// 2 for the PPP header and 4 for the 802.1X header.
// The length of the frame header plus the length
// of the EAP packet must be less than the Framed-MTU.
const DWORD FRAME_HEADER_LENGTH = 4;

// Absolute maximum length of an EAP packet. We bound this to limit worst-case
// memory consumption.
const DWORD MAX_MAX_PACKET_LENGTH = 2048;

//////////
// Inject a PPP_EAP_PACKET into a request.
//////////
VOID
WINAPI
InjectPacket(
    IASRequest& request,
    const PPP_EAP_PACKET& packet
    )
{
   // Get the raw buffer to be packed.
   const BYTE* buf   = (const BYTE*)&packet;
   DWORD nbyte = IASExtractWORD(packet.Length);

   IASTracePrintf("Inserting outbound EAP-Message of length %lu.", nbyte);

   // Determine the maximum chunk size.
   DWORD chunkSize;
   switch (request.get_Protocol())
   {
      case IAS_PROTOCOL_RADIUS:
         chunkSize = 253;
         break;

      default:
         chunkSize = nbyte;
   }

   // Split the buffer into chunks.
   while (nbyte)
   {
      // Compute how many bytes of the EAP-Message to store in this attribute.
      DWORD length = min(nbyte, chunkSize);

      // Initialize the attribute fields.
      IASAttribute attr(true);
      attr.setOctetString(length, buf);
      attr->dwId = RADIUS_ATTRIBUTE_EAP_MESSAGE;
      attr->dwFlags = IAS_INCLUDE_IN_RESPONSE;

      // Inject the attribute into the request.
      attr.store(request);

      // Update our state.
      nbyte -= length;
      buf   += length;
   }
}

//////////
// Extracts the Vendor-Type field from a Microsoft VSA. Returns zero if the
// attribute is not a valid Microsoft VSA.
//////////
BYTE
WINAPI
ExtractMicrosoftVendorType(
    const IASATTRIBUTE& attr
    ) throw ()
{
   if (attr.dwId == RADIUS_ATTRIBUTE_VENDOR_SPECIFIC &&
       attr.Value.itType == IASTYPE_OCTET_STRING &&
       attr.Value.OctetString.dwLength > 6 &&
       !memcmp(attr.Value.OctetString.lpValue, "\x00\x00\x01\x37", 4))
   {
      return *(attr.Value.OctetString.lpValue + 4);
   }

   return (BYTE)0;
}

//////////
// Inject an array of RAS attributes into a request.
//////////
VOID
WINAPI
InjectRASAttributes(
    IASRequest& request,
    const RAS_AUTH_ATTRIBUTE* rasAttrs,
    DWORD flags
    )
{
   if (rasAttrs == NULL) { return; }

   //////////
   // Translate them to IAS format.
   //////////

   IASTraceString("Translating attributes returned by EAP DLL.");

   IASAttributeVectorWithBuffer<8> iasAttrs;
   EAPTranslator::translate(iasAttrs, rasAttrs);

   //////////
   // Iterate through the converted attributes to set the flags and remove any
   // matching attributes from the request.
   //////////

   IASAttributeVector::iterator i;
   for (i = iasAttrs.begin(); i != iasAttrs.end(); ++i)
   {
      IASTracePrintf("Inserting attribute %lu", i->pAttribute->dwId);

      i->pAttribute->dwFlags = flags;
   }

   //////////
   // Add them to the request.
   //////////

   iasAttrs.store(request);
}

//////////
// Performs NT-SAM PAP and MD5-CHAP authentication based on RAS attributes.
//////////
DWORD
WINAPI
AuthenticateUser(
    IASATTRIBUTE& account,
    RAS_AUTH_ATTRIBUTE* pInAttributes
    )
{
   //////////
   // Check the input parameters.
   //////////
   if (!pInAttributes) { return NO_ERROR; }

   //////////
   // Get the NT-SAM userName and domain.
   //////////

   // Get the NT-SAM userName and domain.
   SamExtractor extractor(account);
   PCWSTR domain = extractor.getDomain();
   PCWSTR userName = extractor.getUsername();

   //////////
   // Find the credentials populated by the EAP DLL.
   //////////

   PRAS_AUTH_ATTRIBUTE rasUserPassword     = NULL,
                       rasMD5CHAPPassword  = NULL,
                       rasMD5CHAPChallenge = NULL;

   for ( ; pInAttributes->raaType != raatMinimum; ++pInAttributes)
   {
      switch (pInAttributes->raaType)
      {
         case raatUserPassword:
            rasUserPassword = pInAttributes;
            break;

         case raatMD5CHAPPassword:
            rasMD5CHAPPassword = pInAttributes;
            break;

         case raatMD5CHAPChallenge:
            rasMD5CHAPChallenge = pInAttributes;
            break;
      }
   }

   DWORD status = NO_ERROR;

   // Is this MD5-CHAP?
   if (rasMD5CHAPPassword && rasMD5CHAPChallenge)
   {
      _ASSERT(rasMD5CHAPPassword->dwLength  == 17);

      // The ID is the first byte of the password ...
      BYTE challengeID = *(PBYTE)(rasMD5CHAPPassword->Value);

      // ... and the password is the rest.
      PBYTE chapPassword = (PBYTE)(rasMD5CHAPPassword->Value) + 1;

      IASTracePrintf("Performing CHAP authentication for user %S\\%S.",
                     domain, userName);

      IAS_CHAP_PROFILE profile;
      HANDLE token;
      status = IASLogonCHAP(
                   userName,
                   domain,
                   challengeID,
                   (PBYTE)(rasMD5CHAPChallenge->Value),
                   rasMD5CHAPChallenge->dwLength,
                   chapPassword,
                   &token,
                   &profile
                   );
      CloseHandle(token);
   }

   // Is this PAP?
   else if (rasUserPassword)
   {
      // Convert to a null-terminated string.
      IAS_OCTET_STRING octstr = { rasUserPassword->dwLength,
                                  (PBYTE)rasUserPassword->Value };
      PCSTR userPwd = IAS_OCT2ANSI(octstr);

      IASTracePrintf("Performing PAP authentication for user %S\\%S.",
                     domain, userName);

      IAS_PAP_PROFILE profile;
      HANDLE token;
      status = IASLogonPAP(
                   userName,
                   domain,
                   userPwd,
                   &token,
                   &profile
                   );
      CloseHandle(token);
   }

   return status;
}

//////////
// Updates the AccountLockout database.
//////////
VOID
WINAPI
UpdateAccountLockoutDB(
    IASATTRIBUTE& account,
    DWORD authResult
    )
{
   // Get the NT-SAM userName and domain.
   SamExtractor extractor(account);
   PCWSTR domain = extractor.getDomain();
   PCWSTR userName = extractor.getUsername();

   // Lookup the user in the lockout DB.
   HANDLE hAccount;
   AccountLockoutOpenAndQuery(userName, domain, &hAccount);

   // Report the result.
   if (authResult == NO_ERROR)
   {
      AccountLockoutUpdatePass(hAccount);
   }
   else
   {
      AccountLockoutUpdateFail(hAccount);
   }

   // Close the handle.
   AccountLockoutClose(hAccount);
}

//////////
// Define the static members.
//////////

LONG EAPSession::theNextID = 0;
LONG EAPSession::theRefCount = 0;
IASAttribute EAPSession::theNormalTimeout;
IASAttribute EAPSession::theInteractiveTimeout;
HANDLE EAPSession::theIASEventLog;
HANDLE EAPSession::theRASEventLog;

EAPSession::EAPSession(
               const IASAttribute& accountName,
               std::vector<EAPType*>& eapTypes
               )
   : id((DWORD)InterlockedIncrement(&theNextID)),
     currentType(0),
     account(accountName),
     state(EAPState::createAttribute(id), false),
     fsm(eapTypes),
     maxPacketLength(FRAMED_MTU_DEFAULT - FRAME_HEADER_LENGTH),
     workBuffer(NULL),
     sendPacket(NULL)
{
   eapInput.pUserAttributes = NULL;
}

EAPSession::~EAPSession() throw ()
{
   clearType();
   delete[] sendPacket;
   delete[] eapInput.pUserAttributes;
}

IASREQUESTSTATUS EAPSession::begin(
                                 IASRequest& request,
                                 PPPP_EAP_PACKET recvPacket
                                 )
{
   //////////
   // Get all the attributes from the request.
   //////////
   all.load(request);

   //////////
   // Scan for the Framed-MTU attribute and compute the profile size.
   //////////

   DWORD profileSize = 0;
   DWORD configSize = 0;
   IASAttributeVector::iterator i;
   for (i = all.begin(); i != all.end(); ++i)
   {
      if (i->pAttribute->dwId == RADIUS_ATTRIBUTE_FRAMED_MTU)
      {
         DWORD framedMTU = i->pAttribute->Value.Integer;

         // Only process valid values.
         if (framedMTU >= FRAMED_MTU_MIN)
         {
            // Leave room for the frame header.
            maxPacketLength = framedMTU - FRAME_HEADER_LENGTH;

            // Make sure we're within bounds.
            if (maxPacketLength > MAX_MAX_PACKET_LENGTH)
            {
               maxPacketLength = MAX_MAX_PACKET_LENGTH;
            }
         }

         IASTracePrintf("Setting max. packet length to %lu.", maxPacketLength);
      }

      if (i->pAttribute->dwId == IAS_ATTRIBUTE_EAP_CONFIG)
      {
         ++configSize;
      }
      else if (!(i->pAttribute->dwFlags & IAS_RECVD_FROM_PROTOCOL))
      {
         ++profileSize;
      }
   }

   //////////
   // Save and remove the profile and config attributes.
   //////////

   profile.reserve(profileSize);
   config.reserve(configSize);

   for (i = all.begin(); i != all.end(); ++i)
   {
      if (i->pAttribute->dwId == IAS_ATTRIBUTE_EAP_CONFIG)
      {
         config.push_back(*i);
      }
      else if (!(i->pAttribute->dwFlags & IAS_RECVD_FROM_PROTOCOL))
      {
         profile.push_back(*i);
      }
   }

   profile.remove(request);

   //////////
   // Convert the attributes received from the client to RAS format.
   //////////

   eapInput.pUserAttributes = new RAS_AUTH_ATTRIBUTE[all.size() + 1];

   EAPTranslator::translate(
                     eapInput.pUserAttributes,
                     all,
                     IAS_RECVD_FROM_CLIENT
                     );

   //////////
   // Initialize the EAPInput struct.
   //////////

   eapInput.fAuthenticator = TRUE;
   eapInput.bInitialId = recvPacket->Id + (BYTE)1;
   eapInput.pwszIdentity = account->Value.String.pszWide;

   switch (request.get_Protocol())
   {
      case IAS_PROTOCOL_RADIUS:
         eapInput.hReserved = theIASEventLog;
         break;

      case IAS_PROTOCOL_RAS:
         eapInput.hReserved = theRASEventLog;
         break;
   }

   // Begin the session with the EAP DLL.
   setType(fsm.onBegin());

   //////////
   // We have successfully established the session, so process the message.
   //////////

   return process(request, recvPacket);
}

IASREQUESTSTATUS EAPSession::process(
                                 IASRequest& request,
                                 PPPP_EAP_PACKET recvPacket
                                 )
{
   // Trigger an event on the FSM.
   EAPType* newType;
   switch (fsm.onReceiveEvent(*recvPacket, newType))
   {
      case EAPFSM::MAKE_MESSAGE:
      {
         if (newType != 0)
         {
            setType(newType);
         }
         break;
      }

      case EAPFSM::REPLAY_LAST:
      {
         IASTraceString("EAP-Message appears to be a retransmission. "
                        "Replaying last action.");
         return doAction(request);
      }

      case EAPFSM::FAIL_NEGOTIATE:
      {
         IASTraceString("EAP negotiation failed. Rejecting user.");
         profile.store(request);
         request.SetResponse(IAS_RESPONSE_ACCESS_REJECT,
                             IAS_EAP_NEGOTIATION_FAILED);
         return IAS_REQUEST_STATUS_HANDLED;
      }

      case EAPFSM::DISCARD:
      {
         IASTraceString("EAP-Message is unexpected. Discarding packet.");
         profile.store(request);
         request.SetResponse(IAS_RESPONSE_DISCARD_PACKET,
                             IAS_UNEXPECTED_REQUEST);
         return IAS_REQUEST_STATUS_ABORT;
      }
   }

   // Allocate a temporary packet to hold the response.
   PPPP_EAP_PACKET tmpPacket = (PPPP_EAP_PACKET)_alloca(maxPacketLength);

   // Clear the previous output from the DLL.
   eapOutput.clear();

   DWORD error = currentType->RasEapMakeMessage(
                                 workBuffer,
                                 recvPacket,
                                 tmpPacket,
                                 maxPacketLength,
                                 &eapOutput,
                                 NULL
                                 );
   if (error != NO_ERROR)
   {
      IASTraceFailure("RasEapMakeMessage", error);
      _com_issue_error(HRESULT_FROM_WIN32(error));
   }

   while (eapOutput.Action == EAPACTION_Authenticate)
   {
      IASTraceString("EAP DLL invoked default authenticator.");

      // Authenticate the user.
      DWORD authResult = AuthenticateUser(
                             *account,
                             eapOutput.pUserAttributes
                             );

      //////////
      // Convert the profile to RAS format.
      //////////

      DWORD filter;

      if (authResult == NO_ERROR)
      {
         IASTraceString("Default authentication succeeded.");
         filter = IAS_INCLUDE_IN_ACCEPT;
      }
      else
      {
         IASTraceFailure("Default authentication", authResult);
         filter = IAS_INCLUDE_IN_REJECT;
      }

      PRAS_AUTH_ATTRIBUTE ras = IAS_STACK_NEW(RAS_AUTH_ATTRIBUTE,
                                              profile.size() + 1);

      EAPTranslator::translate(ras, profile, filter);

      //////////
      // Give the result to the EAP DLL.
      //////////

      EAPInput authInput;
      authInput.dwAuthResultCode = authResult;
      authInput.fAuthenticationComplete = TRUE;
      authInput.pUserAttributes = ras;

      eapOutput.clear();

      error = currentType->RasEapMakeMessage(
                              workBuffer,
                              NULL,
                              tmpPacket,
                              maxPacketLength,
                              &eapOutput,
                              &authInput
                              );
      if (error != NO_ERROR)
      {
         IASTraceFailure("RasEapMakeMessage", error);
         _com_issue_error(HRESULT_FROM_WIN32(error));
      }
   }

   //////////
   // Trigger an event on the FSM.
   //////////

   fsm.onDllEvent(eapOutput.Action, *tmpPacket);

   // Clear the old send packet ...
   delete[] sendPacket;
   sendPacket = NULL;

   // ... and save the new one if available.
   switch (eapOutput.Action)
   {
      case EAPACTION_SendAndDone:
      case EAPACTION_Send:
      case EAPACTION_SendWithTimeout:
      case EAPACTION_SendWithTimeoutInteractive:
      {
         size_t length = IASExtractWORD(tmpPacket->Length);
         sendPacket = (PPPP_EAP_PACKET)new BYTE[length];
         memcpy(sendPacket, tmpPacket, length);
      }
   }

   //////////
   // Perform the requested action.
   //////////

   return doAction(request);
}


IASREQUESTSTATUS EAPSession::doAction(IASRequest& request)
{
   IASTraceString("Processing output from EAP DLL.");

   switch (eapOutput.Action)
   {
      case EAPACTION_SendAndDone:
      {
         InjectPacket(request, *sendPacket);
      }

      case EAPACTION_Done:
      {
         // Add the profile first, so that the EAP DLL can override it.
         profile.store(request);

         // Special-case the unauthenticated access
         if (eapOutput.dwAuthResultCode == SEC_E_NO_CREDENTIALS)
         {
            // set the auth type to unauthenticated
            DWORD authID = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
            request.RemoveAttributesByType(1, &authID);

            IASAttribute authType(true);
            authType->dwId = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
            authType->Value.itType = IASTYPE_ENUM;
            authType->Value.Enumerator = IAS_AUTH_NONE;
            authType.store(request);

            // Load the EAP Types attributes into the vector.
            IASAttributeVectorWithBuffer<8> authTypes;
            authTypes.load(request, IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE);
            for (IASAttributeVector::iterator i = authTypes.begin();
                  i != authTypes.end(); ++i)
            {
               if (i->pAttribute->Value.Integer == IAS_AUTH_NONE)
               {
                  // Unauthenticated EAP access allowed
                  IASTraceString("Unauthenticated EAP access allowed");
                  eapOutput.dwAuthResultCode = NO_ERROR;
                  break;
               }
            }
         }

         // Update the account lockout database.
         UpdateAccountLockoutDB(
             *account,
             eapOutput.dwAuthResultCode
             );


         DWORD flags = eapOutput.dwAuthResultCode ? IAS_INCLUDE_IN_REJECT
                                                  : IAS_INCLUDE_IN_ACCEPT;

         InjectRASAttributes(request, eapOutput.pUserAttributes, flags);

         // store the EAP friendly name negotiated for both success and failure
         // if PEAP is used, store the PEAP inside type and update the
         // authentication type from EAP to PEAP
         currentType->storeNameId(request);

         if (eapOutput.dwAuthResultCode == NO_ERROR)
         {
            IASTraceString("EAP authentication succeeded.");
            request.SetResponse(IAS_RESPONSE_ACCESS_ACCEPT, S_OK);
         }
         else
         {
            IASTraceFailure("EAP authentication", eapOutput.dwAuthResultCode);

            HRESULT hr = IASMapWin32Error(eapOutput.dwAuthResultCode,
                                          IAS_AUTH_FAILURE);
            request.SetResponse(IAS_RESPONSE_ACCESS_REJECT, hr);
         }

         return IAS_REQUEST_STATUS_HANDLED;
      }

      case EAPACTION_SendWithTimeoutInteractive:
      case EAPACTION_SendWithTimeout:
      {
         if (eapOutput.Action == EAPACTION_SendWithTimeoutInteractive)
         {
            theInteractiveTimeout.store(request);
         }
         else
         {
            theNormalTimeout.store(request);
         }
      }

      case EAPACTION_Send:
      {
         InjectRASAttributes(request,
                             eapOutput.pUserAttributes,
                             IAS_INCLUDE_IN_CHALLENGE);
         InjectPacket(request, *sendPacket);
         state.store(request);

         IASTraceString("Issuing Access-Challenge.");

         request.SetResponse(IAS_RESPONSE_ACCESS_CHALLENGE, S_OK);
         break;
      }

      case EAPACTION_NoAction:
      default:
      {
         IASTraceString("EAP DLL returned No Action. Discarding packet.");

         request.SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
      }
   }

   return IAS_REQUEST_STATUS_ABORT;
}

extern "C"
NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
   PULONG Seed
   );

HRESULT EAPSession::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   if (theRefCount == 0)
   {
      FILETIME ft;
      GetSystemTimeAsFileTime(&ft);
      ULONG seed = (ft.dwLowDateTime ^ ft.dwHighDateTime);
      theNextID = RtlRandomEx(&seed);

      PIASATTRIBUTE attrs[2];
      DWORD dw = IASAttributeAlloc(2, attrs);
      if (dw != NO_ERROR) { return HRESULT_FROM_WIN32(dw); }

      theNormalTimeout.attach(attrs[0], false);
      theNormalTimeout->dwId = RADIUS_ATTRIBUTE_SESSION_TIMEOUT;
      theNormalTimeout->Value.itType = IASTYPE_INTEGER;
      theNormalTimeout->Value.Integer = 6;
      theNormalTimeout.setFlag(IAS_INCLUDE_IN_CHALLENGE);

      theInteractiveTimeout.attach(attrs[1], false);
      theInteractiveTimeout->dwId = RADIUS_ATTRIBUTE_SESSION_TIMEOUT;
      theInteractiveTimeout->Value.itType = IASTYPE_INTEGER;
      theInteractiveTimeout->Value.Integer = 30;
      theInteractiveTimeout.setFlag(IAS_INCLUDE_IN_CHALLENGE);

      theIASEventLog = RegisterEventSourceW(NULL, L"IAS");
      theRASEventLog = RegisterEventSourceW(NULL, L"RemoteAccess");
   }

   ++theRefCount;

   return S_OK;
}

void EAPSession::finalize() throw ()
{
   IASGlobalLockSentry sentry;

   if (--theRefCount == 0)
   {
      DeregisterEventSource(theRASEventLog);
      DeregisterEventSource(theIASEventLog);
      theInteractiveTimeout.release();
      theNormalTimeout.release();
   }
}

void EAPSession::clearType() throw ()
{
   if (currentType != 0)
   {
      currentType->RasEapEnd(workBuffer);
      currentType = 0;
   }
}

void EAPSession::setType(EAPType* newType)
{
   // If we're switching types, we have to bump the EAP identifier.
   if (currentType != 0)
   {
      ++(eapInput.bInitialId);
   }

   // Try to initialize the new type.
   void* newWorkBuffer = 0;
   if (newType != 0)
   {
      eapInput.pConnectionData = 0;
      eapInput.dwSizeOfConnectionData = 0;

      // Do we have config data for this EAP type?
      for (IASAttributeVector::const_iterator i = config.begin();
           i != config.end();
           ++i)
      {
         const IAS_OCTET_STRING& data = i->pAttribute->Value.OctetString;

         if (data.lpValue[0] == newType->typeCode())
         {
            // Don't pass first byte to EAP DLL.
            eapInput.pConnectionData = data.lpValue + ALIGN_WORST;
            eapInput.dwSizeOfConnectionData = data.dwLength - ALIGN_WORST;
            break;
         }
      }

      DWORD error = newType->RasEapBegin(&newWorkBuffer, &eapInput);
      if (error != NO_ERROR)
      {
         IASTraceFailure("RasEapBegin", error);
         _com_issue_error(HRESULT_FROM_WIN32(error));
      }
   }

   // Success, so clear the old ...
   clearType();

   // ... and save the new.
   currentType = newType;
   workBuffer = newWorkBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapsessiontable.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    EAPSessionTable.cpp
//
// SYNOPSIS
//
//    This file defines the class EAPSessionTable.
//
// MODIFICATION HISTORY
//
//    04/28/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <eapsessiontable.h>

//////////
// Get the system time as a 64-bit integer.
//////////
inline DWORDLONG getCurrentTime() throw ()
{
   ULARGE_INTEGER ft;
   GetSystemTimeAsFileTime((LPFILETIME)&ft);
   return ft.QuadPart;
}

// Session timeout defaults to 2 minutes.
// Max. sessions defaults to 4096.
EAPSessionTable::EAPSessionTable()
   : byID(0x400),
     sessionTimeout(1200000000ui64),
     maxSessions(0x1000)
{ }

EAPSessionTable::~EAPSessionTable()
{
   clear();
}

//////////
// Externally the session timeout is expressed in milliseconds, but internally
// we store it in 100 nsec intervals to facilitate working with FILETIME.
//////////
DWORD EAPSessionTable::getSessionTimeout() const throw ()
{
   return (DWORD)(sessionTimeout / 10000);
}

void EAPSessionTable::setSessionTimeout(DWORD newVal) throw ()
{
   sessionTimeout = 10000 * (DWORDLONG)newVal;
}

void EAPSessionTable::clear() throw ()
{
   _serialize

   // Delete all the sessions.
   for (SessionTable::iterator i = byID.begin(); i.more(); ++i)
   {
      delete i->first;
   }

   // Clear the collections.
   byID.clear();
   byExpiry.clear();
}

void EAPSessionTable::insert(EAPSession* session)
{
   _serialize

   // Make room for the new session.
   while (byExpiry.size() >= maxSessions)
   {
      evictOldest();
   }

   // Evict all expired sessions. We do this before the insert to avoid
   // unnecessary resizing of the session table.
   DWORDLONG now = getCurrentTime();
   evict(now);

   // Compute the expiry of this session.
   now += sessionTimeout;

   // It must be the most recent, so insert it at the front of the list.
   byExpiry.push_front(SessionList::value_type(now, session));

   try
   {
      // We can use multi_insert since the session ID is guaranteed to be unique.
      byID.multi_insert(SessionTable::value_type(session, byExpiry.begin()));
   }
   catch (const std::bad_alloc&)
   {
      byExpiry.pop_front();
      throw;
   }
}

EAPSession* EAPSessionTable::remove(DWORD key) throw ()
{
   _serialize

   // First evict all expired sessions since the requested session may have
   // expired.
   evict(getCurrentTime());

   const SessionEntry* entry = byID.find(key);

   if (entry)
   {
      // Save the session pointer we're going to return.
      EAPSession* session = entry->first;

      // Erase from the expiry list ...
      byExpiry.erase(entry->second);

      // ... and the session table.
      byID.erase(key);

      return session;
   }

   // Not found, so return NULL.
   return NULL;
}

void EAPSessionTable::evict(DWORDLONG now) throw ()
{
   // Loop until the list is empty or the oldest session hasn't expired.
   while (!byExpiry.empty() && byExpiry.back().first <= now)
   {
      evictOldest();
   }
}

void EAPSessionTable::evictOldest() throw ()
{
   // We have an expired session, so erase it from the table.
   byID.erase(byExpiry.back().second->getID());

   // Clean up the session object.
   delete byExpiry.back().second;

   // Remove from the list.
   byExpiry.pop_back();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapsession.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPSession.h
//
// SYNOPSIS
//
//    This file declares the class EAPSession.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    05/08/1998    Convert to new EAP interface.
//    08/27/1998    Use new EAPFSM class.
//    10/13/1998    Add maxPacketLength property.
//    11/13/1998    Add event log handles.
//    05/20/1999    Identity is now a Unicode string.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPSESSION_H_
#define _EAPSESSION_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>
#include <raseapif.h>

#include <iastlutl.h>
#include <vector>
using namespace IASTL;

#include <eapfsm.h>

// Forward references.
class EAPType;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPStruct<T>
//
// DESCRIPTION
//
//    Wraps a raseapif struct to handle initialization.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class EAPStruct : public T
{
public:
   EAPStruct() throw ()
   { clear(); }

   void clear() throw ()
   {
      memset(this, 0, sizeof(T));
      dwSizeInBytes = sizeof(T);
   }
};

typedef EAPStruct<PPP_EAP_INPUT>  EAPInput;
typedef EAPStruct<PPP_EAP_OUTPUT> EAPOutput;


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPSession
//
// DESCRIPTION
//
//    This class encapsulates the state of an ongoing EAP session.
//
///////////////////////////////////////////////////////////////////////////////
class EAPSession
   : NonCopyable
{
public:
   EAPSession(
      const IASAttribute& accountName,
      std::vector<EAPType*>& eapTypes
      );
   ~EAPSession() throw ();

   // Returns the ID for this session.
   DWORD getID() const throw ()
   { return id; }

   PCWSTR getAccountName() const throw ()
   { return account->Value.String.pszWide; }

   // Begin a new session.
   IASREQUESTSTATUS begin(
                       IASRequest& request,
                       PPPP_EAP_PACKET recvPacket
                       );

   // Continue an existent session.
   IASREQUESTSTATUS process(
                       IASRequest& request,
                       PPPP_EAP_PACKET recvPacket
                       );

   static HRESULT initialize() throw ();
   static void finalize() throw ();

protected:

   // Performs the last action returned by the EAP DLL. May be called multiple
   // times per action due to retransmissions.
   IASREQUESTSTATUS doAction(IASRequest& request);

   void clearType() throw ();
   void setType(EAPType* newType);

   //////////
   // Constant properties of a session.
   //////////

   const DWORD id;             // Unique session ID.

   IASAttributeVector all;
   EAPInput eapInput;

   EAPType* currentType;        // current EAP type being used.

   const IASAttribute account; // NT4-Account-Name of the user.
   const IASAttribute state;   // State attribute.

   //////////
   // Current state of a session.
   //////////

   EAPFSM fsm;                 // FSM governing the session.
   DWORD maxPacketLength;      // Max. length of the send packet.
   IASAttributeVector profile; // Authorization profile.
   IASAttributeVector config;  // Configuration for the various EAP types.
   PVOID workBuffer;           // EAP DLL's context buffer.
   EAPOutput eapOutput;        // Last output from the EAP DLL.
   PPPP_EAP_PACKET sendPacket; // Last packet sent.

   // Next available session ID.
   static LONG theNextID;
   // Initialization refCount.
   static LONG theRefCount;
   // Session-Timeout for non-interactive sessions.
   static IASAttribute theNormalTimeout;
   // Session-Timeout for interactive sessions.
   static IASAttribute theInteractiveTimeout;
   // IAS event log handle;
   static HANDLE theIASEventLog;
   // RAS event log handle;
   static HANDLE theRASEventLog;
};

#endif  // _EAPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapfsm.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class EAPFSM.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPFSM_H
#define EAPFSM_H
#pragma once

#include <raseapif.h>
#include <vector>
#include "eaptype.h"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPFSM
//
// DESCRIPTION
//
//    Implements a Finite State Machine governing the EAP session lifecycle.
//    The state machine must be shown all incoming packets and all outgoing
//    actions. The main purpose of the FSM is to decide how to respond to
//    incoming messages.
//
///////////////////////////////////////////////////////////////////////////////
class EAPFSM
{
public:
   EAPFSM(std::vector<EAPType*>& eapTypes) throw ()
      : eapType((eapTypes.front())->dwEapTypeId),
        lastSendCode(0),
        state(0)
   {
      types.swap(eapTypes);
   }

   // Actions in response to messages.
   enum Action
   {
      MAKE_MESSAGE,       // Invoke RasEapMakeMessage.
      REPLAY_LAST,        // Replay the last response from the DLL.
      FAIL_NEGOTIATE,     // Negotiation failed -- reject the user.
      DISCARD             // Unexpected packet -- silently discard.
   };

   // Called to begin a session and retrieve the first type.
   EAPType* onBegin() throw ();

   // Called whenever the EAP extension DLL generates a new response.
   void onDllEvent(
           PPP_EAP_ACTION action,
           const PPP_EAP_PACKET& sendPacket
           ) throw ();

   // Called whenever a new packet is received.
   Action onReceiveEvent(
             const PPP_EAP_PACKET& recvPkt,
             EAPType*& newType
             ) throw ();

private:
   // Returns TRUE if the packet is an expected reponse.
   BOOL isExpected(const PPP_EAP_PACKET& recvPkt) const throw ();

   // Returns TRUE if the packet is a repeat.
   BOOL isRepeat(const PPP_EAP_PACKET& recvPkt) const throw ();

   Action selectNewType(BYTE proposal, EAPType*& newType) throw ();

   /////////
   // Various states for an EAP session.
   /////////

   enum State
   {
      STATE_INITIAL      = 0,
      STATE_NEGOTIATING  = 1,
      STATE_ACTIVE       = 2,
      STATE_DONE         = 3
   };

   // Last EAP type offered.
   BYTE eapType;
   std::vector<EAPType*> types;

   BYTE state;             // State of the session.
   BYTE lastRecvCode;      // Last packet code received.
   BYTE lastRecvId;        // Last packet ID received.
   BYTE lastRecvType;      // Last packet type received.
   BYTE lastSendCode;      // Last packet code sent.
   BYTE lastSendId;        // Next packet ID sent.
};


#endif  // EAPFSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapsessiontable.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPSessionTable.h
//
// SYNOPSIS
//
//    This file defines the class EAPSessionTable.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPSESSIONTABLE_H_
#define _EAPSESSIONTABLE_H_

#include <guard.h>
#include <nocopy.h>

#include <hashtbl.h>
#include <list>

#include <EAPSession.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPSessionTable
//
// DESCRIPTION
//
//    This class maintains a collection of EAPSession objects indexed by
//    session ID. The table also enforces a sessionTimeout which is the
//    maximum time a session will be kept before being deleted.
//
///////////////////////////////////////////////////////////////////////////////
class EAPSessionTable
   : Guardable, NonCopyable
{
public:

   EAPSessionTable() throw (std::bad_alloc);
   ~EAPSessionTable();

   // Session timeout is specified in milliseconds.
   DWORD getSessionTimeout() const throw ();
   void setSessionTimeout(DWORD newVal) throw ();

   DWORD getMaxSessions() const throw ()
   { return maxSessions; }
   void setMaxSessions(DWORD newVal) throw ()
   { maxSessions = newVal; }

   // Clears and deletes all sessions.
   void clear();

   void insert(EAPSession* session);
   EAPSession* remove(DWORD key) throw ();

protected:

   // Evicts all expired sessions.
   void evict(DWORDLONG now) throw ();

   // Evicts the oldest session.
   // Results are undefined if the session table is empty.
   void evictOldest() throw ();

   // List of (Session Expiry, Session) pairs. This list is kept sorted
   // by expiry and is used to evict expired sessions.
   typedef std::list < std::pair < DWORDLONG, EAPSession* > > SessionList;

   // A Session entry binds a SessionList iterator to a session. This allows
   // for efficient updating of the session list.
   typedef std::pair < EAPSession*, SessionList::iterator > SessionEntry;

   // Functor used for extracting the session ID from a SessionEntry.
   struct Extractor {
      DWORD operator()(const SessionEntry& entry) const throw ()
      { return entry.first->getID(); }
   };

   // Table of sessions indexed by session ID. Each entry also has an iterator
   // into the SessionList to allow for efficient removal.
   typedef hash_table < DWORD,
                        identity<DWORD>,
                        SessionEntry,
                        Extractor
                      > SessionTable;

   SessionList byExpiry;
   SessionTable byID;
   DWORDLONG sessionTimeout;
   DWORD maxSessions;         // Max. number of active sessions.
};

#endif  // _EAPSESSIONTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapstate.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPState.cpp
//
// SYNOPSIS
//
//    This file defines the class EAPState.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    08/26/1998    Consolidated into a single class.
//    01/25/2000    User IASGetHostByName.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>
#include <sdoias.h>

#include <lmcons.h>
#include <winsock2.h>

#include <eapstate.h>

//////////
// Current version of the state attribute.
//////////
const WORD IAS_STATE_VERSION = 1;

//////////
// Stores invariant fields of the state attribute. Computed during
// initialization.
//////////
EAPState::Layout invariant;

bool EAPState::isValid() const throw ()
{
   //////////
   // State attribute must have:
   //     (1) The correct length.
   //     (2) Same invariants.
   //     (3) A valid checksum.
   //////////
   return dwLength == sizeof(Layout) &&
          memcmp(get().vendorID, invariant.vendorID, 14) == 0 &&
          getChecksum() == IASAdler32(
                               get().vendorID,
                               sizeof(Layout) - FIELD_OFFSET(Layout, vendorID)
                               );
}

void EAPState::initialize() throw ()
{
   // Null everything out.
   memset(&invariant, 0, sizeof(invariant));

   // Set the vendor ID and version.
   IASInsertDWORD(invariant.vendorID, IAS_VENDOR_MICROSOFT);
   IASInsertWORD (invariant.version,  IAS_STATE_VERSION);

   // Try to set the server IP address. We don't care if this fails since
   // we may be running on a computer without IP installed.
   WCHAR computerName[CNLEN + 1];
   DWORD nchar = CNLEN + 1;
   if (GetComputerNameW(computerName, &nchar))
   {
      PHOSTENT hostEnt = IASGetHostByName(computerName);
      if (hostEnt)
      {
         memcpy(invariant.serverAddress, hostEnt->h_addr, 4);
         LocalFree(hostEnt);
      }
   }

   // Set the source ID.
   IASInsertDWORD(invariant.sourceID, IASAllocateUniqueID());
}

PIASATTRIBUTE EAPState::createAttribute(DWORD sessionID)
{
   //////////
   // Start with the parts that never change.
   //////////

   Layout value(invariant);

   //////////
   // Set the unique session ID.
   //////////

   IASInsertDWORD(value.sessionID, sessionID);

   //////////
   // Compute and insert the checksum.
   //////////

   IASInsertDWORD(
       value.checksum,
       IASAdler32(
           value.vendorID,
           sizeof(Layout) - FIELD_OFFSET(Layout, vendorID)
           )
       );

   //////////
   // Fill in the attribute fields.
   //////////

   IASTL::IASAttribute attr(true);
   attr->dwId    = RADIUS_ATTRIBUTE_STATE;
   attr->dwFlags = IAS_INCLUDE_IN_CHALLENGE;
   attr.setOctetString(sizeof(value), (const BYTE*)&value);

   return attr.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eapstate.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    eapstate.h
//
// SYNOPSIS
//
//    Declares the class EAPState.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    08/26/1998    Consolidated into a single class.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPSTATE_H_
#define _EAPSTATE_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaspolcy.h>
#include <iasutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    EAPState
//
// DESCRIPTION
//
//    The EAPState struct describes the wire-format of the RADIUS State
//    attribute used for EAP.
//
///////////////////////////////////////////////////////////////////////////////
struct EAPState : IAS_OCTET_STRING
{
   struct Layout
   {
      BYTE checksum[4];
      BYTE vendorID[4];
      BYTE version[2];
      BYTE serverAddress[4];
      BYTE sourceID[4];
      BYTE sessionID[4];
   };

   Layout& get() throw ()
   { return *(Layout*)lpValue; }

   const Layout& get() const throw ()
   { return *(Layout*)lpValue; }

   bool isValid() const throw ();

   //////////
   // Miscellaneous accessors.
   //////////

   DWORD getChecksum() const throw ()
   { return IASExtractDWORD(get().checksum); }

   DWORD getVendorID() const throw ()
   { return IASExtractDWORD(get().vendorID); }

   WORD getVersion() const throw ()
   { return IASExtractWORD(get().version); }

   DWORD getServerAddress() const throw ()
   { return IASExtractDWORD(get().serverAddress); }

   DWORD getSourceID() const throw ()
   { return IASExtractDWORD(get().sourceID); }

   DWORD getSessionID() const throw ()
   { return IASExtractDWORD(get().sessionID); }

   // Must be called before any calls to createAttribute.
   static void initialize() throw ();

   static PIASATTRIBUTE createAttribute(DWORD sessionID);
};

#endif   // _EAPSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eaptypes.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPTypes.h
//
// SYNOPSIS
//
//    This file describes the class EAPTypes.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    04/20/1998    Load DLL's on demand.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPTYPES_H_
#define _EAPTYPES_H_

#include <guard.h>
#include <nocopy.h>

class EAPType;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPTypes
//
// DESCRIPTION
//
//    This class implements a collection of EAP providers. Since there are
//    only 256 possible EAP types, the collection is implemented as a sparse
//    array.
//
///////////////////////////////////////////////////////////////////////////////
class EAPTypes
   : Guardable, NonCopyable
{
public:
   EAPTypes() throw ();
   ~EAPTypes() throw ();

   // Returns the EAPType object for a given type ID or NULL if the DLL was
   // not successfully loaded.
   EAPType* operator[](BYTE typeID) throw ();

   EAPType* getNameOnly(BYTE typeID) throw ();

   void initialize() throw ();
   void finalize() throw ();

protected:
   // Attempts to load a provider from the registry.
   EAPType* loadProvider(BYTE typeID) throw ();
   EAPType* loadProviderName(BYTE typeID) throw ();

   long refCount;            // Initialization refCount.
   EAPType* providers[256];  // Collection of providers.
};

#endif  // _EAPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\inc\iaslsa.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the private wrapper around LSA/SAM.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASLSA_H
#define IASLSA_H
#pragma once

#include <dsgetdc.h>
#include <lmcons.h>
#include <mprapi.h>

#ifndef _ASSERT
#define _ASSERT(f)   !(f) ? DebugBreak() : ((void)0)
#endif // _ASSERT

#ifdef __cplusplus
extern "C" {
#endif

//////////
// These are defined here to avoid dependencies on the NT headers.
//////////
#define _MSV1_0_CHALLENGE_LENGTH                 8
#define _NT_RESPONSE_LENGTH                     24
#define _LM_RESPONSE_LENGTH                     24
#define _MSV1_0_USER_SESSION_KEY_LENGTH         16
#define _MSV1_0_LANMAN_SESSION_KEY_LENGTH        8
#define _ENCRYPTED_LM_OWF_PASSWORD_LENGTH       16
#define _ENCRYPTED_NT_OWF_PASSWORD_LENGTH       16
#define _SAMPR_ENCRYPTED_USER_PASSWORD_LENGTH  516
#define _MAX_ARAP_USER_NAMELEN                  32
#define _AUTHENTICATOR_RESPONSE_LENGTH          20
#define _CHAP_RESPONSE_SIZE                     16

DWORD
WINAPI
IASLsaInitialize( VOID );

VOID
WINAPI
IASLsaUninitialize( VOID );

typedef struct _IAS_PAP_PROFILE {
   LARGE_INTEGER KickOffTime;
} IAS_PAP_PROFILE , *PIAS_PAP_PROFILE ;


DWORD
WINAPI
IASLogonPAP(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PCSTR Password,
    OUT PHANDLE Token,
    OUT PIAS_PAP_PROFILE Profile
    );

typedef struct _IAS_CHAP_PROFILE {
   LARGE_INTEGER KickOffTime;
} IAS_CHAP_PROFILE, *PIAS_CHAP_PROFILE;

DWORD
WINAPI
IASLogonCHAP(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN BYTE ChallengeID,
    IN PBYTE Challenge,
    IN DWORD ChallengeLength,
    IN PBYTE Response,
    OUT PHANDLE Token,
    OUT PIAS_CHAP_PROFILE Profile
    );

typedef struct _IAS_MSCHAP_PROFILE {
    WCHAR LogonDomainName[DNLEN + 1];
    UCHAR UserSessionKey[_MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[_MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    LARGE_INTEGER KickOffTime;
} IAS_MSCHAP_PROFILE, *PIAS_MSCHAP_PROFILE;

DWORD
WINAPI
IASLogonMSCHAP(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PBYTE Challenge,
    IN PBYTE NtResponse,
    IN PBYTE LmResponse,
    OUT PIAS_MSCHAP_PROFILE Profile,
    OUT PHANDLE Token
    );

DWORD
WINAPI
IASChangePassword1(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PBYTE Challenge,
    IN PBYTE LmOldPassword,
    IN PBYTE LmNewPassword,
    IN PBYTE NtOldPassword,
    IN PBYTE NtNewPassword,
    IN DWORD NewLmPasswordLength,
    IN BOOL NtPresent,
    OUT PBYTE NewNtResponse,
    OUT PBYTE NewLmResponse
    );

DWORD
WINAPI
IASChangePassword2(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE OldNtHash,
   IN PBYTE OldLmHash,
   IN PBYTE NtEncPassword,
   IN PBYTE LmEncPassword,
   IN BOOL LmPresent
   );

typedef struct _IAS_MSCHAP_V2_PROFILE {
    WCHAR LogonDomainName[DNLEN + 1];
    UCHAR AuthResponse[_AUTHENTICATOR_RESPONSE_LENGTH];
    UCHAR RecvSessionKey[_MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR SendSessionKey[_MSV1_0_USER_SESSION_KEY_LENGTH];
    LARGE_INTEGER KickOffTime;
} IAS_MSCHAP_V2_PROFILE, *PIAS_MSCHAP_V2_PROFILE;

DWORD
WINAPI
IASLogonMSCHAPv2(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PCSTR HashUserName,
    IN PBYTE Challenge,
    IN DWORD ChallengeLength,
    IN PBYTE Response,
    IN PBYTE PeerChallenge,
    OUT PIAS_MSCHAP_V2_PROFILE Profile,
    OUT PHANDLE Token
    );

DWORD
WINAPI
IASChangePassword3(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE EncHash,
   IN PBYTE EncPassword
   );

typedef struct _IAS_LOGON_HOURS {
    USHORT UnitsPerWeek;
    PUCHAR LogonHours;
} IAS_LOGON_HOURS, *PIAS_LOGON_HOURS;

DWORD
WINAPI
IASCheckAccountRestrictions(
    IN PLARGE_INTEGER AccountExpires,
    IN PIAS_LOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER KickOffTime
    );

typedef PVOID (WINAPI *PIAS_LSA_ALLOC)(
    IN SIZE_T uBytes
    );

DWORD
WINAPI
IASGetAliasMembership(
    IN PSID UserSid,
    IN PTOKEN_GROUPS GlobalGroups,
    IN PIAS_LSA_ALLOC Allocator,
    OUT PTOKEN_GROUPS *Groups,
    OUT PDWORD ReturnLength
    );

DWORD
WINAPI
IASGetGroupsForUser(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PIAS_LSA_ALLOC Allocator,
    OUT PTOKEN_GROUPS *Groups,
    OUT PDWORD ReturnLength,
    OUT PLARGE_INTEGER SessionTimeout
    );

DWORD
WINAPI
IASGetRASUserInfo(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PRAS_USER_0 RasUser0
    );

DWORD
WINAPI
IASGetUserParameters(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PWSTR *UserParameters
    );

typedef enum _IAS_DIALIN_PRIVILEGE {
    IAS_DIALIN_DENY,
    IAS_DIALIN_POLICY,
    IAS_DIALIN_ALLOW
} IAS_DIALIN_PRIVILEGE, *PIAS_DIALIN_PRIVILEGE;

DWORD
WINAPI
IASQueryDialinPrivilege(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PIAS_DIALIN_PRIVILEGE pfPrivilege
    );

DWORD
WINAPI
IASValidateUserName(
    IN PCWSTR UserName,
    IN PCWSTR Domain
    );

PCWSTR
WINAPI
IASGetDefaultDomain( VOID );

DWORD
WINAPI
IASGetDnsDomainName(LPWSTR buffer, LPDWORD bufferByteSize);


BOOL
WINAPI
IASIsDomainLocal(
    IN PCWSTR Domain
    );

typedef enum _IAS_ROLE {
    IAS_ROLE_STANDALONE,
    IAS_ROLE_MEMBER,
    IAS_ROLE_DC
} IAS_ROLE;

IAS_ROLE
WINAPI
IASGetRole( VOID );

typedef enum _IAS_PRODUCT_TYPE {
    IAS_PRODUCT_WORKSTATION,
    IAS_PRODUCT_SERVER
} IAS_PRODUCT_TYPE;

IAS_PRODUCT_TYPE
WINAPI
IASGetProductType( VOID );

DWORD
WINAPI
IASGetGuestAccountName(
    OUT PWSTR GuestAccount
    );

HRESULT
WINAPI
IASMapWin32Error(
    DWORD dwError,
    HRESULT hrDefault
    );

DWORD
WINAPI
IASGetDcName(
    IN LPCWSTR DomainName,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

DWORD
WINAPI
IASPurgeTicketCache( VOID );


#ifdef __cplusplus
}
#endif
#endif  // IASLSA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eaptypes.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    This file implements the class EAPTypes.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>

#include <EAPType.h>
#include <EAPTypes.h>

//////////
// Retrieves and possibly expands a registry value of type REG_SZ or
// REG_EXPAND_SZ. The caller is reponsible for deleting the returned string.
//////////
DWORD IASRegQuerySz(HKEY key, PWSTR valueName, PWSTR* value) throw ()
{
   _ASSERT(value != NULL);

   *value = NULL;

   LONG status;
   DWORD type;
   DWORD dataLength;

   // Determine the number of bytes required to hold the value.
   status = RegQueryValueEx(key, valueName, NULL, &type, NULL, &dataLength);
   if (status != NO_ERROR) { return status; }

   // Allocate temporary space on the stack for the value.
   PBYTE tmp = (PBYTE)_alloca(dataLength);

   // Retrieve the value.
   status = RegQueryValueExW(key, valueName, NULL, &type, tmp, &dataLength);
   if (status != NO_ERROR) { return status; }

   if (type == REG_SZ)
   {
      // Determine the length of the string.
      size_t len = wcslen((PCWSTR)tmp) + 1;

      // Allocate memory to hold the return value.
      *value = new (std::nothrow) WCHAR[len];
      if (!*value) { return ERROR_NOT_ENOUGH_MEMORY; }

      // Copy in the string.
      wcscpy(*value, (PCWSTR)tmp);
   }
   else if (type == REG_EXPAND_SZ)
   {
      // Determine the size of the fully expanded string.
      DWORD count = ExpandEnvironmentStringsW((PCWSTR)tmp, NULL, 0);

      // Allocate memory to hold the return value.
      *value = new (std::nothrow) WCHAR[count];
      if (!*value) { return ERROR_NOT_ENOUGH_MEMORY; }

      // Perform the actual expansion.
      if (ExpandEnvironmentStringsW((PCWSTR)tmp, *value, count) == 0)
      {
         // It failed, so clean up and return an error.
         delete *value;
         *value = NULL;
         return GetLastError();
      }
   }
   else
   {
      return ERROR_INVALID_DATA;
   }

   // We made it.
   return NO_ERROR;
}

EAPTypes::EAPTypes() throw ()
   : refCount(0)
{
   // Zero the providers array.
   memset(providers, 0, sizeof(providers));
}


EAPTypes::~EAPTypes() throw ()
{
   // Delete all the providers.
   for (size_t i = 0; i < 256; ++i) { delete providers[i]; }
}

void EAPTypes::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   ++refCount;
}

void EAPTypes::finalize() throw ()
{
   IASGlobalLockSentry sentry;

   if (--refCount == 0)
   {
      // Delete all the providers.
      for (size_t i = 0; i < 256; ++i) { delete providers[i]; }

      // Zero the providers array.
      memset(providers, 0, sizeof(providers));
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    EAPTypes::operator[]
//
// DESCRIPTION
//
//    First checks the providers array for the requested DLL and if not
//    present then invokes loadProvider().
//
///////////////////////////////////////////////////////////////////////////////
EAPType* EAPTypes::operator[](BYTE typeID) throw ()

{
   // Have we already loaded this DLL?
   EAPType* type = (EAPType*)InterlockedCompareExchangePointer(
                                 (PVOID*)(providers + typeID),
                                 NULL,
                                 NULL
                                 );

   // If not, then try to load it.
   // the EAPType* can be in the array but the dll not loaded yet
   // i.e. getNameOnly was called for that type
   if (!type || !type->isLoaded())
   {
      type = loadProvider(typeID);
   }

   // If we got it and it's supported, then return it.
   return type && type->isSupported() ? type : NULL;
}

EAPType* EAPTypes::getNameOnly(BYTE typeID) throw ()
{
   if (providers[typeID])
   {
      return providers[typeID];
   }
   _serialize
   // Double check now that we own the lock.
   if (providers[typeID])
   {
      return providers[typeID];
   }
   else
   {
      return loadProviderName(typeID);
   }
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    EAPTypes::loadProvider
//
// DESCRIPTION
//
//    Loads the requested EAP provider.
//
///////////////////////////////////////////////////////////////////////////////
EAPType* EAPTypes::loadProvider(BYTE typeID) throw ()
{
   _serialize

   // EAPType already partialy loaded?
   EAPType* retval = providers[typeID];

   if (!retval)
   {
      // never loaded before: loads now
      retval = loadProviderName(typeID);
      if (!retval)
      {
         // could not be loaded
         return 0;
      }
   }
   else
   {
      // one thread already completed the load while
      // this thread was blocked at the beginning of this function
      // the provider was already loaded successfully
      if (retval->isLoaded())
      {
         return retval;
      }
   }

   try
   {
      // Load the DLL ...
      DWORD error = retval->load();

      if (error == NO_ERROR)
      {
         IASTraceString("Successfully initialized DLL.");
      }
      else
      {
         IASTraceFailure("EAP DLL initialization", error);

         delete retval;
         retval = NULL;
         // do not remove it from the array. The name was retrieved correctly
         // so at least the name... can be cached
      }
   }
   catch (...)
   {
      IASTraceExcept();
   }

   return retval;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    EAPTypes::loadProviderName
//
// DESCRIPTION
//
//    Opens the registry and load the requested EAP provider.
//
///////////////////////////////////////////////////////////////////////////////
EAPType* EAPTypes::loadProviderName(BYTE typeID) throw ()
{
   // caller has to serialize the call and check for "already loaded
   // once the lock is held

   IASTracePrintf("Reading registry entries for EAP type %lu.", (DWORD)typeID);

   LONG status;

   //////////
   // Open the key where the EAP providers are installed.
   //////////

   CRegKey eapKey;
   status = eapKey.Open(HKEY_LOCAL_MACHINE,
                        RAS_EAP_REGISTRY_LOCATION,
                        KEY_READ);
   if (status != NO_ERROR)
   {
      IASTraceFailure("RegOpenKeyEx", status);
      return NULL;
   }

   //////////
   // Convert the type ID to ASCII.
   //////////

   WCHAR name[20];
   _ultow(typeID, name, 10);

   //////////
   // Open the sub-key.
   //////////

   CRegKey providerKey;
   status = providerKey.Open(eapKey,
                             name,
                             KEY_READ);
   if (status != NO_ERROR)
   {
      IASTraceFailure("RegOpenKeyEx", status);
      return NULL;
   }

   //////////
   // Read the path of the provider DLL.
   //////////

   PWSTR dllPath;
   status = IASRegQuerySz(providerKey,
                          RAS_EAP_VALUENAME_PATH,
                          &dllPath);
   if (status != NO_ERROR)
   {
      IASTraceFailure("IASRegQuerySz", status);
      return NULL;
   }

   IASTracePrintf("Path: %S", dllPath);

   //////////
   // Read the provider's friendly name.
   //////////

   PWSTR friendlyName;
   status = IASRegQuerySz(providerKey,
                          RAS_EAP_VALUENAME_FRIENDLY_NAME,
                          &friendlyName);
   if (status != NO_ERROR)
   {
      IASTraceFailure("IASRegQuerySz", status);
      delete[] dllPath;
      return NULL;
   }

   IASTracePrintf("FriendlyName: %S", friendlyName);

   //////////
   // Read the stand-alone supported value.
   //////////

   DWORD standaloneSupported = TRUE;  // Default is 'TRUE'.
   providerKey.QueryValue(
                   standaloneSupported,
                   RAS_EAP_VALUENAME_STANDALONE_SUPPORTED
                   );

   IASTracePrintf("Standalone supported: %lu", standaloneSupported);

   //////////
   // Try to load the DLL and add it to our collection.
   //////////

   EAPType* retval = NULL;

   try
   {
      retval = new EAPType(friendlyName, typeID, standaloneSupported, dllPath);

      IASTraceString("Will not load the DLL: only getting its friendly name");

      // ... and store it in the providers array.
      InterlockedExchangePointer((PVOID*)(providers + typeID), retval);
   }
   catch (const std::bad_alloc& )
   {
      IASTraceExcept();
   }
   catch (const _com_error& )
   {
      IASTraceExcept();
   }

   delete[] dllPath;
   delete[] friendlyName;

   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eaptype.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPType.cpp
//
// SYNOPSIS
//
//    This file implements the class EAPType.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    09/12/1998    Add standaloneSupported flag.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "sdoias.h"
#include "eaptype.h"
#include "eaptypes.h"
#include "eap.h"
#include <strsafe.h>

//////////
// Signature of the entry point into the extension DLL.
//////////
typedef DWORD (APIENTRY *PRAS_EAP_GET_INFO)(
    DWORD dwEapTypeId,
    PPP_EAP_INFO* pEapInfo
    );

EAPType::EAPType(
                   PCWSTR name, 
                   DWORD typeID, 
                   BOOL standalone, 
                   const wchar_t* path
                 )
   : code(static_cast<BYTE>(typeID)),
     eapFriendlyName(true),
     eapTypeId(true),
     standaloneSupported(standalone),
     dll(NULL),
     dllPath(NULL)
{
   /////////
   // Save the friendly name.
   /////////

   eapFriendlyName.setString(name);
   eapFriendlyName->dwId = IAS_ATTRIBUTE_EAP_FRIENDLY_NAME;


   /////////
   // Save the type Id.
   /////////

   eapTypeId->Value.Integer = typeID;
   eapTypeId->dwId = IAS_ATTRIBUTE_EAP_TYPEID;

   /////////
   // Initialize the base struct.
   /////////

   memset((PPPP_EAP_INFO)this, 0, sizeof(PPP_EAP_INFO));
   dwSizeInBytes = sizeof(PPP_EAP_INFO);
   dwEapTypeId = typeID;

   /////////
   // save the dll path
   /////////

   size_t cchPath = wcslen(path);
   dllPath = new wchar_t[cchPath + 1];
   HRESULT hr = StringCchCopyW(dllPath, cchPath + 1, path);
   if (FAILED(hr))
   {
      delete[] dllPath;
      _com_issue_error(hr);
   }
}

EAPType::~EAPType()
{
   if (dll)
   {
      if (RasEapInitialize)
      {
         RasEapInitialize(FALSE);
      }

      FreeLibrary(dll);
   }
   if (dllPath)
   {
      delete[] dllPath;
   }
}

DWORD EAPType::cleanLoadFailure(
                                  PCSTR errorString, 
                                  HINSTANCE dllInstance
                                ) throw()
{
   _ASSERT(errorString);
   DWORD status = GetLastError();
   IASTraceFailure(errorString, status);
   if (dllInstance)
   {
      FreeLibrary(dllInstance);
   }
   return status;
}

///////////////////////////////////////////////////////////////////////////////
// dll will be used to check if the EAP provider was loaded or not
// therefore dll should be null if anything failed in the load function
///////////////////////////////////////////////////////////////////////////////
DWORD EAPType::load() throw ()
{
   /////////
   // Load the DLL.
   /////////

   HINSTANCE dllInstance = LoadLibraryW(dllPath);
   if (dllInstance == NULL)
   {
      return cleanLoadFailure("LoadLibraryW");
   }

   /////////
   // Lookup the entry point.
   /////////

   PRAS_EAP_GET_INFO RasEapGetInfo;
   RasEapGetInfo = (PRAS_EAP_GET_INFO)GetProcAddress(
                                          dllInstance,
                                          "RasEapGetInfo"
                                          );

   if (!RasEapGetInfo)
   {
      return cleanLoadFailure("GetProcAddress", dllInstance);
   }

   /////////
   // Ask the DLL to fill in the PPP_EAP_INFO struct.
   /////////

   DWORD status = RasEapGetInfo(dwEapTypeId, this);

   if (status != NO_ERROR)
   {
      return cleanLoadFailure("RasEapGetInfo", dllInstance);
   }

   /////////
   // Initialize the DLL if necessary.
   /////////

   if (RasEapInitialize)
   {
      status = RasEapInitialize(TRUE);

      if (status != NO_ERROR)
      {
         return cleanLoadFailure("RasEapInitialize", dllInstance);
      }
   }

   // set dll now so isLoaded will return true only when load is successful
   dll = dllInstance;
   return NO_ERROR;
}

void EAPType::storeNameId(IASRequest& request)
{
   // If this is not PEAP: straightforward
   if (dwEapTypeId != 25)
   {
      eapFriendlyName.store(request);
      eapTypeId.store(request);
   }
   else
   {
      // Get the embedded PEAP ID
      IASTL::IASAttribute peapType;
      DWORD attributeId = MS_ATTRIBUTE_PEAP_EMBEDDED_EAP_TYPEID;
      if (!peapType.load(request, attributeId))
      {
         // remove the previous auth type (EAP) and store the new one (PEAP)
         setAuthenticationTypeToPeap(request);
         // let the EAPSession code handle the failure
         // PEAP was used but did not set any PEAP type
         // happen when PEAP Type requested by the client is not enabled
         return;
      }

      BYTE typeId = (BYTE) peapType->Value.Integer;
      EAPType* peapInsideType = EAP::theTypes[typeId];
      if (peapInsideType == 0)
      {
         // remove the previous auth type (EAP) and store the new one (PEAP)
         setAuthenticationTypeToPeap(request);
         // let the EAPSession code handle the failure
         return;
      }

      // remove the previous auth type (EAP) and store the new one (PEAP)
      setAuthenticationTypeToPeap(request);

      // store the friendlyname and id of the embedded type as the 
      // EAP type.
      peapInsideType->getFriendlyName().store(request);
      
      peapInsideType->getTypeId().store(request);
   }
}

void EAPType::setAuthenticationTypeToPeap(IASRequest& request)
{
   // remove the previous auth type (EAP) and store the new one (PEAP)
   DWORD authTypeId = IAS_ATTRIBUTE_AUTHENTICATION_TYPE;
   IASTL::IASAttribute authenticationType(true);

   authenticationType->dwId = authTypeId;
   authenticationType->Value.itType = IASTYPE_ENUM;
   authenticationType->Value.Enumerator = IAS_AUTH_PEAP;
   request.RemoveAttributesByType(1, &authTypeId);
   authenticationType.store(request);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\eap\eaptype.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    EAPType.h
//
// SYNOPSIS
//
//    This file describes the class EAPType.
//
// MODIFICATION HISTORY
//
//    01/15/1998    Original version.
//    09/12/1998    Add standaloneSupported flag.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EAPTYPE_H_
#define _EAPTYPE_H_

#include <nocopy.h>
#include <raseapif.h>

#include <iaslsa.h>
#include <iastlutl.h>
using namespace IASTL;

// Forward references.
class EAPTypes;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    EAPType
//
// DESCRIPTION
//
//    This class provides a wrapper around a DLL implementing a particular
//    EAP type.
//
///////////////////////////////////////////////////////////////////////////////
class EAPType
   : public PPP_EAP_INFO, private NonCopyable
{
public:
   EAPType(PCWSTR name, DWORD typeID, BOOL standalone, const wchar_t* path);
   ~EAPType() throw ();

   BYTE typeCode() const throw ();

   DWORD load() throw ();

   bool isLoaded() const throw();

   const IASAttribute& getFriendlyName() const throw ()
   { return eapFriendlyName; }

   const IASAttribute& getTypeId() const throw ()
   { return eapTypeId; }

   BOOL isSupported() const throw ()
   { return standaloneSupported || IASGetRole() != IAS_ROLE_STANDALONE; }

   void storeNameId(IASRequest& request);

protected:
   void setAuthenticationTypeToPeap(IASRequest& request);
   
   DWORD cleanLoadFailure(
                             PCSTR errorString, 
                             HINSTANCE dllInstance = 0
                          ) throw();

   // The EAP type code.
   BYTE code;

   // The friendly name of the provider.
   IASAttribute eapFriendlyName;

   // The EAP Type ID
   IASAttribute eapTypeId;

   // TRUE if this type is supported on stand-alone servers.
   BOOL standaloneSupported;

   // The DLL containing the EAP provider extension.
   HINSTANCE dll;

   // the path to the dll
   wchar_t* dllPath;
};


inline BYTE EAPType::typeCode() const throw ()
{
   return code;
}

inline bool EAPType::isLoaded() const throw()
{
   return dll != NULL;
}


#endif  // _EAPTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\inc\iasntds.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    iasntds.h
//
// SYNOPSIS
//
//    Declares global objects and functions for the IAS NTDS API.
//
// MODIFICATION HISTORY
//
//    05/11/1998    Original version.
//    07/13/1998    Clean up header file dependencies.
//    08/25/1998    Added IASNtdsQueryUserAttributes.
//    09/02/1998    Added 'scope' parameter to IASNtdsQueryUserAttributes.
//    03/10/1999    Added IASNtdsIsNativeModeDomain.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASNTDS_H_
#define _IASNTDS_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <winldap.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////
// API must be initialized prior to accessing any of the global objects.
//////////
DWORD
WINAPI
IASNtdsInitialize( VOID );

//////////
// API should be uninitialized when done.
//////////
VOID
WINAPI
IASNtdsUninitialize( VOID );

//////////
// Returns TRUE if the specified domain is running in native mode.
//////////
BOOL
WINAPI
IASNtdsIsNativeModeDomain(
    IN PCWSTR domain
    );


typedef struct _IAS_NTDS_RESULT {
   HANDLE cxn;
   PLDAPMessage msg;
} IAS_NTDS_RESULT, *PIAS_NTDS_RESULT;

//////////
// Reads attributes from a user object.
//////////
DWORD
WINAPI
IASNtdsQueryUserAttributes(
    IN PCWSTR domain,
    IN PCWSTR username,
    IN ULONG scope,
    IN PWCHAR attrs[],
    OUT PIAS_NTDS_RESULT result
    );

//////////
// Frees a result struct.
//////////
VOID
WINAPI
IASNtdsFreeResult(
   PIAS_NTDS_RESULT result
   );

#ifdef __cplusplus


// Simple RAII wrapper around an IAS_NTDS_RESULT struct.
class IASNtdsResult : public IAS_NTDS_RESULT
{
public:
   IASNtdsResult() throw ();
   ~IASNtdsResult() throw ();

private:
   // Not implemented.
   // IASNtdsResult(const IASNtdsResult&);
   // IASNtdsResult& operator=(const IASNtdsResult&);
};


inline IASNtdsResult::IASNtdsResult() throw ()
{
   cxn = 0;
   msg = 0;
}


inline IASNtdsResult::~IASNtdsResult() throw ()
{
   IASNtdsFreeResult(this);
}

}
#endif
#endif // _IASNTDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\inc\iasparms.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasparms.h
//
// SYNOPSIS
//
//    Declares functions for storing and retrieving (name, value) pairs from
//    the SAM UserParameters field.
//
// MODIFICATION HISTORY
//
//    10/16/1998    Original version.
//    02/11/1999    Add RasUser0 functions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASPARMS_H_
#define _IASPARMS_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifndef IASSAMAPI
#define IASSAMAPI DECLSPEC_IMPORT
#endif

#include <mprapi.h>

#ifdef __cplusplus
extern "C" {
#endif

IASSAMAPI
DWORD
WINAPI
IASParmsSetRasUser0(
    IN OPTIONAL PCWSTR pszOldUserParms,
    IN CONST RAS_USER_0 *pRasUser0,
    OUT PWSTR* ppszNewUserParms
    );

IASSAMAPI
DWORD
WINAPI
IASParmsQueryRasUser0(
    IN OPTIONAL PCWSTR pszUserParms,
    OUT PRAS_USER_0 pRasUser0
    );

IASSAMAPI
HRESULT
WINAPI
IASParmsSetUserProperty(
    IN OPTIONAL PCWSTR pszUserParms,
    IN PCWSTR pszName,
    IN CONST VARIANT *pvarValue,
    OUT PWSTR *ppszNewUserParms
    );

IASSAMAPI
HRESULT
WINAPI
IASParmsQueryUserProperty(
    IN PCWSTR pszUserParms,
    IN PCWSTR pszName,
    OUT VARIANT *pvarValue
    );

IASSAMAPI
VOID
WINAPI
IASParmsFreeUserParms(
    IN PWSTR pszNewUserParms
    );

#ifdef __cplusplus
}
#endif
#endif  // _IASPARMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\inc\lockout.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    lockout.h
//
// SYNOPSIS
//
//    Declares the account lockout API.
//
// MODIFICATION HISTORY
//
//    10/21/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _LOCKOUT_H_
#define _LOCKOUT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
AccountLockoutInitialize( VOID );

VOID
WINAPI
AccountLockoutShutdown( VOID );

BOOL
WINAPI
AccountLockoutOpenAndQuery(
    IN  PCWSTR pszUser,
    IN  PCWSTR pszDomain,
    OUT PHANDLE phAccount
    );

VOID
WINAPI
AccountLockoutUpdatePass(
    IN HANDLE hAccount
    );

VOID
WINAPI
AccountLockoutUpdateFail(
    IN HANDLE hAccount
    );

VOID
WINAPI
AccountLockoutClose(
    IN HANDLE hAccount
    );

#ifdef __cplusplus
}
#endif
#endif  // _LOCKOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ldapcxn.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ldapcxn.h
//
// SYNOPSIS
//
//    Declares the class LDAPConnection.
//
// MODIFICATION HISTORY
//
//    05/07/1998    Original version.
//    06/10/1998    Added getHost() method.
//    08/25/1998    Added 'base' property.
//    09/16/1998    Perform access check after bind.
//    04/14/1999    Specify domain and server when opening a connection.
//    09/14/1999    Add SEARCH_TIMEOUT.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  _LDAPCXN_H_
#define  _LDAPCXN_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>
#include <winldap.h>

class LDAPServer;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LDAPConnection
//
// DESCRIPTION
//
//    This class allows multiple clients to share a single LDAP connection.
//    The connection is reference counted and will be automatically unbound
//    when the last reference is released. It also contains a disabled flag
//    that any client can use to indicate that the connection has gone bad.
//
///////////////////////////////////////////////////////////////////////////////
class LDAPConnection
   : NonCopyable
{
public:
   void AddRef() throw ()
   { InterlockedIncrement(&refCount); }

   void Release() throw ();

   void disable() throw ()
   { disabled = TRUE; }

   BOOL isDisabled() const throw ()
   { return disabled; }

   PLDAP get() const throw ()
   { return connection; }

   PCWSTR getBase() const throw ()
   { return base; }

   PCSTR getHost() const throw ()
   { return connection->ld_host; }

   operator PLDAP() const throw ()
   { return connection; }

   static DWORD createInstance(
                    PCWSTR domain,
                    PCWSTR server,
                    LDAPConnection** cxn
                    ) throw ();

   static LDAP_TIMEVAL SEARCH_TIMEOUT;

   void TraceFailure(
           PCSTR functionName,
           ULONG errorCode
           );

protected:

   LDAPConnection(PLDAP ld) throw ()
      : connection(ld),
        refCount(1),
        disabled(FALSE),
        base(NULL)
   { }

   ~LDAPConnection() throw ()
   {
      delete[] base;
      ldap_unbind(connection);
   }

   // Verifies that we have sufficient access to the remote server.
   DWORD checkAccess() throw ();

   // Initializes 'base' by reading the defaultNamingContext from the RootDSE.
   DWORD readRootDSE() throw ();

   PLDAP connection;
   LONG  refCount;
   BOOL  disabled;
   PWSTR base;       // Base DN of this connection. Useful for doing
                     // subtree searches of the entire server.
};

void IASTraceLdapFailure(
         PCSTR functionName,
         ULONG errorCode,
         LDAP* connection = NULL
         );

#endif  // _LDAPCXN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ldapcxn.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ldapcxn.cpp
//
// SYNOPSIS
//
//    This file defines the class LDAPConnection.
//
// MODIFICATION HISTORY
//
//    05/08/1998    Original version.
//    09/16/1998    Perform access check after bind.
//    03/23/1999    Set timeout for connect.
//    04/14/1999    Specify domain and server when opening a connection.
//    07/09/1999    Disable auto reconnect.
//    09/14/1999    Always specify timeout for LDAP searches.
//    01/25/2000    Encrypt LDAP connections.
//                  Pass server name (not domain) to ldap_initW.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <ntldap.h>
#define  SECURITY_WIN32
#include <security.h>
#include <new>

#include <ldapcxn.h>

// Search timeout.
LDAP_TIMEVAL LDAPConnection::SEARCH_TIMEOUT = { 10, 0 };

namespace
{
   // Timeout for LDAP connects.
   LDAP_TIMEVAL CONNECT_TIMEOUT = { 15, 0 };

   // RDN for the dummy object used for access checks.
   const WCHAR DUMMY_OBJECT[] =
      L"CN=RAS and IAS Servers Access Check,CN=System,";

   /* Credentials for Kerberos-only bind.
   SEC_WINNT_AUTH_IDENTITY_EXW BIND_CREDENTIALS =
   {
      SEC_WINNT_AUTH_IDENTITY_VERSION,
      sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
      NULL,
      0,
      NULL,
      0,
      NULL,
      0,
      SEC_WINNT_AUTH_IDENTITY_UNICODE,
      L"Kerberos",
      8
   };
   */
}

void LDAPConnection::Release() throw ()
{
   if (!InterlockedDecrement(&refCount))
   {
      delete this;
   }
}

DWORD LDAPConnection::createInstance(
                          PCWSTR domain,
                          PCWSTR server,
                          LDAPConnection** cxn
                          ) throw ()
{
   DWORD status;
   ULONG opt;

   // Check the input parameters.
   if (cxn == NULL) { return ERROR_INVALID_PARAMETER; }

   // Initialize the connection.
   LDAP* ld = ldap_initW(
                  const_cast<PWCHAR>(server),
                  LDAP_PORT
                  );
   if (ld == NULL)
   {
      return LdapMapErrorToWin32(LdapGetLastError());
   }

   // Set the domain name.
   status = ldap_set_optionW(ld, LDAP_OPT_DNSDOMAIN_NAME, &domain);
   if (status != LDAP_SUCCESS)
   {
      IASTraceLdapFailure("ldap_set_optionW", status, ld);
      ldap_unbind(ld);
      return LdapMapErrorToWin32(status);
   }
   
   opt = PtrToUlong(LDAP_OPT_ON);
   status = ldap_set_optionW(ld, LDAP_OPT_AREC_EXCLUSIVE, &opt);
   if (status != LDAP_SUCCESS)
   {
      IASTraceLdapFailure("ldap_set_optionW", status, ld);
      ldap_unbind(ld);
      return LdapMapErrorToWin32(status);
   }

   // Turn on encryption.
   opt = PtrToUlong(LDAP_OPT_ON);
   status = ldap_set_optionW(ld, LDAP_OPT_ENCRYPT, &opt);
   if (status != LDAP_SUCCESS)
   {
      IASTraceLdapFailure("ldap_set_optionW", status, ld);
      ldap_unbind(ld);
      return LdapMapErrorToWin32(status);
   }

   // Connect to the server ...
   status = ldap_connect(ld, &CONNECT_TIMEOUT);
   if (status == LDAP_SUCCESS)
   {
      // ... and bind the connection.
      status = ldap_bind_sW(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
      if (status != LDAP_SUCCESS)
      {
         IASTraceLdapFailure("ldap_bind_s", status, ld);
         ldap_unbind(ld);
         return LdapMapErrorToWin32(status);
      }
   }
   else
   {
      IASTraceLdapFailure("ldap_connect", status, ld);
      ldap_unbind(ld);
      return LdapMapErrorToWin32(status);
   }

   // Turn off automatic chasing of referrals.
   opt = PtrToUlong(LDAP_OPT_OFF);
   ldap_set_option(ld, LDAP_OPT_REFERRALS, &opt);

   // Turn off auto reconnect of bad connections.
   opt = PtrToUlong(LDAP_OPT_OFF);
   ldap_set_option(ld, LDAP_OPT_AUTO_RECONNECT, &opt);

   // Turn on ldap_conn_from_msg.
   opt = PtrToUlong(LDAP_OPT_ON);
   ldap_set_option(ld, LDAP_OPT_REF_DEREF_CONN_PER_MSG, &opt);

   // Create the LDAPConnection wrapper.
   LDAPConnection* newCxn = new (std::nothrow) LDAPConnection(ld);
   if (newCxn == NULL)
   {
      ldap_unbind(ld);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // Read the RootDSE.
   status = newCxn->readRootDSE();

   // Check access permissions.
   if (status == NO_ERROR) 
   { 
      status = newCxn->checkAccess(); 
   }

   // Process the result.
   if (status == NO_ERROR)
   {
      *cxn = newCxn;
   }
   else
   {
      newCxn->Release();
   }

   return status;
}

//////////
//
// NOTE: This doesn't have to be serialized since it's only called from
//       within createInstance.
//
//////////
DWORD LDAPConnection::checkAccess() throw ()
{
   // Allocate a temporary buffer for the DN.
   size_t len = wcslen(base) * sizeof(WCHAR) + sizeof(DUMMY_OBJECT);
   PWSTR dn = (PWSTR)_alloca(len);

   // Construct the DN of the dummy object.
   memcpy(dn, DUMMY_OBJECT, sizeof(DUMMY_OBJECT));
   wcscat(dn, base);

   // Try to read the dummy object.
   PWCHAR attrs[] = { L"CN", NULL };
   LDAPMessage* res = NULL;
   ULONG ldapError = ldap_search_ext_sW(
                         connection,
                         dn,
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         attrs,
                         TRUE,
                         NULL,
                         NULL,
                         &SEARCH_TIMEOUT,
                         0,
                         &res
                         );

   // We have two different error codes.
   if (ldapError == LDAP_SUCCESS)
   {
      ldapError = res->lm_returncode;
   }

   DWORD status = NO_ERROR;

   if (ldapError != LDAP_SUCCESS)
   {
      TraceFailure("ldap_search_ext_sW", ldapError);
      status = LdapMapErrorToWin32(ldapError);
   }
   else
   {
      // Get the first attribute from the first entry.
      BerElement* ptr;
      PWCHAR attr = ldap_first_attributeW(
                        connection,
                        ldap_first_entry(connection, res),
                        &ptr
                        );

      // If we couldn't read any attributes, then we must not be a member
      // of the RAS and IAS Servers group.
      if (attr == NULL)
      { 
         status = ERROR_ACCESS_DENIED;
      }
   }

   ldap_msgfree(res);

   return status;
}

//////////
//
// NOTE: This doesn't have to be serialized since it's only called from
//       within createInstance.
//
//////////
DWORD LDAPConnection::readRootDSE() throw ()
{
   //////////
   // Read the defaultNamingContext from the RootDSE.
   //////////

   PWCHAR attrs[] = { LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W, NULL };
   LDAPMessage* res = NULL;
   ULONG ldapError = ldap_search_ext_sW(
                         connection,
                         L"",
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         attrs,
                         0,
                         NULL,
                         NULL,
                         &SEARCH_TIMEOUT,
                         0,
                         &res
                         );

   // We have two different error codes.
   if (ldapError == LDAP_SUCCESS)
   {
      ldapError = res->lm_returncode;
   }

   if (ldapError != LDAP_SUCCESS)
   {
      TraceFailure("ldap_search_ext_sW",  ldapError);
      ldap_msgfree(res);
      return LdapMapErrorToWin32(ldapError);
   }

   //////////
   // The search succeeded, so get the attribute value.
   //////////

   PWCHAR* vals = ldap_get_valuesW(
                      connection,
                      ldap_first_entry(connection, res),
                      LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W
                      );
   DWORD status;

   if (vals && *vals)
   {
      // We got something, so save the value.
      base = ias_wcsdup(*vals);

      status = base ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
   }
   else
   {
      // It's a mandatory attribute but we can't see it, so we must not have
      // sufficient permission.
      status = ERROR_ACCESS_DENIED;
   }

   ldap_value_freeW(vals);

   ldap_msgfree(res);

   return status;
}

void LDAPConnection::TraceFailure(
    PCSTR functionName,
    ULONG errorCode
    )
{
   IASTraceLdapFailure(functionName, errorCode, connection);
}

void IASTraceLdapFailure(
    PCSTR functionName,
    ULONG errorCode,
    LDAP* cxn
    )
{
   _ASSERT(functionName != NULL);
   
   IASTracePrintf("LDAP ERROR in %s. Code = %d", functionName, errorCode);
   
   PWCHAR errorString = NULL;
   ULONG result = ldap_get_optionW(
                     cxn, 
                     LDAP_OPT_SERVER_ERROR, 
                     (void*) &errorString
                     );
   if (result == LDAP_SUCCESS)
   {
      IASTracePrintf("Extended error string: %S", errorString);
      // do what you want with the string here
      ldap_memfree(errorString);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\inc\samutil.h ===
/////////////////////////////////////////////////////////////////////////////// //
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    This file describes functions and macros common to all SAM handlers.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SAMUTIL_H
#define SAMUTIL_H
#pragma once

#include <ntdsapi.h>
#include <iaspolcy.h>
#include <iastl.h>
#include <iastlutl.h>
using namespace IASTL;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASStoreFQUserName
//
// DESCRIPTION
//
//    Stores the Fully-Qualified-User-Name.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASStoreFQUserName(
    IAttributesRaw* request,
    DS_NAME_FORMAT format,
    PCWSTR fqdn
    );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASEncryptBuffer
//
// DESCRIPTION
//
//    Encrypts the buffer using the appropriate shared secret and authentictor
//    for 'request'.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASEncryptBuffer(
    IAttributesRaw* request,
    BOOL salted,
    PBYTE buf,
    ULONG buflen
    ) throw ();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASProcessFailure
//
// DESCRIPTION
//
//    Handles any failure during processing of an Access-Request. This function
//    will set the response code for the request based on hrReason and return
//    an appropriate request status. This ensures that all failures are
//    handled consistently across handlers.
//
///////////////////////////////////////////////////////////////////////////////
IASREQUESTSTATUS
WINAPI
IASProcessFailure(
    IRequest* pRequest,
    HRESULT hrReason
    ) throw ();

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SamExtractor
//
// DESCRIPTION
//
//    This class parses a NT4 Account Name of the form "<domain>\<username>"
//    into its separate components. Then replaces the backslash when it goes
//    out of scope.
//
///////////////////////////////////////////////////////////////////////////////
class SamExtractor
{
public:
   SamExtractor(const IASATTRIBUTE& identity);
   ~SamExtractor() throw ();

   const wchar_t* getDomain() const throw ();
   const wchar_t* getUsername() const throw ();

private:
   wchar_t* begin;
   wchar_t* delim;

   // Not implemented
   SamExtractor(const SamExtractor&);
   SamExtractor& operator=(const SamExtractor&);
};

inline SamExtractor::~SamExtractor() throw ()
{
   if (delim != 0)
   {
      *delim = L'\\';
   }
}

inline const wchar_t* SamExtractor::getDomain() const throw ()
{
   return (delim != 0) ? begin : L"";
}

inline const wchar_t* SamExtractor::getUsername() const throw ()
{
   return (delim != 0) ? (delim + 1) : begin;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NtSamHandler
//
// DESCRIPTION
//
//    Abstract base class for sub-handlers that process NT-SAM users.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) NtSamHandler
{
public:
   virtual ~NtSamHandler() throw ()
   { }

   virtual HRESULT initialize() throw ()
   { return S_OK; }

   virtual void finalize() throw ()
   { }
};

void InsertInternalTimeout(
        IASTL::IASRequest& request,
        const LARGE_INTEGER& kickOffTime
        );

#endif  // _SAMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ntcache.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ntcache.cpp
//
// SYNOPSIS
//
//    Defines the class NTCache.
//
// MODIFICATION HISTORY
//
//    05/11/1998    Original version.
//    03/12/1999    Improve locking granularity.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <ntcache.h>

//////////
// Utility function for getting the current system time as a 64-bit integer.
//////////
inline DWORDLONG GetSystemTimeAsDWORDLONG() throw ()
{
   ULARGE_INTEGER ft;
   GetSystemTimeAsFileTime((LPFILETIME)&ft);
   return ft.QuadPart;
}

NTCache::~NTCache()
{
   clear();
}

void NTCache::clear() throw ()
{
   Lock();

   // Release all the domains.
   for (DomainTable::iterator i = cache.begin(); i.more(); ++i)
   {
      (*i)->Release();
   }

   // Clear the hash table.
   cache.clear();

   Unlock();
}

DWORD NTCache::getConnection(PCWSTR domainName, LDAPConnection** cxn) throw ()
{
   _ASSERT(cxn != NULL);

   NTDomain* domain;
   DWORD status = getDomain(domainName, &domain);

   if (status == NO_ERROR)
   {
      status = domain->getConnection(cxn);
      domain->Release();
   }
   else
   {
      *cxn = NULL;
   }

   return status;
}

DWORD NTCache::getDomain(PCWSTR domainName, NTDomain** domain) throw ()
{
   _ASSERT(domain != NULL);

   DWORD status = NO_ERROR;

   Lock();

   // Check if we already have an entry for this domainName.
   NTDomain* const* existing = cache.find(domainName);

   if (existing)
   {
      (*domain = *existing)->AddRef();
   }
   else
   {
      // We don't have this domain, so create a new one ...
      *domain = NTDomain::createInstance(domainName);

      // Evict expired entries.
      evict();

      try
      {
         // Try to insert the domain ...
         cache.multi_insert(*domain);

         // ... and AddRef if we succeeded.
         (*domain)->AddRef();
      }
      catch (...)
      {
         // We don't care if the insert failed.
      }
   }

   Unlock();

   return *domain ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
}

NTDomain::Mode NTCache::getMode(PCWSTR domainName) throw ()
{
   NTDomain::Mode mode = NTDomain::MODE_UNKNOWN;

   NTDomain* domain;
   if (getDomain(domainName, &domain) == NO_ERROR)
   {
      mode = domain->getMode();
      domain->Release();
   }

   return mode;
}

void NTCache::evict() throw ()
{
   //////////
   // Note: This method is not serialized.
   //////////

   DWORDLONG now = GetSystemTimeAsDWORDLONG();

   DomainTable::iterator i = cache.begin();

   while (i.more())
   {
      if ((*i)->isObsolete(now))
      {
         // The entry has expired, so release and erase.
         (*i)->Release();
         cache.erase(i);
      }
      else
      {
         ++i;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\iasntds.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    iasntds.cpp
//
// SYNOPSIS
//
//    Defines global objects and functions for the IAS NTDS API.
//
// MODIFICATION HISTORY
//
//    05/11/1998    Original version.
//    07/13/1998    Clean up header file dependencies.
//    08/25/1998    Added IASNtdsQueryUserAttributes.
//    09/02/1998    Added 'scope' parameter to IASNtdsQueryUserAttributes.
//    03/10/1999    Added IASNtdsIsNativeModeDomain.
//    03/23/1999    Retry failed searches.
//    05/11/1999    Ask for at least one attribute or else you get them all.
//    09/14/1999    Move SEARCH_TIMEOUT to LDAPConnection.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasntds.h>

#include <ldapcxn.h>
#include <ntcache.h>

namespace
{
   // Global object caches.
   NTCache theDomains;

   // Initialization reference count.
   LONG refCount = 0;
}

DWORD
WINAPI
IASNtdsInitialize( VOID )
{
   IASGlobalLockSentry sentry;

   ++refCount;

   return NO_ERROR;

}

VOID
WINAPI
IASNtdsUninitialize( VOID )
{
   IASGlobalLockSentry sentry;

   if (--refCount == 0)
   {
      theDomains.clear();
   }
}

BOOL
WINAPI
IASNtdsIsNativeModeDomain(
    IN PCWSTR domain
    )
{
   return theDomains.getMode(domain) == NTDomain::MODE_NATIVE;
}

//////////
// Retrieve a single entry from the DS. Handles all clean-up on failure.
//////////
DWORD
WINAPI
GetSingleEntry(
    LDAPConnection* cxn,
    PWCHAR base,
    ULONG scope,
    PWCHAR filter,
    PWCHAR attrs[],
    LDAPMessage **res
    ) throw ()
{
   //////////
   // Perform the search.
   //////////

   ULONG error = ldap_search_ext_sW(
                     *cxn,
                     base,
                     scope,
                     filter,
                     attrs,
                     FALSE,
                     NULL,
                     NULL,
                     &LDAPConnection::SEARCH_TIMEOUT,
                     0,
                     res
                     );

   //////////
   // Process the results.
   //////////

   if (error != LDAP_SUCCESS && error != LDAP_PARTIAL_RESULTS)
   {
      cxn->TraceFailure("ldap_search_ext_sW", error);
      cxn->disable();
      error = LdapMapErrorToWin32(error);
   }
   else if ((*res)->lm_returncode != LDAP_SUCCESS)
   {
      error = LdapMapErrorToWin32((*res)->lm_returncode);
      cxn->TraceFailure("ldap_search_ext_sW", (*res)->lm_returncode);
   }
   else if (ldap_count_entries(*cxn, *res) != 1)
   {
      error = ERROR_NO_SUCH_USER;
   }
   else
   {
      return NO_ERROR;
   }

   //////////
   // The search failed, so clean-up.
   //////////

   if (*res != NULL)
   {
      ldap_msgfree(*res);
      *res = NULL;
   }

   return error;
}

//////////
// Constants used for building LDAP search filters.
//////////
const WCHAR USER_FILTER_PREFIX[] = L"(sAMAccountName=";
const WCHAR USER_FILTER_SUFFIX[] = L")";
const size_t MAX_USERNAME_LENGTH = 256;
const size_t USER_FILTER_LENGTH  = sizeof(USER_FILTER_PREFIX)/sizeof(WCHAR) +
                                   MAX_USERNAME_LENGTH +
                                   sizeof(USER_FILTER_SUFFIX)/sizeof(WCHAR);

//////////
// Empty attribute list.
//////////
PWCHAR NO_ATTRS[] = { L"cn", NULL };

DWORD
WINAPI
QueryUserAttributesOnce(
    IN PCWSTR domainName,
    IN PCWSTR username,
    IN ULONG scope,
    IN PWCHAR attrs[],
    OUT PIAS_NTDS_RESULT result
    )
{
   //////////
   // Retrieve a connection to the domain.
   //////////

   CComPtr<LDAPConnection> cxn;
   DWORD error = theDomains.getConnection(domainName, &cxn);

   switch (error)
   {
      case NO_ERROR:
      {
         IASTracePrintf("Sending LDAP search to %s.", cxn->getHost());
         break;
      }

      case ERROR_DS_NOT_INSTALLED:
      {
         IASTracePrintf("DS not installed for domain %S.", domainName);
         return error;
      }

      default:
      {
         IASTracePrintf("Could not open an LDAP connection to domain %S.",
                        domainName);
         IASTraceFailure("NTDomain::getConnection", error);
         return error;
      }
   }

   //////////
   // Initialize the search filter.
   //////////

   WCHAR searchFilter[USER_FILTER_LENGTH];
   wcscpy (searchFilter, USER_FILTER_PREFIX);
   wcsncat(searchFilter, username, MAX_USERNAME_LENGTH);
   wcscat (searchFilter, USER_FILTER_SUFFIX);

   //////////
   // Query the DS. If scope == LDAP_SCOPE_BASE, then we won't retrieve the
   // actual attributes yet.
   //////////

   LDAPMessage* res;
   error = GetSingleEntry(
               cxn,
               const_cast<PWCHAR>(cxn->getBase()),
               LDAP_SCOPE_SUBTREE,
               searchFilter,
               (scope == LDAP_SCOPE_BASE ? NO_ATTRS : attrs),
               &res
               );

   if (error == NO_ERROR && scope == LDAP_SCOPE_BASE)
   {
      // All we care about is the user's DN.
      PWCHAR dn = ldap_get_dnW(*cxn, ldap_first_entry(*cxn, res));
      ldap_msgfree(res);

      // Now get the actual attributes.
      error = GetSingleEntry(
                  cxn,
                  dn,
                  LDAP_SCOPE_BASE,
                  L"(objectclass=*)",
                  attrs,
                  &res
                  );

      ldap_memfree(dn);
   }

   if (error == NO_ERROR)
   {
      LDAPConnection* rawCxn = cxn;
      rawCxn->AddRef();
      result->cxn = rawCxn;
      result->msg = res;
   }

   return error;
}

DWORD
WINAPI
IASNtdsQueryUserAttributes(
    IN PCWSTR domainName,
    IN PCWSTR username,
    IN ULONG scope,
    IN PWCHAR attrs[],
    OUT PIAS_NTDS_RESULT result
    )
{
   if (result == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   result->cxn = 0;
   result->msg = 0;

   DWORD retval = QueryUserAttributesOnce(
                      domainName,
                      username,
                      scope,
                      attrs,
                      result
                      );

   switch (retval)
   {
      case NO_ERROR:
      case ERROR_DS_NOT_INSTALLED:
      case ERROR_NO_SUCH_USER:
      case ERROR_ACCESS_DENIED:
         return retval;
   }

   IASTraceString("Retrying LDAP search.");

   return QueryUserAttributesOnce(
              domainName,
              username,
              scope,
              attrs,
              result
              );
}


VOID
WINAPI
IASNtdsFreeResult(
   PIAS_NTDS_RESULT result
   )
{
   if (result != 0)
   {
      if (result->cxn != 0)
      {
         static_cast<LDAPConnection*>(result->cxn)->Release();
         result->cxn = 0;
      }

      if (result->msg != 0)
      {
         ldap_msgfree(result->msg);
         result->msg = 0;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ntcache.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ntcache.h
//
// SYNOPSIS
//
//    Declares the class NTCache.
//
// MODIFICATION HISTORY
//
//    05/11/1998    Original version.
//    03/12/1999    Improve locking granularity.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTCACHE_H_
#define _NTCACHE_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <hashtbl.h>
#include <iasutil.h>
#include <ntdomain.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTCache
//
// DESCRIPTION
//
//    This class maintains a cache of NTDomain objects indexed by domain name.
//
///////////////////////////////////////////////////////////////////////////////
class NTCache
   : Guardable, NonCopyable
{
public:
   ~NTCache() throw ();

   // Flushes the cache.
   void clear() throw ();

   // Returns a connection to the specified domain. The client is responsible
   // for releasing the connection when done.
   DWORD getConnection(PCWSTR domainName, LDAPConnection** cxn) throw ();

   // Either retrieves an existing NTDomain object or creates a new one.
   // This method does not actually validate that the domain exists, so it
   // only fails when unable to allocate memory. The client is responsible
   // for releasing the domain when done.
   DWORD getDomain(PCWSTR domainName, NTDomain** domain) throw ();

   // Returns the mode of the specified domain.
   NTDomain::Mode getMode(PCWSTR domainName) throw ();

protected:

   // Removes all expired domains from the cache.
   void evict() throw ();

   typedef PCWSTR Key;
   typedef NTDomain* Value;

   // Hash a domain object.
   struct Hasher {
      ULONG operator()(Key key) const throw ()
      { return hash_util::hash(key); }
   };

   // Extract the key (i.e., domainName) from a domain object.
   struct Extractor {
      Key operator()(const Value domain) const throw ()
      { return domain->getDomainName(); }
   };

   // Test two domain objects for equality.
   struct KeyMatch {
      bool operator()(Key key1, Key key2) const throw ()
      { return wcscmp(key1, key2) == 0; }
   };

   typedef hash_table<Key, Hasher, Value, Extractor, KeyMatch> DomainTable;

   DomainTable cache;
};

#endif  // _NTCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ntdomain.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ntdomain.h
//
// SYNOPSIS
//
//    Declares the class NTDomain.
//
// MODIFICATION HISTORY
//
//    05/07/1998    Original version.
//    08/25/1998    Removed RootDSE attributes from the domain.
//    02/24/1999    Add force flag to findServer.
//    03/12/1999    Added isObsolete method.
//    04/14/1999    Specify domain and server when opening a connection.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTDOMAIN_H_
#define _NTDOMAIN_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <guard.h>
#include <nocopy.h>

class LDAPConnection;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTDomain
//
// DESCRIPTION
//
//    This class maintains state information about an NT domain.
//
///////////////////////////////////////////////////////////////////////////////
class NTDomain
   : Guardable, NonCopyable
{
public:
   enum Mode
   {
      MODE_UNKNOWN,
      MODE_NT4,
      MODE_MIXED,
      MODE_NATIVE
   };

   void AddRef() throw ()
   { InterlockedIncrement(&refCount); }

   void Release() throw ();

   PCWSTR getDomainName() const throw ()
   { return name; }

   DWORDLONG getExpiry() const throw ()
   { return expiry; }

   // Returns a connection to the domain. The client is responsible for
   // releasing the connection when done.
   DWORD getConnection(LDAPConnection** cxn) throw ();

   Mode getMode() throw ();

   BOOL isObsolete(DWORDLONG now) const throw ()
   { return (status && now >= expiry); }

   static NTDomain* createInstance(PCWSTR name) throw ();

   static DWORDLONG pollInterval;
   static DWORDLONG retryInterval;

protected:
   NTDomain(PWSTR domainName) throw ();
   ~NTDomain() throw ();

   // Returns TRUE if the current state has expired.
   BOOL isExpired() throw ();

   // Open a new connection to the given DC.
   void openConnection(
            PCWSTR domain,
            PCWSTR server
            ) throw ();

   // Returns TRUE if we have a connection to a DC for the domain.
   BOOL isConnected() throw ();

   // Close the current connection (if any).
   void closeConnection() throw ();

   // Finds a server for the domain.
   void findServer() throw ();

   // Reads the domain mode (i.e., mixed vs native).
   void readDomainMode() throw ();

private:
   LONG refCount;                    // Reference count.
   PWSTR name;                       // Name of the domain.
   Mode mode;                        // Mode of the domain.
   LDAPConnection* connection;       // Cached DC for the domain (if any).
   DWORD status;                     // Current status of the domain.
   DWORDLONG expiry;                 // Time when current state expires.
};

#endif  // _NTDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\ldap\ntdomain.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    ntdomain.cpp
//
// SYNOPSIS
//
//    Defines the clas NTDomain.
//
// MODIFICATION HISTORY
//
//    05/07/1998    Original version.
//    06/23/1998    Changes to DCLocator. Use ntldap constants.
//    07/13/1998    Clean up header file dependencies.
//    02/18/1999    Connect by DNS name not address.
//    03/10/1999    Cache mixed-mode and native-mode connections.
//    03/12/1999    Do not perform I/O from constructor.
//    04/14/1999    Specify domain and server when opening a connection.
//    09/14/1999    Always specify timeout for LDAP searches.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <iaslsa.h>
#include <iasntds.h>

#include <lm.h>

#include <ldapcxn.h>
#include <limits.h>
#include <ntdomain.h>

//////////
// Attributes of interest.
//////////
const WCHAR NT_MIXED_DOMAIN[]        = L"nTMixedDomain";

//////////
// Default search filter.
//////////
const WCHAR ANY_OBJECT[]             = L"(objectclass=*)";

//////////
// Domain attributes that we need.
//////////
const PCWSTR DOMAIN_ATTRS[] = {
   NT_MIXED_DOMAIN,
   NULL
};

//////////
// Utility function for getting the current system time as a 64-bit integer.
//////////
inline DWORDLONG GetSystemTimeAsDWORDLONG() throw ()
{
   ULARGE_INTEGER ft;
   GetSystemTimeAsFileTime((LPFILETIME)&ft);
   return ft.QuadPart;
}

//////////
// Number of 100 nsec intervals in one second.
//////////
const DWORDLONG ONE_SECOND     = 10000000ui64;

//////////
// Defaults for poll interval and retry interval.
//////////
DWORDLONG NTDomain::pollInterval  = 60 * 60 * ONE_SECOND;
DWORDLONG NTDomain::retryInterval =  1 * 60 * ONE_SECOND;

inline NTDomain::NTDomain(PWSTR domainName)
   : refCount(1),
     name(domainName),
     mode(MODE_UNKNOWN),
     connection(NULL),
     status(NO_ERROR),
     expiry(0)
{ }

inline NTDomain::~NTDomain()
{
   if (connection) { connection->Release(); }
   delete[] name;
}

inline BOOL NTDomain::isExpired() throw ()
{
   return GetSystemTimeAsDWORDLONG() >= expiry;
}

inline BOOL NTDomain::isConnected() throw ()
{
   if (connection && connection->isDisabled())
   {
      closeConnection();
   }

   return connection != NULL;
}

void NTDomain::Release() throw ()
{
   if (!InterlockedDecrement(&refCount))
   {
      delete this;
   }
}

DWORD NTDomain::getConnection(LDAPConnection** cxn) throw ()
{
   Lock();

   // Is it time to try for a new connection ?
   if (!isConnected() && isExpired())
   {
      findServer();
   }

   // Return the current connection ...
   if (*cxn = connection) { (*cxn)->AddRef(); }

   // ... and status to the caller.
   DWORD retval = status;

   Unlock();

   return retval;
}

NTDomain::Mode NTDomain::getMode() throw ()
{
   Lock();

   if (isExpired())
   {
      if (isConnected())
      {
         readDomainMode();
      }
      else
      {
         findServer();
      }
   }

   Mode retval = mode;

   Unlock();

   return retval;
}

NTDomain* NTDomain::createInstance(PCWSTR name) throw ()
{
   // We copy the domain name here, so that we don't have to throw an
   // exception from the constructor.
   PWSTR nameCopy = ias_wcsdup(name);

   if (!nameCopy) { return NULL; }

   return new (std::nothrow) NTDomain(nameCopy);
}

void NTDomain::openConnection(
                   PCWSTR domain,
                   PCWSTR server
                   ) throw ()
{
   closeConnection();

   IASTracePrintf("Opening LDAP connection to %S.", server);

   status = LDAPConnection::createInstance(
                                domain,
                                server,
                                &connection
                                );
   if (status == ERROR_ACCESS_DENIED)
   {
      IASTraceString("Access denied -- purging Kerberos ticket cache.");

      IASPurgeTicketCache();

      IASTracePrintf("Retrying LDAP connection to %S.", server);

      status = LDAPConnection::createInstance(
                                   domain,
                                   server,
                                   &connection
                                   );
   }

   if (status == NO_ERROR) { readDomainMode(); }

   if (status == NO_ERROR)
   {
      IASTraceString("LDAP connect succeeded.");
   }
   else
   {
      IASTraceFailure("LDAP connect", status);
   }
}

void NTDomain::closeConnection() throw ()
{
   if (connection)
   {
      connection->Release();
      connection = NULL;
   }
   expiry = 0;
}

void NTDomain::findServer() throw ()
{
   // First try to get a DC from the cache.
   PDOMAIN_CONTROLLER_INFO dci1 = NULL;
   status = IASGetDcName(
                name,
                DS_DIRECTORY_SERVICE_PREFERRED,
                &dci1
                );
   if (status == NO_ERROR)
   {
      if (dci1->Flags & DS_DS_FLAG)
      {
         openConnection(
             dci1->DomainName,
             dci1->DomainControllerName + 2
             );
      }
      else
      {
         // No DS. We'll treat this as if IASGetDcName failed.
         NetApiBufferFree(dci1);
         dci1 = NULL;
         status = ERROR_DS_NOT_INSTALLED;
      }
   }

   // If the cached DC failed, try again with the force flag.
   if (status != NO_ERROR)
   {
      PDOMAIN_CONTROLLER_INFO dci2;
      DWORD err = IASGetDcName(
                      name,
                      DS_DIRECTORY_SERVICE_PREFERRED |
                      DS_FORCE_REDISCOVERY,
                      &dci2
                      );
      if (err == NO_ERROR)
      {
         if (dci2->Flags & DS_DS_FLAG)
         {
            // Don't bother connecting unless this is a different DC than we
            // tried above.
            if (!dci1 ||
                wcscmp(
                    dci1->DomainControllerName,
                    dci2->DomainControllerName
                    ))
            {
               openConnection(
                   dci2->DomainName,
                   dci2->DomainControllerName + 2
                   );
            }
         }
         else
         {
            status = ERROR_DS_NOT_INSTALLED;
         }

         NetApiBufferFree(dci2);
      }
      else
      {
         status = err;
      }
   }

   NetApiBufferFree(dci1);

   /////////
   // Process the result of our 'find'.
   /////////

   if (status == ERROR_DS_NOT_INSTALLED)
   {
      mode = MODE_NT4;
      expiry = GetSystemTimeAsDWORDLONG() + pollInterval;
   }
   else if (status != NO_ERROR)
   {
      expiry = GetSystemTimeAsDWORDLONG() + retryInterval;
   }
   else if (mode == MODE_NATIVE)
   {
      expiry = _UI64_MAX;
   }
   else
   {
      // mode == MODE_MIXED
      expiry = GetSystemTimeAsDWORDLONG() + pollInterval;
   }
}

void NTDomain::readDomainMode() throw ()
{
   LDAPMessage* res = NULL;
   ULONG ldapError = ldap_search_ext_sW(
                         *connection,
                         const_cast<PWCHAR>(connection->getBase()),
                         LDAP_SCOPE_BASE,
                         const_cast<PWCHAR>(ANY_OBJECT),
                         const_cast<PWCHAR*>(DOMAIN_ATTRS),
                         0,
                         NULL,
                         NULL,
                         &LDAPConnection::SEARCH_TIMEOUT,
                         0,
                         &res
                         );

   // We have to check two error codes.
   if (ldapError == LDAP_SUCCESS)
   {
      ldapError = res->lm_returncode;
   }

   if (ldapError == LDAP_SUCCESS)
   {
      PWCHAR* vals = ldap_get_valuesW(
                         *connection,
                         ldap_first_entry(*connection, res),
                         const_cast<PWCHAR>(NT_MIXED_DOMAIN)
                         );

      if (vals && *vals)
      {
         mode = wcstoul(*vals, NULL, 10) ? MODE_MIXED : MODE_NATIVE;
      }
      else
      {
         status = ERROR_ACCESS_DENIED;
      }

      ldap_value_freeW(vals);
   }
   else
   {
      status = LdapMapErrorToWin32(ldapError);
      connection->TraceFailure("ldap_get_valuesW", 
                              ldapError
                              );
   }

   ldap_msgfree(res);

   if (status != NO_ERROR)
   {
      closeConnection();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\dyninfo.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    dyninfo.h
//
// SYNOPSIS
//
//    Declares global variables containing dynamic configuration info.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  DYNINFO_H_
#define  DYNINFO_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include "iaslsa.h"

#ifdef __cplusplus
extern "C" {
#endif

//////////
// The primary domain.
//////////
extern WCHAR thePrimaryDomain[];

//////////
// The default domain.
//////////
extern PCWSTR theDefaultDomain;

//////////
// The dns domain name.
//////////
extern const LSA_UNICODE_STRING* theDnsDomainName;

//////////
// Role of the local machine.
//////////
extern IAS_ROLE ourRole;

//////////
// Name of the guest account for the default domain.
//////////
extern WCHAR theGuestAccount[];

DWORD
WINAPI
IASDynamicInfoInitialize( VOID );

VOID
WINAPI
IASDynamicInfoShutdown( VOID );

#ifdef __cplusplus
}
#endif
#endif  // DYNINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\ezlogon.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezlogon.h
//
// SYNOPSIS
//
//    Describes the abbreviated IAS version of LsaLogonUser.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EZLOGON_H_
#define _EZLOGON_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <ntmsv1_0.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////
// Handle to the IAS Logon Process.
//////////
extern LSA_HANDLE theLogonProcess;

//////////
// The MSV1_0 authentication package.
//////////
extern ULONG theMSV1_0_Package;

DWORD
WINAPI
IASLogonInitialize( VOID );

VOID
WINAPI
IASLogonShutdown( VOID );

VOID
WINAPI
IASInitAuthInfo(
    IN PVOID AuthInfo,
    IN DWORD FixedLength,
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PBYTE* Data
    );

DWORD
WINAPI
IASLogonUser(
    IN PVOID AuthInfo,
    IN ULONG AuthInfoLength,
    OPTIONAL OUT PMSV1_0_LM20_LOGON_PROFILE *Profile,
    OUT PHANDLE Token
    );

///////////////////////////////////////////////////////////////////////////////
//
// Assorted macros to initialize self-relative logon information.
//
///////////////////////////////////////////////////////////////////////////////

// Copy a Unicode string into a UNICODE_STRING.
#define IASInitUnicodeString(str, buf, src) \
{ (str).Length = (USHORT)(wcslen(src) * sizeof(WCHAR)); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PWSTR)memcpy((buf), (src), (str).MaximumLength); \
  (buf) += (str).MaximumLength; }

// Copy a ANSI string into a STRING.
#define IASInitAnsiString(str, buf, src) \
{ (str).Length = (USHORT)(strlen(src) * sizeof(CHAR)); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PSTR)memcpy((buf), (src), (str).MaximumLength);  \
  (buf) += (str).MaximumLength; }

// Copy an octet string into a STRING.
#define IASInitOctetString(str, buf, src, srclen) \
{ (str).Length = (USHORT)(srclen); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PSTR)memcpy((buf), (src), (str).MaximumLength); \
  (buf) += (str).MaximumLength; }

// Copy an ANSI string into a UNICODE_STRING.
#define IASInitUnicodeStringFromAnsi(str, buf, src) \
{ (str).MaximumLength = (USHORT)(sizeof(WCHAR) * ((src).Length + 1)); \
  (str).Buffer = (PWSTR)(buf); \
  RtlAnsiStringToUnicodeString(&(str), &(src), FALSE); \
  (buf) += ((str).MaximumLength = (str).Length); }

// Copy a fixed-size array into a fixed-size array of the same size.
#define IASInitFixedArray(dst, src) \
{ memcpy((dst), (src), sizeof(dst)); }

#ifdef __cplusplus
}
#endif
#endif  // _EZLOGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\ezsam.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezsam.h
//
// SYNOPSIS
//
//    Declares helper functions for the SAM API.
//
// MODIFICATION HISTORY
//
//    08/14/1998    Original version.
//    03/23/1999    Tighten up the ezsam API.
//    04/14/1999    Copy SIDs returned by IASSamOpenUser.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EZSAM_H_
#define _EZSAM_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <ntsam.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////
// Handles for the local SAM domains.
//////////
extern SAM_HANDLE theAccountDomainHandle;
extern SAM_HANDLE theBuiltinDomainHandle;

DWORD
WINAPI
IASSamInitialize( VOID );

VOID
WINAPI
IASSamShutdown( VOID );

DWORD
WINAPI
IASSamOpenUser(
    IN PCWSTR DomainName,
    IN PCWSTR UserName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN OUT OPTIONAL PULONG UserRid,
    OUT OPTIONAL PSID *DomainSid,
    OUT PSAM_HANDLE UserHandle
    );

ULONG
WINAPI
IASLengthRequiredChildSid(
    IN PSID ParentSid
    );

VOID
WINAPI
IASInitializeChildSid(
    IN PSID ChildSid,
    IN PSID ParentSid,
    IN ULONG ChildRid
    );

#ifdef __cplusplus
}
#endif
#endif  // _EZSAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\ezsam.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezsam.c
//
// SYNOPSIS
//
//    Defines helper functions for SAM API.
//
// MODIFICATION HISTORY
//
//    08/16/1998    Original version.
//    02/18/1999    Connect by DNS name not address.
//    03/23/1999    Tighten up the ezsam API.
//                  Better failover/retry logic.
//    04/14/1999    Copy SIDs returned by IASSamOpenUser.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>

#include <lm.h>
#include <dsgetdc.h>

#include <statinfo.h>
#include <ezsam.h>
#include <iastrace.h>

//////////
// Private helper functions.
//////////

DWORD
WINAPI
IASSamOpenDomain(
    IN PCWSTR DomainName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN BOOL Force,
    OUT PSID *DomainSid,
    OUT PSAM_HANDLE DomainHandle
    );

VOID
WINAPI
IASSamFreeSid(
    IN PSID Sid
    );

VOID
WINAPI
IASSamCloseDomain(
    IN SAM_HANDLE SamHandle,
    IN BOOL Valid
    );

DWORD
WINAPI
IASSamLookupUser(
    IN SAM_HANDLE DomainHandle,
    IN PCWSTR UserName,
    IN ACCESS_MASK DesiredAccess,
    IN OUT OPTIONAL PULONG UserRid,
    OUT PSAM_HANDLE UserHandle
    );

//////////
// Handles for the local SAM domains.
//////////
SAM_HANDLE theAccountDomainHandle;
SAM_HANDLE theBuiltinDomainHandle;

//////////
// State associated with a cached domain.
//////////
struct CachedDomain
{
   LONG lock;                     // 1 if the cache is locked, 0 otherwise.
   WCHAR domainName[DNLEN + 1];   // Domain name.
   ACCESS_MASK access;            // Access mask for handle.
   ULARGE_INTEGER expiry;         // Time when entry expires.
   PSID sid;                      // SID for the domain.
   SAM_HANDLE handle;             // Handle to domain.
   LONG refCount;                 // Reference count.
};

//////////
// Time in 100 nsec intervals that a cache entry will be retained.
// Set to 900 seconds.
//////////
#define CACHE_LIFETIME (9000000000ui64)

//////////
// The currently cached domain.
//////////
struct CachedDomain theCache;

//////////
// Try to lock the cache.
//////////
#define TRYLOCK_CACHE() \
   (InterlockedExchange(&theCache.lock, 1) == 0)

//////////
// Unlock the cache.
//////////
#define UNLOCK_CACHE() \
   (InterlockedExchange(&theCache.lock, 0))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamSidDup
//
// DESCRIPTION
//
//    Duplicates the passed in SID. The SID should be freed by calling
//    IASSamFreeSid.
//
///////////////////////////////////////////////////////////////////////////////
PSID
WINAPI
IASSamSidDup(
    PSID Sid
    )
{
   ULONG sidLength;
   PSID rv;

   if (Sid)
   {
      sidLength = RtlLengthSid(Sid);
      rv = RtlAllocateHeap(
               RtlProcessHeap(),
               0,
               sidLength
               );
      if (rv) { memcpy(rv, Sid, sidLength); }
   }
   else
   {
      rv = NULL;
   }

   return rv;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamOpenCachedDomain
//
// DESCRIPTION
//
//    Attempt to open a domain from the cache.
//
///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
IASSamOpenCachedDomain(
    IN PCWSTR DomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSID *DomainSid,
    OUT PSAM_HANDLE DomainHandle
    )
{
   BOOL success;
   ULARGE_INTEGER now;

   success = FALSE;

   // Can we access the cache ?
   if (TRYLOCK_CACHE())
   {
      // Does the domain name match ?
      if (_wcsicmp(DomainName, theCache.domainName) == 0)
      {
         // Does the cached handle have sufficient access rights ?
         if ((DesiredAccess & theCache.access) == DesiredAccess)
         {
            GetSystemTimeAsFileTime((LPFILETIME)&now);

            // Is the entry still valid ?
            if (now.QuadPart < theCache.expiry.QuadPart)
            {
               // We got a cache hit, so update the reference count ...
               InterlockedIncrement(&theCache.refCount);

               // ... and return the data.
               *DomainSid = theCache.sid;
               *DomainHandle = theCache.handle;
               success = TRUE;
            }
            else
            {
               // The entry has expired, so NULL out the name to prevent the
               // next thread from wasting its time.
               theCache.domainName[0] = L'\0';
            }
         }
      }

      UNLOCK_CACHE();
   }

   return success;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamAddCachedDomain
//
// DESCRIPTION
//
//    Attempt to add a domain to the cache.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASSamAddCachedDomain(
    IN PCWSTR DomainName,
    IN ACCESS_MASK Access,
    IN PSID DomainSid,
    IN SAM_HANDLE DomainHandle
    )
{
   // Can we access the cache ?
   if (TRYLOCK_CACHE())
   {
      // Is the current entry idle ?
      if (theCache.refCount == 0)
      {
         // Free the current entry.
         SamCloseHandle(theCache.handle);
         SamFreeMemory(theCache.sid);

         // Store the cached state.
         wcsncpy(theCache.domainName, DomainName, DNLEN);
         theCache.access = Access;
         theCache.sid = DomainSid;
         theCache.handle = DomainHandle;

         // Set the expiration time.
         GetSystemTimeAsFileTime((LPFILETIME)&theCache.expiry);
         theCache.expiry.QuadPart += CACHE_LIFETIME;

         // The caller already has a reference.
         theCache.refCount = 1;
      }

      UNLOCK_CACHE();
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamInitialize
//
// DESCRIPTION
//
//    Initializes the handles for the local SAM domains.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASSamInitialize( VOID )
{
   DWORD status;
   SAM_HANDLE hLocalServer;
   UNICODE_STRING uniAccountDomain;

   //////////
   // Connect to the local SAM.
   //////////

   status = SamConnect(
                NULL,
                &hLocalServer,
                SAM_SERVER_LOOKUP_DOMAIN,
                &theObjectAttributes
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Open a handle to the account domain.
   //////////

   status = SamOpenDomain(
                hLocalServer,
                DOMAIN_LOOKUP |
                DOMAIN_GET_ALIAS_MEMBERSHIP |
                DOMAIN_READ_PASSWORD_PARAMETERS,
                theAccountDomainSid,
                &theAccountDomainHandle
                );
   if (!NT_SUCCESS(status)) { goto close_server; }

   //////////
   // Open a handle to the built-in domain.
   //////////

   status = SamOpenDomain(
                hLocalServer,
                DOMAIN_LOOKUP |
                DOMAIN_GET_ALIAS_MEMBERSHIP,
                theBuiltinDomainSid,
                &theBuiltinDomainHandle
                );
   if (!NT_SUCCESS(status))
   {
      SamCloseHandle(theAccountDomainHandle);
      theAccountDomainHandle = NULL;
   }

close_server:
   SamCloseHandle(hLocalServer);

exit:
   return RtlNtStatusToDosError(status);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamShutdown
//
// DESCRIPTION
//
//    Cleans up global variables.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASSamShutdown( VOID )
{
   // Reset the cache.
   SamFreeMemory(theCache.sid);
   SamCloseHandle(theCache.handle);
   memset(&theCache, 0, sizeof(theCache));

   SamCloseHandle(theAccountDomainHandle);
   theAccountDomainHandle = NULL;

   SamCloseHandle(theBuiltinDomainHandle);
   theBuiltinDomainHandle = NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamOpenDomain
//
// DESCRIPTION
//
//    Opens a connection to a SAM domain. The caller is responsible for
//    closing the returned handle and freeing the returned SID.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASSamOpenDomain(
    IN PCWSTR DomainName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN BOOL Force,
    OUT PSID *DomainSid,
    OUT PSAM_HANDLE DomainHandle
    )
{
   DWORD status;
   PDOMAIN_CONTROLLER_INFOW dci;
   UNICODE_STRING uniServerName, uniDomainName;
   SAM_HANDLE hServer;

   //////////
   // First check for the local account domain.
   //////////

   if (_wcsicmp(DomainName, theAccountDomain) == 0)
   {
      *DomainSid = theAccountDomainSid;
      *DomainHandle = theAccountDomainHandle;

      IASTraceString("Using cached SAM connection to local account domain.");

      return NO_ERROR;
   }

   //////////
   // Try for a cache hit.
   //////////

   if (IASSamOpenCachedDomain(
           DomainName,
           DesiredAccess,
           DomainSid,
           DomainHandle
           ))
   {
      IASTraceString("Using cached SAM connection.");

      return NO_ERROR;
   }

   //////////
   // No luck, so get the name of the DC to connect to.
   //////////

   status = IASGetDcName(
                DomainName,
                (Force ? DS_FORCE_REDISCOVERY : 0) | Flags,
                &dci
                );
   if (status != NO_ERROR) { return status; }

   //////////
   // Connect to the server.
   //////////

   IASTracePrintf("Connecting to SAM server on %S.",
                  dci->DomainControllerName);

   RtlInitUnicodeString(
       &uniServerName,
       dci->DomainControllerName
       );

   status = SamConnect(
                &uniServerName,
                &hServer,
                SAM_SERVER_LOOKUP_DOMAIN,
                &theObjectAttributes
                );

   // We're through with the server name.
   NetApiBufferFree(dci);

   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Get SID for the domain.
   //////////

   RtlInitUnicodeString(
       &uniDomainName,
       DomainName
       );

   status = SamLookupDomainInSamServer(
                hServer,
                &uniDomainName,
                DomainSid
                );
   if (!NT_SUCCESS(status)) { goto close_server; }

   //////////
   // Open the domain using SID we got above
   //////////

   status = SamOpenDomain(
                hServer,
                DesiredAccess,
                *DomainSid,
                DomainHandle
                );

   if (NT_SUCCESS(status))
   {
      // Try to add this to the cache.
      IASSamAddCachedDomain(
          DomainName,
          DesiredAccess,
          *DomainSid,
          *DomainHandle
          );
   }
   else
   {
      // Free the SID. We can use SamFreeMemory since we know this SID isn't
      // in the cache.
      SamFreeMemory(*DomainSid);
      *DomainSid = NULL;
   }

close_server:
   SamCloseHandle(hServer);

exit:
   return RtlNtStatusToDosError(status);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamLookupUser
//
// DESCRIPTION
//
//    Opens a user in a SAM domain. The caller is responsible for closing
//    the returned handle.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASSamLookupUser(
    IN SAM_HANDLE DomainHandle,
    IN PCWSTR UserName,
    IN ACCESS_MASK DesiredAccess,
    IN OUT OPTIONAL PULONG UserRid,
    OUT PSAM_HANDLE UserHandle
    )
{
   DWORD status;
   UNICODE_STRING uniUserName;
   ULONG rid, *prid;
   PSID_NAME_USE nameUse;

   if (UserName)
   {
      //////////
      // Caller supplied a UserName so lookup the RID.
      //////////

      RtlInitUnicodeString(
          &uniUserName,
          UserName
          );

      status = SamLookupNamesInDomain(
                   DomainHandle,
                   1,
                   &uniUserName,
                   &prid,
                   &nameUse
                   );
      if (!NT_SUCCESS(status)) { goto exit; }

      // Save the RID ...
      rid = *prid;

      // ... and free the memory.
      SamFreeMemory(prid);
      SamFreeMemory(nameUse);

      // Return the RID to the caller if requested.
      if (UserRid)
      {
         *UserRid = rid;
      }
   }
   else if (UserRid)
   {
      // Caller supplied a RID.
      rid = *UserRid;
   }
   else
   {
      // Caller supplied neither a UserName or a RID.
      return ERROR_INVALID_PARAMETER;
   }

   //////////
   // Open the user object.
   //////////

   status = SamOpenUser(
                DomainHandle,
                DesiredAccess,
                rid,
                UserHandle
                );

exit:
   return RtlNtStatusToDosError(status);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamOpenUser
//
// DESCRIPTION
//
//    Opens a SAM user. The caller is responsible for closing
//    the returned handle.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASSamOpenUser(
    IN PCWSTR DomainName,
    IN PCWSTR UserName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Flags,
    IN OUT OPTIONAL PULONG UserRid,
    OUT OPTIONAL PSID *DomainSid,
    OUT PSAM_HANDLE UserHandle
    )
{
   DWORD status;
   ULONG tries;
   PSID sid;
   SAM_HANDLE hDomain;
   BOOL success;

   // Initialize the retry state.
   tries = 0;
   success = FALSE;

   do
   {
      //////////
      // Open a connection to the domain.
      //////////

      status = IASSamOpenDomain(
                   DomainName,
                   DOMAIN_LOOKUP,
                   Flags,
                   (tries > 0),
                   &sid,
                   &hDomain
                   );
      if (status == NO_ERROR)
      {
         //////////
         // Lookup the user.
         //////////

         status = IASSamLookupUser(
                      hDomain,
                      UserName,
                      DesiredAccess,
                      UserRid,
                      UserHandle
                      );

         switch (status)
         {
            case NO_ERROR:
               // Everything succeeded, so return the domain SID if requested.
               if (DomainSid && !(*DomainSid = IASSamSidDup(sid)))
               {
                  SamCloseHandle(*UserHandle);
                  *UserHandle = NULL;
                  status = STATUS_NO_MEMORY;
               }
               // Fall through.

            case ERROR_NONE_MAPPED:
               success = TRUE;
               break;
         }

         // Free the sid ...
         IASSamFreeSid(sid);

         // ... and the domain handle.
         IASSamCloseDomain(hDomain, success);
      }

   } while (!success && ++tries < 2);

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamCloseDomain
//
// DESCRIPTION
//
//    Closes a handle returned by IASSamOpenDomain.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASSamCloseDomain(
    IN SAM_HANDLE SamHandle,
    IN BOOL Valid
    )
{
   if (SamHandle == theCache.handle)
   {
      if (!Valid)
      {
         theCache.domainName[0] = L'\0';
      }

      InterlockedDecrement(&theCache.refCount);
   }
   else if (SamHandle != theAccountDomainHandle)
   {
      SamCloseHandle(SamHandle);
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASSamFreeSid
//
// DESCRIPTION
//
//    Frees a SID returned by IASSamOpenDomain.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASSamFreeSid (
    IN PSID Sid
    )
{
   if (Sid != theAccountDomainSid && Sid != theCache.sid)
   {
      SamFreeMemory(Sid);
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLengthRequiredChildSid
//
// DESCRIPTION
//
//    Returns the number of bytes required for a SID immediately subordinate
//    to ParentSid.
//
///////////////////////////////////////////////////////////////////////////////
ULONG
WINAPI
IASLengthRequiredChildSid(
    IN PSID ParentSid
    )
{
   // Get the parent's SubAuthority count.
   ULONG subAuthCount;
   subAuthCount = (ULONG)*RtlSubAuthorityCountSid(ParentSid);

   // And add one for the child RID.
   return RtlLengthRequiredSid(1 + subAuthCount);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASInitializeChildSid
//
// DESCRIPTION
//
//    Initializes a SID with the concatenation of ParentSid + ChildRid.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASInitializeChildSid(
    IN PSID ChildSid,
    IN PSID ParentSid,
    IN ULONG ChildRid
    )
{
   PUCHAR pChildCount;
   ULONG parentCount;

   // Start with the parent SID. We assume the child SID is big enough.
   RtlCopySid(
       MAXLONG,
       ChildSid,
       ParentSid
       );

   // Get a pointer to the child SubAuthority count.
   pChildCount = RtlSubAuthorityCountSid(ChildSid);

   // Save the original parent count ...
   parentCount = (ULONG)*pChildCount;

   // ... then increment the child count.
   ++*pChildCount;

   // Set the last subauthority equal to the RID.
   *RtlSubAuthoritySid(ChildSid, parentCount) = ChildRid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\ezlogon.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezlogon.c
//
// SYNOPSIS
//
//    Defines the IAS wrapper around LsaLogonUser
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//    09/09/1998    Fix AV when logon domain doesn't match user domain.
//    10/02/1998    NULL out handle when LsaLogonUser fails.
//    10/11/1998    Use SubStatus for STATUS_ACCOUNT_RESTRICTION.
//    10/22/1998    PIAS_LOGON_HOURS is now a mandatory parameter.
//    01/28/1999    Remove LogonDomainName check.
//    04/19/1999    Add IASPurgeTicketCache.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <ntlsa.h>
#include <kerberos.h>
#include <windows.h>

#include <ezlogon.h>
#include <iaslsa.h>
#include <iastrace.h>

CONST CHAR LOGON_PROCESS_NAME[] = "IAS";
CONST CHAR TOKEN_SOURCE_NAME[TOKEN_SOURCE_LENGTH] = "IAS";

//////////
// Misc. global variables used for logons.
//////////
LSA_HANDLE theLogonProcess;      // The handle for the logon process.
ULONG theMSV1_0_Package;         // The MSV1_0 authentication package.
ULONG theKerberosPackage;        // The Kerberos authentication package.
STRING theOriginName;            // The origin of the logon requests.
TOKEN_SOURCE theSourceContext;   // The source context of the logon requests.


/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonInitialize
//
// DESCRIPTION
//
//    Registers the logon process.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonInitialize( VOID )
{
   DWORD status;
   BOOLEAN wasEnabled;
   LSA_STRING processName, packageName;
   LSA_OPERATIONAL_MODE opMode;

   //////////
   // Enable SE_TCB_PRIVILEGE.
   //////////

   status = RtlAdjustPrivilege(
                SE_TCB_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Register as a logon process.
   //////////

   RtlInitString(
       &processName,
       LOGON_PROCESS_NAME
       );

   status = LsaRegisterLogonProcess(
                &processName,
                &theLogonProcess,
                &opMode
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Lookup the MSV1_0 authentication package.
   //////////

   RtlInitString(
       &packageName,
       MSV1_0_PACKAGE_NAME
       );

   status = LsaLookupAuthenticationPackage(
                theLogonProcess,
                &packageName,
                &theMSV1_0_Package
                );
   if (!NT_SUCCESS(status)) { goto deregister; }

   //////////
   // Lookup the Kerberos authentication package.
   //////////

   RtlInitString(
       &packageName,
       MICROSOFT_KERBEROS_NAME_A
       );

   status = LsaLookupAuthenticationPackage(
                theLogonProcess,
                &packageName,
                &theKerberosPackage
                );
   if (!NT_SUCCESS(status)) { goto deregister; }

   //////////
   // Initialize the source context.
   //////////

   memcpy(theSourceContext.SourceName,
          TOKEN_SOURCE_NAME,
          TOKEN_SOURCE_LENGTH);
   status = NtAllocateLocallyUniqueId(
                &theSourceContext.SourceIdentifier
                );
   if (!NT_SUCCESS(status)) { goto deregister; }

   return NO_ERROR;

deregister:
   LsaDeregisterLogonProcess(theLogonProcess);
   theLogonProcess = NULL;

exit:
   return RtlNtStatusToDosError(status);
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonShutdown
//
// DESCRIPTION
//
//    Deregisters the logon process.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASLogonShutdown( VOID )
{
   LsaDeregisterLogonProcess(theLogonProcess);
   theLogonProcess = NULL;
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASInitAuthInfo
//
// DESCRIPTION
//
//    Initializes the fields common to all MSV1_0_LM20* structs.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASInitAuthInfo(
    IN PVOID AuthInfo,
    IN DWORD FixedLength,
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PBYTE* Data
    )
{
   PMSV1_0_LM20_LOGON logon;

   // Zero out the fixed data.
   memset(AuthInfo, 0, FixedLength);

   // Set Data to point just past the fixed struct.
   *Data = FixedLength + (PBYTE)AuthInfo;

   // This cast is safe since all LM20 structs have the same initial fields.
   logon = (PMSV1_0_LM20_LOGON)AuthInfo;

   // We always do Network logons.
   logon->MessageType = MsV1_0NetworkLogon;

   // Copy in the strings common to all logons.
   IASInitUnicodeString(logon->LogonDomainName, *Data, Domain);
   IASInitUnicodeString(logon->UserName,        *Data, UserName);
   IASInitUnicodeString(logon->Workstation,     *Data, L"");
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonUser
//
// DESCRIPTION
//
//    Wrapper around LsaLogonUser.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonUser(
    IN PVOID AuthInfo,
    IN ULONG AuthInfoLength,
    OUT PMSV1_0_LM20_LOGON_PROFILE *Profile,
    OUT PHANDLE Token
    )
{
   NTSTATUS status, SubStatus;
   PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
   ULONG ProfileBufferLength;
   LUID LogonId;
   QUOTA_LIMITS Quotas;

   // Make sure the OUT arguments are NULL.
   *Token = NULL;
   ProfileBuffer = NULL;

   status = LsaLogonUser(
                theLogonProcess,
                &theOriginName,
                Network,
                theMSV1_0_Package,
                AuthInfo,
                AuthInfoLength,
                NULL,
                &theSourceContext,
                &ProfileBuffer,
                &ProfileBufferLength,
                &LogonId,
                Token,
                &Quotas,
                &SubStatus
                );

   if (!NT_SUCCESS(status))
   {
      // For account restrictions, we can get a more descriptive error
      // from the SubStatus.
      if (status == STATUS_ACCOUNT_RESTRICTION && !NT_SUCCESS(SubStatus))
      {
         status = SubStatus;
      }

      // Sometimes LsaLogonUser returns an invalid handle value on failure.
      *Token = NULL;
   }

   if (Profile)
   {
      // Return the profile if requested ...
      *Profile = ProfileBuffer;
   }
   else if (ProfileBuffer)
   {
      // ... otherwise free it.
      LsaFreeReturnBuffer(ProfileBuffer);
   }

   return RtlNtStatusToDosError(status);
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASCheckAccountRestrictions
//
// DESCRIPTION
//
//    Checks whether an account can be used for logon.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASCheckAccountRestrictions(
    IN PLARGE_INTEGER AccountExpires,
    IN PIAS_LOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER KickOffTime
    )
{
   LONGLONG now, logonHoursExpiry;
   TIME_ZONE_INFORMATION tzi;
   SYSTEMTIME st;
   size_t msecOfWeek, msecPerUnit, idx, lastUnit, msecLeft;
   const size_t msecPerWeek = 1000 * 60 * 60 * 24 * 7;

   GetSystemTimeAsFileTime((LPFILETIME)&now);

   if (AccountExpires->QuadPart == 0)
   {
      // An expiration time of zero means 'never'.
      KickOffTime->QuadPart = MAXLONGLONG;
   }
   else if (AccountExpires->QuadPart > now)
   {
      KickOffTime->QuadPart = AccountExpires->QuadPart;
   }
   else
   {
      return ERROR_ACCOUNT_EXPIRED;
   }

   // If LogonHours is empty, then we're done.
   if (LogonHours->UnitsPerWeek == 0)
   {
      return NO_ERROR;
   }

   // The LogonHours array does not account for bias.
   switch (GetTimeZoneInformation(&tzi))
   {
      case TIME_ZONE_ID_UNKNOWN:
      case TIME_ZONE_ID_STANDARD:
         // Bias is in minutes.
         now -= 60 * 10000000 * (LONGLONG)tzi.StandardBias;
         break;

      case TIME_ZONE_ID_DAYLIGHT:
         // Bias is in minutes.
         now -= 60 * 10000000 * (LONGLONG)tzi.DaylightBias;
         break;

      default:
         return ERROR_INVALID_LOGON_HOURS;
   }

   FileTimeToSystemTime((LPFILETIME)&now, &st);

   // Number of milliseconds into the week.
   msecOfWeek  = st.wMilliseconds +
                 st.wSecond    * 1000 +
                 st.wMinute    * 1000 * 60 +
                 st.wHour      * 1000 * 60 * 60 +
                 st.wDayOfWeek * 1000 * 60 * 60 * 24;

   // Compute the index of the current time (our starting point).
   msecPerUnit = msecPerWeek / LogonHours->UnitsPerWeek;
   idx = msecOfWeek / msecPerUnit;

   // Number of units until we hit an unset bit.
   lastUnit = 0;

   while (lastUnit < LogonHours->UnitsPerWeek)
   {
      // Test the corresponding bit.
      if ((LogonHours->LogonHours[idx / 8] & (0x1 << (idx % 8))) == 0)
      {
            break;
      }

      ++lastUnit;
      ++idx;

      // Wrap around if necessary.
      if (idx == LogonHours->UnitsPerWeek)
      {
         idx = 0;
      }
   }

   if (lastUnit == LogonHours->UnitsPerWeek)
   {
      // All bits are set, so leave the KickOffTime alone.
   }
   else if (lastUnit > 0)
   {
      // How many milliseconds left?
      msecLeft = (lastUnit - 1) * msecPerUnit;
      msecLeft += msecPerUnit - (msecOfWeek % msecPerUnit);

      // Add this to the current time to find out when logon hours expires.
      logonHoursExpiry = now + (msecLeft * 10000i64);

      // Is this more restrictive than the the current KickOffTime?
      if (logonHoursExpiry < KickOffTime->QuadPart)
      {
         KickOffTime->QuadPart = logonHoursExpiry;
      }
   }
   else
   {
      // Current bit isn't set.
      return ERROR_INVALID_LOGON_HOURS;
   }

   return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASPurgeTicketCache
//
// DESCRIPTION
//
//    Purges the Kerberos ticket cache.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASPurgeTicketCache( VOID )
{
   KERB_PURGE_TKT_CACHE_REQUEST request;
   NTSTATUS status, subStatus;
   PVOID response;
   ULONG responseLength;

   memset(&request, 0, sizeof(request));
   request.MessageType = KerbPurgeTicketCacheMessage;

   response = NULL;
   responseLength = 0;
   subStatus = 0;

   status = LsaCallAuthenticationPackage(
                theLogonProcess,
                theKerberosPackage,
                &request,
                sizeof(request),
                &response,
                &responseLength,
                &subStatus
                );
   if (NT_SUCCESS(status) && (response != NULL))
   {
      LsaFreeReturnBuffer(response);
   }

   return RtlNtStatusToDosError(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\iaslsa.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Implements the IAS API into the NT LSA.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>

#include <align.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <dsgetdc.h>
#include <lm.h>
#include <crypt.h>
#include <sha.h>
#include <rasfmsub.h>
#include <oaidl.h>

#include <iaspolcy.h>
#include <iastrace.h>

#define IASSAMAPI

#include <statinfo.h>
#include <ezsam.h>
#include <dyninfo.h>
#include <ezlogon.h>

#include <iaslsa.h>
#include <iasntds.h>
#include <iasparms.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include <raserror.h>

extern CRITICAL_SECTION critSec;

#define DEFAULT_PARAMETER_CONTROL \
(MSV1_0_DONT_TRY_GUEST_ACCOUNT | MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY | MSV1_0_DISABLE_PERSONAL_FALLBACK)

//////////
// Make sure that the defines in iaslsa.h match the actual NT defines.
//////////

#if _MSV1_0_CHALLENGE_LENGTH  != MSV1_0_CHALLENGE_LENGTH
#error _MSV1_0_CHALLENGE_LENGTH  != MSV1_0_CHALLENGE_LENGTH
#endif

#if _NT_RESPONSE_LENGTH != NT_RESPONSE_LENGTH
#error _NT_RESPONSE_LENGTH != NT_RESPONSE_LENGTH
#endif

#if _LM_RESPONSE_LENGTH != LM_RESPONSE_LENGTH
#error _LM_RESPONSE_LENGTH != LM_RESPONSE_LENGTH
#endif

#if _MSV1_0_USER_SESSION_KEY_LENGTH != MSV1_0_USER_SESSION_KEY_LENGTH
#error _MSV1_0_USER_SESSION_KEY_LENGTH != MSV1_0_USER_SESSION_KEY_LENGTH
#endif

#if _MSV1_0_LANMAN_SESSION_KEY_LENGTH != MSV1_0_LANMAN_SESSION_KEY_LENGTH
#error _MSV1_0_LANMAN_SESSION_KEY_LENGTH != MSV1_0_LANMAN_SESSION_KEY_LENGTH
#endif

#if _ENCRYPTED_LM_OWF_PASSWORD_LENGTH != ENCRYPTED_LM_OWF_PASSWORD_LENGTH
#error _ENCRYPTED_LM_OWF_PASSWORD_LENGTH != ENCRYPTED_LM_OWF_PASSWORD_LENGTH
#endif

#if _ENCRYPTED_NT_OWF_PASSWORD_LENGTH != ENCRYPTED_NT_OWF_PASSWORD_LENGTH
#error _ENCRYPTED_NT_OWF_PASSWORD_LENGTH != ENCRYPTED_NT_OWF_PASSWORD_LENGTH
#endif

#if _MAX_ARAP_USER_NAMELEN != MAX_ARAP_USER_NAMELEN
#error _MAX_ARAP_USER_NAMELEN != MAX_ARAP_USER_NAMELEN
#endif

#if _AUTHENTICATOR_RESPONSE_LENGTH > A_SHA_DIGEST_LEN
#error _AUTHENTICATOR_RESPONSE_LENGTH > A_SHA_DIGEST_LEN
#endif

#if _CHAP_RESPONSE_SIZE != CHAP_RESPONSE_SIZE
#error _CHAP_RESPONSE_SIZE != CHAP_RESPONSE_SIZE
#endif


//////////
// Reference count for API initialization.
//////////
LONG theRefCount;

//////////
// Lock variable -- non-zero if API is locked.
//////////
LONG theLsaLock;

//////////
// SID lengths for the local domains.
//////////
ULONG theAccountSidLen, theBuiltinSidLen;

//////////
// Macros to lock/unlock the LSA API during intialization and shutdown.
//////////
#define LSA_LOCK() \
   while (InterlockedExchange(&theLsaLock, 1)) Sleep(5)

#define LSA_UNLOCK() \
   InterlockedExchange(&theLsaLock, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLsaInitialize
//
// DESCRIPTION
//
//    Initializes the LSA API.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLsaInitialize( VOID )
{
   DWORD status;

   LSA_LOCK();

   if (theRefCount == 0)
   {
      IASTraceString("Initializing LSA/SAM sub-system.");

      status = IASStaticInfoInitialize();
      if (status != NO_ERROR) { goto exit; }

      status = IASSamInitialize();
      if (status != NO_ERROR) { goto shutdown_static; }

      status = IASDynamicInfoInitialize();
      if (status != NO_ERROR) { goto shutdown_sam; }

      status = IASLogonInitialize();
      if (status != NO_ERROR) { goto shutdown_dynamic; }

      theAccountSidLen = IASLengthRequiredChildSid(theAccountDomainSid);
      theBuiltinSidLen = IASLengthRequiredChildSid(theBuiltinDomainSid);

      IASTraceString("LSA/SAM sub-system initialized successfully.");
   }
   else
   {
      // We're already initialized.
      status = NO_ERROR;
   }

   ++theRefCount;
   goto exit;

shutdown_dynamic:
   IASDynamicInfoShutdown();

shutdown_sam:
   IASSamShutdown();

shutdown_static:
   IASStaticInfoShutdown();
   IASTraceFailure("LSA/SAM initialization", status);

exit:
   LSA_UNLOCK();
   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLsaUninitialize
//
// DESCRIPTION
//
//    Uninitializes the LSA API.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASLsaUninitialize( VOID )
{
   LSA_LOCK();

   --theRefCount;

   if (theRefCount == 0)
   {
      IASLogonShutdown();
      IASDynamicInfoShutdown();
      IASSamShutdown();
      IASStaticInfoShutdown();
   }

   LSA_UNLOCK();
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonPAP
//
// DESCRIPTION
//
//    Performs PAP authentication against the NT SAM database.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonPAP(
    PCWSTR UserName,
    PCWSTR Domain,
    PCSTR Password,
    PHANDLE Token,
    PIAS_PAP_PROFILE Profile
    )
{
   DWORD status;
   ULONG authLength;
   PMSV1_0_LM20_LOGON authInfo;
   PBYTE data;
   PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
   ProfileBuffer = NULL;

   // Calculate the length of the authentication info.
   authLength = (ULONG)(sizeof(MSV1_0_LM20_LOGON) +
                (ALIGN_WCHAR - 1) +
                (wcslen(Domain) + wcslen(UserName)) * sizeof(WCHAR) +
                strlen(Password) * (sizeof(WCHAR) + sizeof(CHAR)));

   // Allocate a buffer on the stack.
   // Need extra room for the RtlCopyAnsiStringToUnicode conversion.
   authInfo = (PMSV1_0_LM20_LOGON)_alloca(authLength + 2 * sizeof(WCHAR));

   // Initialize the struct.
   IASInitAuthInfo(
       authInfo,
       sizeof(MSV1_0_LM20_LOGON),
       UserName,
       Domain,
       &data
       );

   // Copy in the ANSI password.
   IASInitAnsiString(
       authInfo->CaseInsensitiveChallengeResponse,
       data,
       Password
       );

   // Make sure that the Unicode string is properly aligned.
   data = ROUND_UP_POINTER(data, ALIGN_WCHAR);

   // Copy in the Unicode password. We have to force a UNICODE_STRING into
   // an ANSI_STRING struct.
   IASInitUnicodeStringFromAnsi(
       *(PUNICODE_STRING)&authInfo->CaseSensitiveChallengeResponse,
       data,
       authInfo->CaseInsensitiveChallengeResponse
       );

   // Set the parameters.
   authInfo->ParameterControl = DEFAULT_PARAMETER_CONTROL |
                                MSV1_0_CLEARTEXT_PASSWORD_ALLOWED |
                                MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED;

   status = IASLogonUser(
                authInfo,
                authLength,
                &ProfileBuffer,
                Token
                );

   if (status == NO_ERROR)
   {
      Profile->KickOffTime.QuadPart = ProfileBuffer->KickOffTime.QuadPart;

      // free it.
      LsaFreeReturnBuffer(ProfileBuffer);
   }
   else
   {
      Profile->KickOffTime.QuadPart = MAXLONGLONG;
   }
   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonCHAP
//
// DESCRIPTION
//
//    Performs MD5-CHAP authentication against the NT SAM database.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonCHAP(
    PCWSTR UserName,
    PCWSTR Domain,
    BYTE ChallengeID,
    PBYTE Challenge,
    DWORD ChallengeLength,
    PBYTE Response,
    PHANDLE Token,
    PIAS_CHAP_PROFILE Profile
    )
{
   DWORD status;
   ULONG authLength, rasAuthLength, md5AuthLength;
   PMSV1_0_SUBAUTH_LOGON authInfo;
   PBYTE data;
   RAS_SUBAUTH_INFO* ras;
   MD5CHAP_SUBAUTH_INFO* md5;
   MD5CHAP_EX_SUBAUTH_INFO* md5ex;
   PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
   ProfileBuffer = NULL;

   // Calculate the length of the MD5 subauth info.
   if (ChallengeLength == 16)
   {
      md5AuthLength = sizeof(MD5CHAP_SUBAUTH_INFO);
   }
   else
   {
      md5AuthLength = sizeof(MD5CHAP_EX_SUBAUTH_INFO) + ChallengeLength - 1;
   }

   // Calculate the length of the RAS subauth info.
   rasAuthLength = sizeof(RAS_SUBAUTH_INFO) + md5AuthLength;

   // Calculate the length of all the subauth info.
   authLength = (ULONG)(sizeof(MSV1_0_LM20_LOGON) +
                (ALIGN_WORST - 1) +
                (wcslen(Domain) + wcslen(UserName)) * sizeof(WCHAR) +
                rasAuthLength);

   // Allocate a buffer on the stack.
   authInfo = (PMSV1_0_SUBAUTH_LOGON)_alloca(authLength);

   // Initialize the struct.
   IASInitAuthInfo(
       authInfo,
       sizeof(MSV1_0_LM20_LOGON),
       UserName,
       Domain,
       &data
       );

   //////////
   // Set the RAS_SUBAUTH_INFO.
   //////////

   // Make sure the struct is properly aligned.
   data = ROUND_UP_POINTER(data, ALIGN_WORST);

   authInfo->AuthenticationInfo1.Length = (USHORT)rasAuthLength;
   authInfo->AuthenticationInfo1.MaximumLength = (USHORT)rasAuthLength;
   authInfo->AuthenticationInfo1.Buffer = (PCHAR)data;

   ras = (RAS_SUBAUTH_INFO*)data;
   ras->DataSize = md5AuthLength;

   //////////
   // Set the MD5CHAP_SUBAUTH_INFO or MD5CHAP_EX_SUBAUTH_INFO.
   //////////

   if (ChallengeLength == 16)
   {
      ras->ProtocolType = RAS_SUBAUTH_PROTO_MD5CHAP;
      md5 = (MD5CHAP_SUBAUTH_INFO*)ras->Data;
      md5->uchChallengeId = ChallengeID;
      IASInitFixedArray(md5->uchChallenge, Challenge);
      IASInitFixedArray(md5->uchResponse, Response);
   }
   else
   {
      ras->ProtocolType = RAS_SUBAUTH_PROTO_MD5CHAP_EX;
      md5ex = (MD5CHAP_EX_SUBAUTH_INFO*)ras->Data;
      md5ex->uchChallengeId = ChallengeID;
      IASInitFixedArray(md5ex->uchResponse, Response);
      memcpy(md5ex->uchChallenge, Challenge, ChallengeLength);
   }

   // Set the parameters and package ID.
   authInfo->ParameterControl =
     DEFAULT_PARAMETER_CONTROL |
     (MSV1_0_SUBAUTHENTICATION_DLL_RAS << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT) |
     MSV1_0_SUBAUTHENTICATION_DLL_EX;

   status = IASLogonUser(
                authInfo,
                authLength,
                &ProfileBuffer,
                Token
                );

   if (status == NO_ERROR)
   {
      Profile->KickOffTime.QuadPart = ProfileBuffer->KickOffTime.QuadPart;

      // free it.
      LsaFreeReturnBuffer(ProfileBuffer);
   }
   else
   {
      Profile->KickOffTime.QuadPart = MAXLONGLONG;
   }
   return status;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonMSCHAP
//
// DESCRIPTION
//
//    Performs MS-CHAP authentication against the NT SAM database.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonMSCHAP(
    PCWSTR UserName,
    PCWSTR Domain,
    PBYTE Challenge,
    PBYTE NtResponse,
    PBYTE LmResponse,
    PIAS_MSCHAP_PROFILE Profile,
    PHANDLE Token
    )
{
   DWORD status;
   ULONG authLength;
   PMSV1_0_LM20_LOGON authInfo;
   PBYTE data;
   PMSV1_0_LM20_LOGON_PROFILE logonProfile;
   DWORD len;

   // Calculate the length of the authentication info.
   authLength = sizeof(MSV1_0_LM20_LOGON) +
                (wcslen(Domain) + wcslen(UserName)) * sizeof(WCHAR) +
                (LmResponse ? LM_RESPONSE_LENGTH : 0) +
                (NtResponse ? NT_RESPONSE_LENGTH : 0);

   // Allocate a buffer on the stack.
   authInfo = (PMSV1_0_LM20_LOGON)_alloca(authLength);

   // Initialize the struct.
   IASInitAuthInfo(
       authInfo,
       sizeof(MSV1_0_LM20_LOGON),
       UserName,
       Domain,
       &data
       );

   /////////
   // Fill in the challenges and responses.
   /////////

   IASInitFixedArray(
       authInfo->ChallengeToClient,
       Challenge
       );

   if (NtResponse)
   {
      IASInitOctetString(
          authInfo->CaseSensitiveChallengeResponse,
          data,
          NtResponse,
          NT_RESPONSE_LENGTH
          );
   }
   else
   {
      memset(
          &authInfo->CaseSensitiveChallengeResponse,
          0,
          sizeof(authInfo->CaseSensitiveChallengeResponse)
          );
   }

   if (LmResponse)
   {
      IASInitOctetString(
          authInfo->CaseInsensitiveChallengeResponse,
          data,
          LmResponse,
          LM_RESPONSE_LENGTH
          );
   }
   else
   {
      memset(
          &authInfo->CaseInsensitiveChallengeResponse,
          0,
          sizeof(authInfo->CaseInsensitiveChallengeResponse)
          );
   }

   // Set the parameters.
   authInfo->ParameterControl = DEFAULT_PARAMETER_CONTROL;

   status = IASLogonUser(
                authInfo,
                authLength,
                &logonProfile,
                Token
                );

   if (status == NO_ERROR)
   {
      Profile->KickOffTime.QuadPart = logonProfile->KickOffTime.QuadPart;

      if (logonProfile->LogonDomainName.Buffer)
      {
         wcsncpy(Profile->LogonDomainName,
                 logonProfile->LogonDomainName.Buffer,
                 DNLEN);
      }
      else
      {
         memset(Profile->LogonDomainName, 0, sizeof(Profile->LogonDomainName));
      }

      IASInitFixedArray(
          Profile->LanmanSessionKey,
          logonProfile->LanmanSessionKey
          );

      IASInitFixedArray(
          Profile->UserSessionKey,
          logonProfile->UserSessionKey
          );

      LsaFreeReturnBuffer(logonProfile);
   }

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASChangePassword1
//
// DESCRIPTION
//
//    Performs V1 password change.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASChangePassword1(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PBYTE Challenge,
    IN PBYTE LmOldPassword,
    IN PBYTE LmNewPassword,
    IN PBYTE NtOldPassword,
    IN PBYTE NtNewPassword,
    IN DWORD NewLmPasswordLength,
    IN BOOL NtPresent,
    OUT PBYTE NewNtResponse,
    OUT PBYTE NewLmResponse
    )
{
   DWORD status;
   SAM_HANDLE hUser;
   LM_OWF_PASSWORD LmOwfOldPassword;
   LM_OWF_PASSWORD LmOwfNewPassword;
   NT_OWF_PASSWORD NtOwfOldPassword;
   NT_OWF_PASSWORD NtOwfNewPassword;
   BOOLEAN fLmOldPresent;

   //////////
   // Open the user object.
   //////////

   status = IASSamOpenUser(
                Domain,
                UserName,
                USER_CHANGE_PASSWORD,
                DS_WRITABLE_REQUIRED,
                NULL,
                NULL,
                &hUser
                );
   if (status != NO_ERROR) { return status; }

   //////////
   // Decrypt the LM passwords.
   //////////

   RtlDecryptLmOwfPwdWithLmSesKey(
       (PENCRYPTED_LM_OWF_PASSWORD)LmOldPassword,
       (PLM_SESSION_KEY)Challenge,
       &LmOwfOldPassword
       );

   RtlDecryptLmOwfPwdWithLmSesKey(
       (PENCRYPTED_LM_OWF_PASSWORD)LmNewPassword,
       (PLM_SESSION_KEY)Challenge,
       &LmOwfNewPassword
       );

   //////////
   // Decrypt the NT passwords if present.
   //////////

   if (NtPresent)
   {
      RtlDecryptNtOwfPwdWithNtSesKey(
          (PENCRYPTED_NT_OWF_PASSWORD)NtOldPassword,
          (PNT_SESSION_KEY)Challenge,
          &NtOwfOldPassword
          );

      RtlDecryptNtOwfPwdWithNtSesKey(
          (PENCRYPTED_NT_OWF_PASSWORD)NtNewPassword,
          (PNT_SESSION_KEY)Challenge,
          &NtOwfNewPassword
          );
   }

   //////////
   // Change the password for this user
   //////////

   fLmOldPresent = (NewLmPasswordLength > LM20_PWLEN) ? FALSE : TRUE;

   status = SamiChangePasswordUser(
                hUser,
                fLmOldPresent,
                &LmOwfOldPassword,
                &LmOwfNewPassword,
                (BOOLEAN)NtPresent,
                &NtOwfOldPassword,
                &NtOwfNewPassword
                );

   if (NT_SUCCESS(status))
   {
      //////////
      // Calculate the user's reponse with the new password.
      //////////

      RtlCalculateLmResponse(
          (PLM_CHALLENGE)Challenge,
          &LmOwfNewPassword,
          (PLM_RESPONSE)NewLmResponse
          );

      RtlCalculateNtResponse(
          (PNT_CHALLENGE)Challenge,
          &NtOwfNewPassword,
          (PNT_RESPONSE)NewNtResponse
          );
   }

   SamCloseHandle(hUser);

   return RtlNtStatusToDosError(status);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASChangePassword2
//
// DESCRIPTION
//
//    Performs V2 password change.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASChangePassword2(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE OldNtHash,
   IN PBYTE OldLmHash,
   IN PBYTE NtEncPassword,
   IN PBYTE LmEncPassword,
   IN BOOL LmPresent
   )
{
   DWORD status;
   PDOMAIN_CONTROLLER_INFOW dci;
   UNICODE_STRING uniServerName, uniUserName;

   //////////
   // Get the name of the DC to connect to.
   //////////

   if (_wcsicmp(Domain, theAccountDomain) == 0)
   {
      //////////
      // Local domain, so use theLocalServer.
      //////////

      dci = NULL;

      RtlInitUnicodeString(
          &uniServerName,
          theLocalServer
          );
   }
   else
   {
      //////////
      // Remote domain, so use IASGetDcName.
      //////////

      status = IASGetDcName(
                   Domain,
                   DS_WRITABLE_REQUIRED,
                   &dci
                   );
      if (status != NO_ERROR) { goto exit; }

      RtlInitUnicodeString(
          &uniServerName,
          dci->DomainControllerName
          );
   }

   RtlInitUnicodeString(
       &uniUserName,
       UserName
       );

   status = SamiChangePasswordUser2(
                &uniServerName,
                &uniUserName,
                (PSAMPR_ENCRYPTED_USER_PASSWORD)NtEncPassword,
                (PENCRYPTED_NT_OWF_PASSWORD)OldNtHash,
                (BOOLEAN)LmPresent,
                (PSAMPR_ENCRYPTED_USER_PASSWORD)LmEncPassword,
                (PENCRYPTED_LM_OWF_PASSWORD)OldLmHash
                );
   status = RtlNtStatusToDosError(status);

   if (dci)
   {
      NetApiBufferFree(dci);
   }

exit:
   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// Various constants used for MS-CHAP v2
//
///////////////////////////////////////////////////////////////////////////////

UCHAR AuthMagic1[39] =
{
   0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
   0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
   0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
   0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74
};

UCHAR AuthMagic2[41] =
{
   0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
   0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
   0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
   0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
   0x6E
};

UCHAR SHSpad1[40] =
{
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

UCHAR SHSpad2[40] =
{
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2
};

UCHAR KeyMagic1[27] =
{
   0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
   0x68, 0x65, 0x20, 0x4D, 0x50, 0x50, 0x45, 0x20, 0x4D,
   0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4B, 0x65, 0x79
};

UCHAR KeyMagic2[84] =
{
   0x4F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x69,
   0x65, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2C, 0x20,
   0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x20, 0x6B, 0x65, 0x79,
   0x3B, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
   0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
   0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
   0x6B, 0x65, 0x79, 0x2E
};

UCHAR KeyMagic3[84] =
{
   0x4F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x69,
   0x65, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2C, 0x20,
   0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
   0x6B, 0x65, 0x79, 0x3B, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
   0x69, 0x64, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
   0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x20,
   0x6B, 0x65, 0x79, 0x2E
};

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonMSCHAPv2
//
// DESCRIPTION
//
//    Performs MS-CHAP v2 authentication.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonMSCHAPv2(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PCSTR HashUserName,
    IN PBYTE Challenge,
    IN DWORD ChallengeLength,
    IN PBYTE Response,
    IN PBYTE PeerChallenge,
    OUT PIAS_MSCHAP_V2_PROFILE Profile,
    OUT PHANDLE Token
    )
{
   A_SHA_CTX context;
   BYTE digest[A_SHA_DIGEST_LEN], masterKey[A_SHA_DIGEST_LEN];
   BYTE computedChallenge[MSV1_0_CHALLENGE_LENGTH];
   IAS_MSCHAP_PROFILE v1profile;
   DWORD status;

   /////////
   // Compute the v2 challenge.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, PeerChallenge, 16);
   A_SHAUpdate(&context, Challenge, ChallengeLength);
   A_SHAUpdate(&context, (PBYTE)HashUserName, strlen(HashUserName));
   A_SHAFinal(&context, digest);
   memcpy(computedChallenge, digest, sizeof(computedChallenge));

   /////////
   // Authenticate the user.
   /////////

   status = IASLogonMSCHAP(
                UserName,
                Domain,
                computedChallenge,
                Response,
                NULL,
                &v1profile,
                Token
                );
   if (status != NO_ERROR) { return status; }

   /////////
   // Generate authenticator response.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, v1profile.UserSessionKey, 16);
   A_SHAUpdate(&context, Response, NT_RESPONSE_LENGTH);
   A_SHAUpdate(&context, AuthMagic1, sizeof(AuthMagic1));
   A_SHAFinal(&context, digest);

   A_SHAInit(&context);
   A_SHAUpdate(&context, digest, sizeof(digest));
   A_SHAUpdate(&context, computedChallenge, sizeof(computedChallenge));
   A_SHAUpdate(&context, AuthMagic2, sizeof(AuthMagic2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->AuthResponse, digest, _AUTHENTICATOR_RESPONSE_LENGTH);

   /////////
   // Generate master key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, v1profile.UserSessionKey, 16);
   A_SHAUpdate(&context, Response, NT_RESPONSE_LENGTH);
   A_SHAUpdate(&context, KeyMagic1, sizeof(KeyMagic1));
   A_SHAFinal(&context, masterKey);

   /////////
   // Generate receive key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic2, sizeof(KeyMagic2));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->RecvSessionKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);

   /////////
   // Generate send key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic3, sizeof(KeyMagic3));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->SendSessionKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);

   /////////
   // Copy the logon domain.
   /////////

   memcpy(
       Profile->LogonDomainName,
       v1profile.LogonDomainName,
       sizeof(Profile->LogonDomainName)
       );

   /////////
   // Save the KickOffTime.
   /////////

   Profile->KickOffTime = v1profile.KickOffTime;

   return NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASChangePassword3
//
// DESCRIPTION
//
//    Performs MS-CHAP v2 change password.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASChangePassword3(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE EncHash,
   IN PBYTE EncPassword
   )
{
   return IASChangePassword2(
              UserName,
              Domain,
              EncHash,
              NULL,
              EncPassword,
              NULL,
              FALSE
              );
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetAliasMembership
//
// DESCRIPTION
//
//    Determines alias membership in the local account and built-in domains.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetAliasMembership(
    IN PSID UserSid,
    IN PTOKEN_GROUPS GlobalGroups,
    IN PIAS_LSA_ALLOC Allocator,
    OUT PTOKEN_GROUPS *Groups,
    OUT PDWORD ReturnLength
    )
{
   DWORD i, status, idx;
   ULONG globalSidCount;
   PSID *globalSids, sidBuffer;
   PULONG accountAliases, builtinAliases;
   ULONG accountAliasCount, builtinAliasCount;
   ULONG buflen, groupCount;

   //////////
   // Form an array of the 'global' SIDs (global groups plus user).
   //////////

   globalSidCount = GlobalGroups->GroupCount + 1;
   globalSids = (PSID*)_alloca(globalSidCount * sizeof(PSID));

   // First the group SIDs ...
   for (i = 0; i < GlobalGroups->GroupCount; ++i)
   {
      globalSids[i] = GlobalGroups->Groups[i].Sid;
   }

   // ... then the user SID.
   globalSids[i] = UserSid;

   //////////
   // Lookup aliases in the account and built-in domains.
   //////////

   status = SamGetAliasMembership(
                theAccountDomainHandle,
                globalSidCount,
                globalSids,
                &accountAliasCount,
                &accountAliases
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto exit;
   }

   status = SamGetAliasMembership(
                theBuiltinDomainHandle,
                globalSidCount,
                globalSids,
                &builtinAliasCount,
                &builtinAliases
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto free_account_aliases;
   }

   //////////
   // Allocate memory for the TOKEN_GROUPS struct.
   //////////

   // Space for the struct header.
   buflen = FIELD_OFFSET(TOKEN_GROUPS, Groups);

   // Space for the global groups.
   groupCount = GlobalGroups->GroupCount;
   for (i = 0; i < groupCount; ++i)
   {
      buflen += RtlLengthSid(GlobalGroups->Groups[i].Sid);
   }

   // Space for the aliases in the account domain.
   groupCount += accountAliasCount;
   buflen += theAccountSidLen * accountAliasCount;

   // Space for the aliases in the builtin domain.
   groupCount += builtinAliasCount;
   buflen += theBuiltinSidLen * builtinAliasCount;

   // Space for the SID_AND_ATTRIBUTES array.
   buflen += sizeof(SID_AND_ATTRIBUTES) * groupCount;

   *Groups = (PTOKEN_GROUPS)Allocator(buflen);
   if (!*Groups)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto free_builtin_aliases;
   }
   *ReturnLength = buflen;

   //////////
   // Fill in the TOKEN_GROUPS struct.
   //////////

   (*Groups)->GroupCount = groupCount;
   sidBuffer = (*Groups)->Groups + groupCount;

   RtlCopySidAndAttributesArray(
       GlobalGroups->GroupCount,
       GlobalGroups->Groups,
       buflen,
       (*Groups)->Groups,
       sidBuffer,
       &sidBuffer,
       &buflen
       );

   idx = GlobalGroups->GroupCount;
   for (i = 0; i < accountAliasCount; ++i, ++idx)
   {
      IASInitializeChildSid(
          sidBuffer,
          theAccountDomainSid,
          accountAliases[i]
          );

      (*Groups)->Groups[idx].Sid = sidBuffer;
      (*Groups)->Groups[idx].Attributes = SE_GROUP_ENABLED;

      sidBuffer = (PBYTE)sidBuffer + theAccountSidLen;
   }

   for (i = 0; i < builtinAliasCount; ++i, ++idx)
   {
      IASInitializeChildSid(
          sidBuffer,
          theBuiltinDomainSid,
          builtinAliases[i]
          );

      (*Groups)->Groups[idx].Sid = sidBuffer;
      (*Groups)->Groups[idx].Attributes = SE_GROUP_ENABLED;

      sidBuffer = (PBYTE)sidBuffer + theBuiltinSidLen;
   }

free_builtin_aliases:
   SamFreeMemory(builtinAliases);

free_account_aliases:
   SamFreeMemory(accountAliases);

exit:
   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetGroupsForUser
//
// DESCRIPTION
//
//    Allocated and initializes a TOKEN_GROUPS struct for the specified user.
//
///////////////////////////////////////////////////////////////////////////////

#define REQUIRED_USER_FIELDS \
   ( USER_ALL_USERACCOUNTCONTROL | \
     USER_ALL_ACCOUNTEXPIRES     | \
     USER_ALL_PARAMETERS         )

DWORD
WINAPI
IASGetGroupsForUser(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PIAS_LSA_ALLOC Allocator,
    OUT PTOKEN_GROUPS *Groups,
    OUT PDWORD ReturnLength,
    OUT PLARGE_INTEGER SessionTimeout
    )
{
   DWORD status, i;
   SAM_HANDLE hUser;
   PSID userDomainSid;
   ULONG userRid;
   PUSER_ALL_INFORMATION uai;
   PGROUP_MEMBERSHIP globalGroups;
   ULONG globalGroupCount, globalSidLen;
   PTOKEN_GROUPS tokenGroups;
   PSID sidBuffer;

   _ASSERT(SessionTimeout != NULL);

   //////////
   // Open the user.
   //////////

   status = IASSamOpenUser(
                Domain,
                UserName,
                USER_LIST_GROUPS | USER_READ_ACCOUNT | USER_READ_LOGON,
                0,
                &userRid,
                &userDomainSid,
                &hUser
                );
   if (status != NO_ERROR) { goto exit; }

   //////////
   // Check the account restrictions.
   //////////

   status = SamQueryInformationUser(
                hUser,
                UserAllInformation,
                (PVOID*)&uai
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto close_user;
   }

   if ((uai->WhichFields & REQUIRED_USER_FIELDS) != REQUIRED_USER_FIELDS)
   {
      status = ERROR_ACCESS_DENIED;
      goto free_user_info;
   }

   if (uai->UserAccountControl & USER_ACCOUNT_DISABLED)
   {
      status = ERROR_ACCOUNT_DISABLED;
      goto free_user_info;
   }

   if (uai->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
   {
      status = ERROR_ACCOUNT_LOCKED_OUT;
      goto free_user_info;
   }

   status = IASCheckAccountRestrictions(
                &(uai->AccountExpires),
                (PIAS_LOGON_HOURS)&(uai->LogonHours),
                SessionTimeout
                );
   if (status != NO_ERROR) { goto free_user_info; }

   //////////
   // Get the user's global groups.
   //////////

   status = SamGetGroupsForUser(
                hUser,
                &globalGroups,
                &globalGroupCount
                );
   if (!NT_SUCCESS(status))
   {
      status = RtlNtStatusToDosError(status);
      goto close_user;
   }


   //////////
   // Allocate memory for the TOKEN_GROUPS struct plus the user SID.
   //////////

   globalSidLen   = IASLengthRequiredChildSid(userDomainSid);
   tokenGroups =
      (PTOKEN_GROUPS)_alloca(
                         FIELD_OFFSET(TOKEN_GROUPS, Groups) +
                         (sizeof(SID_AND_ATTRIBUTES) + globalSidLen) *
                         globalGroupCount +
                         globalSidLen
                         );

   //////////
   // Fill in the TOKEN_GROUPS struct.
   //////////

   tokenGroups->GroupCount = globalGroupCount;
   sidBuffer = tokenGroups->Groups + globalGroupCount;

   for (i = 0; i < globalGroupCount; ++i)
   {
      IASInitializeChildSid(
          sidBuffer,
          userDomainSid,
          globalGroups[i].RelativeId
          );

      tokenGroups->Groups[i].Sid = sidBuffer;
      tokenGroups->Groups[i].Attributes = globalGroups[i].Attributes;

      sidBuffer = (PBYTE)sidBuffer + globalSidLen;
   }

   ///////
   // Compute the user SID.
   ///////

   IASInitializeChildSid(
       sidBuffer,
       userDomainSid,
       userRid
       );

   ///////
   // Expand the group membership locally.
   ///////

   status = IASGetAliasMembership(
                sidBuffer,
                tokenGroups,
                Allocator,
                Groups,
                ReturnLength
                );

   SamFreeMemory(globalGroups);

free_user_info:
   SamFreeMemory(uai);

close_user:
   RtlFreeHeap(RtlProcessHeap(), 0, userDomainSid);
   SamCloseHandle(hUser);

exit:
   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    GetSamUserParameters
//
// DESCRIPTION
//
//    Retrieves the USER_PARAMETERS_INFORMATION for a user.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
GetSamUserParameters(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PUSER_PARAMETERS_INFORMATION *UserParameters
    )
{
   DWORD status;
   SAM_HANDLE hUser;

   // Initialize the out parameter.
   *UserParameters = NULL;

   // Find the user.
   status = IASSamOpenUser(
                Domain,
                UserName,
                USER_READ_ACCOUNT,
                0,
                NULL,
                NULL,
                &hUser
                );
   if (status == NO_ERROR)
   {
      // Get the user's parameters.
      status = SamQueryInformationUser(
                   hUser,
                   UserParametersInformation,
                   (PVOID*)UserParameters
                   );
      if (!NT_SUCCESS(status)) { status = RtlNtStatusToDosError(status); }

      SamCloseHandle(hUser);
   }

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetUserParameters
//
// DESCRIPTION
//
//    Returns the SAM UserParameters for a given user. The returned string
//    must be freed through LocalFree.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetUserParameters(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PWSTR *UserParameters
    )
{
   DWORD status;
   SAM_HANDLE hUser;
   PUSER_PARAMETERS_INFORMATION upi;

   // Initialize the out parameter.
   *UserParameters = NULL;

   // Get the USER_PARAMETERS_INFORMATION.
   status = GetSamUserParameters(
                UserName,
                Domain,
                &upi
                );
   if (status != NO_ERROR) { return status; }

   *UserParameters = (PWSTR)LocalAlloc(
                                LMEM_FIXED,
                                upi->Parameters.Length + sizeof(WCHAR)
                                );

   if (*UserParameters)
   {
      memcpy(*UserParameters, upi->Parameters.Buffer, upi->Parameters.Length);

      (*UserParameters)[upi->Parameters.Length / sizeof(WCHAR)] = L'\0';
   }
   else
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
   }

   SamFreeMemory(upi);

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetRASUserInfo
//
// DESCRIPTION
//
//    Basically a rewrite of RasAdminUserGetInfo.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetRASUserInfo(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PRAS_USER_0 RasUser0
    )
{
   DWORD status;
   PWSTR userParms;

   status = IASGetUserParameters(
                UserName,
                Domain,
                &userParms
                );

   if (status == NO_ERROR)
   {
      status = IASParmsQueryRasUser0(
                   userParms,
                   RasUser0
                   );

      LocalFree(userParms);
   }

   return status;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASValidateUserName
//
// DESCRIPTION
//
//    Verifies that the input parameters represent a valid SAM account.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASValidateUserName(
    IN PCWSTR UserName,
    IN PCWSTR Domain
    )
{
   DWORD status;
   PWCHAR attrs[1];
   PLDAPMessage msg;
   SAM_HANDLE hUser;
   IAS_NTDS_RESULT result = { 0, 0 };

   // For remote domains, we'll try LDAP first since it's faster.
   if (!IASIsDomainLocal(Domain))
   {
      attrs[0] = NULL;
      status = IASNtdsQueryUserAttributes(
                   Domain,
                   UserName,
                   LDAP_SCOPE_SUBTREE,
                   attrs,
                   &result
                   );
      IASNtdsFreeResult(&result);

      if (status != ERROR_DS_NOT_INSTALLED &&
          status != ERROR_INVALID_DOMAIN_ROLE)
      {
         return status;
      }
   }

   // Couldn't use the DS, so try SAM.
   status = IASSamOpenUser(
                Domain,
                UserName,
                USER_READ_ACCOUNT,
                0,
                NULL,
                NULL,
                &hUser
                );
   if (status == NO_ERROR) { SamCloseHandle(hUser); }

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetDefaultDomain
//
// DESCRIPTION
//
//    Returns the default domain. The returned string should be treated as
//    read-only memory.
//
///////////////////////////////////////////////////////////////////////////////
PCWSTR
WINAPI
IASGetDefaultDomain( VOID )
{
   return theDefaultDomain;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetDnsDomainName
//
// DESCRIPTION
//
//    Returns the dns name of the domain
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetDnsDomainName(LPWSTR buffer, LPDWORD bufferByteSize)
{
   DWORD result = NO_ERROR;

   EnterCriticalSection(&critSec);
   // i.e. assert that this function is not called after uninitialize or
   // if initialize failed
   _ASSERT(theDnsDomainName != 0);

   if (bufferByteSize == 0 || buffer == 0)
   {
      result = ERROR_INSUFFICIENT_BUFFER;
   }
   else
   {
      HRESULT hr = StringCbCopyNW(
                      buffer,
                      *bufferByteSize,
                      theDnsDomainName->Buffer,
                      theDnsDomainName->Length
                      );
      if (FAILED(hr))
      {
         result = HRESULT_CODE(hr);
      }
   }

   // always set the necessary size
   *bufferByteSize = theDnsDomainName->Length + sizeof(wchar_t); // for '\0'

   // Failure could be for any reason: insufficient buffer size or
   // anything else.
   LeaveCriticalSection(&critSec);
   return result;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASIsDomainLocal
//
// DESCRIPTION
//
//    Returns TRUE if the specified domain resides on the local machine.
//
///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
IASIsDomainLocal(
    IN PCWSTR Domain
    )
{
   return (_wcsicmp(Domain, theAccountDomain) == 0) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetRole
//
// DESCRIPTION
//
//    Returns the role of the local computer.
//
///////////////////////////////////////////////////////////////////////////////
IAS_ROLE
WINAPI
IASGetRole( VOID )
{
   return ourRole;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetProductType
//
// DESCRIPTION
//
//    Returns the product type of the local computer.
//
///////////////////////////////////////////////////////////////////////////////
IAS_PRODUCT_TYPE
WINAPI
IASGetProductType( VOID )
{
   return ourProductType;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetGuestAccountName
//
// DESCRIPTION
//
//    Returns the SAM account name of the guest account for the default
//    domain. GuestAccount must be large enough to hold DNLEN + UNLEN + 2
//    characters.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetGuestAccountName(
    OUT PWSTR AccountName
    )
{
   wcscpy(AccountName, theGuestAccount);
   return NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASMapWin32Error
//
// DESCRIPTION
//
//    Maps a Win32 error code to an IAS reason code. If the error can't be
//    mapped, 'hrDefault' is returned. If 'hrDefault' equals -1, then
//    HRESULT_FROM_WIN32 will be used to force a mapping.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASMapWin32Error(
    IN DWORD dwError,
    IN HRESULT hrDefault
    )
{
   HRESULT hr = hrDefault;

   switch (dwError)
   {
      case NO_ERROR:
         hr = S_OK;
         break;

      case ERROR_ACCESS_DENIED:
         hr = IAS_ACCESS_DENIED;
         break;

      case ERROR_NO_SUCH_DOMAIN:
         hr = IAS_NO_SUCH_DOMAIN;
         break;

      case ERROR_NO_LOGON_SERVERS:
      case RPC_S_SERVER_UNAVAILABLE:
      case RPC_S_SERVER_TOO_BUSY:
      case RPC_S_CALL_FAILED:
      case EPT_S_NOT_REGISTERED:
         hr = IAS_DOMAIN_UNAVAILABLE;
         break;

      case ERROR_INVALID_PASSWORD:
      case ERROR_LOGON_FAILURE:
         hr = IAS_AUTH_FAILURE;
         break;

      case ERROR_INVALID_LOGON_HOURS:
         hr = IAS_INVALID_LOGON_HOURS;
         break;

      case ERROR_PASSWORD_EXPIRED:
      case ERROR_PASSWORD_MUST_CHANGE:
         hr = IAS_PASSWORD_MUST_CHANGE;
         break;

      case ERROR_ACCOUNT_RESTRICTION:
         hr = IAS_ACCOUNT_RESTRICTION;
         break;

      case ERROR_ACCOUNT_DISABLED:
         hr = IAS_ACCOUNT_DISABLED;
         break;

      case ERROR_ACCOUNT_EXPIRED:
         hr = IAS_ACCOUNT_EXPIRED;
         break;

      case ERROR_ACCOUNT_LOCKED_OUT:
         hr = IAS_ACCOUNT_LOCKED_OUT;
         break;

      case ERROR_NO_SUCH_USER:
      case ERROR_NONE_MAPPED:
      case NERR_UserNotFound:
         hr = IAS_NO_SUCH_USER;
         break;

      case ERROR_ILL_FORMED_PASSWORD:
      case ERROR_PASSWORD_RESTRICTION:
         hr = IAS_CHANGE_PASSWORD_FAILURE;
         break;

      case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
         hr = IAS_NO_CLEARTEXT_PASSWORD;
         break;

      case CRYPT_E_REVOKED:
         hr = IAS_CRYPT_E_REVOKED;
         break;

      case CRYPT_E_NO_REVOCATION_DLL:
         hr = IAS_CRYPT_E_NO_REVOCATION_DLL;
         break;

      case CRYPT_E_NO_REVOCATION_CHECK:
         hr = IAS_CRYPT_E_NO_REVOCATION_CHECK;
         break;

      case CRYPT_E_REVOCATION_OFFLINE:
         hr = IAS_CRYPT_E_REVOCATION_OFFLINE;
         break;

      case SEC_E_MESSAGE_ALTERED:
         hr = IAS_SEC_E_MESSAGE_ALTERED;
         break;

      case SEC_E_NO_AUTHENTICATING_AUTHORITY:
         hr = IAS_SEC_E_NO_AUTHENTICATING_AUTHORITY;
         break;

      case SEC_E_INCOMPLETE_MESSAGE:
         hr = IAS_SEC_E_INCOMPLETE_MESSAGE;
         break;

      case SEC_E_INCOMPLETE_CREDENTIALS:
         hr = IAS_SEC_E_INCOMPLETE_CREDENTIALS;
         break;

      case SEC_E_TIME_SKEW:
         hr = IAS_SEC_E_TIME_SKEW;
         break;

      case SEC_E_UNTRUSTED_ROOT:
         hr = IAS_SEC_E_UNTRUSTED_ROOT;
         break;

      case SEC_E_ILLEGAL_MESSAGE:
         hr = IAS_SEC_E_ILLEGAL_MESSAGE;
         break;

      case SEC_E_CERT_WRONG_USAGE:
         hr = IAS_SEC_E_CERT_WRONG_USAGE;
         break;

      case SEC_E_CERT_EXPIRED:
         hr = IAS_SEC_E_CERT_EXPIRED;
         break;

      case SEC_E_ALGORITHM_MISMATCH:
         hr = IAS_SEC_E_ALGORITHM_MISMATCH;
         break;

      case SEC_E_SMARTCARD_LOGON_REQUIRED:
         hr = IAS_SEC_E_SMARTCARD_LOGON_REQUIRED;
         break;

      case SEC_E_SHUTDOWN_IN_PROGRESS:
         hr = IAS_SEC_E_SHUTDOWN_IN_PROGRESS;
         break;

      case SEC_E_MULTIPLE_ACCOUNTS:
         hr = IAS_SEC_E_MULTIPLE_ACCOUNTS;
         break;

      case TRUST_E_PROVIDER_UNKNOWN:
         hr = IAS_TRUST_E_PROVIDER_UNKNOWN;
         break;

      case TRUST_E_ACTION_UNKNOWN:
         hr = IAS_TRUST_E_ACTION_UNKNOWN;
         break;

      case TRUST_E_SUBJECT_FORM_UNKNOWN:
         hr = IAS_TRUST_E_SUBJECT_FORM_UNKNOWN;
         break;

      case TRUST_E_SUBJECT_NOT_TRUSTED:
         hr = IAS_TRUST_E_SUBJECT_NOT_TRUSTED;
         break;

      case TRUST_E_NOSIGNATURE:
         hr = IAS_TRUST_E_NOSIGNATURE;
         break;

      case CERT_E_EXPIRED:
         hr = IAS_CERT_E_EXPIRED;
         break;

      case CERT_E_VALIDITYPERIODNESTING:
         hr = IAS_CERT_E_VALIDITYPERIODNESTING;
         break;

      case CERT_E_ROLE:
         hr = IAS_CERT_E_ROLE;
         break;

      case CERT_E_PATHLENCONST:
         hr = IAS_CERT_E_PATHLENCONST;
         break;

      case CERT_E_CRITICAL:
         hr = IAS_CERT_E_CRITICAL;
         break;

      case CERT_E_PURPOSE:
         hr = IAS_CERT_E_PURPOSE;
         break;

      case CERT_E_ISSUERCHAINING:
         hr = IAS_CERT_E_ISSUERCHAINING;
         break;

      case CERT_E_MALFORMED:
         hr = IAS_CERT_E_MALFORMED;
         break;

      case CERT_E_UNTRUSTEDROOT:
         hr = IAS_CERT_E_UNTRUSTEDROOT;
         break;

      case CERT_E_CHAINING:
         hr = IAS_CERT_E_CHAINING;
         break;

      case TRUST_E_FAIL:
         hr = IAS_TRUST_E_FAIL;
         break;

      case CERT_E_REVOKED:
         hr = IAS_CERT_E_REVOKED ;
         break;

      case CERT_E_UNTRUSTEDTESTROOT:
         hr = IAS_CERT_E_UNTRUSTEDTESTROOT;
         break;

      case CERT_E_REVOCATION_FAILURE:
         hr = IAS_CERT_E_REVOCATION_FAILURE;
         break;

      case CERT_E_CN_NO_MATCH:
         hr = IAS_CERT_E_CN_NO_MATCH;
         break;

      case CERT_E_WRONG_USAGE:
         hr = IAS_CERT_E_WRONG_USAGE;
         break;

      case TRUST_E_EXPLICIT_DISTRUST:
         hr = IAS_TRUST_E_EXPLICIT_DISTRUST;
         break;

      case CERT_E_UNTRUSTEDCA:
         hr = IAS_CERT_E_UNTRUSTEDCA;
         break;

      case CERT_E_INVALID_POLICY:
         hr = IAS_CERT_E_INVALID_POLICY;
         break;

      case CERT_E_INVALID_NAME:
         hr = IAS_CERT_E_INVALID_NAME;
         break;

      case SEC_E_PKINIT_NAME_MISMATCH:
         hr = IAS_SEC_E_PKINIT_NAME_MISMATCH;
         break;

      case SEC_E_OUT_OF_SEQUENCE:
         hr = IAS_SEC_E_OUT_OF_SEQUENCE;
         break;

      case SEC_E_NO_CREDENTIALS:
         hr = IAS_SEC_E_NO_CREDENTIALS;
         break;

      case NTE_BAD_UID:
      case NTE_BAD_HASH:
      case NTE_BAD_KEY:
      case NTE_BAD_LEN:
      case NTE_BAD_DATA:
      case NTE_BAD_SIGNATURE:
      case NTE_BAD_VER:
      case NTE_BAD_ALGID:
      case NTE_BAD_FLAGS:
      case NTE_BAD_TYPE:
      case NTE_BAD_KEY_STATE:
      case NTE_BAD_HASH_STATE:
      case NTE_NO_KEY:
      case NTE_NO_MEMORY:
      case NTE_EXISTS:
      case NTE_PERM:
      case NTE_NOT_FOUND:
      case NTE_DOUBLE_ENCRYPT:
      case NTE_BAD_PROVIDER:
      case NTE_BAD_PROV_TYPE:
      case NTE_BAD_PUBLIC_KEY:
      case NTE_BAD_KEYSET:
      case NTE_PROV_TYPE_NOT_DEF:
      case NTE_PROV_TYPE_ENTRY_BAD:
      case NTE_KEYSET_NOT_DEF:
      case NTE_KEYSET_ENTRY_BAD:
      case NTE_PROV_TYPE_NO_MATCH:
      case NTE_SIGNATURE_FILE_BAD:
      case SEC_I_CONTINUE_NEEDED:
      case SEC_I_COMPLETE_NEEDED:
      case SEC_I_COMPLETE_AND_CONTINUE:
      case SEC_I_LOCAL_LOGON:
      case SEC_E_BAD_PKGID:
      case SEC_E_CONTEXT_EXPIRED:
      case SEC_I_CONTEXT_EXPIRED:
      case SEC_E_BUFFER_TOO_SMALL:
      case SEC_I_INCOMPLETE_CREDENTIALS:
      case SEC_I_RENEGOTIATE:
      case SEC_E_WRONG_PRINCIPAL:
      case SEC_I_NO_LSA_CONTEXT:
      case SEC_E_ENCRYPT_FAILURE:
      case SEC_E_DECRYPT_FAILURE:
      case SEC_E_SECURITY_QOS_FAILED:
      case SEC_E_UNFINISHED_CONTEXT_DELETED:
      case SEC_E_NO_TGT_REPLY:
      case SEC_E_NO_IP_ADDRESSES:
      case SEC_E_WRONG_CREDENTIAL_HANDLE:
      case SEC_E_CRYPTO_SYSTEM_INVALID:
      case SEC_E_MAX_REFERRALS_EXCEEDED:
      case SEC_E_MUST_BE_KDC:
      case SEC_E_STRONG_CRYPTO_NOT_SUPPORTED:
      case SEC_E_TOO_MANY_PRINCIPALS:
      case SEC_E_NO_PA_DATA:
      case SEC_E_CERT_UNKNOWN:
         hr = IAS_UNEXPECTED_EAP_ERROR;
         break;

      case ERROR_PROTOCOL_NOT_CONFIGURED:
         hr = IAS_EAP_NEGOTIATION_FAILED;
         break;

      default:
         // Default value already set above.
         break;
   }

   return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetDcName
//
// DESCRIPTION
//
//    Wrapper around DsGetDcNameW. Tries to do the right thing with regard
//    to NETBIOS and DNS names.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetDcName(
    IN LPCWSTR DomainName,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
   DWORD status;
   PDOMAIN_CONTROLLER_INFOW dci;

   if (!(Flags & DS_IS_DNS_NAME)) { Flags |= DS_IS_FLAT_NAME; }

   status = DsGetDcNameW(
                NULL,
                DomainName,
                NULL,
                NULL,
                Flags,
                DomainControllerInfo
                );

   if (status == NO_ERROR &&
       !(Flags & DS_IS_DNS_NAME) &&
       ((*DomainControllerInfo)->Flags & DS_DS_FLAG))
   {
      // It's an NT5 DC, so we need the DNS name of the server.
      Flags |= DS_RETURN_DNS_NAME;

      // We always want a cache hit here.
      Flags &= ~(ULONG)DS_FORCE_REDISCOVERY;

      if (!DsGetDcNameW(
               NULL,
               DomainName,
               NULL,
               NULL,
               Flags,
               &dci
               ))
      {
         NetApiBufferFree(*DomainControllerInfo);
         *DomainControllerInfo = dci;
      }
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\dyninfo.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    dyninfo.c
//
// SYNOPSIS
//
//    Defines and initializes global variables containing dynamic configuration
//    information.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//    03/23/1999    Changes to ezsam API.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>

#include <lm.h>

#include "statinfo.h"
#include "ezsam.h"
#include "dyninfo.h"
#include "iastrace.h"

//////////
// The primary domain.
//////////
WCHAR thePrimaryDomain[DNLEN + 1];

//////////
// The default domain.
//////////
PCWSTR theDefaultDomain;

//////////
// The dns domain name.
//////////
const LSA_UNICODE_STRING* theDnsDomainName;

//////////
// Role of the local machine.
//////////
IAS_ROLE ourRole;

//////////
// Name of the guest account for the default domain.
//////////
WCHAR theGuestAccount[DNLEN + UNLEN + 2];

//////////
// Change event and notification thread.
//////////
HANDLE theChangeEvent, theNotificationThread;

//////////
// Flag to bring down the notification thread.
//////////
BOOL theShutdownFlag;

CRITICAL_SECTION critSec;

PPOLICY_DNS_DOMAIN_INFO ppdi;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASQueryPrimaryDomain
//
// DESCRIPTION
//
//    Reads the primary domain info and determines role of the local computer.
//
// NOTES
//
//    This method is intentionally not synchronized. This method is
//    called *very* rarely and worst case a few packets will get
//    discarded because the new domain name hasn't been updated yet.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASQueryPrimaryDomain( VOID )
{
   NTSTATUS status;
   DWORD result;
   LSA_HANDLE hLsa;
   WCHAR accountName[DNLEN + UNLEN + 2], *userName;
   ULONG guestRid;
   SAM_HANDLE hGuest;
   PUSER_ACCOUNT_NAME_INFORMATION uani;
   PPOLICY_DNS_DOMAIN_INFO newDomainInfo;

   //////////
   // Open a handle to the LSA.
   //////////

   status = LsaOpenPolicy(
                NULL,
                &theObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &hLsa
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   EnterCriticalSection(&critSec);

   //////////
   // Get the primary domain information.
   //////////

   newDomainInfo = 0;
   status = LsaQueryInformationPolicy(
                hLsa,
                PolicyDnsDomainInformation,
                (PVOID*)&newDomainInfo
                );
   if (!NT_SUCCESS(status)) { goto close_lsa; }

   // We're done with the info buffer.
   if (ppdi != 0)
   {
      LsaFreeMemory(ppdi);
   }

   ppdi = newDomainInfo;
   //////////
   // Save the primary domain name and determine our role.
   //////////

   if (ppdi->Sid == NULL)
   {
      thePrimaryDomain[0] = L'\0';

      // No primary domain, so we must be standalone.
      ourRole = IAS_ROLE_STANDALONE;

      IASTraceString("Role: Standalone");
   }
   else
   {
      wcsncpy(thePrimaryDomain, ppdi->Name.Buffer, DNLEN);

      if (RtlEqualSid(ppdi->Sid, theAccountDomainSid))
      {
         // Account domain and primary domain are the same, so we must be DC.
         ourRole = IAS_ROLE_DC;

         IASTraceString("Role: Domain Controller");
      }
      else
      {
         ourRole = IAS_ROLE_MEMBER;

         IASTraceString("Role: Domain member");
      }
   }

   _wcsupr(thePrimaryDomain);
   IASTracePrintf("Primary domain: %S", thePrimaryDomain);

   theDnsDomainName = &(ppdi->DnsDomainName);

   if (theDnsDomainName->Buffer != NULL)
   {
      IASTracePrintf("Dns Domain name: %S", theDnsDomainName->Buffer);
   }

   //////////
   // Determine the default domain.
   //////////

   if (ourProductType == IAS_PRODUCT_WORKSTATION)
   {
      // For Workstation, the default domain is always the local domain.
      theDefaultDomain = theAccountDomain;
   }
   else if (ourRole == IAS_ROLE_STANDALONE)
   {
      // For Standalone there's nowhere to go besides local.
      theDefaultDomain = theAccountDomain;
   }
   else if (theRegistryDomain[0] != L'\0')
   {
      // For Server, a registry entry always takes precedence.
      theDefaultDomain = theRegistryDomain;
   }
   else
   {
      // Everyone else defaults to the primary domain.
      theDefaultDomain = thePrimaryDomain;
   }

   IASTracePrintf("Default domain: %S", theDefaultDomain);

   //////////
   // Now that we know the default domain we can determine the guest account.
   //////////

   wcscpy(accountName, theDefaultDomain);
   wcscat(accountName, L"\\");

   // If we can't read the guest account name, we'll assume it's "Guest".
   userName = accountName + wcslen(accountName);
   wcscpy(userName, L"Guest");

   guestRid = DOMAIN_USER_RID_GUEST;
   result = IASSamOpenUser(
                theDefaultDomain,
                NULL,
                USER_READ_GENERAL,
                0,
                &guestRid,
                NULL,
                &hGuest
                );
   if (result != ERROR_SUCCESS)
   { 
      // keep status with a succesfull value
      // we do not want to prevent IAS from starting because of this error
      goto set_guest_account;
   }

   status = SamQueryInformationUser(
                hGuest,
                UserAccountNameInformation,
                (PVOID*)&uani
                );
   if (!NT_SUCCESS(status)) { goto close_guest; }

   // Overwrite the default Guest name with the real one.
   wcsncpy(userName, uani->UserName.Buffer, UNLEN);
   SamFreeMemory(uani);

close_guest:
   SamCloseHandle(hGuest);

set_guest_account:
   // Copy the local buffer into the global buffer.
   wcscpy(theGuestAccount, accountName);

   IASTracePrintf("Guest account: %S", theGuestAccount);

   // Ignore any errors that occurred reading the guest account.
   status = NO_ERROR;

close_lsa:
   LeaveCriticalSection(&critSec);
   LsaClose(hLsa);

exit:
   return RtlNtStatusToDosError(status);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    NotificationProc
//
// DESCRIPTION
//
//    Entry point for notification thread.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
NotificationProc(PVOID lpArg)
{
   DWORD status;

   while (1)
   {
      status = WaitForSingleObject(
                   theChangeEvent,
                   INFINITE
                   );

      // If we had an error or the shutdown flag is set, then we'll exit.
      if ((status != WAIT_OBJECT_0) || theShutdownFlag) { break; }

      IASTraceString("Received domain name change notification.");

      // Otherwise, read the new domain info.
      IASQueryPrimaryDomain();
   }

   return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASDynamicInfoInitialize
//
// DESCRIPTION
//
//    Initializes the dynamic data defined above and creates a thread to
//    wait for change notifications.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASDynamicInfoInitialize( VOID )
{
   DWORD status, threadID;

   if (!InitializeCriticalSectionAndSpinCount(&critSec,  0x00001000))
   {
      return GetLastError();
   }

   do
   {
      //////////
      // Read the initial state of the info.
      //////////

      status = IASQueryPrimaryDomain();
      if (status != NO_ERROR) 
      { 
         break;
      }

      //////////
      // Set up the thread that handles dynamic changes.
      //////////

      // Get a notification event.
      status = NetRegisterDomainNameChangeNotification(&theChangeEvent);
      if (status != NERR_Success) 
      { 
         break; 
      }

      // Reset the shutdown flag.
      theShutdownFlag = FALSE;

      // Create a thread to wait on the event.
      theNotificationThread = CreateThread(
                                 NULL,
                                 0,
                                 NotificationProc,
                                 NULL,
                                 0,
                                 &threadID
                                 );
      if (!theNotificationThread)
      {
         NetUnregisterDomainNameChangeNotification(theChangeEvent);
         theChangeEvent = NULL;
         status = GetLastError();
         break;
      }
      status = NO_ERROR;
   }
   while(FALSE);

   if (status != NO_ERROR)
   {
      DeleteCriticalSection(&critSec);
      if (ppdi != 0)
      {
         LsaFreeMemory(ppdi);
         ppdi = 0;
      }
   }

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASDynamicInfoShutdown
//
// DESCRIPTION
//
//    Shuts down the notifation thread.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASDynamicInfoShutdown( VOID )
{
   // Set the shutdown flag.
   theShutdownFlag = TRUE;

   // Bring down the thread.
   SetEvent(theChangeEvent);
   WaitForSingleObject(
       theNotificationThread,
       INFINITE
       );

   // Unregister the notification.
   NetUnregisterDomainNameChangeNotification(theChangeEvent);
   theChangeEvent = NULL;

   // Close the thread handle.
   CloseHandle(theNotificationThread);
   theNotificationThread = NULL;

   // Critical section not useful anymore
   DeleteCriticalSection(&critSec);

   // We're done with the info buffer.
   if (ppdi != 0)
   {
      LsaFreeMemory(ppdi);
      ppdi = 0;
   }
   theDnsDomainName = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\iasparms.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasparms.cpp
//
// SYNOPSIS
//
//    Defines functions for storing and retrieving (name, value) pairs from
//    the SAM UserParameters field.
//
// MODIFICATION HISTORY
//
//    10/16/1998    Original version.
//    02/11/1999    Add RasUser0 functions.
//    02/24/1999    Treat invalid UserParameters as no dialin.
//    03/16/1999    Truncate callback number if too long.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define IASSAMAPI

#include <iasapi.h>
#include <iasparms.h>

//////////
// I included the Netp function declarations here to avoid dependency on
// the net project.
//////////

DECLSPEC_IMPORT
NTSTATUS
NTAPI
NetpParmsSetUserProperty (
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,
    OUT BOOL *            Update
    );

DECLSPEC_IMPORT
NTSTATUS
NTAPI
NetpParmsQueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

DECLSPEC_IMPORT
VOID
NTAPI
NetpParmsUserPropertyFree (
    LPWSTR NewUserParms
    );

//////////
// Concatenates two BSTR's and returns the result. The caller is responsible
// for freeing the returned string.
//////////
BSTR
WINAPI
ConcatentateBSTRs(
    IN CONST OLECHAR *bstr1,
    IN CONST OLECHAR *bstr2
    )
{
   UINT len1, len2;
   BSTR retval;

   // Compute the lengths of the two strings.
   len1 = bstr1 ? SysStringByteLen((BSTR)bstr1) : 0;
   len2 = bstr2 ? SysStringByteLen((BSTR)bstr2) : 0;

   // Allocate memory for the result.
   retval = SysAllocStringByteLen(NULL, len1 + len2);

   if (retval)
   {
      // Copy in the first string.
      if (bstr1)
      {
         memcpy(retval, bstr1, len1 + sizeof(WCHAR));
      }

      // Copy in the second string.
      if (bstr2)
      {
         memcpy((PBYTE)retval + len1, bstr2, len2 + sizeof(WCHAR));
      }
   }

   return retval;
}

//////////
// Saves a single-valued VARIANT (i.e., not a SAFEARRAY) to a string.
//////////
HRESULT
WINAPI
SaveSingleVariantToString(
    IN CONST VARIANT *pvarSrc,
    OUT BSTR *pbstrDest
    )
{
   HRESULT hr;
   VARIANT v;
   UINT len;
   OLECHAR tag[18];  // 5 + 1 + 10 + 1 + 1

   // Coerce the VARIANT to a BSTR.
   VariantInit(&v);
   hr = IASVariantChangeType(
            &v,
            (LPVARIANT)pvarSrc,
            0,
            VT_BSTR
            );
   if (FAILED(hr)) { return hr; }

   // Compute the length of the header and the data.
   len = SysStringLen(V_BSTR(&v));
   len += swprintf(tag, L"%hu:%lu:", V_VT(pvarSrc), len);

   // Allocate the result string.
   *pbstrDest = SysAllocStringLen(NULL, len);
   if (*pbstrDest != NULL)
   {
      // Copy in the tag and the data.
      wcscat(wcscpy(*pbstrDest, tag), V_BSTR(&v));
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   // Clear the intermediate string.
   VariantClear(&v);

   return hr;
}

//////////
// Loads a single-valued VARIANT (i.e., not a SAFEARRAY) from a string.
// Also returns a pointer to where the scan stopped.
//////////
HRESULT
WINAPI
LoadSingleVariantFromString(
    IN PCWSTR pszSrc,
    IN UINT cSrcLen,
    OUT VARIANT *pvarDest,
    OUT PCWSTR *ppszEnd
    )
{
   PCWSTR nptr;
   VARTYPE vt;
   PWSTR endptr;
   ULONG len;
   VARIANT v;
   HRESULT hr;

   // Initialize the cursor.
   nptr = pszSrc;

   // Read the VARTYPE token.
   vt = (VARTYPE)wcstoul(nptr, &endptr, 10);
   if (endptr == nptr || *endptr != L':') { return E_INVALIDARG; }
   nptr = endptr + 1;

   // Read the length token.
   len = wcstoul(nptr, &endptr, 10);
   if (endptr == nptr || *endptr != L':') { return E_INVALIDARG; }
   nptr = endptr + 1;

   // Make sure there's enough characters left for the data.
   if (nptr + len > pszSrc + cSrcLen) { return E_INVALIDARG; }

   // Read the BSTR data into a VARIANT.
   V_VT(&v) = VT_BSTR;
   V_BSTR(&v) = SysAllocStringLen(nptr, len);
   if (V_BSTR(&v) == NULL) { return E_OUTOFMEMORY; }

   // Coerce the VARIANT to the desired type.
   hr = IASVariantChangeType(
            pvarDest,
            &v,
            0,
            vt
            );

   // Clear the intermediate string.
   VariantClear(&v);

   // Return the position where the scan stopped.
   *ppszEnd = nptr + len;

   return hr;
}

//////////
// Saves a VARIANT to a string. The caller is responsible for freeing the
// returned string.
//////////
HRESULT
WINAPI
IASSaveVariantToString(
    IN CONST VARIANT *pvarSrc,
    OUT BSTR *pbstrDest
    )
{
   HRESULT hr;
   SAFEARRAY *psa;
   LONG lowerBound, upperBound, idx;
   VARIANT *data;
   BSTR item, newResult;

   // Check the input arguments.
   if (pvarSrc == NULL || pbstrDest == NULL) { return E_POINTER; }

   // Initialize the return parameter.
   *pbstrDest = NULL;

   // Is this an array ?
   if (V_VT(pvarSrc) != (VT_VARIANT | VT_ARRAY))
   {
      // No, so we can delegate and bail.
      return SaveSingleVariantToString(pvarSrc, pbstrDest);
   }

   // Yes, so extract the SAFEARRAY.
   psa = V_ARRAY(pvarSrc);

   // We only handle one-dimensional arrays.
   if (SafeArrayGetDim(psa) != 1) { return DISP_E_TYPEMISMATCH; }

   // Get the array bounds.
   hr = SafeArrayGetLBound(psa, 1, &lowerBound);
   if (FAILED(hr)) { return hr; }
   hr = SafeArrayGetUBound(psa, 1, &upperBound);
   if (FAILED(hr)) { return hr; }

   // Get the embedded array of VARIANTs.
   hr = SafeArrayAccessData(psa, (PVOID*)&data);

   // Loop through each VARIANT in the array.
   for (idx = lowerBound; idx <= upperBound; ++idx, ++data)
   {
      // Save the VARIANT into a BSTR.
      hr = SaveSingleVariantToString(data, &item);
      if (FAILED(hr)) { break; }

      // Merge this into the result ...
      newResult = ConcatentateBSTRs(*pbstrDest, item);

      // ... and free the old strings.
      SysFreeString(*pbstrDest);
      SysFreeString(item);

      // Store the new result.
      *pbstrDest = newResult;

      if (!newResult)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
   }

   // If anything went wrong, clean-up the partial result.
   if (FAILED(hr))
   {
      SysFreeString(*pbstrDest);
      *pbstrDest = NULL;
   }

   // Unlock the array.
   SafeArrayUnaccessData(psa);

   return hr;
}

//////////
// Loads a VARIANT from a string. The caller is responsible for freeing the
// returned VARIANT.
//////////
HRESULT
WINAPI
IASLoadVariantFromString(
    IN PCWSTR pszSrc,
    IN UINT cSrcLen,
    OUT VARIANT *pvarDest
    )
{
   PCWSTR end;
   HRESULT hr;
   SAFEARRAYBOUND bound;
   SAFEARRAY *psa;
   LONG index;
   VARIANT* item;

   // Check the parameters.
   if (pszSrc == NULL || pvarDest == NULL) { return E_POINTER; }

   // Initialize the out parameter.
   VariantInit(pvarDest);

   // Compute the end of the buffer.
   end = pszSrc + cSrcLen;

   // Go for the quick score on a single-valued property.
   hr = LoadSingleVariantFromString(
            pszSrc,
            cSrcLen,
            pvarDest,
            &pszSrc
            );
   if (FAILED(hr) || pszSrc == end) { return hr; }

   // Create a SAFEARRAY of VARIANTs to hold the array elements.
   // We know we have at least two elements.
   bound.cElements = 2;
   bound.lLbound = 0;
   psa = SafeArrayCreate(VT_VARIANT, 1, &bound);
   if (psa == NULL)
   {
      VariantClear(pvarDest);
      return E_OUTOFMEMORY;
   }

   // Store the VARIANT we already converted.
   index = 0;
   SafeArrayPtrOfIndex(psa, &index, (PVOID*)&item);
   memcpy(item, pvarDest, sizeof(VARIANT));

   // Now put the SAFEARRAY into the returned VARIANT.
   V_VT(pvarDest) = VT_ARRAY | VT_VARIANT;
   V_ARRAY(pvarDest) = psa;

   do
   {
      // Get the next element in the array.
      ++index;
      hr = SafeArrayPtrOfIndex(psa, &index, (PVOID*)&item);
      if (FAILED(hr)) { break; }

      // Load the next value.
      hr = LoadSingleVariantFromString(
               pszSrc,
               (UINT)(end - pszSrc),
               item,
               &pszSrc
               );
      if (FAILED(hr) || pszSrc == end) { break; }

      // We must have at least one more element, so grow the array.
      ++bound.cElements;
      hr = SafeArrayRedim(psa, &bound);

   } while (SUCCEEDED(hr));

   // If we failed, clean-up any partial results.
   if (FAILED(hr)) { VariantClear(pvarDest); }

   return hr;
}

HRESULT
WINAPI
IASParmsSetUserProperty(
    IN PCWSTR pszUserParms,
    IN PCWSTR pszName,
    IN CONST VARIANT *pvarValue,
    OUT PWSTR *ppszNewUserParms
    )
{
   BSTR bstrValue;
   UNICODE_STRING uniValue;
   NTSTATUS status;
   HRESULT hr;
   BOOL update;

   // Check the parameters.
   if (pvarValue == NULL || ppszNewUserParms == NULL) { return E_POINTER; }

   // Initialize the out parameter.
   *ppszNewUserParms = NULL;

   // Is the VARIANT empty ?
   if (V_VT(pvarValue) != VT_EMPTY)
   {
      // No, so save it to a string.
      hr = IASSaveVariantToString(
               pvarValue,
               &bstrValue
               );
      if (FAILED(hr)) { return hr; }

      RtlInitUnicodeString(&uniValue, bstrValue);
   }
   else
   {
      // Yes, so we're actually going to erase the property.
      bstrValue = NULL;
      memset(&uniValue, 0, sizeof(UNICODE_STRING));
   }

   // Write the property to UserParms.
   status = NetpParmsSetUserProperty(
                (PWSTR)pszUserParms,
                (PWSTR)pszName,
                uniValue,
                0,
                ppszNewUserParms,
                &update
                );

   if (NT_SUCCESS(status))
   {
      hr = S_OK;
   }
   else
   {
      status = RtlNtStatusToDosError(status);
      hr = HRESULT_FROM_WIN32(status);
   }

   // Free the BSTR value.
   SysFreeString(bstrValue);

   return hr;
}

HRESULT
WINAPI
IASParmsQueryUserProperty(
    IN PCWSTR pszUserParms,
    IN PCWSTR pszName,
    OUT VARIANT *pvarValue
    )
{
   NTSTATUS status;
   HRESULT hr;
   WCHAR flag;
   UNICODE_STRING uniValue;

   // Check the parameters.
   if (pvarValue == NULL) { return E_POINTER; }

   // Initialize the out parameter.
   VariantInit(pvarValue);

   // Get the property from UserParms.
   status = NetpParmsQueryUserProperty(
                (PWSTR)pszUserParms,
                (PWSTR)pszName,
                &flag,
                &uniValue
                );
   if (NT_SUCCESS(status))
   {
      if (uniValue.Buffer != NULL)
      {
         // We got a string so convert it to a VARIANT ...
         hr = IASLoadVariantFromString(
                  uniValue.Buffer,
                  uniValue.Length / sizeof (WCHAR),
                  pvarValue
                  );

         // ... and free the string.
         LocalFree(uniValue.Buffer);
      }
      else
      {
         // Buffer is zero-length, so we return VT_EMPTY.
         hr = S_OK;
      }
   }
   else
   {
      status = RtlNtStatusToDosError(status);
      hr = HRESULT_FROM_WIN32(status);
   }

   return hr;
}

VOID
WINAPI
IASParmsFreeUserParms(
    IN PWSTR pszNewUserParms
    )
{
   LocalFree(pszNewUserParms);
}

/////////
// Constants used for compressing/decompressing phone numbers.
/////////

CONST WCHAR COMPRESS_MAP[]     = L"() tTpPwW,-@*#";

#define UNPACKED_DIGIT     (100)
#define COMPRESS_MAP_BEGIN (110)
#define COMPRESS_MAP_END   (COMPRESS_MAP_BEGIN + 14)
#define UNPACKED_OTHER     (COMPRESS_MAP_END + 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    CompressPhoneNumber
//
// DESCRIPTION
//
//    Bizarre algorithm used to compress phone numbers stored in the
//    usr_parms field.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
CompressPhoneNumber(
   IN PCWSTR uncompressed,
   OUT PWSTR compressed
   )
{
   BOOL packed = FALSE;

   for( ; *uncompressed; ++uncompressed)
   {
      switch (*uncompressed)
      {
         case L'0':

            if (packed)
            {
               // Put zero as the second paired digit
               if (*compressed)
               {
                  *compressed *= 10;
                  ++compressed;
                  packed = FALSE;
               }
               else
               {
                  // We have a zero, we cant put a second zero or that
                  // will be a null byte. So, we store the value
                  // UNPACKED_DIGIT to fake this.

                  *compressed = UNPACKED_DIGIT;
                  *(++compressed) = 0;
                  packed = TRUE;
               }
            }
            else
            {
               *compressed = 0;
               packed = TRUE;
            }

            break;

         case L'1':
         case L'2':
         case L'3':
         case L'4':
         case L'5':
         case L'6':
         case L'7':
         case L'8':
         case L'9':

            // If this is the second digit that is going to be
            // packed into one byte
            if (packed)
            {
               *compressed *= 10;
               *compressed += *uncompressed - L'0';

               // we need to special case number 32 which maps to a blank
               if (*compressed == L' ')
               {
                  *compressed = COMPRESS_MAP_END;
               }

               ++compressed;
               packed = FALSE;
            }
            else
            {
               *compressed = *uncompressed - '0';
               packed = TRUE;
            }

            break;

         case L'(':
         case L')':
         case L' ':
         case L't':
         case L'T':
         case L'p':
         case L'P':
         case L'w':
         case L'W':
         case L',':
         case L'-':
         case L'@':
         case L'*':
         case L'#':

            // if the byte was packed then we unpack it
            if (packed)
            {
               *compressed += UNPACKED_DIGIT;
               ++compressed;
               packed = FALSE;
            }

            *compressed = (WCHAR)(COMPRESS_MAP_BEGIN +
                                  (wcschr(COMPRESS_MAP, *uncompressed) -
                                   COMPRESS_MAP));
            ++compressed;
            break;

         default:

            // if the chracter is none of the above specially recognized
            // characters then copy the value + UNPACKED_OTHER to make it
            // possible to decompress at the other end. [ 6/4/96 RamC ]
            if (packed)
            {
               *compressed += UNPACKED_DIGIT;
               ++compressed;
               packed = FALSE;
            }

            *compressed = *uncompressed + UNPACKED_OTHER;
            ++compressed;
        }
    }

    // If we are in the middle of packing something then we unpack it.
    if (packed)
    {
       *compressed += UNPACKED_DIGIT;
       ++compressed;
    }

    // Add the null terminator.
    *compressed = L'\0';
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    DecompressPhoneNumber
//
// DESCRIPTION
//
//    The inverse of CompressPhoneNumber above.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
DecompressPhoneNumber(
    IN PCWSTR compressed,
    OUT PWSTR decompressed
    )
{
   for( ; *compressed; ++compressed, ++decompressed)
   {
      // If this character is packed, then we unpack it.
      if (*compressed < UNPACKED_DIGIT)
      {
         *decompressed = *compressed / 10 + L'0';
         ++decompressed;
         *decompressed = *compressed % 10 + L'0';
         continue;
      }

      // We need to special case number 32 which maps to a blank.
      if (*compressed == COMPRESS_MAP_END)
      {
         *decompressed = L'3';
         ++decompressed;
         *decompressed = L'2';
         continue;
      }

      // The character is an unpacked digit.
      if (*compressed < COMPRESS_MAP_BEGIN)
      {
         *decompressed = *compressed - UNPACKED_DIGIT + L'0';
         continue;
      }

      //  The character is from the compression map.
      if (*compressed < UNPACKED_OTHER)
      {
         *decompressed = COMPRESS_MAP[*compressed - COMPRESS_MAP_BEGIN];
         continue;
      }

      // Otherwise the character is unpacked.
      *decompressed = *compressed - UNPACKED_OTHER;
    }

   // Add a null terminator.
   *decompressed = L'\0';
}

/////////
// Definition of the downlevel UserParameters.
/////////

#define UP_CLIENT_MAC  (L'm')
#define UP_CLIENT_DIAL (L'd')
#define UP_LEN_MAC     (LM20_UNLEN)
#define UP_LEN_DIAL    (LM20_MAXCOMMENTSZ - 4 - UP_LEN_MAC)

typedef struct {
    WCHAR up_MACid;
    WCHAR up_PriGrp[UP_LEN_MAC];
    WCHAR up_MAC_Terminator;
    WCHAR up_DIALid;
    WCHAR up_Privilege;
    WCHAR up_CBNum[UP_LEN_DIAL];
} USER_PARMS;

#define USER_PARMS_LEN (sizeof(USER_PARMS)/sizeof(WCHAR))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    InitUserParms
//
// DESCRIPTION
//
//    Initializes a USER_PARMS struct to a valid default state.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
InitUserParms(
    IN USER_PARMS* userParms
    )
{
   WCHAR *i, *end;

   // Set everything to a space ' '.
   i = (PWCHAR)userParms;
   end = i + USER_PARMS_LEN;
   for ( ; i != end; ++i)
   {
      *i = L' ';
   }

   // Initialize the 'special' fields.
   userParms->up_MACid = UP_CLIENT_MAC;
   userParms->up_PriGrp[0] = L':';
   userParms->up_DIALid = UP_CLIENT_DIAL;
   userParms->up_Privilege = RASPRIV_NoCallback;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASParmsSetRasUser0
//
// DESCRIPTION
//
//    Encodes the RAS_USER_0 struct into the downlevel portion of the
//    UserParameters string.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASParmsSetRasUser0(
    IN OPTIONAL PCWSTR pszOldUserParms,
    IN CONST RAS_USER_0* pRasUser0,
    OUT PWSTR* ppszNewUserParms
    )
{
   size_t oldLen, newLen, compressedLen;
   USER_PARMS userParms;
   WCHAR compressed[MAX_PHONE_NUMBER_LEN + 1];

   // Check the pointers.
   if (pRasUser0 == NULL || ppszNewUserParms == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   // Initialize the out parameters.
   *ppszNewUserParms = NULL;

   // Determine the length of the old UserParameters.
   oldLen = pszOldUserParms ? wcslen(pszOldUserParms) : 0;

   // Initialize the USER_PARMS structure.
   InitUserParms(&userParms);

   // Preserve the MAC Primary Group if present.
   if (oldLen > UP_LEN_MAC)
   {
      memcpy(
          userParms.up_PriGrp,
          pszOldUserParms + 1,
          sizeof(userParms.up_PriGrp)
          );
   }

   // Validate the CallbackType and save the compressed phone number.
   switch (pRasUser0->bfPrivilege & RASPRIV_CallbackType)
   {
      case RASPRIV_NoCallback:
      case RASPRIV_AdminSetCallback:
      case RASPRIV_CallerSetCallback:
      {

         // Compress the phone number.
         CompressPhoneNumber(pRasUser0->wszPhoneNumber, compressed);

         // Make sure it will fit in USER_PARMS.
         compressedLen = wcslen(compressed);
         if (compressedLen > UP_LEN_DIAL) { compressedLen = UP_LEN_DIAL; }

         // Store the compressed phone number.
         memcpy(userParms.up_CBNum, compressed, compressedLen * sizeof(WCHAR));

         break;
      }

      default:
         return ERROR_BAD_FORMAT;
   }

   // Store the privilege flags.
   userParms.up_Privilege = pRasUser0->bfPrivilege;

   // Allocate memory for the new UserParameters.
   newLen = max(oldLen, USER_PARMS_LEN);
   *ppszNewUserParms = (PWSTR)LocalAlloc(
                          LMEM_FIXED,
                          (newLen + 1) * sizeof(WCHAR)
                          );
   if (*ppszNewUserParms == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

   // Copy in the USER_PARMS struct.
   memcpy(*ppszNewUserParms, &userParms, sizeof(USER_PARMS));

   // Copy in any extra stuff.
   if (oldLen > USER_PARMS_LEN)
   {
      memcpy(
          *ppszNewUserParms + USER_PARMS_LEN,
          pszOldUserParms + USER_PARMS_LEN,
          (oldLen - USER_PARMS_LEN) * sizeof(WCHAR)
          );
   }

   // Add the null terminator.
   *(*ppszNewUserParms + newLen) = L'\0';

   return NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASParmsQueryRasUser0
//
// DESCRIPTION
//
//    Decodes the RAS_USER_0 struct from the UserParameters string.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASParmsQueryRasUser0(
    IN OPTIONAL PCWSTR pszUserParms,
    OUT PRAS_USER_0 pRasUser0
    )
{
   USER_PARMS* usrp;
   WCHAR callbackNumber[UP_LEN_DIAL + 1], *p;

   // Check the pointers.
   if (pRasUser0 == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   // Cast the string buffer to a USER_PARMS struct.
   usrp = (USER_PARMS*)pszUserParms;

   // If parms is not properly initialized, default to no RAS privilege.
   if (!pszUserParms ||
       wcslen(pszUserParms) < USER_PARMS_LEN ||
       usrp->up_DIALid != UP_CLIENT_DIAL)
   {
      pRasUser0->bfPrivilege = RASPRIV_NoCallback;
      pRasUser0->wszPhoneNumber[0] = L'\0';
      return NO_ERROR;
   }

   // Make a local copy.
   memcpy(callbackNumber, usrp->up_CBNum, sizeof(WCHAR) * UP_LEN_DIAL);

   // Add a null terminator and null out any trailing blanks.
   p = callbackNumber + UP_LEN_DIAL;
   *p = L'\0';
   while (--p >= callbackNumber && *p == L' ') { *p = L'\0'; }

   // Sanity check the bfPrivilege field.
   switch(usrp->up_Privilege & RASPRIV_CallbackType)
   {
      case RASPRIV_NoCallback:
      case RASPRIV_AdminSetCallback:
      case RASPRIV_CallerSetCallback:
      {
         pRasUser0->bfPrivilege = (BYTE)usrp->up_Privilege;
         DecompressPhoneNumber(callbackNumber, pRasUser0->wszPhoneNumber);
         break;
      }

      default:
      {
         pRasUser0->bfPrivilege = RASPRIV_NoCallback;
         pRasUser0->wszPhoneNumber[0] = L'\0';
      }
    }

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\statinfo.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    statinfo.h
//
// SYNOPSIS
//
//    Declares global variables containing static configuration info.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  _STATINFO_H_
#define  _STATINFO_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaslsa.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////
// Domain names.
//////////
extern WCHAR theAccountDomain [];
extern WCHAR theRegistryDomain[];

//////////
// SID's
//////////
extern PSID theAccountDomainSid;
extern PSID theBuiltinDomainSid;

//////////
// UNC name of the local computer.
//////////
extern WCHAR theLocalServer[];

//////////
// Product type for the local machine.
//////////
extern IAS_PRODUCT_TYPE ourProductType;

//////////
// Object Attributes -- no need to have more than one.
//////////
extern OBJECT_ATTRIBUTES theObjectAttributes;

DWORD
WINAPI
IASStaticInfoInitialize( VOID );

VOID
WINAPI
IASStaticInfoShutdown( VOID );

#ifdef __cplusplus
}
#endif
#endif  // _STATINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\cracker.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    Cracker.h
//
// SYNOPSIS
//
//    This file declares the class NameCracker.
//
// MODIFICATION HISTORY
//
//    04/13/1998    Original version.
//    08/10/1998    Remove NT4 support.
//    08/21/1998    Removed initialization/shutdown routines.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef  CRACKER_H_
#define  CRACKER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include "guard.h"
#include "nocopy.h"

#include <ntdsapi.h>

// Forward declaration of helper class used by NameCracker.
class DsHandle;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NameCracker
//
// DESCRIPTION
//
//    This class wraps the DsCrackNames API. It adds functionality for
//    connection caching and transparent retry of failed queries.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NameCracker
   : Guardable, NonCopyable
{
public:
   NameCracker() throw ();
   ~NameCracker() throw ();

   // Non-connection oriented version of DsCrackNames.
   DWORD crackNames(
             DS_NAME_FLAGS flags,
             DS_NAME_FORMAT formatOffered,
             DS_NAME_FORMAT formatDesired,
             PCWSTR name,
             PCWSTR upnSuffix,
             PDS_NAME_RESULTW *ppResult
             ) throw ();

   // Wrapper around the DsFreeNameResultW.
   void freeNameResult(DS_NAME_RESULTW *pResult) throw ()
   { DsFreeNameResultW(pResult); }

protected:

   // Discards the cached GC handle.  Used to shutdown a bad connection.
   void disable(DsHandle* h) throw ();

   // Get a handle to the Global Catalog.
   DWORD getGC(DsHandle** h) throw ();

   // Current connection to the Global Catalog.
   DsHandle* gc;

private:
   DWORD processSID(
                     PCWSTR name, 
                     PCWSTR upnSuffix, 
                     DS_NAME_FORMAT& newFormatOffered, 
                     wchar_t** ppUpnString) throw();

   bool convertSid2Puid(PCWSTR sidString, LARGE_INTEGER& puid) throw();
   
   DWORD convertPuid2String(
                        const LARGE_INTEGER& puid, 
                        wchar_t* upnString, 
                        DWORD upnStringCch,
                        const wchar_t* suffix
                     ) throw();
   
};

#endif  // CRACKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\lsa\statinfo.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    statinfo.c
//
// SYNOPSIS
//
//    Defines and initializes global variables containing static configuration
//    information.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//    03/24/1999    Convert domain names to upper case.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>

#include <statinfo.h>
#include <iastrace.h>

//////////
// Domain names.
//////////
WCHAR theAccountDomain [DNLEN + 1];   // Local account domain.
WCHAR theRegistryDomain[DNLEN + 1];   // Registry override for default domain.

//////////
// SID's
//////////
PSID theAccountDomainSid;
PSID theBuiltinDomainSid;

//////////
// UNC name of the local computer.
//////////
WCHAR theLocalServer[CNLEN + 3];

//////////
// Product type for the local machine.
//////////
IAS_PRODUCT_TYPE ourProductType;

//////////
// Object Attributes -- no need to have more than one.
//////////
SECURITY_QUALITY_OF_SERVICE QOS =
{
   sizeof(SECURITY_QUALITY_OF_SERVICE),  // Length
   SecurityImpersonation,                // ImpersonationLevel
   SECURITY_DYNAMIC_TRACKING,            // ContextTrackingMode
   FALSE                                 // EffectiveOnly
};
OBJECT_ATTRIBUTES theObjectAttributes =
{
   sizeof(OBJECT_ATTRIBUTES),            // Length
   NULL,                                 // RootDirectory
   NULL,                                 // ObjectName
   0,                                    // Attributes
   NULL,                                 // SecurityDescriptor
   &QOS                                  // SecurityQualityOfService
};

//////////
// Buffers containing the SID's defined above.
//////////
BYTE theAccountDomainSidBuffer[24];
BYTE theBuiltinDomainSidBuffer[16];

//////////
// Location of default domain parameter in the registry.
//////////
CONST
WCHAR
RAS_KEYPATH_BUILTIN[] = L"SYSTEM\\CurrentControlSet\\Services\\RasMan"
                        L"\\ppp\\ControlProtocols\\BuiltIn";
CONST
WCHAR
RAS_VALUENAME_DEFAULT_DOMAIN[] = L"DefaultDomain";


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASStaticInfoInitialize
//
// DESCRIPTION
//
//    Initializes the static data defined above.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASStaticInfoInitialize( VOID )
{
   DWORD cbData, status, type;
   LSA_HANDLE hLsa;
   PPOLICY_ACCOUNT_DOMAIN_INFO padi;
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
   NT_PRODUCT_TYPE ntProductType;
   HKEY hKey;

   //////////
   // The local host is always the server for the local domain.
   //////////

   wcscpy(theLocalServer, L"\\\\");
   cbData = CNLEN + 1;
   if (!GetComputerNameW(theLocalServer + 2, &cbData))
   { return GetLastError(); }

   IASTracePrintf("Local server: %S", theLocalServer);

   //////////
   // Open a handle to the LSA.
   //////////

   status = LsaOpenPolicy(
                NULL,
                &theObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &hLsa
                );
   if (!NT_SUCCESS(status)) { goto error; }

   //////////
   // Get the account domain information.
   //////////

   status = LsaQueryInformationPolicy(
                hLsa,
                PolicyAccountDomainInformation,
                (PVOID*)&padi
                );
   LsaClose(hLsa);
   if (!NT_SUCCESS(status)) { goto error; }

   // Save the domain name.
   wcsncpy(theAccountDomain, padi->DomainName.Buffer, DNLEN);
   _wcsupr(theAccountDomain);

   IASTracePrintf("Local account domain: %S", theAccountDomain);

   // Save the domain SID.
   theAccountDomainSid = (PSID)theAccountDomainSidBuffer;
   RtlCopySid(
       sizeof(theAccountDomainSidBuffer),
       theAccountDomainSid,
       padi->DomainSid
       );

   // We have what we need, so free the memory.
   LsaFreeMemory(padi);

   //////////
   // Form the SID for the Built-in domain.
   //////////

   theBuiltinDomainSid = (PSID)theBuiltinDomainSidBuffer;
   RtlInitializeSid(
       theBuiltinDomainSid,
       &sia,
       1
       );
   *RtlSubAuthoritySid(theBuiltinDomainSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;

   /////////
   // Determine our product type.
   //////////

   RtlGetNtProductType(&ntProductType);
   if (ntProductType == NtProductWinNt)
   {
      ourProductType = IAS_PRODUCT_WORKSTATION;

      IASTraceString("Product Type: Workstation");
   }
   else
   {
      ourProductType = IAS_PRODUCT_SERVER;

      IASTraceString("Product Type: Server");
   }

   //////////
   // Read the default domain (if any) from the registry.
   //////////

   // Open the registry key.
   status = RegOpenKeyW(
                HKEY_LOCAL_MACHINE,
                RAS_KEYPATH_BUILTIN,
                &hKey
                );

   if (status == NO_ERROR)
   {
      // Query the default domain value.
      cbData = sizeof(theRegistryDomain);
      status = RegQueryValueExW(
                   hKey,
                   RAS_VALUENAME_DEFAULT_DOMAIN,
                   NULL,
                   &type,
                   (LPBYTE)theRegistryDomain,
                   &cbData
                   );

      RegCloseKey(hKey);
   }

   // If we didn't successfully read a string, null it out.
   if (status != NO_ERROR || type != REG_SZ)
   {
      theRegistryDomain[0] = L'\0';
   }

   _wcsupr(theRegistryDomain);

   IASTracePrintf("Registry override: %S", theRegistryDomain);

   // Ignore any registry errors since the override is optional.
   return NO_ERROR;

error:
   return RtlNtStatusToDosError(status);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASStaticInfoShutdown
//
// DESCRIPTION
//
//    Currently just a placeholder.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASStaticInfoShutdown( VOID )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\cracker.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    Cracker.cpp
//
// SYNOPSIS
//
//    This file defines the class NameCracker.
//
// MODIFICATION HISTORY
//
//    04/13/1998    Original version.
//    08/10/1998    Remove NT4 support.
//    08/21/1998    Removed initialization/shutdown routines.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "cracker.h"
#include "iaslsa.h"
#include "iasutil.h"
#include "ntdsapip.h"
#include <sddl.h>
#include <new>

#include <strsafe.h>

//  Passport authority for SIDs
#ifndef SECURITY_PASSPORT_AUTHORITY
#define SECURITY_PASSPORT_AUTHORITY         {0,0,0,0,0,10}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    DsCrackNameAutoChaseW
//
// DESCRIPTION
//
//    Extension to DsCrackNames that automatically chases cross-forest
//    referrals using default credentials.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
DsCrackNameAutoChaseW(
   HANDLE hDS,
   DS_NAME_FLAGS flags,
   DS_NAME_FORMAT formatOffered,
   DS_NAME_FORMAT formatDesired,
   PCWSTR name,
   PDS_NAME_RESULTW* ppResult,
   BOOL* pChased
   )
{
   DWORD error;

   if (pChased == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   *pChased = FALSE;

   flags = (DS_NAME_FLAGS)(flags | DS_NAME_FLAG_TRUST_REFERRAL);

   error = DsCrackNamesW(
              hDS,
              flags,
              formatOffered,
              formatDesired,
              1,
              &name,
              ppResult
              );

   while ((error == NO_ERROR) &&
          ((*ppResult)->rItems->status == DS_NAME_ERROR_TRUST_REFERRAL))
   {
      *pChased = TRUE;

      HANDLE hDsForeign;
      error = DsBindW(NULL, (*ppResult)->rItems->pDomain, &hDsForeign);

      DsFreeNameResultW(*ppResult);
      *ppResult = NULL;

      if (error == NO_ERROR)
      {
         error = DsCrackNamesW(
                    hDsForeign,
                    flags,
                    formatOffered,
                    formatDesired,
                    1,
                    &name,
                    ppResult
                    );

         DsUnBindW(&hDsForeign);
      }
   }

   // Win2K Global Catalogs do not support DS_USER_PRINCIPAL_NAME_AND_ALTSECID
   // and will simply return DS_NAME_ERROR_NOT_FOUND every time. Thus, we can't
   // tell the difference between an invalid name and a downlevel GC, so try
   // again as a plain ol' UPN.
   if ((formatOffered == DS_USER_PRINCIPAL_NAME_AND_ALTSECID) &&
       (error == NO_ERROR) &&
       ((*ppResult)->rItems->status == DS_NAME_ERROR_NOT_FOUND))
   {
      DsFreeNameResultW(*ppResult);
      *ppResult = 0;

      return DsCrackNameAutoChaseW(
                hDS,
                flags,
                DS_USER_PRINCIPAL_NAME,
                formatDesired,
                name,
                ppResult,
                pChased
                );
   }

   return error;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DsHandle
//
// DESCRIPTION
//
//    This class represents a reference counted NTDS handle.
//
///////////////////////////////////////////////////////////////////////////////
class DsHandle
   : public NonCopyable
{
public:
   HANDLE get() const throw ()
   { return subject; }

   operator HANDLE() const throw ()
   { return subject; }

protected:
   friend class NameCracker;

   // Constructor and destructor are protected since only NameCracker is
   // allowed to open new handles.
   DsHandle(HANDLE h) throw ()
      : refCount(1), subject(h)
   { }

   ~DsHandle() throw ()
   {
      if (subject) { DsUnBindW(&subject); }
   }

   void AddRef() throw ()
   {
      InterlockedIncrement(&refCount);
   }

   void Release() throw ()
   {
      if (!InterlockedDecrement(&refCount)) { delete this; }
   }

   LONG refCount;      // reference count.
   HANDLE subject;     // HANDLE being ref counted.
};


NameCracker::NameCracker() throw ()
   : gc(NULL)
{ }

NameCracker::~NameCracker() throw ()
{
   if (gc) { gc->Release(); }
}

DWORD NameCracker::crackNames(
                       DS_NAME_FLAGS flags,
                       DS_NAME_FORMAT formatOffered,
                       DS_NAME_FORMAT formatDesired,
                       PCWSTR name,
                       PCWSTR upnSuffix,
                       PDS_NAME_RESULTW *ppResult
                       ) throw ()
{
   wchar_t* upnString = 0;
   DWORD errorCode = NO_ERROR;
   DS_NAME_FORMAT newFormatOffered = formatOffered;

   // if this is a SID
   if (formatOffered == DS_SID_OR_SID_HISTORY_NAME)
   {
      // can return NO_ERROR AND upnString = 0 if the SID is not a Passport SID
      errorCode = processSID(name, upnSuffix, newFormatOffered, &upnString);
   }

   // Get a handle to the GC.
   if (errorCode == NO_ERROR)
   {
      DsHandle* hDS1;
      errorCode = getGC(&hDS1);

      if (errorCode == NO_ERROR)
      {

         // Try to crack the names.
         BOOL chased;
         errorCode = DsCrackNameAutoChaseW(
                        *hDS1,
                        flags,
                        newFormatOffered,
                        formatDesired,
                        (upnString != 0)? upnString : name,
                        ppResult,
                        &chased
                        );

         if (errorCode != NO_ERROR && !chased)
         {
            // We failed, so disable the current handle ...
            disable(hDS1);

            // ... and try to get a new one.
            DsHandle* hDS2;
            errorCode = getGC(&hDS2);

            if (errorCode == NO_ERROR)
            {
               // Give it one more try with the new handle.
               errorCode = DsCrackNameAutoChaseW(
                              *hDS2,
                              flags,
                              formatOffered,
                              formatDesired,
                              name,
                              ppResult,
                              &chased
                              );

               if (errorCode != NO_ERROR && !chased)
               {
                  // No luck so disable the handle.
                  disable(hDS2);
               }

               hDS2->Release();
            }
         }

         hDS1->Release();
      }
   }

   delete[] upnString;
   return errorCode;
}

void NameCracker::disable(DsHandle* h) throw ()
{
   _serialize

   // If it doesn't match our cached handle, then someone else
   // has already disabled it.
   if (h == gc && gc != NULL)
   {
      gc->Release();

      gc = NULL;
   }
}

DWORD NameCracker::getGC(DsHandle** h) throw ()
{
   _ASSERT(h != NULL);

   *h = NULL;

   _serialize

   // Do we already have a cached handle?
   if (!gc)
   {
      // Bind to a GC.
      HANDLE hGC;
      DWORD err = DsBindWithCredA(NULL, NULL, NULL, &hGC);
      if (err != NO_ERROR)
      {
         return err;
      }

      // Allocate a new DsHandle object to wrap the NTDS handle.
      gc = new (std::nothrow) DsHandle(hGC);
      if (!gc)
      {
         DsUnBindW(&hGC);
         return ERROR_NOT_ENOUGH_MEMORY;
      }
   }

   // AddRef the handle and return to caller.
   (*h = gc)->AddRef();

   return NO_ERROR;
}

//
// NameCracker::processSID
//
// Transforms a Passport SID into a UPN
// or does nothing if the SID is not a passport SID
//
// can return NO_ERROR AND upnString = 0 if the SID is not a Passport SID
//
DWORD NameCracker::processSID(
                      PCWSTR name,
                      PCWSTR upnSuffix,
                      DS_NAME_FORMAT& newFormatOffered,
                      wchar_t** ppUpnString) throw()
{
   LARGE_INTEGER puid;

   if (!convertSid2Puid(name, puid))
   {
      // Not a passport SID. nothing to do, return NO_ERROR.
      return NO_ERROR;
   }

   DWORD errorCode = NO_ERROR;
   // The munged Passport SID is stored in altSecurityIdentities.
   newFormatOffered = static_cast<DS_NAME_FORMAT>(
                         DS_USER_PRINCIPAL_NAME_AND_ALTSECID
                         );
   wchar_t* dnsDomain = 0;

   // 16 = hex string representation of PUID
   // 1 for "@" and 1 for '\0'
   // example of string: 012345670abcdef1@mydomain.com
   DWORD upnStringCch = 16 + 1 + 1;
   if (upnSuffix == 0)
   {
      // No suffix, use the dns domain name
      DWORD domainSize = 0;
      IASGetDnsDomainName(0, &domainSize);
      // update the size
      upnStringCch += domainSize;
      dnsDomain = new (std::nothrow) wchar_t [domainSize + 1];
      // no need to check the result: the IASGetDnsDomainName will return
      // ERROR_INSUFFICIENT_BUFFER if the pointer is null
      errorCode = IASGetDnsDomainName(dnsDomain, &domainSize);
      if (errorCode != NO_ERROR)
      {
         // delete[] will work fine even if dnsDomain is NULL
         delete[] dnsDomain;
         return errorCode;
      }
   }
   else
   {
      // upn suffix was provided. Update the size
      upnStringCch += wcslen(upnSuffix);
   }

   // Allocate the string to store the full UPN
   *ppUpnString = new (std::nothrow) wchar_t [upnStringCch];
   if (*ppUpnString == 0)
   {
      errorCode = ERROR_INSUFFICIENT_BUFFER;
   }
   else
   {
      // This is a passport Sid: convert it
      errorCode = convertPuid2String(
                                 puid,
                                 *ppUpnString,
                                 upnStringCch,
                                 (upnSuffix!=0)? upnSuffix:dnsDomain
                              );
   }
   // dnsDomain is not used anymore
   delete[] dnsDomain;

   return errorCode;
}


//
//  Function:   convertSid2Puid
//
//  Synopsis:
//      passport generated sid to puid
//
//  Effects:
//
//  Arguments:
//      PSid        [in] sid to convert
//      PUID*       [out] corresponding puid
//
//  Returns:    invalid_param if not passport generated puid or null
//
//  Notes:
//      SID: S-1-10-D0-D1-...-Dn-X-R where
//          n == 0 for passport
//          D0[31:16] == 0
//          D0[15:0]  == PUID[63:48]
//          X[31:0]   == PUID[47:16]
//          R[31:16]  == PUID[15:0]
//          R[15:0]   == 0 (reserved)
//          R[10]     == 1 (so that R > 1024)
//
bool NameCracker::convertSid2Puid(PCWSTR sidString, LARGE_INTEGER& puid) throw()
{
   _ASSERT(sidString != 0);

   PSID pSid = 0;
   if (!ConvertStringSidToSidW(sidString, &pSid))
   {
      return false;
   }

   bool isPuid;
   // Check that this is a Passport SID
   SID_IDENTIFIER_AUTHORITY PassportIA = SECURITY_PASSPORT_AUTHORITY;
   if (memcmp(GetSidIdentifierAuthority(pSid),
      &PassportIA,
      sizeof(SID_IDENTIFIER_AUTHORITY)) ||
      *GetSidSubAuthorityCount(pSid) != 3)
   {
      isPuid = false;
   }
   else
   {
      //  domain portion of the puid
      puid.HighPart = *GetSidSubAuthority(pSid, 0) << 16;
      puid.HighPart |= *GetSidSubAuthority(pSid, 1) >> 16;
      puid.LowPart = *GetSidSubAuthority(pSid, 1) << 16;
      puid.LowPart |= *GetSidSubAuthority(pSid, 2) >> 16;

      // No need to check the 1st and 3rd subauth for the bits that
      // are not part of the PUID
      isPuid = true;
   }

   LocalFree(pSid);
   return isPuid;
}

//
// converts a PUID into a string.
//
DWORD NameCracker::convertPuid2String(
                      const LARGE_INTEGER& puid,
                      wchar_t* upnString,
                      DWORD upnStringCch,
                      const wchar_t* suffix
                      ) throw()
{
   HRESULT hr = StringCchPrintfW(
                                    upnString,
                                    upnStringCch,
                                    L"%08X%08X@%s",
                                    puid.HighPart,
                                    puid.LowPart,
                                    suffix
                                 );

   if (FAILED(hr))
   {
      return HRESULT_CODE(hr);
   }
   else
   {
      return NO_ERROR;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\externalauthnames.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ExternalAuthNames.h
//
// SYNOPSIS
//
//    This file declares the class ExternalAuthNames.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EXTERNALAUTHNAMES_H_
#define EXTERNALAUTHNAMES_H_
#pragma once

#include "iastl.h"
#include "namemapper.h"


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ExternalAuthNames
//
// DESCRIPTION
//
//    Implements a request handler that converts the RADIUS User-Name
//    attribute to a fully qualified NT4 account name.
//
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE ExternalAuthNames :
   public NameMapper,
   public CComCoClass<ExternalAuthNames, &__uuidof(ExternalAuthNames)>
{
public:

   IAS_DECLARE_REGISTRY(ExternalAuthNames, 1, 0, IASTypeLibrary)

   ExternalAuthNames();

protected:
//////////
// IIasComponent.
//////////
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();
   
// using default destructor
private:
   IASTL::IASAttribute externalProvider;
};

#endif  // EXTERNALAUTHNAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\identityhelper.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    IdentityHelper.cpp
//
// SYNOPSIS
//
//    This file defines the class IdentityHelper.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "iaslsa.h"
#include "memory"
#include "samutil.h"
#include "identityhelper.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


bool IdentityHelper::initialized = false;


/////////
// Registry keys and values.
/////////
const WCHAR PARAMETERS_KEY[] =
   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy";

const WCHAR IDENTITY_ATTR_VALUE[] = L"User Identity Attribute";
const WCHAR DEFAULT_IDENTITY_VALUE[] = L"Default User Identity";
const WCHAR OVERRIDE_USERNAME_VALUE[] = L"Override User-Name";

HRESULT IdentityHelper::IASReadRegistryDword(
                                                HKEY& hKey, 
                                                PCWSTR valueName, 
                                                DWORD defaultValue, 
                                                DWORD* result
                                            )
{
   _ASSERT (result != 0);
   
   DWORD cbData = sizeof(DWORD);
   DWORD type;
   LONG status = RegQueryValueExW(
                                    hKey,
                                    valueName,
                                    NULL,
                                    &type,
                                    (LPBYTE)result,
                                    &cbData
                                 );

   if (status != ERROR_SUCCESS)
   {
      if (status != ERROR_FILE_NOT_FOUND)
      {
         IASTracePrintf("Cannot read value %S.  error %ld", 
                        valueName, 
                        status
                        );
         return HRESULT_FROM_WIN32(status);
      }
      else
      {
         // The attribute does not exist. Set the default
         IASTracePrintf("The registry value %S does not exist. Using default %ld", 
                        valueName, 
                        defaultValue
                        );
         *result = defaultValue;
         return S_OK;
      }
   }

   if (type != REG_DWORD || cbData != sizeof(DWORD))
   {
      IASTracePrintf("Cannot read value %S.  Wrong type %ld. Size = %ld", 
                     valueName, 
                     type,
                     cbData
                     );
      return E_INVALIDARG;
   }

   return S_OK;
}

//
// IdentityHelper::initialize
// CAUTION: calls to this API MUST be serialized.
// i.e. the handler's calling MapNAme::Initialize MUST complete a successful 
// init of each handler's before calling the Init of the next one.
//
HRESULT IdentityHelper::initialize() throw()
{
   if (initialized)
   {
      return S_OK;
   }

   // Open the Parameters registry key.
   HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
   LONG status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );
   if (status != ERROR_SUCCESS)
   {
      IASTracePrintf("Cannot open the reg key %S, error %ld", 
                     PARAMETERS_KEY, 
                     status
                     );
      return HRESULT_FROM_WIN32(status);
   }

   HRESULT hr = S_OK;
   do
   {
      // Query the Identity Attribute.
      hr = IASReadRegistryDword(
                                  hKey, 
                                  IDENTITY_ATTR_VALUE, 
                                  RADIUS_ATTRIBUTE_USER_NAME, 
                                  &identityAttr
                                );
      if (FAILED(hr))
      {
         break;
      }

      // Query the Override User-Name flag.
      hr = IASReadRegistryDword(
                                  hKey, 
                                  OVERRIDE_USERNAME_VALUE, 
                                  FALSE, 
                                  &overrideUsername
                                );
      if (FAILED(hr))
      {
         break;
      }

      DWORD type;

      // Query the length of the Default Identity.
      defaultLength = 0;
      status = RegQueryValueExW(
                   hKey,
                   DEFAULT_IDENTITY_VALUE,
                   NULL,
                   &type,
                   NULL,
                   &defaultLength
                   );
      if (status != ERROR_SUCCESS)
      {
         if (status != ERROR_FILE_NOT_FOUND)
         {
            IASTracePrintf("Cannot read value %S.  error %ld", 
                           DEFAULT_IDENTITY_VALUE, 
                           status
                           );
            hr = HRESULT_FROM_WIN32(status);
            break;
         }
         else
         {
            // Done.
            defaultIdentity = NULL;
            defaultLength = 0;
            break;
         }
      }

      if (type != REG_SZ)
      {
         IASTracePrintf("Cannot read value %S.  Wrong type %ld", 
                        DEFAULT_IDENTITY_VALUE, 
                        type
                        );
         hr = E_INVALIDARG;
         break;
      }

      if (defaultLength < sizeof(WCHAR))
      {
         IASTracePrintf("Cannot read value %S.  Wrong Size = %ld", 
                        DEFAULT_IDENTITY_VALUE, 
                        defaultLength
                        );
         hr = E_INVALIDARG;
         break;
      }

      // Allocate memory to hold the Default Identity.
      defaultIdentity = new (std::nothrow)
                        WCHAR[defaultLength / sizeof(WCHAR)];
      if (defaultIdentity == 0)
      {
         IASTraceString("Default Identity could not be retrieved due to"
                        "out of memory condition.");
         defaultLength = 0;
         hr = E_OUTOFMEMORY;
         break;
      }

      // Query the value of the Default Identity.
      status = RegQueryValueExW(
                     hKey,
                     DEFAULT_IDENTITY_VALUE,
                     NULL,
                     &type,
                     (LPBYTE)defaultIdentity,
                     &defaultLength
                     );
      if (status != ERROR_SUCCESS)
      {
         delete[] defaultIdentity;
         defaultIdentity = NULL;
         defaultLength = 0;
         hr = HRESULT_FROM_WIN32(status);
         IASTracePrintf("Failed to read the value %S. Error is %ld",
                        DEFAULT_IDENTITY_VALUE,
                        status);
         break;
      }
   }
   while(false);

   if (hKey != INVALID_HANDLE_VALUE)
   {
      RegCloseKey(hKey);
   }

   if (SUCCEEDED(hr))
   {
      IASTracePrintf("User identity attribute: %lu", identityAttr);
      IASTracePrintf("Override User-Name: %s",
                     overrideUsername ? "TRUE" : "FALSE");
      IASTracePrintf("Default user identity: %S",
                     (defaultIdentity ? defaultIdentity : L"<Guest>"));

      // Initialized completed
      initialized = true;
   }

   return hr;
}

IdentityHelper::IdentityHelper() throw()
      : identityAttr(1), defaultIdentity(NULL), defaultLength(0)
{
}


IdentityHelper::~IdentityHelper() throw()
{
   delete[] defaultIdentity;
}


bool IdentityHelper::getIdentity(IASRequest& request, 
                                 wchar_t* pIdentity, 
                                 size_t& identitySize)
{
   wchar_t* identity;
   IASAttribute attr;
   HRESULT hr;
   WCHAR name[DNLEN + UNLEN + 2];

   if ((identityAttr == RADIUS_ATTRIBUTE_USER_NAME) || (!overrideUsername))
   {
      // identity chosen for override is user-name
      // can be more than 1 RADIUS_ATTRIBUTE_USER_NAME attribute
      // Use the one from access accept.
      getRadiusUserName(request, attr);
   }

   if (!attr && (identityAttr != RADIUS_ATTRIBUTE_USER_NAME))
   {
      // identity chosen is not user-name
      // only one possible identity attribute
      attr.load(request, identityAttr, IASTYPE_OCTET_STRING);
   }

   // if an 'identity' was retrieved, convert it then return
   if (attr != NULL && attr->Value.OctetString.dwLength != 0)
   {
      // previous step was successful
      // Convert it to a UNICODE string.
      if (identitySize < IAS_OCT2WIDE_LEN(attr->Value.OctetString))
      {
         IASTraceString("IASOctetStringToWide failed");
         identitySize = IAS_OCT2WIDE_LEN(attr->Value.OctetString);
         return false;
      }

      IASOctetStringToWide(attr->Value.OctetString, pIdentity);

      // if that fails, then the string is empty ("")
      if (wcslen(pIdentity) == 0)
      {
         IASTraceString("IASOctetStringToWide failed");
         return false;
      }
      else
      {
         IASTracePrintf(
               "NT-SAM Names handler received request with user identity %S.",
               pIdentity
               );
         return true;
      }
   }
   else
   {
      // previous step was not successful (No identity attribute) 
      // use default identity or guest
      if (defaultIdentity)
      {
         // Use the default identity if set.
         identity = defaultIdentity;
      }
      else
      {
         // Otherwise use the guest account for the default domain.
         IASGetGuestAccountName(name);
         identity = name;
      }

      IASTracePrintf(
            "NT-SAM Names handler using default user identity %S.",
            identity
            );
   }

   IASTracePrintf("identity is \"%S\"", identity);
   
   hr = StringCbCopyW(pIdentity, identitySize, identity);
   if (FAILED(hr))
   {
      identitySize = (wcslen(identity) + 1) * sizeof(wchar_t) ;
      return false;
   }
   return true;
}


//
// set attr to the RADIUS_ATTRIBUTE_USER_NAME found if any
// if 2 are present, take the one returned by the backend server.
// 
//
void IdentityHelper::getRadiusUserName(IASRequest& request, IASAttribute &attr)
{
   IASAttributeVectorWithBuffer<2> vector;
   DWORD Error = vector.load(request, RADIUS_ATTRIBUTE_USER_NAME);
   switch (vector.size())
   {
   case 0:
      // no attribute found
      break;
   case 1:
      // only one attribute: use it
      attr = vector.front().pAttribute;
      break;
   case 2:
      attr = vector.front().pAttribute;
      // IAS_RECVD_FROM_CLIENT is set when the proxy receives the attribute
      // in the access request or accounting request
      if(attr.testFlag(IAS_RECVD_FROM_CLIENT))
      {
         // if the 1st attribute was received from the client (i.e. was in the
         // REQUEST, then use the other one, the other should come from the 
         // back-end server
         attr = vector.back().pAttribute;
         if (attr.testFlag(IAS_RECVD_FROM_CLIENT))
         {
            IASTraceString("ERROR 2 RADIUS_ATTRIBUTE_USER_NAME found in the"
                           "request but both came from the client");
            _com_issue_error(IAS_PROXY_MALFORMED_RESPONSE);
         }
      }
      break;

   default:
      _com_issue_error(IAS_PROXY_MALFORMED_RESPONSE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\namemapper.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    namemapper.cpp
//
// SYNOPSIS
//
//    This file defines the class NameMapper.
//
///////////////////////////////////////////////////////////////////////////////
#include "ias.h"
#include "iaslsa.h"
#include "samutil.h"
#include "namemapper.h"
#include "cracker.h"
#include "identityhelper.h"
#include "iastlutl.h"
#include "ntdsapip.h"

NameCracker NameMapper::cracker;
IdentityHelper NameMapper::identityHelper;


STDMETHODIMP NameMapper::Initialize() const throw()
{
   DWORD error = IASLsaInitialize();
   if (error) { return HRESULT_FROM_WIN32(error); }

   return identityHelper.initialize();
}


STDMETHODIMP NameMapper::Shutdown() const throw()
{
   IASLsaUninitialize();
   return S_OK;
}


IASREQUESTSTATUS NameMapper::onSyncRequest(IRequest* pRequest) throw ()
{
   // This is  function scope, so it can be freed in the catch block.
   PDS_NAME_RESULTW result = NULL;
   wchar_t identity[254];
   wchar_t* pIdentity = identity;
   HRESULT hr = S_OK;

   try
   {
      size_t identitySize = sizeof(identity);
      IASRequest request(pRequest);
      bool identityRetrieved = identityHelper.getIdentity(request,
                                                          pIdentity,
                                                          identitySize);

      if (!identityRetrieved)
      {
         // allocate a big enough buffer and use it
         pIdentity = new wchar_t[identitySize];
         identityRetrieved = identityHelper.getIdentity(request,
                                                        pIdentity,
                                                        identitySize);
         if (!identityRetrieved)
         {
            IASTraceString("Error: no user identity found");
            _com_issue_error(IAS_PROXY_MALFORMED_RESPONSE);
         }
      }

      // Allocate an attribute to hold the NT4 Account Name.
      IASAttribute nt4Name(true);
      nt4Name->dwId = IAS_ATTRIBUTE_NT4_ACCOUNT_NAME;

      DS_NAME_FORMAT formatOffered = DS_UNKNOWN_NAME;

      // If it already contains a backslash
      // then use as is.
      PWCHAR delim = wcschr(identity, L'\\');
      if (delim)
      {
         if (IASGetRole() == IAS_ROLE_STANDALONE ||
            IASGetProductType() == IAS_PRODUCT_WORKSTATION)
         {
            // Strip out the domain.
            *delim = L'\0';

            // Make sure this is a local user.
            if (!IASIsDomainLocal(identity))
            {
               IASTraceString("Non-local users are not allowed -- rejecting.");
               _com_issue_error(IAS_LOCAL_USERS_ONLY);
            }

            // Restore the delimiter.
            *delim = L'\\';
         }

         IASTraceString("Username is already an NT4 account name.");

         nt4Name.setString(identity);
      }
      else if (isCrackable(identity, formatOffered) &&
               (IASGetRole() != IAS_ROLE_STANDALONE))
      {
         // identity seems to be crackable and IAS is not a standalone machine.
         // (either a domain member or a domain controller)
         mapName(identity, nt4Name, formatOffered, 0);
      }
      else
      {
         // Assume no domain was specified and use the default domain
         IASTraceString("Prepending default domain.");
         nt4Name->Value.String.pszWide = prependDefaultDomain(identity);
         nt4Name->Value.String.pszAnsi = NULL;
         nt4Name->Value.itType = IASTYPE_STRING;
      }

      // Convert the domain name to uppercase.
      delim = wcschr(nt4Name->Value.String.pszWide, L'\\');
      *delim = L'\0';
      _wcsupr(nt4Name->Value.String.pszWide);
      *delim = L'\\';

      nt4Name.store(request);

      // For now, we'll use this as the FQDN as well.
      IASStoreFQUserName(
          request,
          DS_NT4_ACCOUNT_NAME,
          nt4Name->Value.String.pszWide
          );

      IASTracePrintf("SAM-Account-Name is \"%S\".",
                     nt4Name->Value.String.pszWide);
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      hr = ce.Error();
   }

   if (pIdentity != identity)
   {
      delete[] pIdentity;
   }

   if (result)
   {
      cracker.freeNameResult(result);
   }

   if ( FAILED(hr) || ((hr != S_OK) && (hr < 0x0000ffff)) )
   {
      // IAS reason code: the reason code will be used
      // or error code: will map to internal error
      return IASProcessFailure(pRequest, hr);
   }
   else
   {
      // S_OK
      return IAS_REQUEST_STATUS_HANDLED;
   }
}


PWSTR NameMapper::prependDefaultDomain(PCWSTR username)
{
   IASTraceString("NameMapper::prependDefaultDomain");

   _ASSERT(username != NULL);

   // Figure out how long everything is.
   PCWSTR domain = IASGetDefaultDomain();
   ULONG domainLen = wcslen(domain);
   ULONG usernameLen = wcslen(username) + 1;

   // Allocate the needed memory.
   ULONG needed = domainLen + usernameLen + 1;
   PWSTR retval = (PWSTR)CoTaskMemAlloc(needed * sizeof(WCHAR));
   if (!retval) { _com_issue_error(E_OUTOFMEMORY); }

   // Set up the cursor used for packing the strings.
   PWSTR dst = retval;

   // Copy in the domain name.
   memcpy(dst, domain, domainLen * sizeof(WCHAR));
   dst += domainLen;

   // Add the delimiter.
   *dst++ = L'\\';

   // Copy in the username.
   // Note: usernameLen includes the null-terminator.
   memcpy(dst, username, usernameLen * sizeof(WCHAR));

   return retval;
}


//////////
// Determines whether an identity can be cracked through DsCrackNames and which
// name format should be offered if it is crackable.
//////////
bool NameMapper::isCrackable(
                    const wchar_t* szIdentity,
                    DS_NAME_FORMAT& format
                    ) const throw ()
{
   format = DS_UNKNOWN_NAME;

   if (wcschr(szIdentity, L'@') != 0)
   {
      if (allowAltSecId)
      {
         format = static_cast<DS_NAME_FORMAT>(
                     DS_USER_PRINCIPAL_NAME_AND_ALTSECID
                     );
      }

      return true;
   }

   return (wcschr(szIdentity, L'=') != 0) ||  // DS_FQDN_1779_NAME
          (wcschr(szIdentity, L'/') != 0);    // DS_CANONICAL_NAME
}



void NameMapper::mapName(
                              const wchar_t* identity,
                              IASAttribute& nt4Name,
                              DS_NAME_FORMAT formatOffered,
                              const wchar_t* suffix
                           )
{
   _ASSERT(identity != NULL);
   _ASSERT(nt4Name != NULL);
   _ASSERT(*nt4Name != NULL);

   PDS_NAME_RESULTW result = NULL;

   HRESULT hr = S_OK;

   do
   {
      // call cracker
      DWORD dwErr = cracker.crackNames(
                                 DS_NAME_FLAG_EVAL_AT_DC,
                                 formatOffered,
                                 DS_NT4_ACCOUNT_NAME,
                                 identity,
                                 suffix,
                                 &result
                                 );

      if (dwErr != NO_ERROR)
      {
         IASTraceFailure("DsCrackNames", dwErr);
         hr = IAS_GLOBAL_CATALOG_UNAVAILABLE;
         break;
      }

      if (result->rItems->status == DS_NAME_NO_ERROR)
      {
         IASTraceString("Successfully cracked username.");

         // DsCrackNames returned an NT4 Account Name, so use it.
         nt4Name.setString(result->rItems->pName);
      }
      else
      {
         // GC could not crack the name
         if (formatOffered != DS_SID_OR_SID_HISTORY_NAME)
         {
            // Not using SID: try to append the default domain to the identity
            IASTraceString("Global Catalog could not crack username; "
                           "prepending default domain.");
            // If it can't be cracked we'll assume that it's a flat
            // username with some weird characters.
            nt4Name->Value.String.pszWide = prependDefaultDomain(identity);
            nt4Name->Value.String.pszAnsi = NULL;
            nt4Name->Value.itType = IASTYPE_STRING;

         }
         else
         {
            // using SID. nothing else can be done.
            IASTracePrintf("Global Catalog could not crack username. Error %x",
                           result->rItems->status);
            hr = IAS_NO_SUCH_USER;
         }
      }
   }
   while(false);

   cracker.freeNameResult(result);

   if ( FAILED(hr) || ((hr != S_OK) && (hr < 0x0000ffff)))
   {
      _com_issue_error(hr);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\ntsamnames.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTSamNames.cpp
//
// SYNOPSIS
//
//    This file defines the class NTSamNames.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "ntsamnames.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\namemapper.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    namemapper.h
//
// SYNOPSIS
//
//    This file declares the class NameMapper.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef NAMEMAPPER_H_
#define NAMEMAPPER_H_
#pragma once

#include "iastl.h"
#include "iastlutl.h"
#include <ntdsapi.h>

class NameCracker;
class IdentityHelper;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NameMapper
//
// DESCRIPTION
//
//    Implements a request handler that converts the RADIUS User-Name
//    attribute to a fully qualified NT4 account name.
//
//
///////////////////////////////////////////////////////////////////////////////
class NameMapper :
   public IASTL::IASRequestHandlerSync
{
public:
   NameMapper(bool iniAllowAltSecId = false) throw ();

//////////
// IIasComponent.
//////////
   STDMETHOD(Initialize)() const throw();
   STDMETHOD(Shutdown)() const throw();

protected:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   // Prepends the default domain to username.
   PWSTR prependDefaultDomain(PCWSTR username);

   bool isCrackable(
           const wchar_t* szIdentity,
           DS_NAME_FORMAT& format
           ) const throw ();

   void mapName(
           const wchar_t* identity,
           IASTL::IASAttribute& nt4Name,
           DS_NAME_FORMAT formatOffered,
           const wchar_t* suffix
           );

   static NameCracker cracker;
   static IdentityHelper identityHelper;

private:
   // Indicates whether altSecurityIdentities are allowed. We only allow
   // altSecurityIdentities for users that are authenticated by a remote RADIUS
   // server.
   bool allowAltSecId;
};


inline NameMapper::NameMapper(bool iniAllowAltSecId) throw ()
   : allowAltSecId(iniAllowAltSecId)
{
}

#endif  // NAMEMAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\externalauthnames.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ExternalAuthNames.cpp
//
// SYNOPSIS
//
//    This file defines the class ExternalAuthNames.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "externalauthnames.h"
#include "samutil.h"
#include "iastlutl.h"
#include <Sddl.h>

ExternalAuthNames::ExternalAuthNames()
   : NameMapper(true), 
     externalProvider(true)
{
   externalProvider->dwId = IAS_ATTRIBUTE_PROVIDER_TYPE;
   externalProvider->Value.itType = IASTYPE_ENUM;
   externalProvider->Value.Enumerator = IAS_PROVIDER_EXTERNAL_AUTH;
}


IASREQUESTSTATUS ExternalAuthNames::onSyncRequest(IRequest* pRequest) throw ()
{
   HRESULT hr = S_OK;
   wchar_t* stringSid = NULL;

   try
   {
      IASRequest request(pRequest);
      IASAttribute attr;
      if (!attr.load(
                     request,
                     IAS_ATTRIBUTE_REMOTE_RADIUS_TO_WINDOWS_USER_MAPPING,
                     IASTYPE_BOOLEAN
                     ) ||
           ( attr->Value.Boolean == VARIANT_FALSE) )
      {
         // Nothing to do
         return IAS_REQUEST_STATUS_HANDLED;
      }

      // set the new provider type
      DWORD providerID = IAS_ATTRIBUTE_PROVIDER_TYPE;
      request.RemoveAttributesByType(1, &providerID);
      externalProvider.store(request);

      // load will throw if more than one attribute is present
      // this is what we want
      if (!attr.load(
                     request,
                     MS_ATTRIBUTE_USER_SECURITY_IDENTITY,
                     IASTYPE_OCTET_STRING
                   ))
      {
         // no UPN: normal name mapping (will use UserName...)
         return NameMapper::onSyncRequest(pRequest);
      }

      if (!ConvertSidToStringSidW(
                                    (PSID)attr->Value.OctetString.lpValue,
                                    &stringSid)
                                 )
      {
         IASTracePrintf("Error ConvertSidToStringSid failed %x",
                        GetLastError());
         _com_issue_error(IAS_NO_SUCH_USER);
      }

      // get the suffix if any.
      IASAttribute upnSuffix;
      upnSuffix.load(
                        request,
                        IAS_ATTRIBUTE_PASSPORT_USER_MAPPING_UPN_SUFFIX,
                        IASTYPE_STRING
                    );

      // get the SID cracked and the result inserted into the request
      IASAttribute nt4Name(true);
      nt4Name->dwId = IAS_ATTRIBUTE_NT4_ACCOUNT_NAME;

      IASTracePrintf("SID received %s", stringSid);

      mapName(
                 stringSid,
                 nt4Name,
                 DS_SID_OR_SID_HISTORY_NAME,
                 upnSuffix? upnSuffix->Value.String.pszWide : NULL
              );

      if(nt4Name->Value.String.pszWide != NULL)
      {
         // Convert the domain name to uppercase.
         PWCHAR delim = wcschr(nt4Name->Value.String.pszWide, L'\\');
         *delim = L'\0';
         _wcsupr(nt4Name->Value.String.pszWide);
         *delim = L'\\';
      }

      nt4Name.store(request);

      // For now, we'll use this as the FQDN as well.
      IASStoreFQUserName(
            request,
            DS_NT4_ACCOUNT_NAME,
            nt4Name->Value.String.pszWide
            );

      IASTracePrintf("SAM-Account-Name is \"%S\".",
                     nt4Name->Value.String.pszWide);

      // Remove MS-User-Security-Identity attribute.
      DWORD securityAttrType = MS_ATTRIBUTE_USER_SECURITY_IDENTITY;
      request.RemoveAttributesByType(1, &securityAttrType);
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      hr = ce.Error();

      if (hr == 0x80070234)
      {
         // HRESULT_FROM_WIN32(ERROR_MORE_DATA)
         hr = IAS_PROXY_MALFORMED_RESPONSE;
      }
   }

   if (stringSid != 0)
   {
      LocalFree(stringSid);
   }

   if ( FAILED(hr) || ((hr != S_OK) && (hr < 0x0000ffff)) )
   {
      return IASProcessFailure(pRequest, hr);
   }
   else
   {
      return IAS_REQUEST_STATUS_HANDLED;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\identityhelper.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    IdentityHelper.h
//
// SYNOPSIS
//
//    This file declares the class IdentityHelper.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IDENTITYHELPER_H_
#define IDENTITYHELPER_H_
#pragma once

#include "iastlutl.h"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IdentityHelper
//
// DESCRIPTION
//
//    Implements a request handler that converts the RADIUS User-Name
//    attribute to a fully qualified NT4 account name.
//
//
///////////////////////////////////////////////////////////////////////////////
class IdentityHelper
{
public:

   IdentityHelper() throw();
   ~IdentityHelper() throw();

   HRESULT initialize() throw();

   bool getIdentity(IASRequest& request, 
                    wchar_t* pIdentity, 
                    size_t& identitySize);
protected:
   HRESULT IASReadRegistryDword(
                                  HKEY& hKey, 
                                  PCWSTR valueName, 
                                  DWORD defaultValue, 
                                  DWORD* result
                               );


private:
   void getRadiusUserName(IASRequest& request, IASAttribute &attr);

   DWORD overrideUsername; // TRUE if we should override the User-Name.
   DWORD identityAttr;     // Attribute used to identify the user.
   PWSTR defaultIdentity;  // Default user identity.
   DWORD defaultLength;    // Length (in bytes) of the default user identity.
   
   static bool initialized;

};

#endif  // IDENTITYHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\names\ntsamnames.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTSamNames.h
//
// SYNOPSIS
//
//    This file declares the class NTSamNames.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTSAMNAMES_H_
#define _NTSAMNAMES_H_
#pragma once

#include "namemapper.h"


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTSamNames
//
// DESCRIPTION
//
//    Implements a request handler that converts the RADIUS User-Name
//    attribute to a fully qualified NT4 account name.
//
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NTSamNames :
   public NameMapper,
   public CComCoClass<NTSamNames, &__uuidof(NTSamNames)>
{
public:

IAS_DECLARE_REGISTRY(NTSamNames, 1, 0, IASTypeLibrary)

};

#endif  // _NTSAMNAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ldapdnary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ldapdnary.h
//
// SYNOPSIS
//
//    This file declares the class LDAPDictionary.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    04/20/1998    Added flags and InjectorProc to the attribute schema.
//    05/01/1998    Changed signature of InjectorProc.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _LDAPDNARY_H_
#define _LDAPDNARY_H_

#include <iaspolcy.h>
#include <winldap.h>

//////////
// Prototype for an injector procedure. These are procedures for inserting
// attributes into a request.
//////////
typedef VOID (WINAPI *InjectorProc)(
    IAttributesRaw* dst,
    PATTRIBUTEPOSITION first,
    PATTRIBUTEPOSITION last
    );

//////////
// Struct that defines an LDAP/IAS attribute.
//////////
struct LDAPAttribute
{
   PCWSTR ldapName;        // The LDAP name of the attribute.
   DWORD iasID;            // The IAS attribute ID.
   IASTYPE iasType;        // The IAS syntax of the attribute.
   DWORD flags;            // Flags that should be applied to the attribute.
   InjectorProc injector;  // Used for adding the attribute to the request.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LDAPDictionary
//
// DESCRIPTION
//
//    This class uses a sorted array of LDAPAttribute's to convert LDAP
//    attribute/value pairs into IASATTRIBUTE structs.
//
///////////////////////////////////////////////////////////////////////////////
class LDAPDictionary
{
public:
   // 'entries' must already be sorted.
   LDAPDictionary(
       size_t numEntries,
       const LDAPAttribute* entries
       ) throw ()
      : num(numEntries), base(entries)
   { }

   // Finds the definition for a given attribute. Returns NULL if not found.
   const LDAPAttribute* find(PCWSTR key) const throw ()
   {
      return (const LDAPAttribute*)
             bsearch(&key, base, num, sizeof(LDAPAttribute), compare);
   }

   // Inserts all the attributes from src into dst.
   void insert(
            IAttributesRaw* dst,
            LDAPMessage* src
            ) const;

protected:
   const size_t num;                 // Number of attributes in dictionary.
   const LDAPAttribute* const base;  // Sorted array of attributes.

   // Comparison function used for searching the dictionary.
   static int __cdecl compare(const void *elem1, const void *elem2);
};

#endif  // _LDAPDNARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\netuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netuser.h
//
// SYNOPSIS
//
//    This file declares the class NetUser.
//
// MODIFICATION HISTORY
//
//    02/26/1998    Original version.
//    03/20/1998    Add support for RAS attributes.
//    04/02/1998    Added callbackFramed member.
//    04/24/1998    Add useRasForLocal flag.
//    04/30/1998    Converted to IASSyncHandler.
//    05/01/1998    Removed obsolete addAttribute method.
//    05/19/1998    Converted to NtSamHandler.
//    10/19/1998    Remove datastore dependencies.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETUSER_H_
#define _NETUSER_H_

#include <samutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NetUser
//
// DESCRIPTION
//
//    This class retrieves per-user attributes from the Networking data store.
//
///////////////////////////////////////////////////////////////////////////////
class NetUser
   : public NtSamHandler
{
public:
   virtual IASREQUESTSTATUS processUser(
                                IASRequest& request,
                                PCWSTR domainName,
                                PCWSTR username
                                );
};

#endif  // _NETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ldapdnary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ldapdnary.cpp
//
// SYNOPSIS
//
//    This file defines the class LDAPDictionary.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    04/20/1998    Added flags and InjectorProc to the attribute schema.
//    05/01/1998    InjectorProc takes an ATTRIBUTEPOSITION array.
//    03/23/1999    Store user's DN.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>

#include <attrcvt.h>
#include <autohdl.h>
#include <ldapdnary.h>
#include <samutil.h>
#include "ldapcxn.h"

//////////
// Smart wrapper around an array of LDAP berval's.
//////////
typedef auto_handle< berval**,
                     ULONG (LDAPAPI*)(struct berval**),
                     &ldap_value_free_len
                   > LDAPValues;

//////////
// Create an attribute from a berval based on the schema info in 'def'.
//////////
inline PIASATTRIBUTE createAttribute(
                         const LDAPAttribute& def,
                         const berval& val
                         )
{
   // Convert the value.
   PIASATTRIBUTE attr = IASAttributeFromBerVal(val, def.iasType);

   // Set the rest of the fields.
   attr->dwId    = def.iasID;
   attr->dwFlags = def.flags;

   return attr;
}

void LDAPDictionary::insert(
                         IAttributesRaw* dst,
                         LDAPMessage* src
                         ) const
{
   // Retrieve the connection for this message.
   LDAP* ld = ldap_conn_from_msg(NULL, src);

   // Used to hold converted attributes. This is defined outside the loop
   // to avoid unnecessary constructor/destructor calls.
   IASTL::IASAttributeVectorWithBuffer<8> attrs;

   // There's only one entry in the message.
   LDAPMessage* e  = ldap_first_entry(ld, src);

   // Store the user's DN.
   PWCHAR dn = ldap_get_dnW(ld, e);
   IASStoreFQUserName(dst, DS_FQDN_1779_NAME, dn);
   ldap_memfree(dn);

   // Iterate through all the attributes in the entry.
   BerElement* ptr;
   for (wchar_t* a  = ldap_first_attributeW(ld, e, &ptr);
                 a != NULL;
                 a  = ldap_next_attributeW(ld, e, ptr))
   {
      // Lookup the schema information.
      const LDAPAttribute* def = find(a);

      // If it doesn't exist, we must not be interested in this attribute.
      if (def == NULL) { continue; }

      IASTracePrintf("Inserting attribute %S.", a);

      // Retrieve the values.
      LDAPValues vals(ldap_get_values_lenW(ld, e, a));
      if (static_cast<struct berval**>(vals) == 0)
      {
         ULONG error = LdapGetLastError();
         ULONG winError = LdapMapErrorToWin32(error);
         if (winError != NO_ERROR)
         {
            IASTraceLdapFailure("ldap_get_values_lenW", error, ld);
            IASTL::issue_error(HRESULT_FROM_WIN32(winError));
         }
         else
         {
            // Most likely cause
            IASTL::issue_error(E_OUTOFMEMORY);
         }
      }

      // Make sure we have enough room. We don't want to throw an
      // exception in 'push_back' since it would cause a leak.
      attrs.reserve(ldap_count_values_len(vals));

      // Iterate through the values.
      for (size_t i = 0; vals.get()[i]; ++i)
      {
         // Add to the array of attributes without addref'ing.
         attrs.push_back(
                  createAttribute(*def, *(vals.get()[i])),
                  false
                  );
      }

      // Inject into the request.
      def->injector(dst, attrs.begin(), attrs.end());

      // Clear out the vector so we can reuse it.
      attrs.clear();
   }
}

//////////
// Comparison function used by bsearch to lookup definitions.
//////////
int __cdecl LDAPDictionary::compare(const void *elem1, const void *elem2)
{
   return wcscmp(((LDAPAttribute*)elem1)->ldapName,
                 ((LDAPAttribute*)elem2)->ldapName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ntsamperuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ntsamperuser.h
//
// SYNOPSIS
//
//    This file declares the class NTSamPerUser.
//
// MODIFICATION HISTORY
//
//    05/19/1998    Original version.
//    01/19/1999    Process Access-Challenge's.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTSAMPERUSER_H_
#define _NTSAMPERUSER_H_

#include <iastl.h>

#include <netuser.h>
#include <ntdsuser.h>
#include <rasuser.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTSamPerUser
//
// DESCRIPTION
//
//    This class implements a Request Handler for retrieving per-user
//    attributes for NT-SAM users.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NTSamPerUser
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<NTSamPerUser, &__uuidof(NTSamPerUser)>
{
public:

IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_NTSAM_PERUSER)
IAS_DECLARE_REGISTRY(NTSamPerUser, 1, 0, IASTypeLibrary)

BEGIN_IAS_RESPONSE_MAP()
   IAS_RESPONSE_ENTRY(IAS_RESPONSE_INVALID)
   IAS_RESPONSE_ENTRY(IAS_RESPONSE_ACCESS_ACCEPT)
   IAS_RESPONSE_ENTRY(IAS_RESPONSE_ACCESS_CHALLENGE)
END_IAS_RESPONSE_MAP()

//////////
// IIasComponent
//////////
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();

protected:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   NetUser  netp;
   NTDSUser ntds;
   RasUser  ras;
};

#endif  // _NTSAMPERUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ntdsuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ntdsuser.h
//
// SYNOPSIS
//
//    This file declares the class NTDSUser.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    04/16/1998    Added Initialize/Shutdown.
//    04/30/1998    Disable handler when NTDS unavailable.
//    05/04/1998    Implement Suspend/Resume.
//    05/19/1998    Converted to NtSamHandler.
//    06/03/1998    Always use LDAP against native-mode domains.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTDSUSER_H_
#define _NTDSUSER_H_

#include <samutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTDSUser
//
// DESCRIPTION
//
//    This class implements a Request Handler for retrieving per-user
//    attributes from NTDS.
//
///////////////////////////////////////////////////////////////////////////////
class NTDSUser
   : public NtSamHandler
{
public:

   virtual HRESULT initialize() throw ();
   virtual void finalize() throw ();

   virtual IASREQUESTSTATUS processUser(
                                IASRequest& request,
                                PCWSTR domainName,
                                PCWSTR username
                                );
};

#endif  // _NTDSUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ntdsuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class NTDSUser.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iaslsa.h>
#include <iasntds.h>

#include <ldapdnary.h>
#include <userschema.h>

#include <ntdsuser.h>

//////////
// Attributes that should be retrieved for each user.
//////////
const PCWSTR PER_USER_ATTRS[] =
{
   L"msNPAllowDialin",
   L"msNPCallingStationID",
   L"msRADIUSCallbackNumber",
   L"msRADIUSFramedIPAddress",
   L"msRADIUSFramedRoute",
   L"msRADIUSServiceType",
   NULL
};

//////////
// Dictionary used for converting returned attributes.
//////////
const LDAPDictionary theDictionary(USER_SCHEMA_ELEMENTS, USER_SCHEMA);

HRESULT NTDSUser::initialize() throw ()
{
   DWORD error = IASNtdsInitialize();

   return HRESULT_FROM_WIN32(error);
}

void NTDSUser::finalize() throw ()
{
   IASNtdsUninitialize();
}

IASREQUESTSTATUS NTDSUser::processUser(
                               IASRequest& request,
                               PCWSTR domainName,
                               PCWSTR username
                               )
{
   // We only handle native-mode domains.
   if (!IASNtdsIsNativeModeDomain(domainName))
   {
      return IAS_REQUEST_STATUS_INVALID;
   }

   IASTraceString("Using native-mode dial-in parameters.");

   //////////
   // Query the DS.
   //////////

   DWORD error;
   IASNtdsResult result;
   error = IASNtdsQueryUserAttributes(
               domainName,
               username,
               LDAP_SCOPE_SUBTREE,
               const_cast<PWCHAR*>(PER_USER_ATTRS),
               &result
               );
   if (error == NO_ERROR)
   {
      // We got something back, so insert the attributes.
      theDictionary.insert(request, result.msg);

      IASTraceString("Successfully retrieved per-user attributes.");

      return IAS_REQUEST_STATUS_HANDLED;
   }

   // We have a DS for this user, but we can't talk to it.
   error = IASMapWin32Error(error, IAS_DOMAIN_UNAVAILABLE);
   return IASProcessFailure(request, error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\ntsamperuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    peruser.cpp
//
// SYNOPSIS
//
//    Defines the class NTSamPerUser.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iaslsa.h>

#include <samutil.h>
#include <sdoias.h>

#include <ntsamperuser.h>

STDMETHODIMP NTSamPerUser::Initialize()
{
   DWORD error = IASLsaInitialize();
   if (error != NO_ERROR) { return HRESULT_FROM_WIN32(error); }

   HRESULT hr;

   hr = netp.initialize();
   if (FAILED(hr)) { goto netp_failed; }

   hr = ntds.initialize();
   if (FAILED(hr)) { goto ntds_failed; }

   hr = ras.initialize();
   if (FAILED(hr)) { goto ras_failed; }

   return S_OK;

ras_failed:
   ntds.finalize();

ntds_failed:
   netp.finalize();

netp_failed:
   IASLsaUninitialize();

   return hr;

}

STDMETHODIMP NTSamPerUser::Shutdown()
{
   ras.finalize();
   ntds.finalize();
   netp.finalize();
   IASLsaUninitialize();
   return S_OK;
}

IASREQUESTSTATUS NTSamPerUser::onSyncRequest(IRequest* pRequest) throw ()
{
   IASREQUESTSTATUS status;

   try
   {
      IASRequest request(pRequest);

      //////////
      // Should we process the request?
      //////////

      IASAttribute ignoreDialin;
      if (ignoreDialin.load(
                          request,
                          IAS_ATTRIBUTE_IGNORE_USER_DIALIN_PROPERTIES,
                          IASTYPE_BOOLEAN
                          ) &&
          ignoreDialin->Value.Boolean)
      {
         return IAS_REQUEST_STATUS_CONTINUE;
      }

      //////////
      // Extract the NT4-Account-Name attribute.
      //////////

      IASAttribute identity;
      if (!identity.load(request,
                         IAS_ATTRIBUTE_NT4_ACCOUNT_NAME,
                         IASTYPE_STRING))
      { return IAS_REQUEST_STATUS_CONTINUE; }

      //////////
      // Convert the User-Name to SAM format.
      //////////

      SamExtractor extractor(*identity);
      PCWSTR domain = extractor.getDomain();
      PCWSTR username = extractor.getUsername();

      IASTracePrintf("NT-SAM User Authorization handler received request "
                     "for %S\\%S.", domain, username);

      //////////
      // Try each handler in order.
      //////////

      status = netp.processUser(request, domain, username);
      if (status != IAS_REQUEST_STATUS_INVALID) { goto done; }

      status = ntds.processUser(request, domain, username);
      if (status != IAS_REQUEST_STATUS_INVALID) { goto done; }

      status = ras.processUser(request, domain, username);
      if (status != IAS_REQUEST_STATUS_INVALID) { goto done; }

      //////////
      // Default is to just continue down the pipeline. Theoretically, we
      // should never get here.
      //////////

      status = IAS_REQUEST_STATUS_CONTINUE;
   }
   catch (const _com_error& ce)
   {
      IASTraceExcept();
      status = IASProcessFailure(pRequest, ce.Error());
   }

done:
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\netuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netuser.cpp
//
// SYNOPSIS
//
//    This file declares the class NetUser.
//
// MODIFICATION HISTORY
//
//    02/26/1998    Original version.
//    03/20/1998    Add support for RAS attributes.
//    03/31/1998    The denyAccess attribute wasn't being initialized properly.
//    04/02/1998    Include Service-Type attribute for callback.
//    04/24/1998    Use RAS API for local users when running under
//                  Workstation or NT4.
//    04/30/1998    Convert to IASSyncHandler.
//                  Reject unknown users.
//    05/01/1998    InjectProc takes an ATTRIBUTEPOSITION array.
//    05/19/1998    Converted to NtSamHandler.
//    06/19/1998    Use injector functions for adding per-user attributes.
//    07/20/1998    Multi-valued attributes were using duplicate loop variable.
//    10/19/1998    Use IASParmsXXX API instead of Datastore2.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <attrcvt.h>
#include <autohdl.h>
#include <varvec.h>

#define IASSAMAPI

#include <iaslsa.h>
#include <iasparms.h>

#include <userschema.h>
#include <netuser.h>

//////////
// Create an attribute from a VARIANT based on the schema info in 'def'.
//////////
PIASATTRIBUTE createAttribute(
                  const LDAPAttribute& def,
                  VARIANT& value
                  )
{
   // Convert the value.
   PIASATTRIBUTE attr = IASAttributeFromVariant(&value, def.iasType);

   // Set the attribute ID ...
   attr->dwId = def.iasID;

   // Set the flags.
   attr->dwFlags = def.flags;

   return attr;
}

IASREQUESTSTATUS NetUser::processUser(
                              IASRequest& request,
                              PCWSTR domainName,
                              PCWSTR username
                              )
{
   //////////
   // Only handle non-domain users.
   //////////

   if (IASGetRole() == IAS_ROLE_DC || !IASIsDomainLocal(domainName))
   {
      return IAS_REQUEST_STATUS_INVALID;
   }

   IASTraceString("Using NT5 local user parameters.");

   //////////
   // Retrieve the UserParameters for this user.
   //////////

   auto_handle< PWSTR, HLOCAL (WINAPI*)(HLOCAL), &LocalFree > userParms;
   DWORD error = IASGetUserParameters(
                     username,
                     domainName,
                     &userParms
                     );
   if (error != NO_ERROR)
   {
      IASTraceFailure("IASGetUserParameters", error);

      return IASProcessFailure(
                 request,
                 IASMapWin32Error(
                     error,
                     IAS_SERVER_UNAVAILABLE
                     )
                 );
   }

   // Used for converting attributes. These are defined outside the loop to
   // avoid unnecessary constructor/destructor calls.
   IASAttributeVectorWithBuffer<8> attrs;
   _variant_t value;

   //////////
   // Iterate through the per-user attributes.
   //////////

   for (size_t i = 0; i < USER_SCHEMA_ELEMENTS; ++i)
   {
      HRESULT hr = IASParmsQueryUserProperty(
                       userParms,
                       USER_SCHEMA[i].ldapName,
                       &value
                       );
      if (FAILED(hr)) { _com_issue_error(hr); }

      // If the VARIANT is empty, this property was never set.
      if (V_VT(&value) == VT_EMPTY) { continue; }

      IASTracePrintf("Inserting attribute %S.", USER_SCHEMA[i].ldapName);

      // The variant is either a single value or an array of VARIANT's.
      if (V_VT(&value) != (VT_ARRAY | VT_VARIANT))
      {
         // Insert the attribute without addref'ing.
         attrs.push_back(
                   createAttribute(USER_SCHEMA[i], value),
                   false
                   );
      }
      else
      {
         CVariantVector<VARIANT> array(&value);

         // Make sure we have enough room. We don't want to throw an
         // exception in 'push_back' since it would cause a leak.
         attrs.reserve(array.size());

         for (size_t j = 0; j < array.size(); ++j)
         {
            // Add to the array of attributes without addref'ing.
            attrs.push_back(
                      createAttribute(USER_SCHEMA[i], array[j]),
                      false
                      );
         }
      }

      // Inject into the request.
      USER_SCHEMA[i].injector(request, attrs.begin(), attrs.end());

      // Clear the attributes and the variant for reuse.
      attrs.clear();
      value.Clear();
   }

   IASTraceString("Successfully retrieved per-user attributes.");

   return IAS_REQUEST_STATUS_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\rasuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class RasUser.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>

#define IASSAMAPI

#include <iaslsa.h>
#include <iasntds.h>
#include <iasparms.h>

#include <sdoias.h>

#include <rasuser.h>
#include <userschema.h>

//////////
// Attributes that should be retrieved for each user.
//////////
const PCWSTR USER_PARMS[] =
{
   L"userParameters",
   NULL
};

HRESULT RasUser::initialize() throw ()
{
   //////////
   // Let's get everything that could fail out of the way first.
   //////////

   PIASATTRIBUTE attrs[3];
   DWORD error = IASAttributeAlloc(3, attrs);
   if (error) { return HRESULT_FROM_WIN32(error); }

   //////////
   // Initialize the dial-in bit attributes.
   //////////

   attrs[0]->dwId = IAS_ATTRIBUTE_ALLOW_DIALIN;
   attrs[0]->Value.itType = IASTYPE_BOOLEAN;
   attrs[0]->Value.Boolean = TRUE;
   attrs[1]->dwFlags = 0;
   allowAccess.attach(attrs[0], false);

   attrs[1]->dwId = IAS_ATTRIBUTE_ALLOW_DIALIN;
   attrs[1]->Value.itType = IASTYPE_BOOLEAN;
   attrs[1]->Value.Boolean = FALSE;
   attrs[1]->dwFlags = 0;
   denyAccess.attach(attrs[1], false);

   attrs[2]->dwId = RADIUS_ATTRIBUTE_SERVICE_TYPE;
   attrs[2]->Value.itType = IASTYPE_ENUM;
   attrs[2]->Value.Enumerator = 4;
   attrs[2]->dwFlags = IAS_INCLUDE_IN_ACCEPT;
   callbackFramed.attach(attrs[2], false);

   return S_OK;
}

void RasUser::finalize() throw ()
{
   allowAccess.release();
   denyAccess.release();
   callbackFramed.release();
}

IASREQUESTSTATUS RasUser::processUser(
                              IASRequest& request,
                              PCWSTR domainName,
                              PCWSTR username
                              )
{
   IASTraceString("Using downlevel dial-in parameters.");

   DWORD error;
   RAS_USER_0 ru0;

   // Try using LDAP first since it's fastest.
   IASNtdsResult result;
   error = IASNtdsQueryUserAttributes(
               domainName,
               username,
               LDAP_SCOPE_SUBTREE,
               const_cast<PWCHAR*>(USER_PARMS),
               &result
               );
   if (error == NO_ERROR)
   {
      // Retrieve the connection for this message.
      LDAP* ld = ldap_conn_from_msg(NULL, result.msg);

      LDAPMessage* entry = ldap_first_entry(ld, result.msg);
      if (entry)
      {
         // Store the user's DN.
         PWCHAR dn = ldap_get_dnW(ld, entry);
         IASStoreFQUserName(request, DS_FQDN_1779_NAME, dn);
         ldap_memfree(dn);

         // There is at most one attribute.
         PWCHAR *str = ldap_get_valuesW(
                           ld,
                           entry,
                           const_cast<PWCHAR>(USER_PARMS[0])
                           );

         // It's okay if we didn't get anything, the API can handle NULL
         // UserParameters.
         error = IASParmsQueryRasUser0((str ? *str : NULL), &ru0);

         ldap_value_freeW(str);
      }
      else
      {
         error = ERROR_NO_SUCH_USER;
      }
   }
   else if (error == ERROR_DS_NOT_INSTALLED)
   {
      // No DS, so fall back to SAM APIs.
      error = IASGetRASUserInfo(username, domainName, &ru0);
   }

   if (error)
   {
      IASTraceFailure("Per-user attribute retrieval", error);

      HRESULT hr = IASMapWin32Error(error, IAS_SERVER_UNAVAILABLE);

      return IASProcessFailure(request, hr);
   }

   // Used for injecting single attributes.
   ATTRIBUTEPOSITION pos, *first, *last;
   first = &pos;
   last  = first + 1;

   //////////
   // Insert the always present Allow-Dialin attribute.
   //////////

   if ((ru0.bfPrivilege & RASPRIV_DialinPrivilege) == 0)
   {
      first->pAttribute = denyAccess;
   }
   else
   {
      first->pAttribute = allowAccess;
   }

   IASTraceString("Inserting attribute msNPAllowDialin.");
   OverwriteAttribute(request, first, last);

   //////////
   // Insert the "Callback Framed" service type if callback is allowed.
   //////////

   if ((ru0.bfPrivilege & RASPRIV_CallbackType) != RASPRIV_NoCallback)
   {
      first->pAttribute = callbackFramed;

      IASTraceString("Inserting attribute msRADIUSServiceType.");
      OverwriteAttribute(request, first, last);
   }

   //////////
   // Insert the Callback-Number if present.
   //////////

   if (ru0.bfPrivilege & RASPRIV_AdminSetCallback)
   {
      IASAttribute callback(true);
      callback->dwId = RADIUS_ATTRIBUTE_CALLBACK_NUMBER;
      callback.setOctetString(ru0.wszPhoneNumber);
      callback.setFlag(IAS_INCLUDE_IN_ACCEPT);

      first->pAttribute = callback;

      IASTraceString("Inserting attribute msRADIUSCallbackNumber.");
      OverwriteAttribute(request, first, last);
   }

   IASTraceString("Successfully retrieved per-user attributes.");
   return IAS_REQUEST_STATUS_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\rasuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    rasuser.h
//
// SYNOPSIS
//
//    This file declares the class RasUser.
//
// MODIFICATION HISTORY
//
//    03/20/1998    Original version.
//    05/19/1998    Converted to NtSamHandler.
//    06/03/1998    Always use RAS/MPR for local users.
//    06/23/1998    Use DCLocator to find server.
//    07/09/1998    Always use RasAdminUserGetInfo
//    07/11/1998    Switch to IASGetRASUserInfo.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RASUSER_H_
#define _RASUSER_H_

#include <samutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RasUser
//
// DESCRIPTION
//
//    This class implements a Request Handler for retrieving per-user
//    attributes through the RAS/MPR API.
//
///////////////////////////////////////////////////////////////////////////////
class RasUser
   : public NtSamHandler
{
public:

   virtual HRESULT initialize() throw ();
   virtual void finalize() throw ();

   virtual IASREQUESTSTATUS processUser(
                                IASRequest& request,
                                PCWSTR domainName,
                                PCWSTR username
                                );

protected:
   // Pre-allocated attributes for the dial-in bit.
   IASAttribute allowAccess, denyAccess, callbackFramed;
};

#endif  // _RASUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\userschema.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    UserSchema.cpp
//
// SYNOPSIS
//
//    Defines the various attribute injection functions.
//
// MODIFICATION HISTORY
//
//    04/20/1998    Original version.
//    05/01/1998    InjectorProc takes an ATTRIBUTEPOSITION array.
//    08/20/1998    Remove InjectAllowDialin.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>
#include <userschema.h>

using _com_util::CheckError;

VOID
WINAPI
OverwriteAttribute(
    IAttributesRaw* dst,
    PATTRIBUTEPOSITION first,
    PATTRIBUTEPOSITION last
    )
{
   // Note: we assume that all the attributes are of the same type.

   // Remove any existing attributes with the same ID.
   CheckError(dst->RemoveAttributesByType(1, &(first->pAttribute->dwId)));

   // Add the new attributes.
   CheckError(dst->AddAttributes((DWORD)(last - first), first));
}

VOID
WINAPI
AppendAttribute(
    IAttributesRaw* dst,
    PATTRIBUTEPOSITION first,
    PATTRIBUTEPOSITION last
    )
{
   // Add the new attribute.
   CheckError(dst->AddAttributes((DWORD)(last - first), first));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\rascominclude.h ===
//#--------------------------------------------------------------
//        
//  File:       rascominclude
//        
//  Synopsis:   This file holds the global declarations for the
//              RAS Server COM component
//              
//
//  History:     2/10/98  MKarki Created
//               8/13/98  SBens  Removed unused dsource.h
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _RASCOMINCLUDE_H_
#define _RASCOMINCLUDE_H_

#include <ias.h>
#include <iaspolcy.h>
#include <iasplcy.h>
#include <iasattr.h>
#include <iascomp.h>
#include <iasdefs.h>
#include <sdoias.h>
#include "sdoiaspriv.h"

#include <iaspipe.h>
#include <iashlpr.h>


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#endif // ifndef _RASCOMINCLUDE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\crascom.h ===
//#--------------------------------------------------------------
//
//  File:       crascom.h
//
//  Synopsis:   This file holds the declarations of the
//				CRasCom class
//
//
//  History:     2/10/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef _CRASCOM_H_
#define _CRASCOM_H_

#include "resource.h"
#include "vsafilter.h"

class CRasCom:
	public IDispatchImpl<IIasComponent,
                        &__uuidof (IIasComponent),
                        &__uuidof (IasHelperLib)
                        >,
	public IRecvRequest,
	public CComObjectRoot,
	public CComCoClass<IasHelper,&__uuidof (IasHelper)>
{

public:

//
// registry declaration for the IasHelper
//
IAS_DECLARE_REGISTRY (IasHelper, 1, 0, IasHelperLib)

//
// this COM Component is not aggregatable
//
DECLARE_NOT_AGGREGATABLE(CRasCom)

//
//  this COM component is a Singleton
//
DECLARE_CLASSFACTORY_SINGLETON (CRasCom)

//
// MACROS for ATL required methods
//
BEGIN_COM_MAP(CRasCom)
	COM_INTERFACE_ENTRY2(IDispatch, IIasComponent)
	COM_INTERFACE_ENTRY(IIasComponent)
	COM_INTERFACE_ENTRY(IRecvRequest)
    COM_INTERFACE_ENTRY_FUNC(__uuidof (IRequestSource), (ULONG_PTR)0, &CRasCom::QueryInterfaceReqSrc)
END_COM_MAP()


//
// MACRO to declare Controlling IUnknown method
//
DECLARE_GET_CONTROLLING_UNKNOWN()

    CRasCom (VOID);

    ~CRasCom (VOID);

public:

    //
    // method of the IRecvRequest interface
    //
    STDMETHOD (Process) (
                /*[in]*/    DWORD           dwAttributeCount,
                /*[in]*/    PIASATTRIBUTE   *ppInIasAttribute,
                /*[out]*/   PDWORD          pdwOutAttributeCount,
                /*[out]*/   PIASATTRIBUTE   **pppOutIasAttribute,
                /*[in]*/    LONG            IasRequest,
                /*[out]*/   LONG            *pIasResponse,
                /*[in]*/    IASPROTOCOL     IasProtocol,
                /*[out]*/       PLONG           plReason,
                /*[in]*/    BOOL            bProcessVSA
                );


    //
    //  methods of IIasComponent interface
    //

    STDMETHOD(Initialize)();

    STDMETHOD(Shutdown)();

    STDMETHOD(GetProperty)(
                /*[in]*/    LONG        id,
                /*[out]*/   VARIANT     *pValue
                );

    STDMETHOD(PutProperty)(
                /*[in]*/    LONG        id,
                /*[in]*/    VARIANT     *pValue
                );

	STDMETHOD(InitNew)();

	STDMETHOD(Suspend)();

	STDMETHOD(Resume)();

private:

    //
    //  here is the class factory for the Request object
    //
    IClassFactory      *m_pIClassFactory;

    //
    //  here is the handle to the Request Handler
    //
    IRequestHandler      *m_pIRequestHandler;

    //
    //  here is the definition of the CRequestSource
    //  which implements the method of the IRequestSource
    //  interface
    //
	class CRequestSource : public IRequestSource
    {

	public:

		CRequestSource (CRasCom *pCRasCom);

		~CRequestSource ();

        //
		// IUnknown methods - delegate to outer IUnknown
        //
		STDMETHOD(QueryInterface)(
            /*[in]*/    REFIID    riid,
            /*[out]*/   void      **ppv
            )
			{
                IUnknown *pUnknown = m_pCRasCom->GetControllingUnknown();
                return (pUnknown->QueryInterface(riid,ppv));
            }

		STDMETHOD_(ULONG,AddRef)(void)
			{
                IUnknown *pUnknown = m_pCRasCom->GetControllingUnknown();
                return (pUnknown->AddRef());
            }

		STDMETHOD_(ULONG,Release)(void)
			{
                IUnknown *pUnknown = m_pCRasCom->GetControllingUnknown();
                return (pUnknown->Release());
            }

        //
		// IDispatch methods - delegate to outer class object
        //
        STDMETHOD(GetTypeInfoCount)(
            /*[out]*/    UINT    *pctinfo
            )
        {
            return (m_pCRasCom->GetTypeInfoCount (pctinfo));
        }

        STDMETHOD(GetTypeInfo)(
            /*[in]*/    UINT        iTInfo,
            /*[in]*/    LCID        lcid,
            /*[out]*/   ITypeInfo   **ppTInfo
            )
        {
            return (m_pCRasCom->GetTypeInfo (iTInfo, lcid, ppTInfo));
        }

        STDMETHOD(GetIDsOfNames)(
            /*[in]*/    const IID&  riid,
            /*[in]*/    LPOLESTR    *rgszNames,
            /*[in]*/    UINT        cNames,
            /*[in]*/    LCID        lcid,
            /*[out]*/   DISPID      *rgDispId)
        {
            return (m_pCRasCom->GetIDsOfNames (
                        riid, rgszNames, cNames, lcid, rgDispId
                        )
                    );
        }

        STDMETHOD(Invoke)(
            /*[in]*/    DISPID          dispIdMember,
            /*[in]*/    const IID&      riid,
            /*[in]*/    LCID            lcid,
            /*[in]*/    WORD            wFlags,
            /*[in/out]*/DISPPARAMS      *pDispParams,
            /*[out]*/   VARIANT         *pVarResult,
            /*[out]*/   EXCEPINFO      *pExcepInfo,
            /*[out]*/   UINT            *puArgErr
            )
        {
            return (m_pCRasCom->Invoke (
                                dispIdMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr
                                )
                );
        }

        //
		// IRequestSource Interface method
        //
		STDMETHOD(OnRequestComplete)(
                /*[in]*/ IRequest           *pIRequest,
                /*[in]*/ IASREQUESTSTATUS   eStatus
                );

    private:

		CRasCom*				m_pCRasCom;


	};	// end of nested class CRequestSource


    //
    //  private method used to remove attributes from the request
    //
    STDMETHOD (RemoveAttributesFromRequest) (
                /*[in]*/    LONG               lResponse,
                /*[in]*/    IAttributesRaw      *pIasAttributesRaw,
                /*[out]*/   PDWORD              pdwOutAttributeCount,
                /*[out]*/   PIASATTRIBUTE       **pppOutIasOutAttribute
                );

    //
    //  this method is called when somone whants the
    //  IRequestHandlercallback interface
    //
    static HRESULT WINAPI QueryInterfaceReqSrc (
                        VOID        *pThis,
                        REFIID      riid,
                        LPVOID      *ppv,
                        DWORD_PTR   dwValue
                        );

    //
    //  instantiate this nested class
    //
    CRequestSource  m_objCRequestSource;

    //
    // now we can call into private methods of CRasCom
    //
    friend class CRequestSource;

    //
    //  instantiate the VSAFilter class
    //
    VSAFilter   m_objVSAFilter;

    //
    //  flag to trac VSAFilter class object initialization
    //
    BOOL m_bVSAFilterInitialized;

    typedef enum _component_state_
    {
        COMP_SHUTDOWN,
        COMP_UNINITIALIZED,
        COMP_INITIALIZED,
        COMP_SUSPENDED

    }   COMPONENTSTATE, *PCOMPONENTSTATE;

    COMPONENTSTATE m_eCompState;

    //
    //  pending requeset count
    //
    LONG    m_lRequestCount;

};

#endif // !define  _CRASCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\crascom.cpp ===
//#--------------------------------------------------------------
//
//  File:		crascom.cpp
//
//  Synopsis:   Implementation of CRasCom class methods
//
//
//  History:     2/10/98  MKarki Created
//               5/15/98  SBens  Do not consolidate VSAs.
//               9/16/98  SBens  Signature of VSAFilter::radiusFromIAS changed.
//              11/17/99  TPerraut Split code for MS-Filter Attribute added
//                        428843
//
//
//    Copyright (C) Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "rascominclude.h"
#include "crascom.h"
#include <iastlutl.h>

const DWORD MAX_SLEEP_TIME = 50;  //milli-seconds


//
// const and defines below added for the split functions. 428843
//
const CHAR      NUL =  '\0';
//
// these are the largest values that the attribute type 
// packet type have  
//
#define MAX_ATTRIBUTE_TYPE   255
//
// these are the related constants
//
#define MAX_ATTRIBUTE_LENGTH    253
#define MAX_VSA_ATTRIBUTE_LENGTH 247

//++--------------------------------------------------------------
//
//  Function:   SplitAndAdd
//
//  Synopsis:   This method is used to remove the original attribute
//              and add new ones
//  Arguments:
//              [in]     IAttributesRaw*
//              [in]     PIASATTRIBUTE
//              [in]     IASTYPE
//              [in]     DWORD  -   attribute length
//              [in]     DWORD  -   max attribute length
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     1/19/99
//              TPerraut    Copied from CRecvFromPipe::SplitAndAdd 11/17/99
//
//  Called By:  SplitAttributes 
//
//----------------------------------------------------------------
HRESULT SplitAndAdd (
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw,
                    /*[in]*/    PIASATTRIBUTE   pIasAttribute,
                    /*[in]*/    IASTYPE         iasType,
                    /*[in]*/    DWORD           dwAttributeLength,
                    /*[in]*/    DWORD           dwMaxLength
                    )
{
    HRESULT             hr = S_OK;
    DWORD               dwPacketsNeeded = 0;
    DWORD               dwFailed = 0;
    PIASATTRIBUTE       *ppAttribArray = NULL;
    PATTRIBUTEPOSITION  pAttribPos = NULL;

    _ASSERT (pIAttributesRaw && pIasAttribute);

    __try
    {
        dwPacketsNeeded = dwAttributeLength / dwMaxLength;
        if (dwAttributeLength % dwMaxLength) {++dwPacketsNeeded;}

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        ::CoTaskMemAlloc (
                             sizeof (ATTRIBUTEPOSITION)*dwPacketsNeeded));
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while split and add of attributese in out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // allocate array to store the attributes in
        //
        ppAttribArray =
            reinterpret_cast <PIASATTRIBUTE*> (
            ::CoTaskMemAlloc (sizeof (PIASATTRIBUTE)*dwPacketsNeeded));
        if (NULL == ppAttribArray)
        {
            IASTracePrintf (
                "Unable to allocate memory"
                "while split and add of out-bound attribues"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        DWORD dwFailed =
                ::IASAttributeAlloc (dwPacketsNeeded, ppAttribArray);
        if (0 != dwFailed)
        {
            IASTracePrintf (
                "Unable to allocate attributes while splitting out-bound"
                "attributes"
                );
            hr = HRESULT_FROM_WIN32 (dwFailed);
            __leave;
        }

        if (IASTYPE_STRING == iasType)
        {
            PCHAR pStart =  (pIasAttribute->Value).String.pszAnsi;
            DWORD dwCopySize = dwMaxLength;

            //
            // set value in each of the new attributes
            //
            for (DWORD dwCount1 = 0; dwCount1 < dwPacketsNeeded; dwCount1++)
            {
                (ppAttribArray[dwCount1])->Value.String.pszAnsi =
                            reinterpret_cast <PCHAR>
                            (::CoTaskMemAlloc ((dwCopySize + 1)*sizeof (CHAR)));
                if (NULL == (ppAttribArray[dwCount1])->Value.String.pszAnsi)
                {
                    IASTracePrintf (
                        "Unable to allocate memory for new attribute values"
                        "while split and add of out-bound attribues"
                        );
                    hr = E_OUTOFMEMORY;
                    __leave;
                }

                //
                // set the value now
                //
                ::CopyMemory (
                        (ppAttribArray[dwCount1])->Value.String.pszAnsi,
                        pStart,
                        dwCopySize
                        );
                //
                // nul terminate the values
                //
                ((ppAttribArray[dwCount1])->Value.String.pszAnsi)[dwCopySize]=NUL;
                (ppAttribArray[dwCount1])->Value.itType =  iasType;
                (ppAttribArray[dwCount1])->dwId = pIasAttribute->dwId;
                (ppAttribArray[dwCount1])->dwFlags = pIasAttribute->dwFlags;

                //
                // calculate for next attribute
                //
                pStart = pStart + dwCopySize;
                dwAttributeLength -= dwCopySize;
                dwCopySize =  (dwAttributeLength > dwMaxLength) ?
                              dwMaxLength : dwAttributeLength;

                //
                // add attribute to position array
                //
                pAttribPos[dwCount1].pAttribute = ppAttribArray[dwCount1];
            }
        }
        else
        {
            PBYTE pStart = (pIasAttribute->Value).OctetString.lpValue;
            DWORD dwCopySize = dwMaxLength;

            //
            // fill the new attributes now
            //
            for (DWORD dwCount1 = 0; dwCount1 < dwPacketsNeeded; dwCount1++)
            {
                (ppAttribArray[dwCount1])->Value.OctetString.lpValue =
                    reinterpret_cast <PBYTE> (::CoTaskMemAlloc (dwCopySize));
                if (NULL ==(ppAttribArray[dwCount1])->Value.OctetString.lpValue)
                {
                    IASTracePrintf (
                        "Unable to allocate memory for new attribute values"
                        "while split and add of out-bound attribues"
                        );
                    hr = E_OUTOFMEMORY;
                    __leave;
                }

                //
                // set the value now
                //
                ::CopyMemory (
                        (ppAttribArray[dwCount1])->Value.OctetString.lpValue,
                        pStart,
                        dwCopySize
                        );

                (ppAttribArray[dwCount1])->Value.OctetString.dwLength = dwCopySize;
                (ppAttribArray[dwCount1])->Value.itType = iasType;
                (ppAttribArray[dwCount1])->dwId = pIasAttribute->dwId;
                (ppAttribArray[dwCount1])->dwFlags = pIasAttribute->dwFlags;

                //
                // calculate for next attribute
                //
                pStart = pStart + dwCopySize;
                dwAttributeLength -= dwCopySize;
                dwCopySize = (dwAttributeLength > dwMaxLength) ?
                                 dwMaxLength :
                                 dwAttributeLength;

                //
                // add attribute to position array
                //
                pAttribPos[dwCount1].pAttribute = ppAttribArray[dwCount1];
            }
        }

        //
        //   add the attribute to the collection
        //
        hr = pIAttributesRaw->AddAttributes (dwPacketsNeeded, pAttribPos);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Failed to add attributes to the collection"
                "on split and add out-bound attributes"
                );
            __leave;
        }
    }
    __finally
    {
        if ((FAILED (hr)) && (ppAttribArray) && (0 == dwFailed))
        {
            for (DWORD dwCount = 0; dwCount < dwPacketsNeeded; dwCount++)
            {
                ::IASAttributeRelease (ppAttribArray[dwCount]);
            }
        }

        if (ppAttribArray) {::CoTaskMemFree (ppAttribArray);}

        if (pAttribPos) {::CoTaskMemFree (pAttribPos);}
    }

    return (hr);

}   //  end of SplitAndAdd method


//++--------------------------------------------------------------
//
//  Function:   SplitAttributes
//
//  Synopsis:   This method is used to split up the following
//              out-bound attributes:
//                  1) Reply-Message attribute
//                  2) MS-Filter-VSA attribute
//                  3) MS QuarantineIpFilter attribute (VSA)
//
//  Arguments:
//              [in]     IAttributesRaw*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     1/19/99
//              TPerraut    Copied from CRecvFromPipe::SplitAttributes 
//                          11/17/99
//
//  Called By:  CRasCom::Process method
//
//----------------------------------------------------------------
HRESULT SplitAttributes (
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw
                    )
{
    const DWORD SPLIT_ATTRIBUTE_COUNT = 3;
    static DWORD  AttribIds [] = {
                                    RADIUS_ATTRIBUTE_REPLY_MESSAGE,
                                    MS_ATTRIBUTE_FILTER,
                                    MS_ATTRIBUTE_QUARANTINE_IPFILTER
                                };

    HRESULT hr = S_OK;
    DWORD dwAttributesFound = 0;
    PATTRIBUTEPOSITION pAttribPos = NULL;

    _ASSERT (pIAttributesRaw);

    __try
    {
        //
        //  get the count of the total attributes in the collection
        //
        DWORD dwAttributeCount = 0;
        hr = pIAttributesRaw->GetAttributeCount (&dwAttributeCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain attribute count in request while "
                "splitting attributes in out-bound packet "
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        ::CoTaskMemAlloc (
                        sizeof (ATTRIBUTEPOSITION)*dwAttributeCount)
                        );
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while splitting attributes in out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // get the attributes we are interested in from the interface
        //
        hr = pIAttributesRaw->GetAttributes (
                                    &dwAttributeCount,
                                    pAttribPos,
                                    SPLIT_ATTRIBUTE_COUNT,
                                    static_cast <PDWORD> (AttribIds)
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain information about attributes"
                "while splitting attributes in out-bound RADIUS packet"
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        // save the count of attributes returned
        //
        dwAttributesFound = dwAttributeCount;

        DWORD dwAttribLength = 0;
        DWORD dwMaxPossibleLength = 0;
        IASTYPE iasType = IASTYPE_INVALID;
        //
        // evaluate each attribute now
        //
        for (DWORD dwCount = 0; dwCount < dwAttributeCount; dwCount++)
        {
            if ((pAttribPos[dwCount].pAttribute)->dwFlags &
                                            IAS_INCLUDE_IN_RESPONSE)
            {
                //
                // get attribute type and length
                //
                if (
                (iasType = (pAttribPos[dwCount].pAttribute)->Value.itType) ==
                            IASTYPE_STRING
                    )
                {
                    DWORD dwErr = ::IASAttributeAnsiAlloc(pAttribPos[dwCount].pAttribute);
                    if (dwErr != NO_ERROR)
                    {
                       hr = (HRESULT_FROM_WIN32(dwErr));
                       __leave;
                    }

                    dwAttribLength =
                        strlen (
                        (pAttribPos[dwCount].pAttribute)->Value.String.pszAnsi);

                }
                else if (
                (iasType = (pAttribPos[dwCount].pAttribute)->Value.itType) ==
                            IASTYPE_OCTET_STRING
                )
                {
                  dwAttribLength =
                  (pAttribPos[dwCount].pAttribute)->Value.OctetString.dwLength;
                }
                else
                {
                    //
                    // only string values need to be split
                    //
                    continue;
                }

                //
                // get max possible attribute length
                //
                if ((pAttribPos[dwCount].pAttribute)->dwId > MAX_ATTRIBUTE_TYPE)
                {
                    dwMaxPossibleLength = MAX_VSA_ATTRIBUTE_LENGTH;
                }
                else
                {
                    dwMaxPossibleLength = MAX_ATTRIBUTE_LENGTH;
                }

                //
                // check if we need to split this attribute
                //
                if (dwAttribLength <= dwMaxPossibleLength)  {continue;}


                //
                // split the attribute now
                //
                hr = SplitAndAdd (
                            pIAttributesRaw,
                            pAttribPos[dwCount].pAttribute,
                            iasType,
                            dwAttribLength,
                            dwMaxPossibleLength
                            );
                if (SUCCEEDED (hr))
                {
                    //
                    //  remove this attribute from the collection now
                    //
                    hr = pIAttributesRaw->RemoveAttributes (
                                1,
                                &(pAttribPos[dwCount])
                                );
                    if (FAILED (hr))
                    {
                        IASTracePrintf (
                            "Unable to remove attribute from collection"
                            "while splitting out-bound attributes"
                            );
                    }
                }
            }
        }
    }
    __finally
    {
        if (pAttribPos)
        {
            for (DWORD dwCount = 0; dwCount < dwAttributesFound; dwCount++)
            {
                ::IASAttributeRelease (pAttribPos[dwCount].pAttribute);
            }

            ::CoTaskMemFree (pAttribPos);
        }
    }

    return (hr);

}   //  end of SplitAttributes method


//++--------------------------------------------------------------
//
//  Function:   CRasCom
//
//  Synopsis:   This is CRasCom Class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
CRasCom::CRasCom (
				VOID
				)
           :m_objCRequestSource (this),
            m_pIRequestHandler(NULL),
            m_pIClassFactory (NULL),
            m_bVSAFilterInitialized (FALSE),
            m_lRequestCount (0),
            m_eCompState (COMP_SHUTDOWN)
{
}	//	end of CRasCom class constructor	


//++--------------------------------------------------------------
//
//  Function:   ~CRasCom
//
//  Synopsis:   This is CRasCom class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
CRasCom::~CRasCom(
            VOID
			)
{
}	//	end of CRasCom class destructor

//++--------------------------------------------------------------
//
//  Function:   InitNew
//
//  Synopsis:   This is the InitNew method exposed through the
//				IIasComponent COM Interface.
//              For the RasCom Component it is implemented for
//              completeness
//
//
//  Arguments:  none
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  by the Component intializer through the IIasComponent
//              interface
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::InitNew (
                VOID
                )
{
    //
    // InitNew call can only be made from SHUTDOWN state
    //
    if (COMP_SHUTDOWN != m_eCompState)
    {
        IASTracePrintf ("The Surrogate can not be called in this state");
        return (E_UNEXPECTED);
    }

    //
    //  reset the total pending request count
    //
    m_lRequestCount = 0;

    //
    //  now we are initialized

    m_eCompState = COMP_UNINITIALIZED;

	return (S_OK);

}	// end of CRasCom::InitNew method

//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   This is the Initialize method exposed through the
//				IIasComponent COM Interface. It initializes the
//              Request object ClassFactory
//
//  Arguments:  none
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  by the Component intializer through the IIasComponent
//              interface
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::Initialize (
                VOID
                )
{
    HRESULT hr = S_OK;

    //
    // Initialize call can only be made from Uninitialized state
    //
    if (COMP_INITIALIZED == m_eCompState)
    {
        return (S_OK);
    }
    else if (COMP_UNINITIALIZED != m_eCompState)
    {
        IASTracePrintf ("The Surrogate can not be initialized in this state");
        return (E_UNEXPECTED);
    }

    //
    //  get the IClassFactory interface to be used to create
    //  the Request COM object
    //
    hr = ::CoGetClassObject (
                __uuidof (Request),
                CLSCTX_INPROC_SERVER,
                NULL,
                IID_IClassFactory,
                reinterpret_cast  <PVOID*> (&m_pIClassFactory)
                );
    if (FAILED (hr))
    {
        IASTracePrintf ("The Surrogate was unable to obtain request factory");
        return (hr);
    }

    //
    //  initialize the VSAFilter class object
    //
    hr = m_objVSAFilter.initialize ();
    if (FAILED (hr))
    {
        IASTracePrintf ("The Surrogate was unable to initializa VSA filtering");
        m_pIClassFactory->Release ();
        m_pIClassFactory = NULL;
        return (hr);
    }
    else
    {
        m_bVSAFilterInitialized = TRUE;
    }

    //
    //  correctly initialized the surrogate
    //
    m_eCompState = COMP_INITIALIZED;

    return (S_OK);

}   //  end of CRasCom::Initialize method

//++--------------------------------------------------------------
//
//  Function:   Shutdown
//
//  Synopsis:   This is the ShutDown method exposed through the
//				IIasComponent COM Interface. It is used to stop
//				processing data
//
//  Arguments:  NONE
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  by the Component shutdown through the IIasComponent
//              interface
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::Shutdown (
                VOID
                )
{
    BOOL    bStatus = FALSE;

    //
    //  shutdown can only be called from the suspend state
    //
    if (COMP_SHUTDOWN == m_eCompState)
    {
        return (S_OK);
    }
    else if (
            (COMP_SUSPENDED != m_eCompState) &&
            (COMP_UNINITIALIZED != m_eCompState)
            )
    {
        IASTracePrintf ("The Surrogate can not be shutdown in current state");
        return (E_UNEXPECTED);
    }

    //
    //  release the interfaces
    //
    if (NULL != m_pIRequestHandler)
    {
        m_pIRequestHandler->Release ();
        m_pIRequestHandler = NULL;
    }

    if (NULL != m_pIClassFactory)
    {
        m_pIClassFactory->Release ();
        m_pIClassFactory = NULL;
    }

    //
    //  shutdown the VSAFilter
    //
    if (TRUE == m_bVSAFilterInitialized)
    {
        m_objVSAFilter.shutdown ();
        m_bVSAFilterInitialized = FALSE;
    }

    //
    //  cleanly shutting down
    //
    m_eCompState = COMP_SHUTDOWN;

    return (S_OK);

}   //  end of CRasCom::Shutdown method

//++--------------------------------------------------------------
//
//  Function:   Suspend
//
//  Synopsis:   This is the Suspend method exposed through the
//				IComponent COM Interface. It is used to suspend
//              packet processing operations
//
//  Arguments:  NONE
//
//  Returns:    HRESULT	-	status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::Suspend (
                VOID
                )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    //
    //  suspend can only be called from the initialized state
    //
    if (COMP_SUSPENDED == m_eCompState)
    {
        return (S_OK);
    }
    else if (COMP_INITIALIZED != m_eCompState)
    {
        IASTracePrintf ("The Surrogate can not be suspended in current state");
        return (E_UNEXPECTED);
    }

    //
    // change state
    //
    m_eCompState = COMP_SUSPENDED;

    while (0 != m_lRequestCount) { Sleep (MAX_SLEEP_TIME); }

    //
    //  we have successfully suspended RADIUS component's packet
    //  processing operations
    //

    return (hr);

}   //  end of CRasCom::Suspend method

//++--------------------------------------------------------------
//
//  Function:   Resume
//
//  Synopsis:   This is the Resume method exposed through the
//				IComponent COM Interface. It is used to resume
//              packet processing operations which had been
//              stopped by a previous call to Suspend API
//
//
//  Arguments:  NONE
//
//  Returns:    HRESULT	-	status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::Resume (
                VOID
                )
{
    if (COMP_SUSPENDED != m_eCompState)
    {
        IASTracePrintf ("The Surrogate can not resume in current state");
        return (E_UNEXPECTED);
    }

    //
    //  we have successfully resumed operations in the RADIUS component
    //
    m_eCompState = COMP_INITIALIZED;

    return (S_OK);

}   //  end of CRasCom::Resume method

//++--------------------------------------------------------------
//
//  Function:   GetProperty
//
//  Synopsis:   This is the IIasComponent Interface method.
//              Only Implemented for the sake of completeness
//
//  Arguments:
//              [in]    LONG    -   id
//              [out]   VARIANT -   *pValue
//
//  Returns:    HRESULT	-	status
//
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::GetProperty (
                LONG        id,
                VARIANT     *pValue
                )
{
    return (S_OK);

}   //  end of CRasCom::GetProperty method

//++--------------------------------------------------------------
//
//  Function:   PutProperty
//
//  Synopsis:   This is the IIasComponent Interface method.
//              Only Implemented for the sake of completeness
//  Arguments:
//              [in]    LONG    -   id
//              [out]   VARIANT -   *pValue
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::PutProperty (
                LONG        id,
                VARIANT     *pValue
                )
{
    HRESULT hr = S_OK;

    //
    //  PutProperty method can only be called from
    //  Uninitialized, Initialized or Suspended state
    //
    if (
        (COMP_UNINITIALIZED != m_eCompState) &&
        (COMP_INITIALIZED != m_eCompState)   &&
        (COMP_SUSPENDED == m_eCompState)
        )
    {
        IASTracePrintf ("Surrogate can not put property in current state");
        return (E_UNEXPECTED);
    }

    //
    //  check if valid arguments where passed in
    //
    if (NULL == pValue) { return (E_POINTER); }

    //
    // carry out the property intialization now
    //
    switch (id)
    {

    case PROPERTY_PROTOCOL_REQUEST_HANDLER:

        if (NULL != m_pIRequestHandler)
        {
            //
            //  clients can not be updated in INITIALIZED or
            //  SUSPENDED state
            //
            hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);
        }
        else if (VT_DISPATCH != pValue->vt)
        {
            hr = DISP_E_TYPEMISMATCH;
        }
        else if (NULL == pValue->punkVal)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            //
            //  initialize the providers
            //
            m_pIRequestHandler = reinterpret_cast <IRequestHandler*>
                                                        (pValue->punkVal);
            m_pIRequestHandler->AddRef ();
        }
        break;

    default:

        hr = DISP_E_MEMBERNOTFOUND;
        break;
    }

    return (hr);

}   //  end of CRasCom::PutProperty method

//++--------------------------------------------------------------
//
//  Function:   QueryInterfaceReqSrc
//
//  Synopsis:   This is the function called when this Component
//              is called and queried for its IRequestSource
//              interface
//
//  Arguments:
//              [in]    PVOID   -   this object refrence
//              [in]    REFIID  -   IID of interface requested
//              [out]   LPVOID  -   return appropriate interface
//              [in]    DWORD
//
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
HRESULT WINAPI
CRasCom::QueryInterfaceReqSrc (
                PVOID   pThis,
                REFIID  riid,
                LPVOID  *ppv,
                DWORD_PTR dwValue
                )
{
     if ((NULL == pThis) || (NULL == ppv))
        return (E_FAIL);

    //
    // get a reference to the nested CRequestSource object
    //
    *ppv =
     &(static_cast<CRasCom*>(pThis))->m_objCRequestSource;

    //
    // increment count
    //
    ((LPUNKNOWN)*ppv)->AddRef();

    return (S_OK);

}   //  end of CRasCom::QueryInterfaceReqSrc method

//++--------------------------------------------------------------
//
//  Function:   CRequestSource
//
//  Synopsis:   This is the constructor of the CRequestSource
//              nested class
//
//  Arguments:
//              [in]    CRasCom*
//
//  Returns:    none
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
CRasCom::CRequestSource::CRequestSource(
                    CRasCom *pCRasCom
                    )
            :m_pCRasCom (pCRasCom)
{
    _ASSERT (NULL != pCRasCom);

}   //  end of CRequestSource class constructor

//++--------------------------------------------------------------
//
//  Function:   ~CRequestSource
//
//  Synopsis:   This is the destructor of the CRequestSource
//              nested class
//
//  Arguments:
//
//  Returns:    HRESULT	-	status
//
//
//  History:    MKarki      Created     11/21/97
//
//----------------------------------------------------------------
CRasCom::CRequestSource::~CRequestSource()
{
}   //  end of CRequestSource destructor

//++--------------------------------------------------------------
//
//  Function:   OnRequestComplete
//
//  Synopsis:   This is a method of IRequestHandler COM interface
//              This is the function called when a request is
//              is being pushed back after backend processing
//              we just return here as we are  only be doing
//              synchronous processing
//
//  Arguments:
//              [in]    IRequest*
//              [in]    IASREQUESTSTATUS
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  Pipeline through the IRequestHandler interface
//
//----------------------------------------------------------------
STDMETHODIMP CRasCom::CRequestSource::OnRequestComplete (
                        IRequest            *pIRequest,
                        IASREQUESTSTATUS    eStatus
                        )
{
    BOOL                    bStatus = FALSE;
    HANDLE                  hEvent = NULL;
    HRESULT                 hr = S_OK;
    unsigned hyper          uhyState = 0;
    CComPtr <IRequestState> pIRequestState;


    if (NULL == pIRequest)
    {
        IASTracePrintf (
            "Surrogate passed invalid argumen in OnRequestComplete method"
            );
        return (E_POINTER);
    }

    //
    //  get the IRequestState interface now
    //
    hr = pIRequest->QueryInterface (
                        __uuidof(IRequestState),
                        reinterpret_cast <PVOID*> (&pIRequestState)
                        );
    if (FAILED (hr))
    {
        IASTracePrintf (
            "Surrogate unable to obtain IRequestState interface in"
            " OnRequestComplete method"
            );
        return (hr);
    }

    //
    //  get the CPacketRadius class object
    //
    hr = pIRequestState->Pop (
                reinterpret_cast <unsigned hyper*> (&uhyState)
                );
    if (FAILED (hr))
    {
        IASTracePrintf (
            "Surrogate unable to obtain information from Request State"
            " in OnRequestComplete method"
            );
        return (hr);
    }

    //
    //  get the hEvent;
    //
    hEvent = reinterpret_cast <HANDLE> (uhyState);

    //
    //  set the event now
    //
    bStatus = ::SetEvent (hEvent);
    if (FALSE == bStatus)
    {
        IASTracePrintf (
            "Surrogate unable to send notification that request is"
            " processed in OnRequestComplete method"
            );
        return (E_FAIL);
    }

    return (S_OK);

}   //  end of CRasCom::CRequestSource::OnRequestComplete method

//++--------------------------------------------------------------
//
//  Function:   Process
//
//  Synopsis:   This is the method of the IRecvRequest COM interface
//              It is called to generate and send request to the
//              pipeline
//
//  Arguments:
//              [in]    DWORD -   number of in attributes
//              [in]    PIASATTRIBUTE* - array of pointer to attribs
//              [out]   PDWORD  - number of out attributes
//              [out]   PIASATTRIBUTE** - pointer
//              [in]    LONG
//              [in/out]LONG*
//              [in]    IASPROTCOL
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  Called by DoRequest C style API
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::Process (
            /*[in]*/        DWORD           dwInAttributeCount,
            /*[in]*/        PIASATTRIBUTE   *ppInIasAttribute,
            /*[out]*/       PDWORD          pdwOutAttributeCount,
            /*[out]*/       PIASATTRIBUTE   **pppOutIasAttribute,
            /*[in]*/        LONG			IasRequest,
            /*[in/out]*/    LONG			*pIasResponse,
            /*[in]*/        IASPROTOCOL     IasProtocol,
            /*[out]*/       PLONG           plReason,
            /*[in]*/        BOOL            bProcessVSA
            )
{

    DWORD                   dwCount = 0;
    HRESULT                 hr = S_OK;
    HANDLE                  hEvent = NULL;
    DWORD                   dwRetVal = 0;
    IRequest                *pIRequest = NULL;
    IAttributesRaw          *pIAttributesRaw = NULL;
    IRequestState           *pIRequestState = NULL;
    PATTRIBUTEPOSITION      pIasAttribPos = NULL;
    static DWORD            dwRequestCount = 0;

    //
    //  check if processing is enabled
    //
    if ((COMP_INITIALIZED != m_eCompState) || (NULL == m_pIRequestHandler))
    {
        IASTracePrintf (
            "Surrogate passed invalid argument for request processing"
            );
        return (E_FAIL);
    }


    __try
    {
        //
        //  increment the request count
        //
        InterlockedIncrement (&m_lRequestCount);

        //  check if we are processing requests at this time
        //
        if ((COMP_INITIALIZED != m_eCompState) || (NULL == m_pIRequestHandler))
        {
            IASTracePrintf (
                "Surrogate unable to process request in the current state"
                );
            hr = E_FAIL;
            __leave;
        }

        if (
            (0 == dwInAttributeCount)       ||
            (NULL == ppInIasAttribute)      ||
            (NULL == pdwOutAttributeCount)  ||
            (NULL == pppOutIasAttribute)    ||
            (NULL == pIasResponse)          ||
            (NULL == plReason)
            )
        {
            IASTracePrintf (
                "Surrogate passed invalid argument for processing request"
                );
            hr = E_INVALIDARG;
            __leave;
        }

        _ASSERT (NULL != m_pIClassFactory);

        //
	    //  create the request object
        //
        HRESULT hr = m_pIClassFactory->CreateInstance (
                        NULL,
                        __uuidof (IRequest),
                        reinterpret_cast <PVOID*> (&pIRequest)
                        );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate failed in creation of a new request object"
                );
            __leave;
        }


        //
        // get IAttributesRaw interface
        //
        hr = pIRequest->QueryInterface (
                            __uuidof (IAttributesRaw),
                            reinterpret_cast <PVOID*> (&pIAttributesRaw)
                            );
        if (FAILED (hr))
        {
            IASTracePrintf (
                  "Surrogate unable to obtain Attribute interface while"
                  " processing request"
                  );
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pIasAttribPos =  reinterpret_cast <PATTRIBUTEPOSITION>(
                         ::CoTaskMemAlloc (
                                sizeof (ATTRIBUTEPOSITION)*dwInAttributeCount)
                                );
        if (NULL == pIasAttribPos)
        {
            IASTracePrintf (
                "Surrogate unable to allocate memory while processing request"
                );

            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        //  put the attributes in the ATTRIBUTEPOSITION structs
        //
        for (dwCount = 0; dwCount < dwInAttributeCount; dwCount++)
        {
            //
            //  mark the attribute as having been received from client
            //
            ppInIasAttribute[dwCount]->dwFlags |= IAS_RECVD_FROM_CLIENT;

            pIasAttribPos[dwCount].pAttribute = ppInIasAttribute[dwCount];
        }

        //
        //  put the attributes collection that we are holding into the
        //  Request object through the IAttributesRaw interface
        //
        hr = pIAttributesRaw->AddAttributes (
                                    dwInAttributeCount,
                                    pIasAttribPos
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate failed to add attributes to request being processed"
                );
            __leave;
        }

     	//
        //  set the request type now
        //
        hr = pIRequest->put_Request (IasRequest);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to set the request type for processing"
                );
            __leave;
        }


        //
        //  set the protocol now
        //
        hr = pIRequest->put_Protocol (IasProtocol);
        if (FAILED (hr))
        {
            IASTracePrintf (
               "Surrogate unable to set protocol type in request for processing"
                );
            __leave;
        }

        //
        //  put your IRequestSource interface in now
        //
        hr = pIRequest->put_Source (&m_objCRequestSource);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to set source in request for processing"
                );
            __leave;
        }

        //
        //  convert the VSA attributes to IAS format if requested
        //
        if (TRUE == bProcessVSA)
        {
            hr = m_objVSAFilter.radiusToIAS (pIAttributesRaw);
            if (FAILED (hr))
            {
                IASTracePrintf (
                    "Surrogate unable to convert VSAs to IAS format"
                    );
                __leave;
            }
        }

        //
        //  create an event which will be used to wake this thread
        //  when the pipeline does multithreaded processing
        //
        hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (NULL == hEvent)
        {
           IASTracePrintf (
                "Surrogate unable to create event while processing request"
                );
            __leave;
        }

        //
        //  get the request state interface to put in our state now
        //
        //
        hr = pIRequest->QueryInterface (
                                __uuidof (IRequestState),
                                reinterpret_cast <PVOID*> (&pIRequestState)
                                );
        if (FAILED (hr))
        {
           IASTracePrintf (
                "Surrogate unable to extract request state interface"
                );
            __leave;
        }

        //
        //  put in the request state - which is our event handle in
        //
        hr = pIRequestState->Push (
                    reinterpret_cast <unsigned hyper> (hEvent)
                    );
        if (FAILED (hr))
        {
           IASTracePrintf (
                "Surrogate unable to set event in request state"
                );
            __leave;
        }

        _ASSERT (NULL != m_pIRequestHandler);

    	//
        //  send the request to the pipeline now
        //
        hr = m_pIRequestHandler->OnRequest (pIRequest);
        if (FAILED (hr))
        {
           IASTracePrintf (
                "Surrogate request failed backend processing..."
                );
            __leave;
        }

        //
        //  now wait for the event now
        //
        dwRetVal = ::WaitForSingleObjectEx (hEvent, INFINITE, TRUE);
        if (0XFFFFFFFF == dwRetVal)
        {
           IASTracePrintf (
                "Surrogate failed on waiting for process completion"
                );
            hr = E_FAIL;
            __leave;
        }

        //
        //  convert the IAS attributes to VSA format if requested
        //
        if (TRUE == bProcessVSA)
        {
            //
            // TPERRAUT  ADDED Bug 428843
            // Always called from RAS with bProcessVSA = true
            //
            // split the attributes which can not fit in a radius packet
            //
            hr = SplitAttributes (pIAttributesRaw);
            if (FAILED (hr))
            {
                IASTracePrintf (
                    "TPERRAUT: Unable to split IAS attribute received from backend"
                   );
                __leave;
            }
            // TPERRAUT  ADDED: END
       

            hr = m_objVSAFilter.radiusFromIAS (pIAttributesRaw);
            if (FAILED (hr))
            {
                IASTracePrintf (
                    "Surrogate failed on extracting VSAs from IAS format"
                    );
                __leave;
            }
        }

        //
        //  now its time to dismantle the request sent to find out
        //  what we got back
        //
        hr = pIRequest->get_Response (pIasResponse);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to obtain response from processed request"
                );
            __leave;
        }

        hr = pIRequest->get_Reason (plReason);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to obtain reason from processed request"
                );
            __leave;
        }


        //
        // remove all the attributes from the request object now
        //
        hr = RemoveAttributesFromRequest (
                                *pIasResponse,
                                pIAttributesRaw,
                                pdwOutAttributeCount,
                                pppOutIasAttribute
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to remove attributes from processed request"
                );
            __leave;
        }
    }

    __finally
    {
        //
        //  do the cleanup now
        //
        if (NULL != hEvent)
        {
            CloseHandle (hEvent);
        }

        if (NULL != pIasAttribPos)
        {
            ::CoTaskMemFree (pIasAttribPos);
        }

        if (NULL != pIRequestState)
        {
            pIRequestState->Release ();
        }

        if (NULL != pIAttributesRaw)
        {
            pIAttributesRaw->Release ();
        }

        if (NULL != pIRequest)
        {
            pIRequest->Release ();
        }

        //
        //  increment the requestreceived
        //
        dwRequestCount =
        (0xFFFFFFFF == dwRequestCount) ? 1 :  dwRequestCount+ 1;

        //
        //  decrement the request count
        //
        InterlockedDecrement (&m_lRequestCount);
    }

	return (hr);

}   //  end of CRasCom::Process method

//++--------------------------------------------------------------
//
//  Function:   RemoveAttributesFromRequest
//
//  Synopsis:   This is the CRasCom class private method
//              that is used to remove the attributes
//              from the Request object through the
//              IAttributesRaw interface
//
//  Arguments:
//              [in]    LONG - response received from pipe
//              [in]    IAttributesRaw*
//              [out]   PIASATTRIBUTE**
//              [out]   PDWORD  - out attribute count
//
//  Returns:    HRESULT	-	status
//
//  History:    MKarki      Created     2/10/98
//
//  Called By:  CRasCom::Process method
//
//----------------------------------------------------------------
STDMETHODIMP
CRasCom::RemoveAttributesFromRequest (
            LONG                     lResponse,
            IAttributesRaw           *pIasAttributesRaw,
            PDWORD                   pdwOutAttributeCount,
            PIASATTRIBUTE            **pppIasAttribute
            )
{
    HRESULT                 hr = S_OK;
    PATTRIBUTEPOSITION      pIasOutAttributePos = NULL;
    DWORD                   dwCount = 0;
    DWORD                   dwAttribCount = 0;
    DWORD                   dwOutCount = 0;
    BOOL                    bGotAttributes = FALSE;
    PIASATTRIBUTE           pIasAttribute = NULL;

    _ASSERT (
            (NULL != pIasAttributesRaw) &&
            (NULL != pppIasAttribute)   &&
            (NULL != pdwOutAttributeCount)
            );

    __try
    {

        //
        //  get the count of the attributes remaining in the collection
        //  these will be the OUT attributes
        //
        hr = pIasAttributesRaw->GetAttributeCount (&dwAttribCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable to obtain attribute count from request in"
                "while removing attributes from request"
                );
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pIasOutAttributePos =  reinterpret_cast <PATTRIBUTEPOSITION> (
                         ::CoTaskMemAlloc (
                            sizeof (ATTRIBUTEPOSITION)*(dwAttribCount))
                           );
        if (NULL == pIasOutAttributePos)
        {
            IASTracePrintf (
                "Surrogate unable to allocate memory"
                "while removing attributes from request"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }


        //
        //  get all the attributes from the collection
        //
        hr = pIasAttributesRaw->GetAttributes (
                                    &dwAttribCount,
                                    pIasOutAttributePos,
                                    0,
                                    NULL
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable get attributes from request interface"
                "while removing attributes"
                );
            __leave;
        }

        //
        //  we have obtained the attributes
        //
        bGotAttributes = TRUE;

        //
        //  remove the attributes from the collection now
        //
        hr = pIasAttributesRaw->RemoveAttributes (
                                dwAttribCount,
                                pIasOutAttributePos
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Surrogate unable remove attributes from request"
                );
            __leave;
        }

        //
        //  calculate the number of attributes not added by the client
        //
        *pdwOutAttributeCount = 0;
        for (dwCount = 0; dwCount < dwAttribCount; dwCount++)
        {
            pIasAttribute = pIasOutAttributePos[dwCount].pAttribute;

            //
            // verify that this attributes has to be sent to client
            //
            if
            (
                ((pIasAttribute->dwFlags & IAS_INCLUDE_IN_ACCEPT) &&
                (IAS_RESPONSE_ACCESS_ACCEPT == lResponse))              ||
                ((pIasAttribute->dwFlags & IAS_INCLUDE_IN_REJECT) &&
                (IAS_RESPONSE_ACCESS_REJECT == lResponse))              ||
                ((pIasAttribute->dwFlags & IAS_INCLUDE_IN_CHALLENGE) &&
                (IAS_RESPONSE_ACCESS_CHALLENGE == lResponse))
            )
            {
                (*pdwOutAttributeCount)++;
            }

        }

        //
        //  allocate memory for PIASATTRIBUTE array
        //
        *pppIasAttribute = reinterpret_cast <PIASATTRIBUTE*> (
            ::CoTaskMemAlloc (sizeof(PIASATTRIBUTE)*(*pdwOutAttributeCount))
                    );
        if (NULL == *pppIasAttribute)
        {
            IASTracePrintf (
                "Surrogate unable to allocate memory for attrib pointer array"
                "while removing attribute from request"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        //  put the attributes in the PIASATTRIBUTE array
        //
        for (dwCount = 0, dwOutCount = 0; dwCount < dwAttribCount; dwCount++)
        {
            pIasAttribute = pIasOutAttributePos[dwCount].pAttribute;

            if  (
                (((pIasAttribute->dwFlags & IAS_INCLUDE_IN_ACCEPT) &&
                (IAS_RESPONSE_ACCESS_ACCEPT == lResponse))              ||
                ((pIasAttribute->dwFlags & IAS_INCLUDE_IN_REJECT) &&
                (IAS_RESPONSE_ACCESS_REJECT == lResponse))              ||
                ((pIasAttribute->dwFlags & IAS_INCLUDE_IN_CHALLENGE) &&
                (IAS_RESPONSE_ACCESS_CHALLENGE == lResponse)))
                &&
                (dwOutCount < *pdwOutAttributeCount)
                )
            {

                //
                //  put the out attribute in the output array
                //
                (*pppIasAttribute)[dwOutCount] =  pIasAttribute;

                dwOutCount++;
            }
            else
            {
                //
                // decrement the reference count for the
                // attributes we created or the ones we are
                // not sending as out to client
                //
                ::IASAttributeRelease (pIasAttribute);
            }
        }

        //
        //  now put in the number of out attribute we are actually
        //  giving the client
        //
        *pdwOutAttributeCount = dwOutCount;

    }
    __finally
    {

        //
        //  cleanup on failure
        //
        if (FAILED (hr))
        {
            if (NULL != *pppIasAttribute)
            {
                ::CoTaskMemFree (*pppIasAttribute);
                pppIasAttribute = NULL;
            }

            //
            //  correct the out attribute count
            //
            *pdwOutAttributeCount = 0;

            //
            //  free up all the attributes also
            //
            if ((TRUE == bGotAttributes) && (NULL != pIasOutAttributePos))
            {
                for (dwCount = 0; dwCount < dwAttribCount; dwCount++)
                {
                    ::IASAttributeRelease (
                            pIasOutAttributePos[dwCount].pAttribute
                            );
                }
            }
        }

        //
        //  delete the dynamically allocated memory
        //
        if (NULL != pIasOutAttributePos)
        {
            ::CoTaskMemFree (pIasOutAttributePos);
        }
    }

    return (hr);

}   //  end of CRasCom::RemoveAttributesFromRequest method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\ntuser\peruser\userschema.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    userschema.h
//
// SYNOPSIS
//
//    This file declares the USER_SCHEMA information.
//
// MODIFICATION HISTORY
//
//    02/26/1998    Original version.
//    03/26/1998    Added msNPAllowDialin.
//    04/13/1998    Added msRADIUSServiceType.
//    05/01/1998    Changed signature of InjectorProc.
//    08/20/1998    Remove InjectAllowDialin.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _USERSCHEMA_H_
#define _USERSCHEMA_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <ldapdnary.h>
#include <sdoias.h>

//////////
// Functions used for injecting attributes.
//////////
VOID
WINAPI
OverwriteAttribute(
    IAttributesRaw* dst,
    PATTRIBUTEPOSITION first,
    PATTRIBUTEPOSITION last
    );

VOID
WINAPI
AppendAttribute(
    IAttributesRaw* dst,
    PATTRIBUTEPOSITION first,
    PATTRIBUTEPOSITION last
    );

//////////
// Schema information for the per-user attributes. This array must be in
// alphabetical order.
//////////
const LDAPAttribute USER_SCHEMA[] =
{
   { L"msNPAllowDialin",
     IAS_ATTRIBUTE_ALLOW_DIALIN,
     IASTYPE_BOOLEAN,
     0,
     OverwriteAttribute },
   { L"msNPCallingStationID",
     IAS_ATTRIBUTE_NP_CALLING_STATION_ID,
     IASTYPE_STRING,
     0,
     OverwriteAttribute },
   { L"msRADIUSCallbackNumber",
     RADIUS_ATTRIBUTE_CALLBACK_NUMBER,
     IASTYPE_OCTET_STRING,
     IAS_INCLUDE_IN_ACCEPT,
     OverwriteAttribute },
   { L"msRADIUSFramedIPAddress",
     RADIUS_ATTRIBUTE_FRAMED_IP_ADDRESS,
     IASTYPE_INET_ADDR,
     IAS_INCLUDE_IN_ACCEPT,
     OverwriteAttribute },
   { L"msRADIUSFramedRoute",
     RADIUS_ATTRIBUTE_FRAMED_ROUTE,
     IASTYPE_OCTET_STRING,
     IAS_INCLUDE_IN_ACCEPT,
     OverwriteAttribute },
   { L"msRADIUSServiceType",
     RADIUS_ATTRIBUTE_SERVICE_TYPE,
     IASTYPE_ENUM,
     IAS_INCLUDE_IN_ACCEPT,
     OverwriteAttribute }
};

// Number of elements in the USER_SCHEMA array.
const size_t USER_SCHEMA_ELEMENTS = sizeof(USER_SCHEMA)/sizeof(LDAPAttribute);

#endif  // _USERSCHEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\rascompch.cpp ===
#include "rascominclude.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_IasHelper                            101
#define IDR_IasHelper                            102

#endif // ifndef _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\rasserver\rascommain.cpp ===
//#--------------------------------------------------------------
//
//  File:       rascommain.cpp
//
//  Synopsis:   this is the main Source File for the RAS Server
//              COM component DLL
//
//
//  History:     2/10/98  MKarki Created
//               8/04/98  MKarki Changes for Dynamic Config
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

//
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f radprotops.mk in the project directory.

#include "rascominclude.h"
#include "crascom.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(IasHelper), CRasCom)
END_OBJECT_MAP()

//
//  globals
//
IRecvRequest        *g_pIRecvRequest = NULL;
ISdoService         *g_pISdoService = NULL;
BOOL                g_bInitialized = FALSE;
CRITICAL_SECTION    g_SrvCritSect;

//
// ProgID of SdoService component
//
const WCHAR SERVICE_PROG_ID[] = L"IAS.SdoService";

//
// ProgID for IasHelper component
//
const WCHAR HELPER_PROG_ID[] = L"IAS.IasHelper";


//++--------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Disabling thread calls
//
//  Arguments:  [in]    HINSTANCE - module handle
//              [in]    DWORD     - reason for call
//              reserved
//
//  Returns:    BOOL    -   sucess/failure
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
        InitializeCriticalSection (&g_SrvCritSect);

      _Module.Init(ObjectMap, hInstance);
      DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection (&g_SrvCritSect);
      _Module.Term();
    }

   return (TRUE);

}   //  end of DllMain method

//++--------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Used to determine if the DLL can be unloaded
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
STDAPI
DllCanUnloadNow(
            VOID
            )
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

}   //  end of DllCanUnloadNow method

//++--------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns a class factory to create an object
//              of the requested type
//
//  Arguments: [in]  REFCLSID
//             [in]  REFIID
//             [out] LPVOID -   class factory
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI
DllGetClassObject(
            REFCLSID rclsid,
            REFIID riid,
            LPVOID* ppv
            )
{
   return (_Module.GetClassObject(rclsid, riid, ppv));

}   //  end of DllGetClassObject method

//++--------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Add entries to the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI DllRegisterServer(
            VOID
            )
{
    //
   // registers object, typelib and all interfaces in typelib
    //
   return (_Module.RegisterServer(TRUE));

}   //  end of DllRegisterServer method

//++--------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes entries from the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI
DllUnregisterServer(
        VOID
        )
{
   _Module.UnregisterServer();
   return (S_OK);

}   //  end of DllUnregisterServer method

//++--------------------------------------------------------------
//
//  Function:   AllocateAttributes
//
//  Synopsis:   This API allocates the number of attributes spefied
//              and returns them in the PIASATTRIBUTE array
//
//  Arguments:
//              [in]    DWORD   - number of attributes
//              [out]   PIASATTRIBUTE* array
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI
AllocateAttributes (
        DWORD           dwAttributeCount,
        PIASATTRIBUTE   *ppIasAttribute
        )
{
    DWORD  dwRetVal = 0;

    //
    //  can only allocate attributes after initialization
    //
    if (FALSE == g_bInitialized)
    {
        IASTracePrintf (
            "InitializeIas method needs to has not been called before"
            "allocating attributes"
            );
        return (E_FAIL);
    }

    //
    //  check if arguments are correct
    //
    if ((0 == dwAttributeCount) || (NULL == ppIasAttribute))
    {
        IASTracePrintf (
            "Inivalid arguments passed in to AllocateAttributes method"
            );
        return (E_INVALIDARG);
    }

    //
    //  allocate attributes now
    //
    dwRetVal = ::IASAttributeAlloc (dwAttributeCount, ppIasAttribute);
    if (0 != dwRetVal)
    {
        IASTracePrintf (
            "Unable to allocate memory in AllocateAttributes method"
            );
        return (E_FAIL);
    }

    return (S_OK);

}   //  end of AllocateAttributes method

//++--------------------------------------------------------------
//
//  Function:   FreeAttributes
//
//  Synopsis:   This API frees the number of attributes spefied
//
//  Arguments:
//              [in]    DWORD   - number of attributes
//              [in]   PIASATTRIBUTE array
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI
FreeAttributes (
        DWORD           dwAttributeCount,
        PIASATTRIBUTE   *ppIasAttribute
        )
{
    DWORD dwCount = 0;

    //
    //  can only free attributes after initialization
    //
    if (FALSE == g_bInitialized)
    {
        IASTracePrintf (
            "InitializeIas needs to be called before freeing attributes"
            );
        return (E_FAIL);
    }

    //
    //  check if correct attributes have been passed in
    //
    if (NULL == ppIasAttribute)
    {
        IASTracePrintf (
            "Invalid arguments passed in to FreeAttributes method"
            );
        return (E_INVALIDARG);
    }

    //
    //  free the attributes now
    //
    for  (dwCount = 0; dwCount < dwAttributeCount; dwCount++)
    {
        ::IASAttributeRelease (ppIasAttribute[dwCount]);
    }

    return (S_OK);

}   //  end of FreeAttributes method

//++--------------------------------------------------------------
//
//  Function:   DoRequest
//
//  Synopsis:   This is the API that is called to send request
//              to the pipeline
//
//  Arguments:
//              [in]   DWORD - number of attributes
//              [in]   PIASATTRIBUTE*
//              [in]   IASREQUEST
//              [out]  IASRESPONSE
//
//  Returns:    HRESULT   -   status
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
STDAPI
DoRequest (
    DWORD           dwInAttributeCount,
    PIASATTRIBUTE   *ppInIasAttribute,
    PDWORD          pdwOutAttributeCount,
    PIASATTRIBUTE   **pppOutIasAttribute,
    LONG            IasRequest,
    LONG            *pIasResponse,
    IASPROTOCOL     IasProtocol,
    PLONG           plReason,
    BOOL            bProcessVSA
    )
{
    DWORD           dwRetVal = 0;
    BOOL            bStatus = FALSE;
    HRESULT         hr =    S_OK;

    //
    //  can only make request to pipeline after initialization
    //
    if (FALSE == g_bInitialized)
    {
        IASTracePrintf (
            "InitializeIas needs to be called before Request processing"
            );
        return (E_FAIL);
    }

    //
    //  check the arguments passed in
    //
    if  (
        (NULL == ppInIasAttribute)      ||
        (NULL == pdwOutAttributeCount)  ||
        (NULL == pppOutIasAttribute)    ||
        (NULL == pIasResponse)          ||
        (NULL == plReason)
        )
    {
        IASTracePrintf (
            "Invalid arguments passed in to DoRequest method"
            );
        return (E_INVALIDARG);
    }

    //
    // make the request to the IASHelper COM Object interface
    //
    hr = g_pIRecvRequest->Process (
                            dwInAttributeCount,
                            ppInIasAttribute,
                            pdwOutAttributeCount,
                            pppOutIasAttribute,
                            IasRequest,
                            pIasResponse,
                            IasProtocol,
                            plReason,
                            bProcessVSA
                            );
    if (FAILED (hr))
    {
        IASTracePrintf ( "Surrogate failed in processing request... hr =%x", hr);
    }

    return  (hr);

}   //  end of DoRequest method

//++--------------------------------------------------------------
//
//  Function:   InitializeIas
//
//  Synopsis:   This is the API that is called to  Initialize the
//              IasHlpr Component
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" HRESULT WINAPI
InitializeIas (
        BOOL   bComInit
        )
{
    HRESULT hr = S_OK;
    CLSID   clsid;


    __try
    {
        EnterCriticalSection (&g_SrvCritSect);

        //
        //  check if we are already initialized
        //
        if (TRUE == g_bInitialized)
        {
            __leave;
        }

        IASTraceInitialize();

        IASTracePrintf ("Initializing Surrogate...");

        //
        //  check if our threads are COM enabled
        //
        if (FALSE == bComInit)
        {
            IASTracePrintf (
                "Thread calling InitializeIas need to be COM enabled"
                 );
            hr = E_INVALIDARG;
            __leave;
        }

        //
        //  convert SdoService ProgID to CLSID
        //
        hr = CLSIDFromProgID (SERVICE_PROG_ID, &clsid);
        if (FAILED (hr))
        {
            IASTracePrintf ( "Unable to get SDO service ID" );
            __leave;
        }

        //
        //  Create the SdoComponent
        //
        hr = CoCreateInstance (
                        clsid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        __uuidof (ISdoService),
                        reinterpret_cast <PVOID*> (&g_pISdoService)
                        );
        if (FAILED (hr))
        {
            IASTracePrintf ( "Unable to create Surrogate COM component");
            __leave;
        }

        //
        //  Initialize the Service first
        //
        hr = g_pISdoService->InitializeService (SERVICE_TYPE_RAS);
        if (FAILED (hr))
        {
            IASTracePrintf ( "Unable to initialize SDO COM component");
            __leave;
        }

        //
        //  Start the IAS service now
        //
        hr = g_pISdoService->StartService (SERVICE_TYPE_RAS);
        if (FAILED (hr))
        {
            IASTracePrintf ( "Unable to start SDO component");

            //
            //  got to do a shutdown if could not start the sevice
            //
            HRESULT hr1 = g_pISdoService->ShutdownService (SERVICE_TYPE_RAS);
            if (FAILED (hr1))
            {
                 IASTracePrintf("Unable to shutdown SDO compnent");
            }
            __leave;
        }

        //
        //  convert IasHelper ProgID to CLSID
        //
        hr = CLSIDFromProgID (HELPER_PROG_ID, &clsid);
        if (FAILED (hr))
        {
            IASTracePrintf("Unable to obtain Surrogate ID");
            __leave;
        }

        //
        //  Create the  IasHelper component
        //
        hr = CoCreateInstance (
                        clsid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        __uuidof (IRecvRequest),
                        reinterpret_cast <PVOID*> (&g_pIRecvRequest)
                        );
        if (FAILED (hr))
        {
            IASTracePrintf("Unable to create Surrogate component");
            __leave;
        }

        //
        //  initialization complete
        //
        g_bInitialized = TRUE;

    }
    __finally
    {
        if (FAILED (hr))
        {

            IASTracePrintf ("Surrogate failed initialization.");

            //
            //  do cleanup
            //
            if (NULL != g_pIRecvRequest)
            {
                g_pIRecvRequest->Release ();
                g_pIRecvRequest = NULL;
            }

            if (NULL != g_pISdoService)
            {
                g_pISdoService->Release ();
                g_pISdoService = NULL;
            }

            IASTraceUninitialize();
        }
        else
        {
            IASTracePrintf ("Surrogate initialized.");
        }

        LeaveCriticalSection (&g_SrvCritSect);
    }

    return (hr);

}   //  end of InitializeIas method

//++--------------------------------------------------------------
//
//  Function:   ShutdownIas
//
//  Synopsis:   This is the API used to shutdown the
//               IasHlpr Component
//
//  Arguments:   none
//
//  Returns:    VOID
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" VOID WINAPI
ShutdownIas (
        VOID
        )
{
    HRESULT     hr = S_OK;

    EnterCriticalSection (&g_SrvCritSect);

    IASTracePrintf ("Shutting down Surrogate....");

    //
    //  stop the components first
    //
    if (FALSE == g_bInitialized)
    {
        LeaveCriticalSection (&g_SrvCritSect);
        return;
    }
    else
    {
        //
        //  don't let any requests come through now
        //
        g_bInitialized = FALSE;
    }

    //
    //  release the reference to the interface
    //
    if (NULL != g_pIRecvRequest)
    {
        g_pIRecvRequest->Release ();
        g_pIRecvRequest = NULL;
    }


    if (NULL != g_pISdoService)
    {
        //
        //  stop the service
        //
        hr = g_pISdoService->StopService (SERVICE_TYPE_RAS);
        if (FAILED (hr))
        {
            IASTracePrintf ("Unable to stop SDO component");
        }

        //
        //  shutdown the service
        //
        hr = g_pISdoService->ShutdownService (SERVICE_TYPE_RAS);
        if (FAILED (hr))
        {
            IASTracePrintf ("Unable to shutdown SDO component");
        }

        g_pISdoService->Release ();
        g_pISdoService = NULL;
    }

    IASTracePrintf ("Surrogate Shutdown complete.");
    IASTraceUninitialize();

    LeaveCriticalSection (&g_SrvCritSect);
    return;

}   //  end of ShutdownIas method

//++--------------------------------------------------------------
//
//  Function:   ConfigureIas
//
//  Synopsis:   This is the API that is called to  reload the
//              IAS configuration information
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     09/04/98
//
//----------------------------------------------------------------
extern "C" HRESULT WINAPI
ConfigureIas (
        VOID
        )
{
    HRESULT hr = S_OK;

    EnterCriticalSection (&g_SrvCritSect);

    IASTracePrintf ("Configuring Surrogate.");

    if (FALSE == g_bInitialized)
    {
        IASTracePrintf (
            "InitializeIas needs to be called before configuring surrogate"
            );
    }
    else if (NULL != g_pISdoService)
    {
       hr = g_pISdoService->ConfigureService (SERVICE_TYPE_RAS);
    }

    LeaveCriticalSection (&g_SrvCritSect);
    return (hr);

}   //  end of ConfigureIas method

//++--------------------------------------------------------------
//
//  Function:   MemAllocIas
//
//  Synopsis:   This is the API used to allocate dynamic memory
//
//  Arguments:  none
//
//  Returns:    PVOID - address of allocated memory
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" PVOID WINAPI
MemAllocIas (
        DWORD   dwSize
        )
{

    return (::CoTaskMemAlloc (dwSize));

}   //  end of MemAllocIas API

//++--------------------------------------------------------------
//
//  Function:   MemFreeIas
//
//  Synopsis:   This is the API to free the dynamic memory
//              allocated through MemAllocIas
//
//  Arguments:  PVOID   - address of allocated memory
//
//  Returns:    VOID
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" VOID WINAPI
MemFreeIas (
        PVOID   pAllocMem
        )
{
    ::CoTaskMemFree (pAllocMem);

}   //  end of MemFreeIas API

//++--------------------------------------------------------------
//
//  Function:   MemReallocIas
//
//  Synopsis:   This is the API to reallocate the already allocate
//              dynamic memory allocated through MemAllocIas
//
//  Arguments:  PVOID   - address of allocated memory
//              DWORD   - new size
//
//  Returns:    PVOID   - adress of new memory
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
extern "C" PVOID WINAPI
MemReallocIas (
        PVOID   pAllocMem,
        DWORD   dwNewSize
        )
{
    return (::CoTaskMemRealloc (pAllocMem, dwNewSize));

}   //  end of MemReallocIas API

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\dsenum.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsenum.h
//
// SYNOPSIS
//
//    This file declares the class DSEnumerator.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSENUM_H_
#define _DSENUM_H_

#include <dsobject.h>
#include <iasdebug.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DSEnumerator
//
// DESCRIPTION
//
//    This class implements IEnumVARIANT for a collection of objects.
//
///////////////////////////////////////////////////////////////////////////////
class DSEnumerator : public IEnumVARIANT
{
public:

DECLARE_TRACELIFE(DSEnumerator);


   DSEnumerator(DSObject* container, IEnumVARIANT* members)
      : refCount(0), parent(container), subject(members) { }

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(const IID& iid, void** ppv);

//////////
// IEnumVARIANT
//////////
   STDMETHOD(Next)(/*[in]*/ ULONG celt,
                   /*[length_is][size_is][out]*/ VARIANT* rgVar,
                   /*[out]*/ ULONG* pCeltFetched);
   STDMETHOD(Skip)(/*[in]*/ ULONG celt);
   STDMETHOD(Reset)();
   STDMETHOD(Clone)(/*[out]*/ IEnumVARIANT** ppEnum);

protected:
   LONG refCount;

   CComPtr<DSObject> parent;       // The container being enumerated.
   CComPtr<IEnumVARIANT> subject;  // The ADSI enumerator.
};

#endif  // _DSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\adsstore.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    adsstore.cpp
//
// SYNOPSIS
//
//    This file defines the class ADsDataStore.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    02/11/1999    Changes to support keeping downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <adsstore.h>
#include <dsobject.h>


STDMETHODIMP ADsDataStore::get_Root(IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   if (*ppObject = root) { (*ppObject)->AddRef(); }

   return S_OK;
}


STDMETHODIMP ADsDataStore::Initialize(BSTR bstrDSName,
                                      BSTR bstrUserName,
                                      BSTR bstrPassword)
{
   try
   {
      // Save these for later.
      userName = bstrUserName;
      password = bstrPassword;

      // Open the root container.
      _com_util::CheckError(OpenObject(bstrDSName, &root));
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP ADsDataStore::OpenObject(BSTR bstrPath,
                                      IDataStoreObject** ppObject)
{
   if (bstrPath == NULL || ppObject == NULL) { return  E_INVALIDARG; }

   *ppObject = NULL;

   try
   {
      // Open the underlying ADSI object ...
      CComPtr<IUnknown> unk;

      // First try with signing and sealing, ...
      HRESULT hr = ADsOpenObject(
                       bstrPath,
                       userName,
                       password,
                       ADS_SECURE_AUTHENTICATION |
                       ADS_USE_SIGNING           |
                       ADS_USE_SEALING,
                       __uuidof(IUnknown),
                       (PVOID*)&unk
                       );
      if (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
      {
         // ... then without. This allows us to connect using NTLM.
         hr = ADsOpenObject(
                  bstrPath,
                  userName,
                  password,
                  ADS_SECURE_AUTHENTICATION,
                  __uuidof(IUnknown),
                  (PVOID*)&unk
                  );
      }
      _com_util::CheckError(hr);

      // ... and convert it to a DSObject.
      (*ppObject = new DSObject(unk))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP ADsDataStore::Shutdown()
{
   root.Release();

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\inc\dstorex.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dstorex.h
//
// SYNOPSIS
//
//    Defines the classes IDataStoreObjectEx and IDataStoreContainerEx.
//
// MODIFICATION HISTORY
//
//    03/02/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSTOREX_H
#define _DSTOREX_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <datastore2.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IDataStoreObjectEx
//
// DESCRIPTION
//
//    This class extends IDataStoreObject in order to map the collection
//    related properties to alternate names. This allows a sub-class to
//    implement both IDataStoreObject and IDataStoreContainer without name
//    collisions.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) IDataStoreObjectEx
   : public IDataStoreObject
{
public:

//////////
// IDataStoreObject members that are mapped to new names.
//////////

   STDMETHOD(get_Count)(long* pVal)
   {
      return get_PropertyCount(pVal);
   }

   STDMETHOD(get__NewEnum)(IUnknown** pVal)
   {
      return get_NewPropertyEnum(pVal);
   }

//////////
// Versions that are overriden in the derived class.
//////////

   STDMETHOD(get_PropertyCount)(long* pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(get_NewPropertyEnum)(IUnknown** pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(Item)(BSTR bstrName, IDataStoreProperty** pVal)
   {
      return E_NOTIMPL;
   }

};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IDataStoreContainerEx
//
// DESCRIPTION
//
//    This class extends IDataStoreContainer in order to map the collection
//    related properties to alternate names. This allows a sub-class to
//    implement both IDataStoreObject and IDataStoreContainer without name
//    collisions.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) IDataStoreContainerEx
   : public IDataStoreContainer
{
public:

//////////
// IDataStoreContainer members that are mapped to new names.
//////////

   STDMETHOD(get_Count)(long* pVal)
   {
      return get_ChildCount(pVal);
   }

   STDMETHOD(get__NewEnum)(IUnknown** pVal)
   {
      return get_NewChildEnum(pVal);
   }

//////////
// Alternate versions that are overriden in the derived class.
//////////

   STDMETHOD(get_ChildCount)(long* pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(get_NewChildEnum)(IUnknown** pVal)
   {
      return E_NOTIMPL;
   }

   STDMETHOD(Item)(BSTR bstrName, IDataStoreObject** pVal)
   {
      return E_NOTIMPL;
   }

};

#endif  // _DSTOREX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\dsobject.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobject.cpp
//
// SYNOPSIS
//
//    This file defines the class DSObject.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    06/09/1998    Refresh property cache before enumerating dirty objects.
//    02/11/1999    Keep downlevel parameters in sync.
//    03/16/1999    Return error if downlevel update fails.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <dsenum.h>
#include <dsobject.h>

#include <vector>

WCHAR USER_PARAMETERS_NAME[] = L"UserParameters";

// Smart pointer for an IADsPropertyEntryPtr.
_COM_SMARTPTR_TYPEDEF(IADsPropertyEntry, __uuidof(IADsPropertyEntry));

//////////
// Prefix added to all RDN's.
//////////
_bstr_t DSObject::thePrefix(L"CN=");

//////////
// The name of the 'name' property.
//////////
_bstr_t DSObject::theNameProperty(L"name");
_bstr_t DSObject::theUserParametersProperty(USER_PARAMETERS_NAME);


DSObject::DSObject(IUnknown* subject)
   : oldParms(NULL)
{
   _Module.Lock();
   // All subjects must support IADs && IDirectoryObject.
   _com_util::CheckError(subject->QueryInterface(
                                      __uuidof(IADs),
                                      (PVOID*)&leaf
                                      ));

   _com_util::CheckError(Restore());
}

DSObject::~DSObject() throw ()
{
   SysFreeString(oldParms);
   _Module.Unlock();
}

//////////
// IUnknown implementation is copied from CComObject<>.
//////////

STDMETHODIMP_(ULONG) DSObject::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) DSObject::Release()
{
   ULONG l = InternalRelease();

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP DSObject::QueryInterface(REFIID iid, void ** ppvObject)
{
   return _InternalQueryInterface(iid, ppvObject);
}

STDMETHODIMP DSObject::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_OUTOFMEMORY; }

   VARIANT v;

   RETURN_ERROR(leaf->Get(theNameProperty, &v));

   // We should have gotten back a non-null BSTR.
   if (V_VT(&v) != VT_BSTR || V_BSTR(&v) == NULL) { return E_FAIL; }

   *pVal = V_BSTR(&v);

   return S_OK;
}

STDMETHODIMP DSObject::get_Class(BSTR* pVal)
{
   return leaf->get_Class(pVal);
}

STDMETHODIMP DSObject::get_GUID(BSTR* pVal)
{
   return leaf->get_GUID(pVal);
}

STDMETHODIMP DSObject::get_Container(IDataStoreContainer** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP DSObject::GetValue(BSTR bstrName, VARIANT* pVal)
{
   return leaf->Get(bstrName, pVal);
}

STDMETHODIMP DSObject::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   return leaf->GetEx(bstrName, pVal);
}

STDMETHODIMP DSObject::PutValue(BSTR bstrName, VARIANT* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   // Flag the object as dirty.
   dirty = TRUE;

   // Synch up the downlevel parameters.
   downlevel.PutValue(bstrName, pVal);

   if ( VT_EMPTY == V_VT(pVal) )
   {
	   return leaf->PutEx(ADS_PROPERTY_CLEAR, bstrName, *pVal);
   }
   else if ( VT_ARRAY == (V_VT(pVal) & VT_ARRAY) )
   {
	   return leaf->PutEx(ADS_PROPERTY_UPDATE, bstrName, *pVal);
   }
   else
   {
	   return leaf->Put(bstrName, *pVal);
   }
}

STDMETHODIMP DSObject::Update()
{
   // Update the UserParameters.
   PWSTR newParms;
   HRESULT hr = downlevel.Update(oldParms, &newParms);
   if (FAILED(hr)) { return hr; }

   // Convert to a VARIANT.
   VARIANT value;
   VariantInit(&value);
   V_VT(&value) = VT_BSTR;
   V_BSTR(&value) = SysAllocString(newParms);

   // Set the UserParameters property.
   leaf->Put(theUserParametersProperty, value);

   // Clean-up.
   VariantClear(&value);
   LocalFree(newParms);

   return leaf->SetInfo();
}

STDMETHODIMP DSObject::Restore()
{
   // Free the old UserParameters.
   if (oldParms)
   {
      SysFreeString(oldParms);
      oldParms = NULL;
   }

   dirty = FALSE;
   HRESULT hr = leaf->GetInfo();
   if (SUCCEEDED(hr))
   {
      // Read the UserParameters property.
      VARIANT value;
      if (leaf->Get(theUserParametersProperty, &value) == S_OK)
      {
         if (V_VT(&value) == VT_BSTR)
         {
            oldParms = V_BSTR(&value);
         }
         else
         {
            // This should never happen.
            VariantClear(&value);
         }
      }
   }
   else if (hr == E_ADS_OBJECT_UNBOUND)
   {
      hr = S_OK;
   }

   return hr;
}

STDMETHODIMP DSObject::Item(BSTR bstrName, IDataStoreProperty** pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   *pVal = NULL;

   // Get the value for this item.
   _variant_t value;
   RETURN_ERROR(leaf->Get(bstrName, &value));

   try
   {
      // Create a new property object.
      (*pVal = new MyProperty(bstrName, value, this))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::get_PropertyCount(long* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   if (dirty)
   {
      RETURN_ERROR(Restore());
   }

   MyProperties properties(leaf);

   if (!properties)
   {
      // Some ADSI providers may not implement IADsPropertyList.
      *pVal = 0;

      return E_NOTIMPL;
   }

   return properties->get_PropertyCount(pVal);
}

STDMETHODIMP DSObject::get_NewPropertyEnum(IUnknown** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   *pVal = NULL;

   if (dirty)
   {
      RETURN_ERROR(Restore());
   }

   MyProperties properties(leaf);

   // Some ADSI providers may not implement IADsPropertyList.
   if (!properties) { return E_NOTIMPL; }

   // Reset the list in case this isn't the first time we've enumerated it.
   properties->Reset();

   try
   {
      using _com_util::CheckError;

      // How many properties are there?
      long count;
      CheckError(properties->get_PropertyCount(&count));

      // Create a temporary array of items.
      std::vector<_variant_t> items;
      items.reserve(count);

      //////////
      // Load all the properties into the temporary array.
      //////////

      while (count--)
      {
         // Get the next item in the list.
         _variant_t item;
         CheckError(properties->Next(&item));

         // Convert it to a Property Entry.
         IADsPropertyEntryPtr entry(item);

         // Get the property name.
         BSTR bstrName;
         CheckError(entry->get_Name(&bstrName));
         _bstr_t name(bstrName, false);

         // Get the property value.
         _variant_t value;
         HRESULT hr = leaf->Get(name, &value);

         if (FAILED(hr))
         {
            if (hr == E_ADS_CANT_CONVERT_DATATYPE)
            {
               // This must be one of those nasty NTDS attributes that has
               // no VARIANT representation.
               continue;
            }

            _com_issue_error(hr);
         }

         // Create the property object and add it to the vector.
         items.push_back(new MyProperty(name, value, this));
      }

      //////////
      // Create and initialize an enumerator for the items.
      //////////

      CComPtr<EnumVARIANT> newEnum(new CComObject<EnumVARIANT>);

      _com_util::CheckError(newEnum->Init(items.begin(),
                                          items.end(),
                                          NULL,
                                          AtlFlagCopy));

      // Return it to the caller.
      (*pVal = newEnum)->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::Item(BSTR bstrName, IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   try
   {
      // Get the ADSI object.
      CComPtr<IDispatch> disp;
      _com_util::CheckError(node->GetObject(NULL,
                                            thePrefix + bstrName,
                                            &disp));

      // Convert to a DSObject.
      *ppObject = spawn(disp);
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::Create(BSTR bstrClass,
                              BSTR bstrName,
                              IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   try
   {
      // Create the ADSI object.
      CComPtr<IDispatch> disp;
      _com_util::CheckError(node->Create(bstrClass,
                                         thePrefix + bstrName,
                                         &disp));

      // Convert to a DSObject.
      *ppObject = spawn(disp);
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::MoveHere(IDataStoreObject* pObject,
                                BSTR bstrNewName)
{
   if (pObject == NULL) { return E_INVALIDARG; }

   try
   {
      using _com_util::CheckError;

      // Downcast to a DSObject.
      DSObject* obj = DSObject::narrow(pObject);

      // Get the absolute path of the object being moved.
      CComBSTR path;
      CheckError(obj->leaf->get_ADsPath(&path));

      // Is the object being renamed?
      _bstr_t newName(bstrNewName ? thePrefix + bstrNewName : _bstr_t());

      // Move it to this container.
      CComPtr<IDispatch> disp;
      CheckError(node->MoveHere(path, newName, &disp));

      //////////
      // Set the leaf to the new object.
      //////////

      CComPtr<IADs> ads;
      CheckError(disp->QueryInterface(__uuidof(IADs), (PVOID*)&ads));

      obj->leaf.Release();
      obj->leaf = ads;
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::Remove(BSTR bstrClass, BSTR bstrName)
{
   if (bstrClass == NULL) { return E_INVALIDARG; }

   try
   {
      _com_util::CheckError(node->Delete(bstrClass, thePrefix + bstrName));
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP DSObject::get_ChildCount(long *pVal)
{
   return node->get_Count(pVal);
}

STDMETHODIMP DSObject::get_NewChildEnum(IUnknown** pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   *pVal = NULL;

   try
   {
      // Get the ADSI enumerator.
      CComPtr<IUnknown> unk;
      _com_util::CheckError(node->get__NewEnum(&unk));

      // Convert to an IEnumVARIANT.
      CComPtr<IEnumVARIANT> enumVariant;
      _com_util::CheckError(unk->QueryInterface(__uuidof(IEnumVARIANT),
                                                (PVOID*)&enumVariant));

      // Construct our wrapper around the real enumerator.
      (*pVal = new DSEnumerator(this, enumVariant))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

IDataStoreObject* DSObject::spawn(IUnknown* subject)
{
   DSObject* child = new DSObject(subject);

   child->InternalAddRef();

   return child;
}


DSObject* DSObject::narrow(IUnknown* p)
{
   DSObject* object;

   using _com_util::CheckError;

   CheckError(p->QueryInterface(__uuidof(DSObject), (PVOID*)&object));

   // We can get away with InternalRelease since the caller must still
   // have a reference to this object.
   object->InternalRelease();

   return object;
}

HRESULT WINAPI DSObject::getContainer(void* pv, REFIID, LPVOID* ppv, DWORD_PTR)
{
   DSObject* obj = (DSObject*)pv;

   // If we don't have a node pointer, try to get one.
   if (obj->node == NULL)
   {
      obj->leaf->QueryInterface(__uuidof(IADsContainer), (PVOID*)&obj->node);
   }

   // If node is not NULL, then we are a container.
   if (obj->node != NULL)
   {
      *ppv = (IDataStoreContainer*)obj;

      obj->AddRef();

      return S_OK;
   }

   *ppv = NULL;

   return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\dsobject.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobject.h
//
// SYNOPSIS
//
//    This file declares the class DSObject.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    06/09/1998    Added dirty flag.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSOBJECT_H_
#define _DSOBJECT_H_

#include <activeds.h>
#include <downlevel.h>
#include <dsproperty.h>
#include <dstorex.h>
#include <iasdebug.h>

//////////
// 'Secret' UUID used to cast an interface to the implementing DSObject.
//////////
class __declspec(uuid("FD97280A-AA56-11D1-BB27-00C04FC2E20D")) DSObject;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DSObject
//
// DESCRIPTION
//
//    This class implements an object in an Active Directory namespace.
//
///////////////////////////////////////////////////////////////////////////////
class DSObject
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >,
     public IDispatchImpl< IDataStoreContainerEx,
                           &__uuidof(IDataStoreContainer),
                           &__uuidof(DataStore2Lib) >
{
public:

   // An ADSI property.
   typedef DSProperty<&__uuidof(DataStore2Lib)> MyProperty;

   // A list of properties.
   typedef CComQIPtr< IADsPropertyList,
                      &__uuidof(IADsPropertyList) > MyProperties;

DECLARE_NO_REGISTRY()
DECLARE_TRACELIFE(DSObject);

BEGIN_COM_MAP(DSObject)
   COM_INTERFACE_ENTRY_IID(__uuidof(DSObject), DSObject)
   COM_INTERFACE_ENTRY(IDataStoreObject)
   COM_INTERFACE_ENTRY_FUNC(__uuidof(IDataStoreContainer), 0, getContainer)
   COM_INTERFACE_ENTRY2(IDispatch, IDataStoreObject)
END_COM_MAP()

   DSObject(IUnknown* subject);
   ~DSObject() throw ();

   // Create a child DSObject.
   IDataStoreObject* spawn(IUnknown* subject);

//////////
// IUnknown
// I did not use CComObject<> because I need to deal with DSObject's directly.
//////////
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();
   STDMETHOD(Item)(BSTR bstrName, IDataStoreProperty** pVal);

//////////
// IDataStoreObjectEx
//////////
   STDMETHOD(get_PropertyCount)(long* pVal);
   STDMETHOD(get_NewPropertyEnum)(IUnknown** pVal);

//////////
// IDataStoreContainer
//////////
   STDMETHOD(Item)(/*[in]*/ BSTR bstrName,
                   /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(Create)(/*[in]*/ BSTR bstrClass,
                     /*[in]*/ BSTR bstrName,
                     /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(MoveHere)(/*[in]*/ IDataStoreObject* pObject,
                       /*[in]*/ BSTR bstrNewName);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrClass, /*[in]*/ BSTR bstrName);

//////////
// IDataStoreContainerEx
//////////
   STDMETHOD(get_ChildCount)(/*[out, retval]*/ long *pVal);
   STDMETHOD(get_NewChildEnum)(/*[out, retval]*/ IUnknown** pVal);

protected:
   // Narrows a COM Interface to the implementing DSObject.
   static DSObject* narrow(IUnknown* p);

   // Used to QI for IDataStoreContainer.
   static HRESULT WINAPI getContainer(void* pv, REFIID, LPVOID* ppv, DWORD_PTR)
      throw ();

   // Different representations of the subject.
   CComPtr<IADs> leaf;
   CComPtr<IADsContainer> node;

   // TRUE if the object has been modified since the last GetInfo.
   BOOL dirty;

   // The downlevel attributes.
   BSTR oldParms;
   DownlevelUser downlevel;

   // The prefix added to all RDN's.
   static _bstr_t thePrefix;

   // Well-known property names.
   static _bstr_t theNameProperty;
   static _bstr_t theUserParametersProperty;
};


#endif  // _DSOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\adsstore.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    adsstore.h
//
// SYNOPSIS
//
//    This file declares the class ADsDataStore.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ADSSTORE_H_
#define _ADSSTORE_H_

#include <iasads.h>
#include <resource.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ADsDataStore
//
// DESCRIPTION
//
//    This class implements IDataStore2 and provides the gateway into the
//    ADSI object space.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE ADsDataStore
   : public CComObjectRootEx< CComMultiThreadModel >,
     public CComCoClass< ADsDataStore, &__uuidof(ADsDataStore) >,
     public IDispatchImpl< IDataStore2,
                           &__uuidof(IDataStore2),
                           &__uuidof(DataStore2Lib) >
{
public:
IAS_DECLARE_REGISTRY(ADsDataStore, 1, IAS_REGISTRY_AUTO, DataStore2Lib)
DECLARE_NOT_AGGREGATABLE(ADsDataStore)

BEGIN_COM_MAP(ADsDataStore)
   COM_INTERFACE_ENTRY(IDataStore2)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//////////
// IDataStore2
//////////
   STDMETHOD(get_Root)(/*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(Initialize)(
                 /*[in]*/ BSTR bstrDSName,
                 /*[in]*/ BSTR bstrUserName,
                 /*[in]*/ BSTR bstrPassword
                  );
   STDMETHOD(OpenObject)(
                 /*[in]*/ BSTR bstrPath,
                 /*[out, retval]*/ IDataStoreObject** ppObject
                 );
   STDMETHOD(Shutdown)();

protected:
   _bstr_t userName;
   _bstr_t password;
   CComPtr<IDataStoreObject> root;
};

#endif  // _ADSSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\iasads.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasads.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    08/28/1998    Added Net and OleDB data stores.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

#include <newop.cpp>

CComModule _Module;
#include <atlimpl.cpp>

#include <adsstore.h>
#include <netstore.h>

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(ADsDataStore),   ADsDataStore)
   OBJECT_ENTRY(__uuidof(NetDataStore),   NetDataStore)
END_OBJECT_MAP()


//////////
// DLL Entry Point
//////////
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
  return  _Module.RegisterServer(TRUE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
  HRESULT hr = _Module.UnregisterServer();
  if (FAILED(hr)) return hr;

  hr = UnRegisterTypeLib(
           __uuidof(DataStore2Lib),
           1,
           0,
           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
           SYS_WIN32
           );
  
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\adsi\dsenum.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsenum.cpp
//
// SYNOPSIS
//
//    This file defines the class DSEnumerator.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <dsenum.h>
#include <dsobject.h>
#include <new>

DEFINE_TRACELIFE(DSEnumerator);

STDMETHODIMP_(ULONG) DSEnumerator::AddRef()
{
   return InterlockedIncrement(&refCount);
}

STDMETHODIMP_(ULONG) DSEnumerator::Release()
{
   LONG l = InterlockedDecrement(&refCount);

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP DSEnumerator::QueryInterface(const IID& iid, void** ppv)
{
   if (iid == __uuidof(IUnknown))
   {
      *ppv = static_cast<IUnknown*>(this);
   }
   else if (iid == __uuidof(IEnumVARIANT))
   {
      *ppv = static_cast<IEnumVARIANT*>(this);
   }
   else
   {
      return E_NOINTERFACE;
   }

   InterlockedIncrement(&refCount);

   return S_OK;
}

STDMETHODIMP DSEnumerator::Next(ULONG celt,
                                VARIANT* rgVar,
                                ULONG* pCeltFetched)
{
   HRESULT hr;

   try
   {
      if (pCeltFetched) { *pCeltFetched = 0; }

      // We have to use our own 'fetched' parameter, since we need the
      // number fetched even if the caller doesn't.
      ULONG fetched = 0;

      _com_util::CheckError(hr = subject->Next(celt, rgVar, &fetched));

      if (pCeltFetched) { *pCeltFetched = fetched; }

      ////////// 
      // Iterate through the returned objects ...
      ////////// 

      while (fetched--)
      {
         ////////// 
         // ... and convert them to DSObjects.
         ////////// 

         IDataStoreObject* obj = parent->spawn(V_DISPATCH(rgVar));

         V_DISPATCH(rgVar)->Release();
         
         V_DISPATCH(rgVar) = obj;

         ++rgVar;
      }
   }
   CATCH_AND_RETURN()

   return hr;
}

STDMETHODIMP DSEnumerator::Skip(ULONG celt)
{
   return subject->Skip(celt);
}

STDMETHODIMP DSEnumerator::Reset()
{
   return subject->Reset();
}

STDMETHODIMP DSEnumerator::Clone(IEnumVARIANT** ppEnum)
{
   if (ppEnum == NULL) { return E_INVALIDARG; }

   *ppEnum = NULL;

   try
   {
      // Get the real enumerator.
      CComPtr<IEnumVARIANT> newSubject;
      _com_util::CheckError(subject->Clone(&newSubject));

      // Construct our wrapper.
      (*ppEnum = new DSEnumerator(parent, newSubject))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\inc\downlevel.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    downlevel.h
//
// SYNOPSIS
//
//    Defines the class DownlevelUser.
//
// MODIFICATION HISTORY
//
//    02/10/1999    Original version.
//    08/23/1999    Add support for msRASSavedCallbackNumber.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DOWNLEVEL_H_
#define _DOWNLEVEL_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <mprapi.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DownlevelUser
//
// DESCRIPTION
//
//     Maps new style (name, value) pairs into a RAS_USER_0 struct.
//
///////////////////////////////////////////////////////////////////////////////
class DownlevelUser
{
public:
   DownlevelUser() throw ();

   HRESULT GetValue(BSTR bstrName, VARIANT* pVal) throw ();
   HRESULT PutValue(BSTR bstrName, VARIANT* pVal) throw ();

   HRESULT Restore(PCWSTR oldParameters) throw ();
   HRESULT Update(PCWSTR oldParameters, PWSTR *newParameters) throw ();

private:
   BOOL dialinAllowed;   // TRUE if the DialinPrivilege should be set.
   BOOL callbackAllowed; // TRUE if callback is allowed.
   BOOL phoneNumberSet;  // TRUE if phoneNumber is non-empty.
   BOOL savedNumberSet;  // TRUE if savedNumber is non-empty.

   WCHAR phoneNumber[MAX_PHONE_NUMBER_LEN + 1];
   WCHAR savedNumber[MAX_PHONE_NUMBER_LEN + 1];

   // Not implemented.
   DownlevelUser(const DownlevelUser&);
   DownlevelUser& operator=(const DownlevelUser&);
};

#endif  // _DOWNLEVEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\inc\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    This file defines the resource IDs for the various DataStore objects.
//
// MODIFICATION HISTORY
//
//    08/28/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_ADsDataStore    101
#define IDS_NetDataStore    102
#define IDS_OleDBDataStore  103

#endif  // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\downlevel.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    downlevel.cpp
//
// SYNOPSIS
//
//    Defines the class DownlevelUser.
//
// MODIFICATION HISTORY
//
//    02/10/1999    Original version.
//    08/23/1999    Add support for msRASSavedCallbackNumber.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasparms.h>
#include <downlevel.h>

// Fixed set of properties supported by the RAS_USER_0 struct.
const wchar_t DIALIN_NAME[]       = L"msNPAllowDialin";
const wchar_t SERVICE_NAME[]      = L"msRADIUSServiceType";
const wchar_t PHONE_NUMBER_NAME[] = L"msRADIUSCallbackNumber";
const wchar_t SAVED_NUMBER_NAME[] = L"msRASSavedCallbackNumber";

DownlevelUser::DownlevelUser() throw ()
   : dialinAllowed(FALSE),
     callbackAllowed(FALSE),
     phoneNumberSet(FALSE),
     savedNumberSet(FALSE)
{ }

HRESULT DownlevelUser::GetValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   //////////
   // Huge mess to map a (name, value) pair into the RAS_USER_0 struct.
   //////////

   VariantInit(pVal);

   HRESULT hr = S_OK;

   if (_wcsicmp(bstrName, DIALIN_NAME) == 0)
   {
      V_BOOL(pVal) = dialinAllowed ? VARIANT_TRUE : VARIANT_FALSE;

      V_VT(pVal) = VT_BOOL;
   }
   else if (_wcsicmp(bstrName, SERVICE_NAME) == 0)
   {
      if (callbackAllowed)
      {
         V_I4(pVal) = 4;   // Callback Framed

         V_VT(pVal) = VT_I4;
      }
      else
      {
         hr = DISP_E_MEMBERNOTFOUND;
      }
   }
   else if (_wcsicmp(bstrName, PHONE_NUMBER_NAME) == 0)
   {
      if (phoneNumberSet)
      {
         if (V_BSTR(pVal) = SysAllocString(phoneNumber))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
      }
      else
      {
         hr = DISP_E_MEMBERNOTFOUND;
      }
   }
   else if (_wcsicmp(bstrName, SAVED_NUMBER_NAME) == 0)
   {
      if (savedNumberSet)
      {
         if (V_BSTR(pVal) = SysAllocString(savedNumber))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
      }
      else
      {
         hr = DISP_E_MEMBERNOTFOUND;
      }
   }
   else
   {
      hr = DISP_E_MEMBERNOTFOUND;
   }

   return hr;
}

HRESULT DownlevelUser::PutValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   //////////
   // Huge mess to map the RAS_USER_0 struct into (name, value) pairs.
   //////////

   HRESULT hr = S_OK;

   if (_wcsicmp(bstrName, DIALIN_NAME) == 0)
   {
      if (V_VT(pVal) == VT_BOOL)
      {
         dialinAllowed = V_BOOL(pVal);
      }
      else if (V_VT(pVal) == VT_EMPTY)
	   {
         // VT_EMPTY == Control through policy == Denied for downlevel.
         dialinAllowed = VARIANT_FALSE;
      }
      else
      {
         hr = DISP_E_TYPEMISMATCH;
      }
   }
   else if (_wcsicmp(bstrName, SERVICE_NAME) == 0)
   {
      if (V_VT(pVal) == VT_EMPTY)
      {
         callbackAllowed = FALSE;
      }
      else if (V_VT(pVal) != VT_I4)
      {
         hr = DISP_E_TYPEMISMATCH;
      }
      else if (V_I4(pVal) != 4)
      {
         hr = E_INVALIDARG;
      }
      else
      {
         callbackAllowed = TRUE;
      }
   }
   else if (_wcsicmp(bstrName, PHONE_NUMBER_NAME) == 0)
   {
      if (V_VT(pVal) == VT_EMPTY)
      {
         phoneNumberSet = FALSE;
      }
      else if (V_VT(pVal) != VT_BSTR)
      {
         hr = DISP_E_TYPEMISMATCH;
      }
      else if (!V_BSTR(pVal))
      {
         hr = E_INVALIDARG;
      }
      else
      {
         wcsncpy(phoneNumber, V_BSTR(pVal), MAX_PHONE_NUMBER_LEN);

         phoneNumberSet = TRUE;
      }
   }
   else if (_wcsicmp(bstrName, SAVED_NUMBER_NAME) == 0)
   {
      if (V_VT(pVal) == VT_EMPTY)
      {
         savedNumberSet = FALSE;
      }
      else if (V_VT(pVal) != VT_BSTR)
      {
         hr = DISP_E_TYPEMISMATCH;
      }
      else if (!V_BSTR(pVal))
      {
         hr = E_INVALIDARG;
      }
      else
      {
         wcsncpy(savedNumber, V_BSTR(pVal), MAX_PHONE_NUMBER_LEN);

         savedNumberSet = TRUE;
      }
   }
   else if (V_VT(pVal) != VT_EMPTY)
   {
      // Trying to set a property that we don't recognize.
      hr = DISP_E_MEMBERNOTFOUND;
   }

   return hr;
}

HRESULT DownlevelUser::Restore(PCWSTR oldParameters) throw ()
{
   dialinAllowed = callbackAllowed = phoneNumberSet = savedNumberSet = FALSE;

   RAS_USER_0 ru0;
   DWORD error = IASParmsQueryRasUser0(oldParameters, &ru0);
   if (error != NO_ERROR)
   {
      return error;
   }

   dialinAllowed = (ru0.bfPrivilege & RASPRIV_DialinPrivilege);

   switch (ru0.bfPrivilege & RASPRIV_CallbackType)
   {
      case RASPRIV_AdminSetCallback:
         memcpy(phoneNumber, ru0.wszPhoneNumber, sizeof(phoneNumber));
         phoneNumberSet = TRUE;
         callbackAllowed = TRUE;
         break;

      case RASPRIV_CallerSetCallback:
         callbackAllowed = TRUE;
         // Fall through.

      default:
         memcpy(savedNumber, ru0.wszPhoneNumber, sizeof(savedNumber));
         savedNumberSet = TRUE;
   }

   return S_OK;
}

HRESULT DownlevelUser::Update(
                           PCWSTR oldParameters,
                           PWSTR *newParameters
                           ) throw ()
{
   RAS_USER_0 ru0;

   //////////
   // Set the bfPrivilege field based on our flags.
   //////////

   ru0.bfPrivilege = dialinAllowed ? RASPRIV_DialinPrivilege : 0;

   if (callbackAllowed && phoneNumberSet)
   {
      ru0.bfPrivilege |= RASPRIV_AdminSetCallback;
      memcpy(ru0.wszPhoneNumber, phoneNumber, sizeof(phoneNumber));
   }
   else
   {
      ru0.bfPrivilege |= (callbackAllowed ? RASPRIV_CallerSetCallback
                                          : RASPRIV_NoCallback);

      if (savedNumberSet)
      {
         memcpy(ru0.wszPhoneNumber, savedNumber, sizeof(savedNumber));
      }
      else
      {
         memset(ru0.wszPhoneNumber, 0, sizeof(ru0.wszPhoneNumber));
      }
   }

   DWORD error = IASParmsSetRasUser0(oldParameters, &ru0, newParameters);

   return HRESULT_FROM_WIN32(error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\iasnet.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasnet.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

#include <newop.cpp>

CComModule _Module;
#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


//////////
// DLL Entry Point
//////////
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
  return  _Module.RegisterServer(FALSE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
  return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\inc\dsproperty.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsproperty.h
//
// SYNOPSIS
//
//    This file declares the class DSProperty.
//
// MODIFICATION HISTORY
//
//    03/02/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DSPROPERTY_H_
#define _DSPROPERTY_H_

#include <datastore2.h>
#include <varvec.h>

//////////
//  ATL implementation of IEnumVARIANT
//////////
typedef CComEnum< IEnumVARIANT,
                  &__uuidof(IEnumVARIANT),
                  VARIANT,
                  _Copy<VARIANT>,
                  CComMultiThreadModelNoCS
                > EnumVARIANT;

//////////
// Test if a property is the special 'name' property.
//////////
inline bool isNameProperty(PCWSTR p) throw ()
{
   return (*p == L'N' || *p == L'n') ? !_wcsicmp(p, L"NAME") : false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DSProperty
//
// DESCRIPTION
//
//    This class implements the IDataStoreProperty interface. It represents
//    a single property of an IDataStoreObject.
//
///////////////////////////////////////////////////////////////////////////////
template <const GUID* plibid>
class DSProperty : 
   public CComObjectRootEx< CComMultiThreadModelNoCS >,
   public IDispatchImpl< IDataStoreProperty,
                         &__uuidof(IDataStoreProperty),
                         plibid >
{
public:

BEGIN_COM_MAP(DSProperty)
   COM_INTERFACE_ENTRY(IDataStoreProperty)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   DSProperty(const _bstr_t& propName,
              const _variant_t& propValue,
              IDataStoreObject* memberOf) throw (_com_error)
      : name(propName),
        value(propValue),
        owner(memberOf)
   { }

//////////
// IUnknown
//////////
	STDMETHOD_(ULONG, AddRef)()
   {
      return InternalAddRef();
   }

	STDMETHOD_(ULONG, Release)()
   {
      ULONG l = InternalRelease();
      if (l == 0) { delete this; }
      return l;
   }

	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
   {
      return _InternalQueryInterface(iid, ppvObject);
   }

//////////
// IDataStoreProperty
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal)
   {
      if (pVal == NULL) { return E_INVALIDARG; }
      *pVal = SysAllocString(name);
      return *pVal ? S_OK : E_OUTOFMEMORY;
   }

   STDMETHOD(get_Value)(/*[out, retval]*/ VARIANT* pVal)
   {
      if (pVal == NULL) { return E_INVALIDARG; }
      return VariantCopy(pVal, &value);
   }

   STDMETHOD(get_ValueEx)(/*[out, retval]*/ VARIANT* pVal)
   {
      if (pVal == NULL) { return E_INVALIDARG; }

      // Is the value an array ?
      if (V_VT(&value) != (VT_VARIANT | VT_ARRAY))
      {
         // No, so we have to convert it to one.

         try
         {
            // Make sure we can sucessfully copy the VARIANT, ...
            _variant_t tmp(value);

            // ... then allocate a SAFEARRAY with a single element.
            CVariantVector<VARIANT> multi(pVal, 1);

            // Load the single value in.
            multi[0] = tmp.Detach();
         }
         CATCH_AND_RETURN()

         return S_OK;
      }

      return VariantCopy(pVal, &value);
   }

   STDMETHOD(get_Owner)(/*[out, retval]*/ IDataStoreObject** pVal)
   {
      if (pVal == NULL) { return E_INVALIDARG; }
      if (*pVal = owner) { owner.p->AddRef(); }
      return S_OK;
   }

protected:
   _bstr_t name;                     // Property name.
   _variant_t value;                 // Property value.
   CComPtr<IDataStoreObject> owner;  // Object to which this property belongs.
};

#endif  // _DSPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netroot.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    netroot.cpp
//
// SYNOPSIS
//
//    This file defines the class NetworkRoot.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    07/08/1998    Check if the server name is already a UNC.
//    02/11/1999    Get rid of parent parameter.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <netutil.h>
#include <netroot.h>
#include <netserver.h>

NetworkRoot::NetworkRoot()
{
   _Module.Lock();
}


NetworkRoot::~NetworkRoot() throw()
{
   _Module.Unlock();
}


//////////
// IUnknown implementation is copied from CComObject<>.
//////////

STDMETHODIMP_(ULONG) NetworkRoot::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) NetworkRoot::Release()
{
   ULONG l = InternalRelease();

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP NetworkRoot::QueryInterface(REFIID iid, void ** ppvObject)
{
   return _InternalQueryInterface(iid, ppvObject);
}

STDMETHODIMP NetworkRoot::get_Name(BSTR* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::get_Class(BSTR* pVal)
{
   if (!pVal) { return E_INVALIDARG; }

   *pVal = SysAllocString(L"NetworkRoot");

   return *pVal ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP NetworkRoot::get_GUID(BSTR* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::get_Container(IDataStoreContainer** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::GetValue(BSTR bstrName, VARIANT* pVal)
{
   return DISP_E_MEMBERNOTFOUND;
}

STDMETHODIMP NetworkRoot::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   return DISP_E_MEMBERNOTFOUND;
}

STDMETHODIMP NetworkRoot::PutValue(BSTR bstrName, VARIANT* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::Update()
{
   return S_OK;
}

STDMETHODIMP NetworkRoot::Restore()
{
   return S_OK;
}

STDMETHODIMP NetworkRoot::get__NewEnum(IUnknown** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::Item(BSTR bstrName, IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   try
   {
      // Determine the correct servername
      if (bstrName != NULL && *bstrName != L'\0' && *bstrName != L'\\')
      {
         // Allocate a temporary buffer.
         size_t len = wcslen(bstrName) + 3;
         PWSTR servername = (PWSTR)_alloca(len * sizeof(WCHAR));

         // Prepend the double backslash.
         wcscpy(servername, L"\\\\");
         wcscat(servername, bstrName);

         // Create the object.
         (*ppObject = new NetworkServer(servername))->AddRef();
      }
      else
      {
         (*ppObject = new NetworkServer(bstrName))->AddRef();
      }
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetworkRoot::get_Count(long *pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::Create(BSTR bstrClass,
                                 BSTR bstrName,
                                 IDataStoreObject** ppObject)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::MoveHere(IDataStoreObject* pObject,
                                   BSTR bstrNewName)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkRoot::Remove(BSTR bstrClass, BSTR bstrName)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netroot.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    netroot.h
//
// SYNOPSIS
//
//    This file declares the class NetworkRoot.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETROOT_H_
#define _NETROOT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <dstorex.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NetworkRoot
//
// DESCRIPTION
//
//    This class implements the root of the Networking namespace.
//
///////////////////////////////////////////////////////////////////////////////
class NetworkRoot
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >,
     public IDispatchImpl< IDataStoreContainer,
                           &__uuidof(IDataStoreContainer),
                           &__uuidof(DataStore2Lib) >
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(NetworkRoot)
   COM_INTERFACE_ENTRY(IDataStoreContainer)
   COM_INTERFACE_ENTRY(IDataStoreObject)
   COM_INTERFACE_ENTRY2(IDispatch, IDataStoreContainer)
END_COM_MAP()

NetworkRoot();
~NetworkRoot() throw();

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);      
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();

//////////
// IDataStoreContainer
//////////
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** pVal);
   STDMETHOD(Item)(/*[in]*/ BSTR bstrName,
                   /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(Create)(/*[in]*/ BSTR bstrClass,
                     /*[in]*/ BSTR bstrName,
                     /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(MoveHere)(/*[in]*/ IDataStoreObject* pObject, 
                       /*[in]*/ BSTR bstrNewName);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrClass, /*[in]*/ BSTR bstrName);
};


#endif  // _NETROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netserver.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    netserver.cpp
//
// SYNOPSIS
//
//    This file defines the class NetworkServer.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    07/09/1998    Modified to handle downlevel users.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <netserver.h>
#include <netuser.h>
#include <netutil.h>
#include <rasuser.h>

const wchar_t DOWNLEVEL_NAME[] = L"downlevel";

NetworkServer::NetworkServer(PCWSTR server)
   : servername(server), downlevel(FALSE)
{
   _Module.Lock();
}


NetworkServer::~NetworkServer() throw()
{
   _Module.Unlock();
}


//////////
// IUnknown implementation is copied from CComObject<>.
//////////

STDMETHODIMP_(ULONG) NetworkServer::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) NetworkServer::Release()
{
   ULONG l = InternalRelease();

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP NetworkServer::QueryInterface(REFIID iid, void ** ppvObject)
{
   return _InternalQueryInterface(iid, ppvObject);
}

STDMETHODIMP NetworkServer::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   try
   {
      *pVal = servername.copy();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetworkServer::get_Class(BSTR* pVal)
{
   if (!pVal) { return E_INVALIDARG; }

   *pVal = SysAllocString(L"NetworkServer");

   return *pVal ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP NetworkServer::get_GUID(BSTR* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::get_Container(IDataStoreContainer** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::GetValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   VariantInit(pVal);

   if (_wcsicmp(bstrName, DOWNLEVEL_NAME) == 0)
   {
      V_VT(pVal) = VT_BOOL;
      
      V_BOOL(pVal) = downlevel ? VARIANT_TRUE : VARIANT_FALSE;
      
      return S_OK;
   }

   return DISP_E_MEMBERNOTFOUND;
}

STDMETHODIMP NetworkServer::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::PutValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   if (_wcsicmp(bstrName, DOWNLEVEL_NAME) == 0)
   {
      if (V_VT(pVal) == VT_BOOL)
      {
         downlevel = V_BOOL(pVal);

         return S_OK;
      }

      return DISP_E_TYPEMISMATCH;
   }

   return DISP_E_MEMBERNOTFOUND;
}

STDMETHODIMP NetworkServer::Update()
{
   return S_OK;
}

STDMETHODIMP NetworkServer::Restore()
{
   return S_OK;
}

STDMETHODIMP NetworkServer::get__NewEnum(IUnknown** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::Item(BSTR bstrName, IDataStoreObject** ppObject)
{
   if (bstrName == NULL || ppObject == NULL) { return E_INVALIDARG; }

   try
   {
      if (!downlevel)
      {
         *ppObject = new NetworkUser(servername, bstrName);
      }
      else
      {
         *ppObject = new RASUser(servername, bstrName);
      }

      (*ppObject)->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetworkServer::get_Count(long *pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::Create(BSTR bstrClass,
                                   BSTR bstrName,
                                   IDataStoreObject** ppObject)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::MoveHere(IDataStoreObject* pObject,
                                     BSTR bstrNewName)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkServer::Remove(BSTR bstrClass, BSTR bstrName)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netstore.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netstore.h
//
// SYNOPSIS
//
//    This file declares the class NetDataStore.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETSTORE_H_
#define _NETSTORE_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasads.h>
#include <resource.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NetDataStore
//
// DESCRIPTION
//
//    This class implements IDataStore2 and provides the gateway into the
//    Networking object space.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NetDataStore
   : public CComObjectRootEx< CComMultiThreadModel >,
     public CComCoClass< NetDataStore, &__uuidof(NetDataStore) >,
     public IDispatchImpl< IDataStore2,
                           &__uuidof(IDataStore2),
                           &__uuidof(DataStore2Lib) >
{
public:
IAS_DECLARE_REGISTRY(NetDataStore, 1, IAS_REGISTRY_AUTO, DataStore2Lib)
DECLARE_NOT_AGGREGATABLE(NetDataStore)

BEGIN_COM_MAP(NetDataStore)
   COM_INTERFACE_ENTRY(IDataStore2)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//////////
// IDataStore2
//////////
   STDMETHOD(get_Root)(/*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(Initialize)(
                 /*[in]*/ BSTR bstrDSName,
                 /*[in]*/ BSTR bstrUserName,
                 /*[in]*/ BSTR bstrPassword
                  );
   STDMETHOD(OpenObject)(
                 /*[in]*/ BSTR bstrPath,
                 /*[out, retval]*/ IDataStoreObject** ppObject
                 );
   STDMETHOD(Shutdown)();

protected:
   // The root object.
   CComPtr<IDataStoreObject> root;
};

#endif  // _NETSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netserver.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    netserver.h
//
// SYNOPSIS
//
//    This file declares the class NetworkServer.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    07/09/1998    Modified to handle downlevel users.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETSERVER_H_
#define _NETSERVER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <dstorex.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NetworkServer
//
// DESCRIPTION
//
//    This class implements a network server.
//
///////////////////////////////////////////////////////////////////////////////
class NetworkServer
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >,
     public IDispatchImpl< IDataStoreContainer,
                           &__uuidof(IDataStoreContainer),
                           &__uuidof(DataStore2Lib) >
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(NetworkServer)
   COM_INTERFACE_ENTRY(IDataStoreContainer)
   COM_INTERFACE_ENTRY(IDataStoreObject)
   COM_INTERFACE_ENTRY2(IDispatch, IDataStoreContainer)
END_COM_MAP()

   NetworkServer(PCWSTR server);
   ~NetworkServer() throw();

   //////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);      
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();

//////////
// IDataStoreContainer
//////////
   STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** pVal);
   STDMETHOD(Item)(/*[in]*/ BSTR bstrName,
                   /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
   STDMETHOD(Create)(/*[in]*/ BSTR bstrClass,
                     /*[in]*/ BSTR bstrName,
                     /*[out, retval]*/ IDataStoreObject** ppObject);
   STDMETHOD(MoveHere)(/*[in]*/ IDataStoreObject* pObject,
                       /*[in]*/ BSTR bstrNewName);
   STDMETHOD(Remove)(/*[in]*/ BSTR bstrClass, /*[in]*/ BSTR bstrName);

protected:
   // The server represented by this object.
   const _bstr_t servername;

   // TRUE if downlevel API's should be used to access users.
   BOOL downlevel;
};


#endif  // _NETSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netuser.h
//
// SYNOPSIS
//
//    This file declares the class NetworkUser.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETUSER_H_
#define _NETUSER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <downlevel.h>
#include <dstorex.h>
#include <netutil.h>
#include <iasdebug.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NetworkUser
//
// DESCRIPTION
//
//    This class implements a network user.
//
///////////////////////////////////////////////////////////////////////////////
class NetworkUser
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >
{
public:

DECLARE_NO_REGISTRY()
DECLARE_TRACELIFE(NetworkUser);

BEGIN_COM_MAP(NetworkUser)
   COM_INTERFACE_ENTRY(IDataStoreObject)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   NetworkUser(const _bstr_t& server, const _bstr_t& user);
   ~NetworkUser() throw ();

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);      
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();

protected:

   bool isDirty() const throw () { return parms != usri2->usri2_parms; }

   // Network server containing the user account.
   const _bstr_t servername;

   // SAM account name.
   const _bstr_t username;

   // User info buffer.
   NetBuffer<PUSER_INFO_2> usri2;

   // Manages the RAS_USER_0 struct.
   DownlevelUser downlevel;

   // Updated user parameters.
   PWSTR parms;
};

#endif  // _NETUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netutil.h
//
// SYNOPSIS
//
//    This file pulls in various useful headers and defines the NetBuffer
//    class.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    08/13/1998    Removed obsolete w32util header.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NETUTIL_H_
#define _NETUTIL_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasutil.h>
#include <lm.h>
#include <nocopy.h>

//////////
// This class makes it easier to work with NetAPI
//////////
template <class T>
class NetBuffer : NonCopyable
{
public:
   explicit NetBuffer(T t = T()) throw ()
      : buffer(t)
   { }

   ~NetBuffer() throw ()
   {
      NetApiBufferFree(buffer);
   }

   void attach(T t) throw ()
   {
      NetApiBufferFree(buffer);

      buffer = t;
   }

   PBYTE* operator&() throw ()
   {
      return (PBYTE*)&buffer;
   }

   T operator->() const throw ()
   {
      return buffer;
   }

private:
   T buffer;
};

#endif  // _NETUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    netuser.cpp
//
// SYNOPSIS
//
//    This file defines the class NetworkUser.
//
// MODIFICATION HISTORY
//
//    02/20/1998    Original version.
//    07/08/1998    Set the UF_PASSWD_NOTREQD flag.
//    08/26/1998    Use level 1013 for NetUserSetInfo.
//    10/19/1998    Switch to SAM version of IASParmsXXX.
//    02/11/1999    Keep downlevel parameters in sync.
//    03/16/1999    Return error if downlevel update fails.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <dsproperty.h>
#include <netuser.h>
#include <varvec.h>
#include <iasparms.h>

NetworkUser::NetworkUser(const _bstr_t& server, const _bstr_t& user)
   : servername(server),
     username(user)
{
   _Module.Lock();
   _w32_util::CheckError(NetUserGetInfo(servername, username, 2, &usri2));

   parms = usri2->usri2_parms;

   downlevel.Restore(parms);
}

NetworkUser::~NetworkUser() throw ()
{
   if (isDirty()) { IASParmsFreeUserParms(parms); }
   _Module.Unlock();
}

//////////
// IUnknown implementation is copied from CComObject<>.
//////////

STDMETHODIMP_(ULONG) NetworkUser::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) NetworkUser::Release()
{
   ULONG l = InternalRelease();

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP NetworkUser::QueryInterface(REFIID iid, void ** ppvObject)
{
   return _InternalQueryInterface(iid, ppvObject);
}

STDMETHODIMP NetworkUser::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   try
   {
      *pVal = username.copy();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetworkUser::get_Class(BSTR* pVal)
{
   if (!pVal) { return E_INVALIDARG; }

   *pVal = SysAllocString(L"NetworkUser");

   return *pVal ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP NetworkUser::get_GUID(BSTR* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkUser::get_Container(IDataStoreContainer** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP NetworkUser::GetValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   if (isNameProperty(bstrName))
   {
      VariantInit(pVal);

      V_BSTR(pVal) = SysAllocString(username);

      return (V_BSTR(pVal)) ? (V_VT(pVal) = VT_BSTR), S_OK : E_OUTOFMEMORY;
   }

   HRESULT hr = IASParmsQueryUserProperty(parms, bstrName, pVal);

   // Currently, the SDO's expect DISP_E_MEMBERNOTFOUND if the property
   // hasn't been set.
   if (SUCCEEDED(hr) && V_VT(pVal) == VT_EMPTY)
   {
      hr = DISP_E_MEMBERNOTFOUND;
   }

   return hr;
}

STDMETHODIMP NetworkUser::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   RETURN_ERROR(GetValue(bstrName, pVal));

   // Is it an array ?
   if (V_VT(pVal) != (VT_VARIANT | VT_ARRAY))
   {
      // No, so we have to convert it to one.

      try
      {
         // Save the single value.
         _variant_t single(*pVal, false);

         // Create a SAFEARRAY with a single element.
         CVariantVector<VARIANT> multi(pVal, 1);

         // Load the single value in.
         multi[0] = single.Detach();
      }
      CATCH_AND_RETURN()
   }

   return S_OK;
}

STDMETHODIMP NetworkUser::PutValue(BSTR bstrName, VARIANT* pVal)
{
   PWSTR newParms;
   HRESULT hr = IASParmsSetUserProperty(
                    parms,
                    bstrName,
                    pVal,
                    &newParms
                    );

   if (SUCCEEDED(hr))
   {
      // Free the old parameters ...
      if (isDirty()) { IASParmsFreeUserParms(parms); }

      // ... and swap in the new ones.
      parms = newParms;

      // Synch up the downlevel parameters.
      downlevel.PutValue(bstrName, pVal);
   }

   return hr;
}

STDMETHODIMP NetworkUser::Update()
{
   // If we haven't made any changes, there's nothing to do.
   if (!isDirty()) { return S_OK; }

   // Load the downlevel parameters.
   PWSTR newParms;
   HRESULT hr = downlevel.Update(parms, &newParms);
   if (FAILED(hr)) { return hr; }

   // Swap these in.
   IASParmsFreeUserParms(parms);
   parms = newParms;

   // Update the user object.
   USER_INFO_1013 usri1013 = { parms };
   NET_API_STATUS status = NetUserSetInfo(servername,
                                          username,
                                          1013,
                                          (LPBYTE)&usri1013,
                                          NULL);

   return HRESULT_FROM_WIN32(status);
}

STDMETHODIMP NetworkUser::Restore()
{
   // Discard any changes.
   if (isDirty()) { IASParmsFreeUserParms(parms); }

   // Get a fresh USER_INFO_2 struct.
   PUSER_INFO_2 fresh;
   NET_API_STATUS status = NetUserGetInfo(servername,
                                          username,
                                          2,
                                          (PBYTE*)&fresh);

   // We succeeded so attach the fresh struct.
   if (status == NERR_Success) { usri2.attach(fresh); }

   // For now we're clean, so parms just points into the struct.
   parms = usri2->usri2_parms;

   // Restore the downlevel parms.
   downlevel.Restore(parms);

   return HRESULT_FROM_WIN32(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\netstore.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    netstore.cpp
//
// SYNOPSIS
//
//    This file defines the class NetDataStore.
//
// MODIFICATION HISTORY
//
//    02/24/1998    Original version.
//    03/17/1998    Implemented OpenObject method.
//    02/11/1999    Get rid of parent parameter.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

#include <netutil.h>
#include <netroot.h>
#include <netstore.h>
#include <netuser.h>

STDMETHODIMP NetDataStore::get_Root(IDataStoreObject** ppObject)
{
   if (ppObject == NULL) { return E_INVALIDARG; }

   if (*ppObject = root) { (*ppObject)->AddRef(); }

   return S_OK;
}

STDMETHODIMP NetDataStore::Initialize(BSTR /* bstrDSName   */,
                                      BSTR /* bstrUserName */,
                                      BSTR /* bstrPassword */)
{
   try
   {
      // Create the root.
      root = new NetworkRoot;
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetDataStore::OpenObject(BSTR bstrPath,
                                      IDataStoreObject** ppObject)
{
   if (bstrPath == NULL || ppObject == NULL) { return E_INVALIDARG; }

   ////////// 
   // 'Crack' the path into a servername and username.
   ////////// 

   PWSTR servername, username;

   if (bstrPath[0] == L'\\')
   {
      if (bstrPath[1] != L'\\')
      {
         return HRESULT_FROM_WIN32(NERR_InvalidComputer);
      }

      // Make a local copy so we can modify the string.
      size_t len = (wcslen(bstrPath) + 1) * sizeof(wchar_t);
      servername = (PWSTR)memcpy(_alloca(len), bstrPath, len);
  
      // Find the start of the username.
      username = wcschr(servername + 2, L'\\');

      if (!username)
      {
         return HRESULT_FROM_WIN32(NERR_BadUsername);
      }
      
      *username++ = L'\0';
   }
   else
   {
      // Doesn't begin with \\, so it's a local user.

      servername = NULL;
      
      username = bstrPath;
   }

   try
   {
      (*ppObject = new NetworkUser(servername, username))->AddRef();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP NetDataStore::Shutdown()
{
   root.Release();

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\rasuser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    rasuser.cpp
//
// SYNOPSIS
//
//    This file defines the class RASUser.
//
// MODIFICATION HISTORY
//
//    07/09/1998    Original version.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <dsproperty.h>
#include <rasuser.h>
#include <iasparms.h>

RASUser::RASUser(const _bstr_t& server, const _bstr_t& user)
   : servername(server),
     username(user)
{
   _Module.Lock();
   _w32_util::CheckError(NetUserGetInfo(servername, username, 2, &usri2));
   _w32_util::CheckError(downlevel.Restore(usri2->usri2_parms));
}

RASUser::~RASUser() throw()
{
   _Module.Unlock();
}


//////////
// IUnknown implementation is copied from CComObject<>.
//////////

STDMETHODIMP_(ULONG) RASUser::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) RASUser::Release()
{
   ULONG l = InternalRelease();

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP RASUser::QueryInterface(REFIID iid, void ** ppvObject)
{
   return _InternalQueryInterface(iid, ppvObject);
}

STDMETHODIMP RASUser::get_Name(BSTR* pVal)
{
   if (pVal == NULL) { return E_INVALIDARG; }

   try
   {
      *pVal = username.copy();
   }
   CATCH_AND_RETURN()

   return S_OK;
}

STDMETHODIMP RASUser::get_Class(BSTR* pVal)
{
   if (!pVal) { return E_INVALIDARG; }

   *pVal = SysAllocString(L"RASUser");

   return *pVal ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP RASUser::get_GUID(BSTR* pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP RASUser::get_Container(IDataStoreContainer** pVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP RASUser::GetValue(BSTR bstrName, VARIANT* pVal)
{
   if (bstrName == NULL || pVal == NULL) { return E_INVALIDARG; }

   if (isNameProperty(bstrName))
   {
      VariantInit(pVal);

      V_BSTR(pVal) = SysAllocString(username);

      return (V_BSTR(pVal)) ? (V_VT(pVal) = VT_BSTR), S_OK : E_OUTOFMEMORY;
   }

   return downlevel.GetValue(bstrName, pVal);
}

STDMETHODIMP RASUser::GetValueEx(BSTR bstrName, VARIANT* pVal)
{
   return GetValue(bstrName, pVal);
}

STDMETHODIMP RASUser::PutValue(BSTR bstrName, VARIANT* pVal)
{
   HRESULT hr;

   if (isNameProperty(bstrName))
   {
      hr = E_INVALIDARG;
   }
   else
   {
      // Proxy to the DownlevelUser object.
      hr = downlevel.PutValue(bstrName, pVal);
   }

   return hr;
}

STDMETHODIMP RASUser::Update()
{
   // Load the downlevel parameters.
   PWSTR newParms;
   HRESULT hr = downlevel.Update(usri2->usri2_parms, &newParms);
   if (FAILED(hr)) { return hr; }

   // Update the user object.
   USER_INFO_1013 usri1013 = { newParms };
   NET_API_STATUS status = NetUserSetInfo(servername,
                                          username,
                                          1013,
                                          (LPBYTE)&usri1013,
                                          NULL);
   LocalFree(newParms);

   return HRESULT_FROM_WIN32(status);
}

STDMETHODIMP RASUser::Restore()
{
   // Get a fresh USER_INFO_2 struct.
   PUSER_INFO_2 fresh;
   NET_API_STATUS status = NetUserGetInfo(servername,
                                          username,
                                          2,
                                          (PBYTE*)&fresh);

   // We succeeded so attach the fresh struct.
   if (status == NERR_Success)
   {
      usri2.attach(fresh);
      downlevel.Restore(usri2->usri2_parms);
   }

   return HRESULT_FROM_WIN32(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\datastore2\net\rasuser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    rasuser.h
//
// SYNOPSIS
//
//    This file declares the class RASUser.
//
// MODIFICATION HISTORY
//
//    07/09/1998    Original version.
//    02/11/1999    Keep downlevel parameters in sync.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RASUSER_H_
#define _RASUSER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <downlevel.h>
#include <dstorex.h>
#include <netutil.h>
#include <iasdebug.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RASUser
//
// DESCRIPTION
//
//    This class implements a network user.
//
///////////////////////////////////////////////////////////////////////////////
class RASUser
   : public CComObjectRootEx< CComMultiThreadModel >,
     public IDispatchImpl< IDataStoreObjectEx,
                           &__uuidof(IDataStoreObject),
                           &__uuidof(DataStore2Lib) >
{
public:

DECLARE_NO_REGISTRY()
DECLARE_TRACELIFE(RASUser);

BEGIN_COM_MAP(RASUser)
   COM_INTERFACE_ENTRY(IDataStoreObject)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   RASUser(const _bstr_t& server, const _bstr_t& user);
   ~RASUser() throw();

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// IDataStoreObject
//////////
   STDMETHOD(get_Name)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Class)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR* pVal);
   STDMETHOD(get_Container)(/*[out, retval]*/ IDataStoreContainer** pVal);      
   STDMETHOD(GetValue)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(GetValueEx)(/*[in]*/ BSTR bstrName,
                         /*[out, retval]*/ VARIANT* pVal);
   STDMETHOD(PutValue)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT* pVal);
   STDMETHOD(Update)();
   STDMETHOD(Restore)();

protected:
   // Network server containing the user account.
   const _bstr_t servername;

   // SAM account name.
   const _bstr_t username;

   // User info buffer.
   NetBuffer<PUSER_INFO_2> usri2;

   // Manages the RAS_USER_0 struct.
   DownlevelUser downlevel;
};

#endif  // _RASUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\dsconnection.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-2001 Microsoft Corporation all rights reserved.
//
// Module:      dsconnection.cpp
//
// Project:     Everest
//
// Description: data store connection implementation
//
// Author:      TLP
//
// When         Who    What
// ----         ---    ----
// 4/6/98       TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "dsconnection.h"
#include "sdo.h"
#include <dsgetdc.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <winsock2.h>

namespace
{
   BOOL
   WINAPI
   IsComputerLocalEx(
       PCWSTR computerName,
       COMPUTER_NAME_FORMAT nameType
       ) throw ()
   {
      WCHAR buffer[256];
      DWORD nSize = sizeof(buffer)/sizeof(WCHAR);
      BOOL success = GetComputerNameEx(
                         nameType,
                         buffer,
                         &nSize
                         );

      return success && !_wcsicmp(buffer, computerName);
   }

   BOOL
   WINAPI
   IsComputerLocal(
       PCWSTR computerName
       ) throw ()
   {
      return IsComputerLocalEx(
                 computerName,
                 ComputerNameNetBIOS
                 ) ||
             IsComputerLocalEx(
                 computerName,
                 ComputerNameDnsHostname
                 ) ||
             IsComputerLocalEx(
                 computerName,
                 ComputerNameDnsFullyQualified
                 ) ||
             IsComputerLocalEx(
                 computerName,
                 ComputerNamePhysicalNetBIOS
                 ) ||
             IsComputerLocalEx(
                 computerName,
                 ComputerNamePhysicalDnsHostname
                 ) ||
             IsComputerLocalEx(
                 computerName,
                 ComputerNamePhysicalDnsFullyQualified
                 );
   }
}

///////////////////////////////////////////////////////////////////////////
CDsConnection::CDsConnection()
   : m_eState(DISCONNECTED),
     m_bIsRemoteServer(false),
     m_bIsMixedMode(false),
     m_bInitializedDS(false),
     m_pDSRoot(NULL),
     m_pDSRootObject(NULL),
     m_pDSRootContainer(NULL)
{
   m_szServerName[0] = '\0';
   m_szConfigPath[0] = '\0';
}

///////////////////////////////////////////////////////////////////////////
CDsConnection::~CDsConnection()
{
   _ASSERT( DISCONNECTED == m_eState );
}


///////////////////////////////////////////////////////////////////////////
bool CDsConnection::SetServerName(LPCWSTR lpszServerName, bool bLocal)
{
   bool success = false;

   if ((lpszServerName != 0) && (*lpszServerName != L'\0'))
   {
      ////////
      // Caller wants a specific server.
      ////////

      // Strip any leading backslashes.
      lpszServerName += wcsspn(lpszServerName, L"\\");

      // Make sure the name will fit in our buffer.
      if (wcslen(lpszServerName) <= IAS_MAX_SERVER_NAME)
      {
         // Save the name ...
         wcscpy(m_szServerName, lpszServerName);

         // ... and determine if it's local or remote.
         m_bIsRemoteServer = !IsComputerLocal(m_szServerName);

         success = true;
      }
   }
   else if (bLocal)
   {
      ////////
      // Caller wants the local machine.
      ////////

      DWORD dwSize = IAS_MAX_SERVER_NAME + 1;
      GetComputerNameW(m_szServerName, &dwSize);
      m_bIsRemoteServer = false;
      success = true;
   }
   else
   {
      ////////
      // Caller wants a domain controller.
      ////////

      PDOMAIN_CONTROLLER_INFOW dci;
      DWORD error = DsGetDcNameW(
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        DS_DIRECTORY_SERVICE_REQUIRED,
                        &dci
                        );
      if (!error && dci->DomainControllerName)
      {
         success = SetServerName(dci->DomainControllerName, false);
         NetApiBufferFree(dci);
      }
   }

   IASTracePrintf("INFO CDsConnection::SetServerName ServerName = %S \n"
                  "m_szServerName = %S IsRemoteServer %d Success = %d\n",
                  lpszServerName,
                  m_szServerName,
                  m_bIsRemoteServer,
                  success);
   return success;
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionIAS::Connect(
                    /*[in]*/ LPCWSTR   lpszServerName,
                    /*[in]*/ LPCWSTR   lpszUserName,
                    /*[in]*/ LPCWSTR   lpszPassword
                         )
{
    HRESULT  hr = E_FAIL;
   _ASSERT( DISCONNECTED == m_eState );
   if ( SetServerName(lpszServerName, true) )
   {
      m_eState = CONNECTED;
      hr = S_OK;
   }
   else
   {
      m_szServerName[0] = '\0';
      m_szConfigPath[0] = '\0';
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionIAS::InitializeDS()
{
   HRESULT  hr = S_OK;
   WCHAR   szConfigPathBuff[IAS_MAX_CONFIG_PATH + 16];

   _ASSERT( CONNECTED == m_eState );
   if ( ! m_bInitializedDS )
   {
      // Set the path to the IAS configuration database
      //
      hr = E_FAIL;
      if ( SetConfigPath() )
      {
         // Create and initialize the IAS data store
         //
         CComPtr<IDataStore2> pDSRoot;
         hr = CoCreateInstance(
                           __uuidof(OleDBDataStore),
                           NULL,
                           CLSCTX_SERVER,
                           __uuidof(IDataStore2),
                           (void**)&pDSRoot
                         );

         if ( SUCCEEDED(hr) )
         {
            // We need to give the object permission to impersonate us. There's
            // no reason to abort if this fails; we'll just try with the
            // existing blanket.
            CoSetProxyBlanket(
                pDSRoot,
                RPC_C_AUTHN_DEFAULT,
                RPC_C_AUTHZ_DEFAULT,
                COLE_DEFAULT_PRINCIPAL,
                RPC_C_AUTHN_LEVEL_DEFAULT,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,
                EOAC_DEFAULT
                );

            wsprintf(
                    szConfigPathBuff,
                    TEXT("%s\\%s"),
                    m_szConfigPath,
                    IAS_CONFIG_DB_LOCATION
                  );

            CComBSTR bstrConfigPath(szConfigPathBuff);
            if (!bstrConfigPath) { return E_OUTOFMEMORY; }

            hr = pDSRoot->Initialize(
                                bstrConfigPath,
                                NULL,
                                NULL
                              );
            if ( SUCCEEDED(hr) )
            {
               // Save references to the data store root object and root object container
               //
               CComPtr<IDataStoreObject> pDSRootObject;
               hr = pDSRoot->get_Root(&pDSRootObject);
               if ( SUCCEEDED(hr) )
               {
                  CComPtr<IDataStoreContainer> pDSRootContainer;
                  hr = pDSRootObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSRootContainer);
                  if ( SUCCEEDED(hr) )
                  {
                     pDSRoot.p->AddRef();
                     pDSRootObject.p->AddRef();
                     pDSRootContainer.p->AddRef();
                     m_pDSRoot = pDSRoot;
                     m_pDSRootObject = pDSRootObject;
                     m_pDSRootContainer = pDSRootContainer;
                     m_bInitializedDS = true;
                  }
               }
               if ( FAILED(hr) )
                  pDSRoot->Shutdown();
            }
         }
      }
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////////
void  CDsConnectionIAS::Disconnect()
{
   if ( m_pDSRootContainer )
   {
      m_pDSRootContainer->Release();
      m_pDSRootContainer = NULL;
   }
   if ( m_pDSRootObject )
   {
      m_pDSRootObject->Release();
      m_pDSRootObject = NULL;
   }
   if ( m_pDSRoot )
   {
      m_pDSRoot->Shutdown();
      m_pDSRoot->Release();
      m_pDSRoot = NULL;
   }
   m_szServerName[0] = '\0';
   m_szConfigPath[0] = '\0';
   m_eState = DISCONNECTED;
}


///////////////////////////////////////////////////////////////////////////
bool  CDsConnectionIAS::SetConfigPath()
{
   bool bReturn = false;
   DWORD dwSize = IAS_MAX_CONFIG_PATH;
   DWORD   dwResult = ERROR_SUCCESS;
   HKEY  hKeyRemote = HKEY_LOCAL_MACHINE;
   WCHAR *pColon;
   CRegKey IASKey;
   WCHAR szConfigPathBuff[IAS_MAX_CONFIG_PATH];

   if ( m_bIsRemoteServer )
       dwResult = RegConnectRegistry(m_szServerName, HKEY_LOCAL_MACHINE, &hKeyRemote);

   if ( ERROR_SUCCESS == dwResult )
   {
      // Open the IAS Service Key
      //
      dwResult = IASKey.Open(
                             hKeyRemote,
                            IAS_POLICY_REG_KEY,
                           KEY_READ
                        );

      if ( ERROR_SUCCESS == dwResult )
      {
         // Get the value of the "ProgramDir" registry entry
         //
         dwSize = IAS_MAX_CONFIG_PATH;
         dwResult = IASKey.QueryValue(
                                       szConfigPathBuff,
                                       (LPCTSTR)IAS_SERVICE_DIRECTORY,
                                       &dwSize
                                      );
         if ( ERROR_SUCCESS == dwResult )
         {
            // If remote machine then create a path to the admin share.
            // Otherwise assume we're using the configuration on the local machine
            //
            if ( m_bIsRemoteServer )
            {
               if ( IAS_MAX_CONFIG_PATH > lstrlen(m_szServerName) + dwSize )
               {
                  // Replace "Drive:" with "Drive$"
                  //
                  pColon = wcsrchr(szConfigPathBuff, L':');
                  if (pColon == NULL)
                  {
                     return false;
                  }
                  *pColon = L'$';

                  // Add leading "\\"
                  //
                     wsprintf(
                          m_szConfigPath,
                          TEXT("\\\\%s\\%s"),
                          m_szServerName,
                          szConfigPathBuff
                        );

                  bReturn = true;
               }
            }
            else
            {
               lstrcpy(m_szConfigPath, szConfigPathBuff);
               bReturn = true;
            }
         }
      }
   }

   IASTracePrintf("INFO CDsConnectionIAS::SetConfigPath. m_szConfigPath= %S\n"
      ,m_szConfigPath);
    return bReturn;
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionAD::Connect(
                   /*[in]*/ LPCWSTR lpszServerName,
                   /*[in]*/ LPCWSTR lpszUserName,
                   /*[in]*/ LPCWSTR lpszPassword
                        )
{
    HRESULT    hr = E_FAIL;

   _ASSERT( DISCONNECTED == m_eState );
   if ( SetServerName(lpszServerName, false) )
   {
      m_eState = CONNECTED;
      hr = S_OK;
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionAD::InitializeDS()
{
   HRESULT  hr = S_OK;

   _ASSERT( CONNECTED == m_eState );
   if ( ! m_bInitializedDS )
   {
       _variant_t vtConfigNamingContext;
      _variant_t  vtDefaultNamingContext;

      // Get the naming contexts at the specified directory server
      //
      hr = GetNamingContexts(&vtConfigNamingContext, &vtDefaultNamingContext);
      if ( SUCCEEDED(hr) )
      {
         // Set the domain mode - mixed or native
         //
         hr = SetMode(&vtDefaultNamingContext);
         if ( SUCCEEDED(hr) )
         {
            // Get the path to the DS configuration information (policies & profiles)
            //
            hr = SetConfigPath(&vtConfigNamingContext);
            if ( SUCCEEDED(hr) )
               m_bInitializedDS = true;
         }
      }
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////////
void  CDsConnectionAD::Disconnect()
{
   if ( m_pDSRootContainer )
   {
      m_pDSRootContainer->Release();
      m_pDSRootContainer = NULL;
   }
   if ( m_pDSRootObject )
   {
      m_pDSRootObject->Release();
      m_pDSRootObject = NULL;
   }
   if ( m_pDSRoot )
   {
      m_pDSRoot->Shutdown();
      m_pDSRoot->Release();
      m_pDSRoot = NULL;
   }
   m_eState = DISCONNECTED;
   m_szServerName[0] = '\0';
   m_szConfigPath[0] = '\0';
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionAD::GetNamingContexts(
                        /*[out]*/ VARIANT*   pvtConfigNamingContext,
                        /*[out]*/ VARIANT*  pvtDefaultNamingContext
                                 )
{
   HRESULT  hr = E_FAIL;
   DWORD  dwLength;
   _bstr_t   bstrNamingContext;
   WCHAR  szRootDSE[MAX_PATH];

   // Check preconditons
   //
   _ASSERT( NULL != pvtConfigNamingContext && NULL != pvtDefaultNamingContext );

   dwLength = lstrlen(IAS_NTDS_LDAP_PROVIDER) +
             lstrlen(m_szServerName) +
            lstrlen(IAS_NTDS_ROOT_DSE);

   _ASSERT( MAX_PATH > dwLength );
   if ( MAX_PATH > dwLength )
   {
      wsprintf(
              szRootDSE,
              TEXT("%s%s/%s"),
              IAS_NTDS_LDAP_PROVIDER,
              m_szServerName,
              IAS_NTDS_ROOT_DSE
            );

      CComPtr<IDataStore2> pDS2;
      hr = CoCreateInstance(
                        __uuidof(ADsDataStore),
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDataStore2,
                        (void**)&pDS2
                      );
      if ( SUCCEEDED(hr) )
      {
         hr = pDS2->Initialize(
                           szRootDSE,
                           NULL,
                           NULL
                         );
         if ( SUCCEEDED(hr) )
         {
            CComPtr<IDataStoreObject> pRootDSE;
            hr = pDS2->get_Root(&pRootDSE);
            if ( SUCCEEDED(hr) )
            {
               _bstr_t bstrNamingContext = IAS_NTDS_CONFIG_NAMING_CONTEXT;
               hr = pRootDSE->GetValue(bstrNamingContext, pvtConfigNamingContext);
               if ( SUCCEEDED(hr) )
               {
                  bstrNamingContext = IAS_NTDS_DEFAULT_NAMING_CONTEXT;
                  hr = pRootDSE->GetValue(bstrNamingContext, pvtDefaultNamingContext);
                  if ( FAILED(hr) )
                     VariantClear(pvtConfigNamingContext);
               }
            }

            pDS2->Shutdown();
         }
      }
   }

   return hr;
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionAD::SetMode(
                  /*[in]*/ VARIANT*  pvtDefaultNamingContext
                         )
{
   HRESULT  hr = E_FAIL;
   DWORD dwLength;
   WCHAR   szPath[MAX_PATH + 1];

   // Set the mixed mode flag based on the value of the "ntMixedDomain" property
   //

   _ASSERT ( NULL != pvtDefaultNamingContext );

   dwLength = lstrlen(IAS_NTDS_LDAP_PROVIDER) +
             lstrlen(m_szServerName)  +
            lstrlen(V_BSTR(pvtDefaultNamingContext));

   _ASSERT( dwLength < MAX_PATH );
   if ( dwLength < MAX_PATH )
   {
      wsprintf(
              szPath,
              TEXT("%s%s/%s"),
              IAS_NTDS_LDAP_PROVIDER,
              m_szServerName,
              V_BSTR(pvtDefaultNamingContext)
            );

      CComPtr<IDataStore2> pDS2;
      hr = CoCreateInstance(
                        __uuidof(ADsDataStore),
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDataStore2,
                        (void**)&pDS2
                      );
      if ( SUCCEEDED(hr) )
      {
         hr = pDS2->Initialize(
                          szPath,
                          NULL,
                          NULL
                         );
         if ( SUCCEEDED(hr) )
         {
            CComPtr<IDataStoreObject> pDefaultNamingContext;
            hr = pDS2->get_Root(&pDefaultNamingContext);
            if ( SUCCEEDED(hr) )
            {
               _variant_t vtMode;
               hr = pDefaultNamingContext->GetValue(IAS_NTDS_MIXED_MODE_FLAG, &vtMode);
               if ( SUCCEEDED(hr) )
               {
                  if ( IAS_MIXED_MODE == V_I4(&vtMode) )
                     m_bMixedMode = true;
                  else
                     m_bMixedMode = false;
               }
            }

            pDS2->Shutdown();
         }
      }
   }

   return hr;
}


///////////////////////////////////////////////////////////////////////////
HRESULT CDsConnectionAD::SetConfigPath(
                        /*[in]*/ VARIANT*  pvtConfigNamingContext
                              )
{
   HRESULT hr = E_FAIL;
   DWORD dwLength;
   WCHAR   szPath[MAX_PATH + 1];

   // Set the root and root container for the IAS configuration information
   //

   _ASSERT ( NULL != pvtConfigNamingContext );

   dwLength = lstrlen(IAS_NTDS_LDAP_PROVIDER) +
              lstrlen(m_szServerName) +
              lstrlen(IAS_NTDS_COMMON_NAMES) +
              lstrlen(V_BSTR(pvtConfigNamingContext));

   _ASSERT( dwLength < MAX_PATH );

   if ( dwLength < MAX_PATH )
   {
      wsprintf(
              szPath,
              // TEXT("%s%s/%s%s"),
              TEXT("%s%s/%s"),
              IAS_NTDS_LDAP_PROVIDER,
              m_szServerName,
              //IAS_NTDS_COMMON_NAMES,
              V_BSTR(pvtConfigNamingContext)
            );

      CComPtr<IDataStore2> pDSRoot;
      hr = CoCreateInstance(
                        __uuidof(ADsDataStore),
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDataStore2,
                        (void**)&pDSRoot
                      );
      if ( SUCCEEDED(hr) )
      {
         hr = pDSRoot->Initialize(
                             szPath,
                             NULL,
                             NULL
                           );
         if ( SUCCEEDED(hr) )
         {
            CComPtr<IDataStoreObject> pDSRootObject;
            hr = pDSRoot->get_Root(&pDSRootObject);
            if ( SUCCEEDED(hr) )
            {
                CComPtr<IDataStoreContainer> pDSRootContainer;
               hr = pDSRootObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSRootContainer);
               if ( SUCCEEDED(hr) )
               {
                  pDSRoot.p->AddRef();
                  pDSRootObject.p->AddRef();
                  pDSRootContainer.p->AddRef();
                  m_pDSRoot = pDSRoot;
                  m_pDSRootObject = pDSRootObject;
                  m_pDSRootContainer = pDSRootContainer;
               }
            }

            if ( FAILED(hr) )
               pDSRoot->Shutdown();
         }
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\infohelper.cpp ===
//#--------------------------------------------------------------
//
//  File:		infohelper.cpp
//
//  Synopsis:   Implementation of helper methods
//              which are used by the sdoserverinfo COM object
//
//
//  History:     06/08/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include "infohelper.h"
#include "sdoias.h"
#include "dsconnection.h"
#include <lmcons.h>
#include <lmwksta.h>
#include <lmserver.h>
#include <lmerr.h>
#include <winldap.h>
#include <explicitlink.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <activeds.h>
#include <winsock2.h>

//
// reg key to be queried
//
const WCHAR PRODUCT_OPTIONS_REGKEY [] =
            L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions";

//
// maximum Domain name
//
const DWORD MAX_DOMAINNAME_LENGTH = 1024;

//
// this holds the matrix to get SYSTEMTYPE from the
// NTTYPE and VERSION type
//
const IASOSTYPE g_OsInfoTable [2][2] = {
                             SYSTEM_TYPE_NT4_WORKSTATION,
                             SYSTEM_TYPE_NT5_WORKSTATION,
                             SYSTEM_TYPE_NT4_SERVER,
                             SYSTEM_TYPE_NT5_SERVER
                             };

//++--------------------------------------------------------------
//
//  Function:   SdoGetOSInfo
//
//  Synopsis:   This is method used to get OS System information
//              Currently it returns the following info:
//              1) Os Version: 4 or 5
//              2) NtType:     Wks or Svr
//
//  Arguments:
//              LPCWSTR - machine name
//              PSYSTEMTYPE - info to be returned
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
SdoGetOSInfo (
        /*[in]*/    LPCWSTR         lpServerName,
        /*[out]*/   PIASOSTYPE      pSystemType
        )
{
    HRESULT     hr = S_OK;
    NTVERSION   eNtVersion;
    NTTYPE      eNtType;

    _ASSERT ((NULL != lpServerName) && (NULL != pSystemType));

    do
    {
        //
        //  get the OS Version now
        //
        hr = ::GetNTVersion (lpServerName, &eNtVersion);
        if (FAILED (hr))
        {
		    IASTracePrintf(
                "Error in SDO - SdoGetOSInfo() - GetNTVersion() failed..."
                );
            break;
        }

        //
        //  get the OS type - NT Server or Workstation
        //
        hr = ::IsWorkstationOrServer (lpServerName, &eNtType);
        if (FAILED (hr))
        {
		    IASTracePrintf(
                "Error in SDO - SdoGetOSInfo()"
                "- IsWorkstationOrServer() failed..."
                );
            break;
        }

        //
        //  now decide which machine type this is
        //
        *pSystemType = g_OsInfoTable [eNtType][eNtVersion];

    } while (FALSE);

    return (hr);

}   //  end of ::SdoServerInfo method

//++--------------------------------------------------------------
//
//  Function:   SdoGetDomainInfo
//
//  Synopsis:   This is method used to get the domain type
//                information
//
//  Arguments:
//              LPCWSTR     - machine name
//              LPCWSTR     - Domain name
//              PDOMAINTYPE - Domain Info
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
SdoGetDomainInfo (
        /*[in]*/   LPCWSTR          pszServerName,
        /*[in]*/   LPCWSTR          pszDomainName,
        /*[out]*/  PIASDOMAINTYPE   pDomainType
        )
{
    HRESULT hr = S_OK;
    BOOL    bHasDC = FALSE;
    BOOL    bHasDS = FALSE;
    BOOL    bMixed = FALSE;
    LPBYTE  pNetBuffer = NULL;
    WCHAR   szGeneratedDomainName [MAX_DOMAINNAME_LENGTH + 3];
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;

    _ASSERT (pDomainType);

    //
    //  get the domain information by calling DsGetDcName
    //  where this API is supported
    //
    DWORD dwErr =  ::DsGetDcName (
                        pszServerName,
                        pszDomainName,
                        NULL,
                        NULL,
                        DS_FORCE_REDISCOVERY |
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pDCInfo
                        );
    if (NO_ERROR == dwErr)
    {
        //
        //  we sure have a domain controller
        //
        bHasDC = TRUE;

        //
        //  check if DS is available
        //
        bHasDS = ((pDCInfo->Flags & DS_DS_FLAG) != 0);

        if (NULL == pszDomainName)
        {
            pszDomainName = pDCInfo->DomainName;
        }
    }
    else if (ERROR_NO_SUCH_DOMAIN == dwErr)
    {
        IASTracePrintf(
            "Error in SDO - SdoGetDomainInfo()"
            " - domain could not be located..."
            );
    }
    else
    {
	    IASTracePrintf(
            "Error in SDO - SdoGetDomainInfo()"
            " - DsGetDcName(DS_PREFERRED) failed with error:%d",
            dwErr
            );
        hr = HRESULT_FROM_WIN32 (dwErr);
        goto Cleanup;
    }

#if 0
    //
    // case of NT4 - which we don't support as of now
    //
    else
    {
        WCHAR szShortDomainName[MAX_DOMAINNAME_LENGTH +2];
        if (NULL != pszDomainName)
        {
            lstrcpy (szShortDomainName, pszDomainName);
            PWCHAR pTemp = wcschr (szShortDomainName, L'.');
            if (NULL != pTemp)
            {
                *pTemp = L'\0';
            }
        }

        //
        //  DsGetDcName not availabe so call NetGetDCName
        //  could be Nt 4 machine
        //
        LPBYTE pNetBuffer = NULL;
        NET_API_STATUS status = ::NetGetAnyDCName (
                                        pszServerName,
                                        (NULL == pszDomainName) ?
                                        NULL:szShortDomainName,
                                        &pNetBuffer
                                        );
        if (NERR_Success != status)
        {
			IASTracePrintf(
                    "Error in SDO - SdoGetDomainInfo()"
                    " -NetGetAnyDCName (ANY_DOMAIN) failed with error:%d",
                    status
                    );
        }
        else
        {
            //
            //  we sure have a domain controller
            //
            bHasDC = TRUE;

            //
            //  get domain name if we don't have one already
            //
            if (NULL == pszDomainName)
            {
                hr = ::SdoGetDomainName (pszServerName, szGeneratedDomainName);
                if (FAILED (hr))
                {
					IASTracePrintf(
                        "Error in SDO - SdoGetDomainInfo()"
                        " - SdoGetDomainName() failed with error:%x",
                        hr
                        );
                    goto Cleanup;
                }
            }

            //
            //  skip the leading "\\"
            //
            PWCHAR pDomainServerName =
                        2 + reinterpret_cast <PWCHAR>(pNetBuffer);
            //
            //  try connecting to LDAP port on this server
            //
            LDAP *ld = ldap_openW (
                            const_cast <PWCHAR> (pDomainServerName),
                            LDAP_PORT
                            );
            bHasDS = ld ? ldap_unbind (ld), TRUE:FALSE;
        }
    }
#endif

    //
    //  if we have NT5 DC, check if its mixed or native domain
    //
    if (TRUE == bHasDS)
    {
        hr = ::IsMixedDomain (pszDomainName, &bMixed);
        if (FAILED (hr))
        {
			IASTracePrintf(
                "Error in SDO - SdoGetOSInfo()"
                " - IsMixedDomain() failed with errror:%x",
                hr
                );
        }
    }

    //
    //   now set the info in the pDomainInfo struct
    //

    if (SUCCEEDED (hr))
    {
        if (bMixed)
            *pDomainType = DOMAIN_TYPE_MIXED;
        else if (bHasDS)
            *pDomainType = DOMAIN_TYPE_NT5;
        else if (bHasDC)
            *pDomainType = DOMAIN_TYPE_NT4;
        else
            *pDomainType = DOMAIN_TYPE_NONE;
    }

    //
    //  cleanup here
    //
Cleanup:

    if (NULL !=  pDCInfo)
        ::NetApiBufferFree (pDCInfo);

    if (NULL !=  pNetBuffer)
        ::NetApiBufferFree (pNetBuffer);

    return (hr);

}   //  end of SdoGetDomainInfo method

//++--------------------------------------------------------------
//
//  Function:   IsWorkstationOrServer
//
//  Synopsis:   This is method determines if a specific machine
//              is running NT workstation or Server
//
//  Arguments:
//              LPCWSTR - machine name
//              NTTYPE*
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
IsWorkstationOrServer (
        /*[in]*/    LPCWSTR pszComputerName,
        /*[out]*/   NTTYPE  *pNtType
        )
{
    HRESULT hr = S_OK;
    WCHAR   szCompleteName [IAS_MAX_SERVER_NAME + 3];
    PWCHAR  pszTempName = const_cast <PWCHAR> (pszComputerName);

    _ASSERT ((NULL != pszComputerName) && (NULL !=  pNtType));

    do
    {
        //
        // the computer name should have a "\\" in front
        //
        if ((L'\\' != *pszComputerName) || (L'\\' != *(pszComputerName + 1)))
        {
            if (::wcslen (pszComputerName) > IAS_MAX_SERVER_NAME)
            {
                IASTracePrintf(
                    "Error in Server Info SDO - IsWorkstationOrServer()"
                    " - Computer name is too big..."
                    );
                hr = E_FAIL;
                break;
            }
            ::wcscpy (szCompleteName, L"\\\\");
            ::wcscat (szCompleteName, pszComputerName);
            pszTempName = szCompleteName;
        }

        //
        // Connect to the registry
        //
        HKEY  hResult;
        DWORD dwErr = ::RegConnectRegistry (
                                pszTempName,
                                HKEY_LOCAL_MACHINE,
                                &hResult
                                );
        if (ERROR_SUCCESS != dwErr)
        {
		    IASTracePrintf(
                "Error in SDO - IsWorkstationOrServer()"
                " - RegConnectRegistry() failed with error:%d",
                dwErr
                );
            hr = HRESULT_FROM_WIN32 (dwErr);
            break;
        }

        //
        //  open the registry key now
        //
        HKEY hValueKey;
        dwErr = ::RegOpenKeyEx (
                        hResult,
                        PRODUCT_OPTIONS_REGKEY,
                        0,
                        KEY_QUERY_VALUE,
                        &hValueKey
                        );
        if (ERROR_SUCCESS != dwErr)
        {
		    IASTracePrintf(
                "Error in SDO - IsWorkstationOrServer()"
                " - RegOpenKeyEx() failed with error:%d",
                hr
                );
            RegCloseKey (hResult);
            hr = HRESULT_FROM_WIN32 (dwErr);
            break;
        }

        //
        //  get the value now
        //
        WCHAR szProductType [MAX_PATH];
        DWORD dwBufferLength = MAX_PATH;
        dwErr = RegQueryValueEx (
                        hValueKey,
                        L"ProductType",
                        NULL,
                        NULL,
                        (LPBYTE)szProductType,
                        &dwBufferLength
                        );
        if (ERROR_SUCCESS != dwErr)
        {
		    IASTracePrintf(
                "Error in SDO - IsWorkstationOrServer()"
                " - RegQueryValueEx() failed with error:%d",
                hr
                );
            RegCloseKey (hValueKey);
            RegCloseKey (hResult);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }

        //
        //  determine which NT Type we have on this machine
        //
        if (_wcsicmp (L"WINNT", szProductType) == 0)
        {
            *pNtType = NT_WKSTA;
        }
        else if (!_wcsicmp (L"SERVERNT", szProductType) ||
                 !_wcsicmp (L"LanmanNT", szProductType))
        {
            *pNtType = NT_SVR;
        }
        else
        {
		    IASTracePrintf(
                "Error in SDO - IsWorkstationOrServer()"
                " - Could not determine machine type..."
                );
            RegCloseKey (hValueKey);
            RegCloseKey (hResult);
            hr = E_FAIL;
        }

        //
        //  cleanup
        //
        RegCloseKey (hValueKey);
        RegCloseKey (hResult);

    } while (FALSE);

    return (hr);

}   //  end of  ::IsWorkstationOrServer method

//++--------------------------------------------------------------
//
//  Function:   GetNTVersion
//
//  Synopsis:   This is method determines which version of NT
//              is running on this machine
//
//  Arguments:
//              LPCWSTR - machine name
//              NTVERSION*
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
GetNTVersion (
        /*[in]*/    LPCWSTR     lpComputerName,
        /*[out]*/   NTVERSION   *pNtVersion
        )
{
    HRESULT hr = S_OK;

    _ASSERT ((NULL  != lpComputerName) && (NULL != pNtVersion));

    do
    {
        //
        //  get level 100 workstation information
        //
        PWKSTA_INFO_100 pInfo = NULL;
        DWORD dwErr = ::NetWkstaGetInfo (
                                (LPWSTR)lpComputerName,
                                100,
                                (LPBYTE*)&pInfo
                                );
        if (NERR_Success != dwErr)
        {
		    IASTracePrintf(
                "Error in SDO - GetNTVersion()"
                "- NTWkstaGetInfo failed with error:%d",
                dwErr
                );
            hr = HRESULT_FROM_WIN32 (dwErr);
            break;
        }

        //
        //  get the version info
        //
        if (4 == pInfo->wki100_ver_major)
        {
            *pNtVersion = NTVERSION_4;
        }
        else if ( 5 == pInfo->wki100_ver_major)
        {
            *pNtVersion = NTVERSION_5;
        }
        else
        {
		    IASTracePrintf(
                    "Error in SDO - GetNTVersion()"
                    " - Unsupported OS version..."
                    );
            hr = E_FAIL;
        }

    } while (FALSE);

    return (hr);

}   //  end of ::GetNTVersion method

//++--------------------------------------------------------------
//
//  Function:   IsMixedDomain
//
//  Synopsis:   This is method determines which version of NT
//              is running on this machine
//
//  Arguments:
//              [in]    LPCWSTR - machine name
//              [out]   PBOOL   - is mixed
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
IsMixedDomain (
            /*[in]*/    LPCWSTR pszDomainName,
            /*[out]*/   PBOOL   pbIsMixed
            )
{
    HRESULT hr = S_OK;
    WCHAR szTempName [MAX_DOMAINNAME_LENGTH + 8];

    _ASSERT ((NULL != pszDomainName) && (NULL != pbIsMixed));

    do
    {
        //
        // check the arguments passedin
        //
        if ((NULL == pszDomainName) || (NULL == pbIsMixed))
        {
		    IASTracePrintf(
                "Error in SDO - IsMixedDomain()"
                " - Invalid parameter - NULL"
                );
            hr = E_INVALIDARG;
            break;
        }

        if (::wcslen (pszDomainName) > MAX_DOMAINNAME_LENGTH)
        {
		    IASTracePrintf(
                "Error in SDO - IsMixedDomain()"
                " - Invalid parameter (domain name is to long)..."
                );
            hr = E_FAIL;
            break;
        }

        //
        // form the DN name
        //
        wcscpy (szTempName, L"LDAP://");
        wcscat (szTempName, pszDomainName);

        //
        //  get the domain object
        //
        CComPtr <IADs> pIADs;
        hr = ::ADsGetObject (
                        szTempName,
                        IID_IADs,
                        reinterpret_cast <PVOID*> (&pIADs)
                        );
        if (FAILED (hr))
        {
		    IASTracePrintf(
                "Error in SDO - IsMixedDomain()"
                " - Could not get the domain object from the DS with error:%x",
                hr
                );
            break;
        }

        //
        //  get the Mixed Domain info
        //
        _variant_t varMixedInfo;
        hr = pIADs->Get (L"nTMixedDomain", &varMixedInfo);
        if (FAILED (hr))
        {
            if (E_ADS_PROPERTY_NOT_FOUND == hr)
            {
                //
                //  this is OK
                //
                *pbIsMixed = FALSE;
                hr = S_OK;
            }
            else
            {
			    IASTracePrintf(
                    "Error in SDO - IsMixedDomain()"
                     "- Could not get the 'nTMixedDomain' property"
                    "from the domain object, failed with error:%x",
                    hr
                    );
            }
            break;
        }

        _ASSERT (
             (VT_BOOL == V_VT (&varMixedInfo)) ||
             (VT_I4 == V_VT (&varMixedInfo))
            );

        //
        //  get the values from the variant
        //
        if (VT_I4 == V_VT (&varMixedInfo))
        {
            *pbIsMixed = V_I4 (&varMixedInfo);
        }
        else if (VT_BOOL == V_VT (&varMixedInfo))
        {
            *pbIsMixed =  (VARIANT_TRUE == V_BOOL (&varMixedInfo));
        }
        else
        {
		    IASTracePrintf(
                "Error in SDO - IsMixedDomain()"
                "-'nTMixedDomain property has an invalid value..."
                );
            hr = E_FAIL;
            break;
        }

    }  while (FALSE);

    return (hr);

}   // end of IsMixedDomain

//++--------------------------------------------------------------
//
//  Function:   SdoGetDomainName
//
//  Synopsis:   This is method determines the domain name
//              given the server name
//
//  Arguments:
//              LPCWSTR - machine name
//              LPWSTR  - pDomanName
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     06/08/98
//
//----------------------------------------------------------------
HRESULT
SdoGetDomainName (
            /*[in]*/    LPCWSTR pszServerName,
            /*[out]*/   LPWSTR  pDomainName
            )
{
    _ASSERT (NULL != pDomainName);

#if 0
    SERVER_INFO_503 ServerInfo;
    ServerInfo.sv503_domain = pDomainName;
    DWORD dwErr = ::NetServerGetInfo (
                        const_cast <LPWSTR> (pszServerName),
                        503,
                        reinterpret_cast <LPBYTE*> (&ServerInfo)
                        );
    if (NERR_Success != dwErr)
    {
		IASTracePrintf("Error in SDO - SdoGetDomainName() - NetServerGetInfo() failed...");
        return (HRESULT_FROM_WIN32 (dwErr));
    }

    return (S_OK);


#endif
    return (E_FAIL);

}   //  end of ::SdoGetDomainName method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\dspath.h ===
//#--------------------------------------------------------------
//        
//  File:       dspath.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CDSPath class. The class object exports
//              the IDataStoreObject interface which is
//              used by the Dictionary SDO to obtain the
//              datastore path    
//              
//
//  History:     09/25/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _DSPATH_H_
#define _DSPATH_H_

#include "resource.h" 

//
// name of the property it holds
//
const WCHAR PROPERTY_DICTIONARY_PATH[] = L"Path";

//
// CDSPath class declaration
//
class CDSPath:
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IDataStoreObject,
                        &__uuidof (IDataStoreObject),
                        &LIBID_SDOIASLibPrivate>
{

public:

    //
    //-----------IDataStoreObject methods-------------------
    //

    //
    // get the value for the current property in the data
    // store object
    //
    STDMETHOD(GetValue)(
                /*[in]*/            BSTR bstrName, 
                /*[out, retval]*/   VARIANT* pVal
                )
    {   
        HRESULT hr = E_INVALIDARG;

        _ASSERT (NULL != pVal);

        if (0 == _wcsicmp ((PWCHAR) bstrName, PROPERTY_DICTIONARY_PATH))
        { 
            hr = ::VariantCopy (pVal, &m_vtPath);
        }

        return (hr);
    }

    STDMETHOD(get_Container)(
                /*[out, retval]*/ IDataStoreContainer** pVal
                )    
    {return (E_NOTIMPL);}


    STDMETHOD(GetValueEx)(
                /*[in]*/ BSTR bstrName,
                /*[out, retval]*/ VARIANT* pVal
                )
    {return (E_NOTIMPL);}

    STDMETHOD(get_Name)(
                /*[out, retval]*/ BSTR* pVal
                ) 
    { return (E_NOTIMPL);}

    STDMETHOD(get_Class)(
                /*[out, retval]*/ BSTR* pVal
                )
    { return (E_NOTIMPL); }

    STDMETHOD(get_GUID)(
                /*[out, retval]*/ BSTR* pVal
                )
    { return (E_NOTIMPL); }


    STDMETHOD(PutValue)(
                /*[in]*/ BSTR bstrName, 
                /*[in]*/ VARIANT* pVal
                )
    { return (E_NOTIMPL); }

    STDMETHOD(Update)()
    { return (E_NOTIMPL); }

    STDMETHOD(Restore)()
    { return (E_NOTIMPL); }

    STDMETHOD(get_Count)(
                /*[out, retval]*/ LONG *pVal
                )
    { return (E_NOTIMPL); }

    STDMETHOD(Item)(
                /*[in]*/          BSTR                  bstrName,
                /*[out, retval]*/ IDataStoreProperty    **ppObject
                )
    { return (E_NOTIMPL); }

    STDMETHOD(get__NewEnum)(
                /*[out, retval]*/ IUnknown** pVal
                )
    { return (E_NOTIMPL); }


public:

    CDSPath () {InternalAddRef ();}

    ~CDSPath (){}

    //
    // initialize the Data Store container object
    //
    HRESULT Initialize (
                /*[in]*/    LPCWSTR pwszPath
                )
    {
        _ASSERT (NULL != pwszPath);
        m_vtPath = pwszPath;
        return (S_OK);
    }

//
// ATL interface information
//
BEGIN_COM_MAP(CDSPath)
	COM_INTERFACE_ENTRY(IDataStoreObject)
	COM_INTERFACE_ENTRY2(IDispatch, IDataStoreObject)
END_COM_MAP()

private:

    //
    // variant holding the dictionary path
    //
    _variant_t m_vtPath;

};  //  end of CDSPath class declaration

//
//  this is for creating the CDSPath class object
//  through new
//
typedef CComObjectNoLock<CDSPath> DS_PATH_OBJ;

#endif //_DSPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\attrdef.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdef.cpp
//
// SYNOPSIS
//
//    Defines the class AttributeDefinition.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//    01/27/2000    Add support for proxy policies.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <memory>
#include <attrdef.h>

inline AttributeDefinition::AttributeDefinition() throw ()
{
   memset(this, 0, sizeof(*this));
}

inline AttributeDefinition::~AttributeDefinition() throw ()
{
   SysFreeString(name);
   SysFreeString(description);
   SysFreeString(ldapName);
   SafeArrayDestroy(enumNames);
   SafeArrayDestroy(enumValues);
}

void AttributeDefinition::Release() const throw ()
{
   if (InterlockedDecrement(&refCount) == 0)
   {
      delete const_cast<AttributeDefinition*>(this);
   }
}

HRESULT AttributeDefinition::getInfo(
                                 ATTRIBUTEINFO infoId,
                                 VARIANT* pVal
                                 ) const throw ()
{
   if (pVal == NULL) { return E_INVALIDARG; }

   VariantInit(pVal);

   HRESULT hr = S_OK;

   switch (infoId)
   {
      case NAME:
      {
         if (V_BSTR(pVal) = SysAllocString(name))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
         break;
      }

      case SYNTAX:
      {
         V_I4(pVal) = (LONG)syntax;
         V_VT(pVal) = VT_I4;
         break;
      }

      case RESTRICTIONS:
      {
         V_I4(pVal) = (LONG)restrictions;
         V_VT(pVal) = VT_I4;
         break;
      }

      case DESCRIPTION:
      {
         // Description is optional, so it may be NULL.
         if (description)
         {
            if (V_BSTR(pVal) = SysAllocString(description))
            {
               V_VT(pVal) = VT_BSTR;
            }
            else
            {
               hr = E_OUTOFMEMORY;
            }
         }
         break;
      }

      case VENDORID:
      {
         V_I4(pVal) = (LONG)vendor;
         V_VT(pVal) = VT_I4;
         break;
      }

      case LDAPNAME:
      {
         if (V_BSTR(pVal) = SysAllocString(ldapName))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
         break;
      }

      default:
         hr = E_INVALIDARG;
   }

   return hr;
}

HRESULT AttributeDefinition::getProperty(
                                 LONG propId,
                                 VARIANT* pVal
                                 ) const throw ()
{
   if (pVal == NULL) { return E_INVALIDARG; }

   VariantInit(pVal);

   HRESULT hr = S_OK;

   switch (propId)
   {
      case PROPERTY_SDO_NAME:
      {
         if (V_BSTR(pVal) = SysAllocString(name))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
         break;
      }

      case PROPERTY_ATTRIBUTE_ID:
      {
         V_VT(pVal) = VT_I4;
         V_I4(pVal) = id;
         break;
      }

      case PROPERTY_ATTRIBUTE_VENDOR_ID:
      {
         V_VT(pVal) = VT_I4;
         V_I4(pVal) = vendor;
         break;
      }

      case PROPERTY_ATTRIBUTE_IS_ENUMERABLE:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = enumNames ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      case PROPERTY_ATTRIBUTE_ENUM_NAMES:
      {
         if (enumNames)
         {
            hr = SafeArrayCopy(enumNames, &V_ARRAY(pVal));
            if (SUCCEEDED(hr)) { V_VT(pVal) = VT_ARRAY; }
         }
         break;
      }

      case PROPERTY_ATTRIBUTE_ENUM_VALUES:
      {
         if (enumValues)
         {
            hr = SafeArrayCopy(enumValues, &V_ARRAY(pVal));
            if (SUCCEEDED(hr)) { V_VT(pVal) = VT_ARRAY; }
         }
         break;
      }

      case PROPERTY_ATTRIBUTE_SYNTAX:
      {
         V_VT(pVal) = VT_I4;
         V_I4(pVal) = syntax;
         break;
      }

      case PROPERTY_ATTRIBUTE_ALLOW_MULTIPLE:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = (restrictions & MULTIVALUED)
                             ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      case PROPERTY_ATTRIBUTE_ALLOW_IN_PROFILE:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = (restrictions & ALLOWEDINPROFILE)
                             ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      case PROPERTY_ATTRIBUTE_ALLOW_IN_CONDITION:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = (restrictions & ALLOWEDINCONDITION)
                             ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      case PROPERTY_ATTRIBUTE_DISPLAY_NAME:
      {
         if (V_BSTR(pVal) = SysAllocString(ldapName))
         {
            V_VT(pVal) = VT_BSTR;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
         break;
      }

      case PROPERTY_ATTRIBUTE_ALLOW_IN_PROXY_PROFILE:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = (restrictions & ALLOWEDINPROXYPROFILE)
                             ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      case PROPERTY_ATTRIBUTE_ALLOW_IN_PROXY_CONDITION:
      {
         V_VT(pVal) = VT_BOOL;
         V_BOOL(pVal) = (restrictions & ALLOWEDINPROXYCONDITION)
                             ? VARIANT_TRUE : VARIANT_FALSE;
         break;
      }

      default:
          hr = E_INVALIDARG;
   }

   return hr;
}

HRESULT AttributeDefinition::createInstance(
                                 AttributeDefinition** newDef
                                 ) throw ()
{
   // Check the arguments.
   if (newDef == NULL) { return E_INVALIDARG; }

   // Create a new AttributeDefinition.
   *newDef = new (std::nothrow) AttributeDefinition();
   if (*newDef == NULL) { return E_OUTOFMEMORY; }

   // Set the refCount to one.
   (*newDef)->refCount = 1;

   return S_OK;
}

int __cdecl AttributeDefinition::searchById(
                                     const ULONG* key,
                                     const AttributeDefinition* const* def
                                     ) throw ()
{
   if (*key > (*def)->id)
   {
      return 1;
   }
   else if (*key < (*def)->id)
   {
      return -1;
   }

   return 0;
}

int __cdecl AttributeDefinition::sortById(
                                     const AttributeDefinition* const* def1,
                                     const AttributeDefinition* const* def2
                                     ) throw ()
{
   if ((*def1)->id > (*def2)->id)
   {
      return 1;
   }
   else if ((*def1)->id < (*def2)->id)
   {
      return -1;
   }

   return 0;
}

int __cdecl AttributeDefinition::searchByName(
                                     PCWSTR key,
                                     const AttributeDefinition* const* def
                                     ) throw ()
{
   return _wcsicmp(key, (*def)->name);
}

int __cdecl AttributeDefinition::sortByName(
                                     const AttributeDefinition* const* def1,
                                     const AttributeDefinition* const* def2
                                     ) throw ()
{
   return _wcsicmp((*def1)->name, (*def2)->name);
}

int __cdecl AttributeDefinition::searchByLdapName(
                                     PCWSTR key,
                                     const AttributeDefinition* const* def
                                     ) throw ()
{
   return _wcsicmp(key, (*def)->ldapName);
}

int __cdecl AttributeDefinition::sortByLdapName(
                                     const AttributeDefinition* const* def1,
                                     const AttributeDefinition* const* def2
                                     ) throw ()
{
   return _wcsicmp((*def1)->ldapName, (*def2)->ldapName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\regkeys.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      regkeys.h
//
// Project:     Windows 2000
//
// Description: IAS NT4 to IAS W2K Migration Utility Include
//
// Author:      TLP 1/13/1999
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IAS_MIGRATION_KEYS_H_
#define _IAS_MIGRATION_KEYS_H_

#define AUTHSRV_KEY				(LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\AuthSrv"
#define AUTHSRV_PARAMETERS_KEY	(LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\AuthSrv\\Parameters"
#define AUTHSRV_PROVIDERS_KEY	(LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\AuthSrv\\Providers"
#define AUTHSRV_PARAMETERS_VERSION (LPWSTR)L"Version"
#define AUTHSRV_PROVIDERS_EXTENSION_DLL_VALUE	(LPCWSTR)L"ExtensionDLLs"

#define IAS_KEY					(LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy"
#define IAS_PARAMETERS_KEY		(LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters"

#endif // _IAS_MIGRATION_KEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\dsconnection.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      dsconnection.h
//
// Project:     Everest
//
// Description: IAS Server Data Object Definition
//
// Author:      TLP
//
// When         Who    What
// ----         ---    ----
// 4/6/98       TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_CONNECTION_H_
#define _INC_IAS_SDO_CONNECTION_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>


///////////////////////////////////////////////////////////////////////////
// IAS Data Store Information
///////////////////////////////////////////////////////////////////////////
#define     IAS_SERVICE_DIRECTORY           L"ProductDir"
#define     IAS_DICTIONARY_LOCATION         L"dnary.mdb"
#define     IAS_CONFIG_DB_LOCATION          L"ias.mdb"
#define     IAS_MAX_CONFIG_PATH             (MAX_PATH + 1)
#define		IAS_MIXED_MODE					1

///////////////////////////////////////////////////////////////////////////
// Active Directory Data Store Information
///////////////////////////////////////////////////////////////////////////
#define     IAS_NTDS_ROOT_DSE               (LPWSTR)L"RootDSE"
#define     IAS_NTDS_LDAP_PROVIDER          (LPWSTR)L"LDAP://"
#define     IAS_NTDS_CONFIG_NAMING_CONTEXT  (LPWSTR)L"configurationNamingContext"
#define		IAS_NTDS_DEFAULT_NAMING_CONTEXT (LPWSTR)L"defaultNamingContext"
#define     IAS_NTDS_MIXED_MODE_FLAG		(LPWSTR)L"nTMixedDomain"
#define		IAS_NTDS_SAM_ACCOUNT_NAME		(LPWSTR)L"sAMAccountName"
#define     IAS_NTDS_COMMON_NAMES           (LPWSTR)L"cn=RADIUS,cn=Services,"

// I don't think we can assume a fully qualified DNS name will be less
// than or equal to MAX_PATH in length, but it's too risky to replace
// m_szServerName with a dynamically allocated buffer. Furthermore, there
// appear to be lots of other places in the SDO code that make this
// faulty assumption.
const DWORD IAS_MAX_SERVER_NAME = MAX_PATH;

///////////////////////////////////////////////////////////////////////////
// Data Store Connection
///////////////////////////////////////////////////////////////////////////
class CDsConnection
{

public:

	CDsConnection();
	virtual ~CDsConnection();

	virtual HRESULT			Connect(
							/*[in]*/ LPCWSTR lpszServerName,
							/*[in]*/ LPCWSTR lpszUserName,
							/*[in]*/ LPCWSTR lpszPassword
								   ) = 0;

	virtual HRESULT			InitializeDS(void) = 0;

	virtual void			Disconnect(void) = 0;

	bool					IsConnected() const;
	bool					IsRemoteServer() const;

	LPCWSTR					GetConfigPath() const;

	LPCWSTR					GetServerName() const;

	bool					SetServerName(
								  /*[in]*/ LPCWSTR lpwszServerName,
								  /*[in]*/ bool bDefaultToLocal
								         );

	IDataStore2*			GetDSRoot(BOOL bAddRef = FALSE) const;

	IDataStoreObject*		GetDSRootObject(BOOL bAddRef = FALSE) const;

	IDataStoreContainer*	GetDSRootContainer(BOOL bAddRef = FALSE) const;

protected:

	typedef enum _DSCONNECTIONSTATE
	{
		DISCONNECTED,
		CONNECTED

	} DSCONNECTIONSTATE;

	DSCONNECTIONSTATE		m_eState;
	bool					m_bIsRemoteServer;
	bool					m_bIsMixedMode;
	bool					m_bInitializedDS;
	IDataStore2*			m_pDSRoot;
	IDataStoreObject*		m_pDSRootObject;
	IDataStoreContainer*	m_pDSRootContainer;
	WCHAR					m_szServerName[IAS_MAX_SERVER_NAME + 1];
	WCHAR					m_szConfigPath[IAS_MAX_CONFIG_PATH + 1];

private:

	// Disallow copy and assignment
	//
	CDsConnection(CDsConnection& theConnection);
	CDsConnection& operator=(CDsConnection& theConnection);
};

typedef CDsConnection* PDATA_STORE_CONNECTION;


//////////////////////////////////////////////////////////////////////////////
inline bool CDsConnection::IsConnected() const
{ return ( CONNECTED == m_eState ? true : false ); }

//////////////////////////////////////////////////////////////////////////////
inline bool CDsConnection::IsRemoteServer() const
{ return m_bIsRemoteServer; }

//////////////////////////////////////////////////////////////////////////////
inline IDataStore2* CDsConnection::GetDSRoot(BOOL bAddRef) const
{
	if ( bAddRef )
		m_pDSRoot->AddRef();
	return m_pDSRoot;
}

//////////////////////////////////////////////////////////////////////////////
inline IDataStoreObject* CDsConnection::GetDSRootObject(BOOL bAddRef) const
{
	if ( bAddRef )
		m_pDSRootObject->AddRef();
	return m_pDSRootObject;
}

//////////////////////////////////////////////////////////////////////////////
inline IDataStoreContainer* CDsConnection::GetDSRootContainer(BOOL bAddRef) const
{
	if ( bAddRef )
		m_pDSRoot->AddRef();
	return m_pDSRootContainer;
}

//////////////////////////////////////////////////////////////////////////////
inline LPCWSTR CDsConnection::GetConfigPath() const
{ return (LPCWSTR)m_szConfigPath; }

//////////////////////////////////////////////////////////////////////////////
inline LPCWSTR CDsConnection::GetServerName() const
{ return (LPCWSTR)m_szServerName; }


//////////////////////////////////////////////////////////////////////////////
// IAS Data Store Connection
//////////////////////////////////////////////////////////////////////////////
class CDsConnectionIAS : public CDsConnection
{

public:

	HRESULT Connect(
			/*[in]*/ LPCWSTR lpszServerName,
			/*[in]*/ LPCWSTR lpszUserName,
			/*[in]*/ LPCWSTR lpszPassword
				   );

	HRESULT InitializeDS(void);

	void	Disconnect(void);

private:

	bool	SetConfigPath(void);
};


//////////////////////////////////////////////////////////////////////////////
// Active Directory Data Store Connection
//////////////////////////////////////////////////////////////////////////////
class CDsConnectionAD : public CDsConnection
{

public:

	CDsConnectionAD()
		: CDsConnection(), m_bMixedMode(false) { }

	HRESULT Connect(
			/*[in]*/ LPCWSTR lpszServerName,
			/*[in]*/ LPCWSTR lpszUserName,
			/*[in]*/ LPCWSTR lpszPassword
				   );

	HRESULT InitializeDS(void);

	void	Disconnect(void);

	bool	IsMixedMode(void) const;

private:

	HRESULT	GetNamingContexts(
					 /*[in]*/ VARIANT*  pvtConfigNamingContext,
			  	     /*[in]*/ VARIANT*  pvtDefaultNamingContext
							 );
	HRESULT SetMode(
		   /*[out]*/ VARIANT*  pvtDefaultNamingContext
			       );

	HRESULT SetConfigPath(
				/*[out]*/ VARIANT*  pvtConfigNamingContext
					     );

	bool m_bMixedMode;
};


//////////////////////////////////////////////////////////////////////////////
inline bool CDsConnectionAD::IsMixedMode() const
{ return m_bMixedMode; }


#endif // _INC_IAS_SDO_CONNECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\attrdef.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdef.h
//
// SYNOPSIS
//
//    Declares the class AttributeDefinition.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ATTRDEF_H
#define ATTRDEF_H
#if _MSC_VER >= 1000
#pragma once
#endif

class SdoDictionary;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AttributeDefinition
//
// DESCRIPTION
//
//    Encapsulates all the information about an attribute in the dictionary.
//
///////////////////////////////////////////////////////////////////////////////
class AttributeDefinition
{
public:

   void AddRef() const throw ()
   { InterlockedIncrement(&refCount); }

   void Release() const throw ();

   // Retrieve attribute information based on the ATTRIBUTEINFO enum.
   HRESULT getInfo(
               ATTRIBUTEINFO infoId,
               VARIANT* pVal
               ) const throw ();

   // Retrieve attribute information based on the SDO property ID.
   HRESULT getProperty(
               LONG propId,
               VARIANT* pVal
               ) const throw ();

   // Create a new, empty definition.
   static HRESULT createInstance(AttributeDefinition** newDef) throw ();

   ///////
   // Functions for indexing attributes with qsort/bsearch.
   ///////

   static int __cdecl searchById(
                      const ULONG* key,
                      const AttributeDefinition* const* def
                      ) throw ();
   static int __cdecl sortById(
                      const AttributeDefinition* const* def1,
                      const AttributeDefinition* const* def2
                      ) throw ();

   static int __cdecl searchByName(
                      PCWSTR key,
                      const AttributeDefinition* const* def
                      ) throw ();
   static int __cdecl sortByName(
                      const AttributeDefinition* const* def1,
                      const AttributeDefinition* const* def2
                      ) throw ();

   static int __cdecl searchByLdapName(
                      PCWSTR key,
                      const AttributeDefinition* const* def
                      ) throw ();
   static int __cdecl sortByLdapName(
                      const AttributeDefinition* const* def1,
                      const AttributeDefinition* const* def2
                      ) throw ();

protected:
   AttributeDefinition() throw ();
   ~AttributeDefinition() throw ();

public:
   /////////
   // I made these public for two reasons:
   //     (1) I'm lazy.
   //     (2) The SdoDictionary class only gives out const pointers to
   //         AttributeDefinition's, so they will be read-only anyway.
   /////////

   ULONG id;                // Internal attribute ID.
   ULONG syntax;            // Syntax.
   ULONG restrictions;      // ATTRIBUTERESTRICTIONS flags.
   ULONG vendor;            // Vendor ID -- zero if RADIUS standard.
   BSTR name;               // Display name.
   BSTR description;        // Description.
   BSTR ldapName;           // LDAP name (used for persisting attribute).
   LPSAFEARRAY enumNames;   // Array of enum names (null if not enumerable).
   LPSAFEARRAY enumValues;  // Array of enum values.

private:
   mutable LONG refCount;   // Reference count.

   // Not implemented.
   AttributeDefinition(const AttributeDefinition&);
   AttributeDefinition& operator=(const AttributeDefinition&);
};

#endif  // ATTRDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\infohelper.h ===
//#--------------------------------------------------------------
//        
//  File:       infohelper.h
//        
//  Synopsis:   This file holds the declarations of the 
//				helper functions of the IASSDO.DLL
//                  
//
//  History:     06/08/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _INFOHELPER_H_
#define _INFOHELPER_H_

#include <ias.h>
#include <dsgetdc.h>

//
// tracing id
// 
#define TRACE_INFOHELPER   1002

//
// DsGetDcName signature
//
typedef DWORD (WINAPI *PDS_GET_DC_NAMEW)(
    LPCWSTR     ComputerName,
    LPCWSTR     DomainName,
    GUID        *DomainGuid,
    LPCWSTR     SiteName,
    ULONG       Flags,
    PDOMAIN_CONTROLLER_INFOW    *DomainControllerInfo
    );

//
// enumeration for the Version Info
//
typedef enum _NTVERSION_
{
    NTVERSION_4 = 0,
    NTVERSION_5 = 1

}   NTVERSION;

//
// enumeration for the NT Type
//
typedef enum _NTTYPE_
{
    NT_WKSTA = 0,
    NT_SVR = 1

}   NTTYPE;

//
// declarations of the helper methods
//


//
// returns the OS Info for the specific machine
//
HRESULT
SdoGetOSInfo (
        /*[in]*/    LPCWSTR         lpServerName,
        /*[out]*/   PIASOSTYPE      pSystemType
        );

//
// returns the domain info, given the domain or machine name
//
HRESULT
SdoGetDomainInfo (
        /*[in]*/   LPCWSTR          pszServerName,
        /*[in]*/   LPCWSTR          pszDomainName,
        /*[out]*/  PIASDOMAINTYPE   pDomainType
        );

//
// returns the Nt Type - Workstation or Server running 
// on the specified machine
//
HRESULT 
IsWorkstationOrServer (
        /*[in]*/    LPCWSTR pszComputerName,
        /*[out]*/   NTTYPE  *pNtType
        );
//
// returns the NT Version - 4 or 5
//
HRESULT
GetNTVersion (
        /*[in]*/    LPCWSTR     lpComputerName,
        /*[out]*/   NTVERSION   *pNtVersion
        );


//
// checks if the particular domain is mixed
//
HRESULT
IsMixedDomain (
            LPCWSTR pszDomainName,
            PBOOL   pbIsMixed
            );

//
// gets the domain name given a server name
//
HRESULT
SdoGetDomainName (
            /*[in]*/    LPCWSTR pszServerName,
            /*[out]*/   LPWSTR  pDomainName
            );

#endif //_INFOHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoattribute.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdoattribute.h
//
// SYNOPSIS
//
//    Declares the class SdoAttribute.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDOATTRIBUTE_H
#define SDOATTRIBUTE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <sdoias.h>
#include "sdoiaspriv.h"


class AttributeDefinition;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoAttribute
//
// DESCRIPTION
//
//    Implements the profile attribute SDO.
//
///////////////////////////////////////////////////////////////////////////////
class SdoAttribute
   : public IDispatchImpl< ISdo, &__uuidof(ISdo), &LIBID_SDOIASLib >
{
public:
   // Create a new attribute with an empty value.
   static HRESULT createInstance(
                      const AttributeDefinition* definition,
                      SdoAttribute** newAttr
                      ) throw ();

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// ISdo
//////////
   STDMETHOD(GetPropertyInfo)(LONG Id, IUnknown** ppPropertyInfo);
   STDMETHOD(GetProperty)(LONG Id, VARIANT* pValue);
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);
   STDMETHOD(ResetProperty)(LONG Id);
   STDMETHOD(Apply)();
   STDMETHOD(Restore)();
   STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

protected:
   SdoAttribute(const AttributeDefinition* definition) throw ();
   ~SdoAttribute() throw ();

public:
   const AttributeDefinition* def;  // Definition for this attribute type.
   VARIANT value;             // Value of this instance.
   
private:
   LONG refCount;             // Reference count.

   // Not implemented
   SdoAttribute(const SdoAttribute&);
   SdoAttribute& operator=(const SdoAttribute&);
};

#endif  // SDOATTRIBUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdo.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdo.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object Definition
//
// Author:      TLP 1/23/98
//
// When         Who    What
// ----         ---    ----
// 2/28/98      TLP    Prepare for IDataStore2
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ias.h>
#include "sdo.h"
#include "sdohelperfuncs.h"
#include "sdofactory.h"

////////////////////////////////////////////////////////////////////////////
// CSdo Class Implementation
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//                     SDO CONSTRUCTOR/DESTRUCTOR
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CSdo::CSdo()
    : m_pParent(NULL),
     m_pDSObject(NULL),
      m_fSdoInitialized(FALSE),
     m_fPersistOnApply(FALSE),
     m_fIsPersisted(FALSE)
{
   InternalAddRef();
}

//////////////////////////////////////////////////////////////////////////////
CSdo::~CSdo()
{
   InternalShutdown();
}


////////////////////////////////////////////////////////////////////////////
//                  ISdo INTERFACE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::GetPropertyInfo(LONG Id, IUnknown** ppSdoPropertyInfo)
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    _ASSERT( NULL != ppSdoPropertyInfo );
    if ( NULL == ppSdoPropertyInfo )
        return E_POINTER;

    HRESULT hr = S_OK;

    try
    {
        PropertyMapIterator p = m_PropertyMap.find(Id);
        if ( p == m_PropertyMap.end() )
        {
         IASTracePrintf("Error in SDO - GetProperty() - Property with ID = %d could not be found...", Id);
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
         (*ppSdoPropertyInfo = ((*p).second)->GetPropertyInfo())->AddRef();
      }
    }
    catch(_com_error theComError)
    {
      IASTracePrintf("Error in SDO - GetPropertyInfo() - Caught COM exception...");
        hr = theComError.Error();
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - GetPropertyInfo() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::GetProperty(LONG Id, VARIANT *pValue)
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    // Check function parameters
    //
    _ASSERT( NULL != pValue );
    if ( NULL == pValue )
        return E_POINTER;

    HRESULT hr = E_FAIL;

    try
    {
      if ( PROPERTY_SDO_DATASTORE_NAME != Id )
      {
         PropertyMapIterator p = m_PropertyMap.find(Id);
         if ( p == m_PropertyMap.end() )
         {
            IASTracePrintf("Error in SDO - GetProperty() - Property with ID = %d could not be found...", Id);
            hr = DISP_E_MEMBERNOTFOUND;
         }
         else
         {
            hr = InitializeProperty(Id);   // Defer property initialization until property is requeted.
            if ( SUCCEEDED(hr) )
               hr = ((*p).second)->GetValue(pValue);
         }
      }
      else
      {
         hr = GetDatastoreName(pValue);
      }
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - GetProperty() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::PutProperty(LONG Id, VARIANT * pValue)
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    // Check function parameters
    //
    _ASSERT( NULL != pValue );
    if ( NULL == pValue )
        return E_POINTER;

    HRESULT hr = E_FAIL;

    try
    {
        PropertyMapIterator p = m_PropertyMap.find(Id);
        if ( p == m_PropertyMap.end() )
        {
         IASTracePrintf("Error in SDO - PutProperty() - Property with ID = %d could not be found...", Id);
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
          if ( ((*p).second)->GetFlags() & SDO_PROPERTY_READ_ONLY )
          {
            IASTracePrintf("SDO Property Error - Validate() - Tried to change a read only property...");
         }
         else
         {
              hr = ValidateProperty((*p).second, pValue);
             if ( SUCCEEDED(hr) )
            {
               if ( PROPERTY_SDO_NAME == ((*p).second)->GetId() )
               {
                  if ( m_pParent )
                  {
                     if ( lstrcmpi(V_BSTR(((*p).second)->GetValue()),V_BSTR(pValue)) )
                     {
                        VARIANT_BOOL boolVal;
                        hr = m_pParent->IsNameUnique(V_BSTR(pValue), &boolVal);
                        if ( SUCCEEDED(hr) )
                        {
                           if ( VARIANT_TRUE == boolVal )
                              hr = ((*p).second)->PutValue(pValue);
                           else
                              hr = E_INVALIDARG;
                        }
                     }
                     else
                     {
                        hr = ((*p).second)->PutValue(pValue);
                     }
                  }
               }
               else
               {
                  hr = ((*p).second)->PutValue(pValue);
               }
            }
         }
        }
    }
    catch(_com_error theComError)
    {
      IASTracePrintf("Error in SDO - PutProperty() - Caught COM exception...");
        hr = theComError.Error();
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - GetProperty() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::ResetProperty(LONG Id)
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    HRESULT hr = E_FAIL;

    try
    {
        PropertyMapIterator p = m_PropertyMap.find(Id);
        if ( p == m_PropertyMap.end() )
        {
         IASTracePrintf("Error in SDO - ResetProperty() - Property with ID = %d could not be found...", Id);
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            // Reset the property to its default value (if defined)
            //
            if ( ((*p).second)->GetFlags() & SDO_PROPERTY_HAS_DEFAULT )
            {
                ((*p).second)->Reset();
            ((*p).second)->SetUpdateValue();
            }
            else
            {
            IASTracePrintf("Error in SDO - ResetProperty() - Property with ID = %d does not have a default value...", Id);
                hr = E_INVALIDARG;
            }
        }
    }
    catch(_com_error theComError)
    {
      IASTracePrintf("Error in SDO - ResetProperty() - Caught COM exception...");
        hr = theComError.Error();
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - ResetProperty() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::Apply()
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    HRESULT hr = S_OK;

    try
    {
        if ( m_fPersistOnApply )
            hr = Save();
    }
    catch(_com_error theComError)
    {
      IASTracePrintf("Error in SDO - Apply() - Caught COM exception...");
        hr = theComError.Error();
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - Apply() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::Restore()
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    HRESULT  hr = S_OK;

    try
    {
       if ( m_fPersistOnApply )
       {
            // Just return S_OK if we've never persisted the object
            //
            if ( m_fIsPersisted )
            {
                // Load the SDO properties from the persistent store
                //
                hr = Load();
            }
        }
    }
    catch(_com_error theComError)
    {
      IASTracePrintf("Error in SDO - Restore() - Caught COM exception...");
        hr = theComError.Error();
    }
    catch (...)
    {
      IASTracePrintf("Error in SDO - Restore() - Caught unknown exception...");
        hr = E_FAIL;
    }

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdo::get__NewEnum(IUnknown** ppEnumPropertyInfo)
{
    CSdoLock theLock(*this);

   _ASSERT( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    _ASSERT( NULL != ppEnumPropertyInfo );
    if ( NULL == ppEnumPropertyInfo )
        return E_POINTER;

   HRESULT hr = E_FAIL;
   EnumVARIANT* newEnum = NULL;

   try
   {
      vector<_variant_t> properties;
      VARIANT   property;
      VariantInit(&property);
      PropertyMapIterator p = m_PropertyMap.begin();
      while ( p != m_PropertyMap.end() )
      {
         V_VT(&property) = VT_DISPATCH;
         V_DISPATCH(&property) = dynamic_cast<IDispatch*>(((*p).second)->GetPropertyInfo());
         properties.push_back(property);
         p++;
      }

      newEnum = new (std::nothrow) CComObject<EnumVARIANT>;
      if ( newEnum == NULL )
      {
         IASTracePrintf("Error in SDO - get__NewEnum() - Out of memory...");
         return E_OUTOFMEMORY;
      }
      hr = newEnum->Init(
                     properties.begin(),
                     properties.end(),
                     static_cast<IUnknown*>(this),
                     AtlFlagCopy
                    );
      if ( SUCCEEDED(hr) )
      {
         (*ppEnumPropertyInfo = newEnum)->AddRef();
         return S_OK;
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO - get__NewEnum() - Caught unknown exception...");
      hr = E_FAIL;
   }

   if ( newEnum )
      delete newEnum;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//                    SDO Base Class Functions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::InternalInitialize(
                   /*[in]*/ LPCWSTR         lpszSdoName,
                  /*[in]*/ LPCWSTR         lpszSdoProgId,
                  /*[in]*/ ISdoMachine*      pAttachedMachine,
                  /*[in]*/ IDataStoreObject*   pDSObject,
                  /*[in]*/ ISdoCollection*   pParent,
                  /*[in]*/ bool            fInitNew
                        )
{
   // Check precondtions
   //
   _ASSERT( NULL != lpszSdoProgId && NULL != pAttachedMachine );

   HRESULT   hr = S_OK;

   if ( ! m_fSdoInitialized )
   {
      try
      {
         // Get the SDO schema class for lpszSdoClassId
         //
         CComPtr<IUnknown> pUnknown;
         CComPtr<ISdoSchema> pSdoSchema;
         hr = pAttachedMachine->GetSDOSchema(&pUnknown);
         if ( FAILED(hr) )
            throw _com_error(hr);

         hr = pUnknown->QueryInterface(IID_ISdoSchema, (void**)&pSdoSchema);
         if ( FAILED(hr) )
            throw _com_error(hr);

         pUnknown.Release();
         _bstr_t classId = lpszSdoProgId;
         hr = pSdoSchema->GetClass(classId, &pUnknown);
         if ( FAILED(hr) )
            throw _com_error(hr);

         CComPtr<ISdoClassInfo> pSdoClassInfo;
         hr = pUnknown->QueryInterface(IID_ISdoClassInfo, (void**)&pSdoClassInfo);
         if ( FAILED(hr) )
            throw _com_error(hr);

         // Initialize the SDO's properties from the schema class
         //
         AllocateProperties(pSdoClassInfo);

         // Set the SDO's class
         //
         PropertyMapIterator p = m_PropertyMap.find(PROPERTY_SDO_CLASS);
         _ASSERT( p != m_PropertyMap.end() );
         _variant_t vtClass = ::GetDataStoreClass(lpszSdoProgId);
         ((*p).second)->PutValue(&vtClass);

         // Set the SDO's name (if provided)
         //
         if ( lpszSdoName )
         {
            _variant_t vtName = lpszSdoName;
            hr = PutPropertyInternal(PROPERTY_SDO_NAME, &vtName);
            if ( FAILED(hr) )
               throw _com_error(hr);
         }
         // Save a reference to the parent object
         //
         if ( pParent )
         {
            m_pParent = pParent;
//            m_pParent->AddRef(); Weak reference for now
         }
         // Save a reference to the data store object used to persist this objects state
         //
         if ( pDSObject )
         {
            m_pDSObject = pDSObject;
            m_pDSObject->AddRef();
            m_fPersistOnApply = TRUE;
         }

         hr = FinalInitialize(fInitNew, pAttachedMachine);
         if ( FAILED(hr) )
            throw _com_error(hr);

         // Set the SDO's state to "initialized"
         //
         m_fSdoInitialized = TRUE;
      }
      catch(_com_error theError)
      {
         IASTracePrintf("Error in SDO - InternalInitialize() - Caught com_error exception...");
         InternalShutdown();
         hr = theError.Error();
      }
      catch(...)
      {
         IASTracePrintf("Error in SDO - InternalInitialize() - Caught unknown exception...");
         InternalShutdown();
         hr = E_FAIL;
      }
   }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
HRESULT   CSdo::InternalInitialize(
                  /*[in]*/ LPCWSTR         lpszSdoName,
                  /*[in]*/ LPCWSTR         lpszSdoProgId,
                    /*[in]*/ ISdoSchema*      pSdoSchema,
                  /*[in]*/ IDataStoreObject*   pDSObject,
                  /*[in]*/ ISdoCollection*   pParent,
                  /*[in]*/ bool            fInitNew
                          )
{
   // Check precondtions
   //
   _ASSERT( NULL != lpszSdoProgId && NULL != pSdoSchema );

   HRESULT   hr = S_OK;

   if ( ! m_fSdoInitialized )
   {
      try
      {
         // Get the SDO schema class for lpszSdoClassId
         //
         CComPtr<IUnknown> pUnknown;
         _bstr_t classId = lpszSdoProgId;
         hr = pSdoSchema->GetClass(classId, &pUnknown);
         if ( FAILED(hr) )
            throw _com_error(hr);

         CComPtr<ISdoClassInfo> pSdoClassInfo;
         hr = pUnknown->QueryInterface(IID_ISdoClassInfo, (void**)&pSdoClassInfo);
         if ( FAILED(hr) )
            throw _com_error(hr);

         // Initialize the SDO's properties from the schema class
         //
         AllocateProperties(pSdoClassInfo);

         // Set the SDO's class
         //
         PropertyMapIterator p = m_PropertyMap.find(PROPERTY_SDO_CLASS);
         _ASSERT( p != m_PropertyMap.end() );
         _variant_t vtClass = ::GetDataStoreClass(lpszSdoProgId);
         ((*p).second)->PutValue(&vtClass);

         // Set the SDO's name (if provided)
         //
         if ( lpszSdoName )
         {
            _variant_t vtName = lpszSdoName;
            hr = PutPropertyInternal(PROPERTY_SDO_NAME, &vtName);
            if ( FAILED(hr) )
               throw _com_error(hr);
         }
         // Save a reference to the parent object
         //
         if ( pParent )
         {
            m_pParent = pParent;
//            m_pParent->AddRef(); Weak reference for now...
         }
         // Save a reference to the data store object used to persist this objects state
         //
         if ( pDSObject )
         {
            m_pDSObject = pDSObject;
            m_pDSObject->AddRef();
            m_fPersistOnApply = TRUE;
         }

         hr = FinalInitialize(fInitNew, NULL);
         if ( FAILED(hr) )
            throw _com_error(hr);

         // Set the SDO's state to "initialized"
         //
         m_fSdoInitialized = TRUE;
      }
      catch(_com_error theError)
      {
         IASTracePrintf("Error in SDO - InternalInitialize() - Caught com_error exception...");
         InternalShutdown();
         hr = theError.Error();
      }
      catch(...)
      {
         IASTracePrintf("Error in SDO - InternalInitialize() - Caught unknown exception...");
         InternalShutdown();
         hr = E_FAIL;
      }
   }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::FinalInitialize(
                 /*[in]*/ bool         fInitNew,
                 /*[in]*/ ISdoMachine* pAttachedMachine
                      )
{
   if ( fInitNew )
      return S_OK;
   else
      return LoadProperties();
}


//////////////////////////////////////////////////////////////////////////////
void CSdo::InternalShutdown()
{
   if ( m_pParent )
   {
//      m_pParent->Release();   Weak reference for now...
      m_pParent = NULL;
   }
   if ( m_pDSObject )
   {
      m_pDSObject->Release();
      m_pDSObject = NULL;
   }
   FreeProperties();
   m_fSdoInitialized = FALSE;
}


////////////////////////////////////////////////////////////////////////////
void CSdo::AllocateProperties(
                      /*[in]*/ ISdoClassInfo* pSdoClassInfo
                             ) throw (_com_error)
{
   HRESULT hr = E_FAIL;

   SDO_TRACE_VERBOSE_1("Allocating properties for the SDO at $%p...",this);

   do
   {
      CComPtr<IEnumVARIANT> pPropertyEnum;
      hr = ::SDOGetClassPropertyEnumerator(PROPERTY_SET_REQUIRED, pSdoClassInfo, &pPropertyEnum);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO - AllocateProperties() - Could not get required property enumerator failed...");
         throw _com_error(hr);
      }

      CComPtr<ISdoPropertyInfo>  pSdoPropertyInfo;
      hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
      while ( S_OK == hr )
      {
         {
            auto_ptr<SDOPROPERTY> pProperty (new CSdoProperty(pSdoPropertyInfo, SDO_PROPERTY_MANDATORY));
            pair<PropertyMapIterator, bool> thePair = m_PropertyMap.insert(PropertyMap::value_type(pProperty->GetId(), pProperty.get()));
            if ( false == thePair.second )
               throw _com_error(E_FAIL);

            pProperty.release();
            SDO_TRACE_VERBOSE_3("Allocated property '%ls' of type %d for the SDO at $%p  ", pProperty->GetName(), pProperty->GetType(), this);
         }

         pSdoPropertyInfo.Release();
         hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
      }
      if ( S_FALSE == hr )
      {
         pPropertyEnum.Release();
         hr = ::SDOGetClassPropertyEnumerator(PROPERTY_SET_OPTIONAL, pSdoClassInfo, &pPropertyEnum);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO - AllocateProperties() - Could not get optional property enumerator failed...");
            throw _com_error(hr);
         }

         hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
         while ( S_OK == hr )
         {
            {
               auto_ptr<SDOPROPERTY> pProperty (new CSdoProperty(pSdoPropertyInfo));
               pair<PropertyMapIterator, bool> thePair = m_PropertyMap.insert(PropertyMap::value_type(pProperty->GetId(), pProperty.get()));
               if ( false == thePair.second )
                  throw _com_error(E_FAIL);

               pProperty.release();
               SDO_TRACE_VERBOSE_3("Allocated property '%ls' of type %d for the SDO at $%p  ", pProperty->GetName(), pProperty->GetType(), this);
            }

            pSdoPropertyInfo.Release();
            hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
         }
         if ( S_FALSE != hr )
            throw _com_error(hr);
      }
      else
      {
         throw _com_error(hr);
      }

   } while ( FALSE );
}


////////////////////////////////////////////////////////////////////////////
void CSdo::FreeProperties(void)
{
    PropertyMapIterator     p;

   SDO_TRACE_VERBOSE_1("Releasing properties for the SDO at $%p...",this);

    // Delete the properties we've allocated
   //
    p = m_PropertyMap.begin();
    while ( p != m_PropertyMap.end() )
    {
      SDO_TRACE_VERBOSE_3("Released property '%ls' of type %d from the SDO at $%p...",((*p).second)->GetName(),((*p).second)->GetType(), this);
        delete (*p).second; // Invokes ~CSdoProperty()
      p = m_PropertyMap.erase(p);
    }
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::LoadProperties()
{
    HRESULT  hr = S_OK;

   // Check preconditions
   //
   _ASSERT ( NULL != m_pDSObject );

   SDO_TRACE_VERBOSE_1("Loading properties for the SDO at $%p...",this);

   // The state of the object before the LoadProperties() operation
   // should be preserved in the event of a load failure. Thus, if
   // any single property fails to load then the entire load
   // operation fails and the state of the object remains unchanged.

    PropertyMapIterator p = m_PropertyMap.begin();
    while ( p != m_PropertyMap.end() )
    {
        // Load only persistent properties
        //
        if ( ! ( ((*p).second)->GetFlags() & SDO_PROPERTY_NO_PERSIST ) )
        {
            // Get the property value from the data store object
            //
            if ( ((*p).second)->GetFlags() & SDO_PROPERTY_MULTIVALUED )
               hr = m_pDSObject->GetValueEx(((*p).second)->GetName(), ((*p).second)->GetUpdateValue());
            else
               hr = m_pDSObject->GetValue(((*p).second)->GetName(), ((*p).second)->GetUpdateValue());

            if ( SUCCEEDED(hr) )
            {
            SDO_TRACE_VERBOSE_3("Loaded property '%ls' of type %d for the SDO at $%p...", ((*p).second)->GetName(), ((*p).second)->GetType(), this);
         }
         else
         {
                // If a mandatory property fails to load and we don't have a default value for it
            // then we have an error condition
            //
                if ( ((*p).second)->GetFlags() & SDO_PROPERTY_MANDATORY )
            {
               if ( ((*p).second)->GetFlags() & SDO_PROPERTY_HAS_DEFAULT )
               {
                  SDO_TRACE_VERBOSE_1("SDO - LoadProperties() - GetValue('%ls') failed...",((*p).second)->GetName());
               }
               else
               {
                  IASTracePrintf("Error in SDO - LoadProperties() - Mandatory property '%ls' failed to load...", ((*p).second)->GetName());
                  break;
               }
            }
            else
            {
               SDO_TRACE_VERBOSE_1("SDO - LoadProperties() - GetValue('%ls') failed...",((*p).second)->GetName());
            }
              ((*p).second)->Reset();
                hr = S_OK;
            }
        }
        p++;
    }

   // Use the newly loaded values and flag the object as
   // persisted so that it can be restored via ISdo::Restore()
   //
   if ( SUCCEEDED(hr) )
   {
       p = m_PropertyMap.begin();
      while ( p != m_PropertyMap.end() )
      {
         if ( ! (((*p).second)->GetFlags() & SDO_PROPERTY_NO_PERSIST) )
            ((*p).second)->SetUpdateValue();
         p++;
      }
      m_fIsPersisted = TRUE;
   }
   else
   {
      while ( p != m_PropertyMap.begin() )
      {
         if ( ! (((*p).second)->GetFlags() & SDO_PROPERTY_NO_PERSIST) )
            VariantClear(((*p).second)->GetUpdateValue());
         p--;
      }
   }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::SaveProperties()
{
    HRESULT  hr = S_OK;

   // Check preconditions
   //
   _ASSERT ( NULL != m_pDSObject );

   SDO_TRACE_VERBOSE_1("Saving properties for the SDO at $%p...",this);

    // Put the SDO property values into the underlying data store
    //
    PropertyMapIterator p = m_PropertyMap.begin();
    while ( p != m_PropertyMap.end() )
    {
        // Make sure we're supposed to persist this property
        //
        if ( ! ( ((*p).second)->GetFlags() & SDO_PROPERTY_NO_PERSIST) )
        {
           // Empty properties don't get persisted
         //
            if ( VT_EMPTY == V_VT(((*p).second)->GetValue()) )
            {
               // Mandatory properties cannot be empty
             //
               if ( ((*p).second)->GetFlags() & SDO_PROPERTY_MANDATORY )
                {
               _ASSERT(FALSE);   // Contractual Error (precondition violation)
                    hr = E_FAIL;
                    break;
                }
         }

            // Persist the property
         //
            hr = m_pDSObject->PutValue(((*p).second)->GetName(), ((*p).second)->GetValue());
            if ( FAILED(hr) )
            {
            IASTracePrintf("Error in SDO - SaveProperties() - Could not persist SDO changes because PutValue() failed for property '%ls'...", ((*p).second)->GetName());
                break;
            }

         SDO_TRACE_VERBOSE_3("Saved property '%ls' of type %d from the SDO at $%p...", ((*p).second)->GetName(), ((*p).second)->GetType(), this);
        }
        p++;
    }
    if ( SUCCEEDED(hr) )
    {
        // Now persist the changes
        //
        hr = m_pDSObject->Update();
        if ( SUCCEEDED(hr) )
        {
         // Flag the object as persisted so that it can be restored via ISdo::Restore()
         //
         m_fIsPersisted = TRUE;
      }
      else
      {
         IASTracePrintf("Error in SDO - SaveProperties() - Could not persist the SDO changes because Update() failed...");
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
HRESULT CSdo::GetPropertyInternal(
                         /*[in]*/ LONG     lPropertyId,
                     /*[in]*/ VARIANT* pValue
                            ) throw()
{
   HRESULT   hr = E_FAIL;

   PropertyMapIterator p = m_PropertyMap.find(lPropertyId);
   _ASSERT( p != m_PropertyMap.end() );
   if ( p != m_PropertyMap.end() )
   {
      hr = ((*p).second)->GetValue(pValue);
      _ASSERT( SUCCEEDED(hr) );
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - GetPropertyInternal() - GetValue() failed...\n");
   }
   else
   {
      IASTracePrintf("Error in SDO - GetPropertyInternal() - Invalid property Id...\n");
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////
HRESULT CSdo::PutPropertyInternal(
                        /*[in]*/ LONG     lPropertyId,
                     /*[in]*/ VARIANT* pValue
                           ) throw()
{
   HRESULT   hr = E_FAIL;

   PropertyMapIterator p = m_PropertyMap.find(lPropertyId);
   _ASSERT( p != m_PropertyMap.end() );
   if ( p != m_PropertyMap.end() )
   {
      hr = ((*p).second)->PutValue(pValue);
      _ASSERT( SUCCEEDED(hr) );
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - PutPropertyInternal() - PutValue() failed...\n");
   }
   else
   {
      IASTracePrintf("Error in SDO - PutPropertyInternal() - Invalid property Id...\n");
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////
HRESULT CSdo::ChangePropertyDefaultInternal(
                           /*[in]*/ LONG     lPropertyId,
                           /*[in]*/ VARIANT* pValue
                                 ) throw()
{
   HRESULT   hr = E_FAIL;

   PropertyMapIterator p = m_PropertyMap.find(lPropertyId);
   _ASSERT( p != m_PropertyMap.end() );
   if ( p != m_PropertyMap.end() )
   {
      hr = ((*p).second)->PutDefault(pValue);
      _ASSERT( SUCCEEDED(hr) );
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - ChangePropertyDefault() - PutDefault() failed...\n");
   }
   else
   {
      IASTracePrintf("Error in SDO - ChangePropertyDefault() - Invalid property Id...\n");
   }

   return hr;
}



//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::InitializeCollection(
                 LONG CollectionPropertyId,
                 LPCWSTR lpszCreateClassId,
                 ISdoMachine* pSdoMachine,
                 IDataStoreContainer* pDSContainer,
                 size_t maxSize
                 ) throw ()
{
   ISdoCollection* pSdoCollection = ::MakeSDOCollection(
                                           lpszCreateClassId,
                                           pSdoMachine,
                                           pDSContainer,
                                           maxSize
                                           );
   if ( NULL == pSdoCollection )
   {
      IASTracePrintf("Error in SDO - InitializeCollection() - MakeSDOCollection failed...");
      return E_FAIL;
   }
   _variant_t vtDispatch;
   V_VT(&vtDispatch) = VT_DISPATCH;
   HRESULT hr = pSdoCollection->QueryInterface(IID_IDispatch, (void**)&vtDispatch.pdispVal);
   pSdoCollection->Release();
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO - InitializeCollection() - QueryInterface(IDispatch) failed...");
      return hr;
   }
   hr = PutPropertyInternal(CollectionPropertyId, &vtDispatch);
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::Load(void)
{
   return LoadProperties();
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdo::Save(void)
{
   return SaveProperties();
}


//////////////////////////////////////////////////////////////////////////
void CSdo::NoPersist(void)
{
   if ( m_pDSObject )
   {
      m_pDSObject->Release();
      m_pDSObject = NULL;
      m_fPersistOnApply = FALSE;
   }
}


//////////////////////////////////////////////////////////////////////////
HRESULT CSdo::ValidateProperty(
                   /*[in]*/ PSDOPROPERTY pProperty,
                   /*[in]*/ VARIANT* pValue
                          )
{
   return pProperty->Validate(pValue);
}


//////////////////////////////////////////////////////////////////////////
HRESULT CSdo::GetDatastoreName(VARIANT* pDSName)
{
   HRESULT hr = DISP_E_MEMBERNOTFOUND;
   if ( m_pDSObject )
   {
      BSTR bstrDSName;
      hr = m_pDSObject->get_Name(&bstrDSName);
      if ( SUCCEEDED(hr) )
      {
         VariantInit(pDSName);
         V_VT(pDSName) = VT_BSTR;
         V_BSTR(pDSName) = bstrDSName;
      }
      else
      {
         IASTracePrintf("Error in SDO - GetDatastoreName() - get_Name() failed...");
      }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoclient.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class CSdoClient.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdoclient.h"
#include "sdohelperfuncs.h"


CSdoClient::~CSdoClient() throw ()
{
}


HRESULT CSdoClient::ValidateProperty(
                       PSDOPROPERTY pProperty,
                       VARIANT* pValue
                       ) throw ()
{
   HRESULT hr = pProperty->Validate(pValue);
   if (SUCCEEDED(hr) && (pProperty->GetId() == PROPERTY_CLIENT_ADDRESS))
   {
      if (IASIsStringSubNetW(V_BSTR(pValue)))
      {
         IAS_PRODUCT_LIMITS limits;
         hr = SDOGetProductLimits(m_pParent, &limits);
         if (SUCCEEDED(hr) && !limits.allowSubnetSyntax)
         {
            hr = IAS_E_LICENSE_VIOLATION;
         }
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoattribute.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdoattribute.cpp
//
// SYNOPSIS
//
//    Defines the class SdoAttribute.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <memory>
#include <attrdef.h>
#include <sdoattribute.h>

inline SdoAttribute::SdoAttribute(
                         const AttributeDefinition* definition
                         ) throw ()
   : def(definition), refCount(0)
{
   def->AddRef();
   VariantInit(&value);
}

inline SdoAttribute::~SdoAttribute() throw ()
{
   VariantClear(&value);
   def->Release();
}

HRESULT SdoAttribute::createInstance(
                          const AttributeDefinition* definition,
                          SdoAttribute** newAttr
                          ) throw ()
{
   // Check the arguments.
   if (definition == NULL || newAttr == NULL) { return E_INVALIDARG; }

   // Create a new SdoAttribute.
   *newAttr = new (std::nothrow) SdoAttribute(definition);
   if (!*newAttr) { return E_OUTOFMEMORY; }

   // Set the reference count to one.
   (*newAttr)->refCount = 1;

   return S_OK;
}

STDMETHODIMP_(ULONG) SdoAttribute::AddRef()
{
   return InterlockedIncrement(&refCount);
}

STDMETHODIMP_(ULONG) SdoAttribute::Release()
{
   ULONG l = InterlockedDecrement(&refCount);

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP SdoAttribute::QueryInterface(REFIID iid, void ** ppvObject)
{
   if (ppvObject == NULL) { return E_POINTER; }

   if (iid == __uuidof(ISdo) ||
       iid == __uuidof(IUnknown) ||
       iid == __uuidof(IDispatch))
   {
      *ppvObject = this;
   }
   else
   {
      return E_NOINTERFACE;
   }

   InterlockedIncrement(&refCount);

   return S_OK;
}

STDMETHODIMP SdoAttribute::GetPropertyInfo(LONG Id, IUnknown** ppPropertyInfo)
{ return E_NOTIMPL; }

STDMETHODIMP SdoAttribute::GetProperty(LONG Id, VARIANT* pValue)
{
   if (Id != PROPERTY_ATTRIBUTE_VALUE)
   {
      // Everything but the value comes from the attribute definition.
      return def->getProperty(Id, pValue);
   }

   if (pValue == NULL) { return E_INVALIDARG; }

   VariantInit(pValue);

   return VariantCopy(pValue, &value);
}

STDMETHODIMP SdoAttribute::PutProperty(LONG Id, VARIANT* pValue)
{
   if (Id == PROPERTY_ATTRIBUTE_VALUE)
   {
      // Make a copy of the supplied value.
      VARIANT tmp;
      VariantInit(&tmp);
      HRESULT hr = VariantCopy(&tmp, pValue);
      if (SUCCEEDED(hr))
      {
         // Replace our current value with the new one.
         VariantClear(&value);
         value = tmp;
      }

      return hr;
   }

   // All other properties are read-only.
   return E_ACCESSDENIED;
}

STDMETHODIMP SdoAttribute::ResetProperty(LONG Id)
{ return S_OK; }

STDMETHODIMP SdoAttribute::Apply()
{ return S_OK; }

STDMETHODIMP SdoAttribute::Restore()
{ return S_OK; }

STDMETHODIMP SdoAttribute::get__NewEnum(IUnknown** ppEnumVARIANT)
{ return E_NOTIMPL; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdobasedefs.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdobasedefs.h
//
// Project:     Everest
//
// Description: Common classes and definitions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SDO_BASE_DEFS_H_
#define __INC_SDO_BASE_DEFS_H_

#include <ias.h>
#include <sdoias.h>
#include <comutil.h>
#include <comdef.h>
#include <iascomp.h>  

#include <map>
#include <list>
using namespace std;


// Ole DB Driver 
//
#define IAS_DICTIONARY_DRIVER			L"Microsoft.Jet.OLEDB.4.0"


//////////////////////////////////////////////////////////////
// Debug/Error Trace Macros - Wrap Underlying Trace Facilities
//////////////////////////////////////////////////////////////

///////////////////////////////////
// Trace Functin Wrappers

#define		SDO_ERROR_ID	0x100
#define		SDO_DEBUG_ID	0x200

#define		TRACE_FUNCTION_WRAPPER(x)		\
			TRACE_FUNCTION(x);

#define		ERROR_TRACE_WRAPPER(dbgmsg)       \
			ErrorTrace(SDO_ERROR_ID, dbgmsg); \

#define		ERROR_TRACE_WRAPPER_1(dbgmsg, param)     \
			ErrorTrace(SDO_ERROR_ID, dbgmsg, param); \

#define		DEBUG_TRACE_WRAPPER(dbgmsg)				\
			DebugTrace(SDO_DEBUG_ID, dbgmsg);

#define		DEBUG_TRACE_WRAPPER_1(dbgmsg, param)	\
			DebugTrace(SDO_ERROR_ID, dbgmsg, param);

/////////////////////////////////////////////////////////
// Object Management Classes
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//
// Master Pointer Tasks 
//
// 1) Object instance counting
// 2) Object construction and destruction
// 3) Object lifetime control through reference counting
//
////////////////////////////////////////////////////////

template <class T>
class CSdoMasterPtr
{

public:

	// Either master pointer constructor can result in an exception being thrown. 
	// Creator of the master pointer is responsible for handling exceptions
	//
	/////////////////////////////////////////
	CSdoMasterPtr(LONG PointeeType, LONG PointeeId)
		: m_pT(new T(PointeeType, PointeeId)), m_dwRefCount(0) 
	{ m_dwInstances++; }

	/////////////////////////////////////////
	CSdoMasterPtr()
		: m_pT(new T), m_dwRefCount(0) 
	{ m_dwInstances++; }

	// T must have a copy constructor or must work with the default C++ 
	// copy constructor
	//
	/////////////////////////////////////////
	//CSdoMasterPtr(const CSdoMasterPtr<T>& mp)
	//	: m_pT(new T(*(mp.m_pT))), m_dwRefCount(0) 
	//{ m_dwInstances++; }


	/////////////////////////////////////////
	~CSdoMasterPtr() 
	{ _ASSERT( 0 == m_dwRefCount ); delete m_pT; }


	/////////////////////////////////////////
	CSdoMasterPtr<T>& operator = (const CSdoMasterPtr<T>& mp)
	{
		// Check for assignment to self
		//
		if ( this ! &mp )
		{
			// Delete object pointed at and create a new one
			// User of the master pointer is responsible for catching
			// any exception thrown as a result of creating a object
			//
			delete m_pT;
			m_dwInstances--;
			m_pT = new T(*(mp.m_pT));
		}
		return *this;
    }

	
	/////////////////////////////////////////
	T* operator->() 
	{ _ASSERT( NULL != m_pT ); return m_pT; }

	
	/////////////////////////////////////////
	void Hold(void)
	{
		m_dwRefCount++;
	}

	/////////////////////////////////////////
	void Release(void)
	{
		// Handle case where someone calls Release when ref count is 0.
		//
		if ( m_dwRefCount > 0 )
			m_dwRefCount--;
		
		if ( 0 >= m_dwRefCount )
		{
			m_dwInstances--;
			delete this;	// ~CSdoMasterPtr() deletes m_pT
		}
	}

	/////////////////////////////////////////
	DWORD GetInstanceCount(void);

private:

	// T must have a copy constructor or must work with the default C++ 
	// copy constructor. This is not the case here...
	//
	/////////////////////////////////////////
	CSdoMasterPtr(const CSdoMasterPtr<T>& mp)
		: m_pT(new T(*(mp.m_pT))), m_dwRefCount(0) 
	{ m_dwInstances++; }

	T*					m_pT;			// Actual object
	DWORD				m_dwRefCount;	// Ref count
	static DWORD		m_dwInstances;	// Instances
};


/////////////////////////////////////////////////////////
//
// SDO Handle Tasks 
//
// 1) Master Pointer Object creation
// 2) Hide use of reference counting from programmer
//
////////////////////////////////////////////////////////

template <class T> 
class CSdoHandle
{

public:

	/////////////////////////////////////////
	CSdoHandle()
		: m_mp(NULL) { }

	/////////////////////////////////////////
	CSdoHandle(CSdoMasterPtr<T>* mp) 
		: m_mp(mp) 
	{ 
		_ASSERT( NULL != m_mp );
		m_mp->Hold(); 
	}

	/////////////////////////////////////////
	CSdoHandle(const CSdoHandle<T>& h)
		: m_mp(h.m_mp) 
	{ 
		if ( NULL != m_mp )
			m_mp->Hold(); 
	}

	/////////////////////////////////////////
	~CSdoHandle()
	{ 
		if ( NULL != m_mp )
			m_mp->Release(); 
	}

	/////////////////////////////////////////
	CSdoHandle<T>& operator = (const CSdoHandle<T>& h)
	{
		// Check for reference to self and instance where
		// h points to the same mp we do.
		//
		if ( this != &h && m_mp != h.m_mp )
		{
			if ( NULL != m_mp )
				m_mp->Release();
			m_mp = h.m_mp;
			if ( NULL != m_mp )
				m_mp->Hold();
		}

		return *this;
	}

	/////////////////////////////////////////
	CSdoMasterPtr<T>& operator->() 
	{ 
		_ASSERT( NULL != m_mp ); 
		return *m_mp; 
	}
	
	
	/////////////////////////////////////////
	bool IsValid()
	{
		return (NULL != m_mp ? true : false);
	}


private:

	CSdoMasterPtr<T>*	m_mp;
};


#endif //__INC_SDO_BASE_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sdoias.rc
//
#define IDS_PROJNAME                      110000
#define IDS_SDOMACHINE_DESC               119000
#define IDR_SdoMachine                    120000
#define IDS_SDOSERVICE_DESC               121000
#define IDR_SdoService                    122000
#define IDS_SDOPIPELINE_DESC              123000
#define IDR_SdoPipeline                   124000
#define IDS_INFOTIP                       125000
#define IDS_SHORTCUT_DISPLAY              126000
#define IDS_DESC_NOT_AVAIL                127000

#define IDS_M90 -90
#define IDS_1 1
#define IDS_2 2
#define IDS_3 3
#define IDS_4 4
#define IDS_5 5
#define IDS_6 6
#define IDS_7 7
#define IDS_8 8
#define IDS_9 9
#define IDS_10 10
#define IDS_11 11
#define IDS_12 12
#define IDS_13 13
#define IDS_14 14
#define IDS_15 15
#define IDS_16 16
#define IDS_18 18
#define IDS_19 19
#define IDS_20 20
#define IDS_22 22
#define IDS_23 23
#define IDS_24 24
#define IDS_25 25
#define IDS_26 26
#define IDS_27 27
#define IDS_28 28
#define IDS_29 29
#define IDS_30 30
#define IDS_31 31
#define IDS_32 32
#define IDS_33 33
#define IDS_34 34
#define IDS_35 35
#define IDS_36 36
#define IDS_37 37
#define IDS_38 38
#define IDS_39 39
#define IDS_40 40
#define IDS_41 41
#define IDS_42 42
#define IDS_43 43
#define IDS_44 44
#define IDS_45 45
#define IDS_46 46
#define IDS_47 47
#define IDS_48 48
#define IDS_49 49
#define IDS_50 50
#define IDS_51 51
#define IDS_52 52
#define IDS_53 53
#define IDS_55 55
#define IDS_60 60
#define IDS_61 61
#define IDS_62 62
#define IDS_63 63
#define IDS_64 64
#define IDS_65 65
#define IDS_66 66
#define IDS_67 67
#define IDS_68 68
#define IDS_69 69
#define IDS_70 70
#define IDS_71 71
#define IDS_72 72
#define IDS_73 73
#define IDS_74 74
#define IDS_75 75
#define IDS_76 76
#define IDS_77 77
#define IDS_78 78
#define IDS_79 79
#define IDS_80 80
#define IDS_81 81
#define IDS_82 82
#define IDS_83 83
#define IDS_85 85
#define IDS_86 86
#define IDS_87 87
#define IDS_88 88
#define IDS_90 90
#define IDS_91 91
#define IDS_108 108
#define IDS_120 120
#define IDS_121 121
#define IDS_122 122
#define IDS_125 125
#define IDS_126 126
#define IDS_131 131
#define IDS_132 132
#define IDS_135 135
#define IDS_136 136
#define IDS_139 139
#define IDS_141 141
#define IDS_152 152
#define IDS_153 153
#define IDS_154 154
#define IDS_155 155
#define IDS_156 156
#define IDS_157 157
#define IDS_158 158
#define IDS_159 159
#define IDS_160 160
#define IDS_161 161
#define IDS_162 162
#define IDS_163 163
#define IDS_164 164
#define IDS_165 165
#define IDS_166 166
#define IDS_167 167
#define IDS_168 168
#define IDS_169 169
#define IDS_170 170
#define IDS_171 171
#define IDS_172 172
#define IDS_173 173
#define IDS_174 174
#define IDS_175 175
#define IDS_176 176
#define IDS_177 177
#define IDS_178 178
#define IDS_179 179
#define IDS_180 180
#define IDS_181 181
#define IDS_182 182
#define IDS_183 183
#define IDS_184 184
#define IDS_185 185
#define IDS_186 186
#define IDS_187 187
#define IDS_188 188
#define IDS_189 189
#define IDS_190 190
#define IDS_191 191
#define IDS_192 192
#define IDS_193 193
#define IDS_194 194
#define IDS_195 195
#define IDS_196 196
#define IDS_197 197
#define IDS_198 198
#define IDS_199 199
#define IDS_200 200
#define IDS_201 201
#define IDS_202 202
#define IDS_203 203
#define IDS_204 204
#define IDS_205 205
#define IDS_206 206
#define IDS_207 207
#define IDS_208 208
#define IDS_209 209
#define IDS_210 210
#define IDS_211 211
#define IDS_212 212
#define IDS_213 213
#define IDS_214 214
#define IDS_215 215
#define IDS_216 216
#define IDS_217 217
#define IDS_218 218
#define IDS_219 219
#define IDS_220 220
#define IDS_221 221
#define IDS_222 222
#define IDS_223 223
#define IDS_224 224
#define IDS_225 225
#define IDS_226 226
#define IDS_227 227
#define IDS_228 228
#define IDS_229 229
#define IDS_230 230
#define IDS_231 231
#define IDS_232 232
#define IDS_233 233
#define IDS_234 234
#define IDS_235 235
#define IDS_236 236
#define IDS_238 238
#define IDS_239 239
#define IDS_240 240
#define IDS_241 241
#define IDS_242 242
#define IDS_243 243
#define IDS_244 244
#define IDS_245 245
#define IDS_246 246
#define IDS_247 247
#define IDS_248 248
#define IDS_249 249
#define IDS_250 250
#define IDS_251 251
#define IDS_252 252
#define IDS_253 253
#define IDS_254 254
#define IDS_4096 4096
#define IDS_4097 4097
#define IDS_4098 4098
#define IDS_4099 4099
#define IDS_4100 4100
#define IDS_4101 4101
#define IDS_4102 4102
#define IDS_4103 4103
#define IDS_4104 4104
#define IDS_4105 4105
#define IDS_4106 4106
#define IDS_4107 4107
#define IDS_4108 4108
#define IDS_4116 4116
#define IDS_4117 4117
#define IDS_4127 4127
#define IDS_4128 4128
#define IDS_4129 4129
#define IDS_4130 4130
#define IDS_4131 4131
#define IDS_4132 4132
#define IDS_4149 4149
#define IDS_4158 4158
#define IDS_4161 4161
#define IDS_4162 4162
#define IDS_4163 4163
#define IDS_4165 4165
#define IDS_4166 4166
#define IDS_4167 4167
#define IDS_4168 4168
#define IDS_4169 4169
#define IDS_5000 5000
#define IDS_6000 6000
#define IDS_6001 6001

    
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           134
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdo.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdo.h
//
// Project:     Everest
//
// Description: IAS Server Data Object Declaration
//
// Author:      TLP 1/23/98
//
// When         Who    What
// ----         ---    ----
// 2/28/98      TLP    Prepare for IDataStore2
// 8/24/98      SEB    MS-CHAP handler moved to NTSamAuthentication.
//
///////////////////////////////////////////////////////////////////////////

#ifndef __IAS_SDO_H_
#define __IAS_SDO_H_

#include "resource.h"
#include <iascomp.h>
#include <comdef.h>
#include <sdoiaspriv.h>
#include <datastore2.h>
#include "sdoproperty.h"

#include <map>
#include <vector>
#include <string>
using namespace std;


/////////////////////////////////////////////////////////////////////////////
// Enumeration class definition
/////////////////////////////////////////////////////////////////////////////
typedef CComEnum< IEnumVARIANT,
                  &__uuidof(IEnumVARIANT),
                  VARIANT,
                  _Copy<VARIANT>,
                  CComSingleThreadModel
                > EnumVARIANT;

//////////////////////////
// Tracing Flags
/////////////////////////

// #define   SDO_TRACE_VERBOSE

#ifdef  SDO_TRACE_VERBOSE

#define SDO_TRACE_VERBOSE_0(msg)                  IASTracePrintf(msg)
#define SDO_TRACE_VERBOSE_1(msg,param1)               IASTracePrintf(msg,param1)
#define SDO_TRACE_VERBOSE_2(msg,param1,param2)         IASTracePrintf(msg,param1,param2)
#define   SDO_TRACE_VERBOSE_3(msg,param1,param2,param3)   IASTracePrintf(msg,param1,param2,param3)

#else

#define SDO_TRACE_VERBOSE_0(msg)
#define SDO_TRACE_VERBOSE_1(msg,param1)
#define SDO_TRACE_VERBOSE_2(msg,param1,param2)
#define   SDO_TRACE_VERBOSE_3(msg,param1,param2,param3)

#endif

//////////////////////////////////////
// IAS Policy Registry Key

#define      IAS_POLICY_REG_KEY   L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy"

/////////////////////////////////////////////////
// Well - Known names of data store entities

#define     SDO_STOCK_PROPERTY_CLASS      L"class"
#define     SDO_STOCK_PROPERTY_NAME         L"name"
#define      SDO_STOCK_PROPERTY_CLASS_ID      L"Component Prog Id"

/////////////////////////////////////////////
// IAS Service Data Store Type Registry Value

#define      IAS_DATASTORE_TYPE               L"DataStoreType"

//////////////////////////////
// Data Store Object Names
//
#define DS_OBJECT_CLIENTS          L"Clients"
#define DS_OBJECT_SERVICE          L"Microsoft Internet Authentication Service"
#define DS_OBJECT_PROFILES         L"RadiusProfiles"
#define DS_OBJECT_POLICIES         L"NetworkPolicy"
#define DS_OBJECT_PROTOCOLS        L"Protocols"
#define DS_OBJECT_AUDITORS         L"Auditors"
#define DS_OBJECT_REQUESTHANDLERS  L"RequestHandlers"
#define DS_OBJECT_VENDORS          L"Vendors"
#define DS_OBJECT_RADIUSGROUPS     L"RADIUS Server Groups"
#define DS_OBJECT_PROXY_POLICIES   L"Proxy Policies"
#define DS_OBJECT_PROXY_PROFILES   L"Proxy Profiles"

///////////////////
// Record Set Names
//
#define     RECORD_SET_DICTIONARY_ATTRIBUTES    L"Attributes"
#define     RECORD_SET_DICTIONARY_ENUMERATORS   L"Enumerators"

///////////////////////////
// Class Names and Prog IDs
//
#define SDO_CLASS_NAME_ATTRIBUTE        L"Attribute"
#define SDO_CLASS_NAME_ATTRIBUTE_VALUE  L"AttributeValue"
#define SDO_CLASS_NAME_CLIENT           L"Client"
#define SDO_CLASS_NAME_CONDITION        L"Condition"
#define SDO_CLASS_NAME_PROFILE          L"msRADIUSProfile"  // ADSI Class
#define SDO_CLASS_NAME_POLICY           L"msNetworkPolicy"  // ADSI Class
#define SDO_CLASS_NAME_USER             L"user"             // ADSI Class
#define SDO_CLASS_NAME_DICTIONARY       L"Dictionary"
#define SDO_CLASS_NAME_SERVICE          L"Service"
#define SDO_CLASS_NAME_COMPONENT        L"Component"
#define SDO_CLASS_NAME_VENDOR           L"Vendor"

#define SDO_PROG_ID_ATTRIBUTE           L"IAS.SdoAttribute"
#define SDO_PROG_ID_ATTRIBUTE_VALUE     L"IAS.SdoAttributeValue"
#define SDO_PROG_ID_CLIENT              L"IAS.SdoClient"
#define SDO_PROG_ID_CONDITION           L"IAS.SdoCondition"
#define SDO_PROG_ID_PROFILE             L"IAS.SdoProfile"
#define SDO_PROG_ID_POLICY              L"IAS.SdoPolicy"
#define SDO_PROG_ID_USER                L"IAS.SdoUser"
#define SDO_PROG_ID_DICTIONARY          L"IAS.SdoDictionary"
#define SDO_PROG_ID_SERVICE             L"IAS.SdoServiceIAS"
#define SDO_PROG_ID_VENDOR              L"IAS.SdoVendor"
#define SDO_PROG_ID_RADIUSGROUP         L"IAS.SdoRadiusServerGroup"
#define SDO_PROG_ID_RADIUSSERVER        L"IAS.SdoRadiusServer"

// Wrap ATL Multi-Threaded Com Base Class Critical Section
//
class CSdoLock
{

public:

    CSdoLock(CComObjectRootEx<CComMultiThreadModel>& T) throw()
        : m_theLock(T)
    { m_theLock.Lock(); }

    ~CSdoLock() throw()
    { m_theLock.Unlock(); }

protected:

    CComObjectRootEx<CComMultiThreadModel>& m_theLock;
};


/////////////////////////////////////////////////////////////////////////////
// Class:       CSdo
//
// Description: All SDOs that export ISdo inherit from this class
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CSdo :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatchImpl<ISdo, &IID_ISdo, &LIBID_SDOIASLib>
{

public:

   //////////////////////////////////////////////////////////////////////////
    CSdo();

   //////////////////////////////////////////////////////////////////////////
   virtual ~CSdo();

   //////////////////////////////////////////////////////////////////////////
   HRESULT   InternalInitialize(
                  /*[in]*/ LPCWSTR         lpszSdoName,
                  /*[in]*/ LPCWSTR         lpszSdoProgId,
                    /*[in]*/ ISdoMachine*      pSdoMachine,
                  /*[in]*/ IDataStoreObject*   pDSObject,
                  /*[in]*/ ISdoCollection*   pParent,
                  /*[in]*/ bool            fInitNew
                       ) throw();

   //////////////////////////////////////////////////////////////////////////
   HRESULT   InternalInitialize(
                  /*[in]*/ LPCWSTR         lpszSdoName,
                  /*[in]*/ LPCWSTR         lpszSdoProgId,
                    /*[in]*/ ISdoSchema*      pSdoSchema,
                  /*[in]*/ IDataStoreObject*   pDSObject,
                  /*[in]*/ ISdoCollection*   pParent,
                  /*[in]*/ bool            fInitNew
                       ) throw();

    //////////////////
    // ISdo Interface
    //////////////////

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetPropertyInfo)(
                  /*[in]*/ LONG Id,
                  /*[out]*/ IUnknown** ppSdoPropertyInfo
                       );

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetProperty)(
                   /*[in]*/ LONG Id,
                  /*[out]*/ VARIANT* pValue
                          );

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(PutProperty)(
                   /*[in]*/ LONG Id,
                   /*[in]*/ VARIANT* pValue
                          );

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(ResetProperty)(
                     /*[in]*/ LONG Id
                            );

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(Apply)(void);

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(Restore)(void);

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get__NewEnum)(
                   /*[out]*/ IUnknown** pEnumVARIANT   // Property Enumerator
                           );

protected:

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT FinalInitialize(
                      /*[in]*/ bool         fInitNew,
                      /*[in]*/ ISdoMachine* pAttachedMachine
                           ) throw();

   //////////////////////////////////////////////////////////////////////////
   void InternalShutdown(void) throw();

   //////////////////////////////////////////////////////////////////////////
    HRESULT LoadProperties() throw();

   //////////////////////////////////////////////////////////////////////////
    HRESULT SaveProperties() throw();


   //////////////////////////////////////////////////////////////////////////
   BOOL IsSdoInitialized(void) const throw()
   { return m_fSdoInitialized;   }

   //////////////////////////////////////////////////////////////////////////
   void NoPersist(void) throw();

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT InitializeProperty(LONG lPropertyId) throw()
   { return S_OK; }

   //////////////////////////////////////////////////////////////////////////
   HRESULT GetPropertyInternal(
                      /*[in]*/ LONG     lPropertyId,
                  /*[in]*/ VARIANT* pValue
                         ) throw();

   //////////////////////////////////////////////////////////////////////////
   HRESULT PutPropertyInternal(
                      /*[in]*/ LONG     lPropertyId,
                  /*[in]*/ VARIANT* pValue
                         ) throw();

   //////////////////////////////////////////////////////////////////////////
   HRESULT ChangePropertyDefaultInternal(
                          /*[in]*/ LONG     lPropertyId,
                          /*[in]*/ VARIANT* pValue
                               ) throw();

   //////////////////////////////////////////////////////////////////////////
   HRESULT InitializeCollection(
              LONG CollectionPropertyId,
              LPCWSTR lpszCreateClassId,
              ISdoMachine* pSdoMachine,
              IDataStoreContainer* pDSContainer,
              size_t maxSize = INFINITE
              ) throw();

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT Load(void) throw();

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT Save(void) throw();

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT ValidateProperty(
                       /*[in]*/ PSDOPROPERTY pProperty,
                      /*[in]*/ VARIANT* pValue
                             ) throw();

   //////////////////////////////////////////////////////////////////////////

    typedef map<LONG, CSdoProperty*>  PropertyMap;
    typedef PropertyMap::iterator     PropertyMapIterator;

    // This SDO's property map
    PropertyMap         m_PropertyMap;

   // Parent object
   ISdoCollection*      m_pParent;

    // Data store object into which this SDO is persisted
    IDataStoreObject*   m_pDSObject;

private:

   CSdo(const CSdo& rhs);
   CSdo& operator = (CSdo& rhs);

    /////////////
    // Properties
    /////////////

    // Sdo state flag - Set to true once the SDO has been initialized
    BOOL            m_fSdoInitialized;

    // Persist the object at apply time
    BOOL            m_fPersistOnApply;

    // Set if object has been persisted (and can therfore be restored)
    BOOL            m_fIsPersisted;

   ////////////////////
   // Private Functions
   ////////////////////

   //////////////////////////////////////////////////////////////////////////
    void AllocateProperties(
                 /*[in]*/ ISdoClassInfo* pSdoClassInfo
                       )  throw (_com_error);

   //////////////////////////////////////////////////////////////////////////
    void FreeProperties(void) throw();


   //////////////////////////////////////////////////////////////////////////
   HRESULT GetDatastoreName(
                    /*[in*/ VARIANT* pDSName
                       ) throw();
};

#endif //__IAS_SDO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoclient.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class CSdoClient
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDOCLIENT_H
#define SDOCLIENT_H
#pragma once

#include "sdo.h"
#include "sdofactory.h"


class CSdoClient : public CSdo
{

public:

DECLARE_SDO_FACTORY(CSdoClient);

BEGIN_COM_MAP(CSdoClient)
   COM_INTERFACE_ENTRY_IID(__uuidof(ISdo), ISdo)
   COM_INTERFACE_ENTRY_IID(__uuidof(IDispatch), IDispatch)
END_COM_MAP()

   CSdoClient() throw ();
   virtual ~CSdoClient() throw ();

   virtual HRESULT ValidateProperty(
                      PSDOPROPERTY pProperty,
                      VARIANT* pValue
                      ) throw ();

private:
   // Not implemented.
   CSdoClient(const CSdoClient& rhs);
   CSdoClient& operator = (CSdoClient& rhs);
};


inline CSdoClient::CSdoClient() throw ()
{
}

#endif // SDOCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocollection.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocollection.h
//
// Project:     Everest
//
// Description: IAS Server Data Object Collection Declaration
//
// Author:      TLP 1/23/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef __IAS_SDOCOLLECTION_H_
#define __IAS_SDOCOLLECTION_H_

#include <ias.h>
#include <sdoiaspriv.h>
#include <comdef.h>         // COM definitions - Needed for IEnumVARIANT
#include "resource.h"       // main symbols

#include <vector>
using namespace std;

///////////////////////////////////////////////////////////////////////////////
#define      EMPTY_NAME      L""

/////////////////////////////////////////////////////////////////////////////
// CSdoCollection Class Declaration
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CSdoCollection :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatchImpl<ISdoCollection, &IID_ISdoCollection, &LIBID_SDOIASLib>,
   public IASProductLimits
{

public:

    CSdoCollection();
    ~CSdoCollection();

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CSdoCollection)
   COM_INTERFACE_ENTRY(ISdoCollection)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY_IID(__uuidof(IASProductLimits), IASProductLimits)
END_COM_MAP()

public:

   ///////////////////////////
    // ISdoCollection Interface
    ///////////////////////////

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Count)(
        /*[out, retval]*/ LONG *pVal
                        );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(Add)(
            /*[in]*/ BSTR       Name,
        /*[in/out]*/ IDispatch** ppItem
                  );

   //////////////////////////////////////////////////////////////////////////////
    STDMETHOD(Remove)(
              /*[in]*/ IDispatch* pItem
                     );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(RemoveAll)(void);

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(Reload)(void);

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(IsNameUnique)(
                    /*[in]*/ BSTR          bstrName,
                   /*[out]*/ VARIANT_BOOL* pBool
                     );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(Item)(
             /*[in]*/ VARIANT*    Index,
            /*[out]*/ IDispatch** pItem
                   );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get__NewEnum)(
                   /*[out]*/ IUnknown** pEnumVARIANT
                           );

   // IASProductLimits.
   STDMETHOD(get_Limits)(IAS_PRODUCT_LIMITS* pVal);

private:

   friend ISdoCollection* MakeSDOCollection(
                             LPCWSTR lpszCreateClassId,
                             ISdoMachine* pSdoMachine,
                             IDataStoreContainer* pDSContainer,
                             size_t maxSize
                             );

   //////////////////////////////////////////////////////////////////////////////
   HRESULT InternalInitialize(
                    /*[in]*/ LPCWSTR              lpszCreateClassId,
                    /*[in]*/ ISdoMachine*        pSdoMachine,
                    /*[in]*/ IDataStoreContainer* pDSContainer,
                    /*[in]*/ size_t maxSize
                          );

   //////////////////////////////////////////////////////////////////////////////
   void InternalShutdown(void);

   /////////////////////////////////////////////////////////////////////////////
   HRESULT InternalAdd(
               /*[in]*/ BSTR      bstrName,
          /*[in/out]*/ IDispatch **ppItem
                   );

   //////////////////////////////////////////////////////////////////////////////
   HRESULT InternalIsNameUnique(
                    /*[in]*/ BSTR          bstrName,
                   /*[out]*/ VARIANT_BOOL* pBool
                        );

   //////////////////////////////////////////////////////////////////////////////
   HRESULT Load(void);

   //////////////////////////////////////////////////////////////////////////////
   void ReleaseItems(void);


    // Container for collection's SDOs
    //
    typedef vector<_variant_t>      VariantArray;
    typedef VariantArray::iterator  VariantArrayIterator;

   // Container for object references
   //
   VariantArray                    m_Objects;

    // Collection state
    //
    bool                            m_fSdoInitialized;

   // Data store container associated with this collection
   //
    IDataStoreContainer*            m_pDSContainer;

   // Attached Machine
   //
   ISdoMachine*               m_pSdoMachine;

    // Create on add allowed flag
    //
    bool                            m_fCreateOnAdd;

   // Data store class name for objects that can be created by this collection
   //
   _bstr_t                     m_DatastoreClass;

   // Prog Id of the objects (SDOs) that can be created by this collection
   //
    _bstr_t                         m_CreateClassId;

    size_t m_MaxSize;
};

typedef CComObjectNoLock<CSdoCollection>   SDO_COLLECTION_OBJ;
typedef CComObjectNoLock<CSdoCollection>*   PSDO_COLLECTION_OBJ;


#endif //__IAS_SDOCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponent.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponent.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object - IAS Component Class Implementation
//
// Author:      TLP 6/18/98
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ias.h>
#include <iascomp.h>
#include <portparser.h>
#include "sdocomponent.h"
#include "sdohelperfuncs.h"

///////////////////////////////
// CComponentCfg Implementation
///////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CComponentCfg::CComponentCfg(LONG lComponentId)
   : m_lComponentId(lComponentId),
     m_pComponentCfg(NULL)
{
   // create letter object
   //
   switch( lComponentId )
   {
      case IAS_PROVIDER_MICROSOFT_NTSAM_AUTH:
         m_pComponentCfg = (CComponentCfg*) new CComponentCfgAuth(lComponentId);
         break;

      case IAS_PROVIDER_MICROSOFT_ACCOUNTING:
         m_pComponentCfg = (CComponentCfg*) new CComponentCfgAccounting(lComponentId);
         break;

      case IAS_PROTOCOL_MICROSOFT_RADIUS:
         m_pComponentCfg = (CComponentCfg*) new CComponentCfgRADIUS(lComponentId);
         break;

      default:
         m_pComponentCfg = (CComponentCfg*) new CComponentCfgNoOp(lComponentId);
         break;
   }
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentCfgAuth::Load(CSdoComponent* pSdoComponent)
{
   HRESULT      hr = S_OK;

   do
   {
      // Determine if were attached to the local machine
      //
      BSTR bstrMachine = NULL;
      hr = (pSdoComponent->GetMachineSdo())->GetAttachedComputer(&bstrMachine);
      if ( FAILED(hr) )
         break;

      wchar_t computerName[MAX_COMPUTERNAME_LENGTH + 1];
      DWORD size = MAX_COMPUTERNAME_LENGTH;
      GetComputerName(computerName, &size);

      LONG lResult = ERROR_SUCCESS;
      HKEY hKeyRemote = HKEY_LOCAL_MACHINE;
      if ( lstrcmpi(computerName, bstrMachine ) )
      {
         // We're not attached to the local machine so connect to the
         // registry of the remote machine
         //
         lResult = RegConnectRegistry(
                                bstrMachine,
                                HKEY_LOCAL_MACHINE,
                                &hKeyRemote
                               );
      }
      SysFreeString(bstrMachine);
      if ( ERROR_SUCCESS != lResult )
      {
         IASTracePrintf("Error in NT SAM Authentication SDO - Could not attach to the remote registry..");
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      // Open the IAS key
      //
      CRegKey   IASKey;
      lResult = IASKey.Open(
                       hKeyRemote,
                       IAS_POLICY_REG_KEY,
                       KEY_READ
                      );

      if ( lResult != ERROR_SUCCESS )
      {
         IASTracePrintf("Error in NT SAM Authentication SDO - Could not open IAS registry key..");
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      // Get the value of the Allow LAN Manager Authentication key.
      // Note that this key may not even be present. In this case
      // the property object will just use the schema defined default.
      //
      VARIANT vt;
      DWORD dwValue;
      lResult = IASKey.QueryValue(
                            dwValue,
                           (LPCTSTR) IAS_NTSAM_AUTH_ALLOW_LM
                           );

      if ( lResult == ERROR_SUCCESS )
      {
         V_VT(&vt) = VT_BOOL;
         V_BOOL(&vt) = (dwValue ? VARIANT_TRUE : VARIANT_FALSE);
         hr = pSdoComponent->PutComponentProperty(
                                         PROPERTY_NTSAM_ALLOW_LM_AUTHENTICATION,
                                        &vt
                                       );
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in NT SAM Authentication SDO - Could not store the Allow LM property..");
            break;
         }
      }

   } while ( FALSE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentCfgRADIUS::Initialize(CSdoComponent* pSdoComponent)
{
   HRESULT hr = E_FAIL;

   do
   {
      CComPtr<IDataStoreContainer> pDSContainer;
      hr = (pSdoComponent->GetComponentDataStore())->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainer);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Component - RADIUS::Initialize() - QueryInterface() failed...");
         break;
      }

      CComBSTR bstrClientsName(DS_OBJECT_CLIENTS);
      if (!bstrClientsName)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      CComPtr<IDataStoreObject> pDSObject;
      hr = pDSContainer->Item(
                          bstrClientsName,
                         &pDSObject
                        );
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Component - RADIUS::Initialize() - IDataStoreContainer::Item(Clients) failed...");
         break;
      }

      CComPtr<IDataStoreContainer> pDSContainer2;
      hr = pDSObject->QueryInterface(
                              IID_IDataStoreContainer,
                              (void**)&pDSContainer2
                             );
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Component - RADIUS::Initialize() - QueryInterface() failed...");
         break;
      }

      IAS_PRODUCT_LIMITS limits;
      hr = SDOGetProductLimits(pSdoComponent->GetMachineSdo(), &limits);
      if (FAILED(hr))
      {
         break;
      }

      hr = pSdoComponent->InitializeComponentCollection(
                             PROPERTY_RADIUS_CLIENTS_COLLECTION,
                             SDO_PROG_ID_CLIENT,
                             pDSContainer2,
                             limits.maxClients
                             );
      if ( FAILED(hr) )
         break;

      pDSObject.Release();
      pDSContainer2.Release();

      CComBSTR bstrVendorsName(DS_OBJECT_VENDORS);
      if (!bstrVendorsName)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      hr = pDSContainer->Item(
                         bstrVendorsName,
                        &pDSObject
                        );
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Component - RADIUS::Initialize() - IDataStoreContainer::Item(Vendors) failed...");
         break;
      }

      hr = pDSObject->QueryInterface(
                              IID_IDataStoreContainer,
                              (void**)&pDSContainer2
                             );
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Component - RADIUS::Initialize() - QueryInterface() failed...");
         break;
      }

      hr = pSdoComponent->InitializeComponentCollection(
                                               PROPERTY_RADIUS_VENDORS_COLLECTION,
                                              SDO_PROG_ID_VENDOR,
                                            pDSContainer2
                                                  );
   } while ( FALSE );

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentCfgAccounting::Initialize(CSdoComponent* pSdoComponent)
{
   HRESULT   hr = E_FAIL;

   do
   {
      BSTR bstrMachineName = NULL;
      hr = (pSdoComponent->GetMachineSdo())->GetAttachedComputer(&bstrMachineName);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Accounting SDO - Could not get the name of the attached computer...");
         break;
      }
      wchar_t szLogFileDir[MAX_PATH+1];
      hr = ::SDOGetLogFileDirectory(
                              bstrMachineName,
                              MAX_PATH,
                              szLogFileDir
                            );
      if ( FAILED(hr) )
      {
         SysFreeString(bstrMachineName);
         IASTracePrintf("Error in Accounting SDO - Could not get the default log file directory..");
         break;
      }
      _variant_t vtLogFileDir = szLogFileDir;
      SysFreeString(bstrMachineName);
      hr = pSdoComponent->ChangePropertyDefault(
                                       PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY,
                                      &vtLogFileDir
                                     );
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Accounting SDO - Could not store the default log file directory property..");
         break;
      }

   } while ( FALSE );

   return hr;
}


///////////////////////////////
// CSdoComponent Implementation
///////////////////////////////

////////////////////////////////////////////////////////////////////////////////
CSdoComponent::CSdoComponent()
   : m_pComponentCfg(NULL),
     m_pAttachedMachine(NULL)
{

}

////////////////////////////////////////////////////////////////////////////////
CSdoComponent::~CSdoComponent()
{
   if ( m_pComponentCfg )
      delete m_pComponentCfg;
   if ( m_pAttachedMachine )
      m_pAttachedMachine->Release();
}


////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::InitializeComponentCollection(
                          LONG CollectionPropertyId,
                          LPWSTR lpszCreateClassId,
                          IDataStoreContainer* pDSContainer,
                          DWORD maxSize
                          )
{
   _ASSERT ( m_pAttachedMachine );
   return InitializeCollection(
                         CollectionPropertyId,
                         lpszCreateClassId,
                         m_pAttachedMachine,
                         pDSContainer,
                         maxSize
                        );
}


////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::ChangePropertyDefault(
                              /*[in]*/ LONG     Id,
                              /*[in]*/ VARIANT* pValue
                                 )
{
   return ChangePropertyDefaultInternal(Id, pValue);
}

////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::PutComponentProperty(
                              /*[in]*/ LONG     Id,
                              /*[in]*/ VARIANT* pValue
                                   )
{
   return PutPropertyInternal(Id, pValue);
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::FinalInitialize(
                        /*[in]*/ bool         fInitNew,
                        /*[in]*/ ISdoMachine* pAttachedMachine
                             )
{
   _ASSERT ( ! fInitNew );
   HRESULT hr;
   do
   {
      hr = Load();
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Component SDO - FinalInitialize() - Could not load component properties...");
         break;
      }
      _variant_t vtComponentId;
      hr = GetPropertyInternal(PROPERTY_COMPONENT_ID, &vtComponentId);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Component SDO - FinalInitialize() - Could not get the component Id...");
         break;
      }
      auto_ptr<CComponentCfg> pComponentCfg (new CComponentCfg(V_I4(&vtComponentId)));
      if ( NULL == pComponentCfg.get() )
      {
         IASTracePrintf("Error in Component SDO - FinalInitialize() - Could not create component: %lx...",V_I4(&vtComponentId));
         hr = E_FAIL;
         break;
      }
      (m_pAttachedMachine = pAttachedMachine)->AddRef();
      hr = pComponentCfg->Initialize(this);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Component SDO - FinalInitialize() - Could not initialize component: %lx...",V_I4(&vtComponentId));
         break;
      }
      m_pComponentCfg = pComponentCfg.release();
      hr = Load();
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Component SDO - FinalInitialize() - Could not configure component: %lx...",V_I4(&vtComponentId));
         break;
      }

   } while ( FALSE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::Load()

{
   HRESULT hr = CSdo::Load();
   if ( SUCCEEDED(hr) )
   {
      if ( m_pComponentCfg )
         hr = m_pComponentCfg->Load(this);
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoComponent::Save()
{
   HRESULT hr = CSdo::Save();
   if ( SUCCEEDED(hr) )
   {
      if ( m_pComponentCfg )
        {
            hr = m_pComponentCfg->Validate (this);
            if (SUCCEEDED (hr))
            {
             hr = m_pComponentCfg->Save(this);
            }
        }
   }
   return hr;
}


HRESULT CSdoComponent::ValidateProperty(
                          SDOPROPERTY* prop,
                          VARIANT* value
                          ) throw()
{
   HRESULT hr = prop->Validate(value);
   if (SUCCEEDED(hr) &&
       (m_pComponentCfg->GetId() == IAS_PROTOCOL_MICROSOFT_RADIUS))
   {
      switch (prop->GetId())
      {
         case PROPERTY_RADIUS_ACCOUNTING_PORT:
         case PROPERTY_RADIUS_AUTHENTICATION_PORT:
         {
            if (!CPortParser::IsPortStringValid(V_BSTR(value)))
            {
               hr = E_INVALIDARG;
            }
            break;
         }

         default:
         {
            // Do nothing.
            break;
         }
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponentfactory.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponentfactory.h
//
// Project:     Everest
//
// Description: Component Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SDO_COMPONENT_FACTORY_H_
#define __INC_SDO_COMPONENT_FACTORY_H_

#include "sdobasedefs.h"
#include "sdocomponentmgr.h"

///////////////////////////////////////////////////////////////////
ComponentPtr MakeComponent(
						   COMPONENTTYPE eComponentType, 
						   LONG          lComponentId 
						  );

///////////////////////////////////////////////////////////////////
// Component Factory - Builds Handles to Components
///////////////////////////////////////////////////////////////////
class CComponentFactory
{

friend ComponentPtr MakeComponent(
								  COMPONENTTYPE eComponentType,
								  LONG		    lComponentId
								 );

public:

	//////////////////////////////////////////////////////////////////////////
	ComponentPtr make(
					  COMPONENTTYPE eComponentType, 
					  LONG lComponentId
					 );

private:

	CComponentFactory() { }
	CComponentFactory(CComponentFactory& x);
	CComponentFactory& operator = (CComponentFactory& x);
};


#endif // __INC_SDO_COMPONENT_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponent.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponent.h
//
// Project:     Everest
//
// Description: IAS Server Data Object - IAS Component Class Definition
//
// Author:      TLP 6/16/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_COMPONENT_H_
#define _INC_IAS_SDO_COMPONENT_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdobasedefs.h"
#include "sdo.h"
#include <sdofactory.h>

class CComponentCfg;   // Forward declaration

/////////////////////////////////////////////////////////////////////////////
// CSdoComponent
/////////////////////////////////////////////////////////////////////////////
class CSdoComponent : public CSdo
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoComponent)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY(ISdo)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoComponent);

   ////////////////////////////////////////////////////////////////////////
   CSdoComponent();
    virtual ~CSdoComponent();

   ////////////////////////////////////////////////////////////////////////
   HRESULT FinalInitialize(
               /*[in]*/ bool         fInitNew,
               /*[in]*/ ISdoMachine* pAttachedMachine
                      );

   ////////////////////////////////////////////////////////////////////////
   HRESULT Load(void);

   ////////////////////////////////////////////////////////////////////////
   HRESULT Save(void);

   ////////////////////////////////////////////////////////////////////////
   HRESULT InitializeComponentCollection(
              LONG CollectionPropertyId,
              LPWSTR CreateClassId,
              IDataStoreContainer* pDSContainer,
              DWORD maxSize = INFINITE
              );

   ////////////////////////////////////////////////////////////////////////
   HRESULT PutComponentProperty(
                     /*[in]*/ LONG     Id,
                     /*[in]*/ VARIANT* pValue
                           );

   ////////////////////////////////////////////////////////////////////////
   HRESULT ChangePropertyDefault(
                       /*[in]*/ LONG     Id,
                       /*[in]*/ VARIANT* pValue
                         );

   ////////////////////////////////////////////////////////////////////////
   IDataStoreObject* GetComponentDataStore(void) const
   { return m_pDSObject; }

   ////////////////////////////////////////////////////////////////////////
   ISdoMachine* GetMachineSdo(void) const
   { return m_pAttachedMachine; }

protected:
   virtual HRESULT ValidateProperty(
                      SDOPROPERTY* prop,
                      VARIANT* value
                      ) throw();

private:

   CSdoComponent(const CSdoComponent& rhs);
   CSdoComponent& operator = (CSdoComponent& rhs);

   CComponentCfg*   m_pComponentCfg;
   ISdoMachine*   m_pAttachedMachine;
};

typedef CComObjectNoLock<CSdoComponent>  SDO_COMPONENT_OBJ;
typedef CComObjectNoLock<CSdoComponent>* PSDO_COMPONENT_OBJ;


/////////////////////////////////////////////////////////////////////////////
// The Base Componet Configureation Class (Envelope )
/////////////////////////////////////////////////////////////////////////////

class CComponentCfgAuth;
class CComponentCfgRADIUS;
class CComponentCfgAccounting;
class CComponentCfgNoOp;

///////////////////////////////////////////
// Dummy class used for letter construction
//
struct DummyConstructor
{
   DummyConstructor(int=0) { }
};

/////////////////////////////////////////////////////////////////////////////
// This class is in place to handle loading and saving component
// configuration data to the registry
/////////////////////////////////////////////////////////////////////////////

class CComponentCfg
{

public:

   //////////////////////////////////////////////////////////////////////////
   CComponentCfg(LONG lComponentId);

   //////////////////////////////////////////////////////////////////////////
   virtual ~CComponentCfg()
   {
      // if m_pComponent is not NULL then the envelope is being destroyed
      //
      if ( m_pComponentCfg )
         delete m_pComponentCfg;
   }

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT Initialize(CSdoComponent* pSdoComponent)
   {
      return m_pComponentCfg->Initialize(pSdoComponent);
   }

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT Load(CSdoComponent* pSdoComponent)
   {
      return m_pComponentCfg->Load(pSdoComponent);
   }

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT   Save(CSdoComponent* pSdoComponent)
   {
      return m_pComponentCfg->Save(pSdoComponent);
   }

   //////////////////////////////////////////////////////////////////////////
   virtual HRESULT   Validate (CSdoComponent* pSdoComponent)
   {
      return m_pComponentCfg->Validate (pSdoComponent);
   }

   //////////////////////////////////////////////////////////////////////////
   LONG GetId(void) const
   { return m_lComponentId; }

protected:

   // Invoked explicitly by derived (letter) classes
   //
   CComponentCfg(LONG lComponentId, DummyConstructor theDummy)
      : m_lComponentId(lComponentId),
        m_pComponentCfg(NULL) {  }

private:

   // No default constructor since we would'nt know what
   // type of component configurator to build by default
   //
   CComponentCfg();

   // No copy or assignment of component configurators
   //
   CComponentCfg(const CComponentCfg& theComponent);
   CComponentCfg& operator = (CComponentCfg& theComponent);

   LONG         m_lComponentId;
   CComponentCfg*   m_pComponentCfg;
};

/////////////////////////////////////////////////////////////////////////////
// The Derived Componet Configureation Class (Letters)
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
class CComponentCfgNoOp : public CComponentCfg
{
   // By default we load the component configuration from the default
   // configuration source (.mdb file) - the do nothing case
   //
public:

   HRESULT Initialize(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Load(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Save(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Validate(CSdoComponent* pSdoComponent)
   { return S_OK; }

private:

   friend CComponentCfg;
   CComponentCfgNoOp(LONG lComponentId)
      : CComponentCfg(lComponentId, DummyConstructor()) { }

   // No copy or assignment of component configurators
   //
   CComponentCfgNoOp();
   CComponentCfgNoOp(const CComponentCfgNoOp& theComponent);
   CComponentCfgNoOp& operator = (CComponentCfgNoOp& theComponent);
};


//////////////////////////////////////////////////////////////////////////////

#define      IAS_NTSAM_AUTH_ALLOW_LM         L"Allow LM Authentication"

class CComponentCfgAuth : public CComponentCfg
{
   // Since we have no UI for request handlers we allow the
   // CPW1 parameter to be set via the registry
   //
public:

   HRESULT Initialize(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Load(CSdoComponent* pSdoComponent);

   HRESULT Save(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Validate(CSdoComponent* pSdoComponent)
   { return S_OK; }

private:

   friend CComponentCfg;
   CComponentCfgAuth(LONG lComponentId)
      : CComponentCfg(lComponentId, DummyConstructor()) { }


   // No copy or assignment of component configurators
   //
   CComponentCfgAuth();
   CComponentCfgAuth(const CComponentCfgAuth& rhs);
   CComponentCfgAuth& operator = (CComponentCfgAuth& rhs);
};


//////////////////////////////////////////////////////////////////////////////
class CComponentCfgRADIUS : public CComponentCfg
{
   // Need to initialize and configure the clients collection
   // of the RADIUS protocol component.
   //
public:

   HRESULT Initialize(CSdoComponent* pSdoComponent);

   HRESULT Load(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Save(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Validate(CSdoComponent* pSdoComponent)
   { return S_OK; }

private:

   friend CComponentCfg;
   CComponentCfgRADIUS(LONG lComponentId)
      : CComponentCfg(lComponentId, DummyConstructor()) { }

   // No copy or assignment of component configurators
   //
   CComponentCfgRADIUS();
   CComponentCfgRADIUS(const CComponentCfgRADIUS& rhs);
   CComponentCfgRADIUS& operator = (CComponentCfgRADIUS& rhs);
};


//////////////////////////////////////////////////////////////////////////////

class CComponentCfgAccounting : public CComponentCfg
{

public:

   HRESULT Initialize(CSdoComponent* pSdoComponent);

   HRESULT Load(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Save(CSdoComponent* pSdoComponent)
   { return S_OK; }

   HRESULT Validate(CSdoComponent* pSdoComponent)
   { return S_OK; }

private:

   friend CComponentCfg;
   CComponentCfgAccounting(LONG lComponentId)
      : CComponentCfg(lComponentId, DummyConstructor()) { }


   // No copy or assignment of component configurators
   //
   CComponentCfgAccounting();
   CComponentCfgAccounting(const CComponentCfgAccounting& rhs);
   CComponentCfgAccounting& operator = (CComponentCfgAccounting& rhs);
};


#endif // _INC_IAS_SDO_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponentmgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponentmgr.cpp
//
// Project:     Everest
//
// Description: IAS - Server Core Manager Implementation
//
// Author:      TLP
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdocomponentmgr.h"
#include "sdocomponentfactory.h"
#include "sdohelperfuncs.h"
#include "sdocomponent.h"
#include <iascomp.h>
#include <iastlb.h>

/////////////////////////////////////////
// Component Master Pointer Intance Count
/////////////////////////////////////////
DWORD ComponentMasterPtr::m_dwInstances = 0;

//////////////////////////////////////////////////////////////////////////////
//				The Component (Envelope) Constructor
//
// Only a ComponentMasterPtr object can construct a component object
//
//////////////////////////////////////////////////////////////////////////////
CComponent::CComponent(LONG eComponentType, LONG lComponentId)
	: m_lId(lComponentId),
	  m_eState(COMPONENT_STATE_SHUTDOWN),
	  m_eType((COMPONENTTYPE)eComponentType),
	  m_pComponent(NULL)
{
	TRACE_ENVELOPE_CREATE(CComponent);
	_ASSERT( COMPONENT_TYPE_MAX > eComponentType );

	// create letter object
	//
	switch( eComponentType )
	{
		case COMPONENT_TYPE_AUDITOR:
			m_pComponent = new CComponentAuditor(lComponentId);
			break;

		case COMPONENT_TYPE_PROTOCOL:
			m_pComponent = new CComponentProtocol(lComponentId);
			break;

		case COMPONENT_TYPE_REQUEST_HANDLER:
			m_pComponent = new CComponentRequestHandler(lComponentId);
			break;

		default:
			_ASSERT( FALSE );
	};
}


//////////////////////////////////////////////////////////////////////////////
//					IAS	COMPONENT MANAGER CLASSES
//
// These classes are responsible for configuring, kick-starting and finally
// shutting down IAS core components. A component class basically is a wrapper
// around the IIasComponent interface. Its value add is that it knows how
// to configure / initialize / shutdown the component using mechanisms
// unknown to the underlying component.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//						  Auditor
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::Initialize(ISdo* pSdoAuditor)
{
	HRESULT			hr;
	IASComponentPtr	pAuditor;

	do
	{
		hr = SDOCreateComponentFromObject(
										   pSdoAuditor,
										   &pAuditor
										 );
		if ( FAILED(hr) )
			break;

		hr = pAuditor->InitNew();
		if ( FAILED(hr) )
			break;

		hr = SDOConfigureComponentFromObject(
											 pSdoAuditor,
											 pAuditor.p
											);
		if ( FAILED(hr) )
		{
			pAuditor->Shutdown();
			break;
		}

		hr = pAuditor->Initialize();
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Auditor Component - Initialize() for Auditor %d failed...",GetId());
			pAuditor->Shutdown();
			break;
		}

		m_pAuditor = pAuditor;

	} while (FALSE);

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::Configure(ISdo* pSdoAuditor)
{
	return SDOConfigureComponentFromObject(
											pSdoAuditor,
											m_pAuditor
									      );
};

///////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::GetObject(IUnknown** ppObj, REFIID riid)
{
	_ASSERT( FALSE );
	return E_FAIL;
}

///////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::PutObject(IUnknown* pObj, REFIID riid)
{
	_ASSERT( FALSE );
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::Suspend()
{
	return m_pAuditor->Suspend();
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentAuditor::Resume()
{
	return m_pAuditor->Resume();
}


//////////////////////////////////////////////////////////////////////////////
void CComponentAuditor::Shutdown()
{
	m_pAuditor->Shutdown();
	m_pAuditor.Release();
}


//////////////////////////////////////////////////////////////////////////////
//						    Protocol
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::Initialize(ISdo* pSdoProtocol)
{
	HRESULT			hr;
	IASComponentPtr	pProtocol;

	do
	{
		hr = SDOCreateComponentFromObject(pSdoProtocol, &pProtocol);
		if ( FAILED(hr) )
			break;

		// We don't really initialize the protocol (entirely anyway). What
		// we really want to do at this point is configure the protocol since
		// the protocol SDO is available. We can't finish initialization until
		// the protocol receives an IRequestHandler interface (for the
		// component that will process protocol generated requests).
		//

		hr = pProtocol->InitNew();
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Protocol Component - Initialize() - Could not InitNew() protocol %d failed...",GetId());
			break;
		}

		hr = SDOConfigureComponentFromObject(
											 pSdoProtocol,
											 pProtocol
											);
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Protocol Component - Initialize() - Could not configure protocol %d failed...",GetId());
			pProtocol->Shutdown();
			break;
		}

		hr = pProtocol->Initialize();
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Protocol Component - Initialize() - Could not initialize protocol %d failed...",GetId());
			pProtocol->Shutdown();
			break;
		}

		m_pProtocol = pProtocol;

	} while (FALSE);

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::Configure(ISdo* pSdoProtocol)
{
	return SDOConfigureComponentFromObject(
											 pSdoProtocol,
											 m_pProtocol
										  );
}

///////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::GetObject(IUnknown** ppObj, REFIID riid)
{
	_ASSERT( FALSE );
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::PutObject(IUnknown* pObject, REFIID riid)
{
	HRESULT				hr;
	_variant_t			vtRequestHandler;

	_ASSERT( riid == IID_IRequestHandler);
	_ASSERT( NULL != pObject );

	vtRequestHandler = (IDispatch*)pObject;
	hr = m_pProtocol->PutProperty(PROPERTY_PROTOCOL_REQUEST_HANDLER, &vtRequestHandler);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::Suspend()
{
	return m_pProtocol->Suspend();
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentProtocol::Resume()
{
	return m_pProtocol->Resume();
}

//////////////////////////////////////////////////////////////////////////////
void CComponentProtocol::Shutdown()
{
	// a Protocol can get shutdown while suspended or initialized!
	//
	m_pProtocol->Shutdown();
	m_pProtocol.Release();
}

//////////////////////////////////////////////////////////////////////////////
//					   Request Handler
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::Initialize(ISdo* pSdoService)
{
	HRESULT			hr;
	CComPtr<ISdo>	pSdoRequestHandler;

	_ASSERT( NULL != m_pRequestHandler.p );

	// request handler may or may not have an SDO associated
	// with it. Those request handlers that do not expose
	// configuration data will not have an associated SDO.

	hr = SDOGetComponentFromCollection(
							           pSdoService,
							           PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
								       GetId(),
								       &pSdoRequestHandler
							          );
	if ( SUCCEEDED(hr) )
	{
		hr = SDOConfigureComponentFromObject(
											 pSdoRequestHandler,
											 m_pRequestHandler.p
										    );
	}
	else
	{
		hr = S_OK;
	}

	if ( SUCCEEDED(hr) )
	{
		hr = m_pRequestHandler->Initialize();
		if ( FAILED(hr) )
			IASTracePrintf("Error in Request Handler Component - Initialize() - failed for request handler %d...", GetId());
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::GetObject(IUnknown** ppObj, REFIID riid)
{
	_ASSERT( FALSE );
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::PutObject(IUnknown* pObject, REFIID riid)
{
	HRESULT		hr;

	_ASSERT( riid == IID_IIasComponent );
	_ASSERT( NULL != pObject );
	_ASSERT( NULL == m_pRequestHandler.p );
	hr = pObject->QueryInterface(riid, (void**)&m_pRequestHandler.p);
	if ( SUCCEEDED(hr) )
		hr = m_pRequestHandler->InitNew();

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::Configure(ISdo* pSdoService)
{
	HRESULT			hr;
	CComPtr<ISdo>	pSdoRequestHandler;

	_ASSERT( NULL != m_pRequestHandler.p );

	// request handler may or may not have an SDO associated
	// with it. Those request handlers that do not expose
	// configuration data will not have an associated SDO.

	hr = SDOGetComponentFromCollection(
						   	           pSdoService,
							           PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
								       GetId(),
								       &pSdoRequestHandler
							          );
	if ( SUCCEEDED(hr) )
	{
		hr = SDOConfigureComponentFromObject(
											 pSdoRequestHandler,
											 m_pRequestHandler.p
										    );
	}
	else
	{
		hr = S_OK;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::Suspend()
{
	return m_pRequestHandler->Suspend();
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CComponentRequestHandler::Resume()
{
	return m_pRequestHandler->Resume();
}


//////////////////////////////////////////////////////////////////////////////
void CComponentRequestHandler::Shutdown()
{
	m_pRequestHandler->Shutdown();
	m_pRequestHandler.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponentfactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponentfactory.cpp
//
// Project:     Everest
//
// Description: Component Factory Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdocomponentfactory.h"

//////////////////////////////////////////////////////////////////////////
ComponentPtr CComponentFactory::make(COMPONENTTYPE eComponentType, LONG lComponentId)
{
	ComponentMasterPtr* mp = new(nothrow) ComponentMasterPtr((LONG)eComponentType, lComponentId);
	if ( NULL != mp )
		return ComponentPtr(mp);
	else
		return ComponentPtr();
}


///////////////////////////////////////////////////////////////////////////////
ComponentPtr MakeComponent(
						    COMPONENTTYPE eComponentType, 
						    LONG lComponentId 
						  )
{
	/////////////////////////////////////////////////////////////////////////
	static CComponentFactory	theFactory; // One and only component factory
	/////////////////////////////////////////////////////////////////////////
	return theFactory.make(eComponentType, lComponentId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocollection.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) Microsoft Corporation all rights reserved.
//
// Module:      sdocollection.h
//
// Description: IAS Server Data Object Collection Implementation
//
// Author:      TLP 1/23/98
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdo.h"
#include "sdocollection.h"
#include "sdofactory.h"
#include "sdohelperfuncs.h"


/////////////////////////////////////////////////////////////////////////////
//                  CSdoCollection Class Implementation
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CSdoCollection::CSdoCollection()
    : m_fSdoInitialized(false),
      m_pDSContainer(NULL),
     m_pSdoMachine(NULL),
     m_fCreateOnAdd(false),
     m_MaxSize(INFINITE)
{
   InternalAddRef();
}

/////////////////////////////////////////////////////////////////////////////
CSdoCollection::~CSdoCollection()
{
   InternalShutdown();
}


/////////////////////////////////////////////////////////////////////////////
//          ISdoCollection Interface Implmentation
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::get_Count(long* pCount)
{
    CSdoLock    theLock(*this);

    // Check precondtions
    //
    _ASSERT ( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    _ASSERT( NULL != pCount );
   if ( NULL == pCount )
      return E_POINTER;

   *pCount = m_Objects.size();
   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::Add(
                        /*[in]*/ BSTR      bstrName,
                    /*[in/out]*/ IDispatch** ppItem
                                )
{
    CSdoLock    theLock(*this);

    // Check preconditions
    //
   _ASSERT ( m_fSdoInitialized );
    if ( ! m_fSdoInitialized )
        return E_FAIL;

    _ASSERT ( NULL != ppItem );
   if ( NULL == ppItem )
        return E_POINTER;

   // Get the Sdo name from the specified object if bstrName is not given
   //
   HRESULT hr = E_FAIL;
   _variant_t vtSdoName;
   if ( NULL == bstrName )
   {
      CComPtr<ISdo> pSdo;
      hr = (*ppItem)->QueryInterface(IID_ISdo, (void**)&pSdo);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Collection - Add() - QueryInterface(ISdo) failed!...");
         return hr;
      }
      hr = pSdo->GetProperty(PROPERTY_SDO_NAME, &vtSdoName);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Collection - Add - GetProperty(Name) failed");
         return hr;
      }
      bstrName = V_BSTR(&vtSdoName);
   }

   // Ensure that the SDO name is unique
   //
   VARIANT_BOOL boolVal;
   hr = InternalIsNameUnique(bstrName, &boolVal);
   if ( SUCCEEDED(hr) )
   {
      if (boolVal)
      {
         if (m_Objects.size() >= m_MaxSize)
         {
            hr = IAS_E_LICENSE_VIOLATION;
         }
         else
         {
            hr = InternalAdd(bstrName, ppItem);
         }
      }
      else
      {
         // Name is not unqiue
         //
         hr = E_INVALIDARG;
      }
   }
   return hr;
}



/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::Remove(IDispatch* pItem)
{
    CSdoLock    theLock(*this);

   HRESULT  hr = DISP_E_MEMBERNOTFOUND;

    try
    {
        SDO_TRACE_VERBOSE_2("Removing item at $%p from SDO collection at $%p...", pItem, this);

       // Check preconditions
      //
      _ASSERT ( m_fSdoInitialized );
      if ( ! m_fSdoInitialized )
         throw _com_error(E_UNEXPECTED);

      _ASSERT ( NULL != pItem );
      if ( NULL == pItem )
         throw _com_error(E_POINTER);

      CComPtr<ISdo> pSdo;
      hr = pItem->QueryInterface(IID_ISdo, (void**)&pSdo);
      if ( FAILED(hr) )
         throw _com_error(hr);

        VariantArrayIterator p = m_Objects.begin();
        while (  p != m_Objects.end() )
        {
         if ( (*p).pdispVal == pItem )
         {
            // Remove the object from the underlying datastore (if neccessary)
            //
            if ( m_pDSContainer )
            {
               _variant_t vtItemName;
               hr = pSdo->GetProperty(PROPERTY_SDO_DATASTORE_NAME, &vtItemName);
               if ( FAILED(hr) )
                  throw _com_error(hr);

               hr = m_pDSContainer->Remove(NULL, V_BSTR(&vtItemName));
               if ( FAILED(hr) )
                  throw _com_error(hr);
            }
            // Remove the object from the collection
            //
            m_Objects.erase(p);
            break;
         }
            p++;
        }
    }

   catch (_com_error theError)
   {
      hr = theError.Error();
      IASTracePrintf("Error in SDO Collection - Remove() - Caught _com_error exception: %lx...", hr);
   }

    catch (...)
    {
        hr = E_UNEXPECTED;
      IASTracePrintf("Error in SDO Collection - Remove() - Caught unhandled exception...");
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::RemoveAll(void)
{

    CSdoLock    theLock(*this);

   HRESULT hr = S_OK;

    try
    {
       SDO_TRACE_VERBOSE_1("Clearing the items from the SDO collection at $%p...",this);

       _ASSERT ( m_fSdoInitialized );
      if ( ! m_fSdoInitialized )
         throw _com_error(E_UNEXPECTED);

      if ( ! m_Objects.empty() )
      {
         VariantArrayIterator p = m_Objects.begin();
         while( p != m_Objects.end() )
         {
            if ( m_pDSContainer )
            {
               CComPtr<ISdo> pSdo;
               hr = ((*p).pdispVal)->QueryInterface(IID_ISdo, (void**)&pSdo);
               if ( FAILED(hr) )
                  throw _com_error(E_UNEXPECTED);

               _variant_t vtItemName;
               hr = pSdo->GetProperty(PROPERTY_SDO_DATASTORE_NAME, &vtItemName);
               if ( FAILED(hr) )
                  throw _com_error(E_UNEXPECTED);

               hr = m_pDSContainer->Remove(NULL, V_BSTR(&vtItemName));
               if ( FAILED(hr) )
                  throw _com_error(hr);   // Datastore Error
            }

              p = m_Objects.erase(p);
         }
      }
    }

   catch(_com_error theError)
   {
      hr = theError.Error();
      IASTracePrintf("Error in SDO Collection - RemoveAll() - Caught _com_error exception: %lx...", hr);
   }
    catch(...)
    {
      hr = E_UNEXPECTED;
      IASTracePrintf("Error in SDO Collection - RemoveAll() - Caught unhandled exception...");
    }

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::Reload(void)
{
    CSdoLock    theLock(*this);

   HRESULT hr = S_OK;

   try
   {
       _ASSERT ( m_fSdoInitialized );
      if ( ! m_fSdoInitialized )
         throw _com_error(E_UNEXPECTED);

      if ( m_pDSContainer )
      {
         ReleaseItems();
         hr = Load();
      }
   }
   catch(_com_error theError)
   {
      hr = theError.Error();
      IASTracePrintf("Error in SDO Collection - Reload() - Caught _com_error exception: %lx...", hr);
   }
   catch(...)
   {
      hr = E_UNEXPECTED;
      IASTracePrintf("Error in SDO Collection - Reload() - Caught unhandled exception...");
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::IsNameUnique(
                          /*[in]*/ BSTR          bstrName,
                         /*[out]*/ VARIANT_BOOL* pBool
                               )
{
    CSdoLock    theLock(*this);

    // Check preconditions
    //
   _ASSERT ( m_fSdoInitialized );
    if ( ! m_fSdoInitialized )
        return E_FAIL;

    _ASSERT ( NULL != bstrName && NULL != pBool );
   if ( NULL == bstrName || NULL == pBool )
        return E_POINTER;

   VARIANT_BOOL boolVal;
   HRESULT hr = InternalIsNameUnique(bstrName, &boolVal);
   if ( SUCCEEDED(hr) )
      *pBool = boolVal;

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::Item(
                         /*[in]*/  VARIANT*    pName,
                        /*[out]*/  IDispatch** ppItem
                                 )
{
    CSdoLock    theLock(*this);

    // Check preconditions
   //
    _ASSERT ( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    _ASSERT ( NULL != pName && NULL != ppItem );
    if ( pName == NULL || ppItem == NULL )
        return E_POINTER;

    if ( VT_BSTR != V_VT(pName) )
      return E_INVALIDARG;

    SDO_TRACE_VERBOSE_2("Locating item '%ls' in SDO collection at $%p...", V_BSTR(pName), this);

    if ( m_Objects.empty() )
   {
      IASTracePrintf("Error in SDO Collection - Item() - Could not locate the specified item...");
        return DISP_E_MEMBERNOTFOUND;
   }

    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    try
    {
       ISdo*      pSdo;
      IDispatch* pDispatch;
      _variant_t varName;

        VariantArrayIterator p = m_Objects.begin();
        while ( p != m_Objects.end() )
        {
            pDispatch = (*p).pdispVal;
            hr = pDispatch->QueryInterface(IID_ISdo,(void **)&pSdo);
            if ( FAILED(hr) )
                break;

            hr = pSdo->GetProperty(PROPERTY_SDO_NAME, &varName);
            pSdo->Release();
            if ( FAILED(hr) )
                break;

            _ASSERT( V_VT(&varName) == VT_BSTR );
            if ( 0 == lstrcmpiW(V_BSTR(pName), V_BSTR(&varName)) )
            {
                (*ppItem = pDispatch)->AddRef();
                hr = S_OK;
                break;
            }

            varName.Clear();
            p++;
            hr = DISP_E_MEMBERNOTFOUND;
        }

      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO Collection - Item() - Could not locate the specified item...");
    }
    catch(_com_error theCOMError)
    {
        hr = theCOMError.Error();
      IASTracePrintf("Error in SDO Collection - Item() - Caught COM exception...");
    }
    catch(...)
    {
        hr = DISP_E_MEMBERNOTFOUND;
      IASTracePrintf("Error in SDO Collection - Item() - Caught unknown exception...");
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoCollection::get__NewEnum(IUnknown** ppEnumSdo)
{
    CSdoLock    theLock(*this);

    // Check function preconditions
    //
    _ASSERT ( m_fSdoInitialized );
   if ( ! m_fSdoInitialized )
      return E_FAIL;

    _ASSERT ( NULL != ppEnumSdo );
    if (ppEnumSdo == NULL)
        return E_POINTER;

   HRESULT hr = E_FAIL;
   EnumVARIANT* newEnum = NULL;

   try
   {
      newEnum = new (std::nothrow) CComObject<EnumVARIANT>;

      if ( newEnum == NULL )
      {
         IASTracePrintf("Error in SDO Collection - get__NewEnum() - Out of memory...");
         return E_OUTOFMEMORY;
      }

      hr = newEnum->Init(
                     m_Objects.begin(),
                     m_Objects.end(),
                     GetControllingUnknown(),
                     AtlFlagCopy
                    );
      if ( SUCCEEDED(hr) )
      {
         (*ppEnumSdo = newEnum)->AddRef();
         return S_OK;
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO Collection - get__NewEnum() - Caught unknown exception...");
      hr = E_FAIL;
   }

   if ( NULL != newEnum )
      delete newEnum;

    return hr;
}


STDMETHODIMP CSdoCollection::get_Limits(IAS_PRODUCT_LIMITS* pVal)
{
   return SDOGetProductLimits(m_pSdoMachine, pVal);
}


/////////////////////////////////////////////////////////////////////////////
// Collection Initialization / Shutdown Methods
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoCollection::InternalInitialize(
                           LPCWSTR lpszCreateClassId,
                           ISdoMachine* pSdoMachine,
                           IDataStoreContainer* pDSContainer,
                           size_t maxSize
                           )
{
    CSdoLock    theLock(*this);

   // Check preconditions...
   //
    _ASSERT( ! m_fSdoInitialized );
   if ( m_fSdoInitialized )
      return S_OK;

   m_MaxSize = maxSize;

   HRESULT hr = S_OK;

   SDO_TRACE_VERBOSE_1("SDO Collection at $%p is initializing its internal state...",this);

   _ASSERT( NULL != pSdoMachine );
   m_pSdoMachine = pSdoMachine;
   m_pSdoMachine->AddRef();

   if ( lpszCreateClassId )
   {
      m_fCreateOnAdd = true;
      m_CreateClassId = lpszCreateClassId;
       if ( NULL != pDSContainer )
      {
         m_DatastoreClass = ::GetDataStoreClass(lpszCreateClassId);
         m_pDSContainer = pDSContainer;
         m_pDSContainer->AddRef();
         hr = Load();
      }
   }
   else
   {
      // Collection of SDOs for IAS components (auditors, request handlers, protocols).
      // New components cannot be added to this collection by a script or UI.
      // Instead, component parameters and class information should be added to ias.mdb

      _ASSERT( pDSContainer );
      m_pDSContainer = pDSContainer;
      m_pDSContainer->AddRef();
      hr = Load();
   }

   if ( FAILED(hr) )
      InternalShutdown();
    else
      m_fSdoInitialized = TRUE;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
void CSdoCollection::InternalShutdown()
{
   ReleaseItems();

   if ( m_pDSContainer )
   {
      m_pDSContainer->Release();
      m_pDSContainer = NULL;
   }

   if ( m_pSdoMachine )
   {
      m_pSdoMachine->Release();
      m_pSdoMachine = NULL;
   }

   m_fSdoInitialized = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CSdoCollection::InternalAdd(
                           /*[in]*/ BSTR      bstrName,
                      /*[in/out]*/ IDispatch **ppItem
                           )
{
   HRESULT  hr = S_OK;

    try
    {
      do
      {
         // Does the caller want us to create the item?
         //
         if ( NULL == *ppItem )
         {
            // Yes... Attempt to create the item
            //
            if ( ! m_fCreateOnAdd )
            {
               IASTracePrintf("Error in SDO Collection - Add() - Cannot create on add...");
               hr = E_INVALIDARG;
               break;
            }

                _ASSERT( NULL != bstrName );
            if ( NULL == bstrName )
            {
               IASTracePrintf("Error in SDO Collection - Add() - NULL object name...");
                    hr = E_INVALIDARG;
               break;
            }

            SDO_TRACE_VERBOSE_1("Creating new item and additing it to SDO collection at $%p...",this);

            _variant_t varName = bstrName;
            CComPtr<IDataStoreObject> pDSObject;

            // Does the collection have a data store container associated with it?
            //
                if ( m_pDSContainer )
                {
               // Yes... Create a new data store object and associate it with the SDO
               //
                    hr = m_pDSContainer->Create(
                                                 m_DatastoreClass,
                                                 bstrName,
                                                 &pDSObject
                                           );
                    if ( FAILED(hr) )
                    {
                  IASTracePrintf("Error in SDO Collection - Add() - Could not create a data store object...");
                        break;
                    }
            }
            CComPtr<ISdo> pSdo;
            pSdo.p = ::MakeSDO(
                            bstrName,
                            m_CreateClassId,
                           m_pSdoMachine,
                           pDSObject,
                           static_cast<ISdoCollection*>(this),
                           true
                           );
                if ( NULL == pSdo.p )
            {
               IASTracePrintf("Error in Collection SDO - Add() - MakeSDO() failed...");
               hr = E_FAIL;
               break;
            }

            CComPtr<IDispatch> pDispatch;
                hr = pSdo->QueryInterface(IID_IDispatch, (void**)&pDispatch);
                if ( FAILED(hr) )
                {
               IASTracePrintf("Error in SDO Collection - Add() - QueryInterface(IID_IDispatch) failed...");
                    break;
            }

                m_Objects.push_back((IDispatch*)pDispatch.p);
            (*ppItem = pDispatch.p)->AddRef();
            }
           else
          {
            // No... Just add the specified item to the collection
            //
              m_Objects.push_back(*ppItem);
          }

      } while ( FALSE );
    }
    catch (bad_alloc)
    {
      IASTracePrintf("Error in SDO Collection - Add() - Out of memory...");
        hr = E_OUTOFMEMORY;
    }
    catch(...)
    {
      IASTracePrintf("Error in SDO Collection - Add() - Caught unhandled exception...");
        hr = E_FAIL;
    }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoCollection::InternalIsNameUnique(
                             /*[in]*/ BSTR          bstrName,
                            /*[out]*/ VARIANT_BOOL* pBool
                                 )
{
   _variant_t   vtSdoName;
   VariantArrayIterator p = m_Objects.begin();
   while ( p != m_Objects.end() )
   {
      if ( FAILED((dynamic_cast<ISdo*>((*p).pdispVal))->GetProperty(PROPERTY_SDO_NAME, &vtSdoName)) )
      {
         IASTracePrintf("Error in SDO Collection - GetProperty(PROPERTY_SDO_NAME) failed...");
         *pBool = VARIANT_FALSE;
         return E_FAIL;
      }
      if ( 0 == lstrcmpi(bstrName, V_BSTR(&vtSdoName)) )
      {
         IASTracePrintf("Error in SDO Collection - Add() - Sdo Name is Not Unique...");
         *pBool = VARIANT_FALSE;
         return S_OK;
      }
      vtSdoName.Clear();
      p++;
   }
   *pBool = VARIANT_TRUE;
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoCollection::Load()

{
    CSdoLock    theLock(*this);

    HRESULT hr = E_FAIL;

   _ASSERT ( m_pDSContainer );
   if ( m_pDSContainer )
   {
      SDO_TRACE_VERBOSE_1("SDO Collection at $%p is loading its items from the data store...",this);

       CComPtr<IUnknown> pUnknown;
      hr = m_pDSContainer->get__NewEnum(&pUnknown);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Collection SDO - Load() - IDataStoreContainer::get__NewEnum() failed...");
         return E_FAIL;
      }

       CComPtr<IEnumVARIANT> pEnumVariant;
      hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Collection SDO - Load() - QueryInterface(IID_IEnumVARIANT) failed...");
         return E_FAIL;
      }

      CComBSTR bstrClassID(SDO_STOCK_PROPERTY_CLASS_ID);
      if (!bstrClassID) { return E_OUTOFMEMORY; }

       CComPtr<IDataStoreObject> pDSObject;
      CComPtr<ISdo>             pSdoArchive;
       CComPtr<IDispatch>        pDispatch;
      CComPtr<ISdo>          pSdo;

      hr = ::SDONextObjectFromContainer(pEnumVariant, &pDSObject);
      while ( S_OK == hr )
      {
         if ( 0 == m_CreateClassId.length() )
         {
            _variant_t vtComponentClassId;
            hr = pDSObject->GetValue(bstrClassID, &vtComponentClassId);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Collection SDO - LoadSdo() - IDataStoreObject::GetValue() failed...");
                 break;
            }
            pSdo.p = ::MakeSDO(
                           NULL,
                           V_BSTR(&vtComponentClassId),
                           m_pSdoMachine,
                           pDSObject.p,
                            static_cast<ISdoCollection*>(this),
                            false
                            );
         }
         else
         {
            pSdo.p = ::MakeSDO(
                           NULL,
                           m_CreateClassId,
                           m_pSdoMachine,
                           pDSObject.p,
                           static_cast<ISdoCollection*>(this),
                           false
                           );
         }
         if ( NULL == pSdo.p )
         {
            IASTracePrintf("Error in SDO Collection SDO - LoadSdo() - MakeSDO() failed...");
              break;
         }
         hr = pSdo->QueryInterface(IID_IDispatch, (void**)&pDispatch);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Collection SDO - Load() - QueryInterface(IID_IDispatch) failed...");
            break;
         }
         _variant_t vtName;
         hr = pSdo->GetProperty(PROPERTY_SDO_NAME, &vtName);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Collection SDO - Load() - GetProperty(PROPERTY_SDO_NAME) failed...");
            break;
         }
         hr = InternalAdd(V_BSTR(&vtName), &pDispatch.p);
         if ( FAILED(hr) )
            break;

         vtName.Clear();
         pDispatch.Release();
         pDSObject.Release();
         pSdo.Release();

         hr = ::SDONextObjectFromContainer(pEnumVariant, &pDSObject);
      }

      if ( S_FALSE == hr )
         hr = S_OK;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
void CSdoCollection::ReleaseItems()
{
    if ( ! m_Objects.empty() )
    {
      VariantArrayIterator p = m_Objects.begin();
        while( p != m_Objects.end() )
            p = m_Objects.erase(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocomponentmgr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocomponentmgr.h
//
// Project:     Everest
//
// Description: IAS Core Component Manager Definitions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
// 8/13/98      SEB    dsource.h has been merged into iastlb.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SDO_COMPONENT_MGR_H_
#define __INC_SDO_COMPONENT_MGR_H_

#include "sdobasedefs.h"
#include <iastlb.h>

//////////////////////////////////////////////////////////////////////////////
//					IAS Component Interface Class
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////
// Component Class Lifetime Trace (Debugging)
//

// #define	TRACE_ENVELOPE_LETTER_LIFETIME

#ifdef  TRACE_ENVELOPE_LETTER_LIFETIME

#define TRACE_ENVELOPE_CREATE(x)    ATLTRACE(L"Created %ls - envelope class - at %p \n", L#x, this);
#define TRACE_ENVELOPE_DESTROY(x)   ATLTRACE(L"Destroyed %ls - envelope class - at %p \n", L#x, this);
#define TRACE_LETTER_CREATE(x)		ATLTRACE(L"Created %ls - letter class - at %p \n", L#x, this);
#define TRACE_LETTER_DESTROY(x)		ATLTRACE(L"Destroyed %ls  - letter class - at %p \n", L#x, this);

#else

#define TRACE_ENVELOPE_CREATE(x)
#define TRACE_ENVELOPE_DESTROY(x)
#define TRACE_LETTER_CREATE(x)
#define TRACE_LETTER_DESTROY(x)

#endif

//////////////////////
// Types of Components
//
typedef enum _COMPONENTTYPE
{
	COMPONENT_TYPE_AUDITOR = 0x100,
	COMPONENT_TYPE_UNUSED,
	COMPONENT_TYPE_PROTOCOL,
	COMPONENT_TYPE_REQUEST_HANDLER,

	COMPONENT_TYPE_MAX

}	COMPONENTTYPE;


///////////////////
// Component States
//
typedef enum _COMPONENTSTATE
{
	COMPONENT_STATE_SHUTDOWN = 0x100,
	COMPONENT_STATE_INITIALIZED,
	COMPONENT_STATE_SUSPENDED

}	COMPONENTSTATE;


/////////////////////////////////////////////////////////////////////////////
// The Base Componet Class (Envelope )
/////////////////////////////////////////////////////////////////////////////

// Forward references
//
class	CComponent;
class	CComponentAuditor;
class	CComponentProtocol;
class	CComponentRequestHandler;

// Object management class typedefs
//
typedef CSdoMasterPtr<CComponent>						ComponentMasterPtr;
typedef CSdoHandle<CComponent>							ComponentPtr;

// Component container class typedefs
//
typedef LONG											IAS_COMPONENT_ID;
typedef map<IAS_COMPONENT_ID, ComponentPtr>				ComponentMap;
typedef map<IAS_COMPONENT_ID, ComponentPtr>::iterator	ComponentMapIterator;

///////////////////////////////////////////
// Dummy class used for letter construction
//
struct LetterConstructor
{
	LetterConstructor(int=0) { }
};

/////////////////////////////////////////////////////////////////////////////
class CComponent
{

public:

	//////////////////////////////////////////////////////////////////////////
	virtual ~CComponent()
	{
		// if m_pComponent is not NULL then the envelope is being destroyed.
		// if m_pComponent is NULL then the letter is being destroyed.
		//
		// the enveloper will only be destroyed by the master pointer that
		// owns it. The envelope will then destroy the letter it created. The
		// letter, which is derived from the envelope, will eventually cause
		// this destructor to be invoked again - this time however
		// m_pComponent is set to NULL.
		//
		if ( NULL != m_pComponent )
		{
			TRACE_ENVELOPE_DESTROY(CComponent);
			delete m_pComponent;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT Initialize(ISdo* pSdoService)
	{
		_ASSERT( COMPONENT_STATE_SHUTDOWN == m_eState );
		HRESULT hr = m_pComponent->Initialize(pSdoService);
		if ( SUCCEEDED(hr) )
			m_eState = COMPONENT_STATE_INITIALIZED;
		return hr;
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT Configure(ISdo* pSdoService)
	{
		_ASSERT( COMPONENT_STATE_SHUTDOWN != m_eState );
		return m_pComponent->Configure(pSdoService);
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT Suspend(void)
	{
		_ASSERT( COMPONENT_STATE_INITIALIZED == m_eState );
		HRESULT hr = m_pComponent->Suspend();
		if ( SUCCEEDED(hr) )
			m_eState = COMPONENT_STATE_SUSPENDED;
		return hr;
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT Resume(void)
	{
		_ASSERT( COMPONENT_STATE_SUSPENDED == m_eState );
		HRESULT hr = m_pComponent->Resume();
		if ( SUCCEEDED(hr) )
			m_eState = COMPONENT_STATE_INITIALIZED;
		return hr;
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT PutObject(IUnknown* pObj, REFIID riid)
	{
		// _ASSERT( COMPONENT_STATE_INITIALIZED == m_eState );
		return m_pComponent->PutObject(pObj, riid);
	}

	//////////////////////////////////////////////////////////////////////////
	virtual HRESULT GetObject(IUnknown** ppObj, REFIID riid)
	{
		_ASSERT( COMPONENT_STATE_INITIALIZED == m_eState );
		return m_pComponent->GetObject(ppObj, riid);
	}

	//////////////////////////////////////////////////////////////////////////
	virtual void Shutdown(void)
	{
		_ASSERT(
				 COMPONENT_STATE_INITIALIZED == m_eState ||
				 COMPONENT_STATE_SUSPENDED == m_eState
			   );
		m_pComponent->Shutdown();
		m_eState = COMPONENT_STATE_SHUTDOWN;
	}

	//////////////////////////////////////////////////////////////////////////
	inline LONG GetId(void) const
	{ return m_lId; }

	//////////////////////////////////////////////////////////////////////////
	inline COMPONENTSTATE GetState(void) const
	{ return m_eState; }

	//////////////////////////////////////////////////////////////////////////
	inline COMPONENTTYPE GetType(void) const
	{ return m_eType; }

protected:

	typedef CComPtr<IIasComponent>		IASComponentPtr;

	// Invoked explicitly by derived (letter) classes
	//
	CComponent(LONG eComponentType, LONG lComponentId, LetterConstructor TheDummy)
	 : m_lId(lComponentId),
	   m_eState(COMPONENT_STATE_SHUTDOWN), // Not used by derived class
	   m_eType((COMPONENTTYPE)eComponentType),
	   m_pComponent(NULL)
	{

	}

private:

	// No default constructor since we would'nt know what
	// type of component to build by default
	//
	CComponent();

	// The constructor - Only a ComponentMasterPtr can construct this class
	//
	friend ComponentMasterPtr;
	CComponent(LONG eComponentType, LONG lComponentId);

	// No copy - No Assignment - No Shirt, No Shoes, No Service
	//
	CComponent(const CComponent& theComponent);
	CComponent& operator = (const CComponent& theComponent);

	/////////////////////////////////////////////////////////////////////////
	LONG			m_lId;
	COMPONENTSTATE	m_eState;
	COMPONENTTYPE	m_eType;
	CComponent*		m_pComponent;
};


///////////////////////////////////////////////////////////////////
// IAS Component (Letter) Classes
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
class CComponentAuditor : public CComponent
{

public:

	CComponentAuditor(LONG lComponentId)
		: CComponent(COMPONENT_TYPE_AUDITOR, lComponentId, LetterConstructor())
	{
		TRACE_LETTER_CREATE(CComponentAuditor);
	}

	virtual ~CComponentAuditor()
	{
		TRACE_LETTER_DESTROY(CComponentAuditor);
	}

	virtual HRESULT Initialize(ISdo* pSdoService);
	virtual HRESULT Configure(ISdo* pSdoService);
	virtual HRESULT Suspend(void);
	virtual HRESULT Resume(void);
	virtual HRESULT GetObject(IUnknown** ppObj, REFIID riid);
	virtual HRESULT PutObject(IUnknown* pObj, REFIID riid);
	virtual void    Shutdown(void);

private:

	CComponentAuditor(const CComponentAuditor& x);
	CComponentAuditor& operator = (const CComponentAuditor& x);

	IASComponentPtr			m_pAuditor;
};


///////////////////////////////////////////////////////////////////
class CComponentProtocol : public CComponent
{
public:

	CComponentProtocol(LONG lComponentId)
		: CComponent(COMPONENT_TYPE_PROTOCOL, lComponentId, LetterConstructor())
	{
		TRACE_LETTER_CREATE(CComponentProtocol);
	}

	virtual ~CComponentProtocol()
	{
		TRACE_LETTER_DESTROY(CComponentProtocol);
	}

	virtual HRESULT Initialize(ISdo* pSdo);
	virtual HRESULT Configure(ISdo* pSdo);
	virtual HRESULT Suspend(void);
	virtual HRESULT Resume(void);
	virtual HRESULT GetObject(IUnknown** ppObj, REFIID riid);
	virtual HRESULT PutObject(IUnknown* pObj, REFIID riid);
	virtual void    Shutdown(void);

private:

	CComponentProtocol(const CComponentProtocol& x);
	CComponentProtocol& operator = (const CComponentProtocol& x);

	IASComponentPtr			m_pProtocol;
};


///////////////////////////////////////////////////////////////////
class CComponentRequestHandler : public CComponent
{
public:

	CComponentRequestHandler(LONG lComponentId)
		: CComponent(COMPONENT_TYPE_REQUEST_HANDLER, lComponentId, LetterConstructor())
	{
		TRACE_LETTER_CREATE(CComponentRequestHandler);
	}

	~CComponentRequestHandler()
	{
		TRACE_LETTER_DESTROY(CComponentRequestHandler);
	}

	virtual HRESULT Initialize(ISdo* pSdo);
	virtual HRESULT Configure(ISdo* pSdo);
	virtual HRESULT Suspend(void);
	virtual HRESULT Resume(void);
	virtual HRESULT GetObject(IUnknown** ppObj, REFIID riid);
	virtual HRESULT PutObject(IUnknown* pObj, REFIID riid);
	virtual void    Shutdown(void);

private:

	CComponentRequestHandler(const CComponentRequestHandler& x);
	CComponentRequestHandler& operator = (const CComponentRequestHandler& x);

	IASComponentPtr			m_pRequestHandler;
};

#endif //  __INC_SDO_COMPONENT_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocondition.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocondition.cpp
//
// Project:     Everest
//
// Description: IAS - Condition SDO Implementation
//
// Author:      TLP 2/13/98
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdocondition.h"
#include "xprparse.h"

///////////////////////////////////////////////////////////////////////////
HRESULT CSdoCondition::ValidateProperty(
								/*[in]*/ PSDOPROPERTY pProperty, 
								/*[in]*/ VARIANT* pValue
									   )
{
	/* Uncomment when core has switched over to using the new dictionary
	
	if ( PROPERTY_CONDITION_TEXT == pProperty->GetId() )
	{
		_ASSERT( VT_BSTR == V_VT(pValue) );
		if ( VT_BSTR != V_VT(pValue) ) 
			return E_INVALIDARG;

		_variant_t vtReturn;
		return IASParseExpression( V_BSTR(pValue), &vtReturn );
	}
	return pProperty->Validate(pValue);

	*/
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocondition.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocondition.h
//
// Project:     Everest
//
// Description: IAS - Condition SDO Declaration
//
// Author:      TLP 2/13/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_CONDITION_H_
#define _INC_IAS_SDO_CONDITION_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include <sdofactory.h>

/////////////////////////////////////////////////////////////////////////////
// CSdoCondition
/////////////////////////////////////////////////////////////////////////////

class CSdoCondition : public CSdo 
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoCondition)
	COM_INTERFACE_ENTRY(ISdo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoCondition);

	/////////////////////////////////////////////////////////////////////////////
	CSdoCondition() { }

	/////////////////////////////////////////////////////////////////////////////
    ~CSdoCondition() { }

	////////////////////////////////////////////////////////////////////////////
	HRESULT ValidateProperty(
				     /*[in]*/ PSDOPROPERTY pProperty, 
					 /*[in]*/ VARIANT* pValue
					        ) throw();

private:

	CSdoCondition(const CSdoCondition& rhs);
	CSdoCondition& operator = (CSdoCondition& rhs);
};

#endif // _INC_IAS_SDO_CONDITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocoremgr.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocoremgr.h
//
// Project:     Everest
//
// Description: IAS Core Manager
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __INC_IAS_SDO_CORE_MGR_H
#define __INC_IAS_SDO_CORE_MGR_H

#include "sdobasedefs.h"
#include "sdocomponentmgr.h"
#include "sdopipemgr.h"

///////////////////////////////////////////////////////////////////
// IAS Service Status

typedef enum IAS_SERVICE_STATUS
{
   IAS_SERVICE_STATUS_STARTED = 0x100,
   IAS_SERVICE_STATUS_STOPPED = 0x200

}   IAS_SERVICE_STATUS;


///////////////////////////////////////////////////////////////////
// IAS Core Manager

class CCoreMgr
{

friend CCoreMgr& GetCoreManager(void);

private:

   ///////////////////////////////////////////////////////////////////
   // Start of nested Class - Service Status
   //
   class CServiceStatus
   {
      enum _MAX_SERVICES { MAX_SERVICES = 16 };

      typedef struct _SERVICEINFO
      {
         IAS_SERVICE_STATUS   eStatus;
         SERVICE_TYPE      eType;

      } SERVICEINFO;

      #define DEFINE_IAS_SERVICES()   \
            DWORD i = 0;         \
            memset(&m_ServiceInfo, 0, sizeof(SERVICEINFO) * MAX_SERVICES);

      #define INIT_IAS_SERVICE(Type)                             \
            _ASSERT( i < MAX_SERVICES );                       \
            m_ServiceInfo[i].eStatus = IAS_SERVICE_STATUS_STOPPED;   \
            m_ServiceInfo[i].eType = Type;                       \
            i++;
   public:

      //////////////////////////////////////////////////////////////////////
      void SetServiceStatus(SERVICE_TYPE eType, IAS_SERVICE_STATUS eStatus)
      {
         DWORD i;
         for ( i = 0; i < MAX_SERVICES; i++ )
         {
            if ( m_ServiceInfo[i].eType == eType )
            {
               m_ServiceInfo[i].eStatus = eStatus;
               return;
            }
         }
         _ASSERT(FALSE);
      }

      //////////////////////////////////////////////////////////////////////
      bool IsServiceStarted(SERVICE_TYPE eType) const
      {
         DWORD i;
         for ( i = 0; i < MAX_SERVICES; i++ )
         {
            if ( m_ServiceInfo[i].eType == eType )
            {
               return ( m_ServiceInfo[i].eStatus == IAS_SERVICE_STATUS_STARTED ? true : false );
            }
         }

         return false;
      }

      //////////////////////////////////////////////////////////////////////
      bool IsAnyServiceStarted()
      {
         DWORD i;
         for ( i = 0; i < MAX_SERVICES; i++ )
         {
            if ( m_ServiceInfo[i].eStatus == IAS_SERVICE_STATUS_STARTED )
               return true;
         }

         return false;
      }

   private:

      // Constructed by the core manager
      //
      friend class CCoreMgr;

      CServiceStatus()
      {
         // Initialize the IAS service information
         //
         DEFINE_IAS_SERVICES();
         INIT_IAS_SERVICE(SERVICE_TYPE_IAS);
         INIT_IAS_SERVICE(SERVICE_TYPE_RAS);
         // New Service Here...
      }

      SERVICEINFO    m_ServiceInfo[MAX_SERVICES];

   }; // End of nested class CServiceStatus

public:

   CCoreMgr();
   CCoreMgr(CCoreMgr& theCore);
   CCoreMgr& operator = (CCoreMgr& theCore);


   HRESULT   StartService(SERVICE_TYPE ServiceType);
   HRESULT   StopService(SERVICE_TYPE ServiceType);
   HRESULT   UpdateConfiguration(void);

private:

   IASDATASTORE GetDataStore(void);

   HRESULT   InitializeComponents(void);
   void   ShutdownComponents(void);

   HRESULT   InitializeAuditors(ISdo* pSdoService);
   HRESULT   ConfigureAuditors(ISdo* pSdoService);
   void   ShutdownAuditors(void);

   HRESULT   InitializeProtocols(ISdo* pSdoService);
   HRESULT   ConfigureProtocols(ISdo* pSdoService);
   void   ShutdownProtocols(void);

   bool   AddComponent(LONG Id, ComponentPtr& cp, ComponentMap& damap)
   {
      try
      {
         pair<ComponentMapIterator, bool> thePair;
         thePair = damap.insert(ComponentMap::value_type(Id, cp));
         return thePair.second;
      }
      catch(...)
      {

      }
      return false;
   }

   ////////////////////////////////////////

   typedef enum _CORESTATE
   {
      CORE_STATE_SHUTDOWN,
      CORE_STATE_INITIALIZED

   }   CORESTATE;

   CORESTATE         m_eCoreState;
   PipelineMgr      m_PipelineMgr;
   ComponentMap      m_Auditors;
   ComponentMap      m_Protocols;
   CServiceStatus      m_ServiceStatus;
};


////////////////////////
// Core manager accessor

CCoreMgr& GetCoreManager(void);


#endif // __INC_IAS_SDO_CORE_MGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdodictionary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdodictionary.h
//
// SYNOPSIS
//
//    Declares the class SdoDictionary.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDODICTIONARY_H
#define SDODICTIONARY_H
#if _MSC_VER >= 1000
#pragma once
#endif

class AttributeDefinition;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoDictionary
//
// DESCRIPTION
//
//    Implements the ISdoDictionaryOld interface.
//
///////////////////////////////////////////////////////////////////////////////
class SdoDictionary
   : public IDispatchImpl< ISdoDictionaryOld,
                           &__uuidof(ISdoDictionaryOld),
                           &LIBID_SDOIASLib
                         >,
     public IDispatchImpl< ISdo,
                           &__uuidof(ISdo),
                           &LIBID_SDOIASLib
                         >
{
public:

   // Create a new dictionary.
   static HRESULT createInstance(
                      PCWSTR path,
                      bool local,
                      SdoDictionary** newDnary
                      )  throw ();

   // Retrieve AttributeDefinition's by various keys.
   const AttributeDefinition* findById(ULONG id) const throw ();
   const AttributeDefinition* findByName(PCWSTR name) const throw ();
   const AttributeDefinition* findByLdapName(PCWSTR ldapName) const throw ();

//////////
// IUnknown
//////////
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

//////////
// ISdoDictionaryOld
//////////
   STDMETHOD(EnumAttributes)(
                 VARIANT* Id,
                 VARIANT* pValues
                 );
   STDMETHOD(GetAttributeInfo)(
                 ATTRIBUTEID Id,
                 VARIANT* pInfoIDs,
                 VARIANT* pInfoValues
                 );
   STDMETHOD(EnumAttributeValues)(
                 ATTRIBUTEID Id,
                 VARIANT* pValueIds,
                 VARIANT* pValuesDesc
                 );
   STDMETHOD(CreateAttribute)(
                 ATTRIBUTEID Id,
                 IDispatch** ppAttributeObject
                 );
   STDMETHOD(GetAttributeID)(
                 BSTR bstrAttributeName,
                 ATTRIBUTEID* pId
                 );

//////////
// ISdo
//////////
   STDMETHOD(GetPropertyInfo)(LONG Id, IUnknown** ppPropertyInfo);
   STDMETHOD(GetProperty)(LONG Id, VARIANT* pValue);
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);
   STDMETHOD(ResetProperty)(LONG Id);
   STDMETHOD(Apply)();
   STDMETHOD(Restore)();
   STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

protected:
   SdoDictionary() throw ();
   ~SdoDictionary() throw ();

   // Initialize the dictionary from the specified data source.
   HRESULT initialize(PCWSTR dsn, bool local) throw ();

private:
   LONG refCount;                            // Reference count.
   PWSTR dnaryLoc;                           // Location of the dictionary.
   ULONG size;                               // Number of definitions.
   const AttributeDefinition** byId;         // Sorted by ID.
   const AttributeDefinition** byName;       // Sorted by Name.
   const AttributeDefinition** byLdapName;   // Sorted by LDAP Name.

   // Not implemented.
   SdoDictionary(const SdoDictionary&);
   SdoDictionary& operator=(const SdoDictionary&);
};

#endif  // SDODICTIONARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdofactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdofactory.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object Factory
//
// When         Who    What
// ----         ---    ----
// 9/8/98       TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ias.h>
#include "sdofactory.h"
#include "sdo.h"
#include "sdoschema.h"
#include "sdocollection.h"
#include "sdoclient.h"
#include "sdocomponent.h"
#include "sdocondition.h"
#include "sdoprofile.h"
#include "sdopolicy.h"
#include "sdoserviceias.h"
#include "sdouser.h"
#include "sdovendor.h"
#include "sdoservergroup.h"

//////////////////////////////////////////////////////////////////////////////
BEGIN_SDOFACTORY_MAP(SdoClassFactory1)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_CLIENT, CSdoClient)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_CONDITION, CSdoCondition)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_POLICY, CSdoPolicy)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_PROFILE, CSdoProfile)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_SERVICE, CSdoServiceIAS)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_USER, CSdoUser)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_VENDOR, CSdoVendor)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_RADIUSGROUP, SdoServerGroup)
   DEFINE_SDOFACTORY_ENTRY_1(SDO_PROG_ID_RADIUSSERVER, SdoServer)
END_SDOFACTORY_MAP()

//////////////////////////////////////////////////////////////////////////////
ISdo* MakeSDO(
     /*[in]*/ LPCWSTR          lpszSdoName,
     /*[in]*/ LPCWSTR           lpszSdoProgId,
     /*[in]*/ ISdoMachine*      pAttachedMachine,
     /*[in]*/ IDataStoreObject* pDSObject,
     /*[in]*/ ISdoCollection*   pParent,
     /*[in]*/ bool             fInitNew
            )
{
   ISdo* pSdo = NULL;
   PSDO_CLASS_FACTORY_INFO pFactoryInfo = SdoClassFactory1;
   while ( pFactoryInfo->pProgId )
   {
      if ( 0 == lstrcmp(pFactoryInfo->pProgId, lpszSdoProgId) )
      {
         _ASSERT ( NULL != pFactoryInfo->pfnFactory1 );
         pSdo = (pFactoryInfo->pfnFactory1)(
                                    lpszSdoName,
                                    lpszSdoProgId,
                                    pAttachedMachine,
                                    pDSObject,
                                    pParent,
                                    fInitNew
                                   );
         break;
      }
      pFactoryInfo++;
      if ( NULL == pFactoryInfo->pProgId )
      {
         // Default to creating a component SDO
         //
         _ASSERT ( NULL != pFactoryInfo->pfnFactory1 );
         pSdo = (pFactoryInfo->pfnFactory1)(
                                    lpszSdoName,
                                    lpszSdoProgId,
                                    pAttachedMachine,
                                    pDSObject,
                                    pParent,
                                    fInitNew
                                   );
      }
   }
   return pSdo;
}


//////////////////////////////////////////////////////////////////////////////
BEGIN_SDOFACTORY_MAP(SdoClassFactory2)
END_SDOFACTORY_MAP()

//////////////////////////////////////////////////////////////////////////////
ISdo* MakeSDO(
     /*[in]*/ LPCWSTR          lpszSdoName,
     /*[in]*/ LPCWSTR           lpszSdoProgId,
     /*[in]*/ ISdoSchema*       pSdoSchema,
     /*[in]*/ IDataStoreObject* pDSObject,
     /*[in]*/ ISdoCollection*   pParent,
     /*[in]*/ bool             fInitNew
            )
{
   ISdo* pSdo = NULL;
   PSDO_CLASS_FACTORY_INFO pFactoryInfo = SdoClassFactory2;
   while ( pFactoryInfo->pProgId )
   {
      if ( 0 == lstrcmp(pFactoryInfo->pProgId, lpszSdoProgId) )
      {
         _ASSERT ( NULL != pFactoryInfo->pfnFactory2 );
         pSdo = (pFactoryInfo->pfnFactory2)(
                                    lpszSdoName,
                                    lpszSdoProgId,
                                    pSdoSchema,
                                    pDSObject,
                                    pParent,
                                    fInitNew
                                   );
         break;
      }
      pFactoryInfo++;
   }
   return pSdo;
}

//////////////////////////////////////////////////////////////////////////////
ISdoCollection* MakeSDOCollection(
                   LPCWSTR lpszCreateClassId,
                   ISdoMachine* pAttachedMachine,
                   IDataStoreContainer* pDSContainer,
                   size_t maxSize
                   )
{
   ISdoCollection* pSdoCollection = NULL;
   try
   {
      auto_ptr<SDO_COLLECTION_OBJ> pCollection (new SDO_COLLECTION_OBJ);
      if ( SUCCEEDED(pCollection->InternalInitialize(
                                             lpszCreateClassId,
                                             pAttachedMachine,
                                              pDSContainer,
                                             maxSize
                                             )) )
      {
         pSdoCollection = dynamic_cast<ISdoCollection*>(pCollection.release());
      }
      else
      {
         IASTracePrintf("Error in SDO Factory - MakeSDOCollection() - Collection could not be initialized...");
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO Factory - MakeSDOCollection() - Could not create collection object...");
   }
   return pSdoCollection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdocoremgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdocoremgr.cpp
//
// Project:     Everest
//
// Description: IAS - Server Core Manager Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdocoremgr.h"
#include "sdohelperfuncs.h"
#include "sdocomponentfactory.h"
#include "sdo.h"
#include "sdoserviceias.h"

/////////////////////////
// Core manager retrieval

CCoreMgr& GetCoreManager(void)
{
	//////////////////////////////////////////////////////////////////////////
	static CCoreMgr theCoreManager;    // The one and only core manager
	//////////////////////////////////////////////////////////////////////////
	return theCoreManager;
}

//////////////////////////////////////////////////////////////////////////////
//				IAS	CORE MANAGER CLASS IMPLEMENTATION
//
// This class is responsible for managing the lifetimes of the components
// that do "real" work. It also provides services to the class that
// implements the ISdoService interface.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////////
CCoreMgr::CCoreMgr()
	: m_eCoreState(CORE_STATE_SHUTDOWN)
{

}


//////////////////////////////////////////////////////////////////////////////
//
// Function:	CCoreMgr::StartService()
//
// Visibility:  Public
//
// Inputs:		eType: type of service to stop
//
// Outputs:		S_OK - function succeeded - service started.
//				E_FAIL - function failed - service not started.
//
// Description: Starts a specified IAS service.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CCoreMgr::StartService(SERVICE_TYPE eType)
{
	HRESULT		hr = S_OK;
	LONG		lProtocolId;
	bool		fUpdateConfiguration = true;

	do
	{
		// Initialize the core if we've not already done so...
		//
		if ( CORE_STATE_SHUTDOWN == m_eCoreState )
		{
			hr = InitializeComponents();
			if ( FAILED(hr) )
				break;

			// No need to update configuration (InitializeComponents() just did)
			//
			fUpdateConfiguration = false;
		}

		// Start the requested service if it ain't already started
		//
		if ( ! m_ServiceStatus.IsServiceStarted(eType) )
		{
			switch ( eType )
			{
				case SERVICE_TYPE_IAS:
					lProtocolId = IAS_PROTOCOL_MICROSOFT_RADIUS;
					break;

				case SERVICE_TYPE_RAS:
					lProtocolId = IAS_PROTOCOL_MICROSOFT_SURROGATE;
					break;

				default:

					// BAD! - tar and feather the caller
					//
					_ASSERT(FALSE);
					break;
			};

			hr = E_FAIL;

			// Brackets provide scope that ensures the protocol
			// handle is released before invoking ShutdownComponents().
			// This allows all protocols to be released in the
			// context of the ShutdownProtocols() function.
			{
				ComponentMapIterator iter = m_Protocols.find(lProtocolId);
				_ASSERT( iter != m_Protocols.end() );
				if ( iter != m_Protocols.end() )
				{
					// Update the service configuration if we're already
					// initialized and we're just resuming a protocol. We need
					// to do this because the service may be started in an
					// instance of svchost running another of our services.
					//

					// For example, RRAS is running automatically and then the
					// user configures IAS via the IAS UI and then starts the
					// IAS service. If the service starts in the instance of
					// svchost running RRAS then we need to update its
					// configuration.

					hr = S_OK;
					if ( fUpdateConfiguration )
					{
						hr = UpdateConfiguration();
						if ( FAILED(hr) )
							IASTracePrintf("IAS Core Manager was unable to configure service: %d...", eType);
					}
					if ( SUCCEEDED(hr) )
					{
						ComponentPtr pProtocol = (*iter).second;
						hr = pProtocol->Resume();
					}
				}
			}

			if ( SUCCEEDED(hr) )
			{
				m_ServiceStatus.SetServiceStatus(eType, IAS_SERVICE_STATUS_STARTED);

				// TODO: Log Service Started Event (IAS Only)

				IASTracePrintf("IAS Core Manager successfully started service %d...", eType);
			}
			else
			{
				// TODO: Log Service Failed Event (IAS Only)

				// This function did not succeed so shutdown the core if no
				// other services are started.
				//
				if ( ! m_ServiceStatus.IsAnyServiceStarted() )
					ShutdownComponents();
			}
		}

	} while ( FALSE );

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function:	CCoreMgr::StopService()
//
// Visibility:  Public
//
// Inputs:		eType: type of service to stop
//
// Outputs:		S_OK - function succeeded - service started.
//				E_FAIL - function failed - service not started.
//
// Description: Stops a specified IAS service.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CCoreMgr::StopService(SERVICE_TYPE eType)
{
	HRESULT		hr = E_FAIL;
	LONG		lProtocolId;

	do
	{
		switch ( eType )
		{
			case SERVICE_TYPE_IAS:
				lProtocolId = IAS_PROTOCOL_MICROSOFT_RADIUS;
				break;

			case SERVICE_TYPE_RAS:
				lProtocolId = IAS_PROTOCOL_MICROSOFT_SURROGATE;
				break;

			default:

				// BAD! - tar and feather the caller
				//
				_ASSERT(FALSE);
				break;
		};

		// Brackets provide scope that ensures the protocol
		// handle is released before invoking ShutdownComponents().
		// This allows all protocols to be released in the
		// context of the ShutdownProtocols() function.
		{
			ComponentMapIterator iter = m_Protocols.find(lProtocolId);
			if ( iter == m_Protocols.end() )
				break;
			ComponentPtr pProtocol = (*iter).second;
			hr = pProtocol->Suspend();
			if ( SUCCEEDED(hr) )
				IASTracePrintf("IAS Core Manager stopped service %d...", eType);
		}

		m_ServiceStatus.SetServiceStatus(eType, IAS_SERVICE_STATUS_STOPPED);

		// Shutdown the core if this was the last active service
		//
		if ( ! m_ServiceStatus.IsAnyServiceStarted() )
			ShutdownComponents();

	} while ( FALSE );

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:	CCoreMgr::UpdateConfiguration()
//
// Visibility:  Public
//
// Inputs:		None
//
// Outputs:		S_OK - function succeeded - service started.
//				E_FAIL - function failed - service not started.
//
// Description: Used to update the configuration information used
//				by the core components.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CCoreMgr::UpdateConfiguration()
{
	HRESULT					hr = E_FAIL;

	_ASSERT ( CORE_STATE_INITIALIZED == m_eCoreState );

	IASTracePrintf("IAS Core Manager is updating component configuration...");

	do
	{
		CComPtr<ISdoMachine> pSdoMachine;
		hr = CoCreateInstance(
         					   CLSID_SdoMachine,
   	               			   NULL,
    						   CLSCTX_INPROC_SERVER,
   							   IID_ISdoMachine,
							   (void**)&pSdoMachine
							 );
		if ( FAILED(hr) )
			break;

		IASTracePrintf("IAS Core Manager is attaching to the local machine...");
		hr = pSdoMachine->Attach(NULL);
		if ( FAILED(hr) )
			break;

		// Get the service SDO
		//
		CComPtr<IUnknown> pUnknown;
		hr = pSdoMachine->GetServiceSDO(GetDataStore(), IASServiceName, &pUnknown);
		if ( FAILED(hr) )
			break;

		CComPtr<CSdoServiceIAS> pSdoService;
		hr = pUnknown->QueryInterface(__uuidof(SdoService), (void**)&pSdoService);
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Core Manager - InitializeComponents() - QueryInterface(ISdo) failed...");
			break;
		}

		hr = ConfigureAuditors(pSdoService);
		if ( FAILED(hr) )
			break;

      CComPtr<IDataStoreObject> dstore;
      pSdoService->getDataStoreObject(&dstore);
		hr = LinkHandlerProperties(pSdoService, dstore);
		if ( FAILED(hr) )
			break;

		hr = m_PipelineMgr.Configure(pSdoService);
		if ( FAILED(hr) )
			break;

		hr = ConfigureProtocols(pSdoService);
		if ( FAILED(hr) )
			break;

	} while ( FALSE );

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
// Core Manager Private Member Functions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT	CCoreMgr::InitializeComponents(void)
{
	HRESULT	hr;

	_ASSERT ( CORE_STATE_SHUTDOWN == m_eCoreState );


	do
	{
      IASTraceInitialize();
	   IASTraceString("IAS Core Manager is initializing the IAS components...");
		IASInitialize();

		CComPtr<ISdoMachine> pSdoMachine;
		hr = CoCreateInstance(
         					   CLSID_SdoMachine,
   	               			   NULL,
    						   CLSCTX_INPROC_SERVER,
   							   IID_ISdoMachine,
							   (void**)&pSdoMachine
							 );
		if ( FAILED(hr) )
			break;

		IASTracePrintf("IAS Core Manager is attaching to the local machine...");
		hr = pSdoMachine->Attach(NULL);
		if ( FAILED(hr) )
			break;

		CComPtr<IUnknown> pUnknown;
		hr = pSdoMachine->GetServiceSDO(GetDataStore(), IASServiceName, &pUnknown);
		if ( FAILED(hr) )
			break;

		CComPtr<CSdoServiceIAS> pSdoService;
		hr = pUnknown->QueryInterface(__uuidof(SdoService), (void**)&pSdoService);
		if ( FAILED(hr) )
		{
			IASTracePrintf("Error in Core Manager - InitializeComponents() - QueryInterface(ISdo - Service) failed...");
			break;
		}

		hr = InitializeAuditors(pSdoService);
		if ( FAILED(hr) )
			break;


      CComPtr<IDataStoreObject> dstore;
      pSdoService->getDataStoreObject(&dstore);
		hr = LinkHandlerProperties(pSdoService, dstore);
		if ( FAILED(hr) )
		{
			ShutdownAuditors();
			break;
		}

		hr = m_PipelineMgr.Initialize(pSdoService);
		if ( FAILED(hr) )
		{
			ShutdownAuditors();
			break;
		}

		hr = InitializeProtocols(pSdoService);
		if ( FAILED(hr) )
		{
			m_PipelineMgr.Shutdown();
			ShutdownAuditors();
			break;
		}

		m_eCoreState = CORE_STATE_INITIALIZED;

	} while (FALSE);


	if ( FAILED(hr) )
   {
		IASUninitialize();
      IASTraceUninitialize();
   }

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
void	CCoreMgr::ShutdownComponents(void)
{
	_ASSERT ( CORE_STATE_INITIALIZED == m_eCoreState );
	IASTracePrintf("IAS Core Manager is shutting down the IAS components...");
	ShutdownProtocols();
	m_PipelineMgr.Shutdown();
	ShutdownAuditors();
	IASUninitialize();
   IASTraceUninitialize();
	m_eCoreState = CORE_STATE_SHUTDOWN;
}

//////////////////////////////////////////////////////////////////////////////
IASDATASTORE CCoreMgr::GetDataStore()
{
	CRegKey	IASKey;
	LONG lResult = IASKey.Open( HKEY_LOCAL_MACHINE, IAS_POLICY_REG_KEY, KEY_READ );
	if ( lResult == ERROR_SUCCESS )
	{
		DWORD dwValue;
		lResult = IASKey.QueryValue( dwValue, (LPCTSTR)IAS_DATASTORE_TYPE );
		if ( lResult == ERROR_SUCCESS )
			return (IASDATASTORE)dwValue;
	}
	return DATA_STORE_LOCAL;
}



//////////////////////////////////////////////////////////////////////////////
HRESULT CCoreMgr::InitializeAuditors(ISdo* pSdoService)
{
	HRESULT						hr;
	LONG						lComponentId;
	CComPtr<IEnumVARIANT>		pEnumAuditors;
	CComPtr<ISdo>				pSdoAuditor;

	// Note about state: When this function completes, either all of the
	// auditors are initialized or none of the auditors are initialized

	IASTracePrintf("IAS Core Manager is initializing the auditors...");

	try
	{
		do
		{
			hr = ::SDOGetCollectionEnumerator(pSdoService, PROPERTY_IAS_AUDITORS_COLLECTION, &pEnumAuditors);
			if ( FAILED(hr) )
				break;

			hr = ::SDONextObjectFromCollection(pEnumAuditors, &pSdoAuditor);
			while ( S_OK == hr )
			{
				hr = ::SDOGetComponentIdFromObject(pSdoAuditor, &lComponentId);
				if ( FAILED(hr) )
					break;
				{
					ComponentPtr pAuditor = ::MakeComponent(COMPONENT_TYPE_AUDITOR, lComponentId);
					if ( ! pAuditor.IsValid() )
					{
						hr = E_FAIL;
						break;
					}

					hr = pAuditor->Initialize(pSdoAuditor);
					if ( FAILED(hr) )
						break;

					if ( ! AddComponent(lComponentId, pAuditor, m_Auditors) )
					{
						hr = E_FAIL;
						break;
					}
				}

				pSdoAuditor.Release();
				hr = ::SDONextObjectFromCollection(pEnumAuditors, &pSdoAuditor);
			}

			if ( S_FALSE == hr )
				hr = S_OK;

		} while ( FALSE );

	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - InitializeAuditors() - Caught unknown exception...");
		hr = E_FAIL;
	}

	if ( FAILED(hr) )
	{
		IASTracePrintf("Error in IAS Core Manager - InitializeAuditors() - Could not initialize the auditors...");
		ShutdownAuditors();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CCoreMgr::ConfigureAuditors(ISdo* pSdoService)
{
	HRESULT		hr = S_OK;


	IASTracePrintf("IAS Core Manager is configuring the auditors...");

	try
	{
		// Try to update the configuration settings for each request handler. We
		// assume that auditors are autonomous with respect to configuration
		// and if one fails to configure we'll continue to try to configure the others
		//
		ComponentMapIterator iter = m_Auditors.begin();
		while ( iter != m_Auditors.end() )
		{
            CComPtr <ISdo> pSdoComponent;
			ComponentPtr pAuditor = (*iter).second;

            // get the component from the collection
            hr = ::SDOGetComponentFromCollection (pSdoService, PROPERTY_IAS_AUDITORS_COLLECTION, pAuditor->GetId (), &pSdoComponent);
            if (SUCCEEDED (hr))
            {
			    hr = pAuditor->Configure(pSdoComponent);
			    if ( FAILED(hr) )
			    {
				    IASTracePrintf("IAS Core Manager - ConfigureAuditors() - Auditor %d could not be configured...", pAuditor->GetId());
				    hr = S_OK;
			    }
            }
            else
            {
				    IASTracePrintf("IAS Core Manager - ConfigureAuditors() - unable to get component from collection in auditor %d...", pAuditor->GetId());
				    hr = S_OK;
            }
			iter++;
		}
	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - ConfigureAuditors() - Caught unknown exception...");
		hr = E_FAIL;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
void	CCoreMgr::ShutdownAuditors(void)
{
	IASTracePrintf("IAS Core Manager is shutting down the auditors...");

	try
	{
		ComponentMapIterator iter = m_Auditors.begin();
		while ( iter != m_Auditors.end() )
		{
			ComponentPtr pAuditor = (*iter).second;
			pAuditor->Suspend();
			pAuditor->Shutdown();
			iter = m_Auditors.erase(iter);
		}
	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - ShutdownAuditors() - Caught unknown exception...");
	}
}

//////////////////////////////////////////////////////////////////////////////
HRESULT	CCoreMgr::InitializeProtocols(ISdo* pSdoService)
{
	HRESULT	hr = E_FAIL;

	IASTracePrintf("IAS Core Manager is initializing the protocols...");

	// Note about state: When this function completes, either all of the
	// protocols are initialized or none of the protocols are initialized

	try
	{
		do
		{
			CComPtr<IRequestHandler> pRequestHandler;
			m_PipelineMgr.GetPipeline(&pRequestHandler);

			CComPtr<IEnumVARIANT> pEnumProtocols;
			hr = ::SDOGetCollectionEnumerator(pSdoService, PROPERTY_IAS_PROTOCOLS_COLLECTION, &pEnumProtocols);
			if ( FAILED(hr) )
				break;

			LONG		  lComponentId;
			CComPtr<ISdo> pSdoProtocol;
			hr = ::SDONextObjectFromCollection(pEnumProtocols, &pSdoProtocol);
			while ( S_OK == hr )
			{
				hr = ::SDOGetComponentIdFromObject(pSdoProtocol, &lComponentId);
				if ( FAILED(hr) )
					break;
				{
					ComponentPtr pProtocol = ::MakeComponent(COMPONENT_TYPE_PROTOCOL, lComponentId);
					if ( ! pProtocol.IsValid() )
					{
						hr = E_FAIL;
						break;
					}

					// Don't treat protocol initialization as a critical failure
					//

					hr = pProtocol->Initialize(pSdoProtocol);
					if ( SUCCEEDED(hr) )
					{
						hr = pProtocol->PutObject(pRequestHandler, IID_IRequestHandler);
						if ( FAILED(hr) )
							break;

						hr = pProtocol->Suspend();
						if ( FAILED(hr) )
							break;

						if ( ! AddComponent(lComponentId, pProtocol, m_Protocols) )
						{
							hr = E_FAIL;
							break;
						}
					}
					pSdoProtocol.Release();
				}

				hr = ::SDONextObjectFromCollection(pEnumProtocols, &pSdoProtocol);
			}

			if ( S_FALSE == hr )
				hr = S_OK;

		} while ( FALSE );
	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - InitializeProtocols() - Caught unknown exception...");
		hr = E_FAIL;
	}

	if ( FAILED(hr) )
	{
		IASTracePrintf("Error in IAS Core Manager - InitializeProtocols() - Could not initialize the protocols...");
		ShutdownProtocols();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT	CCoreMgr::ConfigureProtocols(ISdo* pSdoService)
{
	HRESULT		hr = S_OK;

	IASTracePrintf("IAS Core Manager is configuring the protocols...");


	// Try to update the configuration settings for each protocol
	// Note we assume the request handler used by a protocol is not
	// dynamically configurable!
	//
	try
	{
		ComponentMapIterator iter = m_Protocols.begin();
		while ( iter != m_Protocols.end() )
		{
            CComPtr<ISdo> pSdoComponent;
			ComponentPtr pProtocol = (*iter).second;

            // get the protocol collection
            hr = ::SDOGetComponentFromCollection (pSdoService, PROPERTY_IAS_PROTOCOLS_COLLECTION, pProtocol->GetId (), &pSdoComponent);
            if (SUCCEEDED (hr))
			{

	    		hr = pProtocol->Configure(pSdoComponent);
			    if ( FAILED(hr) )
			    {
				    IASTracePrintf("IAS Core Manager - ConfigureProtocols() - Protocol %d could not be configured...", pProtocol->GetId());
				    hr = S_OK;
			    }
            }
            else
            {
				    IASTracePrintf("IAS Core Manager - ConfigureProtocols() - unnable to get component from collection for protocol %d...", pProtocol->GetId());
				    hr = S_OK;
            }
			iter++;
		}
	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - ConfigureProtocols() - Caught unknown exception...");
		hr = E_FAIL;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
void	CCoreMgr::ShutdownProtocols(void)
{
	IASTracePrintf("IAS Core Manager is shutting down the protocols...");

	try
	{
		ComponentMapIterator iter = m_Protocols.begin();
		while ( iter != m_Protocols.end() )
		{
			ComponentPtr pProtocol = (*iter).second;
			// We only initialize a protocol when its associated
			// service (IAS or RAS currently) is started.
			if ( COMPONENT_STATE_INITIALIZED == pProtocol->GetState() )
				pProtocol->Suspend();
			pProtocol->Shutdown();
			iter = m_Protocols.erase(iter);
		}
	}
	catch(...)
	{
		IASTracePrintf("Error in IAS Core Manager - ShutdownProtocols() - Caught unknown exception...");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdodictionary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdodictionary.cpp
//
// SYNOPSIS
//
//    Defines the class SdoDictionary.
//
// MODIFICATION HISTORY
//
//    03/01/1999    Original version.
//    01/27/2000    Add support for proxy policies.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <vector>

#include <iastlb.h>
#include <iastlutl.h>
#include <iasutil.h>
#include <iasuuid.h>

#include <attrdef.h>
#include <sdoattribute.h>
#include <sdodictionary.h>
#include "resource.h"

using namespace std;

// Function type used with bsearch and qsort.
typedef int (__cdecl *CompFn)(const void*, const void*);

inline SdoDictionary::SdoDictionary() throw ()
   : refCount(0),
     dnaryLoc(NULL),
     size(0),
     byId(NULL),
     byName(NULL),
     byLdapName(NULL)
{
}

inline SdoDictionary::~SdoDictionary() throw ()
{
   for (ULONG i = 0; i < size; ++i)
   {
      if (byId[i]) { byId[i]->Release(); }
   }

   delete[] byId;
   delete[] byName;
   delete[] byLdapName;
   delete dnaryLoc;
}

HRESULT SdoDictionary::createInstance(
                           PCWSTR path,
                           bool local,
                           SdoDictionary** newDnary
                           )  throw ()
{
   // Check the arguments.
   if (path == NULL || newDnary == NULL) { return E_INVALIDARG; }

   // Initialize the out parameter.
   *newDnary = NULL;

   // Create a new dictionary.
   SdoDictionary* dnary = new (std::nothrow) SdoDictionary;
   if (!dnary) { return E_OUTOFMEMORY; }

   // Build the DSN.
   PWCHAR dsn = (PWCHAR)_alloca((wcslen(path) + 11) * sizeof(WCHAR));
   wcscat(wcscpy(dsn, path), L"\\dnary.mdb");

   // Initialize the dictionary.
   HRESULT hr = dnary->initialize(dsn, local);
   if (FAILED(hr))
   {
      delete dnary;
      return hr;
   }

   // Set the refCount & return.
   dnary->refCount = 1;
   *newDnary = dnary;

   return S_OK;
}

const AttributeDefinition* SdoDictionary::findById(
                                              ULONG id
                                              ) const throw ()
{
   const AttributeDefinition* const* match;
   match = (const AttributeDefinition* const*)
           bsearch(
               &id,
               byId,
               size,
               sizeof(AttributeDefinition*),
               (CompFn)AttributeDefinition::searchById
               );

   return match ? *match : NULL;
}

const AttributeDefinition* SdoDictionary::findByName(
                                              PCWSTR name
                                              ) const throw ()
{
   const AttributeDefinition* const* match;

   match = (const AttributeDefinition* const*)
           bsearch(
               name,
               byName,
               size,
               sizeof(AttributeDefinition*),
               (CompFn)AttributeDefinition::searchByName
               );

   return match ? *match : NULL;
}

const AttributeDefinition* SdoDictionary::findByLdapName(
                                              PCWSTR name
                                              ) const throw ()
{
   const AttributeDefinition* const* match;

   match = (const AttributeDefinition* const*)
           bsearch(
               name,
               byLdapName,
               size,
               sizeof(AttributeDefinition*),
               (CompFn)AttributeDefinition::searchByLdapName
               );

   return match ? *match : NULL;
}

STDMETHODIMP_(ULONG) SdoDictionary::AddRef()
{
   return InterlockedIncrement(&refCount);
}

STDMETHODIMP_(ULONG) SdoDictionary::Release()
{
   ULONG l = InterlockedDecrement(&refCount);

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP SdoDictionary::QueryInterface(REFIID iid, void ** ppvObject)
{
   if (ppvObject == NULL) { return E_POINTER; }

   if (iid == __uuidof(ISdoDictionaryOld) ||
       iid == __uuidof(IUnknown) ||
       iid == __uuidof(IDispatch))
   {
      *ppvObject = this;
   }
   else if (iid == __uuidof(ISdo))
   {
      *ppvObject = static_cast<ISdo*>(this);
   }
   else
   {
      return E_NOINTERFACE;
   }

   InterlockedIncrement(&refCount);

   return S_OK;
}

STDMETHODIMP SdoDictionary::EnumAttributes(
                                VARIANT* Id,
                                VARIANT* pValues
                                )
{
   // Check the arguments.
   if (Id == NULL || pValues == NULL) { return E_INVALIDARG; }

   // Initialize the out parameters.
   VariantInit(Id);
   VariantInit(pValues);

   // Find out what the caller's asking for.
   const AttributeDefinition* single;
   const AttributeDefinition* const* src;
   ULONG numAttrs;
   if (V_VT(Id) == VT_EMPTY)
   {
      // He wants all the attributes.
      src = byId;
      numAttrs = size;
   }
   else if (V_VT(Id) == VT_I4)
   {
      // He wants a single attribute.
      single = findById(V_VT(Id));
      if (!single) { return DISP_E_MEMBERNOTFOUND; }
      src = &single;
      numAttrs = 1;
   }
   else
   {
      // Invalid VARIANT type.
      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;

   do
   {
      //////////
      // Allocate SAFEARRAYs to hold the return values.
      //////////

      V_ARRAY(Id) = SafeArrayCreateVector(VT_I4, 0, numAttrs);
      V_VT(Id) = VT_ARRAY | VT_I4;

      V_ARRAY(pValues) = SafeArrayCreateVector(VT_VARIANT, 0, numAttrs);
      V_VT(pValues) = VT_ARRAY | VT_VARIANT;

      if (!V_ARRAY(Id) || !V_ARRAY(pValues))
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      //////////
      // Populate the arrays.
      //////////

      const AttributeDefinition* const* end = src + numAttrs;
      PULONG dstId = (PULONG)V_ARRAY(Id)->pvData;
      LPVARIANT dstName = (LPVARIANT)V_ARRAY(pValues)->pvData;

      for ( ; src != end; ++src, ++dstId, ++dstName)
      {
         *dstId = (*src)->id;

         V_BSTR(dstName) = SysAllocString((*src)->name);
         if (!V_BSTR(dstName))
         {
            hr = E_OUTOFMEMORY;
            break;
         }
         V_VT(dstName) = VT_BSTR;
      }

   } while (false);

   // If anything went wrong, clean up.
   if (FAILED(hr))
   {
      VariantClear(Id);
      VariantClear(pValues);
   }

   return hr;
}

STDMETHODIMP SdoDictionary::GetAttributeInfo(
                 ATTRIBUTEID Id,
                 VARIANT* pInfoIDs,
                 VARIANT* pInfoValues
                 )
{
   // Check the arguments.
   if (pInfoValues == NULL ||
       pInfoIDs == NULL ||
       // V_VT(pInfoIDs) != (VT_ARRAY | VT_I4) ||
       V_ARRAY(pInfoIDs) == NULL ||
       V_ARRAY(pInfoIDs)->cDims != 1)
   {
      return E_INVALIDARG;
   }

   // Initialize the out parameter.
   VariantInit(pInfoValues);

   // Find the attribute of interest.
   const AttributeDefinition* def = findById(Id);
   if (!def) { return DISP_E_MEMBERNOTFOUND; }

   // Allocate the outbound array.
   ULONG num = V_ARRAY(pInfoIDs)->rgsabound[0].cElements;
   V_ARRAY(pInfoValues) = SafeArrayCreateVector(VT_VARIANT, 0, num);
   if (!V_ARRAY(pInfoValues)) { return E_OUTOFMEMORY; }
   V_VT(pInfoValues) = VT_ARRAY | VT_VARIANT;

   // Fill in the information.
   PULONG src = (PULONG)V_ARRAY(pInfoIDs)->pvData;
   LPVARIANT dst = (LPVARIANT)V_ARRAY(pInfoValues)->pvData;
   for ( ; num > 0; --num, ++src, ++dst)
   {
      HRESULT hr = def->getInfo((ATTRIBUTEINFO)*src, dst);
      if (FAILED(hr))
      {
         VariantClear(pInfoValues);
         return hr;
      }
   }

   return S_OK;
}

STDMETHODIMP SdoDictionary::EnumAttributeValues(
                 ATTRIBUTEID Id,
                 VARIANT* pValueIds,
                 VARIANT* pValuesDesc
                 )
{
   // Check the arguments.
   if (pValueIds == NULL || pValuesDesc == NULL) { return E_INVALIDARG; }

   // Initialize the out parameters.
   VariantInit(pValueIds);
   VariantInit(pValuesDesc);

   // Find the attribute of interest.
   const AttributeDefinition* def = findById(Id);
   if (!def) { return DISP_E_MEMBERNOTFOUND; }

   // If it's not enumerable, there's nothing to do.
   if (def->enumNames == NULL) { return S_OK; }

   // Copy the enum Names and Values.
   HRESULT hr = SafeArrayCopy(def->enumValues, &V_ARRAY(pValueIds));
   if (SUCCEEDED(hr))
   {
      V_VT(pValueIds) = VT_ARRAY | VT_I4;

      hr = SafeArrayCopy(def->enumNames, &V_ARRAY(pValuesDesc));
      if (SUCCEEDED(hr))
      {
         V_VT(pValuesDesc) = VT_ARRAY | VT_VARIANT;
      }
      else
      {
         VariantClear(pValueIds);
      }
   }

   return hr;
}

STDMETHODIMP SdoDictionary::CreateAttribute(
                 ATTRIBUTEID Id,
                 IDispatch** ppAttributeObject
                 )
{
   // Check the arguments.
   if (ppAttributeObject == NULL) { return E_INVALIDARG; }

   // Initialize the out parameter.
   *ppAttributeObject = NULL;

   // Find the attribute of interest.
   const AttributeDefinition* def = findById(Id);
   if (!def) { return DISP_E_MEMBERNOTFOUND; }

   SdoAttribute* newAttr;
   HRESULT hr = SdoAttribute::createInstance(def, &newAttr);
   if (FAILED(hr)) { return hr; }

   *ppAttributeObject = newAttr;

   return S_OK;
}

STDMETHODIMP SdoDictionary::GetAttributeID(
                 BSTR bstrAttributeName,
                 ATTRIBUTEID* pId
                 )
{
   // Check the arguments.
   if (bstrAttributeName == NULL || pId == NULL) { return E_INVALIDARG; }

   const AttributeDefinition* match;

   // Check for LDAP Name first since this will speed up load time.
   match = findByLdapName(bstrAttributeName);

   if (!match)
   {
      // Maybe it's a display name instead.
      match = findByName(bstrAttributeName);
   }

   if (!match) { return DISP_E_MEMBERNOTFOUND; }

   *pId = (ATTRIBUTEID)match->id;

   return S_OK;
}

STDMETHODIMP SdoDictionary::GetPropertyInfo(LONG Id, IUnknown** ppPropertyInfo)
{ return E_NOTIMPL; }

STDMETHODIMP SdoDictionary::GetProperty(LONG Id, VARIANT* pValue)
{
   // Check the input args.
   if (pValue == NULL) { return E_INVALIDARG; }

   // Initialize the out parameter.
   VariantInit(pValue);

   // We only have one property.
   if (Id != PROPERTY_DICTIONARY_LOCATION) { return DISP_E_MEMBERNOTFOUND; }

   // dnaryLoc may be NULL.
   if (dnaryLoc)
   {
       V_BSTR(pValue) = SysAllocString(dnaryLoc);
       if (!V_BSTR(pValue)) { return E_OUTOFMEMORY; }
   }
   else
   {
       V_BSTR(pValue) = NULL;
   }

   V_VT(pValue) = VT_BSTR;

   return S_OK;
}

STDMETHODIMP SdoDictionary::PutProperty(LONG Id, VARIANT* pValue)
{ return E_ACCESSDENIED; }

STDMETHODIMP SdoDictionary::ResetProperty(LONG Id)
{ return S_OK; }

STDMETHODIMP SdoDictionary::Apply()
{ return S_OK; }

STDMETHODIMP SdoDictionary::Restore()
{ return S_OK; }

STDMETHODIMP SdoDictionary::get__NewEnum(IUnknown** ppEnumVARIANT)
{ return E_NOTIMPL; }

HRESULT SdoDictionary::initialize(PCWSTR dsn, bool local)  throw ()
{
   const size_t IAS_MAX_STRING = 512; 

   // Save the dsn.
   size_t nbyte = (wcslen(dsn) + 1) * sizeof(WCHAR);
   dnaryLoc = (PWSTR)operator new (nbyte, std::nothrow);
   if (!dnaryLoc) { return E_OUTOFMEMORY; }
   memcpy(dnaryLoc, dsn, nbyte);

   // Vector to hold the AttributeDefinitions.
   vector<const AttributeDefinition*> defs;

   HRESULT hr = S_OK;

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] =
      {
         L"ID",
         L"Name",
         L"Syntax",
         L"MultiValued",
         L"VendorID",
         L"IsAllowedInProfile",
         L"IsAllowedInCondition",
         L"-IsAllowedInProxyProfile",
         L"-IsAllowedInProxyCondition",
         L"Description",
         L"LDAPName",
         L"EnumNames",
         L"EnumValues",
         NULL
      };

      // Open the attributes table.
      IASTL::IASDictionary dnary(COLUMNS, (local ? NULL : dsn));

      defs.reserve(dnary.getNumRows());

      while (dnary.next())
      {
         // We're not interested in attributes that don't have a name.
         if (dnary.isEmpty(1)) { continue; }

         // Create a new AttributeDefinition.
         CComPtr<AttributeDefinition> def;
         HRESULT hr = AttributeDefinition::createInstance(&def);
         if (FAILED(hr)) { throw bad_alloc(); }

         /////////
         // Process the fields in the query result.
         /////////

         def->id = (ULONG)dnary.getLong(0);

         def->name = SysAllocString(dnary.getBSTR(1));
         if (!def->name) { throw bad_alloc(); }

         def->syntax = (ULONG)dnary.getLong(2);

         if (dnary.getBool(3))
         {
            def->restrictions |= MULTIVALUED;
         }

         def->vendor = (ULONG)dnary.getLong(4);

         if (dnary.getBool(5))
         {
            def->restrictions |= ALLOWEDINPROFILE;
         }

         if (dnary.getBool(6))
         {
            def->restrictions |= ALLOWEDINCONDITION;
         }

         if (dnary.getBool(7))
         {
            def->restrictions |= ALLOWEDINPROXYPROFILE;
         }

         if (dnary.getBool(8))
         {
            def->restrictions |= ALLOWEDINPROXYCONDITION;
         }

         if (dnary.isEmpty(9))
         {
            // Whistler machine. Load the string from the rc file
            WCHAR strTemp[IAS_MAX_STRING];
            int nbChar = LoadString(
                           _Module.GetResourceInstance(), 
                           static_cast<UINT>(def->id), 
                           strTemp,
                           IAS_MAX_STRING
                           );

            if (nbChar > 0)
            {
               // Description found
               def->description = SysAllocString(strTemp);
               if (!def->description) { throw bad_alloc();}
            }
            else
            {
               // Load the Default string
               nbChar = LoadString(
                           _Module.GetResourceInstance(), 
                           IDS_DESC_NOT_AVAIL, 
                           strTemp,
                           IAS_MAX_STRING
                           );
               _ASSERT(nbChar > 0);
               def->description = SysAllocString(strTemp);
               if (!def->description) { throw bad_alloc();}
            }
         }
         else
         {
            // This is a Windows 2000 machine
            def->description = SysAllocString(dnary.getBSTR(9));
            if (!def->description) { throw bad_alloc(); }
         }

         if (!dnary.isEmpty(10))
         {
            def->ldapName = SysAllocString(dnary.getBSTR(10));
         }
         else
         {
            def->ldapName = SysAllocString(def->name);
         }
         if (!def->ldapName) { throw bad_alloc(); }

         // Get the enumeration SAFEARRAYs.
         if (!dnary.isEmpty(11))
         {
            hr = SafeArrayCopy(
                     V_ARRAY(dnary.getVariant(11)),
                     &def->enumNames
                     );
            if (FAILED(hr)) { _com_issue_error(hr); }
         }

         if (!dnary.isEmpty(12))
         {
            hr = SafeArrayCopy(
                     V_ARRAY(dnary.getVariant(12)),
                     &def->enumValues
                     );
            if (FAILED(hr)) { _com_issue_error(hr); }
         }

         // Add this to the entries vector.
         defs.push_back(def);

         // We've safely stored the attribute, so detach.
         *(&def) = NULL;
      }

      // Allocate the permanent arrays.
      size = defs.size();
      byId = new const AttributeDefinition*[size];
      byName = new const AttributeDefinition*[size];
      byLdapName = new const AttributeDefinition*[size];

      // Fill in the arrays.
      size_t nbyte = size * sizeof(AttributeDefinition*);
      memcpy(byId, defs.begin(), nbyte);
      memcpy(byName, defs.begin(), nbyte);
      memcpy(byLdapName, defs.begin(), nbyte);

      // Sort the arrays.
      qsort(
          byId,
          size,
          sizeof(AttributeDefinition*),
          (CompFn)AttributeDefinition::sortById
          );
      qsort(
          byName,
          size,
          sizeof(AttributeDefinition*),
          (CompFn)AttributeDefinition::sortByName
          );
      qsort(
          byLdapName,
          size,
          sizeof(AttributeDefinition*),
          (CompFn)AttributeDefinition::sortByLdapName
          );
   }
   catch (const _com_error& ce)
   {
      hr = ce.Error();
   }
   catch (const std::bad_alloc&)
   {
      hr = E_OUTOFMEMORY;
   }
   catch (...)
   {
      hr = DISP_E_EXCEPTION;
   }

   if (FAILED(hr))
   {
      vector<const AttributeDefinition*>::iterator i;
      for (i = defs.begin(); i != defs.end(); ++i)
      {
         if (*i) { (*i)->Release(); }
      }

      delete[] byId;
      delete[] byName;
      delete[] byLdapName;

      size = 0;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdofactory.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdofactory.h
//
// Project:     Everest
//
// Description: SDO Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 9/08/98      TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SDO_FACTORY_H_
#define __INC_SDO_FACTORY_H_

#include "resource.h"
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"


//////////////////////////////////////////////////////////////////////////////
template <class T>
class CSdoFactoryImpl
{

public:

   CSdoFactoryImpl() { }
   ~CSdoFactoryImpl() { }

   //////////////////////////////////////////////////////////////////////////
    static ISdo* WINAPI MakeSdo(
                          LPCWSTR         lpszSdoName,
                          LPCWSTR         lpszSdoProgId,
                          ISdoMachine*      pAttachedMachine,
                          IDataStoreObject*   pDSObject,
                          ISdoCollection*   pParent,
                          bool            fInitNew
                           )
   {
      ISdo* pSdo = NULL;
      auto_ptr< CComObjectNoLock<T> > pSdoNew (new CComObjectNoLock<T>);
      if ( SUCCEEDED(pSdoNew->InternalInitialize(
                                       lpszSdoName,
                                          lpszSdoProgId,
                                         pAttachedMachine,
                                       pDSObject,
                                       pParent,
                                       fInitNew
                                      )) )
      {
         pSdo = dynamic_cast<ISdo*>(pSdoNew.release());
      }
      return pSdo;
   }

   //////////////////////////////////////////////////////////////////////////
    static ISdo* WINAPI MakeSdo(
                          LPCWSTR         lpszSdoName,
                          LPCWSTR         lpszSdoProgId,
                          ISdoSchema*      pSdoSchema,
                          IDataStoreObject*   pDSObject,
                          ISdoCollection*   pParent,
                          bool            fInitNew
                           )
   {
      ISdo* pSdo = NULL;
      auto_ptr< CComObjectNoLock<T> > pSdoNew (new CComObjectNoLock<T>);
      if ( SUCCEEDED(pSdoNew->InternalInitialize(
                                       lpszSdoName,
                                          lpszSdoProgId,
                                         pSdoSchema,
                                       pDSObject,
                                       pParent,
                                       fInitNew
                                      )) )
      {
         pSdo = dynamic_cast<ISdo*>(pSdoNew.release());
      }
      return pSdo;
   }

private:

   CSdoFactoryImpl(const CSdoFactoryImpl& rhs);
   CSdoFactoryImpl& operator = (CSdoFactoryImpl& rhs);
};


//////////////////////////////////////////////////////////////////////////////
#define   DECLARE_SDO_FACTORY(x)   static CSdoFactoryImpl<x> m_Factory;

//////////////////////////////////////////////////////////////////////////////
typedef ISdo* (WINAPI *PFNFACTORY1)(
                            LPCWSTR            lpszSdoName,
                             LPCWSTR            lpszSdoProgId,
                             ISdoMachine*       pSdoMachine,
                             IDataStoreObject*   pDSObject,
                            ISdoCollection*       pParent,
                            bool            fInitNew
                             );

//////////////////////////////////////////////////////////////////////////////
typedef ISdo* (WINAPI *PFNFACTORY2)(
                            LPCWSTR            lpszSdoName,
                             LPCWSTR            lpszSdoProgId,
                             ISdoSchema*         pSdoSchema,
                             IDataStoreObject*   pDSObject,
                            ISdoCollection*       pParent,
                            bool            fInitNew
                             );

//////////////////////////////////////////////////////////////////////////////
typedef struct _SDO_CLASS_FACTORY_INFO
{
   LPCWSTR      pProgId;
   PFNFACTORY1   pfnFactory1;
   PFNFACTORY2 pfnFactory2;

} SDO_CLASS_FACTORY_INFO, *PSDO_CLASS_FACTORY_INFO;

//////////////////////////////////////////////////////////////////////////////
#define      BEGIN_SDOFACTORY_MAP(x)    SDO_CLASS_FACTORY_INFO x[] = {
#define      DEFINE_SDOFACTORY_ENTRY_1(x,y) { x, y::m_Factory.MakeSdo, NULL },
#define      DEFINE_SDOFACTORY_ENTRY_2(x,y) { x, NULL, y::m_Factory.MakeSdo },
#define      END_SDOFACTORY_MAP()           { NULL, CSdoComponent::m_Factory.MakeSdo, NULL } };


//////////////////////////////////////////////////////////////////////////////
ISdo* MakeSDO(
     /*[in]*/ LPCWSTR          lpszSdoName,
     /*[in]*/ LPCWSTR           lpszSdoProgId,
     /*[in]*/ ISdoMachine*      pAttachedMachine,
     /*[in]*/ IDataStoreObject* pDSObject,
     /*[in]*/ ISdoCollection*   pParent,
     /*[in]*/ bool             fInitNew
            );

///////////////////////////////////////////////////////////////////
ISdo* MakeSDO(
     /*[in]*/ LPCWSTR          lpszSdoName,
     /*[in]*/ LPCWSTR           lpszSdoProgId,
     /*[in]*/ ISdoSchema*       pSdoSchema,
     /*[in]*/ IDataStoreObject* pDSObject,
     /*[in]*/ ISdoCollection*   pParent,
     /*[in]*/ bool              fInitNew
           );

///////////////////////////////////////////////////////////////////
ISdoCollection* MakeSDOCollection(
                   LPCWSTR lpszCreateClassId,
                   ISdoMachine* pAttachedMachine,
                   IDataStoreContainer* pDSContainer,
                   size_t maxSize
                   );

#endif // __INC_SDO_FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdohelperfuncs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdohelperfuncs.cpp
//
// Project:     Everest
//
// Description: Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
// 9/06/98      TLP      Added data store helpers
// 9/09/98      TLP    Added misc helpers
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iascomp.h>
#include <iasutil.h>
#include "sdohelperfuncs.h"
#include "sdoproperty.h"
#include "sdo.h"

///////////////////////////////////////////////////////////////////
HRESULT SDOGetCollectionEnumerator(
                     /*[in]*/   ISdo*         pSdo,
                     /*[in]*/   LONG         lPropertyId,
                    /*[out]*/   IEnumVARIANT** ppEnum
                          )
{
   HRESULT               hr;
   CComPtr<IUnknown>      pUnknown;
   CComPtr<ISdoCollection>   pSdoCollection;
   _variant_t            vtDispatch;

   _ASSERT( NULL != pSdo && NULL == *ppEnum );
   hr = pSdo->GetProperty(lPropertyId, &vtDispatch);
   _ASSERT( VT_DISPATCH == V_VT(&vtDispatch) );
   if ( SUCCEEDED(hr) )
   {
      hr = vtDispatch.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pSdoCollection);
      if ( SUCCEEDED(hr) )
      {
         hr = pSdoCollection->get__NewEnum(&pUnknown);
         if ( SUCCEEDED(hr) )
          {
            hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)ppEnum);
         }
      }
   }

   if ( FAILED(hr) )
      IASTracePrintf("Error in SDO Helper - SDOGetCollectionEnumerator() failed...");

   return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromCollection(
                      /*[in]*/ IEnumVARIANT*  pEnum,
                     /*[out]*/ ISdo**         ppSdo
                           )
{
   HRESULT         hr;
    DWORD         dwRetrieved = 1;
   _variant_t      vtDispatch;

   _ASSERT( NULL != pEnum && NULL == *ppSdo );
    hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
    _ASSERT( S_OK == hr || S_FALSE == hr );
   if ( S_OK == hr )
   {
        hr = vtDispatch.pdispVal->QueryInterface(IID_ISdo, (void**)ppSdo);
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO Helper - SDOGetNextObjectFromCollection() failed...");
   }

   return hr;
}



///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentFromCollection(
                        /*[in]*/ ISdo*  pSdoServer,
                       /*[in]*/ LONG   lCollectionPropertyId,
                       /*[in]*/ LONG   lComponentId,
                      /*[out]*/ ISdo** ppSdo
                              )
{
   HRESULT               hr;
   CComPtr<IEnumVARIANT>   pEnum;
   CComPtr<ISdo>         pSdo;
   LONG               ComponentId;

   do
   {
      hr = SDOGetCollectionEnumerator(
                               pSdoServer,
                               lCollectionPropertyId,
                               &pEnum
                              );
      if ( FAILED(hr) )
         break;

      hr = SDONextObjectFromCollection(pEnum,&pSdo);
      while( S_OK == hr )
      {
         hr = SDOGetComponentIdFromObject(
                                  pSdo,
                                  &ComponentId
                                 );
         if ( FAILED(hr) )
            break;

         if ( ComponentId == lComponentId )
         {
            pSdo.p->AddRef();
            *ppSdo = pSdo;
            break;
         }

         pSdo.Release();
         hr = SDONextObjectFromCollection(pEnum,&pSdo);
      }

      if ( S_OK != hr )
         hr = E_FAIL;

   } while ( FALSE );

   return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT   SDOConfigureComponentFromObject(
                         /*[in]*/ ISdo*         pSdo,
                        /*[in]*/ IIasComponent*   pComponent
                              )
{
   HRESULT   hr = E_FAIL;

   do
   {
      _ASSERT( NULL != pSdo && NULL != pComponent );

      CComPtr<IUnknown> pUnknown;
      hr = pSdo->get__NewEnum(&pUnknown);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - get__NewEnum() failed... %x", hr);
         break;
      }
      CComPtr<IEnumVARIANT> pEnumProperties;
      hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumProperties);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - QueryInterface(IID_IEnumVARIANT) failed... %x", hr);
         break;
      }

      LONG flags;
      LONG alias;
      _variant_t vtProperty;
      CComPtr<ISdoPropertyInfo> pSdoPropertyInfo;

      hr = SDONextPropertyFromClass(pEnumProperties, &pSdoPropertyInfo);
      while ( S_OK == hr )
      {
         hr = pSdoPropertyInfo->get_Flags(&flags);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - ISdoPropertyInfo::get_Flags() failed... %x", hr);
            break;
         }
         if ( SDO_PROPERTY_COMPONENT & flags )
         {
            hr = pSdoPropertyInfo->get_Alias(&alias);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - ISdoPropertyInfo::get_Alias() failed... %x", hr);
               break;
            }
            hr = pSdo->GetProperty(alias, &vtProperty);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - ISdo::GetProperty() failed... %x", hr);
               break;
            }
            hr = pComponent->PutProperty(alias, &vtProperty);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO - SDOConfigureComponentFromObject() - ISdo::PutProperty() failed... %x", hr);
               break;
            }
            vtProperty.Clear();
         }

         pSdoPropertyInfo.Release();
         hr = SDONextPropertyFromClass(pEnumProperties, &pSdoPropertyInfo);
      }
      if ( S_FALSE == hr )
         hr = S_OK;

   } while (FALSE);

   return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentIdFromObject(
                     /*[in]*/ ISdo*   pSdo,
                     /*[out]*/ PLONG   pComponentId
                           )
{
   _ASSERT( NULL != pSdo && NULL != pComponentId );

   HRESULT      hr;
   _variant_t   vtProperty;
   hr = pSdo->GetProperty(PROPERTY_COMPONENT_ID, &vtProperty);
   if ( SUCCEEDED(hr) )
   {
      _ASSERT( VT_I4 == V_VT(&vtProperty) );
      *pComponentId = V_I4(&vtProperty);
   }
   else
   {
      IASTracePrintf("Error in SDO Helper - SDOGetComponentIdFromObject() failed...");
   }

   return hr;
}


///////////////////////////////////////////////////////////////////
HRESULT SDOCreateComponentFromObject(
                      /*[in]*/ ISdo*           pSdo,
                     /*[out]*/ IIasComponent** ppComponent
                           )
{
   HRESULT      hr;
   _variant_t   vtProgId;
   CLSID      clsId;

   _ASSERT( NULL != pSdo && NULL == *ppComponent );

   hr = pSdo->GetProperty(PROPERTY_COMPONENT_PROG_ID, &vtProgId);
   if ( SUCCEEDED(hr) )
   {
      _ASSERT( VT_BSTR == V_VT(&vtProgId) );
      hr = CLSIDFromProgID(V_BSTR(&vtProgId), &clsId);
      if ( SUCCEEDED(hr) )
      {
         hr = CoCreateInstance(
                           clsId,
                                    NULL,
                            CLSCTX_INPROC_SERVER,
                              IID_IIasComponent,
                           (void**)ppComponent
                          );
      }
   }

   if ( FAILED(hr) )
      IASTracePrintf("Error in SDO Helper - SDOCreateComponentFromObject() failed...");

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetContainedObject(
                  /*[in]*/ BSTR              bstrObjectName,
                  /*[in]*/ IDataStoreObject*  pDSObject,
                 /*[out]*/ IDataStoreObject** ppDSObject
                         )
{
   CComPtr<IDataStoreContainer> pDSContainer;
   HRESULT hr = pDSObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainer);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO Schema - BuildClasses() - QueryInterface(1) failed...");
      return hr;
   }
   hr = pDSContainer->Item(bstrObjectName, ppDSObject);
   if ( FAILED(hr) )
      IASTracePrintf("Error in SDO Schema - BuildClasses() - Item('%ls') failed...", bstrObjectName);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetContainerEnumerator(
                     /*[in]*/ IDataStoreObject* pDSObject,
                    /*[out]*/ IEnumVARIANT** ppObjectEnumerator
                          )
{
   CComPtr<IDataStoreContainer> pDSContainer;
   HRESULT hr = pDSObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainer);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO - GetContainerEnumerator() - QueryInterface(IDataStoreContainer) returned %lx...", hr);
      return hr;
   }
   CComPtr<IUnknown> pUnknown;
   hr = pDSContainer->get__NewEnum(&pUnknown);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO - GetContainerEnumerator - get__NewEnum() returned %lx...", hr);
      return hr;
   }
   hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)ppObjectEnumerator);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO - GetContainerEnumerator() - QueryInterface(IID_IEnumVARIANT) returned %lx...",hr);
      return hr;
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromContainer(
                     /*[in]*/ IEnumVARIANT*      pEnumVariant,
                     /*[out]*/ IDataStoreObject** ppDSObject
                          )
{
   _variant_t vt;
   DWORD dwRetrieved = 1;
   HRESULT hr = pEnumVariant->Next(1, &vt, &dwRetrieved);
   if ( S_OK == hr )
   {
      hr = vt.pdispVal->QueryInterface(IID_IDataStoreObject,(void**)ppDSObject);
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - GetNextObjectFromContainer() - QueryInterface(IDataStoreObject) failed...");
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetObjectPropertyEnumerator(
                          /*[in]*/ IDataStoreObject* pDSObject,
                         /*[out]*/ IEnumVARIANT** ppPropertyEnumerator
                              )
{
   CComPtr<IUnknown> pUnknown;
   HRESULT hr = pDSObject->get__NewEnum(&pUnknown);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO Schema - GetObjectPropertyEnumerator() - get__NewEnum() failed...");
      return hr;
   }
   hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)ppPropertyEnumerator);
   if ( FAILED(hr) )
      IASTracePrintf("Error in SDO Schema -  GetObjectPropertyEnumerator() - QueryInterface(IID_IEnumVARIANT) failed...");

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextPropertyFromObject(
                    /*[in]*/ IEnumVARIANT*      pEnumVariant,
                   /*[out]*/ IDataStoreProperty** ppDSProperty
                          )
{
   _variant_t vt;
   DWORD dwRetrieved = 1;
   HRESULT hr = pEnumVariant->Next(1, &vt, &dwRetrieved);
   if ( S_OK == hr )
   {
      hr = vt.pdispVal->QueryInterface(IID_IDataStoreObject,(void**)ppDSProperty);
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - GetNextPropertyFromObject() - QueryInterface(IDataStoreProperty) failed...");
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetClassPropertyEnumerator(
                        /*[in]*/ CLASSPROPERTYSET ePropertySet,
                        /*[in]*/ ISdoClassInfo*   pSdoClassInfo,
                       /*[out]*/ IEnumVARIANT**   ppPropertyEnumerator
                               )
{
   CComPtr<IUnknown> pUnknown;
   HRESULT hr;

   if ( PROPERTY_SET_REQUIRED == ePropertySet )
   {
      hr = pSdoClassInfo->get_RequiredProperties(&pUnknown);
   }
   else
   {
      _ASSERT( PROPERTY_SET_OPTIONAL == ePropertySet );
      hr = pSdoClassInfo->get_OptionalProperties(&pUnknown);
   }

   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO Schema - GetClassPropertyEnumerator() - get__NewEnum() failed...");
      return hr;
   }

   hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)ppPropertyEnumerator);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO Schema -  GetClassPropertyEnumerator() - QueryInterface(IID_IEnumVARIANT) failed...");
      return hr;
   }

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextPropertyFromClass(
                   /*[in]*/ IEnumVARIANT*       pEnumVariant,
                  /*[out]*/ ISdoPropertyInfo** ppSdoPropertyInfo
                          )
{
   _variant_t vt;
   DWORD dwRetrieved = 1;
   HRESULT hr = pEnumVariant->Next(1, &vt, &dwRetrieved);
   if ( S_OK == hr )
   {
      hr = vt.punkVal->QueryInterface(IID_ISdoPropertyInfo,(void**)ppSdoPropertyInfo);
      if ( FAILED(hr) )
         IASTracePrintf("Error in SDO - GetNextPropertyFromClass() - QueryInterface(ISdoPropertyInfo) failed...");
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
BOOL SDOIsNameUnique(
           /*[in]*/ ISdoCollection*   pSdoCollection,
           /*[in]*/ VARIANT*         pName
                )
{
    // Get the data store containers enumerator
    //
   CComPtr<IUnknown> pUnknown;
    HRESULT hr = pSdoCollection->get__NewEnum(&pUnknown);
    if ( FAILED(hr) )
        return FALSE;

   CComPtr<IEnumVARIANT> pEnumVariant;
    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant);
    if ( FAILED(hr) )
    {
        IASTracePrintf("Error in SDO - IsNameUnique() - QueryInterface(IID_IEnumVARIANT) failed...");
        return FALSE;
    }

   CComPtr<ISdo> pSdo;
   _variant_t    vtName;

    hr = ::SDONextObjectFromCollection(pEnumVariant, &pSdo);
    while ( S_OK == hr )
   {
      hr = pSdo->GetProperty(PROPERTY_SDO_NAME, &vtName);
      if ( FAILED(hr) )
          break;

      if ( 0 == lstrcmpi(V_BSTR(pName), V_BSTR(&vtName) ) )
         break;

      vtName.Clear();
      pSdo.Release();

       hr = ::SDONextObjectFromCollection(pEnumVariant, &pSdo);
   }

   if ( S_FALSE == hr )
      return TRUE;
   else
      return FALSE;
}


//////////////////////////////////////////////////////////////////////////
HRESULT ValidateDNSName(
            /*[in]*/ VARIANT* pValue
                   )
{
   // Is it a BSTR?
   if (V_VT(pValue) != VT_BSTR) { return E_INVALIDARG; }

   // Is it dotted decimal?
   if (wcsspn(V_BSTR(pValue), L"0123456789.") == wcslen(V_BSTR(pValue)))
   {
      // If so, then make sure it can be converted.
      if (ias_inet_wtoh(V_BSTR(pValue)) == 0xffffffff)
      {
         return E_INVALIDARG;
      }
   }

   return S_OK;
}

#define SYSTEM_ROOT_REG_KEY      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define SYSTEM_ROOT_VALUE      L"SystemRoot"
#define LOG_FILE_DIR         L"\\system32\\LogFiles"

//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetLogFileDirectory(
                  /*[in]*/ LPCWSTR lpszComputerName,
                  /*[in]*/ DWORD   dwLogFileDirectorySize,
                  /*[out*/ PWCHAR  pLogFileDirectory
                        )
{
   _ASSERT( pLogFileDirectory != NULL && dwLogFileDirectorySize > 0 );

   HRESULT hr = E_FAIL;
   do
   {
      LONG   lResult = ERROR_SUCCESS;
      HKEY   hKeyRemote = HKEY_LOCAL_MACHINE;
      DWORD   dwSize = MAX_PATH;
      wchar_t szBuffer[MAX_PATH + 1];

      if ( lpszComputerName )
      {
         // Is lpszComputerName the name of the local machine?
         //
         GetComputerName(szBuffer, &dwSize);
         if ( lstrcmpi(szBuffer, lpszComputerName ) )
         {
            // Nope... we're attached to a remote computer so connect to the
            // remote machine's registry.
            //
            lResult = RegConnectRegistry(
                                   lpszComputerName,
                                   HKEY_LOCAL_MACHINE,
                                   &hKeyRemote
                                  );
         }
      }
      if ( ERROR_SUCCESS != lResult )
      {
         IASTracePrintf("Error in GetLogFileDirectory() - Could not attach to the remote registry..");
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      // Open the "CurrentVersion" key
      //
      CRegKey   CurVerKey;
      lResult = CurVerKey.Open(
                              hKeyRemote,
                             SYSTEM_ROOT_REG_KEY,
                            KEY_READ
                          );

      if ( ERROR_SUCCESS != lResult )
      {
         IASTracePrintf("Error in GetLogFileDirectory() - Could not open the 'system root' registry key..");
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }
      // Get the value of the "SystemRoot" Registry entry
      //
      dwSize = MAX_PATH;
      lResult = CurVerKey.QueryValue(
                                    szBuffer,
                                   (LPCTSTR)SYSTEM_ROOT_VALUE,
                                  &dwSize
                                );

      if ( ERROR_SUCCESS != lResult )
      {
         IASTracePrintf("Error in SDO Schema - SetDefaults() - Could not get the 'system root' registry value..");
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }
      // Now build the default log file directory path
      //
      if ( lstrlen(szBuffer) + lstrlen(LOG_FILE_DIR) >= dwLogFileDirectorySize )
      {
         IASTracePrintf("Error in GetLogFileDirectory() - system root directory path is too long..");
         hr = E_UNEXPECTED;
         break;
      }
         wsprintf(
              pLogFileDirectory,
              L"%s%s",
              szBuffer,
              LOG_FILE_DIR
            );
      hr = S_OK;

   } while ( FALSE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////

BEGIN_CLASSTOPROGID_MAP(SdoClassNameToProgID)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_ATTRIBUTE, SDO_PROG_ID_ATTRIBUTE)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_CLIENT, SDO_PROG_ID_CLIENT)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_CONDITION, SDO_PROG_ID_CONDITION)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_DICTIONARY, SDO_PROG_ID_DICTIONARY)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_PROFILE, SDO_PROG_ID_PROFILE)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_POLICY, SDO_PROG_ID_POLICY)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_SERVICE, SDO_PROG_ID_SERVICE)
//   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_USER, SDO_PROG_ID_USER)
   DEFINE_CLASSTOPROGID_ENTRY(SDO_CLASS_NAME_VENDOR, SDO_PROG_ID_VENDOR)
END_CLASSTOPROGID_MAP()

//////////////////////////////////////////////////////////////////////////////
LPWSTR GetDataStoreClass(
             /*[in]*/ LPCWSTR lpszSdoProgId
                    )
{
   PCLASSTOPROGID   pClassToProgId = SdoClassNameToProgID;
   while ( pClassToProgId->pDatastoreClass )
   {
      if ( 0 == lstrcmp(pClassToProgId->pSdoProgId, lpszSdoProgId) )
         return pClassToProgId->pDatastoreClass;
      pClassToProgId++;
   }
   return SDO_CLASS_NAME_COMPONENT;
}


HRESULT SDOGetProductLimits(
           IUnknown* source,
           IAS_PRODUCT_LIMITS* result
           ) throw ()
{
   if ((source == 0) || (result == 0))
   {
      return E_POINTER;
   }

   CComPtr<IASProductLimits> limits;
   HRESULT hr = source->QueryInterface(
                           __uuidof(IASProductLimits),
                           reinterpret_cast<void**>(&limits)
                           );
   if (SUCCEEDED(hr))
   {
      hr = limits->get_Limits(result);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdohelperfuncs.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdohelperfuncs.h
//
// Project:     Everest
//
// Description: Helper Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 6/08/98      TLP    Initial Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __INC_IAS_SDO_HELPER_FUNCS_H
#define __INC_IAS_SDO_HELPER_FUNCS_H

#include <ias.h>
#include <iaslimits.h>
#include <sdoiaspriv.h>
#include <winsock2.h>

//////////////////////////////////////////////////////////////////////////////
//                  SDO HELPER FUNCTIONS
//
// TODO: Wrap these in a seperate name space
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// SDO Collection Helpers
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
HRESULT SDOGetCollectionEnumerator(
                     /*[in]*/   ISdo*         pSdo,
                     /*[in]*/   LONG         lPropertyId,
                    /*[out]*/ IEnumVARIANT** ppEnum
                          );

///////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromCollection(
                     /*[in]*/ IEnumVARIANT*  pEnum,
                     /*[out]*/ ISdo**         ppSdo
                           );

///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentFromCollection(
                        /*[in]*/ ISdo*  pSdoService,
                       /*[in]*/ LONG   lCollectionPropertyId,
                       /*[in]*/ LONG   lComponentId,
                      /*[out]*/ ISdo** ppSdo
                              );


/////////////////////////////////////////////////////////////////////////////
// Core Helpers
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
HRESULT   SDOConfigureComponentFromObject(
                         /*[in]*/ ISdo*         pSdo,
                        /*[in]*/ IIasComponent*   pComponent
                              );

///////////////////////////////////////////////////////////////////
HRESULT SDOGetComponentIdFromObject(
                     /*[in]*/ ISdo*   pSdo,
                     /*[out]*/ PLONG   pComponentId
                           );

///////////////////////////////////////////////////////////////////
HRESULT SDOCreateComponentFromObject(
                      /*[in]*/ ISdo*           pSdo,
                     /*[out]*/ IIasComponent** ppComponent
                           );


/////////////////////////////////////////////////////////////////////////////
// Data Store Helpers
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetContainedObject(
                  /*[in]*/ BSTR               bstrObjectName,
                  /*[in]*/ IDataStoreObject*  pDSObject,
                 /*[out]*/ IDataStoreObject** ppDSObject
                         );

//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetContainerEnumerator(
                     /*[in]*/ IDataStoreObject* pDSObject,
                    /*[out]*/ IEnumVARIANT**    ppObjectEnumerator
                          );

//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextObjectFromContainer(
                     /*[in]*/ IEnumVARIANT*      pEnumVariant,
                     /*[out]*/ IDataStoreObject** ppDSObject
                          );

//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetObjectPropertyEnumerator(
                          /*[in]*/ IDataStoreObject* pDSObject,
                         /*[out]*/ IEnumVARIANT**    ppPropertyEnumerator
                              );

//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextPropertyFromObject(
                    /*[in]*/ IEnumVARIANT*        pEnumVariant,
                   /*[out]*/ IDataStoreProperty** ppDSProperty
                          );


/////////////////////////////////////////////////////////////////////////////
// Schema Helpers
/////////////////////////////////////////////////////////////////////////////

typedef enum _CLASSPROPERTYSET
{
   PROPERTY_SET_REQUIRED,
   PROPERTY_SET_OPTIONAL

}   CLASSPROPERTYSET;

//////////////////////////////////////////////////////////////////////////////
HRESULT SDOGetClassPropertyEnumerator(
                     /*[in]*/ CLASSPROPERTYSET ePropertySet,
                     /*[in]*/ ISdoClassInfo*   pSdoClassInfo,
                    /*[out]*/ IEnumVARIANT**   ppPropertyEnumerator
                            );

//////////////////////////////////////////////////////////////////////////////
HRESULT SDONextPropertyFromClass(
                   /*[in]*/ IEnumVARIANT*      pEnumVariant,
                  /*[out]*/ ISdoPropertyInfo** ppSdoPropertyInfo
                          );

/////////////////////////////////////////////////////////////////////////////
// Misc Helpers
/////////////////////////////////////////////////////////////////////////////

HRESULT SDOGetLogFileDirectory(
                  /*[in]*/ LPCWSTR lpszComputerName,
                  /*[in]*/ DWORD   dwLogFileDirectorySize,
                  /*[out*/ PWCHAR  pLogFileDirectory
                        );

//////////////////////////////////////////////////////////////////////////////
BOOL SDOIsNameUnique(
           /*[in]*/ ISdoCollection*   pSdoCollection,
           /*[in]*/ VARIANT*         pName
                );


/////////////////////////////////////////////////////////////////////////////
HRESULT ValidateDNSName(
            /*[in]*/ VARIANT* pAddressValue
                  );


///////////////////////////////////////////////////////////////////////////////
// Data Store Class to SDO Prog ID Map
///////////////////////////////////////////////////////////////////////////////

typedef struct _CLASSTOPROGID
{
   LPWSTR  pDatastoreClass;
   LPWSTR   pSdoProgId;

} CLASSTOPROGID, *PCLASSTOPROGID;


#define      BEGIN_CLASSTOPROGID_MAP(x) \
   static CLASSTOPROGID   x[] = {

#define      DEFINE_CLASSTOPROGID_ENTRY(x,y) \
      {                           \
         x,                        \
         y                        \
      },

#define      END_CLASSTOPROGID_MAP() \
      {                     \
         NULL,               \
         NULL               \
      }                     \
   };

///////////////////////////////////////////////////////////////////////////////
LPWSTR GetDataStoreClass(
             /*[in]*/ LPCWSTR lpszSdoProgId
                   );


HRESULT SDOGetProductLimits(
           IUnknown* source,
           IAS_PRODUCT_LIMITS* result
           ) throw ();

#endif // __INC_IAS_SDO_HELPER_FUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoias.cpp ===
// sdoias.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f sdoiasps.mk in the project directory.

#include "stdafx.h"
#include <ias.h>
#include <initguid.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include "sdomachine.h"
#include "sdoservice.h"
#include "newop.cpp"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SdoMachine, CSdoMachine)
	OBJECT_ENTRY(CLSID_SdoService, CSdoService)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
       	_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);
    HRESULT hres = S_OK;
    if ( SUCCEEDED(hr) )
    {
        hr = _Module.RegisterTypeLib(L"\\1");
        if (FAILED(hr))
        {
            hres = hr;
        }
        hr = _Module.RegisterTypeLib(L"\\2");
        if (FAILED(hr))
        {
            hres = hr;
        }
    }
    else
    {
        hres = hr;
    }
    return hres;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdomachine.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdomachine.cpp
//
// Project:      Everest
//
// Description:   SDO Machine Implementation
//
// Author:      TLP 9/1/98
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ias.h>
#include <lm.h>
#include <dsrole.h>
#include "sdomachine.h"
#include "sdofactory.h"
#include "sdo.h"
#include "dspath.h"
#include "sdodictionary.h"
#include "sdoschema.h"
#include "activeds.h"

HRESULT
WINAPI
IASGetLDAPPathForUser(
    PCWSTR computerName,
    PCWSTR userName,
    BSTR* path
    ) throw ()
{
   HRESULT hr;

   // Check the pointers.
   if (!computerName || !userName || !path) { return E_POINTER; }

   // Check the string lengths, so we don't have to worry about overflow.
   if (wcslen(computerName) > MAX_PATH || wcslen(userName) > MAX_PATH)
   { return E_INVALIDARG; }

   // Initialize the out parameter.
   *path = NULL;

   // Form the LDAP path for the target computer.
   WCHAR root[8 + MAX_PATH];
   wcscat(wcscpy(root, L"LDAP://"), computerName);

   // Get the IDirectorySearch interface.
   CComPtr<IDirectorySearch> search;

   // tperraut 453050
   hr = ADsOpenObject(
            root,
            NULL,
            NULL,
            ADS_SECURE_AUTHENTICATION |
            ADS_USE_SIGNING |
            ADS_USE_SEALING,
            __uuidof(IDirectorySearch),
            (PVOID*)&search
            );
   if (FAILED(hr)) { return hr; }

   // Form the search filter.
   WCHAR filter[18 + MAX_PATH];
   wcscat(wcscat(wcscpy(filter, L"(sAMAccountName="), userName), L")");

   // Execute the search.
   PWSTR attrs[] = { L"distinguishedName" };
   ADS_SEARCH_HANDLE result;
   hr = search->ExecuteSearch(
                    filter,
                    attrs,
                    1,
                    &result
                    );
   if (FAILED(hr)) { return hr; }

   // Get the first row.
   hr = search->GetFirstRow(result);
   if (SUCCEEDED(hr))
   {
      // Get the column containing the distinguishedName.
      ADS_SEARCH_COLUMN column;
      hr = search->GetColumn(result, attrs[0], &column);
      if (SUCCEEDED(hr))
      {
         // Sanity check the struct.
         if (column.dwADsType == ADSTYPE_DN_STRING && column.dwNumValues)
         {
            // Extract the DN.
            PCWSTR dn = column.pADsValues[0].DNString;

            // Get the Pathname object.
            IADsPathname* pathname;
            hr = CoCreateInstance(
                     __uuidof(Pathname),
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     __uuidof(IADsPathname),
                     (PVOID*)&pathname
                     );

            if (SUCCEEDED(hr))
            {
               do
               {
                  /////////
                  // Build the ADSI path.
                  /////////

                  hr = pathname->Set(L"LDAP", ADS_SETTYPE_PROVIDER);
                  if (FAILED(hr)) { break; }

                  hr = pathname->Set((PWSTR)computerName, ADS_SETTYPE_SERVER);
                  if (FAILED(hr)) { break; }

                  hr = pathname->Set((PWSTR)dn, ADS_SETTYPE_DN);
                  if (FAILED(hr)) { break; }

                  hr = pathname->Retrieve(ADS_FORMAT_WINDOWS, path);

               } while (FALSE);

               pathname->Release();
            }
         }
         else
         {
            // We got back a bogus ADS_SEARCH_COLUMN struct.
            hr = E_FAIL;
         }

         // Free the column data.
         search->FreeColumn(&column);
      }
   }

   // Close the search handle.
   search->CloseSearchHandle(result);

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
CSdoMachine::CSdoMachine()
: m_fAttached(false),
  m_fSchemaInitialized(false),
  m_pSdoSchema(NULL),
  m_pSdoDictionary(NULL),
  dsType(Directory_Unknown)
{
   memset(&m_Limits, 0, sizeof(m_Limits));
}


//////////////////////////////////////////////////////////////////////////////
CSdoMachine::~CSdoMachine()
{
   if ( m_fAttached )
   {
      m_dsIAS.Disconnect();
      m_dsAD.Disconnect();
      m_pSdoSchema->Release();
        if ( m_pSdoDictionary )
         m_pSdoDictionary->Release();
      IASUninitialize();
   }
}

//////////////////////
// ISdoMachine Methods

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::Attach(
                    /*[in]*/ BSTR computerName
                             )
{
    CSdoLock theLock(*this);

   _ASSERT( ! m_fAttached );
   if ( m_fAttached )
      return E_FAIL;

   HRESULT hr = E_FAIL;

   try
   {
      if ( computerName )
         IASTracePrintf("Machine SDO is attempting to attach to computer: '%ls'...", computerName);
      else
         IASTracePrintf("Machine SDO is attempting to attach to the local computer...");

      IASTracePrintf("Machine SDO is initializing the IAS support services...");
      if ( IASInitialize() )
      {
         hr = m_dsIAS.Connect(computerName, NULL, NULL);
         if ( SUCCEEDED(hr) )
         {
            DWORD error = IASGetProductLimits(computerName, &m_Limits);
            if (error == NO_ERROR)
            {
               IASTracePrintf("Machine SDO is creating the SDO schema...");
               hr = CreateSDOSchema();
               if ( SUCCEEDED(hr) )
               {

                  IASTracePrintf("Machine SDO has successfully attached to computer: '%ls'...",m_dsIAS.GetServerName());
                  m_fAttached = true;
               }
               else
               {
                  m_dsIAS.Disconnect();
                  IASUninitialize();
               }
            }
            else
            {
               hr = HRESULT_FROM_WIN32(error);
               m_dsIAS.Disconnect();
               IASUninitialize();
            }
         }
         else
         {
            IASTracePrintf("Error in Machine SDO - Attach() - Could not connect to IAS data store...");
         }
      }
      else
      {
         IASTracePrintf("Error in Machine SDO - Attach() - Could not initialize IAS support services...");
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in Machine SDO - Attach() - Caught unknown exception...");
      hr = E_UNEXPECTED;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetDictionarySDO(
                               /*[out]*/ IUnknown** ppDictionarySdo
                                      )
{
    CSdoLock theLock(*this);

   IASTracePrintf("Machine SDO is retrieving the Dictionary SDO...");

    HRESULT hr = S_OK;

   try
   {
      do
      {
         // Check preconditions
         //
          _ASSERT( m_fAttached );
         if ( ! m_fAttached )
         {
            hr = E_FAIL;
            break;
         }

         _ASSERT( NULL != ppDictionarySdo );
         if ( NULL == ppDictionarySdo )
         {
            hr = E_POINTER;
            break;
         }

         // The dictionary is a singleton...
         //
         if (NULL == m_pSdoDictionary)
         {
            hr = InitializeSDOSchema();
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetDictionarySDO() - Could not initialize the SDO schema...");
               break;
            }

            // Create the Dictionary SDO
            CComPtr<SdoDictionary> pSdoDictionary;
            hr = SdoDictionary::createInstance(
                                    m_dsIAS.GetConfigPath(),
                                    !m_dsIAS.IsRemoteServer(),
                                    (SdoDictionary**)&m_pSdoDictionary
                                    );
            if (FAILED(hr))
            {
               IASTraceFailure("SdoDictionary::createInstance", hr);
               break;
            }
         }

         // Return the dictionary interface to the caller
         //
         (*ppDictionarySdo = m_pSdoDictionary)->AddRef();

      } while ( FALSE );
   }
   catch(...)
   {
      IASTracePrintf("Error in Machine SDO - GetDictionarySDO() - Caught unknown exception...");
      hr = E_UNEXPECTED;
   }

   return hr;
}

const wchar_t g_IASService[] = L"IAS";
const wchar_t g_RASService[] = L"RemoteAccess";
const wchar_t g_Sentinel[]   = L"Sentinel";

LPCWSTR   CSdoMachine::m_SupportedServices[MACHINE_MAX_SERVICES] = {
      g_IASService,
      g_RASService,
      g_Sentinel
};

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetServiceSDO(
                            /*[in]*/ IASDATASTORE dataStore,
                           /*[in]*/ BSTR         serviceName,
                          /*[out]*/ IUnknown**   ppServiceSdo
                                  )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT(
           ( DATA_STORE_LOCAL == dataStore || DATA_STORE_DIRECTORY == dataStore ) &&
          NULL != serviceName &&
          NULL != ppServiceSdo
         );

   if ( ( DATA_STORE_LOCAL != dataStore && DATA_STORE_DIRECTORY != dataStore ) ||
       NULL == serviceName ||
       NULL == ppServiceSdo
      )
   {
      return E_INVALIDARG;
   }

   IASTracePrintf("Machine SDO is attempting to retrieve the Service SDO for service: %ls...", serviceName);

   int i;
   for ( i = 0; i < MACHINE_MAX_SERVICES; i++ )
   {
      if ( ! lstrcmp(serviceName, m_SupportedServices[i]) )
      {
         break;
      }
      else
      {
         if ( ! lstrcmp(m_SupportedServices[i], g_Sentinel ) )
            return E_INVALIDARG;
      }
   }

   HRESULT hr = E_INVALIDARG;

   try
   {
      do
      {
         hr = InitializeSDOSchema();
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in Machine SDO - GetServiceSDO() - Could not initialize the SDO schema...");
            break;
         }

         CComBSTR bstrServiceName(DS_OBJECT_SERVICE);
         if (!bstrServiceName)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         CComPtr<IDataStoreObject> pDSObject;
         hr = (m_dsIAS.GetDSRootContainer())->Item(bstrServiceName, &pDSObject);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in Machine SDO - GetServiceSDO() - Could not locate IAS service data store...");
            break;
         }
         CComPtr<ISdo> pSdoService;
         pSdoService.p = ::MakeSDO(
                             serviceName,
                             SDO_PROG_ID_SERVICE,
                             static_cast<ISdoMachine*>(this),
                             pDSObject,
                             NULL,
                             false
                            );
         if ( NULL == pSdoService.p )
         {
            IASTracePrintf("Error in Machine SDO - GetServiceSDO() - MakeSDO() failed...");
            hr = E_FAIL;
            break;
         }
         hr = pSdoService->QueryInterface(IID_IDispatch, (void**)ppServiceSdo);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in Machine SDO - GetServiceSDO() - QueryInterface(IDispatch) failed...");
            break;
         }

      } while ( FALSE );
   }
   catch(...)
   {
      IASTracePrintf("Error in Machine SDO - GetServiceSDO() - Caught unknown exception...");
      hr = E_UNEXPECTED;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////

const wchar_t DOWNLEVEL_NAME[] = L"downlevel";

STDMETHODIMP CSdoMachine::GetUserSDO(
                         /*[in]*/ IASDATASTORE  eDataStore,
                         /*[in]*/ BSTR          bstrUserName,
                        /*[out]*/ IUnknown**    ppUserSdo
                                )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT(
           ( DATA_STORE_LOCAL == eDataStore || DATA_STORE_DIRECTORY == eDataStore ) &&
          NULL != bstrUserName &&
          NULL != ppUserSdo
          );

   if ( ( DATA_STORE_LOCAL != eDataStore && DATA_STORE_DIRECTORY != eDataStore ) ||
       NULL == bstrUserName ||
       NULL == ppUserSdo
      )
      return E_INVALIDARG;

   HRESULT hr = E_FAIL;

   // Map local users to the DS if we're attached to a machine with
   // a directory.
   if (eDataStore == DATA_STORE_LOCAL && hasDirectory())
   {
      eDataStore = DATA_STORE_DIRECTORY;
   }

   // If we're connecting to a directory and the username doesn't begin with
   // "LDAP://", then we'll assume it's a SAM account name.
   BSTR ldapPath = NULL;
   if (eDataStore == DATA_STORE_DIRECTORY &&
       wcsncmp(bstrUserName, L"LDAP://", 7))
   {
      hr = IASGetLDAPPathForUser(
               m_dsIAS.GetServerName(),
               bstrUserName,
               &ldapPath
               );
      if (FAILED(hr)) { return hr; }

      bstrUserName = ldapPath;
   }

   IASTracePrintf("Machine SDO is attempting to retrieve the RAS User SDO for user: %ls...", bstrUserName);

   ISdo*   pSdoUser = NULL;

   try
   {
      do
      {
         // Get the IDataStoreObject interface for the new User SDO.
         // We'll use the IDataStoreObject interface to read/write User SDO properties.
         //
         bool                 fUseDownLevelAPI = false;
         bool                 fUseNetAPI = true;
         CComPtr<IDataStoreObject> pDSObject;
         _variant_t              vtSAMAccountName;

         if ( DATA_STORE_DIRECTORY == eDataStore )
         {
            // Make sure we're connected to the directory
            //
            if ( ! m_dsAD.IsConnected() )
            {
               hr = m_dsAD.Connect(m_dsIAS.GetServerName(), NULL, NULL);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not connect to the directory data store...");
                  break;
               }
            }

            // Make sure it's initialized.
            hr = m_dsAD.InitializeDS();
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not initialize the directory data store...");
               break;
            }

            // Get the user object from the directory
            //
            hr = (m_dsAD.GetDSRoot())->OpenObject(bstrUserName, &pDSObject);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not retrieve user object from DS...");
               break;
            }
            // If we're connected to a dc in a mixed domain we'll need to first get the users
            // SAM account name from the user object in the active directory and then treat the
            // GetUserSDO() call as if the caller specified DATA_STORE_LOCAL. We also use
            // downlevel APIs (SAM) because its a mixed domain.
            //
            if ( m_dsAD.IsMixedMode() )
            {
               IASTracePrintf("Machine SDO - GetUserSDO() - Current DC (Server) %ls is in a mixed mode domain...", m_dsAD.GetServerName());
               hr = pDSObject->GetValue(IAS_NTDS_SAM_ACCOUNT_NAME, &vtSAMAccountName);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Server SDO - GetUserSDO() - Could not retrieve users SAM account name...");
                  break;
               }
               bstrUserName = V_BSTR(&vtSAMAccountName);
               fUseDownLevelAPI = true;
               pDSObject.Release();
               IASTracePrintf("Server SDO - GetUserSDO() - User's SAM account name is: %ls...", (LPWSTR)bstrUserName);
            }
            else
            {
               // Use the directory data store object for all subsequent property read/write
               // operations on this User SDO.
               //
               IASTracePrintf("Server SDO - GetUserSDO() - Using active directory for user properties...");
               fUseNetAPI = false;
            }
         }
         if ( fUseNetAPI )
         {
            // Create the net data store and aquire the data store object interfaces
            // we'll use to complete the GetUserSDO() operation
            //
            CComPtr<IDataStore2> pDSNet;
            hr = CoCreateInstance(
                        __uuidof(NetDataStore),
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDataStore2,
                        (void**)&pDSNet
                      );
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - CoCreateInstance(NetDataStore) failed...");
               break;
            }

            hr = pDSNet->Initialize(NULL, NULL, NULL);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not initialize net data store...");
               break;
            }

            CComPtr<IDataStoreObject> pDSRootObject;
            hr = pDSNet->get_Root(&pDSRootObject);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not get Root object from net data store...");
               break;
            }

            CComPtr<IDataStoreContainer> pDSContainer;
            hr = pDSRootObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainer);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - QueryInterface(IID_IDataStoreContainer) failed...");
               break;
            }

            // Get the name of the attached computer and use it to aquire a "Server"
            // (machine) object from the data store.
            //
            CComPtr<IDataStoreObject> pDSObjectMachine;
            if ( fUseDownLevelAPI )
            {
               _bstr_t bstrServerName = m_dsAD.GetServerName();
               IASTracePrintf("Machine SDO - GetUserSDO() - Using server %ls with downlevel APIs...", (LPWSTR)bstrServerName);
               hr = pDSContainer->Item(bstrServerName, &pDSObjectMachine);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not obtain server object from net data store...");
                  break;
               }

               _bstr_t bstrDownLevel = DOWNLEVEL_NAME;
               _variant_t vtDownLevel;
               V_BOOL(&vtDownLevel) = VARIANT_TRUE;
               V_VT(&vtDownLevel) = VT_BOOL;
               hr = pDSObjectMachine->PutValue(bstrDownLevel, &vtDownLevel);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not set downlevel data store mode...");
                  break;
               }
            }
            else
            {
               _bstr_t bstrServerName = m_dsIAS.GetServerName();
               IASTracePrintf("Machine SDO - GetUserSDO() - Using server %ls with Net APIs...", (LPWSTR)bstrServerName);
               hr = pDSContainer->Item(bstrServerName, &pDSObjectMachine);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not obtain server object from data store...");
                  break;
               }
            }
            pDSContainer.Release();

            // Get "User" object from the "Server" object. We'll use the "User" object in
            // all subsequent read/write operations on the User SDO.
            //
            hr = pDSObjectMachine->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainer);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - QueryInterface(IID_IDataStoreContainer) failed...");
               break;
            }
            hr = pDSContainer->Item(bstrUserName, &pDSObject);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - Could not obtain user object from data store...");
               break;
            }
         }
         // Create and initialize the User SDO
         //
         pSdoUser = ::MakeSDO(
                         NULL,
                         SDO_PROG_ID_USER,
                         static_cast<ISdoMachine*>(this),
                         pDSObject,
                         NULL,
                         false
                        );
         if ( NULL == pSdoUser )
         {
            IASTracePrintf("Error in Machine SDO - GetUserSDO() - MakeSDO() failed...");
            hr = E_FAIL;
         }
         else
         {
            CComPtr<IDispatch>   pSdoDispatch;
            hr = pSdoUser->QueryInterface(IID_IDispatch, (void**)&pSdoDispatch);
            if ( FAILED(hr) )
               IASTracePrintf("Error in Machine SDO - GetUserSDO() - QueryInterface(IDispatch) failed...");
            else
               (*ppUserSdo = pSdoDispatch)->AddRef();
         }
      }
      while ( FALSE);
   }
    catch(...)
   {
      IASTracePrintf("Error in Server SDO - GetUserSDO() - Caught unknown exception...");
      hr = E_FAIL;
   }

   if ( pSdoUser )
      pSdoUser->Release();

   if (ldapPath) { SysFreeString(ldapPath); }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetOSType(
                        /*[out]*/ IASOSTYPE* eOSType
                              )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT( NULL != eOSType );
   if ( NULL == eOSType )
      return E_INVALIDARG;

    // Get the OS info now
    //
    HRESULT hr = m_objServerInfo.GetOSInfo (
                                          (LPWSTR)m_dsIAS.GetServerName(),
                                 eOSType
                                 );
    if ( FAILED (hr) )
        IASTracePrintf("Error in Machine SDO - GetOSType() failed with error: %lx...", hr);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetDomainType(
                             /*[out]*/ IASDOMAINTYPE* eDomainType
                                 )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT( NULL != eDomainType );
   if ( NULL == eDomainType )
      return E_INVALIDARG;

    HRESULT hr = m_objServerInfo.GetDomainInfo (
                                             OBJECT_TYPE_COMPUTER,
                                          (LPWSTR)m_dsIAS.GetServerName(),
                                       eDomainType
                                    );
    if (FAILED (hr))
        IASTracePrintf("Error in Machine SDO - GetDomainType() - failed with error: %lx...", hr);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::IsDirectoryAvailable(
                                    /*[out]*/ VARIANT_BOOL* boolDirectoryAvailable
                                      )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT( NULL != boolDirectoryAvailable );
   if ( NULL == boolDirectoryAvailable )
      return E_INVALIDARG;

   *boolDirectoryAvailable = VARIANT_FALSE;
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetAttachedComputer(
                             /*[out]*/ BSTR* bstrComputerName
                                  )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT( NULL != bstrComputerName );
   if ( NULL == bstrComputerName )
      return E_INVALIDARG;

   *bstrComputerName = SysAllocString(m_dsIAS.GetServerName());

   if ( NULL != *bstrComputerName )
      return S_OK;
   else
      return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoMachine::GetSDOSchema(
                       /*[out]*/ IUnknown** ppSDOSchema
                              )
{
    CSdoLock theLock(*this);

   _ASSERT( m_fAttached );
   if ( ! m_fAttached )
      return E_FAIL;

   _ASSERT( NULL != ppSDOSchema );
   if ( NULL == ppSDOSchema )
      return E_INVALIDARG;

   (*ppSDOSchema = m_pSdoSchema)->AddRef();

   return S_OK;
}


STDMETHODIMP CSdoMachine::get_Limits(IAS_PRODUCT_LIMITS* pVal)
{
   if (pVal == 0)
   {
      return E_POINTER;
   }
   *pVal = m_Limits;
   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Private member functions

///////////////////////////////////////////////////////////////////////////////
HRESULT CSdoMachine::CreateSDOSchema()
{
   auto_ptr<SDO_SCHEMA_OBJ> pSchema (new SDO_SCHEMA_OBJ);
   HRESULT hr = pSchema->Initialize(NULL);
   if ( SUCCEEDED(hr) )
      m_pSdoSchema = dynamic_cast<ISdoSchema*>(pSchema.release());
   return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CSdoMachine::InitializeSDOSchema()
{
   HRESULT hr = S_OK;
   if ( ! m_fSchemaInitialized )
   {
      // First initialize the IAS data store
      //
      hr = m_dsIAS.InitializeDS();
      if ( SUCCEEDED(hr) )
      {
         // Get the root data store object for the SDO schema
         //
         CComPtr<IDataStoreContainer> pDSRootContainer = m_dsIAS.GetDSRootContainer();
         _bstr_t   bstrSchemaName = SDO_SCHEMA_ROOT_OBJECT;
         CComPtr<IDataStoreObject> pSchemaDataStore;
         hr = pDSRootContainer->Item(bstrSchemaName, &pSchemaDataStore);
         if ( SUCCEEDED(hr) )
         {
            // Initialize the SDO schema from the SDO schema data store
            //
            PSDO_SCHEMA_OBJ pSchema = dynamic_cast<PSDO_SCHEMA_OBJ>(m_pSdoSchema);
            hr = pSchema->Initialize(pSchemaDataStore);
            if ( SUCCEEDED(hr) )
               m_fSchemaInitialized = true;
         }
         else
         {
            IASTracePrintf("Error in Machine SDO - InitializeSDOSchema() - Could not locate schema data store...");
         }
      }
      else
      {
         IASTracePrintf("Error in Machine SDO - InitializeSDOSchema() - Could not initialize the IAS data store...");
      }
   }
   return hr;
}

// Returns TRUE if the attached machine has a DS.
BOOL CSdoMachine::hasDirectory() throw ()
{
   if (dsType == Directory_Unknown)
   {
      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC info;
      DWORD error = DsRoleGetPrimaryDomainInformation(
                        m_dsIAS.GetServerName(),
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE*)&info
                        );
      if (error == NO_ERROR)
      {
         if (info->Flags & DSROLE_PRIMARY_DS_RUNNING)
         {
            dsType = Directory_Available;
         }
         else
         {
            dsType = Directory_None;
         }

         NetApiBufferFree(info);
      }
   }

   return dsType == Directory_Available;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdomachine.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdomachine.h
//
// Project:      Everest
//
// Description:   SDO Machine Class Declaration
//
// Author:      TLP 9/1/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef _INC_SDO_MACHINE_H_
#define _INC_SDO_MACHINE_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "dsconnection.h"
#include "sdoserverinfo.h"

//////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CSdoMachine :
   public CComObjectRootEx<CComMultiThreadModel>,
   public CComCoClass<CSdoMachine,&CLSID_SdoMachine>,
   public IDispatchImpl<ISdoMachine, &IID_ISdoMachine, &LIBID_SDOIASLib>,
   public IASProductLimits,
   private IASTraceInitializer
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoMachine)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY(ISdoMachine)
   COM_INTERFACE_ENTRY_IID(__uuidof(IASProductLimits), IASProductLimits)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CSdoMachine)
DECLARE_REGISTRY_RESOURCEID(IDR_SdoMachine)

    CSdoMachine();
   ~CSdoMachine();

   //////////////////////
   // ISdoMachine Methods

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(Attach)(
             /*[in]*/ BSTR computerName
                  );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetDictionarySDO)(
                   /*[out]*/ IUnknown** ppDictionarySdo
                           );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetServiceSDO)(
                 /*[in]*/ IASDATASTORE dataStore,
                /*[in]*/ BSTR         serviceName,
               /*[out]*/ IUnknown**   ppServiceSdo
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetUserSDO)(
              /*[in]*/ IASDATASTORE  dataStore,
              /*[in]*/ BSTR          userName,
             /*[out]*/ IUnknown**    ppUserSdo
                     );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD (GetOSType)(
              /*[out]*/ IASOSTYPE* eOSType
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD (GetDomainType)(
                   /*[out]*/ IASDOMAINTYPE* DomainType
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD (IsDirectoryAvailable)(
                          /*[out]*/ VARIANT_BOOL* boolDirectoryAvailable
                            );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD (GetAttachedComputer)(
                      /*[out]*/ BSTR* bstrComputerName
                             );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD (GetSDOSchema)(
               /*[out]*/ IUnknown** ppSDOSchema
                        );

   // IASProductLimits.
   STDMETHOD(get_Limits)(IAS_PRODUCT_LIMITS* pVal);

private:

   typedef enum { MACHINE_MAX_SERVICES = 3 };

   CSdoMachine(const CSdoMachine&);
   CSdoMachine& operator = (CSdoMachine&);

   //////////////////////////////////////////////////////////////////////////////
   HRESULT CreateSDOSchema(void);

   //////////////////////////////////////////////////////////////////////////////
   HRESULT InitializeSDOSchema(void);

   // Returns TRUE if the attached machine has a DS.
   BOOL hasDirectory() throw ();

   // Attach status
   //
   bool            m_fAttached;

   // Schema initialization state (lazy initialization)
   //
   bool            m_fSchemaInitialized;

   // SDO Schema
   //
   ISdoSchema*         m_pSdoSchema;

    // IDispatch interface to dictionary SDO
    //
    IUnknown*           m_pSdoDictionary;

   // IAS data store connection
   //
   CDsConnectionIAS   m_dsIAS;

   // Directory data store connection
   //
   CDsConnectionAD      m_dsAD;

    //  Information about attached computer
    //
    CSdoServerInfo      m_objServerInfo;

    enum DirectoryType
    {
       Directory_Unknown,
       Directory_None,
       Directory_Available
    };

    DirectoryType dsType;

    IAS_PRODUCT_LIMITS m_Limits;

   //  Supported services
   //
   static LPCWSTR      m_SupportedServices[MACHINE_MAX_SERVICES];
};


#endif // _INC_SDO_MACHINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdopipemgr.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdopipemgr.h
//
// SYNOPSIS
//
//    Declares the class PipelineMgr.
//
// MODIFICATION HISTORY
//
//    02/03/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDOPIPEMGR_H
#define SDOPIPEMGR_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <vector>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PipelineMgr
//
///////////////////////////////////////////////////////////////////////////////
class PipelineMgr
{
public:
   _COM_SMARTPTR_TYPEDEF(IIasComponent, __uuidof(IIasComponent));

   HRESULT Initialize(ISdo* pSdoService) throw ();
   HRESULT Configure(ISdo* pSdoService) throw ();
   void Shutdown() throw ();

   HRESULT GetPipeline(IRequestHandler** handler) throw ();

private:
   typedef std::vector<ComponentPtr>::iterator ComponentIterator;

   IIasComponentPtr pipeline;            // The pipeline.
   std::vector<ComponentPtr> components; // Handlers configured by the SDOs
};

//////////
// Links various SDO objects to handler properties.
//////////
HRESULT
WINAPI
LinkHandlerProperties(
    ISdo* pSdoService,
    IDataStoreObject* pDsObject
    ) throw ();

#endif // SDOPIPEMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdopipemgr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdopipemgr.cpp
//
//
// SYNOPSIS
//
//    Defines the class PipelineMgr.
//
// MODIFICATION HISTORY
//
//    02/03/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <sdocomponentfactory.h>
#include <sdohelperfuncs.h>
#include <sdopipemgr.h>

#define IAS_PROVIDER_MICROSOFT_RADIUS_PROXY  8
#define IAS_PROVIDER_MICROSOFT_PROXY_POLICY  5

_COM_SMARTPTR_TYPEDEF(ISdo, __uuidof(ISdo));
_COM_SMARTPTR_TYPEDEF(ISdoCollection, __uuidof(ISdoCollection));

HRESULT PipelineMgr::Initialize(ISdo* pSdoService) throw ()
{
   using _com_util::CheckError;

   HRESULT retval = S_OK;

   try
   {
      // Get the request handlers collection.
      _variant_t disp;
      CheckError(pSdoService->GetProperty(
                                  PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                                  &disp
                                  ));
      ISdoCollectionPtr handlers(disp);

      // Get the number of handlers to be managed.
      long count;
      CheckError(handlers->get_Count(&count));

      // Reserve space in our internal collection ...
      components.reserve(count);

      // ... and create a SAFEARRAY to give to the pipline.
      _variant_t result;
      SAFEARRAYBOUND bound[2] = { { count, 0 }, { 2, 0 } };
      V_ARRAY(&result) = SafeArrayCreate(VT_VARIANT, 2, bound);
      if (!V_ARRAY(&result)) { _com_issue_error(E_OUTOFMEMORY); }
      V_VT(&result) = VT_ARRAY | VT_VARIANT;

      // The next element in the SAFEARRAY to be populated.
      VARIANT* next = (VARIANT*)V_ARRAY(&result)->pvData;

      // Get an enumerator on the handler collection.
      IUnknownPtr unk;
      CheckError(handlers->get__NewEnum(&unk));
      IEnumVARIANTPtr iter(unk);

      // Iterate through the handlers.
      _variant_t element;
      unsigned long fetched;
      while (iter->Next(1, &element, &fetched) == S_OK && fetched == 1)
      {
         // Get an SDO from the VARIANT.
         ISdoPtr handler(element);
         element.Clear();

         // Get the handlers ProgID ...
         CheckError(handler->GetProperty(PROPERTY_COMPONENT_PROG_ID, next));
         
         IASTracePrintf("PipelineMgr::Initialize: progID = %S", V_BSTR(next));

         // ... and create the COM component.
         IUnknownPtr object(V_BSTR(next), NULL, CLSCTX_INPROC_SERVER);

         // Store the component in the SAFEARRAY.
         V_VT(++next) = VT_UNKNOWN;
         (V_UNKNOWN(next) = object)->AddRef();
         ++next;

         // Create the wrapper.
         _variant_t id;
         CheckError(handler->GetProperty(PROPERTY_COMPONENT_ID, &id));
         IASTracePrintf("componentID = %d", V_I4(&id));
         ComponentPtr component = MakeComponent(
                                      COMPONENT_TYPE_REQUEST_HANDLER,
                                      V_I4(&id)
                                      );

         // Initialize the wrapper.
         CheckError(component->PutObject(object, __uuidof(IIasComponent)));
         CheckError(component->Initialize(pSdoService));

         // Save it in our internal collection.
         components.push_back(component);
      }

      // Create and initialize the pipeline.
      pipeline.CreateInstance(L"IAS.Pipeline", NULL, CLSCTX_INPROC_SERVER);
      CheckError(pipeline->InitNew());
      CheckError(pipeline->PutProperty(0, &result));
      CheckError(pipeline->Initialize());
   }
   catch (const _com_error& ce)
   {
      retval = ce.Error();
   }
   catch (const std::bad_alloc&)
   {
      retval = E_OUTOFMEMORY;
   }
   catch (...)
   {
      retval = E_FAIL;
   }

   if (FAILED(retval))
   {
      // Clean up any partial result.
      Shutdown();
   }

   return retval;
}

HRESULT PipelineMgr::Configure(ISdo* pSdoService) throw ()
{
   // Configure each of the components.
   for (ComponentIterator i = components.begin(); i != components.end(); ++i)
   {
      (*i)->Configure(pSdoService);
   }

   return S_OK;
}

void PipelineMgr::Shutdown()
{
   for (ComponentIterator i = components.begin(); i != components.end(); ++i)
   {
      (*i)->Suspend();
      (*i)->Shutdown();
   }

   components.clear();

   if (pipeline)
   {
      pipeline->Shutdown();
      pipeline.Attach(NULL);
   }
}

HRESULT PipelineMgr::GetPipeline(IRequestHandler** handler) throw ()
{
   return pipeline->QueryInterface(
                        __uuidof(IRequestHandler),
                        (PVOID*)handler
                        );
}

void LinkPoliciesToEnforcer(
         ISdo* service,
         LONG policiesAlias,
         LONG profilesAlias,
         LONG handlerAlias
         )
{
   using _com_util::CheckError;

   // Get an enumerator for the policies collection.
   IEnumVARIANTPtr policies;
   CheckError(SDOGetCollectionEnumerator(
                  service,
                  policiesAlias,
                  &policies
                  ));

   // Get the profiles collection.
   _variant_t profilesProperty;
   CheckError(service->GetProperty(
                           profilesAlias,
                           &profilesProperty
                           ));
   ISdoCollectionPtr profiles(profilesProperty);

   // Iterate through the policies.
   ISdoPtr policy;
   while (SDONextObjectFromCollection(policies, &policy) == S_OK)
   {
      // Get the policy name ...
      _variant_t name;
      CheckError(policy->GetProperty(
                             PROPERTY_SDO_NAME,
                             &name
                             ));

      // ... and find the corresponding profile.
      IDispatchPtr item;
      CheckError(profiles->Item(&name, &item));
      ISdoPtr profile(item);

      // Get the attributes collection from the profile ...
      _variant_t attributes;
      CheckError(profile->GetProperty(
                              PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                              &attributes
                              ));

      // ... and link it to the policy.
      CheckError(policy->PutProperty(
                             PROPERTY_POLICY_ACTION,
                             &attributes
                             ));
   }

   // Get the request handler that will enforce these policies.
   ISdoPtr handler;
   CheckError(SDOGetComponentFromCollection(
                  service,
                  PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                  handlerAlias,
                  &handler
                  ));

   // Get the policy collection as a variant ...
   _variant_t policiesValue;
   CheckError(service->GetProperty(
                           policiesAlias,
                           &policiesValue
                           ));

   // ... and link it to the handler.
   CheckError(handler->PutProperty(
                            PROPERTY_NAP_POLICIES_COLLECTION,
                            &policiesValue
                            ));
}

VOID
WINAPI
LinkGroupsToProxy(
    ISdo* service,
    IDataStoreObject* ias
    )
{
   using _com_util::CheckError;

   ISdoPtr proxy;
   CheckError(SDOGetComponentFromCollection(
                  service,
                  PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                  IAS_PROVIDER_MICROSOFT_RADIUS_PROXY,
                  &proxy
                  ));

   _variant_t v(ias);
   CheckError(proxy->PutProperty(
                         PROPERTY_RADIUSPROXY_SERVERGROUPS,
                         &v
                         ));
}

HRESULT
WINAPI
LinkHandlerProperties(
    ISdo* pSdoService,
    IDataStoreObject* pDsObject
    ) throw ()
{
   try
   {
      LinkPoliciesToEnforcer(
          pSdoService,
          PROPERTY_IAS_POLICIES_COLLECTION,
          PROPERTY_IAS_PROFILES_COLLECTION,
          IAS_PROVIDER_MICROSOFT_NAP
          );

      LinkPoliciesToEnforcer(
          pSdoService,
          PROPERTY_IAS_PROXYPOLICIES_COLLECTION,
          PROPERTY_IAS_PROXYPROFILES_COLLECTION,
          IAS_PROVIDER_MICROSOFT_PROXY_POLICY
          );

      LinkGroupsToProxy(
          pSdoService,
          pDsObject
          );
   }
   catch (const _com_error& ce)
   {
      return ce.Error();
   }
   catch (...)
   {
      return E_FAIL;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdopolicy.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdopolicy.h
//
// Project:     Everest
//
// Description: IAS Server Data Object - Policy Object Definition
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_POLICY_H_
#define _INC_IAS_SDO_POLICY_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include <sdofactory.h>

#define		IAS_CONDITION_NAME	L"Condition"

/////////////////////////////////////////////////////////////////////////////
// CSdoPolicy
/////////////////////////////////////////////////////////////////////////////

class CSdoPolicy : public CSdo 
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoPolicy)
	COM_INTERFACE_ENTRY(ISdo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoPolicy);

	///////////////////////////////////////////////////////////////////////////
	CSdoPolicy() { }

	///////////////////////////////////////////////////////////////////////////
    ~CSdoPolicy() { }

	///////////////////////////////////////////////////////////////////////////
	HRESULT FinalInitialize(
				    /*[in]*/ bool         fInitNew,
				    /*[in]*/ ISdoMachine* pAttachedMachine
							);

	///////////////////////////////////////////////////////////////////////////
	HRESULT Load(void);

	///////////////////////////////////////////////////////////////////////////
	HRESULT Save(void);

private:

	CSdoPolicy(const CSdoPolicy& rhs);
	CSdoPolicy& operator = (CSdoPolicy& rhs);

    // Transformation functions
    //
	HRESULT ConditionsFromConstraints(void);

	HRESULT ConstraintsFromConditions(void);
};

#endif // _INC_IAS_SDO_POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoprofile.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoprofile.h
//
// Project:     Everest
//
// Description: IAS Server Data Object - Profile Object Definition
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_PROFILE_H_
#define _INC_IAS_SDO_PROFILE_H_

#include "resource.h"
#include <ias.h>
#include <iaspolcy.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include <sdofactory.h>

class SdoDictionary;

/////////////////////////////////////////////////////////////////////////////
// CSdoProfile
/////////////////////////////////////////////////////////////////////////////

class CSdoProfile :
   public CSdo
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoProfile)
   COM_INTERFACE_ENTRY(ISdo)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoProfile);

   ///////////////////////////////////////////////////////////////////////////
   CSdoProfile();

   ///////////////////////////////////////////////////////////////////////////
    ~CSdoProfile();

   ///////////////////////////////////////////////////////////////////////////
   HRESULT FinalInitialize(
                /*[in]*/ bool         fInitNew,
                /*[in]*/ ISdoMachine* pAttachedMachine
                     );

   ///////////////////////////////////////////////////////////////////////////
   HRESULT Load(void);

   ///////////////////////////////////////////////////////////////////////////
   HRESULT Save(void);

private:

   CSdoProfile(const CSdoProfile& rhs);
   CSdoProfile& operator = (CSdoProfile& rhs);

   ///////////////////////////////////////////////////////////////////////////
   HRESULT LoadAttributes(void);

   ///////////////////////////////////////////////////////////////////////////
   HRESULT SaveAttributes(void);

   ///////////////////////////////////////////////////////////////////////////
   HRESULT ClearAttributes(void);

   // Dictionary SDO
   //
   CComPtr<SdoDictionary>   m_pSdoDictionary;
};

#endif // _INC_IAS_SDO_PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdopolicy.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdopolicy.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object - Policy Object Implementation
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdopolicy.h"
#include "sdohelperfuncs.h"
#include <varvec.h>
#include <time.h>

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoPolicy::FinalInitialize(
						   /*[in]*/ bool         fInitNew,
						   /*[in]*/ ISdoMachine* pAttachedMachine
									)
{
	HRESULT hr = InitializeCollection(
						              PROPERTY_POLICY_CONDITIONS_COLLECTION, 
								      SDO_PROG_ID_CONDITION,
								      pAttachedMachine,
								      NULL
								     );
	if ( SUCCEEDED(hr) )
	{
		if ( ! fInitNew )
			hr = Load();
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoPolicy::Load()
{
	HRESULT hr = LoadProperties();
	if ( SUCCEEDED(hr) )
		hr = ConditionsFromConstraints(); 

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoPolicy::Save()
{
	HRESULT hr = ConstraintsFromConditions();
	if ( SUCCEEDED(hr) )
		hr = SaveProperties();

	return hr;
}


static DWORD dwConditionName;

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoPolicy::ConditionsFromConstraints()  	// Invoked by LoadSdo()...

{
	// Preliminaries...
	//
    _variant_t  vtConstraints;
	HRESULT hr = GetPropertyInternal(PROPERTY_POLICY_CONSTRAINT, &vtConstraints);
    if ( FAILED(hr) )
	{
		IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - Could not get policy constraints...");
        return E_FAIL;
	}
	_variant_t vtConditions;
	hr = GetPropertyInternal(PROPERTY_POLICY_CONDITIONS_COLLECTION, &vtConditions);
    if ( FAILED(hr) )
	{
		IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - Could not get conditions collection...");
        return E_FAIL;
	}
	CComPtr<ISdoCollection> pConditions;
	hr = vtConditions.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pConditions);
    if ( FAILED(hr) )
	{
		IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - QueryInterface(ISdoCollection) failed...");
        return E_FAIL;
	}

	// Clear the conditions collection
	//
	pConditions->RemoveAll();

    // hr = S_OK at this point... Short circuit if there are no constraints
    //
	if ( VT_EMPTY != V_VT(&vtConstraints) )
	{
		CVariantVector<VARIANT> Constraints(&vtConstraints) ;
		ULONG ulCount = 0;	

		// Build a condition object out of each constraint. 
		//

 	    CComPtr<IDispatch>	pDispatch;
		CComPtr<ISdo>		pSdo;
		_variant_t			vtConditionText;
		_bstr_t				bstrConditionName;
		WCHAR				szConditionName[MAX_PATH + 1];

		dwConditionName = 0;
		while ( ulCount < Constraints.size() )
		{
			// For now we'll generate a name... The conditions collection should go away and 
			// we should use the policy object constraint property directly.
			//
			wsprintf(
					  szConditionName, 
					  _T("Condition%ld"), 
					  dwConditionName++
					);

			bstrConditionName = szConditionName;
			hr = pConditions->Add(bstrConditionName, &pDispatch);
			if ( FAILED(hr) )
			{
				IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - Could not update conditions collection...");
				break;
			}
			hr = pDispatch->QueryInterface(IID_ISdo, (void**)&pSdo);
			if ( FAILED(hr) )
			{
				IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - QueryInterface() failed...");
				break;
			}
			vtConditionText = Constraints[ulCount];
			hr = pSdo->PutProperty(PROPERTY_CONDITION_TEXT, &vtConditionText);
			if ( FAILED(hr) )
			{
				IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - PutProperty() failed...");
				break;
			}
			vtConditionText.Clear();
			pDispatch.Release();
			pSdo.Release();
			ulCount++;
		}
	}

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoPolicy::ConstraintsFromConditions()  
{
	// Preliminaries...
	//
    PropertyMapIterator p = m_PropertyMap.find(PROPERTY_POLICY_CONSTRAINT);
	_ASSERT ( p != m_PropertyMap.end() );

	_variant_t vtConditions;
	HRESULT hr = GetPropertyInternal(PROPERTY_POLICY_CONDITIONS_COLLECTION, &vtConditions);
    if ( FAILED(hr) )
	{
		IASTracePrintf("Error in Policy SDO - ConstraintsFromConditions() - Could not get conditions collection...");
        return hr;
	}
	CComPtr<ISdoCollection> pConditions;
	hr = vtConditions.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pConditions);
    if ( FAILED(hr) )
	{
		IASTracePrintf("Error in Policy SDO - ConditionsFromConstraints() - QueryInterface(ISdoCollection) failed...");
        return hr;
	}

	LONG lCount;
	hr = pConditions->get_Count(&lCount);
	_ASSERT( SUCCEEDED(hr) );
	if ( FAILED(hr) )
        return hr;

	// Short circuit if no constraints are present
	//
    _variant_t	vtConstraints;
	if ( 0 == lCount )
	{
		// Put VT_EMPTY into data store to clear out the constraints
		//
	    hr = ((*p).second)->PutValue(&vtConstraints);
		if ( FAILED(hr) )
			IASTracePrintf("Error in Policy SDO - ConstraintsFromConditions() - PutValue(VT_EMPTY) failed...");
    }                
	else
	{
		// Create the varvec of Constraints and reset the count
		//
		CVariantVector<VARIANT> Constraints(&vtConstraints, lCount);
		lCount = 0;

		// Build the constraints property from the Policy SDO's conditions collection
		//
		CComPtr<IEnumVARIANT> pEnumConditions;
		hr = SDOGetCollectionEnumerator(
						   				static_cast<ISdo*>(this), 
										PROPERTY_POLICY_CONDITIONS_COLLECTION, 
										&pEnumConditions
									   );
		
		CComPtr<ISdo> pSdoCondition;
		hr = ::SDONextObjectFromCollection(pEnumConditions, &pSdoCondition);
		while ( S_OK == hr )
		{
			hr = pSdoCondition->GetProperty(PROPERTY_CONDITION_TEXT, &Constraints[lCount]);		
			if ( FAILED(hr) )
			{
				IASTracePrintf("Error in Policy SDO - ConstraintsFromConditions() - GetProperty() failed...");
				break;
			}
			lCount++;
			pSdoCondition.Release();
			hr = ::SDONextObjectFromCollection(pEnumConditions, &pSdoCondition);
		}
		if ( S_FALSE == hr )
			hr = S_OK;

		// Update the msNPConstraints property if everything went OK
		//
		if ( SUCCEEDED(hr) )
		{
			hr = ((*p).second)->PutValue(&vtConstraints);
			if ( FAILED(hr) )
				IASTracePrintf("Error in Policy SDO - ConstraintsFromConditions() - PutValue() failed...");
		}
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoprofile.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoprofile.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object - Profile Object Implementation
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// C++ Exception Specification ignored
#pragma warning(disable:4290)

#include <iasattr.h>
#include <attrcvt.h>
#include <varvec.h>
#include "sdoprofile.h"
#include "sdohelperfuncs.h"

#include <attrdef.h>
#include <sdoattribute.h>
#include <sdodictionary.h>

//////////////////////////////////////////////////////////////////////////////
CSdoProfile::CSdoProfile()
    : m_pSdoDictionary(NULL)
{

}


//////////////////////////////////////////////////////////////////////////////
CSdoProfile::~CSdoProfile()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::FinalInitialize(
                       /*[in]*/ bool         fInitNew,
                      /*[in]*/ ISdoMachine* pAttachedMachine
                             )

{
   CComPtr<IUnknown> pUnknown;
   HRESULT hr = pAttachedMachine->GetDictionarySDO(&pUnknown);
   if ( SUCCEEDED(hr) )
   {
      hr = pUnknown->QueryInterface(IID_ISdoDictionaryOld, (void**)&m_pSdoDictionary);
      if ( SUCCEEDED(hr) )
      {
         hr = InitializeCollection(
                               PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                             SDO_PROG_ID_ATTRIBUTE,
                             pAttachedMachine,
                             NULL
                            );
         if ( SUCCEEDED(hr) )
         {
            if ( ! fInitNew )
               hr = Load();
         }
      }
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::Load()
{
   HRESULT hr = LoadAttributes();
   if ( SUCCEEDED(hr) )
      hr = LoadProperties();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::Save()
{
   HRESULT hr = SaveAttributes();
   if ( SUCCEEDED(hr) )
      hr = SaveProperties();

   return hr;
}



//////////////////////////////////////////////////////////////////////////////
// Profile class private member functions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Load the Profile SDO's attributes from the persistent store
//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::LoadAttributes()
{
    HRESULT      hr;
   ATTRIBUTEID   AttributeID;

   SDO_TRACE_VERBOSE_1("Profile SDO at $%p is loading profile attributes from the data store...",this);

   _variant_t vtAttributes;
   hr = GetPropertyInternal(PROPERTY_PROFILE_ATTRIBUTES_COLLECTION, &vtAttributes);
    if ( FAILED(hr) )
   {
      IASTracePrintf("Error in Profile SDO - LoadAttributes() - Could not get attributes collection...");
        return E_FAIL;
   }
   CComPtr<ISdoCollection> pAttributes;
   hr = vtAttributes.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pAttributes);
    if ( FAILED(hr) )
   {
      IASTracePrintf("Error in Profile SDO - LoadAttributes() - QueryInterface(ISdoCollection) failed...");
        return E_FAIL;
   }
   // Clear the current contents of the profile attributes collection
   //
    pAttributes->RemoveAll();

    // Create a new attribute SDO for each profile attribute
    //
    CComPtr<IUnknown> pUnknown;
    hr = m_pDSObject->get__NewEnum(&pUnknown);
    if ( FAILED(hr) )
    {
        IASTracePrintf("Error in Profile SDO - LoadAttributes() - get__NewEnum() failed...");
        return E_FAIL;
    }
    CComPtr<IEnumVARIANT> pEnumVariant;
    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant);
    if ( FAILED(hr) )
    {
        IASTracePrintf("Error in Profile SDO - LoadAttributes() - QueryInterface(IEnumVARIANT) failed...");
        return E_FAIL;
    }

    _variant_t    vtDSProperty;
   DWORD      dwRetrieved = 1;

    hr = pEnumVariant->Next(1, &vtDSProperty, &dwRetrieved);
    if ( S_FALSE == hr )
    {
        IASTracePrintf("Error in Profile SDO - LoadAttributes() - No profile object properties...");
        return E_FAIL;
    }

    BSTR                        bstrName = NULL;
    CComPtr<IDataStoreProperty>   pDSProperty;

    while ( S_OK == hr  )
    {
        hr = vtDSProperty.pdispVal->QueryInterface(IID_IDataStoreProperty, (void**)&pDSProperty);
        if ( FAILED(hr) )
        {
         IASTracePrintf("Error in Profile SDO - LoadAttributes() - QueryInterface(IEnumDataStoreProperty) failed...");
            break;
        }
        hr = pDSProperty->get_Name(&bstrName);
        if ( FAILED(hr) )
        {
           IASTracePrintf("Error in Profile SDO - LoadAttributes() - get_Name() failed for %ls...", bstrName);
            break;
        }

        // If the attribute is not in the dictionary, then it's not an
        // attribute and it doesn't belong in the SDO collection.
        const AttributeDefinition* def = m_pSdoDictionary->findByLdapName(
                                                               bstrName
                                                               );
        if (def)
        {
           // Create an attribute SDO.
           CComPtr<SdoAttribute> attr;
           hr = SdoAttribute::createInstance(def, &attr);
           if (FAILED(hr)) { break; }

           // Set the value from the datastore.
           if (attr->def->restrictions & MULTIVALUED)
           {
              hr = pDSProperty->get_ValueEx(&attr->value);
           }
           else
           {
              hr = pDSProperty->get_Value(&attr->value);
           }

           if (FAILED(hr))
           {
               IASTraceFailure("IDataStore2::GetValue", hr);
               break;
           }

           // Add the attribute to the attributes collection.
           hr = pAttributes->Add(def->name, (IDispatch**)&attr);
           if (FAILED(hr)) { break; }

           SDO_TRACE_VERBOSE_2("Profile SDO at $%p loaded attribute '%S'",
                               this, bstrName);
        }

        // Next profile object property
      //
      pDSProperty.Release();
        vtDSProperty.Clear();
        SysFreeString(bstrName);
      bstrName = NULL;

        dwRetrieved = 1;
        hr = pEnumVariant->Next(1, &vtDSProperty, &dwRetrieved);
    }

    if ( S_FALSE == hr )
        hr = S_OK;

   if ( bstrName )
      SysFreeString(bstrName);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// Save the Profile SDO's attributes to the persistent store
//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::SaveAttributes()
{
   HRESULT   hr;

   SDO_TRACE_VERBOSE_1("Profile SDO at $%p is saving profile attributes...",this);

    hr = ClearAttributes();
    if ( FAILED(hr) )
        return E_FAIL;

   _variant_t vtAttributes;
   hr = GetPropertyInternal(PROPERTY_PROFILE_ATTRIBUTES_COLLECTION, &vtAttributes);
    if ( FAILED(hr) )
   {
      IASTracePrintf("Error in Profile SDO - LoadAttributes() - Could not get attributes collection...");
        return E_FAIL;
   }
   CComPtr<ISdoCollection> pAttributes;
   hr = vtAttributes.pdispVal->QueryInterface(IID_ISdoCollection, (void**)&pAttributes);
    if ( FAILED(hr) )
   {
      IASTracePrintf("Error in Profile SDO - LoadAttributes() - QueryInterface(ISdoCollection) failed...");
        return E_FAIL;
   }

    // Store the "Value" property of each Attribute SDO as a
   // profile attribute value.
   //
    CComPtr<IUnknown> pUnknown;
    hr = pAttributes->get__NewEnum(&pUnknown);
    if ( FAILED(hr) )
    {
        IASTracePrintf("Error in Profile SDO - SaveAttributes() - get__NewEnum() failed...");
        return E_FAIL;
    }

    CComPtr<IEnumVARIANT> pEnumVariant;
    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant);
    if ( FAILED(hr) )
    {
      IASTracePrintf("Error in Profile SDO - SaveAttributes() - QueryInterface(IEnumVARIANT) failed...");
        return E_FAIL;
    }

    _variant_t   vtAttribute;
    DWORD      dwRetrieved = 1;

    hr = pEnumVariant->Next(1, &vtAttribute, &dwRetrieved);
    if ( S_FALSE == hr )
    {
      SDO_TRACE_VERBOSE_1("Profile SDO at $%p has an empty attributes collection...",this);
        return S_OK;
    }

    CComPtr<ISdo>      pSdo;
   _variant_t         vtName;
   _variant_t         vtValue;
   _variant_t         vtMultiValued;

    while ( S_OK == hr  )
    {
        hr = vtAttribute.pdispVal->QueryInterface(IID_ISdo, (void**)&pSdo);
        if ( FAILED(hr) )
        {
         IASTracePrintf("Error in Profile SDO - SaveAttributes() - QueryInterface(ISdo) failed...");
            hr = E_FAIL;
            break;
        }
      hr = pSdo->GetProperty(PROPERTY_ATTRIBUTE_DISPLAY_NAME, &vtName);
        if ( FAILED(hr) )
            break;

        if ( 0 == lstrlen(V_BSTR(&vtName)) )
        {
         IASTracePrintf("Error in Profile SDO - SaveAttributes() - dictionary corrupt?...");
         hr = E_FAIL;
            break;
       }

      hr = pSdo->GetProperty(PROPERTY_ATTRIBUTE_VALUE, &vtValue);
        if ( FAILED(hr) )
            break;

      hr = pSdo->GetProperty(PROPERTY_ATTRIBUTE_ALLOW_MULTIPLE, &vtMultiValued);
        if ( FAILED(hr) )
            break;

      if ( V_BOOL(&vtMultiValued) == VARIANT_TRUE )
      {
         _variant_t   vtType;
         hr = pSdo->GetProperty(PROPERTY_ATTRIBUTE_SYNTAX, &vtType);
         if ( FAILED(hr) )
            break;

         hr = m_pDSObject->PutValue(V_BSTR(&vtName), &vtValue);
      }
      else
      {
         hr = m_pDSObject->PutValue(V_BSTR(&vtName), &vtValue);
      }

        if ( FAILED(hr) )
        {
         IASTracePrintf("Error in Profile SDO - SaveAttributes() - PutValue() failed...");
            break;
        }

      SDO_TRACE_VERBOSE_2("Profile SDO at $%p saved attribute '%ls'...", this, vtName.bstrVal);

        pSdo.Release();
        vtAttribute.Clear();
        vtName.Clear();
        vtValue.Clear();
      vtMultiValued.Clear();

        dwRetrieved = 1;
        hr = pEnumVariant->Next(1, &vtAttribute, &dwRetrieved);
    }

    if ( S_FALSE == hr )
        hr = S_OK;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// Deletes the Profile SDO's attributes from the persistent store
//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProfile::ClearAttributes(void)
{
    HRESULT      hr;
   ATTRIBUTEID   AttributeID;

   SDO_TRACE_VERBOSE_1("Profile SDO at $%p is clearing its profile attributes...",this);

   _ASSERT( NULL != m_pDSObject);

   // Set each profile attribute that has a representation in the IAS dictionary to VT_EMPTY
   //
    CComPtr<IUnknown> pUnknown;
    hr = m_pDSObject->get__NewEnum(&pUnknown);
    if ( FAILED(hr) )
    {
      IASTracePrintf("Error in Profile SDO - ClearAttributes() - get__NewEnum() failed...");
        return E_FAIL;
    }

    CComPtr<IEnumVARIANT> pEnumVariant;
    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant);
    if ( FAILED(hr) )
    {
      IASTracePrintf("Error in Profile SDO - ClearAttributes() - QueryInterface(IEnumVARIANT) failed...");
        return E_FAIL;
    }

    DWORD      dwRetrieved = 1;
    _variant_t  vtDSProperty;

    hr = pEnumVariant->Next(1, &vtDSProperty, &dwRetrieved);
    if ( S_FALSE == hr )
    {
      SDO_TRACE_VERBOSE_1("Profile SDO at $%p has no profile attributes in the data store...",this);
        return S_OK;
    }

    BSTR                  bstrName = NULL;
    CComPtr<IDataStoreProperty> pDSProperty;
    _variant_t                  vtEmpty;

    while ( S_OK == hr  )
    {
        hr = vtDSProperty.pdispVal->QueryInterface(IID_IDataStoreProperty, (void**)&pDSProperty);
        if ( FAILED(hr) )
        {
         IASTracePrintf("Error in Profile SDO - ClearAttributes() - QueryInterface(IDataStoreProperty) failed...");
            hr = E_FAIL;
            break;
        }
        hr = pDSProperty->get_Name(&bstrName);
        if ( FAILED(hr) )
        {
         IASTracePrintf("Error in Profile SDO - ClearAttributes() - IDataStoreProperty::Name() failed...");
            break;
        }
        hr = m_pSdoDictionary->GetAttributeID(bstrName, &AttributeID);
        if ( SUCCEEDED(hr) )
        {
           hr = m_pDSObject->PutValue(bstrName, &vtEmpty);
           if ( FAILED(hr) )
          {
            IASTracePrintf("Error in Profile SDO - ClearAttributes() - IDataStoreObject::PutValue() failed...");
            break;
         }

         SDO_TRACE_VERBOSE_2("Profile SDO at $%p cleared attribute '%ls'...", this, bstrName);
      }

       pDSProperty.Release();
        vtDSProperty.Clear();
        SysFreeString(bstrName);
      bstrName = NULL;

        dwRetrieved = 1;
        hr = pEnumVariant->Next(1, &vtDSProperty, &dwRetrieved);
    }

   if ( S_FALSE == hr )
      hr = S_OK;

   if ( bstrName )
        SysFreeString(bstrName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoschema.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   IAS Server Data Object - Schema Implementation
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdoschema.h"
#include "sdohelperfuncs.h"
#include "varvec.h"

#include <vector>
using namespace std;

//////////////////////////////////////////////////////////////////////////////
//                       SCHEMA IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
static WCHAR PropertyIdClass[] = L"{46557889-4DB8-11d2-8ECE-00C04FC2F519}";
static WCHAR PropertyIdName[] =  L"{46557888-4DB8-11d2-8ECE-00C04FC2F519}";

static LPCWSTR RequiredProperties[] =
{
   PropertyIdClass,
   PropertyIdName,
   NULL
};

//////////////////////////////////////////////////////////////////////////////
static WCHAR PropertyIdCallingStationId[] =       L"{EFE7FCD3-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdSavedCallingStationId[] = L"{EFE7FCD4-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRADIUSCallbackNumber[] =    L"{EFE7FCD5-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRADIUSFramedRoute[] =     L"{EFE7FCD6-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRADIUSFramedIPAddress[] = L"{EFE7FCD7-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRASCallbackNumber[] =     L"{EFE7FCD8-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRASFramedRoute[] =        L"{EFE7FCD9-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRASFramedIPAddress[] =    L"{EFE7FCDA-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdAllowDialin[] =           L"{EFE7FCDB-4D26-11d2-A8C8-00AA00A71DCA}";
static WCHAR PropertyIdRADIUSServiceType[] =     L"{EFE7FCDC-4D26-11d2-A8C8-00AA00A71DCA}";

static LPCWSTR UserOptionalProperties[] =
{
   PropertyIdCallingStationId,
   PropertyIdSavedCallingStationId,
   PropertyIdRADIUSCallbackNumber,
   PropertyIdRADIUSFramedRoute,
   PropertyIdRADIUSFramedIPAddress,
   PropertyIdRASCallbackNumber,
   PropertyIdRASFramedRoute,
   PropertyIdRASFramedIPAddress,
   PropertyIdAllowDialin,
   PropertyIdRADIUSServiceType,
   NULL
};

//////////////////////////////////////////////////////////////////////////////
// Internal SDO Properties
//
BEGIN_SCHEMA_PROPERTY_MAP(InternalProperties)
   DEFINE_SCHEMA_PROPERTY(
                     SDO_STOCK_PROPERTY_CLASS,               // Name
                     PropertyIdClass,                     // Id
                     (LONG)VT_BSTR,                        // Syntax
                     (LONG)PROPERTY_SDO_CLASS,               // Alias
                     496,                              // Flas
                     1,                                 // MinLength
                     255,                              // MaxLength
                     SDO_STOCK_PROPERTY_CLASS               // DisplayName
                    )
   DEFINE_SCHEMA_PROPERTY(
                     SDO_STOCK_PROPERTY_NAME,
                     PropertyIdName,
                     (LONG)VT_BSTR,
                     (LONG)PROPERTY_SDO_NAME,
                     112,
                     1,
                     255,
                     SDO_STOCK_PROPERTY_NAME
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"Calling Station Id",
                     PropertyIdCallingStationId,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_CALLING_STATION_ID,
                     0x210,
                     1,
                     0,
                     L"msNPCallingStationID"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"Saved Calling Station Id",
                     PropertyIdSavedCallingStationId,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_SAVED_CALLING_STATION_ID,
                     0x210,
                     1,
                     0,
                     L"msNPSavedCallingStationID"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RADIUS Callback Number",
                     PropertyIdRADIUSCallbackNumber,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_RADIUS_CALLBACK_NUMBER,
                     48,
                     1,
                     255,
                     L"msRADIUSCallbackNumber"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RADIUS Framed Route",
                     PropertyIdRADIUSFramedRoute,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_RADIUS_FRAMED_ROUTE,
                     560,
                     1,
                     255,
                     L"msRADIUSFramedRoute"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RADIUS Framed IP Address",
                     PropertyIdRADIUSFramedIPAddress,
                     (LONG)VT_I4,
                     PROPERTY_USER_RADIUS_FRAMED_IP_ADDRESS,
                     0,
                     0,
                     0,
                     L"msRADIUSFramedIPAddress"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RAS Saved Callback Number",
                     PropertyIdRASCallbackNumber,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER,
                     48,
                     1,
                     255,
                     L"msRASSavedCallbackNumber"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RAS Saved Framed Route",
                     PropertyIdRASFramedRoute,
                     (LONG)VT_BSTR,
                     PROPERTY_USER_SAVED_RADIUS_FRAMED_ROUTE,
                     560,
                     1,
                     255,
                     L"msRASSavedFramedRoute"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"RAS Saved Framed IP Address",
                     PropertyIdRASFramedIPAddress,
                     (LONG)VT_I4,
                     PROPERTY_USER_SAVED_RADIUS_FRAMED_IP_ADDRESS,
                     0,
                     0,
                     0,
                     L"msRASSavedFramedIPAddress"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"Allow Dial-In",
                     PropertyIdAllowDialin,
                     (LONG)VT_BOOL,
                     PROPERTY_USER_ALLOW_DIALIN,
                     0,
                     0,
                     0,
                     L"msNPAllowDialin"
                    )
   DEFINE_SCHEMA_PROPERTY(
                     L"Service Type",
                     PropertyIdRADIUSServiceType,
                     (LONG)VT_I4,
                     PROPERTY_USER_SERVICE_TYPE,
                     0,
                     0,
                     0,
                     L"msRADIUSServiceType"
                    )
END_SCHEMA_PROPERTY_MAP


//////////////////////////////////////////////////////////////////////////////
// Internal SDO Classes
//
BEGIN_SCHEMA_CLASS_MAP(InternalClasses)
   DEFINE_SCHEMA_CLASS(
                  SDO_PROG_ID_USER,
                  RequiredProperties,
                  UserOptionalProperties
                  )
END_SCHEMA_CLASS_MAP

//////////////////////////////////////////////////////////////////////////////
CSdoSchema::CSdoSchema()
   : m_state(SCHEMA_OBJECT_SHUTDOWN),
     m_fInternalObjsInitialized(false),
     m_fSchemaObjsInitialized(false)
{
   InitializeCriticalSection(&m_critSec);
   InternalAddRef();
}

//////////////////////////////////////////////////////////////////////////////
CSdoSchema::~CSdoSchema()
{
   if ( SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      DestroyClasses();
      DestroyProperties();
   }
   DeleteCriticalSection(&m_critSec);
}

///////////////////
// Public Iterface

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchema::GetVersion(
                     /*[in]*/ BSTR* version
                            )
{
   _ASSERT( NULL != version );
   _ASSERT( SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      BSTR theStr = ::SysAllocString( m_version.c_str() );
      if ( theStr )
      {
         *version = theStr;
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchema::GetClass(
                    /*[in]*/ BSTR id,
                   /*[out]*/ IUnknown** ppSdoClassInfo
                           )
{
   _ASSERT( NULL != id && NULL != ppSdoClassInfo );
   HRESULT hr = E_FAIL;
   try
   {
      ClassMapIterator p = m_classMap.find(id);
      _ASSERT( p != m_classMap.end() );
      if ( p != m_classMap.end() )
      {
         ((*p).second)->AddRef();
         *ppSdoClassInfo = (*p).second;
         hr = S_OK;
      }
      else
      {
         IASTracePrintf("Error in SDO Schema - GetClass() - Unknown class id...");
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO Schema - GetClass() - Caught unknown exception...");
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchema::GetProperty(
                      /*[in]*/ BSTR id,
                      /*[out]*/ IUnknown** ppSdoPropertyInfo
                              )
{
   _ASSERT( NULL != id && NULL != ppSdoPropertyInfo );
   HRESULT hr = E_FAIL;
   try
   {
      PropertyMapIterator p = m_propertyMap.find(id);
      _ASSERT( p != m_propertyMap.end() );
      if ( p != m_propertyMap.end() )
      {
         ((*p).second)->AddRef();
         *ppSdoPropertyInfo = (*p).second;
         hr = S_OK;
      }
      else
      {
         IASTracePrintf("Error in SDO Schema - GetProperty() - Unknown property id...");
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO Schema - GetProperty() - Caught unknown exception...");
   }
   return hr;
}


////////////////////
// Private Functions

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::Initialize(
                 /*[in]*/ IDataStoreObject* pSchemaDataStore
                         )
{
   HRESULT hr = S_OK;
   EnterCriticalSection(&m_critSec);
   try
   {
      do
      {
         if ( ! m_fInternalObjsInitialized )
         {
            hr = BuildInternalProperties();
            if (FAILED(hr) )
               break;
            hr = BuildInternalClasses();
            if ( FAILED(hr) )
            {
               DestroyProperties();
               break;
            }
            m_fInternalObjsInitialized = true;
            m_state = SCHEMA_OBJECT_INITIALIZED;
         }
         if ( pSchemaDataStore )
         {
            if ( ! m_fSchemaObjsInitialized )
            {
               hr = BuildSchemaProperties(pSchemaDataStore);
               if ( SUCCEEDED(hr) )
                  hr = BuildSchemaClasses(pSchemaDataStore);
               if ( FAILED(hr) )
               {
                  DestroyProperties();
                  DestroyClasses();
                  m_fInternalObjsInitialized = false;
                  m_state = SCHEMA_OBJECT_SHUTDOWN;
                  break;
               }
               m_fSchemaObjsInitialized = true;
            }
         }

      } while ( FALSE );
   }
   catch(...)
   {
      IASTracePrintf("Error in SDO Schema - Initialize() - Caught unknown exception...");
      DestroyClasses();
      DestroyProperties();
      m_fInternalObjsInitialized = false;
      m_state = SCHEMA_OBJECT_SHUTDOWN;
      hr = E_FAIL;
   }
   LeaveCriticalSection(&m_critSec);
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::AddProperty(
                  /*[in]*/ PSDO_PROPERTY_OBJ pPropertyObj
                         )
{
   HRESULT hr = E_FAIL;
   BSTR propertyId = NULL;

   try {

      hr = pPropertyObj->get_Id(&propertyId);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - AddProperty() - CSdoPropertyClass::get_Id() failed...");
         return hr;
      }
      PropertyMapIterator p = m_propertyMap.find(propertyId);
      _ASSERT( p == m_propertyMap.end() );
      if ( p == m_propertyMap.end() )
      {
         pair<PropertyMapIterator, bool> thePair = m_propertyMap.insert(PropertyMap::value_type(propertyId, static_cast<ISdoPropertyInfo*>(pPropertyObj)));
         if ( true == thePair.second )
            hr = S_OK;
      }
      else
      {
         IASTracePrintf("Error in SDO Schema - AddProperty() - Property was already defined...");
      }

      SysFreeString(propertyId);
   }
   catch(...)
   {
      if ( NULL != propertyId )
         SysFreeString(propertyId);
      throw;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::AddClass(
                /*[in]*/ PSDO_CLASS_OBJ pClassObj
                     )
{
   HRESULT hr = E_FAIL;
   BSTR classId = NULL;

   try {

      hr = pClassObj->get_Id(&classId);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - AddClass() - CSdoSchemaClass::get_Id() failed...");
         return hr;
      }

      ClassMapIterator p = m_classMap.find(classId);
      _ASSERT( p == m_classMap.end() );
      if ( p == m_classMap.end() )
      {
         pair<ClassMapIterator, bool> thePair = m_classMap.insert(ClassMap::value_type(classId, static_cast<ISdoClassInfo*>(pClassObj)));
         if ( true == thePair.second )
            hr = S_OK;
      }
      else
      {
         IASTracePrintf("Error in SDO Schema - AddClass() - Class was already defined...");
      }

      SysFreeString(classId);
   }
   catch(...)
   {
      if ( NULL != classId )
         SysFreeString(classId);
      throw;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::InitializeClasses()
{
   HRESULT hr = S_OK;
   ClassMapIterator p = m_classMap.begin();
   while ( p != m_classMap.end() )
   {
      hr = (static_cast<CSdoSchemaClass*>((*p).second))->Initialize(static_cast<ISdoSchema*>(this));
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - InitializeClasses() - CSdoSchema::Initialize() failed...");
         break;
      }
      p++;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
void CSdoSchema::DestroyClasses()
{
   ClassMapIterator p = m_classMap.begin();
   while ( p != m_classMap.end() )
   {
      ((*p).second)->Release();
      p = m_classMap.erase(p);
   }
}

//////////////////////////////////////////////////////////////////////////////
void CSdoSchema::DestroyProperties()
{
   PropertyMapIterator p = m_propertyMap.begin();
   while ( p != m_propertyMap.end() )
   {
      ((*p).second)->Release();
      p = m_propertyMap.erase(p);
   }
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::BuildInternalProperties()
{
   HRESULT hr = S_OK;
   PSCHEMA_PROPERTY_INFO pPropertyInfo = InternalProperties;
   while ( NULL != pPropertyInfo->lpszName )
   {
      auto_ptr <SDO_PROPERTY_OBJ> pPropertyObj (new SDO_PROPERTY_OBJ);
      if ( NULL == pPropertyObj.get())
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalProperties() - Could not alloc memory for property...");
         hr = E_FAIL;
         break;
      }
      hr = pPropertyObj->Initialize(pPropertyInfo);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalProperties() - property initialization failed...");
         break;
      }
      hr = AddProperty(pPropertyObj.get());
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalProperties() - AddProperty() failed...");
         break;
      }
        pPropertyObj.release ();
      pPropertyInfo++;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::BuildInternalClasses()
{
   HRESULT hr = S_OK;
   PSCHEMA_CLASS_INFO pClassInfo = InternalClasses;
   while ( NULL != pClassInfo->lpszClassId )
   {
      auto_ptr <SDO_CLASS_OBJ> pClassObj (new SDO_CLASS_OBJ);
      if ( NULL == pClassObj.get())
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalClasses() - Could not alloc memory for class...");
         hr = E_FAIL;
         break;
      }
      hr = pClassObj->Initialize(pClassInfo, static_cast<ISdoSchema*>(this));
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalClasses() - Class initialization failed...");
         break;
      }
      hr = AddClass(pClassObj.get());
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema - BuildInternalClasses() - AddClass() failed...");
         break;
      }
        pClassObj.release ();
      pClassInfo++;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::BuildSchemaProperties(
                           /*[in]*/ IDataStoreObject* pSchema
                                 )
{
   HRESULT hr = E_FAIL;
   do
   {
      SDO_TRACE_VERBOSE_0("Building SDO Schema Properties...");

      CComPtr<IDataStoreObject> pProperties;
      _bstr_t bstrName = SDO_SCHEMA_PROPERTIES_CONTAINER;
      hr = ::SDOGetContainedObject(bstrName, pSchema, &pProperties);
      if ( FAILED(hr) )
         break;

      CComPtr<IEnumVARIANT> pPropertiesEnum;
      hr = ::SDOGetContainerEnumerator(pProperties, &pPropertiesEnum);
      if ( FAILED(hr) )
         break;

      CComPtr<IDataStoreObject> pPropertyDataStore;
      hr = ::SDONextObjectFromContainer(pPropertiesEnum, &pPropertyDataStore);
      while ( S_OK == hr )
      {
         auto_ptr <SDO_PROPERTY_OBJ> pPropertyObj (new SDO_PROPERTY_OBJ);
         if ( NULL == pPropertyObj.get())
         {
            IASTracePrintf("Error in SDO Schema - BuildProperties() - Could not alloc memory for property...");
            hr = E_FAIL;
            break;
         }
         hr = pPropertyObj->Initialize(pPropertyDataStore);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema - BuildProperties() - InitNew() failed...");
            break;
         }
         hr = AddProperty(pPropertyObj.get());
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema - BuildProperties() - AddProperty() failed...");
            break;
         }
            pPropertyObj.release ();
         pPropertyDataStore.Release();
         hr = ::SDONextObjectFromContainer(pPropertiesEnum, &pPropertyDataStore);
      }
      if ( S_FALSE == hr )
         hr = S_OK;

   } while (FALSE);

   if ( FAILED(hr) )
      DestroyProperties();

   return hr;

}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchema::BuildSchemaClasses(
                        /*[in]*/ IDataStoreObject* pSchema
                               )
{
   HRESULT hr = E_FAIL;
   do
   {
      SDO_TRACE_VERBOSE_0("Building SDO Schema Classes...");

      CComPtr<IDataStoreObject> pClasses;
      _bstr_t bstrName = SDO_SCHEMA_CLASSES_CONTAINER;
      hr = ::SDOGetContainedObject(bstrName, pSchema, &pClasses);
      if ( FAILED(hr) )
         break;

      CComPtr<IEnumVARIANT>   pClassesEnum;
      hr = ::SDOGetContainerEnumerator(pClasses, &pClassesEnum);
      if ( FAILED(hr) )
         break;

      CComPtr<IDataStoreObject> pClassDataStore;
      hr = ::SDONextObjectFromContainer(pClassesEnum, &pClassDataStore);
      while ( S_OK == hr )
      {
         auto_ptr <SDO_CLASS_OBJ> pClassObj (new SDO_CLASS_OBJ);
         if ( NULL == pClassObj.get())
         {
            IASTracePrintf("Error in SDO Schema - BuildSchemaClasses() - Could not alloc memory for class...");
            hr = E_FAIL;
            break;
         }
         hr = pClassObj->InitNew(pClassDataStore, static_cast<ISdoSchema*>(this));
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema - BuildSchemaClasses() - InitNew() failed...");
            break;
         }
         hr = AddClass(pClassObj.get());
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema - BuildSchemaClasses() - AddClass() failed...");
            break;
         }
            pClassObj.release ();
         pClassDataStore.Release();
         hr = ::SDONextObjectFromContainer(pClassesEnum, &pClassDataStore);
      }
      if ( S_FALSE == hr )
         hr = InitializeClasses();

   } while (FALSE);

   if ( FAILED(hr) )
      DestroyClasses();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
//                     SCHEMA CLASS IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CSdoSchemaClass::CSdoSchemaClass()
: m_state(SCHEMA_OBJECT_SHUTDOWN)
{
   InternalAddRef();
}

//////////////////////////////////////////////////////////////////////////////
CSdoSchemaClass::~CSdoSchemaClass()
{
   FreeProperties();
}


//////////////////////////
// ISdoClassInfo Functions


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::get_Id(
                      /*[in]*/ BSTR* Id
                             )
{
   _ASSERT( NULL != Id && SCHEMA_OBJECT_SHUTDOWN != m_state );
   if ( NULL != Id && SCHEMA_OBJECT_SHUTDOWN != m_state )
   {
      BSTR retVal = SysAllocString(m_id.c_str());
      if ( NULL != retVal )
      {
         *Id = retVal;
         return S_OK;
      }
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::GetProperty(
                           /*[in]*/ LONG alias,
                           /*[in]*/ IUnknown** ppSdoPropertyInfo
                                  )
{
   _ASSERT( NULL != ppSdoPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state );

   HRESULT hr = E_FAIL;
   if ( NULL != ppSdoPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      try
      {
         ClassPropertyMapIterator p;
         p = m_requiredProperties.find(alias);
         if ( p != m_requiredProperties.end() )
         {
            (*ppSdoPropertyInfo = (*p).second)->AddRef();
            hr = S_OK;
         }
         else
         {
            p = m_optionalProperties.find(alias);
            _ASSERT ( p != m_optionalProperties.end() );
            if ( p != m_optionalProperties.end() )
            {
               (*ppSdoPropertyInfo = (*p).second)->AddRef();
               hr = S_OK;
            }
            else
            {
               IASTracePrintf("Error in SDO Schema Class - get_Property() - Unknown property alias...");
            }
         }
      }
      catch(...)
      {
         IASTracePrintf("Error in SDO Schema Class - get_Property() - Caught unknown exception...");
      }
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::get_RequiredPropertyCount(
                                             /*[in]*/ LONG* count
                                                    )
{
   _ASSERT( NULL != count && SCHEMA_OBJECT_INITIALIZED == m_state );

   HRESULT hr = E_FAIL;
   if ( NULL != count && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      *count = m_requiredProperties.size();
      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::get_RequiredProperties(
                                     /*[in]*/ IUnknown** ppPropertyInfo
                                            )
{
   _ASSERT( NULL != ppPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state );

   HRESULT hr = E_FAIL;
   EnumVARIANT* newEnum = NULL;

   if ( NULL != ppPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      try
      {
         VARIANT   property;
         vector<_variant_t> properties;
         VariantInit(&property);
         ClassPropertyMapIterator p = m_requiredProperties.begin();
         while ( p != m_requiredProperties.end() )
         {
            V_VT(&property) = VT_DISPATCH;
            V_DISPATCH(&property) = dynamic_cast<IDispatch*>((*p).second);
            properties.push_back(property);
            p++;
         }
         newEnum = new (std::nothrow) CComObject<EnumVARIANT>;
         if (newEnum == NULL)
         {
            IASTracePrintf("Error in SDO Schema Class - get__NewEnum() - Out of memory...");
            return E_OUTOFMEMORY;
         }
         hr = newEnum->Init(
                        properties.begin(),
                        properties.end(),
                        static_cast<IUnknown*>(this),
                        AtlFlagCopy
                       );
         if ( SUCCEEDED(hr) )
         {
            (*ppPropertyInfo = newEnum)->AddRef();
            return S_OK;
         }
      }
      catch(...)
      {
         IASTracePrintf("Error in SDO Schema Class - get__NewEnum() - Caught unknown exception...");
         hr = E_FAIL;
      }

      if ( newEnum )
         delete newEnum;
   }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::get_OptionalPropertyCount(
                                             /*[in]*/ LONG* count
                                                    )
{
   _ASSERT( NULL != count && SCHEMA_OBJECT_INITIALIZED == m_state );

   HRESULT hr = E_FAIL;
   if ( NULL != count && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      *count = m_optionalProperties.size();
      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaClass::get_OptionalProperties(
                                     /*[in]*/ IUnknown** ppPropertyInfo
                                            )
{
   _ASSERT( NULL != ppPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state );

   HRESULT hr = E_FAIL;
   EnumVARIANT* newEnum = NULL;

   if ( NULL != ppPropertyInfo && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      try
      {
         VARIANT   property;
         vector<_variant_t> properties;
         VariantInit(&property);
         ClassPropertyMapIterator p = m_optionalProperties.begin();
         while ( p != m_optionalProperties.end() )
         {
            V_VT(&property) = VT_DISPATCH;
            V_DISPATCH(&property) = dynamic_cast<IDispatch*>((*p).second);
            properties.push_back(property);
            p++;
         }
         newEnum = new (std::nothrow) CComObject<EnumVARIANT>;
         if (newEnum == NULL)
         {
            IASTracePrintf("Error in SDO Schema Class - get__NewEnum() - Out of memory...");
            return E_OUTOFMEMORY;
         }
         hr = newEnum->Init(
                        properties.begin(),
                        properties.end(),
                        static_cast<IUnknown*>(this),
                        AtlFlagCopy
                       );
         if ( SUCCEEDED(hr) )
         {
            (*ppPropertyInfo = newEnum)->AddRef();
            return S_OK;
         }
      }
      catch(...)
      {
         IASTracePrintf("Error in SDO Schema Class - get__NewEnum() - Caught unknown exception...");
         hr = E_FAIL;
      }

      if ( newEnum )
         delete newEnum;
   }

    return hr;
}


/////////////////////
// Private Functions


//////////////////////////////////////////////////////////////////////////////
void CSdoSchemaClass::FreeProperties()
{
   ClassPropertyMapIterator p;
   p = m_requiredProperties.begin();
   while ( p != m_requiredProperties.end() )
   {
      ((*p).second)->Release();
      p = m_requiredProperties.erase(p);
   }
   p = m_optionalProperties.begin();
   while ( p != m_optionalProperties.end() )
   {
      ((*p).second)->Release();
      p = m_optionalProperties.erase(p);
   }

}

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchemaClass::ReadClassProperties(
                            /*[in]*/ IDataStoreObject* pDSClass
                                   )
{
   HRESULT hr = E_FAIL;

   do
   {
      _variant_t vtValue;
      _variant_t vtName = SDO_SCHEMA_CLASS_ID;
      hr = pDSClass->GetValue(V_BSTR(&vtName), &vtValue);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Class - InitNew() - IDataStoreObject::GetValue(Name) failed...");
         break;
      }
      m_id = V_BSTR(&vtValue);

      SDO_TRACE_VERBOSE_1("Initializing Schema Class: '%ls'...",m_id.c_str());

      vtName = SDO_SCHEMA_CLASS_BASE_CLASSES;
      hr = pDSClass->GetValueEx(V_BSTR(&vtName), &m_variants[VARIANT_BASES]);
      if ( FAILED(hr) )
      {
         if ( DISP_E_MEMBERNOTFOUND != hr )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - IDataStoreObject::GetValueEx(BASE_CLASSES) failed...");
            break;
         }
      }
      else
      {
         _ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(&m_variants[VARIANT_BASES]) );
         if ( (VT_ARRAY | VT_VARIANT) != V_VT(&m_variants[VARIANT_BASES]) )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - Invalid data type (BASE_CLASSES)...");
            hr = E_FAIL;
            break;
         }

#ifdef DEBUG

         CVariantVector<VARIANT> properties(&m_variants[VARIANT_BASES]);
         DWORD count = 0;
         while ( count < properties.size() )
         {
            _ASSERT( VT_BSTR == properties[count].vt );
            count++;
         }
#endif
      }

      vtName = SDO_SCHEMA_CLASS_REQUIRED_PROPERTIES;
      hr = pDSClass->GetValueEx(V_BSTR(&vtName), &m_variants[VARIANT_REQUIRED]);
      if ( FAILED(hr) )
      {
         if ( DISP_E_MEMBERNOTFOUND != hr )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - IDataStoreObject::GetValueEx(REQUIRED_PROPERTIES) failed...");
            break;
         }
      }
      else
      {
         _ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(&m_variants[VARIANT_REQUIRED]) );
         if ( (VT_ARRAY | VT_VARIANT) != V_VT(&m_variants[VARIANT_REQUIRED]) )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - Invalid data type (REQUIRED_PROPERTIES)...");
            hr = E_FAIL;
            break;
         }

#ifdef DEBUG

         CVariantVector<VARIANT> properties(&m_variants[VARIANT_REQUIRED]);
         DWORD count = 0;
         while ( count < properties.size() )
         {
            _ASSERT( VT_BSTR == properties[count].vt );
            count++;
         }
#endif
      }

      vtName = SDO_SCHEMA_CLASS_OPTIONAL_PROPERTIES;
      hr = pDSClass->GetValueEx(V_BSTR(&vtName), &m_variants[VARIANT_OPTIONAL]);
      if ( FAILED(hr) )
      {
         if ( DISP_E_MEMBERNOTFOUND != hr )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - IDataStoreObject::GetValueEx(OPTIONAL_PROPERTIES) failed...");
            break;
         }
         hr = S_OK; // Class has no optional properties
      }
      else
      {
         _ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(&m_variants[VARIANT_OPTIONAL]) );
         if ( (VT_ARRAY | VT_VARIANT) != V_VT(&m_variants[VARIANT_OPTIONAL]) )
         {
            IASTracePrintf("Error in SDO Schema Class - InitNew() - Invalid data type (OPTIONAL_PROPERTIES)...");
            hr = E_FAIL;
         }

#ifdef DEBUG

         CVariantVector<VARIANT> properties(&m_variants[VARIANT_OPTIONAL]);
         DWORD count = 0;
         while ( count < properties.size() )
         {
            _ASSERT( VT_BSTR == properties[count].vt );
            count++;
         }
#endif
      }

   } while (FALSE);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchemaClass::AddProperty(
                     /*[in]*/ CLASSPROPERTYSET  ePropertySet,
                     /*[in]*/ ISdoPropertyInfo* pSdoPropertyInfo
                             )
{
   LONG alias;
   HRESULT hr = pSdoPropertyInfo->get_Alias(&alias);
   if ( FAILED(hr) )
   {
      IASTracePrintf("Error in SDO Schema Class - InitNew() - get_Alias() failed...");
      return hr;
   }

   ClassPropertyMapIterator p, q;

   if ( PROPERTY_SET_REQUIRED == ePropertySet )
   {
      p = m_requiredProperties.find(alias);
      q = m_requiredProperties.end();
   }
   else
   {
      _ASSERT( PROPERTY_SET_OPTIONAL == ePropertySet );
      p = m_optionalProperties.find(alias);
      q = m_optionalProperties.end();
   }

   _ASSERT( p == q );
   if ( p == q )
   {
      pair<ClassPropertyMapIterator, bool> thePair;

      if ( PROPERTY_SET_REQUIRED == ePropertySet )
         thePair = m_requiredProperties.insert(ClassPropertyMap::value_type(alias, pSdoPropertyInfo));
      else
         thePair = m_optionalProperties.insert(ClassPropertyMap::value_type(alias, pSdoPropertyInfo));

      if ( true == thePair.second )
      {
         pSdoPropertyInfo->AddRef();   // AddRef() AFTER item has been added to the property map...
         hr = S_OK;
      }
   }
   else
   {
      IASTracePrintf("Error in SDO Schema Class - AddProperty() - Property was already defined...");
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoSchemaClass::AddBaseClassProperties(
                              /*[in]*/ ISdoClassInfo* pSdoClassInfo
                                    )
{
   CComPtr<IEnumVARIANT> pPropertyEnum;
   HRESULT hr = ::SDOGetClassPropertyEnumerator(PROPERTY_SET_REQUIRED, pSdoClassInfo, &pPropertyEnum);
   if ( FAILED(hr) )
      return hr;

   CComPtr<ISdoPropertyInfo> pSdoPropertyInfo;

   hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
   while ( S_OK == hr )
   {
      hr = AddProperty(PROPERTY_SET_REQUIRED, pSdoPropertyInfo);
      if ( FAILED(hr) )
         break;
      pSdoPropertyInfo.Release();
      hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
   }
   if ( S_FALSE == hr )
   {
      pPropertyEnum.Release();

      hr = ::SDOGetClassPropertyEnumerator(PROPERTY_SET_OPTIONAL, pSdoClassInfo, &pPropertyEnum);
      if ( FAILED(hr) )
         return hr;

      hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
      while ( S_OK == hr )
      {
         hr = AddProperty(PROPERTY_SET_OPTIONAL, pSdoPropertyInfo);
         if ( FAILED(hr) )
            break;
         pSdoPropertyInfo.Release();
         hr = ::SDONextPropertyFromClass(pPropertyEnum, &pSdoPropertyInfo);
      }

      if ( S_FALSE == hr )
         return S_OK;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT   CSdoSchemaClass::InitNew(
                    /*[in]*/ IDataStoreObject* pDSClass,
                   /*[in]*/ ISdoSchema*      pSchema
                          )
{
   HRESULT hr = E_FAIL;

   do
   {
      _ASSERT( SCHEMA_OBJECT_SHUTDOWN == m_state );
      hr = ReadClassProperties(pDSClass);
      if ( FAILED(hr) )
         break;

      CComPtr<IUnknown> pUnknown;
      CComPtr<ISdoPropertyInfo> pSdoPropertyInfo;

      DWORD count = 0;

      if ( VT_EMPTY != V_VT(&m_variants[VARIANT_REQUIRED]) )
      {
         CVariantVector<VARIANT> properties(&m_variants[VARIANT_REQUIRED]);

         while ( count < properties.size() )
         {
            hr = pSchema->GetProperty(properties[count].bstrVal, &pUnknown);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - InitNew() - GetProperty(REQUIRED) failed...");
               break;
            }
            hr = pUnknown->QueryInterface(IID_ISdoPropertyInfo, (void**)&pSdoPropertyInfo);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - InitNew() - QueryInterface(REQUIRED) failed...");
               break;
            }
            hr = AddProperty(PROPERTY_SET_REQUIRED, pSdoPropertyInfo);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - InitNew() - AddProperty(REQUIRED) failed...");
               break;
            }
            pUnknown.Release();
            pSdoPropertyInfo.Release();
            count++;
         }
      }
      if ( SUCCEEDED(hr) )
      {
         if ( VT_EMPTY != V_VT(&m_variants[VARIANT_OPTIONAL]) )
         {
            count = 0;
            CVariantVector<VARIANT> properties(&m_variants[VARIANT_OPTIONAL]);

            while ( count < properties.size() )
            {
               hr = pSchema->GetProperty(properties[count].bstrVal, &pUnknown);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in SDO Schema Class - InitNew() - GetProperty(OPTIONAL) failed...");
                  break;
               }
               hr = pUnknown->QueryInterface(IID_ISdoPropertyInfo, (void**)&pSdoPropertyInfo);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in SDO Schema Class - InitNew() - QueryInterface(OPTIONAL) failed...");
                  break;
               }
               hr = AddProperty(PROPERTY_SET_OPTIONAL, pSdoPropertyInfo);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in SDO Schema Class - InitNew() - AddProperty(OPTIONAL) failed...");
                  break;
               }
               pUnknown.Release();
               pSdoPropertyInfo.Release();
               count++;
            }
         }
         if ( SUCCEEDED(hr) )
            m_state = SCHEMA_OBJECT_UNINITIALIZED;
      }

   } while (FALSE);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT   CSdoSchemaClass::Initialize(
                     /*[in]*/ ISdoSchema* pSchema
                             )
{
   HRESULT hr = S_OK;
   _ASSERT( SCHEMA_OBJECT_SHUTDOWN != m_state );
   if ( SCHEMA_OBJECT_UNINITIALIZED == m_state )
   {
      if ( VT_EMPTY != V_VT(&m_variants[VARIANT_BASES]) )
      {
         hr = E_FAIL;
         CVariantVector<VARIANT> classes(&m_variants[VARIANT_BASES]);
         CComPtr<ISdoClassInfo> pSdoClassInfo;
         CComPtr<IUnknown> pUnknown;
         DWORD count = 0;
         while ( count < classes.size() )
         {
            hr = pSchema->GetClass(classes[count].bstrVal, &pUnknown);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - Inititalize() - GetClass() failed...");
               break;
            }
            hr = pUnknown->QueryInterface(IID_ISdoClassInfo, (void**)&pSdoClassInfo);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - Inititalize() - QueryInterface() failed...");
               break;
            }
            hr = AddBaseClassProperties(pSdoClassInfo);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in SDO Schema Class - Inititalize() - AddBaseClassProperties() failed...");
               break;
            }
            pUnknown.Release();
            pSdoClassInfo.Release();
            count++;
         }
      }
      if ( SUCCEEDED(hr) )
         m_state = SCHEMA_OBJECT_INITIALIZED;
   }

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT   CSdoSchemaClass::Initialize(
                     /*[in]*/ PSCHEMA_CLASS_INFO   pClassInfo,
                     /*[in]*/ ISdoSchema*      pSchema
                             )
{
   _ASSERT( SCHEMA_OBJECT_SHUTDOWN == m_state );

   HRESULT hr = S_OK;
   CComPtr<IUnknown> pUnknown;
   CComPtr<ISdoPropertyInfo> pSdoPropertyInfo;

   m_id = pClassInfo->lpszClassId;

   PCLASSPROPERTIES pRequiredProperties = pClassInfo->pRequiredProperties;
   while ( NULL != pRequiredProperties[0] )
   {
      hr = pSchema->GetProperty((LPWSTR)pRequiredProperties[0], &pUnknown);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Class - Inititialize() - GetProperty(REQUIRED) failed...");
         break;
      }
      hr = pUnknown->QueryInterface(IID_ISdoPropertyInfo, (void**)&pSdoPropertyInfo);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Class - Initialize() - QueryInterface(REQUIRED) failed...");
         break;
      }
      hr = AddProperty(PROPERTY_SET_REQUIRED, pSdoPropertyInfo);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Class - Initialize() - AddProperty(REQUIRED) failed...");
         break;
      }
      pUnknown.Release();
      pSdoPropertyInfo.Release();
      pRequiredProperties++;
   }
   if ( SUCCEEDED(hr) )
   {
      PCLASSPROPERTIES pOptionalProperties = pClassInfo->pOptionalProperties;
      while ( NULL != pOptionalProperties[0] )
      {
         hr = pSchema->GetProperty((LPWSTR)pOptionalProperties[0], &pUnknown);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Class - Inititialize() - GetProperty(OPTIONAL) failed...");
            break;
         }
         hr = pUnknown->QueryInterface(IID_ISdoPropertyInfo, (void**)&pSdoPropertyInfo);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Class - Initialize() - QueryInterface(OPTIONAL) failed...");
            break;
         }
         hr = AddProperty(PROPERTY_SET_OPTIONAL, pSdoPropertyInfo);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Class - Initialize() - AddProperty(OPTIONAL) failed...");
            break;
         }
         pUnknown.Release();
         pSdoPropertyInfo.Release();
         pOptionalProperties++;
      }

      if ( SUCCEEDED(hr) )
         m_state = SCHEMA_OBJECT_INITIALIZED;
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
//                     SCHEMA PROPERTY IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CSdoSchemaProperty::CSdoSchemaProperty()
: m_state(SCHEMA_OBJECT_SHUTDOWN),
  m_type(0),
  m_alias(0),
  m_flags(0),
  m_minLength(0),
  m_maxLength(0)
{
   InternalAddRef();
}

//////////////////////////////////////////////////////////////////////////////
CSdoSchemaProperty::~CSdoSchemaProperty()
{

}

/////////////////////////////
// ISdoPropertyInfo Functions

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Name(
                         /*[out]*/ BSTR* name
                                 )
{
   _ASSERT( NULL != name && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != name && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      BSTR retVal = SysAllocString(m_name.c_str());
      if ( NULL != retVal )
      {
         *name = retVal;
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Id(
                        /*[out]*/ BSTR* id
                                )
{
   _ASSERT( NULL != id && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != id && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      BSTR retVal = SysAllocString(m_id.c_str());
      if ( NULL != retVal )
      {
         *id = retVal;
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Type(
                         /*[out]*/ LONG* type
                                 )
{
   _ASSERT( NULL != type && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != type && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      *type = m_type;
      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Alias(
                         /*[out]*/ LONG* alias
                                 )
{
   _ASSERT( NULL != alias && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != alias && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      *alias = m_alias;
      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Flags(
                         /*[out]*/ LONG* flags
                                  )
{
   _ASSERT( NULL != flags && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != flags && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      *flags = m_flags;
      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_DisplayName(
                                 /*[out]*/ BSTR* displayName
                                         )
{
   _ASSERT( NULL != displayName && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != displayName && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      BSTR retVal = SysAllocString(m_displayName.c_str());
      if ( NULL != retVal )
      {
         *displayName = retVal;
         return S_OK;
      }
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasMinLength(
                                  /*[out]*/ VARIANT_BOOL* pBool
                                       )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MAX_VALUE & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_MinLength(
                             /*[out]*/ LONG* length
                                     )
{
   _ASSERT( NULL != length && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != length && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MIN_LENGTH & m_flags )
      {
         *length = m_minLength;
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasMaxLength(
                                  /*[out]*/ VARIANT_BOOL* pBool
                                       )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MAX_LENGTH & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_MaxLength(
                             /*[out]*/ LONG* length
                                     )
{
   _ASSERT( NULL != length && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != length && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MAX_LENGTH & m_flags )
      {
         *length = m_maxLength;
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasMinValue(
                                 /*[out]*/ VARIANT_BOOL* pBool
                                      )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MIN_VALUE & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_MinValue(
                            /*[out]*/ VARIANT* value
                                    )
{
   _ASSERT( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MIN_VALUE & m_flags )
      {
         VariantInit(value);
         VariantCopy(value, &m_minValue);
         return S_OK;
      }
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasMaxValue(
                                 /*[out]*/ VARIANT_BOOL* pBool
                                      )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MAX_VALUE & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_MaxValue(
                            /*[out]*/ VARIANT* value
                                    )
{
   _ASSERT( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MAX_VALUE & m_flags )
      {
         VariantInit(value);
         VariantCopy(value, &m_maxValue);
         return S_OK;
      }
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasDefaultValue(
                                     /*[out]*/ VARIANT_BOOL* pBool
                                          )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_HAS_DEFAULT & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_DefaultValue(
                                /*[out]*/ VARIANT* value
                                        )
{
   _ASSERT( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != value && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_HAS_DEFAULT & m_flags )
      {
         VariantInit(value);
         return VariantCopy(value, &m_defaultValue);
      }
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::HasFormat(
                               /*[out]*/ VARIANT_BOOL* pBool
                                     )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_FORMAT & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::get_Format(
                             /*[out]*/ BSTR* Format
                                     )
{
   _ASSERT( NULL != Format && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != Format && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_FORMAT & m_flags )
      {
         BSTR retVal = SysAllocString(m_format.c_str());
         if ( NULL != retVal )
         {
            *Format = retVal;
            return S_OK;
         }
      }
   }
   return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::IsRequired(
                                /*[out]*/ VARIANT_BOOL* pBool
                                     )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MANDATORY & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::IsReadOnly(
                                /*[out]*/ VARIANT_BOOL* pBool
                                     )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_READ_ONLY & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::IsMultiValued(
                                   /*[out]*/ VARIANT_BOOL* pBool
                                        )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_MULTIVALUED & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoSchemaProperty::IsCollection(
                                   /*[out]*/ VARIANT_BOOL* pBool
                                       )
{
   _ASSERT( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state );
   if ( NULL != pBool && SCHEMA_OBJECT_INITIALIZED == m_state )
   {
      if ( SDO_PROPERTY_COLLECTION & m_flags )
         *pBool = VARIANT_TRUE;
      else
         *pBool = VARIANT_FALSE;

      return S_OK;
   }
   return E_FAIL;
}


//////////////////
// Private methods

//////////////////////////////////////////////////////////////////////////////
HRESULT   CSdoSchemaProperty::Initialize(
                        /*[in]*/ IDataStoreObject* pDSObject
                               )
{
   HRESULT      hr = E_FAIL;

   _ASSERT ( SCHEMA_OBJECT_SHUTDOWN == m_state );
   do
   {
      _variant_t   vtValue;
      _variant_t   vtName;

      vtName = SDO_SCHEMA_PROPERTY_NAME;
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read property name...");
         break;
      }
      m_name = V_BSTR(&vtValue);


      SDO_TRACE_VERBOSE_1("Initializing Schema Property: '%ls'...", m_name.c_str());

      vtName = SDO_SCHEMA_PROPERTY_ID;
      vtValue.Clear();
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( SUCCEEDED(hr) )
      {
         m_id = V_BSTR(&vtValue);
      }
      else
      {
         m_id = m_name;
      }

      vtName = SDO_SCHEMA_PROPERTY_TYPE;
      vtValue.Clear();
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read property type...");
         break;
      }
      m_type = V_I4(&vtValue);

      vtName = SDO_SCHEMA_PROPERTY_ALIAS;
      vtValue.Clear();
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read property alias...");
         break;
      }
      m_alias = V_I4(&vtValue);

      vtName = SDO_SCHEMA_PROPERTY_FLAGS;
      vtValue.Clear();
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( SUCCEEDED(hr) )
      {
         m_flags = V_I4(&vtValue);
      }
      else
      {
         m_flags = 0;
      }

      vtName = SDO_SCHEMA_PROPERTY_DISPLAYNAME;
      vtValue.Clear();
      hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
      if ( SUCCEEDED(hr) )
      {
         m_displayName = V_BSTR(&vtValue);
      }
      else
      {
         m_displayName = m_name;
      }
      hr = S_OK;

      if ( m_flags & SDO_PROPERTY_MIN_VALUE )
      {
         vtName = SDO_SCHEMA_PROPERTY_MINVAL;
         vtValue.Clear();
         hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read min value for property %ls...", m_name.c_str());
            break;
         }
         m_minValue = vtValue;
      }

      if ( m_flags & SDO_PROPERTY_MIN_VALUE )
      {
         vtName = SDO_SCHEMA_PROPERTY_MAXVAL;
         vtValue.Clear();
         hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read max value for property %ls...", m_name.c_str());
            break;
         }
         m_maxValue = vtValue;
      }

      if ( m_flags & SDO_PROPERTY_MIN_LENGTH )
      {
         vtName = SDO_SCHEMA_PROPERTY_MINLENGTH;
         vtValue.Clear();
         hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read min length for property %ls...", m_name.c_str());
            break;
         }
         m_minLength = V_I4(&vtValue);
      }

      if ( m_flags & SDO_PROPERTY_MAX_LENGTH )
      {
         vtName = SDO_SCHEMA_PROPERTY_MAXLENGTH;
         vtValue.Clear();
         hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read max length for property %ls...", m_name.c_str());
            break;
         }
         m_maxLength = V_I4(&vtValue);
      }

      _ASSERT ( m_minLength <= m_maxLength );

      if ( m_flags & SDO_PROPERTY_HAS_DEFAULT )
      {
         vtName = SDO_SCHEMA_PROPERTY_DEFAULTVAL;
         vtValue.Clear();
         if ( m_flags & SDO_PROPERTY_MULTIVALUED )
            hr = pDSObject->GetValueEx(V_BSTR(&vtName), &vtValue);
         else
            hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read default value for property %ls...", m_name.c_str());
            break;
         }
         m_defaultValue = vtValue;
      }

      if ( m_flags & SDO_PROPERTY_FORMAT )
      {
         vtName = SDO_SCHEMA_PROPERTY_FORMAT;
         vtValue.Clear();
         hr = pDSObject->GetValue(V_BSTR(&vtName), &vtValue);
         if ( FAILED(hr) )
         {
            IASTracePrintf("Error in SDO Schema Property - Initialize() - Could not read format string for property %ls...", m_name.c_str());
            break;
         }
         m_format = V_BSTR(&vtValue);
      }

      m_state = SCHEMA_OBJECT_INITIALIZED;

   } while ( FALSE );

   return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT   CSdoSchemaProperty::Initialize(
                        /*[in]*/ PSCHEMA_PROPERTY_INFO pPropertyInfo
                               )
{
   _ASSERT ( SCHEMA_OBJECT_SHUTDOWN == m_state );

   _ASSERT( pPropertyInfo->lpszName );
   m_name = pPropertyInfo->lpszName;
   _ASSERT( pPropertyInfo->Id );
   m_id = pPropertyInfo->Id;
   m_type = pPropertyInfo->Syntax;
   m_alias = pPropertyInfo->Alias;
   m_flags = pPropertyInfo->Flags;
   m_minLength = pPropertyInfo->MinLength;
   m_maxLength = pPropertyInfo->MaxLength;
   _ASSERT( m_minLength <= m_maxLength );
   _ASSERT( pPropertyInfo->lpszDisplayName );
   m_displayName = pPropertyInfo->lpszDisplayName;

   m_state = SCHEMA_OBJECT_INITIALIZED;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoproperty.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoproperty.h
//
// Project:     Everest
//
// Description: IAS Server Data Object Property Declarations
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_SDO_PROPERTY_H_
#define _INC_SDO_PROPERTY_H_

#include <ias.h>
#include <sdoiaspriv.h>
#include <comutil.h>
#include <comdef.h>
#include <fa.hxx>
#include "resource.h"

#include <string>
using namespace std;

////////////////////////////////////////////
// SDO property flag definitions
////////////////////////////////////////////
#define		SDO_PROPERTY_POINTER	    0x0001	// Property is an IUnknown pointer  

#define		SDO_PROPERTY_COLLECTION     0x0002  // Property is an SDO collection 

#define     SDO_PROPERTY_MIN_VALUE      0x0004  // Property has a minimum value

#define     SDO_PROPERTY_MAX_VALUE      0x0008  // Property has a maximum value

#define     SDO_PROPERTY_MIN_LENGTH     0x0010  // Property has a minium length

#define     SDO_PROPERTY_MAX_LENGTH     0x0020  // Property has a maximum length

#define     SDO_PROPERTY_MANDATORY      0x0040  // Property is mandatory (required)

#define		SDO_PROPERTY_NO_PERSIST		0x0080	// Property cannot be persisted

#define     SDO_PROPERTY_READ_ONLY      0x0100  // Property is read only

#define		SDO_PROPERTY_MULTIVALUED	0x0200  // Property is multi-valued

#define		SDO_PROPERTY_HAS_DEFAULT	0x0400  // Property has a default value

#define		SDO_PROPERTY_COMPONENT		0x0800  // Property is used by IAS component

#define		SDO_PROPERTY_FORMAT			0x1000  // Property has a format string


/////////////////////////////////////////////////////////////////////////////
// Server Data Object Property Class - Holds a Single Property
/////////////////////////////////////////////////////////////////////////////
class CSdoProperty
{
	CComPtr<ISdoPropertyInfo>	m_pSdoPropertyInfo;
	CComBSTR						m_name;				
	LONG						m_alias;			
	DWORD						m_flags;		
    BOOL						m_dirty;		
    VARTYPE						m_type;			
	DWORD						m_index;		
	ULONG						m_minLength;	
	ULONG						m_maxLength;	
	CDFA*						m_dfa;		    // Formating
	_variant_t					m_minValue;		
	_variant_t					m_maxValue;		
	_variant_t					m_defaultValue;	
    _variant_t					m_value[2];		// Property values (facilitate safe load)
												// See GetUpdateValue() / SetUpdateValue()
public:

    CSdoProperty(
			     ISdoPropertyInfo* pSdoPropertyInfo,
		         DWORD             dwFlags = 0 
			    ) throw (_com_error);

    ~CSdoProperty();

	//////////////////////////////////////////////////////////////////////////
    ISdoPropertyInfo* GetPropertyInfo(void) const
    { return m_pSdoPropertyInfo.p; }

	//////////////////////////////////////////////////////////////////////////
    BSTR GetName(void) const
    { return m_name; }

	//////////////////////////////////////////////////////////////////////////
    HRESULT GetValue(VARIANT *value) throw(_com_error)
    { 
		HRESULT hr = VariantCopy(value, &m_value[m_index]); 
		return hr; 
	}

	//////////////////////////////////////////////////////////////////////////
    VARIANT* GetValue(void) throw()
    { return &m_value[m_index]; }

	//////////////////////////////////////////////////////////////////////////
    HRESULT PutValue(VARIANT* value) throw(_com_error)
    { 
		m_value[m_index] = value; 
		m_dirty = TRUE; 
		return S_OK; 
	}

	//////////////////////////////////////////////////////////////////////////
    HRESULT PutDefault(VARIANT* value) throw(_com_error)
    { 
		m_defaultValue = value; 
		return S_OK; 
	}

	//////////////////////////////////////////////////////////////////////////
	void ChangeType(VARTYPE vt) throw(_com_error)
	{ m_value[m_index].ChangeType(vt, NULL); }

	//////////////////////////////////////////////////////////////////////////
	LONG GetId(void) const
	{ return m_alias; }
	
	//////////////////////////////////////////////////////////////////////////
    DWORD GetFlags(void) const
    { return m_flags; }

	//////////////////////////////////////////////////////////////////////////
    void SetFlags(DWORD dwFlags)
    { m_flags = dwFlags; }

	//////////////////////////////////////////////////////////////////////////
    VARTYPE GetType(void) const
    { return m_type; }

	//////////////////////////////////////////////////////////////////////////
    BOOL IsDirty(void) const
    { return m_dirty; }

	//////////////////////////////////////////////////////////////////////////
    VOID SetType(VARTYPE vt)
    { m_type = vt; }

	//////////////////////////////////////////////////////////////////////////
    VOID SetMinLength(ULONG minLength)
    { m_minLength = minLength; }

	//////////////////////////////////////////////////////////////////////////
    VOID SetMaxLength(ULONG maxLength)
    { m_maxLength = maxLength; }

	//////////////////////////////////////////////////////////////////////////
    void Reset(void) throw(_com_error);

	//////////////////////////////////////////////////////////////////////////
    HRESULT Validate(VARIANT *newValue);
	
	//////////////////////////////////////////////////////////////////////////
	// The following functions are used to facilitate a safe load. 
	//////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////
	VARIANT* GetUpdateValue(void) throw()
	{ return (m_index > 0) ? &m_value[0] : &m_value[1]; }

	//////////////////////////////////////////////////////////////////////////
	void SetUpdateValue(void) throw()
	{ 
		VariantClear(&m_value[m_index]); 
		m_index = (m_index > 0) ? 0 : 1; 
	}

private:

    // Don't allow copy or assignment
    CSdoProperty(const CSdoProperty& rhs);
    CSdoProperty& operator=(CSdoProperty& rhs);

	/////////////////////////////////////////////////////////////////////////
    HRESULT ValidateIt(VARIANT *newValue);
};

typedef CSdoProperty  SDOPROPERTY;
typedef CSdoProperty* PSDOPROPERTY; 


#endif // _INC_SDO_PROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoschema.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoschema.h
//
// Project:      Everest
//
// Description:   SDO Schema Class Declaration
//
// Author:      TLP 9/1/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef _INC_SDO_SCHEMA_H_
#define _INC_SDO_SCHEMA_H_

#include <ias.h>
#include <sdoiaspriv.h>
#include <comdef.h>         // COM definitions - Needed for IEnumVARIANT
#include "sdohelperfuncs.h"
#include "sdo.h"
#include "resource.h"       // main symbols
#include "StdString.h"

#include <vector>
using namespace std;

//////////////////////////////////////////////////////////////////////
// SDO Schema Data Types
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
typedef struct _SCHEMA_PROPERTY_INFO
{
   LPCWSTR      lpszName;
   LPCWSTR      Id;
   LONG      Syntax;
   LONG      Alias;
   DWORD      Flags;
   DWORD      MinLength;
   DWORD      MaxLength;
   LPCWSTR      lpszDisplayName;

}   SCHEMA_PROPERTY_INFO, *PSCHEMA_PROPERTY_INFO;


//////////////////////////////////////////////////////////////////////

typedef LPCWSTR *PCLASSPROPERTIES;

typedef struct _SCHEMA_CLASS_INFO
{
   LPCWSTR            lpszClassId;
   PCLASSPROPERTIES   pRequiredProperties;
   PCLASSPROPERTIES   pOptionalProperties;

}   SCHEMA_CLASS_INFO, *PSCHEMA_CLASS_INFO;


//////////////////////////////////////////////////////////////////////
#define   BEGIN_SCHEMA_PROPERTY_MAP(x) \
   static SCHEMA_PROPERTY_INFO  x[] = {

//////////////////////////////////////////////////////////////////////
#define DEFINE_SCHEMA_PROPERTY(name, id, syntax, alias, flags, minLength, maxLength, displayName) \
                        {            \
                           name,      \
                           id,         \
                           syntax,      \
                           alias,      \
                           flags,      \
                           minLength,   \
                           maxLength,   \
                           displayName   \
                        },

//////////////////////////////////////////////////////////////////////
#define END_SCHEMA_PROPERTY_MAP                         \
                        {                     \
                           NULL,               \
                           NULL,               \
                           0,                  \
                           PROPERTY_SDO_RESERVED,   \
                           0,                  \
                           0,                  \
                           0,                  \
                           NULL               \
                        } };


//////////////////////////////////////////////////////////////////////
#define BEGIN_SCHEMA_CLASS_MAP(x) \
   static SCHEMA_CLASS_INFO x[] = {

//////////////////////////////////////////////////////////////////////
#define DEFINE_SCHEMA_CLASS(id, required, optional) \
                     {                  \
                         id,               \
                        required,         \
                        optional         \
                     },

//////////////////////////////////////////////////////////////////////
#define END_SCHEMA_CLASS_MAP                  \
                     {                  \
                        NULL,            \
                        NULL,            \
                        NULL            \
                     } };

//////////////////////////////////////////////////////////////////////
typedef enum _SCHEMA_OBJECT_STATE
{
   SCHEMA_OBJECT_SHUTDOWN,
   SCHEMA_OBJECT_UNINITIALIZED,
   SCHEMA_OBJECT_INITIALIZED

}   SCHEMA_OBJECT_STATE;


//////////////////////////////////////////
class CSdoSchema;   // Forward declaration
//////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSdoSchemaClass Declaration
/////////////////////////////////////////////////////////////////////////////

#define   SDO_SCHEMA_CLASS_ID                  L"ClassId"
#define SDO_SCHEMA_CLASS_BASE_CLASSES         L"BaseClasses"
#define SDO_SCHEMA_CLASS_REQUIRED_PROPERTIES   L"RequiredProperties"
#define SDO_SCHEMA_CLASS_OPTIONAL_PROPERTIES   L"OptionalProperties"

////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CSdoSchemaClass :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatchImpl<ISdoClassInfo, &IID_ISdoClassInfo, &LIBID_SDOIASLibPrivate>
{

friend   CSdoSchema;

public:

    CSdoSchemaClass();
   virtual ~CSdoSchemaClass();

// ATL Interface Map
BEGIN_COM_MAP(CSdoSchemaClass)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY(ISdoClassInfo)
END_COM_MAP()

   ////////////////////////
   // ISdoClassInfo Methods

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Id)(
          /*[out]*/ BSTR* Id
                  );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetProperty)(
               /*[in]*/ LONG alias,
              /*[out]*/ IUnknown** ppPropertyInfo
                      );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_RequiredPropertyCount)(
                            /*[out]*/ LONG* count
                                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_RequiredProperties)(
                        /*[out]*/ IUnknown** ppUnknown
                                );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_OptionalPropertyCount)(
                            /*[out]*/ LONG* count
                                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_OptionalProperties)(
                        /*[out]*/ IUnknown** ppUnknown
                                );

private:

   CSdoSchemaClass(const CSdoSchemaClass&);
   CSdoSchemaClass& operator = (CSdoSchemaClass&);

   /////////////////////////////////////////////////////////////////////////////
   HRESULT InitNew(
         /*[in]*/ IDataStoreObject* pDSClass,
          /*[in]*/ ISdoSchema*      pSchema
                );

   /////////////////////////////////////////////////////////////////////////////
    HRESULT   Initialize(
             /*[in]*/ ISdoSchema* pSchema
                   );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT Initialize(
             /*[in]*/ PSCHEMA_CLASS_INFO  pClassInfo,
             /*[in]*/ ISdoSchema*         pSchema
                 );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT AddProperty(
            /*[in]*/ CLASSPROPERTYSET  ePropertySet,
            /*[in]*/ ISdoPropertyInfo* pPropertyInfo
                   );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT AddBaseClassProperties(
                     /*[in]*/ ISdoClassInfo* pSdoClassInfo
                          );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT ReadClassProperties(
                   /*[in]*/ IDataStoreObject* pDSClass
                         );

   //////////////////////////////////////////////////////////////////////////////
   void FreeProperties(void);


    typedef map<LONG, ISdoPropertyInfo*> ClassPropertyMap;
    typedef ClassPropertyMap::iterator    ClassPropertyMapIterator;

   enum { VARIANT_BASES = 0, VARIANT_REQUIRED, VARIANT_OPTIONAL, VARIANT_MAX };

   SCHEMA_OBJECT_STATE      m_state;
   StdWString               m_id;
   _variant_t            m_variants[VARIANT_MAX];
   ClassPropertyMap      m_requiredProperties;
   ClassPropertyMap      m_optionalProperties;

}; // End of class cSdoSchemaClass

typedef CComObjectNoLock<CSdoSchemaClass>   SDO_CLASS_OBJ;
typedef CComObjectNoLock<CSdoSchemaClass>*   PSDO_CLASS_OBJ;


/////////////////////////////////////////////////////////////////////////////
// CSdoSchemaProperty Declaration
/////////////////////////////////////////////////////////////////////////////

#define   SDO_SCHEMA_PROPERTY_NAME         SDO_STOCK_PROPERTY_NAME
#define   SDO_SCHEMA_PROPERTY_ID            L"PropertyId"
#define   SDO_SCHEMA_PROPERTY_TYPE         L"Syntax"
#define   SDO_SCHEMA_PROPERTY_ALIAS         L"Alias"
#define   SDO_SCHEMA_PROPERTY_FLAGS         L"Flags"
#define   SDO_SCHEMA_PROPERTY_DISPLAYNAME      L"DisplayName"
#define   SDO_SCHEMA_PROPERTY_MINVAL         L"MinValue"
#define   SDO_SCHEMA_PROPERTY_MAXVAL         L"MaxValue"
#define   SDO_SCHEMA_PROPERTY_MINLENGTH      L"MinLength"
#define   SDO_SCHEMA_PROPERTY_MAXLENGTH      L"MaxLength"
#define   SDO_SCHEMA_PROPERTY_DEFAULTVAL      L"DefaultValue"
#define SDO_SCHEMA_PROPERTY_FORMAT         L"Format"

class ATL_NO_VTABLE CSdoSchemaProperty :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatchImpl<ISdoPropertyInfo, &IID_ISdoPropertyInfo, &LIBID_SDOIASLibPrivate>
{

friend   CSdoSchema;

public:

    CSdoSchemaProperty();
   virtual ~CSdoSchemaProperty();

// ATL Interface Map
BEGIN_COM_MAP(CSdoSchemaProperty)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY(ISdoPropertyInfo)
END_COM_MAP()

   // ISdoPropertyInfo Methods

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Name)(
              /*[out]*/ BSTR* Name
                      );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Id)(
           /*[out]*/ BSTR* Id
                  );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Type)(
             /*[out]*/ LONG* type
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Alias)(
              /*[out]*/ LONG* alias
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Flags)(
              /*[out]*/ LONG* flags
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_DisplayName)(
                    /*[out]*/ BSTR* displayName
                          );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasMinLength)(
                 /*[out]*/ VARIANT_BOOL* pBool
                         );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_MinLength)(
                  /*[out]*/ LONG* length
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasMaxLength)(
                 /*[out]*/ VARIANT_BOOL* pBool
                     );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_MaxLength)(
                  /*[out]*/ LONG* length
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasMinValue)(
                /*[out]*/ VARIANT_BOOL* pBool
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_MinValue)(
                 /*[out]*/ VARIANT* value
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasMaxValue)(
                /*[out]*/ VARIANT_BOOL* pBool
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_MaxValue)(
                 /*[out]*/ VARIANT* value
                       );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasDefaultValue)(
                   /*[out]*/ VARIANT_BOOL* pBool
                        );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_DefaultValue)(
                     /*[out]*/ VARIANT* value
                          );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(HasFormat)(
              /*[out]*/ VARIANT_BOOL* pBool
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(get_Format)(
                 /*[out]*/ BSTR* displayName
                       );


   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(IsRequired)(
             /*[out]*/ VARIANT_BOOL* pBool
                    );


   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(IsReadOnly)(
               /*[out]*/ VARIANT_BOOL* pBool
                    );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(IsMultiValued)(
                  /*[out]*/ VARIANT_BOOL* pBool
                      );

   //////////////////////////////////////////////////////////////////////////////
   STDMETHOD(IsCollection)(
                 /*[out]*/ VARIANT_BOOL* pBool
                     );

private:

   CSdoSchemaProperty(const CSdoSchemaProperty&);
   CSdoSchemaProperty& operator = (CSdoSchemaProperty&);

   //////////////////////////////////////////////////////////////////////////////
    HRESULT   Initialize(
             /*[in]*/ IDataStoreObject* pDSObject
                   );

   //////////////////////////////////////////////////////////////////////////////
   HRESULT Initialize(
             /*[in]*/ PSCHEMA_PROPERTY_INFO pPropertyInfo
                   );

   //////////////////////////////////////////////////////////////////////////////
   SCHEMA_OBJECT_STATE   m_state;
   StdWString            m_name;
   StdWString            m_id;
   StdWString            m_displayName;
   StdWString            m_format;
   LONG            m_type;
   LONG            m_alias;
   DWORD            m_flags;
   DWORD            m_minLength;
   DWORD            m_maxLength;
   _variant_t         m_minValue;
   _variant_t         m_maxValue;
   _variant_t         m_defaultValue;

};   // End of class CSdoSchemaProperty

typedef CComObjectNoLock<CSdoSchemaProperty>   SDO_PROPERTY_OBJ;
typedef CComObjectNoLock<CSdoSchemaProperty>*   PSDO_PROPERTY_OBJ;


/////////////////////////////////////////////////////////////////////////////
// CSdoSchema Declaration
/////////////////////////////////////////////////////////////////////////////

#define SDO_SCHEMA_ROOT_OBJECT            L"SDO Schema"
#define   SDO_SCHEMA_PROPERTIES_CONTAINER      L"SDO Schema Properties"
#define   SDO_SCHEMA_CLASSES_CONTAINER      L"SDO Schema Classes"

class ATL_NO_VTABLE CSdoSchema :
   public CComObjectRootEx<CComMultiThreadModel>,
   public IDispatchImpl<ISdoSchema, &IID_ISdoSchema, &LIBID_SDOIASLibPrivate>
{

friend HRESULT MakeSDOSchema(
                 /*[in]*/ IDataStoreContainer* pDSRootContainer,
                 /*[out*/ ISdoSchema**         ppSdoSchema
                        );

public:

    CSdoSchema();
   ~CSdoSchema();   // Don't plan to derive from this class...

// ATL Interface Map
BEGIN_COM_MAP(CSdoSchema)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY(ISdoSchema)
END_COM_MAP()


   /////////////////////////////////////////////////////////////////////////////
   HRESULT Initialize(
           /*[in]*/ IDataStoreObject* pSchemaDataStore
                   );

   ///////////////////////////
   // ISdoPropertyInfo Methods

    /////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetVersion)(
                /*[in]*/ BSTR* version
                     );

   /////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetClass)(
             /*[in]*/ BSTR classId,
            /*[out]*/ IUnknown** sdoClassInfo
                    );

   /////////////////////////////////////////////////////////////////////////////
   STDMETHOD(GetProperty)(
                /*[in]*/ BSTR propertyId,
              /*[out]*/ IUnknown** sdoPropertyInfo
                      );

private:

   CSdoSchema(const CSdoSchema&);        // No copy
   CSdoSchema& operator = (CSdoSchema&); // No assignment

   /////////////////////////////////////////////////////////////////////////////
   SCHEMA_OBJECT_STATE GetState() const
   { return m_state; }

   /////////////////////////////////////////////////////////////////////////////
   HRESULT AddProperty(
             /*[in]*/ PSDO_PROPERTY_OBJ pPropertyObj
                   );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT AddClass(
          /*[in]*/ PSDO_CLASS_OBJ pClassObj
               );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT InitializeClasses(void);

   /////////////////////////////////////////////////////////////////////////////
   void DestroyProperties(void);

   /////////////////////////////////////////////////////////////////////////////
   void DestroyClasses(void);

   /////////////////////////////////////////////////////////////////////////////
   HRESULT BuildInternalProperties(void);

   /////////////////////////////////////////////////////////////////////////////
   HRESULT BuildInternalClasses(void);

   /////////////////////////////////////////////////////////////////////////////
   HRESULT BuildSchemaProperties(
                     /*[in]*/ IDataStoreObject* pSchema
                            );

   /////////////////////////////////////////////////////////////////////////////
   HRESULT BuildSchemaClasses(
                   /*[in]*/ IDataStoreObject* pSchema
                          );

    typedef map<StdWString, ISdoClassInfo*>    ClassMap;
    typedef ClassMap::iterator             ClassMapIterator;

    typedef map<StdWString, ISdoPropertyInfo*>  PropertyMap;
    typedef PropertyMap::iterator          PropertyMapIterator;

   SCHEMA_OBJECT_STATE      m_state;
   bool               m_fInternalObjsInitialized;
   bool               m_fSchemaObjsInitialized;
   CRITICAL_SECTION      m_critSec;
   StdWString               m_version;
   ClassMap            m_classMap;
   PropertyMap            m_propertyMap;

}; // End of class CSdoSchema

typedef CComObjectNoLock<CSdoSchema>  SDO_SCHEMA_OBJ;
typedef CComObjectNoLock<CSdoSchema>* PSDO_SCHEMA_OBJ;


#endif // _INC_SDO_SCHEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoservergroup.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdoservergroup.cpp
//
// SYNOPSIS
//
//    Defines the class SdoServerGroup.
//
// MODIFICATION HISTORY
//
//    02/03/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdafx.h>
#include <sdoservergroup.h>

HRESULT SdoServerGroup::FinalInitialize(
                            bool fInitNew,
                            ISdoMachine* pAttachedMachine
                            )
{
   HRESULT hr;
   IDataStoreContainer* container;
   hr = m_pDSObject->QueryInterface(
                         __uuidof(IDataStoreContainer),
                         (PVOID*)&container
                         );
   if (SUCCEEDED(hr))
   {
      hr = InitializeCollection(
               PROPERTY_RADIUSSERVERGROUP_SERVERS_COLLECTION,
               SDO_PROG_ID_RADIUSSERVER,
               pAttachedMachine,
               container
               );

      container->Release();

      if (SUCCEEDED(hr) && !fInitNew) { hr = Load(); }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoproperty.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoproperty.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object Property Implementation
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdoproperty.h"
#include <varvec.h>

//////////////////////////////////////////////////////////////////////////////
CSdoProperty::CSdoProperty(
						   ISdoPropertyInfo* pSdoPropertyInfo,
  						   DWORD             dwFlags
						  ) throw (_com_error)
    : m_alias(PROPERTY_SDO_RESERVED),
	  m_flags(0),
	  m_dirty(FALSE),
      m_type(VT_EMPTY),
	  m_index(0),
	  m_dfa(NULL)
{
    HRESULT hr;
	hr = pSdoPropertyInfo->get_DisplayName(&m_name);
	if ( FAILED(hr) )
		throw _com_error(hr);

	LONG type;
	hr = pSdoPropertyInfo->get_Type(&type);
	if ( FAILED(hr) )
		throw _com_error(hr);
	m_type = (VARTYPE)type;

	hr = pSdoPropertyInfo->get_Alias(&m_alias);
	if ( FAILED(hr) )
		throw _com_error(hr);

	hr = pSdoPropertyInfo->get_Flags((LONG*)&m_flags);
	if ( FAILED(hr) )
		throw _com_error(hr);
	
	m_flags |= dwFlags;

	if ( m_flags & SDO_PROPERTY_MIN_LENGTH )
	{
		hr = pSdoPropertyInfo->get_MinLength((LONG*)&m_minLength);
		if ( FAILED(hr) )
			throw _com_error(hr);
	}

	if ( m_flags & SDO_PROPERTY_MAX_LENGTH )
	{
		hr = pSdoPropertyInfo->get_MaxLength((LONG*)&m_maxLength);
		if ( FAILED(hr) )
			throw _com_error(hr);
	}

	if ( m_flags & SDO_PROPERTY_MIN_VALUE )
	{
		hr = pSdoPropertyInfo->get_MinValue(&m_minValue);
		if ( FAILED(hr) )
			throw _com_error(hr);
	}

	if ( m_flags & SDO_PROPERTY_MAX_VALUE )
	{
		hr = pSdoPropertyInfo->get_MaxValue(&m_maxValue);
		if ( FAILED(hr) )
			throw _com_error(hr);
	}

	if ( m_flags & SDO_PROPERTY_HAS_DEFAULT )
	{
		hr = pSdoPropertyInfo->get_DefaultValue(&m_defaultValue);
		if ( FAILED(hr) )
			throw _com_error(hr);

		m_value[m_index] = m_defaultValue;
	}

	if ( m_flags & SDO_PROPERTY_FORMAT )
	{
		BSTR format;
		hr = pSdoPropertyInfo->get_Format (&format);
		if ( FAILED(hr) )
			throw _com_error(hr);
		m_dfa = new CDFA(format, FALSE);
		SysFreeString(format);
	}

	m_pSdoPropertyInfo = pSdoPropertyInfo;
}


//////////////////////////////////////////////////////////////////////////////
CSdoProperty::~CSdoProperty()
{
	if ( m_dfa )
		delete m_dfa;
}		


//////////////////////////////////////////////////////////////////////////////
void CSdoProperty::Reset(void) throw(_com_error)
{ 
    if ( m_flags & SDO_PROPERTY_HAS_DEFAULT )
	{
		_ASSERT( ! (m_flags & (SDO_PROPERTY_POINTER | SDO_PROPERTY_COLLECTION)) ) ;
		if ( ! (m_flags & (SDO_PROPERTY_POINTER | SDO_PROPERTY_COLLECTION)) )
		{
			if ( FAILED(VariantCopy(GetUpdateValue(), &m_defaultValue)) )
				throw _com_error(E_FAIL);
		}
	}
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProperty::Validate(VARIANT *pValue)
{
   // We'll always allow an empty property. If it turns out to be mandator this
   // will be caught during Apply.
   if (V_VT(pValue) == VT_EMPTY) { return S_OK; }

	HRESULT hr = S_OK;
	if ( m_flags & SDO_PROPERTY_MULTIVALUED )
	{
		_ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(pValue) );
		if ( (VT_ARRAY | VT_VARIANT) != V_VT(pValue) )
		{
			hr = E_INVALIDARG;
		}
		else
		{
			CVariantVector<VARIANT> property(pValue);
			DWORD count = 0;
			while ( count < property.size() )
			{
        		hr = ValidateIt(&property[count]);
				if ( FAILED(hr) )
					break;
		    
				count++;
			}
		}
	}
	else
	{
		hr = ValidateIt(pValue);
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoProperty::ValidateIt(VARIANT* pValue)
{
	// Validate type
	//
    if ( m_type != V_VT(pValue) &&
         !(m_type == (VT_ARRAY | VT_UI1) && V_VT(pValue) == VT_BSTR))
    {
		IASTracePrintf("SDO Property Error - Validate() - type mismatch...");
        return E_INVALIDARG;
    }

	// Make sure a VT_BOOL is a VT_BOOL
    //
	if ( VT_BOOL == V_VT(pValue) )
	{
		_ASSERTE ( VARIANT_TRUE == V_BOOL(pValue) || VARIANT_FALSE == V_BOOL(pValue) );
		if ( VARIANT_TRUE != V_BOOL(pValue) && VARIANT_FALSE != V_BOOL(pValue) )
        {
			IASTracePrintf("SDO Property Error - Validate() - VT_BOOL not set to VARIANT_TRUE or VARIANT_FALSE...");
			return E_INVALIDARG;
        }
        return S_OK;
	}

	// Validate format
	//
	if ( m_flags & SDO_PROPERTY_FORMAT )
	{
		_ASSERT( V_VT(pValue) == VT_BSTR );
		if ( V_VT(pValue) == VT_BSTR )
		{
			if ( ! m_dfa->Recognize(V_BSTR(pValue)) )
				return E_INVALIDARG;
		}	
		else
		{
			return E_INVALIDARG;
		}
	}

	// Min Value
    //
	if ( m_flags & SDO_PROPERTY_MIN_VALUE )
	{
		if ( V_VT(pValue) == VT_I4 || V_VT(pValue) == VT_I2 )
		{
			if ( V_VT(pValue) == VT_I4 )
			{
				if ( V_I4(&m_minValue) > V_I4(pValue) )
				{
					IASTracePrintf("SDO Property Error - Validate() - I4 Value too small for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}
			else 
			{
				if ( V_I2(&m_minValue) > V_I2(pValue) )
				{
					IASTracePrintf("SDO Property Error - Validate() - I2 Value too small for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}					
		}
	}

	// Max Value
    //
	if ( m_flags & SDO_PROPERTY_MAX_VALUE )
	{
		if ( V_VT(pValue) == VT_I4 || V_VT(pValue) == VT_I2 )
		{
			if ( V_VT(pValue) == VT_I4 )
			{
				if ( V_I4(&m_maxValue) < V_I4(pValue) )
				{
					IASTracePrintf("SDO Property Error - Validate() - I4 Value too big for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}
			else
			{
				if	( V_I2(&m_maxValue) < V_I2(pValue) )
				{
					IASTracePrintf("SDO Property Error - Validate() - I2 Value too big for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}					
		}
	}

	// Min Length
    //
	if ( m_flags & SDO_PROPERTY_MIN_LENGTH )
	{
		_ASSERT( VT_BSTR == V_VT(pValue) || (VT_ARRAY | VT_UI1) == V_VT(pValue) );
		if (  VT_BSTR == V_VT(pValue) )
		{
			if ( NULL == V_BSTR(pValue) )
			{
				return E_INVALIDARG;
			}
			else
			{
				if ( m_minLength > SysStringLen(V_BSTR(pValue)) )
				{
					IASTracePrintf("SDO Property Error - Validate() - Min length for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}
		}
		else
		{
			CVariantVector<BYTE> OctetString(pValue);
			if ( m_minLength > OctetString.size() )
			{
				IASTracePrintf("SDO Property Error - Validate() - Min length for property '%ls'...",m_name);
				return E_INVALIDARG;
			}
		}
	}

	// Max Length
    //
	if ( m_flags & SDO_PROPERTY_MAX_LENGTH )
	{
		_ASSERT( VT_BSTR == V_VT(pValue) || (VT_ARRAY | VT_UI1) == V_VT(pValue) );
		if (  VT_BSTR == V_VT(pValue) )
		{
			if ( NULL == V_BSTR(pValue) )
			{
				return E_INVALIDARG;
			}				
			else
			{
				if ( m_maxLength < SysStringLen(V_BSTR(pValue)) )
				{
					IASTracePrintf("SDO Property Error - Validate() - Max length for property '%ls'...",m_name);
					return E_INVALIDARG;
				}
			}
		}
		else
		{
			CVariantVector<BYTE> OctetString(pValue);
			if ( m_maxLength < OctetString.size() )
			{
				IASTracePrintf("SDO Property Error - Validate() - Max length for property '%ls'...",m_name);
				return E_INVALIDARG;
			}
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoservergroup.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdoservergroup.h
//
// SYNOPSIS
//
//    Declares the classes SdoServerGroup and SdoServer.
//
// MODIFICATION HISTORY
//
//    02/03/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDOSERVERGROUP_H
#define SDOSERVERGROUP_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <sdo.h>
#include <sdofactory.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoServerGroup
//
///////////////////////////////////////////////////////////////////////////////
class SdoServerGroup : public CSdo
{
public:

BEGIN_COM_MAP(SdoServerGroup)
   COM_INTERFACE_ENTRY(ISdo)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(SdoServerGroup);

   HRESULT FinalInitialize(
               bool fInitNew,
               ISdoMachine* pAttachedMachine
               );
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoServerGroup
//
///////////////////////////////////////////////////////////////////////////////
class SdoServer : public CSdo
{
public:
BEGIN_COM_MAP(SdoServer)
   COM_INTERFACE_ENTRY(ISdo)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(SdoServer);
};

#endif  // SDOSERVERGROUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoserverinfo.h ===
//#--------------------------------------------------------------
//        
//  File:       sdoserverinfo.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CSdoServerInfo class
//                  
//
//  History:     06/04/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _SDOSERVERINFO_H_
#define _SDOSERVERINFO_H_

#include "resource.h"
#include <ias.h>
#include <sdoias.h>
#include <infohelper.h>


typedef  enum _object_type
{
    OBJECT_TYPE_COMPUTER,
    OBJECT_TYPE_USER

}   OBJECTTYPE, *POBJECTTYPE;

//
// declaration of the CSdoServerInfo class
//
class CSdoServerInfo
{

public:

    //
    // this method gets the system type - NT Version,NT Type
    //
    HRESULT GetOSInfo (
                /*[in]*/    BSTR        lpServerName,
                /*[out]*/   PIASOSTYPE  pOSType
                );

    //
    //  this method returns the NT Domain type
    //
    HRESULT GetDomainInfo (
                /*[in]*/    OBJECTTYPE      ObjectType,
                /*[in]*/    BSTR            lpObjectId,
                /*[out]*/   PIASDOMAINTYPE  pDomainType
                );

    CSdoServerInfo (VOID);

    ~CSdoServerInfo(VOID);

private:

    //
    //resolves the ADS path to a domain name
    //
    HRESULT GetDomainFromADsPath (
                /*[in]*/    LPCWSTR pObjectId, 
                /*[out*/    LPWSTR  pszDomainName
                );

    bool m_bIsNT5;

};

#endif // !define  _SDOSERVERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoservice.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoservice.cpp
//
// Project:     Everest
//
// Description: IAS Service SDO Implementation
//
// Author:      TLP 2/3/98
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdoservice.h"
#include "sdocoremgr.h"


/////////////////////////////////////////////////////////////
// CSdoService Class - Implements ISdoService
/////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CSdoService::CSdoService()
   : m_theThread(NULL)
{
}


//////////////////////////////////////////////////////////////////////////////
CSdoService::~CSdoService()
{
}


//////////////////////
// ISdoService Methods
//////////////////////

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoService::InitializeService(SERVICE_TYPE eServiceType)
{
   // Check preconditions...
   //
   _ASSERT ( SERVICE_TYPE_MAX > eServiceType );

   // Use this to debug the service...
   // DebugBreak();
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoService::ShutdownService(SERVICE_TYPE eServiceType)
{
   // Check preconditions...
   //
   _ASSERT ( SERVICE_TYPE_MAX > eServiceType );
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoService::StartService(SERVICE_TYPE eServiceType)
{
   // Check preconditions...
   //
   _ASSERT ( SERVICE_TYPE_MAX > eServiceType );
    CSdoLock theLock(*this);
   return GetCoreManager().StartService(eServiceType);
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoService::StopService(SERVICE_TYPE eServiceType)
{
   // Check preconditions...
   //
   _ASSERT ( SERVICE_TYPE_MAX > eServiceType );
    CSdoLock theLock(*this);
   return GetCoreManager().StopService(eServiceType);
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoService::ConfigureService (SERVICE_TYPE eServiceType)
{
   // Check preconditions...
   //
   _ASSERT ( SERVICE_TYPE_MAX > eServiceType );
    CSdoLock theLock(*this);
    if ( m_theThread )
    {
      // We already have a thread, so just interrupt it to reset the timer.
        QueueUserAPC(InterruptThread, m_theThread, 0);
    }
    else
    {
        // Create a new thread.
        DWORD threadId;
        m_theThread = CreateThread(
                                   NULL,
                                   0,
                           DebounceAndConfigure,
                                   (LPVOID)this,
                                   0,
                                   &threadId
                                  );

        if ( ! m_theThread )
        {
         // We couldn't create a new thread, so we'll just do it ourself.
            UpdateConfiguration();
        }
   }
   return S_OK;
}


//////////////////
// Private Methods
//////////////////

//////////////////////////////////////////////////////////////////////////////
void CSdoService::UpdateConfiguration()
{
    // Clear out the thread handle.
    CSdoLock theLock(*this);
   if ( m_theThread )
   {
      CloseHandle( m_theThread );
      m_theThread = NULL;
   }
    GetCoreManager().UpdateConfiguration();
}


//////////////////////////////////////////////////////////////////////////////
// Empty APC used to interrupt the debounce thread.
//////////////////////////////////////////////////////////////////////////////
VOID WINAPI CSdoService::InterruptThread(
                        /*[in]*/ ULONG_PTR dwParam
                               )
{
}


// Debounce interval in milliseconds.
const DWORD DEBOUNCE_INTERVAL = 5000;

//////////////////////////////////////////////////////////////////////////////
// Entry point for the debounce thread.
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CSdoService::DebounceAndConfigure(
                              /*[in]*/ LPVOID pSdoService
                                   )
{
   // Loop until we sleep for DEBOUNCE_INTERVAL without being interrupted.
    while (SleepEx(DEBOUNCE_INTERVAL, TRUE) == WAIT_IO_COMPLETION) { }
    // Update the configuration.
   ((CSdoService*)pSdoService)->UpdateConfiguration();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoserviceias.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdoserviceias.cpp
//
// Project:      Everest
//
// Description:   SDO Service Class Implementation
//
// Author:      TLP 9/1/98
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdoserviceias.h"
#include "sdohelperfuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CSdoServiceIAS Class Implementation
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CSdoServiceIAS::CSdoServiceIAS()
   : m_clsSdoServiceControlImpl(this),
     m_pAttachedMachine(NULL),
     m_bstrAttachedComputer(NULL)
{
   m_PropertyStatus[0] = PROPERTY_UNINITIALIZED;   // RADIUS Server Groups
   m_PropertyStatus[1] = PROPERTY_UNINITIALIZED;   // Policies
   m_PropertyStatus[2] = PROPERTY_UNINITIALIZED;   // Profiles
   m_PropertyStatus[3] = PROPERTY_UNINITIALIZED;   // Protocols
   m_PropertyStatus[4] = PROPERTY_UNINITIALIZED;   // Auditors
   m_PropertyStatus[5] = PROPERTY_UNINITIALIZED;   // RequestHandlers
   m_PropertyStatus[6] = PROPERTY_UNINITIALIZED;   // Proxy Policies
   m_PropertyStatus[7] = PROPERTY_UNINITIALIZED;   // Proxy Profiles
}


/////////////////////////////////////////////////////////////////////////////
CSdoServiceIAS::~CSdoServiceIAS()
{
   if ( m_pAttachedMachine )
      m_pAttachedMachine->Release();
   if ( m_bstrAttachedComputer )
      SysFreeString(m_bstrAttachedComputer);
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CSdoServiceIAS::FinalInitialize(
                        /*[in]*/ bool         fInitNew,
                        /*[in]*/ ISdoMachine* pAttachedMachine
                               )
{
   _ASSERT ( ! fInitNew );

   HRESULT hr;
   do
   {
      hr = GetPropertyInternal(PROPERTY_SDO_NAME, &m_ServiceName);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Service SDO - FinalInitialize() - Could not get the service name...");
         break;
      }
      hr = pAttachedMachine->GetAttachedComputer(&m_bstrAttachedComputer);
      if ( FAILED(hr) )
      {
         IASTracePrintf("Error in Service SDO - FinalInitialize() - Could not get name of attached computer...");
         break;
      }

      hr = LoadProperties();
      if ( FAILED(hr) )
         break;

      (m_pAttachedMachine = pAttachedMachine)->AddRef();
   }
   while (FALSE);

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Lazy initialization of IAS Service SDO properties
//

IAS_PROPERTY_INFO g_PropertyInfo[MAX_SERVICE_PROPERTIES] =
{
   {
      PROPERTY_IAS_RADIUSSERVERGROUPS_COLLECTION,
      SDO_PROG_ID_RADIUSGROUP,
      DS_OBJECT_RADIUSGROUPS
   },
   {
      PROPERTY_IAS_POLICIES_COLLECTION,
      SDO_PROG_ID_POLICY,
      DS_OBJECT_POLICIES
   },
   {
      PROPERTY_IAS_PROFILES_COLLECTION,
      SDO_PROG_ID_PROFILE,
      DS_OBJECT_PROFILES
   },
   {
      PROPERTY_IAS_PROTOCOLS_COLLECTION,
      NULL,
      DS_OBJECT_PROTOCOLS
   },
   {
      PROPERTY_IAS_AUDITORS_COLLECTION,
      NULL,
      DS_OBJECT_AUDITORS
   },
   {
      PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
      NULL,
      DS_OBJECT_REQUESTHANDLERS
   },
   {
      PROPERTY_IAS_PROXYPOLICIES_COLLECTION,
      SDO_PROG_ID_POLICY,
      DS_OBJECT_PROXY_POLICIES
   },
   {
      PROPERTY_IAS_PROXYPROFILES_COLLECTION,
      SDO_PROG_ID_PROFILE,
      DS_OBJECT_PROXY_PROFILES
   }
};

HRESULT CSdoServiceIAS::InitializeProperty(LONG Id)
{
   HRESULT hr = S_OK;

   do
   {
      if ( PROPERTY_SDO_START <= Id )
      {
         PIAS_PROPERTY_INFO pInfo = &g_PropertyInfo[Id - PROPERTY_SDO_START];
         _ASSERT ( pInfo->Id == Id );
         if ( PROPERTY_UNINITIALIZED == m_PropertyStatus[Id - PROPERTY_SDO_START] )
         {
            _ASSERT( pInfo->lpszDSContainerName );
            CComPtr<IDataStoreContainer> pDSContainerRoot;
               hr = m_pDSObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainerRoot);
               if ( FAILED(hr) )
               {
                  IASTracePrintf("Error in Service SDO - InitializeProperty() - QueryInterface(1) failed...");
                  break;
               }
            _bstr_t bstrContainerName = pInfo->lpszDSContainerName;
            CComPtr<IDataStoreObject> pDSObject;
            hr = pDSContainerRoot->Item(bstrContainerName, &pDSObject);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Service SDO - InitializeProperty() - Could not retrieve container: '%ls'...", bstrContainerName);
               break;
            }
            CComPtr<IDataStoreContainer> pDSContainerCollection;
            hr = pDSObject->QueryInterface(IID_IDataStoreContainer, (void**)&pDSContainerCollection);
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Service SDO - InitializeProperty() - QueryInterface(2) failed...");
               break;
            }

            size_t maxSize = INFINITE;

            if (Id == PROPERTY_IAS_RADIUSSERVERGROUPS_COLLECTION)
            {
               IAS_PRODUCT_LIMITS limits;
               hr = SDOGetProductLimits(m_pAttachedMachine, &limits);
               if (FAILED(hr))
               {
                  break;
               }

               maxSize = limits.maxServerGroups;
            }

            hr = InitializeCollection(
                                pInfo->Id,
                                pInfo->lpszItemProgId,
                                m_pAttachedMachine,
                                pDSContainerCollection,
                                maxSize
                               );
            if ( FAILED(hr) )
            {
               IASTracePrintf("Error in Service SDO - InitializeProperty() - Could not initialize collection for: '%ls'...", bstrContainerName);
               break;
            }
            else
            {
               m_PropertyStatus[Id - PROPERTY_SDO_START] = PROPERTY_INITIALIZED;
            }
         }
      }

   } while ( FALSE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
LPCWSTR CSdoServiceIAS::GetServiceName(void)
{
   if ( VT_EMPTY == V_VT(&m_ServiceName) )
   {
      HRESULT hr = GetPropertyInternal(PROPERTY_SDO_DATASTORE_NAME, &m_ServiceName);
      if ( FAILED(hr) )
         throw _com_error(hr);
   }
   return V_BSTR(&m_ServiceName);
}


/////////////////////////////////////////////////////////////////////////////
//
// FuncName:        QueryInterfaceInternal()
//
// Description:     Function called by AtlInternalQueryInterface() because
//                  we used COM_INTERFACE_ENTRY_FUNC in the definition of
//                  CRequest. Its purpose is to return a pointer to one
//                  or the request object's "raw" interfaces.
//
// Preconditions:   None
//
// Inputs:          Defined by ATL COM_INTERFACE_ENTRY_FUNC macro
//
// Outputs:         Defined by ATL COM_INTERFACE_ENTRY_FUNC macro
//
//////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CSdoServiceIAS::QueryInterfaceInternal(
                                          void*   pThis,
                                          REFIID  riid,
                                          LPVOID* ppv,
                                          DWORD_PTR dw
                                         )
{
   if ( InlineIsEqualGUID(riid, IID_ISdoServiceControl) )
   {
      *ppv = &(static_cast<CSdoServiceIAS*>(pThis))->m_clsSdoServiceControlImpl;
       ((LPUNKNOWN)*ppv)->AddRef();
       return S_OK;
   }
   else
   {
        _ASSERT(FALSE);
        return E_NOTIMPL;
   }
}


//////////////////////////////////////////////////////////////////////////////
CSdoServiceIAS::CSdoServiceControlImpl::CSdoServiceControlImpl(CSdoServiceIAS* pSdoServiceIAS)
   : m_pSdoServiceIAS(pSdoServiceIAS)
{

}

//////////////////////////////////////////////////////////////////////////////
CSdoServiceIAS::CSdoServiceControlImpl::~CSdoServiceControlImpl()
{

}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoServiceIAS::CSdoServiceControlImpl::StartService()
{
   HRESULT      hr = E_FAIL;
   SC_HANDLE   hServiceManager;
   SC_HANDLE   hService;

    CSdoLock   theLock(*m_pSdoServiceIAS);

   try
   {
      IASTracePrintf("Service SDO is attempting to start service '%ls'...", m_pSdoServiceIAS->GetServiceName());

      if ( NULL != (hServiceManager = OpenSCManager(m_pSdoServiceIAS->m_bstrAttachedComputer, NULL, SC_MANAGER_ALL_ACCESS)) )
      {
         if ( NULL != (hService = OpenService(hServiceManager, m_pSdoServiceIAS->GetServiceName(), SERVICE_ALL_ACCESS)) )
         {
            if ( ::StartService(hService, NULL, NULL) == TRUE )
            {
               hr = S_OK;
               IASTracePrintf("Service SDO successfully started service '%ls'...", m_pSdoServiceIAS->GetServiceName());
            }

            CloseServiceHandle(hService);
         }

         CloseServiceHandle(hServiceManager);
      }

      if ( FAILED(hr) )
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         IASTracePrintf("Error in Service SDO - StartService() - could not start service '%ls'...", m_pSdoServiceIAS->GetServiceName());
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in Service SDO - StartService() - caught unknown exception...");
      hr = E_FAIL;
   }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoServiceIAS::CSdoServiceControlImpl::GetServiceStatus(
                                              /*[out]*/ LONG *pStatus
                                                      )
{
   HRESULT      hr = E_FAIL;
   SC_HANDLE   hServiceManager;
   SC_HANDLE   hService;

    CSdoLock   theLock(*m_pSdoServiceIAS);

   // Check preconditions
    _ASSERTE( NULL != pStatus );
   if ( NULL == pStatus )
      return E_INVALIDARG;

   try
   {
      IASTracePrintf("Service SDO is attempting to retrieve status for service '%ls'...", m_pSdoServiceIAS->GetServiceName());

      if ( NULL != (hServiceManager = OpenSCManager(m_pSdoServiceIAS->m_bstrAttachedComputer, NULL, SC_MANAGER_ALL_ACCESS)) )
      {
         if ( NULL != (hService = OpenService(hServiceManager, m_pSdoServiceIAS->GetServiceName(), SERVICE_ALL_ACCESS)) )
         {
            SERVICE_STATUS   ServiceStatus;

            if ( TRUE == QueryServiceStatus(hService, &ServiceStatus) )
            {
               *pStatus = (LONG)ServiceStatus.dwCurrentState;
               hr = S_OK;
               IASTracePrintf("Service SDO successfully retrieved status for service '%ls'...", m_pSdoServiceIAS->GetServiceName());
            }

            CloseServiceHandle(hService);
         }

         CloseServiceHandle(hServiceManager);
      }

      if ( FAILED(hr) )
      {
         // Returns ERROR_SERVICE_DOES_NOT_EXIST if IAS has not been installed
         //
         hr = HRESULT_FROM_WIN32(GetLastError());
         IASTracePrintf("Error in Service SDO - GetServiceStatus() - Could not retrieve status for service '%ls'...", m_pSdoServiceIAS->GetServiceName());
      }
   }
   catch(...)
   {
      IASTracePrintf("Error in Service SDO - GetServiceStatus() - caught unknown exception...");
      hr = E_FAIL;
   }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoServiceIAS::CSdoServiceControlImpl::StopService()
{
    CSdoLock theLock(*m_pSdoServiceIAS);
   HRESULT hr;

   try
   {
      IASTracePrintf("Service SDO is attempting to send control code %d (stop) to service '%ls'...", SERVICE_CONTROL_STOP, m_pSdoServiceIAS->GetServiceName());
      hr = ControlIAS(SERVICE_CONTROL_STOP);
   }
   catch(...)
   {
      IASTracePrintf("Error in Service SDO - StopService() - caught unknown exception...");
      hr = E_FAIL;
   }
   return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoServiceIAS::CSdoServiceControlImpl::ResetService()
{
    CSdoLock theLock(*m_pSdoServiceIAS);
   HRESULT hr;

   try
   {
      IASTracePrintf("Service SDO is attempting to send control code %d (reset) to service '%ls'...", SERVICE_CONTROL_RESET, m_pSdoServiceIAS->GetServiceName());
      hr = ControlIAS(SERVICE_CONTROL_RESET);
   }
   catch(...)
   {
      IASTracePrintf("Error in Service SDO - StopService() - caught unknown exception...");
      hr = E_FAIL;
   }
   return hr;
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CSdoServiceIAS::CSdoServiceControlImpl::ControlIAS(DWORD dwControlCode)
{
   HRESULT      hr = E_FAIL;
   SC_HANDLE   hServiceManager;
   SC_HANDLE   hService;

   if ( NULL != (hServiceManager = OpenSCManager(m_pSdoServiceIAS->m_bstrAttachedComputer, NULL, SC_MANAGER_ALL_ACCESS)) )
   {
      if ( NULL != (hService = OpenService(hServiceManager, m_pSdoServiceIAS->GetServiceName(), SERVICE_ALL_ACCESS)) )
      {
         SERVICE_STATUS   ServiceStatus;

         if ( TRUE == ControlService(hService, dwControlCode, &ServiceStatus) )
         {
            hr = S_OK;
            IASTracePrintf("Service SDO successfully sent control code %d to service '%ls'...", dwControlCode, m_pSdoServiceIAS->GetServiceName());
         }

         CloseServiceHandle(hService);
      }

      CloseServiceHandle(hServiceManager);
   }

   if ( FAILED(hr) )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      IASTracePrintf("Service SDO Status - control code %d could not be delivered to service '%ls'...", dwControlCode, m_pSdoServiceIAS->GetServiceName());
   }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoservice.h ===
// SdoService.h: Definition of the CSdoNtSam class
//
//////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_SERVICE_H_
#define _INC_IAS_SDO_SERVICE_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"

/////////////////////////////////////////////////////////////////////////////
// CSdoService
/////////////////////////////////////////////////////////////////////////////

class CSdoService : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSdoService,&CLSID_SdoService>,
   	public IDispatchImpl<ISdoService, &IID_ISdoService, &LIBID_SDOIASLibPrivate>
{

public:

    CSdoService();
    ~CSdoService();

	////////////////////////
    // ISdoService Interface 
    ////////////////////////

	STDMETHOD(InitializeService)(SERVICE_TYPE eServiceType);

	STDMETHOD(StartService)(SERVICE_TYPE eServiceType);

	STDMETHOD(StopService)(SERVICE_TYPE eServiceType);

	STDMETHOD(ShutdownService)(SERVICE_TYPE eServiceType);

	STDMETHOD(ConfigureService)(SERVICE_TYPE eServiceType);


BEGIN_COM_MAP(CSdoService)
	COM_INTERFACE_ENTRY(ISdoService)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_CLASSFACTORY_SINGLETON(CSdoService)
DECLARE_NOT_AGGREGATABLE(CSdoService) 
DECLARE_REGISTRY_RESOURCEID(IDR_SdoService)

private:

	// Handle of the current debounce thread (if any).
	HANDLE	m_theThread;

	CSdoService(const CSdoService& rhs);
	CSdoService& operator = (CSdoService& rhs);

	// Processes a service configuration request.
	VOID WINAPI ProcessConfigureService(void) throw(); 

	// Updates the services configuration
	void UpdateConfiguration(void);

	// Empty APC used to interrupt the debounce thread.
	static VOID WINAPI InterruptThread(
				               /*[in]*/ ULONG_PTR dwParam
				                      ) throw ();

	// Entry point for the debounce thread.
	static DWORD WINAPI DebounceAndConfigure(
						             /*[in]*/ LPVOID pSdoService
					                        ) throw ();

};

#endif // _INC_IAS_SDO_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoserverinfo.cpp ===
//#--------------------------------------------------------------
//        
//  File:		sdoserverinfo.cpp
//        
//  Synopsis:   Implementation of CSdoServerInfo class methods
//              
//
//  History:     06/04/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include "sdoserverinfo.h"
#include <activeds.h>
#include <security.h>

const DWORD MAX_DOMAINNAME_LENGTH = 1024;

//++--------------------------------------------------------------
//
//  Function:   CSdoServerInfo
//
//  Synopsis:   This is CSdoServerInfo Class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     06/04/98
//
//----------------------------------------------------------------
CSdoServerInfo::CSdoServerInfo()
    :m_bIsNT5 (false)
{

    DWORD           dwSize = sizeof (OSVERSIONINFO);
    OSVERSIONINFO   VersionInfo;

    ZeroMemory (&VersionInfo, dwSize);
    VersionInfo.dwOSVersionInfoSize = dwSize;

    //
    //   find out which system type this is
    //
    m_bIsNT5 = 
    (GetVersionEx (&VersionInfo) && (5 == VersionInfo.dwMajorVersion));

}	//	end of CSdoServerInfo class constructor	

//++--------------------------------------------------------------
//
//  Function:   ~CSdoServerInfo
//
//  Synopsis:   This is CSdoSeverInfo class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     2/10/98
//
//----------------------------------------------------------------
CSdoServerInfo ::~CSdoServerInfo()
{
}	//	end of CSdoServerInfo class destructor

//++--------------------------------------------------------------
//
//  Function:   GetOSInfo
//
//  Synopsis:   This is GetOSInfo method of the 
//				ISdoServerInfo COM Interface. 
//
//  Arguments: 
//              [in]    BSTR        -   Computer Name
//              [out]   PIASOSTYPE
//
//  Returns:    HRESULT	-	status 
//
//
//  History:    MKarki      Created     06/09/98
//
//----------------------------------------------------------------
HRESULT
CSdoServerInfo::GetOSInfo (
                    /*[in]*/    BSTR            bstrServerName,
                    /*[out]*/   PIASOSTYPE      pOSType
                    )
{
    WCHAR   szComputerName [MAX_COMPUTERNAME_LENGTH +1];
    DWORD   dwBufferSize = MAX_COMPUTERNAME_LENGTH +1;
    DWORD   dwErrorCode =  ERROR_SUCCESS;

	_ASSERT(NULL != pOSType);
    if (NULL == pOSType) 
    {
		IASTracePrintf(
            "Error in Server Information SDO - GetOSInfo()"
            " - invalid argument passed in"
            );
        return E_INVALIDARG;
    }

    //
    // check if the user wants to get Info about local machine
    //
    if ( NULL == bstrServerName )
    {
        if ( FALSE == ::GetComputerName (szComputerName, &dwBufferSize))
        {
            dwErrorCode = GetLastError ();
			IASTracePrintf(
                "Error in Server Information SDO - GetOSInfo()"
                "GetComputerName() failed with error: %d", 
                dwErrorCode
                );
            return (HRESULT_FROM_WIN32 (dwErrorCode));
        }
        else
        {
            bstrServerName = szComputerName;
        }
    }

    //  call the IASSDO.DLL specific method to return the 
    //  required information
    //
    return (::SdoGetOSInfo (bstrServerName, pOSType));

}   //  end of CSdoServerInfo::GetOSInfo method

//++--------------------------------------------------------------
//
//  Function:   GetDomainInfo
//
//  Synopsis:   This is the ISdoServerInfo Interface method. 
//
//  Arguments:  
//              [in]    OBJECTTYPE
//              [in]    BSTR        - Object Id
//              [out]   PDOMAINTYPE 
//
//  Returns:    HRESULT	-	status 
//
//
//  History:    MKarki      Created     06/09/98
//
//----------------------------------------------------------------
HRESULT
CSdoServerInfo::GetDomainInfo (
                /*[in]*/    OBJECTTYPE      ObjectType,
                /*[in]*/    BSTR            bstrObjectId,
                /*[out]*/   PIASDOMAINTYPE  pDomainType
                )
{
    HRESULT hr = S_OK;
    WCHAR   szDomainName[MAX_DOMAINNAME_LENGTH +1];
    WCHAR   szComputerName [MAX_COMPUTERNAME_LENGTH +1];
    DWORD   dwBufferSize = MAX_COMPUTERNAME_LENGTH +1;

    _ASSERT (NULL != pDomainType);

    if (NULL == pDomainType)
    {
		IASTracePrintf(
            "Error in Server Information SDO - GetDomainInfo()"
            " - invalid argument passed in (PIASDOMAINTYPE==NULL)"
            );
        return (E_INVALIDARG);
    }

    // for now we are not supporting this API if this is not 
    // a NT 5 machine 
    //
    if ( false == m_bIsNT5 )
    {
		IASTracePrintf(
            "Error in Server Information SDO - GetDomainInfo()"
            " - Not an NT 5 machine..."
            );
        return (E_NOTIMPL);
    }

    switch (ObjectType)
    {

    case OBJECT_TYPE_COMPUTER:

        //
        // check if the user wants to get Info about local machine
        //
        if ( NULL == bstrObjectId)
        {
            if ( FALSE == ::GetComputerName (szComputerName, &dwBufferSize))
            {
                DWORD dwErrorCode = GetLastError ();
			    IASTracePrintf(
                    "Error in Server Information SDO - GetDomainInfo()"
                    "GetComputerName() failed with error: %d", 
                    dwErrorCode
                    );
                hr = HRESULT_FROM_WIN32 (dwErrorCode);
                break;
            }
            else
            {
                bstrObjectId = szComputerName;
            }
        }

        //
        //  call the API to get the appropriate info
        //
        hr = ::SdoGetDomainInfo (
                            bstrObjectId, 
                            NULL,
                            pDomainType
                            );
        if (FAILED (hr))
        {
			IASTracePrintf(
                "Error in Server Information SDO"
                " - GetDomainInfo() - SetDomainInfo() failed:%x",
                hr
                );
            break;
        }
        break;

    case OBJECT_TYPE_USER:
        //
        //  get the domain name from the ADsPath
        //
        hr = GetDomainFromADsPath (bstrObjectId, szDomainName);
        if (FAILED (hr))
        {
			IASTracePrintf(
                    "Error in Server Information SDO GetDomainInfo()"
                    " - GetDomainFromADsPath() failed with error:%x",
                    hr
                    );
            break;
        }

        //
        //
        //  call the API to get the appropriate info
        //
        hr = ::SdoGetDomainInfo (
                            NULL, 
                            szDomainName, 
                            pDomainType
                            );
        if (FAILED (hr))
        {
			IASTracePrintf(
                "Error in Server Information SDO - GetDomainInfo()"
                " - SdoGetDomainInfo() failed with error:%x",
                hr
                );
            break;
        }

        break;

    default:
		IASTracePrintf(
            "Error in Server Information SDO - GetDomainInfo()"
            " - Invalid object type:%d",
            ObjectType
            );
        hr = E_INVALIDARG;
        break;
    }
    
    return (hr);

}   //  end of CSdoServerInfo::GetDomainInfo method

//++--------------------------------------------------------------
//
//  Function:   GetDomainFromADsPath
//
//  Synopsis:   This is the CSdoServerInfo class private method. 
//              used to convert a ADsPath to a Domain Name
//
//  Arguments:  
//              [in]    LPCWSTR   - ADsPath
//              [out]   PWSTR     - Domain Name
//
//  Returns:    HRESULT	-	status 
//
//
//  History:    MKarki      Created     06/09/98
//
//----------------------------------------------------------------
HRESULT
CSdoServerInfo::GetDomainFromADsPath (
        /*[in]*/    LPCWSTR pObjectId, 
        /*[out]*/   LPWSTR  pszDomainName
        )
{
    _ASSERT ((NULL != pObjectId) && (NULL != pszDomainName));

    //  copy the name to the buffer to be returned
    //
    wcscpy (pszDomainName, pObjectId);

    PWCHAR pTemp = wcschr (pszDomainName, L'/');
    if (NULL != pTemp)
    {
        //
        //  we only need the domain name part of the ADsPath
        //
        *pTemp = L'\0';
    }

    return (S_OK);

}   //  end of CSdoServerInfo::GetDomainFromADsPath method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdouser.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdouser.cpp
//
// Project:     Everest
//
// Description: IAS Server Data Object - User Object Implementation
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sdouser.h"

//////////////////////////////////////////////////////////////////////////////
HRESULT CSdoUser::FinalInitialize(
						  /*[in]*/ bool         fInitNew,
						  /*[in]*/ ISdoMachine* pAttachedMachine
								 )
{
	// Should always have a data store object associated with a user
	//
	_ASSERT( ! fInitNew );

	// Load the persistent User object properties (including the name)
	//
	HRESULT hr = LoadProperties();

	// Don't allow the client application to modify or persist the user name
	//
    PropertyMapIterator p = m_PropertyMap.find(PROPERTY_SDO_NAME);
	_ASSERT( p != m_PropertyMap.end() );
	DWORD dwFlags = ((*p).second)->GetFlags();
	dwFlags |= (SDO_PROPERTY_NO_PERSIST | SDO_PROPERTY_READ_ONLY);
	((*p).second)->SetFlags(dwFlags);

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSdoUser::Apply()
{
   if (m_pDSObject)
   {
      m_pDSObject->Restore();
   }

   return CSdo::Apply();
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CSdoUser::ValidateProperty(
						   /*[in]*/ PSDOPROPERTY pProperty,
						   /*[in]*/ VARIANT* pValue
				                  )
{
	if ( VT_EMPTY == V_VT(pValue) )
		return S_OK;
	else
		return pProperty->Validate(pValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdovendor.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdovendor.h
//
// Project:     Everest
//
// Description: IAS Server Data Object - Vendor Information Object Definition
//
// Author:      TLP 10/21/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_VENDOR_H_
#define _INC_IAS_SDO_VENDOR_H_

#include "resource.h"    // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"         // SDO base class

/////////////////////////////////////////////////////////////////////////////
// CSdoVendor
/////////////////////////////////////////////////////////////////////////////

class CSdoVendor : public CSdo 
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoVendor)
	COM_INTERFACE_ENTRY(ISdo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoVendor);

	/////////////////////////////////////////////////////////////////////////////
	CSdoVendor() { }

	/////////////////////////////////////////////////////////////////////////////
    ~CSdoVendor() { }

private:

	CSdoVendor(const CSdoVendor& rhs);
	CSdoVendor& operator = (CSdoVendor& rhs);
};

#endif // _INC_IAS_SDO_VENDOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdouser.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      sdouser.h
//
// Project:     Everest
//
// Description: IAS Server Data Object - User Object Definition
//
// Author:      TLP 1/23/98
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INC_IAS_SDO_USER_H_
#define _INC_IAS_SDO_USER_H_

#include "resource.h"
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include <sdofactory.h>

/////////////////////////////////////////////////////////////////////////////
// CSdoUser
/////////////////////////////////////////////////////////////////////////////

class CSdoUser : public CSdo
{

public:

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoUser)
	COM_INTERFACE_ENTRY(ISdo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoUser);

	/////////////////////////////////////////////////////////////////////////////
	CSdoUser() { }

	/////////////////////////////////////////////////////////////////////////////
    ~CSdoUser() { }

	/////////////////////////////////////////////////////////////////////////////
	HRESULT FinalInitialize(
				    /*[in]*/ bool         fInitNew,
				    /*[in]*/ ISdoMachine* pAttachedMachine
						   );

   //////////////////////////////////////////////////////////////////////////
   STDMETHOD(Apply)(void);

	/////////////////////////////////////////////////////////////////////////////
	HRESULT ValidateProperty(
				       /*[in]*/ PSDOPROPERTY pProperty,
				       /*[in]*/ VARIANT* pValue
				            );

private:

	CSdoUser(const CSdoUser& rhs);
	CSdoUser& operator = (CSdoUser& rhs);
};

#endif // _INC_IAS_SDO_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\sdoserviceias.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:		sdoserviceias.h
//
// Project:		Everest
//
// Description:	SDO Machine Class Declaration
//
// Author:		TLP 9/1/98
//
///////////////////////////////////////////////////////////////////////////

#ifndef _INC_SDO_SERVICE_IAS_H_
#define _INC_SDO_SERVICE_IAS_H_

#include "resource.h"       // main symbols
#include <ias.h>
#include <sdoiaspriv.h>
#include "sdo.h"
#include <sdofactory.h>
#include "dsconnection.h"

// SCM command for IAS service reset
//
#define		SERVICE_CONTROL_RESET		128

// Number of Service SDO properties
//
#define		MAX_SERVICE_PROPERTIES		8

// IAS Service SDO Property Information
//
typedef struct _IAS_PROPERTY_INFO
{
	LONG	Id;
	LPCWSTR lpszItemProgId;
	LPCWSTR	lpszDSContainerName;

}	IAS_PROPERTY_INFO, *PIAS_PROPERTY_INFO;

/////////////////////////////////////////////////////////////////////////////
// CSdoServiceIAS
/////////////////////////////////////////////////////////////////////////////
class CSdoServiceIAS : public CSdo
{

public:

   void getDataStoreObject(IDataStoreObject** obj) throw ()
   { (*obj = m_pDSObject)->AddRef(); }

////////////////////
// ATL Interface Map
////////////////////
BEGIN_COM_MAP(CSdoServiceIAS)
	COM_INTERFACE_ENTRY(ISdo)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_FUNC(IID_ISdoServiceControl, 0, &CSdoServiceIAS::QueryInterfaceInternal)
	COM_INTERFACE_ENTRY_IID(__uuidof(SdoService), CSdoServiceIAS)
END_COM_MAP()

DECLARE_SDO_FACTORY(CSdoServiceIAS);

	class CSdoServiceControlImpl :
    	public IDispatchImpl<ISdoServiceControl, &IID_ISdoServiceControl, &LIBID_SDOIASLib>
	{

	public:

		CSdoServiceControlImpl(CSdoServiceIAS* pSdoServiceIAS);
		~CSdoServiceControlImpl();

		//////////////////////////////
		// ISdoServiceControl Iterface

		////////////////////////////////////////////////
		// IUnknown methods - delegate to outer IUnknown

		//////////////////////////////////////////////////////////////////////
		STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
		{
            if ( riid == IID_IDispatch )
            {
                *ppv = static_cast<IDispatch*>(this);
                AddRef();
                return S_OK;
            }
            else
            {
                return m_pSdoServiceIAS->QueryInterface(riid, ppv);
            }
        }

		//////////////////////////////////////////////////////////////////////
		STDMETHOD_(ULONG,AddRef)(void)
		{
			return m_pSdoServiceIAS->AddRef();
		}

		//////////////////////////////////////////////////////////////////////
		STDMETHOD_(ULONG,Release)(void)
		{
			return m_pSdoServiceIAS->Release();
		}

		/////////////////////////////
		// ISdoServiceControl Methods

		//////////////////////////////////////////////////////////////////////
		STDMETHOD(StartService)(void);

		//////////////////////////////////////////////////////////////////////
		STDMETHOD(StopService)(void);

		//////////////////////////////////////////////////////////////////////
		STDMETHOD(GetServiceStatus)(
							/*[out]*/ LONG* pServiceStatus
							       );

		//////////////////////////////////////////////////////////////////////
		STDMETHOD(ResetService)(void);

	private:

		//////////////////////////////////////////////////////////////////////
		HRESULT ControlIAS(DWORD dwControl);

		//////////////////////////////////////////////////////////////////////
		CSdoServiceIAS*  m_pSdoServiceIAS;
	};

	/////////////////////////////////////////////////////////////////////////////
	CSdoServiceIAS();

	/////////////////////////////////////////////////////////////////////////////
	~CSdoServiceIAS();

	/////////////////////////////////////////////////////////////////////////////
	HRESULT FinalInitialize(
		            /*[in]*/ bool         fInitNew,
					/*[in]*/ ISdoMachine* pAttachedMachine
					       );

private:

friend CSdoServiceControlImpl;

	/////////////////////////////////////////////////////////////////////////////
	CSdoServiceIAS(const CSdoServiceIAS& rhs);
	CSdoServiceIAS& operator = (CSdoServiceIAS& rhs);

	/////////////////////////////////////////////////////////////////////////////
	HRESULT InitializeProperty(LONG Id);

	LPCWSTR GetServiceName(void);

	/////////////////////////////////////////////////////////////////////////////
	static  HRESULT WINAPI QueryInterfaceInternal(
												  void*   pThis,
												  REFIID  riid,
												  LPVOID* ppv,
												  DWORD_PTR dw
												 );

	// Class that implements ISdoServiceControl
	//
	CSdoServiceControlImpl		m_clsSdoServiceControlImpl;

	// SCM Name of the service
	//
	_variant_t					m_ServiceName;

	// Attached machine
	//
	ISdoMachine*				m_pAttachedMachine;

	// Name of attached computer
	//
	BSTR						m_bstrAttachedComputer;

	// Property status - used for lazy property initialization
	//
	typedef enum _PROPERTY_STATUS
	{
		PROPERTY_UNINITIALIZED,
		PROPERTY_INITIALIZED

	}	PROPERTY_STATUS;

	PROPERTY_STATUS m_PropertyStatus[MAX_SERVICE_PROPERTIES];

};


#endif // _INC_IAS_SDO_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include "statreg.h"
#include "statreg.cpp"
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\statreg.cpp ===
// This is a part of the Active Template Library.
// Copyright (C)  Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////
#define RET_ON_ERROR(x) \
		if (FAILED(hr = x))\
			return hr;
///////////////////////////////////////
#define BREAK_ON_ERROR(x) \
		if (FAILED(hr = x))\
			break;
///////////////////////////////////////
#ifdef _DEBUG
#define REPORT_ERROR(name, func) \
		if (func != ERROR_SUCCESS)\
			ATLTRACE(_T("NON CRITICAL ERROR : %s failed\n"), name);
#define REG_TRACE_RECOVER() \
		if (!bRecover) \
			ATLTRACE(_T("Opened Key %s\n"), szToken); \
		else \
			ATLTRACE(_T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#else //!_DEBUG
#define REG_TRACE_RECOVER()
#define REPORT_ERROR(name, func) \
		func;
#endif //_DEBUG

///////////////////////////////////////
//
//  this value has been changed to 256 bytes for sdoias
//  because on handling sdopipeline.rgs stack overflow takes
//  places due to much stack allocation on recursion
//  MKarki - 4/25/98
//
#define MAX_TYPE            MAX_VALUE
//#define MAX_VALUE           4096
#define MAX_VALUE             256

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

class CParseBuffer
{
public:
	int nPos;
	int nSize;
	LPTSTR p;
	CParseBuffer(int nInitial);
	~CParseBuffer() {CoTaskMemFree(p);}
	BOOL AddChar(TCHAR ch);
	BOOL AddString(LPCOLESTR lpsz);
	LPTSTR Detach();

};

LPCTSTR   rgszNeverDelete[] = //Component Catagories
{
	_T("CLSID"), _T("TYPELIB")
};

const int   cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);

static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

static HKEY WINAPI HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

static HKEY HKeyFromCompoundString(LPTSTR szToken, LPTSTR& szTail)
{
	if (NULL == szToken)
		return NULL;

	LPTSTR lpsz = StrChr(szToken, chDirSep);

	if (NULL == lpsz)
		return NULL;

	szTail = CharNext(lpsz);
	*lpsz = chEOS;
	HKEY hKey = HKeyFromString(szToken);
	*lpsz = chDirSep;
	return hKey;
}

static LPVOID QueryValue(HKEY hKey, LPCTSTR szValName, DWORD& dwType)
{
	DWORD dwCount = 0;

	if (RegQueryValueEx(hKey, szValName, NULL, &dwType, NULL, &dwCount) != ERROR_SUCCESS)
	{
		ATLTRACE(_T("RegQueryValueEx failed for Value %s\n"), szValName);
		return NULL;
	}

	if (!dwCount)
	{
		ATLTRACE(_T("RegQueryValueEx returned 0 bytes\n"));
		return NULL;
	}

	// Not going to Check for fail on CoTaskMemAlloc & RegQueryValueEx as NULL
	// will be returned regardless if anything failed

	LPVOID pData = CoTaskMemAlloc(dwCount);
	RegQueryValueEx(hKey, szValName, NULL, &dwType, (LPBYTE) pData, &dwCount);
	return pData;
}

/////////////////////////////////////////////////////////////////////////////
//

HRESULT CRegParser::GenerateError(UINT nID)
{
//  m_re.m_nID   = nID;
//  m_re.m_cLines = m_cLines;
	return DISP_E_EXCEPTION;
}


CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
	m_cLines            = 1;
}

BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case chSpace:
		case chTab:
		case chCR:
		case chLF:
				return TRUE;
	}

	return FALSE;
}

void CRegParser::IncrementLinePos()
{
	m_pchCur = CharNext(m_pchCur);
	if (chLF == *m_pchCur)
		IncrementLineCount();
}

void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		IncrementLinePos();
}

HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	UINT ichToken = 0;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (chEOS == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		IncrementLinePos(); // Skip Quote

		while (chEOS != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				IncrementLinePos();   // as it has been escaped

			LPTSTR pchPrev = m_pchCur;
			IncrementLinePos();

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (chEOS == *m_pchCur)
		{
			ATLTRACE(_T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = chEOS;
		IncrementLinePos(); // Skip end quote
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (chEOS != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			IncrementLinePos();
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = chEOS;
	}
	return S_OK;
}

static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{szDwordVal,  VT_I4}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	RET_ON_ERROR(NextToken(szTypeToken))
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE(_T("%s Type not supported\n"), szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	RET_ON_ERROR(NextToken(szValue));
	long lVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetValue(szValue, szValueName);
		ATLTRACE(_T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_I4:
		VarI4FromStr(T2OLE(szValue), 0, 0, &lVal);
		lRes = rkParent.SetValue(lVal, szValueName);
		ATLTRACE(_T("Setting Value %d at %s\n"), lVal, !szValueName ? _T("default") : szValueName);
		break;
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		hr = HRESULT_FROM_WIN32(lRes);
	}

	RET_ON_ERROR(NextToken(szToken))

	return S_OK;
}

BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL)))
	{
		ATLTRACE(_T("Should not be here!!\n"));
		_ASSERTE(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE(_T("RegQueryInfoKey Failed "));
		_ASSERTE(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbData = 0;
		lResult = RegQueryValueEx(hkey, NULL, NULL, NULL, NULL, &cbData);

		if (ERROR_SUCCESS == lResult)
			return !cbData;
		else
			return TRUE;
	}

	return cbValues > 0;
}

HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		RET_ON_ERROR(NextToken(szToken))
		// Skip assignment
		SkipWhiteSpace();
		RET_ON_ERROR(NextToken(szValue));
		RET_ON_ERROR(NextToken(szToken))
	}

	return S_OK;
}


HRESULT CRegParser::RegisterSubkeys(HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	TCHAR   szToken[MAX_VALUE];
	LONG    lRes;
	TCHAR   szKey[MAX_VALUE];
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE(_T("Num Els = %d\n"), cbNeverDelete);
	RET_ON_ERROR(NextToken(szToken))  // Should be key name


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			BREAK_ON_ERROR(NextToken(szToken))

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					BREAK_ON_ERROR(NextToken(szToken))
					BREAK_ON_ERROR(SkipAssignment(szToken))
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			BREAK_ON_ERROR(NextToken(szToken))
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			BREAK_ON_ERROR(NextToken(szValueName))
			BREAK_ON_ERROR(NextToken(szToken))

			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover)
				{
					ATLTRACE(_T("Deleting %s\n"), szValueName);
					REPORT_ERROR(_T("RegDeleteValue"), RegDeleteValue(hkParent, szValueName))
				}

				BREAK_ON_ERROR(SkipAssignment(szToken)) // Strip off type
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE(_T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken);
					if (ERROR_SUCCESS != lRes)
						return GenerateError(E_ATL_CREATE_KEY_FAILED);
				}
			}

			BREAK_ON_ERROR(NextToken(szToken))

			if (*szToken == chEquals)
				BREAK_ON_ERROR(AddValue(keyCur, NULL, szToken)) // NULL == default
		}
		else
		{
			if (!bRecover && keyCur.Open(hkParent, szToken) != ERROR_SUCCESS)
				bRecover = TRUE;

			// TRACE out Key open status and if in recovery mode
			REG_TRACE_RECOVER()

			// Remember Subkey
			lstrcpyn(szKey, szToken, MAX_VALUE);

			// If in recovery mode

			if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
			{
				BREAK_ON_ERROR(NextToken(szToken))
				BREAK_ON_ERROR(SkipAssignment(szToken))

				if (*szToken == chLeftBracket)
				{
					BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, bRecover))
					if (bRecover) // Turn off recovery if we are done
					{
						bRecover = bInRecovery;
						ATLTRACE(_T("Ending Recovery Mode\n"));
						BREAK_ON_ERROR(NextToken(szToken))
						BREAK_ON_ERROR(SkipAssignment(szToken))
						continue;
					}
				}

				if (!bRecover && HasSubKeys(keyCur))
				{
					// See if the KEY is in the NeverDelete list and if so, don't
					if (CanForceRemoveKey(szKey))
					{
						ATLTRACE(_T("Deleting non-empty subkey %s by force\n"), szKey);
						REPORT_ERROR(_T("RecurseDeleteKey"), keyCur.RecurseDeleteKey(szKey))
					}
					BREAK_ON_ERROR(NextToken(szToken))
					continue;
				}

				if (bRecover)
					continue;
			}

			if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
			   return GenerateError(E_ATL_CLOSE_KEY_FAILED);

			if (!bRecover && bDelete)
			{
				ATLTRACE(_T("Deleting Key %s\n"), szKey);
				REPORT_ERROR(_T("RegDeleteKey"), RegDeleteKey(hkParent, szKey))
			}

			BREAK_ON_ERROR(NextToken(szToken))
			BREAK_ON_ERROR(SkipAssignment(szToken))
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket)
			{
				BREAK_ON_ERROR(RegisterSubkeys(keyCur.m_hKey, bRegister, FALSE))
				BREAK_ON_ERROR(NextToken(szToken))
			}
		}
	}

	return hr;
}

LPTSTR CParseBuffer::Detach()
{
	LPTSTR lp = p;
	p = NULL;
	return lp;
}

CParseBuffer::CParseBuffer(int nInitial)
{
	nPos = 0;
	nSize = nInitial;
	p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
}

BOOL CParseBuffer::AddString(LPCOLESTR lpsz)
{
	USES_CONVERSION;
	LPCTSTR lpszT = OLE2CT(lpsz);
	while (*lpszT)
	{
		AddChar(*lpszT);
		lpszT++;
	}
	return TRUE;
}

BOOL CParseBuffer::AddChar(TCHAR ch)
{
	if (nPos == nSize) // realloc
	{
      int newSize = nSize * 2;
      void* newPointer = (LPTSTR) CoTaskMemRealloc(p, newSize*sizeof(TCHAR));
      if (newPointer == 0)
      {
         return FALSE;
      }
      else
      {
         nSize = newSize;
         p = static_cast<LPTSTR>(newPointer);
      }
	}
	p[nPos++] = ch;
	return TRUE;
}

HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	_ASSERTE(lpszReg != NULL);
	_ASSERTE(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*m_pchCur != NULL) // look for end
	{
		if (*m_pchCur == _T('%'))
		{
			IncrementLinePos();
			if (*m_pchCur == _T('%'))
				pb.AddChar(*m_pchCur);
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE(_T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				int nLength = (int)(lpszNext - m_pchCur);
				if (nLength > 31)
				{
					hr = E_FAIL;
					break;
				}
				TCHAR buf[32];
				lstrcpyn(buf, m_pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				pb.AddString(lpszVar);
				while (m_pchCur != lpszNext)
					IncrementLinePos();
			}
		}
		else
			pb.AddChar(*m_pchCur);
		IncrementLinePos();
	}
	pb.AddChar(NULL);
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[_MAX_PATH];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

	m_pchCur = szReg;

	// Preprocess szReg

	while (chEOS != *m_pchCur)
	{
		BREAK_ON_ERROR(NextToken(szToken))
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE(_T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		BREAK_ON_ERROR(NextToken(szToken))

		if (chLeftBracket != *szToken)
		{
			ATLTRACE(_T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE(_T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(hkBase, FALSE);
				break;
			}
		}
		else
		{
			BREAK_ON_ERROR(RegisterSubkeys(hkBase, bRegister))
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

HRESULT CExpansionVector::Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;

	EXPANDER* pExpand = NULL;
	ATLTRY(pExpand = new EXPANDER);
	if (pExpand == NULL)
		return E_OUTOFMEMORY;

	DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR);
	DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
	pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
	pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
	if (pExpand->szKey == NULL || pExpand->szValue == NULL)
	{
		CoTaskMemFree(pExpand->szKey);
		CoTaskMemFree(pExpand->szValue);
		delete pExpand;
		return E_OUTOFMEMORY;
	}
	memcpy(pExpand->szKey, lpszKey, cbKey);
	memcpy(pExpand->szValue, lpszValue, cbValue);

	if (m_cEls == m_nSize)
	{
      int newSize = m_nSize * 2;
      void* newPointer = (EXPANDER**)realloc(m_p, newSize*sizeof(EXPANDER*));
      if (newPointer == NULL)
      {
         return E_OUTOFMEMORY;
      }
      else
      {
         m_p = static_cast<EXPANDER **>(newPointer);
         m_nSize = newSize;
      }
	}

	if (NULL != m_p)
	{
		m_p[m_cEls] = pExpand;
		m_cEls++;
	}
	else
		hr = E_OUTOFMEMORY;

	return hr;

}

LPCOLESTR CExpansionVector::Find(LPTSTR lpszKey)
{
	USES_CONVERSION;
	for (int iExpand = 0; iExpand < m_cEls; iExpand++)
	{
		if (!lstrcmpi(OLE2T(m_p[iExpand]->szKey), lpszKey)) //are equal
			return m_p[iExpand]->szValue;
	}
	return NULL;
}

HRESULT CExpansionVector::ClearReplacements()
{
	for (int iExpand = 0; iExpand < m_cEls; iExpand++)
	{
		EXPANDER* pExp = m_p[iExpand];
		CoTaskMemFree(pExp->szValue);
		CoTaskMemFree(pExp->szKey);
		delete pExp;
	}
	m_cEls = 0;
	return S_OK;
}

HRESULT CRegObject::GenerateError(UINT nID)
{
//  re.m_nID    = nID;
//  re.m_cLines = -1;

	return DISP_E_EXCEPTION;
}

HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return hr;
}

HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE(_T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		ATLTRACE(_T("Failed to FindResource on ID:%s TYPE:%s\n"), szID, szType);
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE(_T("Failed to LoadResource \n"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

#ifdef _DEBUG
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;

	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);


	LPCTSTR szReg = OLE2CT(bstrData);

#ifdef _DEBUG
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE(_T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

HRESULT CRegObject::MemMapAndRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE(_T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	if (NULL == hMapping)
	{
		ATLTRACE(_T("Failed to CreateFileMapping\n"));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	LPVOID pMap = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);

	if (NULL == pMap)
	{
		ATLTRACE(_T("Failed to MapViewOfFile\n"));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	LPTSTR szReg = A2T((char*)pMap);

	if (chEOS != szReg[cbFile]) //ensure buffer is NULL terminated
	{
		ATLTRACE(_T("ERROR : Bad or missing End of File\n"));
		return E_FAIL; // make a real error
	}

#ifdef _DEBUG
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	HRESULT hRes = parser.RegisterBuffer(szReg, bRegister);

//  if (FAILED(hRes))
//      re = parser.GetRegException();

	UnmapViewOfFile(pMap);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return hRes;
}

HRESULT STDMETHODCALLTYPE CRegObject::FileRegister(LPCOLESTR bstrFileName)
{
	return MemMapAndRegister(bstrFileName, TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::FileUnregister(LPCOLESTR bstrFileName)
{
	return MemMapAndRegister(bstrFileName, FALSE);
}

HRESULT STDMETHODCALLTYPE CRegObject::StringRegister(LPCOLESTR bstrData)
{
	return RegisterWithString(bstrData, TRUE);
}

HRESULT STDMETHODCALLTYPE CRegObject::StringUnregister(LPCOLESTR bstrData)
{
	return RegisterWithString(bstrData, FALSE);
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

const TCHAR  chSemiColon         = _T(';');
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chEscape            = _T('\\');
const TCHAR  chComma             = _T(',');
const TCHAR  chDelete            = _T('~');
const TCHAR  chEOS               = _T('\0');
const TCHAR  chTab               = _T('\t');
const TCHAR  chLF                = _T('\n');
const TCHAR  chCR                = _T('\r');
const TCHAR  chSpace             = _T(' ');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chVarLead           = _T('%');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
//const LPCTSTR  szRightBracket  = _T("}");
//const LPCTSTR  szLeftBracket   = _T("{");
//const LPCTSTR  szEquals            = _T("=");
//const LPCTSTR  szDirSep          = _T("\\");
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

struct EXPANDER
{
	LPOLESTR    szKey;
	LPOLESTR    szValue;
};

class CExpansionVector
{
public:
	CExpansionVector()
	{
		m_cEls = 0;
		m_nSize=10;
		m_p=(EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
	}
	HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue);
	LPCOLESTR Find(LPTSTR lpszKey);
	HRESULT ClearReplacements();


private:
	EXPANDER** m_p;
	int m_cEls;
	int m_nSize;
};


#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR pszFileName);
	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR pszFileName);
	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR pszData);
	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR pszData);

protected:

	HRESULT MemMapAndRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);


	static HRESULT GenerateError(UINT nID);

	CExpansionVector                                m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};


class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	void    IncrementLinePos();
	void    IncrementLineCount(){m_cLines++;}


	LPTSTR  m_pchCur;
	int     m_cLines;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT nID);
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }

};

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "sdoias.h"
#include "comdef.h"

#include <windows.h>


#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sdo\sdoias\stdstring.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class StdAllocator and the typedefs StdString and StdWString.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef STDSTRING_H
#define STDSTRING_H
#pragma once

#include <cstddef>
#include <string>

// Implements a standard library conformant allocator that uses the run-time's
// private heap for allocations.
template <class T>
class StdAllocator
{
public:
   typedef size_t size_type;
   typedef ptrdiff_t difference_type;
   typedef T* pointer;
   typedef const T* const_pointer;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T value_type;

   template <class U>
   struct rebind
   {
      typedef StdAllocator<U> other;
   };

   StdAllocator() throw ();

   // Lint is not smart enough to recognize copy constructors for template
   //lint -esym(1931, StdAllocator<*>::StdAllocator*)
   StdAllocator(const StdAllocator&) throw ()
   {
   }

   template <class U>
   StdAllocator(const StdAllocator<U>&) throw ()
   {
   }

   ~StdAllocator() throw ();

   pointer address(reference x) const throw ();
   const_pointer address(const_reference x) const throw ();

   pointer allocate(size_type n, const void* hint = 0);
   void deallocate(pointer p, size_type n) throw ();

   size_type max_size() const throw ();

   void construct(pointer p, const T& val);
   void destroy(pointer p) throw ();

   // Non-standard member required by Microsoft's implementation.
   bool operator==(const StdAllocator& rhs) const throw ();
};


// Replacement for std::string.
typedef std::basic_string<
                char,
                std::char_traits<char>,
                StdAllocator<char>
                > StdString;


// Replacement for std::wstring.
typedef std::basic_string<
                wchar_t,
                std::char_traits<wchar_t>,
                StdAllocator<wchar_t>
                > StdWString;


template <class T>
inline StdAllocator<T>::StdAllocator() throw ()
{
}


template <class T>
inline StdAllocator<T>::~StdAllocator() throw ()
{
}


template <class T>
inline __TYPENAME StdAllocator<T>::pointer StdAllocator<T>::address(
                                                    reference x
                                                    ) const throw ()
{
   return &x;
}


template <class T>
inline __TYPENAME StdAllocator<T>::const_pointer StdAllocator<T>::address(
                                                          const_reference x
                                                          ) const throw ()
{
   return &x;
}


template <class T>
inline __TYPENAME StdAllocator<T>::pointer StdAllocator<T>::allocate(
                                                    size_type n,
                                                    const void*
                                                    )
{
   return static_cast<pointer>(operator new (n * sizeof(T)));
}


template <class T>
inline void StdAllocator<T>::deallocate(pointer p, size_type) throw ()
{
   operator delete(p);
}


template <class T>
inline __TYPENAME StdAllocator<T>::size_type StdAllocator<T>::max_size() const throw ()
{
   // Max size supported by the NT heap.
   return MAXINT_PTR;
}


template <class T>
inline void StdAllocator<T>::construct(pointer p, const T& val)
{
   new (p) T(val);
}


template <class T>
inline void StdAllocator<T>::destroy(pointer p) throw ()
{
   p->~T();
}


template <class T>
inline bool StdAllocator<T>::operator==(const StdAllocator&) const throw ()
{
   return true;
}

#endif // STDSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\auditchannel.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    AuditChannel.cpp
//
// SYNOPSIS
//
//    Implements the class AuditChannel.
//
// MODIFICATION HISTORY
//
//    09/05/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <guard.h>
#include <algorithm>

#include <AuditChannel.h>

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    AuditChannel::Clear
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP AuditChannel::Clear()
{
   _com_serialize

   sinks.clear();

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    AuditChannel::Connect
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP AuditChannel::Connect(IAuditSink* pSink)
{
   if (pSink == NULL) { return E_POINTER; }

   _com_serialize

   // Check if we already have this audit sink.
   if (std::find(sinks.begin(), sinks.end(), pSink) != sinks.end())
   {
      return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
   }

   try
   {
      // Insert the interface into the audit sink list.
      sinks.push_back(pSink);
   }
   catch (std::bad_alloc)
   {
      return E_OUTOFMEMORY;
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    AuditChannel::Disconnect
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP AuditChannel::Disconnect(IAuditSink* pSink)
{
   if (pSink == NULL) { return E_POINTER; }

   _com_serialize

   // Find the specified audit sink.
   SinkVector::iterator i = std::find(sinks.begin(), sinks.end(), pSink);

   if (i == sinks.end()) { return E_INVALIDARG; }

   // Erase the audit sink from the list.
   sinks.erase(i);

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    AuditChannel::AuditEvent
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP AuditChannel::AuditEvent(ULONG ulEventID,
                                       ULONG ulNumStrings,
                                       ULONG ulDataSize,
                                       wchar_t** aszStrings,
                                       byte* pRawData)
{
   _ASSERT(ulNumStrings == 0 || aszStrings != NULL);
   _ASSERT(ulDataSize == 0   || pRawData != NULL);

   _com_serialize

   // Forward the data to each sink.
   for (SinkVector::iterator i = sinks.begin(); i != sinks.end(); ++i)
   {
      (*i)->AuditEvent(ulEventID,
                       ulNumStrings,
                       ulDataSize,
                       aszStrings,
                       pRawData);
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\auditor.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    auditor.h
//
// SYNOPSIS
//
//    This file declares the class Auditor
//
// MODIFICATION HISTORY
//
//    02/27/1998    Original version.
//    08/11/1998    Convert to IASTL.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _AUDITOR_H_
#define _AUDITOR_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iastl.h>
#include <iastlb.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Auditor
//
// DESCRIPTION
//
//    This serves as an abstract base class for all auditor plug-ins.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE Auditor
   : public IASTL::IASComponent,
     public IAuditSink
{
public:

BEGIN_COM_MAP(Auditor)
   COM_INTERFACE_ENTRY_IID(__uuidof(IAuditSink),    IAuditSink)
   COM_INTERFACE_ENTRY_IID(__uuidof(IIasComponent), IIasComponent)
END_COM_MAP()

//////////
// IIasComponent
//////////
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
};

#endif  // _AUDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\auditor.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    auditor.cpp
//
// SYNOPSIS
//
//    This file defines the class Auditor
//
// MODIFICATION HISTORY
//
//    02/27/1998    Original version.
//    08/13/1998    Minor clean up.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <iasutil.h>
#include <auditor.h>

HRESULT Auditor::Initialize()
{
   //////////
   // Connect to the audit channel.
   //////////

   CLSID clsid;
   RETURN_ERROR(CLSIDFromProgID(IAS_PROGID(AuditChannel), &clsid));

   CComPtr<IAuditSource> channel;
   RETURN_ERROR(CoCreateInstance(clsid,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 __uuidof(IAuditSource),
                                 (PVOID*)&channel));

   return channel->Connect(this);
}



STDMETHODIMP Auditor::Shutdown()
{
   //////////
   // Disconnect from the audit channel.
   //////////

   CLSID clsid;
   RETURN_ERROR(CLSIDFromProgID(IAS_PROGID(AuditChannel), &clsid));

   CComPtr<IAuditSource> channel;
   RETURN_ERROR(CoCreateInstance(clsid,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 __uuidof(IAuditSource),
                                 (PVOID*)&channel));

   // Ignore disconnect errors.
   channel->Disconnect(this);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\auditchannel.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    AuditChannel.h
//
// SYNOPSIS
//
//    This file describes the class AuditChannel.
//
// MODIFICATION HISTORY
//
//    09/05/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _AUDITCHANNEL_H_
#define _AUDITCHANNEL_H_

#include <iastlb.h>
#include <resource.h>
#include <vector>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AuditChannel
//
// DESCRIPTION
//
//    This class implements the IAuditSource and IAuditSink interfaces.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE AuditChannel : 
   public CComObjectRootEx<CComMultiThreadModel>,
   public CComCoClass<AuditChannel, &__uuidof(AuditChannel)>,
   public IAuditSink,
   public IAuditSource
{
public:

IAS_DECLARE_REGISTRY(AuditChannel, 1, 0, IASCoreLib)
DECLARE_CLASSFACTORY_SINGLETON(AuditChannel)
DECLARE_NOT_AGGREGATABLE(AuditChannel)

BEGIN_COM_MAP(AuditChannel)
   COM_INTERFACE_ENTRY_IID(__uuidof(IAuditSource), IAuditSource)
   COM_INTERFACE_ENTRY_IID(__uuidof(IAuditSink),   IAuditSink)
END_COM_MAP()

//////////
// IAuditSource
//////////
   STDMETHOD(Clear)();
   STDMETHOD(Connect)(IAuditSink* pSink);
   STDMETHOD(Disconnect)(IAuditSink* pSink);

//////////
// IAuditSink
//////////
   STDMETHOD(AuditEvent)(ULONG ulEventID,
                         ULONG ulNumStrings,
                         ULONG ulDataSize,
                         wchar_t** aszStrings,
                         byte* pRawData);

protected:
   typedef std::vector<IAuditSinkPtr> SinkVector;
   SinkVector sinks;
};

#endif  //_AUDITCHANNEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\infobase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    InfoBase.cpp
//
// SYNOPSIS
//
//    This file implements the class InfoBase
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    09/09/1998    Added PutProperty.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <InfoBase.h>
#include <CounterMap.h>

STDMETHODIMP InfoBase::Initialize()
{
   // Initialize the shared memory.
   if (!info.initialize())
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   // Sort the counter map, so we can use bsearch.
   qsort(&theCounterMap,
         sizeof(theCounterMap)/sizeof(RadiusCounterMap),
         sizeof(RadiusCounterMap),
         counterMapCompare);

   // Connect to the audit channel.
   HRESULT hr = Auditor::Initialize();
   if (FAILED(hr))
   {
      info.finalize();
   }

   return hr;
}

STDMETHODIMP InfoBase::Shutdown()
{
   // For some reason, the SDOs call Shutdown on uninitialized components.
   if (getState() != STATE_UNINITIALIZED)
   {
      Auditor::Shutdown();
      info.finalize();
   }

   return S_OK;
}

STDMETHODIMP InfoBase::PutProperty(LONG, VARIANT*)
{
   // Just use this as an opportunity to reset the counter.
   info.onReset();

   return S_OK;
}

STDMETHODIMP InfoBase::AuditEvent(ULONG ulEventID,
                                  ULONG ulNumStrings,
                                  ULONG,
                                  wchar_t** aszStrings,
                                  byte*)
{
   //////////
   // Try to find a counter map entry.
   //////////

   RadiusCounterMap* entry = (RadiusCounterMap*)
      bsearch(&ulEventID,
              &theCounterMap,
              sizeof(theCounterMap)/sizeof(RadiusCounterMap),
              sizeof(RadiusCounterMap),
              counterMapCompare);

   // No entry means this event doesn't trigger a counter, so we're done.
   if (entry == NULL) { return S_OK; }

   if (entry->type == SERVER_COUNTER)
   {
      RadiusServerEntry* pse = info.getServerEntry();

      if (pse)
      {
         InterlockedIncrement((long*)(pse->dwCounters + entry->serverCounter));
      }
   }
   else if (ulNumStrings > 0)  // Can't log client data without the address
   {
      _ASSERT(aszStrings != NULL);
      _ASSERT(*aszStrings != NULL);

      RadiusClientEntry* pce = info.findClientEntry(*aszStrings);

      if (pce)
      {
         InterlockedIncrement((long*)(pce->dwCounters + entry->clientCounter));
      }
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\infobase.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    InfoBase.h
//
// SYNOPSIS
//
//    This file describes the class InfoBase
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    09/09/1998    Added PutProperty.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _INFOBASE_H_
#define _INFOBASE_H_

#include <auditor.h>
#include <resource.h>
#include <InfoShare.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    InfoBase
//
// DESCRIPTION
//
//    The InfoBase connects to the audit channel and maintains the
//    server information base in shared memory.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE InfoBase
   : public Auditor,
     public CComCoClass<InfoBase, &__uuidof(InfoBase)>
{
public:

IAS_DECLARE_REGISTRY(InfoBase, 1, 0, IASCoreLib)

//////////
// IIasComponent
//////////
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT *pValue);

//////////
// IAuditSink
//////////
   STDMETHOD(AuditEvent)(ULONG ulEventID,
                         ULONG ulNumStrings,
                         ULONG ulDataSize,
                         wchar_t** aszStrings,
                         byte* pRawData);

protected:
  InfoShare info;
};

#endif  // _INFOBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\countermap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    CounterMap.h
//
// SYNOPSIS
//
//    This file describes the mapping of IAS Events to InfoBase counters.
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    09/08/1997    Conform to latest rev. of ietf draft.
//    04/23/1999    Include iasevent.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _COUNTERMAP_H_
#define _COUNTERMAP_H_

#include <iasradius.h>

//////////
// Enum for representing the type of counter to be incremented.
//////////
enum RadiusCounterType
{
   SERVER_COUNTER,
   CLIENT_COUNTER
};


//////////
// Struct used for mapping an event (category, ID) tuple to a counter.
//////////
struct RadiusCounterMap
{
   long  event;
   union
   {
      RadiusClientCounter clientCounter;
      RadiusServerCounter serverCounter;
   };
   RadiusCounterType type;
};


//////////
// Array defining all events that will increment counters.
//////////
static RadiusCounterMap theCounterMap[] =
{
   {IAS_EVENT_RADIUS_AUTH_ACCESS_REQUEST,     radiusAuthServAccessRequests,          CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_DUP_ACCESS_REQUEST, radiusAuthServDupAccessRequests,       CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_ACCESS_ACCEPT,      radiusAuthServAccessAccepts,           CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_ACCESS_REJECT,      radiusAuthServAccessRejects,           CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_ACCESS_CHALLENGE,   radiusAuthServAccessChallenges,        CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_MALFORMED_PACKET,   radiusAuthServMalformedAccessRequests, CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_BAD_AUTHENTICATOR,  radiusAuthServBadAuthenticators,       CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_DROPPED_PACKET,     radiusAuthServPacketsDropped,          CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_UNKNOWN_TYPE,       radiusAuthServUnknownType,             CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_DROPPED_PACKET,     radiusAccServPacketsDropped,           CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_REQUEST,            radiusAccServRequests,                 CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_DUP_REQUEST,        radiusAccServDupRequests,              CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_RESPONSE,           radiusAccServResponses,                CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_BAD_AUTHENTICATOR,  radiusAccServBadAuthenticators,        CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_MALFORMED_PACKET,   radiusAccServMalformedRequests,        CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_NO_RECORD,          radiusAccServNoRecord,                 CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_UNKNOWN_TYPE,       radiusAccServUnknownType,              CLIENT_COUNTER},
   {IAS_EVENT_RADIUS_AUTH_INVALID_CLIENT,     (RadiusClientCounter)radiusAuthServTotalInvalidRequests, SERVER_COUNTER},
   {IAS_EVENT_RADIUS_ACCT_INVALID_CLIENT,     (RadiusClientCounter)radiusAccServTotalInvalidRequests,  SERVER_COUNTER}
};


//////////
// Comparsion function used for sorting and searching the counter map.
//////////
int __cdecl counterMapCompare(const void* elem1, const void* elem2)
{
   return (int)(*((long*)elem1) - *((long*)elem2));
}


#endif  // _COUNTERMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\nteventlog.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTEventLog.h
//
// SYNOPSIS
//
//    This file describes the class NTEventLog
//
// MODIFICATION HISTORY
//
//    08/05/1997    Original version.
//    04/19/1998    New trigger/filter model.
//    08/11/1998    Convert to IASTL.
//    04/23/1999    Simplify filtering.
//    02/16/2000    Log Success at the same level as warnings.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTEVENTLOG_H_
#define _NTEVENTLOG_H_

#include <auditor.h>
#include <resource.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTEventLog
//
// DESCRIPTION
//
//    The NTEventLog listens to an EventChannel and logs all received events
//    to the NT Event Log.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NTEventLog
   : public Auditor,
     public CComCoClass<NTEventLog, &__uuidof(NTEventLog)>
{
public:

IAS_DECLARE_REGISTRY(NTEventLog, 1, 0, IASCoreLib)

   NTEventLog() throw ()
      : eventLog(NULL)
   { }
   ~NTEventLog() throw ()
   { if (eventLog) { DeregisterEventSource(eventLog); } }

//////////
// IIasComponent
//////////
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT *pValue);

//////////
// IAuditSink
//////////
   STDMETHOD(AuditEvent)(ULONG ulEventID,
                         ULONG ulNumStrings,
                         ULONG ulDataSize,
                         wchar_t** aszStrings,
                         byte* pRawData);

private:
   // NT event log.
   HANDLE eventLog;

   // Event types to be logged.
   BOOL shouldReport[4];
};

#endif  // _NTEVENTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\infoshare.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    InfoShare.h
//
// SYNOPSIS
//
//    This file describes the class InfoShare.
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    03/17/1998    Added clear() method.
//    06/01/1998    Added default constructor.
//    09/09/1998    Protect client changes with a shared Mutex.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _INFOSHARE_H_
#define _INFOSHARE_H_

#include <iasinfo.h>
#include <guard.h>
#include <nocopy.h>
#include <map>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    InfoShare
//
// DESCRIPTION
//
//    This class manages the shared memory used for exposing server
//    statistics to the outside world.
//
///////////////////////////////////////////////////////////////////////////////
class InfoShare
   : NonCopyable
{
public:

   InfoShare() throw ();
   ~InfoShare() throw ();

   // Returns the RadiusClientEntry struct for the given address.
   RadiusClientEntry* findClientEntry(PCWSTR inetAddress) throw ();

   // Returns the RadiusServerEntry struct.
   RadiusServerEntry* getServerEntry() const throw ()
   { return info ? &(info->seServer) : NULL; }

   // Sets the server reset time.
   void onReset() throw ();

   bool initialize() throw ();
   void finalize() throw ();

protected:
   // Functions to serialize access to the shared memory.
   void Lock() throw ()
   { WaitForSingleObject(monitor, INFINITE); }
   void Unlock() throw ()
   { ReleaseMutex(monitor); }
   
   friend class Guard<InfoShare>;

   // Create a new client entry in shared memory.
   RadiusClientEntry* addClientEntry(DWORD address) throw ();

   // Clear the data structure.
   void clear() throw ();

   // Map addresses to RadiusClientEntry's.
   typedef std::map< DWORD, RadiusClientEntry* > ClientMap;

   ClientMap clients;        // Index of client entries.
   HANDLE monitor;           // Handle of the mutex.
   DWORD pageSize;           // Size of a page (in bytes).
   DWORD committed;          // Number of pages committed.
   DWORD reserved;           // Number of pages reserved.
   HANDLE fileMap;           // Handle of the file mapping.
   RadiusStatistics* info;   // Pointer to shared struct.
};

#endif  // _INFOSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\nteventlog.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTEventLog.cpp
//
// SYNOPSIS
//
//    This file implements the class NTEventLog
//
// MODIFICATION HISTORY
//
//    08/05/1997    Original version.
//    04/19/1998    New trigger/filter model.
//    08/11/1998    Convert to IASTL.
//    04/23/1999    Don't log RADIUS events. Simplify filtering.
//    02/16/2000    Log Success at the same level as warnings.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <iasevent.h>
#include <sdoias.h>
#include <nteventlog.h>

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    NTEventLog::Initialize
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP NTEventLog::Initialize()
{
   // Register the event source ...
   eventLog = RegisterEventSourceW(NULL, IASServiceName);
   if (!eventLog)
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   // ... then connect to the audit channel.
   HRESULT hr = Auditor::Initialize();
   if (FAILED(hr))
   {
      DeregisterEventSource(eventLog);
      eventLog = NULL;
   }

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    NTEventLog::Shutdown
//
///////////////////////////////////////////////////////////////////////////////
HRESULT NTEventLog::Shutdown()
{
   Auditor::Shutdown();

   if (eventLog)
   {
      DeregisterEventSource(eventLog);
      eventLog = NULL;
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    NTEventLog::PutProperty
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP NTEventLog::PutProperty(LONG Id, VARIANT *pValue)
{
   if (pValue == NULL) { return E_INVALIDARG; }

   switch (Id)
   {
      case PROPERTY_EVENTLOG_LOG_APPLICATION_EVENTS:
         shouldReport[IAS_SEVERITY_ERROR] = V_BOOL(pValue);
         break;

      case PROPERTY_EVENTLOG_LOG_MALFORMED:
         shouldReport[IAS_SEVERITY_SUCCESS] = V_BOOL(pValue);
         shouldReport[IAS_SEVERITY_WARNING] = V_BOOL(pValue);
         break;

      case PROPERTY_EVENTLOG_LOG_DEBUG:
         shouldReport[IAS_SEVERITY_INFORMATIONAL] = V_BOOL(pValue);
         break;

      default:
      {
         return DISP_E_MEMBERNOTFOUND;
      }
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    NTEventLog::AuditEvent
//
// DESCRIPTION
//
//    I have intentionally not serialized access to this method. If this
//    method is invoked while another caller is in SetMinSeverity, worst case
//    an event won't get filtered.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP NTEventLog::AuditEvent(
                             ULONG ulEventID,
                             ULONG ulNumStrings,
                             ULONG ulDataSize,
                             wchar_t** aszStrings,
                             byte* pRawData
                             )
{
   // Don't log RADIUS events.
   ULONG facility = (ulEventID & 0x0FFF0000) >> 16;
   if (facility == IAS_FACILITY_RADIUS) { return S_OK; }

   ULONG severity = ulEventID >> 30;

   if (shouldReport[severity])
   {
      WORD type;
      switch (severity)
      {
         case IAS_SEVERITY_ERROR:
            type = EVENTLOG_ERROR_TYPE;
            break;

         case IAS_SEVERITY_WARNING:
            type = EVENTLOG_WARNING_TYPE;
            break;

         default:
            type = EVENTLOG_INFORMATION_TYPE;
      }

      ReportEventW(
          eventLog,
          type,
          0,            // category code
          ulEventID,
          NULL,         // user security identifier
          (WORD)ulNumStrings,
          ulDataSize,
          (LPCWSTR*)aszStrings,
          pRawData
          );
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\dll_bld\iasapi.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines all the non-COM DLL exports for the IAS core.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <iasevent.h>
#include <iastlb.h>
#include <iasutil.h>
#include <varvec.h>
#include <resource.h>
#include <winsock2.h>
#include <svcguid.h>
#include <md5.h>

///////////////////////////////////////////////////////////////////////////////
//
// Audit Channel API
//
///////////////////////////////////////////////////////////////////////////////

// Global pointer to the audit channel.
IAuditSink* pAuditChannel = NULL;

HRESULT
WINAPI
IASReportEvent(
    DWORD dwEventID,
    DWORD dwNumStrings,
    DWORD dwDataSize,
    LPCWSTR* aszStrings,
    LPVOID pRawData
    )
{
   if (pAuditChannel == NULL) { return E_POINTER; }

   return pAuditChannel->AuditEvent(dwEventID,
                                    dwNumStrings,
                                    dwDataSize,
                                    (wchar_t**)aszStrings,
                                    (byte*)pRawData);
}

///////////////////////////////////////////////////////////////////////////////
//
// Thread Pool API
//
///////////////////////////////////////////////////////////////////////////////

#include <dispatcher.h>

// The global dispatcher object.
Dispatcher dispatcher;

BOOL
WINAPI
IASRequestThread(PIAS_CALLBACK pOnStart)
{
  return dispatcher.requestThread(pOnStart);
}

DWORD
WINAPI
IASSetMaxNumberOfThreads(DWORD dwNumberOfThreads)
{
   return dispatcher.setMaxNumberOfThreads(dwNumberOfThreads);
}

DWORD
WINAPI
IASSetMaxThreadIdle(DWORD dwMilliseconds)
{
   return dispatcher.setMaxThreadIdle(dwMilliseconds);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASRegisterComponent
//
// DESCRIPTION
//
//    Updates the registry entries for the specified component.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASRegisterComponent(
    HINSTANCE hInstance,
    REFCLSID clsid,
    LPCWSTR szProgramName,
    LPCWSTR szComponent,
    DWORD dwRegFlags,
    REFGUID tlid,
    WORD wVerMajor,
    WORD wVerMinor,
    BOOL bRegister
    )
{
   //////////
   // Create the registrar object.
   //////////

   CComPtr<IRegistrar> p;
   RETURN_ERROR(CoCreateInstance(CLSID_Registrar,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IRegistrar,
                                 (void**)&p));

   //////////
   // Get the module file name for the component.
   //////////

   WCHAR szModule[MAX_PATH + 1];
   DWORD numberChars = GetModuleFileNameW(hInstance, szModule, MAX_PATH + 1);
   if ((numberChars == 0) || (numberChars == MAX_PATH + 1))
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   //////////
   // Get our module file name.
   //////////

   WCHAR szOurModule[MAX_PATH + 1] = L"";
   if (!GetModuleFileNameW(_Module.GetModuleInstance(),
                           szOurModule,
                           MAX_PATH + 1))
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   //////////
   // Convert the GUID strings.
   //////////

   WCHAR szClsID[40], szLibID[40];
   RETURN_ERROR(StringFromGUID2(
                  clsid,
                  szClsID,
                  sizeof(szClsID) / sizeof(WCHAR)));

   RETURN_ERROR(StringFromGUID2(
                  tlid,
                  szLibID,
                  sizeof(szLibID) / sizeof(WCHAR)));

   //////////
   // Convert the version to a string.
   //////////

   WCHAR szMajor[7] = L"";
   wsprintfW(szMajor, L"%d", wVerMajor);
   WCHAR szMinor[7] = L"";
   wsprintfW(szMinor, L"%d", wVerMinor);

   //////////
   // Parse the bit flags.
   //////////

   PCWSTR szContext, szAttributes, szModel;

   if (dwRegFlags & IAS_REGISTRY_LOCAL)
   {
      szContext = L"LocalServer32";
   }
   else
   {
      szContext = L"InprocServer32";
   }


   if (dwRegFlags & IAS_REGISTRY_AUTO)
   {
      szAttributes = L"Programmable";
   }
   else
   {
      szAttributes = L"";
   }

   if (dwRegFlags & IAS_REGISTRY_BOTH)
   {
      szModel = L"Both";
   }
   else if (dwRegFlags & IAS_REGISTRY_APT)
   {
      szModel = L"Apartment";
   }
   else
   {
      szModel = L"Free";
   }


   //////////
   // Add the replacement strings.
   //////////

   RETURN_ERROR(p->AddReplacement(L"MODULE",     szModule));
   RETURN_ERROR(p->AddReplacement(L"CLSID",      szClsID));
   RETURN_ERROR(p->AddReplacement(L"PROGRAM",    szProgramName));
   RETURN_ERROR(p->AddReplacement(L"COMPONENT",  szComponent));
   RETURN_ERROR(p->AddReplacement(L"TYPENAME",   L" "));
   RETURN_ERROR(p->AddReplacement(L"LIBID",      szLibID));
   RETURN_ERROR(p->AddReplacement(L"MAJORVER",   szMajor));
   RETURN_ERROR(p->AddReplacement(L"MINORVER",   szMinor));
   RETURN_ERROR(p->AddReplacement(L"CONTEXT",    szContext));
   RETURN_ERROR(p->AddReplacement(L"ATTRIBUTES", szAttributes));
   RETURN_ERROR(p->AddReplacement(L"MODEL",      szModel));

   //////////
   // Now we either register or unregister the component based on the
   // bRegister flag.
   //////////

   HRESULT hr;
   if (bRegister)
   {
      hr = p->ResourceRegister(szOurModule, IDR_IASCOM, L"REGISTRY");
   }
   else
   {
      hr = p->ResourceUnregister(szOurModule, IDR_IASCOM, L"REGISTRY");
   }

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASAdler32
//
// DESCRIPTION
//
//    Computes the Adler-32 checksum of a buffer.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASAdler32(
    CONST BYTE *pBuffer,
    DWORD nBufferLength
    )
{
   static const DWORD ADLER_BASE = 65521;

   DWORD s1 = 1;
   DWORD s2 = 0;

   while (nBufferLength--)
   {
      s1 = (s1 + *pBuffer++) % ADLER_BASE;

      s2 = (s2 + s1) % ADLER_BASE;
   }

   return (s2 << 16) + s1;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASAllocateUniqueID
//
// DESCRIPTION
//
//    Allocates a 32-bit integer that's guaranteed to be unique process-wide.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASAllocateUniqueID( VOID )
{
   static LONG nextID = 0;

   return (DWORD)InterlockedIncrement(&nextID);
}

//////////
// Convert a hex digit to the number it represents.
//////////
inline BYTE digit2Num(WCHAR digit) throw ()
{
   return (digit >= L'0' && digit <= L'9') ? digit - L'0'
                                           : digit - (L'A' - 10);
}

//////////
// Convert a number to a hex representation.
//////////
inline WCHAR num2Digit(BYTE num) throw ()
{
   return (num < 10) ? num + L'0'
                     : num + (L'A' - 10);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASVariantChangeType
//
// DESCRIPTION
//
//    Replacement for VariantChangeType (q.v.) to bypass creating a message
//    loop.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
IASVariantChangeType(
    VARIANT * pvargDest,
    VARIANT * pvarSrc,
    USHORT wFlags,
    VARTYPE vt
    )
{
   // Check the input arguments.
   if (pvargDest == NULL || pvarSrc == NULL)
   {
      return E_INVALIDARG;
   }

   // Is the source already the requested type?
   if (V_VT(pvarSrc) == vt)
   {
      return (pvargDest != pvarSrc) ? VariantCopy(pvargDest, pvarSrc) : S_OK;
   }

   VARIANT varTmp;
   VariantInit(&varTmp);

   switch (MAKELONG(vt, V_VT(pvarSrc)))
   {
      case MAKELONG(VT_BOOL, VT_BSTR):
      {
         if (V_BSTR(pvarSrc) == NULL) { return DISP_E_TYPEMISMATCH; }
         V_BOOL(&varTmp) = (VARIANT_BOOL)
                           _wtol(V_BSTR(pvarSrc)) ? VARIANT_TRUE
                                                  : VARIANT_FALSE;
         break;
      }

      case MAKELONG(VT_I4,   VT_BSTR):
      {
         if (V_BSTR(pvarSrc) == NULL) { return DISP_E_TYPEMISMATCH; }
         V_I4(&varTmp) = _wtol(V_BSTR(pvarSrc));
         break;
      }

      case MAKELONG((VT_UI1 | VT_ARRAY) , VT_BSTR):
      {
         // Extract the source string.
         PCWSTR src = V_BSTR(pvarSrc);
         if (src == NULL) { return DISP_E_TYPEMISMATCH; }
         LONG srclen = wcslen(src);

         // Compute the destination length.
         if (srclen & 1) { return DISP_E_TYPEMISMATCH; }
         LONG dstlen = srclen / 2;

         // Allocate a SAFEARRAY of bytes to hold the octets.
         CVariantVector<BYTE> vec(&varTmp, dstlen);
         PBYTE dst = vec.data();

         // Loop through the source and convert.
         while (dstlen--)
         {
            *dst    = digit2Num(*src++) << 4;
            *dst++ |= digit2Num(*src++);
         }

         break;
      }

      case MAKELONG(VT_BSTR, VT_BOOL):
      {
         V_BSTR(&varTmp) = SysAllocString(V_BOOL(pvarSrc) ? L"-1" : L"0");
         if (V_BSTR(&varTmp) == NULL) { return E_OUTOFMEMORY; }
         break;
      }

      case MAKELONG(VT_BSTR, VT_I4):
      {
         WCHAR buffer[12];
         V_BSTR(&varTmp) = SysAllocString(_ltow(V_I4(pvarSrc), buffer, 10));
         if (V_BSTR(&varTmp) == NULL) { return E_OUTOFMEMORY; }
         break;
      }

      case MAKELONG(VT_BSTR, (VT_UI1 | VT_ARRAY)):
      {
         // Extract the source octets.
         CVariantVector<BYTE> vec(pvarSrc);
         CONST BYTE* src = vec.data();
         LONG srclen = vec.size();

         // Allocate space for the 'stringized' version.
         PWCHAR dst = SysAllocStringLen(NULL, srclen * 2);
         if (dst == NULL) { return E_OUTOFMEMORY; }
         V_BSTR(&varTmp) = dst;

         // Loop through and convert.
         while (srclen--)
         {
            *dst++ = num2Digit(*src >> 4);
            *dst++ = num2Digit(*src++ & 0xF);
         }

         // Add a null-terminator.
         *dst = L'\0';
         break;
      }

      default:
         return DISP_E_TYPEMISMATCH;
   }

   // We successfully converted, so set the type.
   V_VT(&varTmp) = vt;

   // Free the destination.
   VariantClear(pvargDest);

   // Copy in the coerced variant.
   *pvargDest = varTmp;

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Routines to handle startup and shutdown.
//
///////////////////////////////////////////////////////////////////////////////

// Reference count for the IAS API.
LONG refCount = 0;

// Shared local dictionary.
VARIANT theDictionaryStorage;

BOOL
WINAPI
IASInitialize(VOID)
{
   HRESULT hr;
   DWORD error;
   WSADATA wsaData;

   // Global lock to serialize access.
   IASGlobalLockSentry sentry;

   // If we're already initialized, there's nothing to do.
   if (refCount > 0)
   {
      ++refCount;
      return TRUE;
   }

   // Initialize the audit channel.
   hr = CoCreateInstance(__uuidof(AuditChannel),
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         __uuidof(IAuditSink),
                         (PVOID*)&pAuditChannel);
   if (FAILED(hr))
   {
      SetLastError(hr);
      goto auditor_failed;
   }

   // Initialize winsock.
   error = WSAStartup(MAKEWORD(2, 0), &wsaData);
   if (error)
   {
      SetLastError(error);
      goto wsa_failed;
   }

   // Initialize the thread pool.
   if (!dispatcher.initialize())
   {
      goto thrdpool_failed;
   }

   // Everything succeeded, so bump up the refCount.
   ++refCount;
   return TRUE;

thrdpool_failed:
   WSACleanup();

wsa_failed:
   pAuditChannel->Release();
   pAuditChannel = NULL;

auditor_failed:
   return FALSE;
}


VOID
WINAPI
IASUninitialize( VOID)
{
   IASGlobalLockSentry sentry;

   _ASSERT(refCount != 0);

   if (--refCount == 0)
   {
      // Shutdown the thread pool. This blocks until all threads have exited.
      dispatcher.finalize();

      // Shutdown winsock.
      WSACleanup();

      // Shutdown the audit channel.
      pAuditChannel->Release();
      pAuditChannel = NULL;

      // Shutdown the dictionary.
      VariantClear(&theDictionaryStorage);
   }
}

VOID
WINAPI
IASRadiusCrypt(
    BOOL encrypt,
    BOOL salted,
    const BYTE* secret,
    ULONG secretLen,
    const BYTE* reqAuth,
    PBYTE buf,
    ULONG buflen
    )
{
   MD5_CTX context;
   BYTE cipherText[MD5DIGESTLEN];
   BYTE *p;
   const BYTE *end, *endBlock, *ct, *src;
   WORD salt;
   static LONG theNextSalt;

   // Use the Request-Authenticator as the first block of ciphertext.
   ct = reqAuth;

   // Compute the beginning and end of the data to be crypted.
   p   = buf;
   end = buf + buflen;

   // Is the buffer salted ?
   if (salted)
   {
      if (encrypt)
      {
         // Get the next salt value.
         salt = (WORD)(++theNextSalt);
         // High bit must be set.
         salt |= 0x8000;
         // Store at the front of the buffer.
         IASInsertWORD(buf, salt);
      }

      // Skip past the salt.
      p += 2;
   }

   // Loop through the buffer.
   while (p < end)
   {
      // Compute the digest.
      MD5Init(&context);
      MD5Update(&context, secret, secretLen);
      MD5Update(&context, ct, MD5DIGESTLEN);
      if (salted)
      {
         MD5Update(&context, buf, 2);
         // Only use the salt on the first pass.
         salted = FALSE;
      }
      MD5Final(&context);

      // Find the end of the block to be decrypted.
      endBlock = p + MD5DIGESTLEN;
      if (endBlock >= end)
      {
         // We've reached the end of the buffer.
         endBlock = end;
      }
      else
      {
         // Save the ciphertext for the next pass.
         ct = encrypt ? p : (PBYTE)memcpy(cipherText, p, MD5DIGESTLEN);
      }

      // Crypt the block.
      for (src = context.digest; p < endBlock; ++p, ++src)
      {
         *p ^= *src;
      }
   }
}

/////////
// Unicode version of gethostbyname. The caller must free the returned hostent
// struct by calling LocalFree.
/////////
PHOSTENT
WINAPI
IASGetHostByName(
    IN PCWSTR name
    )
{
   // We put these at function scope, so we can clean them up on the way out.
   DWORD error = NO_ERROR;
   HANDLE lookup = NULL;
   union
   {
      WSAQUERYSETW querySet;
      BYTE buffer[512];
   };
   PWSAQUERYSETW result = NULL;
   PHOSTENT retval = NULL;

   do
   {
      if (!name)
      {
         // A NULL name means use the local host, so allocate a buffer ...
         DWORD size = 0;
         GetComputerNameEx(
             ComputerNamePhysicalDnsFullyQualified,
             NULL,
             &size
             );
         PWSTR buf = (PWSTR)_alloca(size * sizeof(WCHAR));

         // ... and get the local DNS name.
         if (!GetComputerNameEx(
                  ComputerNamePhysicalDnsFullyQualified,
                  buf,
                  &size
                  ))
         {
            error = GetLastError();
            break;
         }

         name = buf;
      }

      //////////
      // Create the query set
      //////////

      GUID hostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
      AFPROTOCOLS protocols[2] =
      {
         { AF_INET, IPPROTO_UDP },
         { AF_INET, IPPROTO_TCP }
      };
      memset(&querySet, 0, sizeof(querySet));
      querySet.dwSize = sizeof(querySet);
      querySet.lpszServiceInstanceName = (PWSTR)name;
      querySet.lpServiceClassId = &hostAddrByNameGuid;
      querySet.dwNameSpace = NS_ALL;
      querySet.dwNumberOfProtocols = 2;
      querySet.lpafpProtocols = protocols;

      //////////
      // Execute the query.
      //////////

      error = WSALookupServiceBeginW(
                  &querySet,
                  LUP_RETURN_ADDR,
                  &lookup
                  );
      if (error)
      {
         error = WSAGetLastError();
         break;
      }

      //////////
      // How much space do we need for the result?
      //////////

      DWORD length = sizeof(buffer);
      error = WSALookupServiceNextW(
                    lookup,
                    0,
                    &length,
                    &querySet
                    );
      if (!error)
      {
         result = &querySet;
      }
      else
      {
         error = WSAGetLastError();
         if (error != WSAEFAULT)
         {
            break;
         }

         /////////
         // Allocate memory to hold the result.
         /////////

         result = (PWSAQUERYSETW)LocalAlloc(0, length);
         if (!result)
         {
            error = WSA_NOT_ENOUGH_MEMORY;
            break;
         }

         /////////
         // Get the result.
         /////////

         error = WSALookupServiceNextW(
                     lookup,
                     0,
                     &length,
                     result
                     );
         if (error)
         {
            error = WSAGetLastError();
            break;
         }
      }

      if (result->dwNumberOfCsAddrs == 0)
      {
         error = WSANO_DATA;
         break;
      }

      ///////
      // Allocate memory to hold the hostent struct
      ///////

      DWORD naddr = result->dwNumberOfCsAddrs;
      SIZE_T nbyte = sizeof(hostent) +
                     (naddr + 1) * sizeof(char*) +
                     naddr * sizeof(in_addr);
      retval = (PHOSTENT)LocalAlloc(0, nbyte);
      if (!retval)
      {
         error = WSA_NOT_ENOUGH_MEMORY;
         break;
      }

      ///////
      // Initialize the hostent struct.
      ///////

      retval->h_name = NULL;
      retval->h_aliases = NULL;
      retval->h_addrtype = AF_INET;
      retval->h_length = sizeof(in_addr);
      retval->h_addr_list = (char**)(retval + 1);

      ///////
      // Store the addresses.
      ///////

      u_long* nextAddr = (u_long*)(retval->h_addr_list + naddr + 1);

      for (DWORD i = 0; i < naddr; ++i)
      {
         sockaddr_in* sin = (sockaddr_in*)
            result->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

         retval->h_addr_list[i] = (char*)nextAddr;

         *nextAddr++ = sin->sin_addr.S_un.S_addr;
      }

      ///////
      // NULL terminate the address list.
      ///////

      retval->h_addr_list[i] = NULL;

   } while (FALSE);

   //////////
   // Clean up and return.
   //////////

   if (result && result != &querySet) { LocalFree(result); }

   if (lookup) { WSALookupServiceEnd(lookup); }

   if (error)
   {
      if (error == WSASERVICE_NOT_FOUND) { error = WSAHOST_NOT_FOUND; }

      WSASetLastError(error);
   }

   return retval;
}

/////////
// Fill in an IASTable struct from a VARIANT containing the table data.
/////////
HRESULT ExtractTableFromVariant(
            IN VARIANT* var,
            OUT IASTable* table
            ) throw ()
{
   // Check the arguments.
   if (!var || !table) { return E_POINTER; }

   // Outer VARIANT must be an array of VARIANTs.
   if (V_VT(var) != (VT_ARRAY | VT_VARIANT)) { return E_INVALIDARG; }

   // Array must be 1D with exactly 3 elements.
   LPSAFEARRAY array = V_ARRAY(var);
   if (array->cDims != 1 || array->rgsabound[0].cElements != 3)
   {
      return E_INVALIDARG;
   }

   // tableData is an array of three variants:
   //   (1) Column names
   //   (2) Column types.
   //   (3) Table data matrix.
   VARIANT* tableData = (VARIANT*)(array->pvData);

   // Process the column names.
   VARIANT* namesVariant = tableData + 0;

   // The VARIANT must be an array of BSTRs.
   if (V_VT(namesVariant) != (VT_ARRAY | VT_BSTR)) { return E_INVALIDARG; }

   // Array must be 1D.
   LPSAFEARRAY namesArray = V_ARRAY(namesVariant);
   if (namesArray->cDims != 1) { return E_INVALIDARG; }

   // Store the info in the IASTable.
   table->numColumns = namesArray->rgsabound[0].cElements;
   table->columnNames = (BSTR*)(namesArray->pvData);

   // Process the column types.
   VARIANT* typesVariant = tableData + 1;

   // The VARIANT must be an array of shorts.
   if (V_VT(typesVariant) != (VT_ARRAY | VT_UI2)) { return E_INVALIDARG; }

   // Array must be 1D with 1 element per column.
   LPSAFEARRAY typesArray = V_ARRAY(typesVariant);
   if (typesArray->cDims != 1 ||
       typesArray->rgsabound[0].cElements != table->numColumns)
   {
      return E_INVALIDARG;
   }

   // Store the info in the IASTable.
   table->columnTypes = (VARTYPE*)(namesArray->pvData);

   // Process the table data matrix.
   VARIANT* tableVariant = tableData + 2;

   // The VARIANT must be an array of VARIANTs.
   if (V_VT(tableVariant) != (VT_ARRAY | VT_VARIANT)) { return E_INVALIDARG; }

   // Array must be 2D with 1st dim equal to number of columns.
   LPSAFEARRAY tableArray = V_ARRAY(tableVariant);
   if (tableArray->cDims != 2 ||
       tableArray->rgsabound[0].cElements != table->numColumns)
   {
      return E_INVALIDARG;
   }

   // Store the info in the IASTable.
   table->numRows = tableArray->rgsabound[1].cElements;
   table->table = (VARIANT*)(tableArray->pvData);

   return S_OK;
}

HRESULT
WINAPI
IASGetDictionary(
    IN PCWSTR path,
    OUT IASTable* dnary,
    OUT VARIANT* storage
    )
{
   // Initialize the out parameters.
   VariantInit(storage);

   // Create the AttributeDictionary object.
   HRESULT hr;
   CComPtr<IAttributeDictionary> dnaryObj;
   hr = CoCreateInstance(
            __uuidof(AttributeDictionary),
            NULL,
            CLSCTX_SERVER,
            __uuidof(IAttributeDictionary),
            (PVOID*)&dnaryObj
            );
   if (FAILED(hr)) { return hr; }

   // We need to give the object permission to impersonate us. There's
   // no reason to abort if this fails; we'll just try with the
   // existing blanket.
   CoSetProxyBlanket(
       dnaryObj,
       RPC_C_AUTHN_DEFAULT,
       RPC_C_AUTHZ_DEFAULT,
       COLE_DEFAULT_PRINCIPAL,
       RPC_C_AUTHN_LEVEL_DEFAULT,
       RPC_C_IMP_LEVEL_IMPERSONATE,
       NULL,
       EOAC_DEFAULT
       );

   // Convert the path to a BSTR.
   CComBSTR bstrPath(path);
   if (!bstrPath) { return E_OUTOFMEMORY; }

   // Get the dictionary.
   hr = dnaryObj->GetDictionary(bstrPath, storage);
   if (FAILED(hr)) { return hr; }

   hr = ExtractTableFromVariant(storage, dnary);
   if (FAILED(hr)) { VariantClear(storage); }

   return hr;
}

const IASTable*
WINAPI
IASGetLocalDictionary( VOID )
{
   static IASTable theTable;

   // Global lock to serialize access.
   IASGlobalLockSentry sentry;

   // Have we already gotten the local dictionary ?
   if (V_VT(&theDictionaryStorage) == VT_EMPTY)
   {
      HRESULT hr;

      // No, so determine the path ...
      WCHAR path[256];
      DWORD size = sizeof(path)/sizeof(WCHAR);
      hr = IASGetDictionaryPath(path, &size);
      if (hr == NO_ERROR)
      {
         // ... and get the dictionary.
         hr = IASGetDictionary(
                  path,
                  &theTable,
                  &theDictionaryStorage
                  );
      }
      else
      {
         hr = HRESULT_FROM_WIN32(hr);
      }

      if (FAILED(hr))
      {
         SetLastError(hr);
         return NULL;
      }
   }

   return &theTable;
}


CRITICAL_SECTION theGlobalLock;

VOID
WINAPI
IASGlobalLock()
{
   EnterCriticalSection(&theGlobalLock);
}

VOID
WINAPI
IASGlobalUnlock()
{
   LeaveCriticalSection(&theGlobalLock);
}


namespace
{
   // The registry value used to store the license type.
   const wchar_t licenseTypeValue[] = L"LicenseType";
}


DWORD
WINAPI
IASGetLicenseType(
   OUT IAS_LICENSE_TYPE* licenseType
   )
{
   if (licenseType == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   OSVERSIONINFOEXW versionInfo;
   memset(&versionInfo, 0, sizeof(versionInfo));
   versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
   if (!GetVersionExW(reinterpret_cast<OSVERSIONINFOW*>(&versionInfo)))
   {
      return GetLastError();
   }

   if (versionInfo.wProductType == VER_NT_WORKSTATION)
   {
      if ((versionInfo.wSuiteMask &  VER_SUITE_PERSONAL)  != 0)
      {
         *licenseType = IASLicenseTypePersonal;
      }
      else
      {
         *licenseType = IASLicenseTypeProfessional;
      }
   }
   else
   {
      if ((versionInfo.wSuiteMask & VER_SUITE_DATACENTER) != 0)
      {
         *licenseType = IASLicenseTypeDataCenter;
      }
      else if ((versionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) != 0)
      {
         *licenseType = IASLicenseTypeEnterpriseServer;
      }
      else if ((versionInfo.wSuiteMask & VER_SUITE_BLADE) != 0)
      {
         *licenseType = IASLicenseTypeWebBlade;
      }
      else if ((versionInfo.wSuiteMask & VER_SUITE_SMALLBUSINESS) != 0)
      {
         *licenseType = IASLicenseTypeSmallBusinessServer;
      }
      else
      {
         *licenseType = IASLicenseTypeStandardServer;
      }
   }

   return NO_ERROR;
}


DWORD
WINAPI
IASPublishLicenseType(
   IN HKEY hKey
   )
{
   IAS_LICENSE_TYPE licenseType;
   DWORD error = IASGetLicenseType(&licenseType);
   if (error == NO_ERROR)
   {
      DWORD value = licenseType;
      error = RegSetValueEx(
                 hKey,
                 licenseTypeValue,
                 0,
                 REG_DWORD,
                 reinterpret_cast<const BYTE*>(&value),
                 sizeof(value)
                 );
   }

   return error;
}


DWORD
WINAPI
IASGetProductLimits(
   IN LPCWSTR computerName,
   OUT IAS_PRODUCT_LIMITS* limits
   )
{
   DWORD error;
   IAS_LICENSE_TYPE licenseType;

   if (computerName != 0)
   {
      CRegKey remote;
      error = RegConnectRegistryW(
                 computerName,
                 HKEY_LOCAL_MACHINE,
                 &(remote.m_hKey)
                 );
      if (error != NO_ERROR)
      {
         return error;
      }

      CRegKey policy;
      error = policy.Open(remote, IAS_POLICY_KEY);
      if (error != NO_ERROR)
      {
         return error;
      }

      DWORD value;
      error = policy.QueryValue(value, licenseTypeValue);
      if (error == NO_ERROR)
      {
         licenseType = static_cast<IAS_LICENSE_TYPE>(value);
      }
      else if (error == ERROR_FILE_NOT_FOUND)
      {
         // If the value doesn't exist, assume this is a downlevel machine
         // since we didn't create this value before .NET Server.
         licenseType = IASLicenseTypeDownlevel;
      }
      else
      {
         return error;
      }
   }
   else
   {
      error = IASGetLicenseType(&licenseType);
      if (error != NO_ERROR)
      {
         return error;
      }
   }

   return IASGetProductLimitsForType(licenseType, limits);
}


VOID
WINAPI
IASReportLicenseViolation( VOID )
{
   IASReportEvent(IAS_E_SERVICE_LICENSE_VIOLATION, 0, 0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\auditor\infoshare.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    InfoShare.cpp
//
// SYNOPSIS
//
//    This file implements the class InfoShare.
//
// MODIFICATION HISTORY
//
//    09/09/1997    Original version.
//    03/17/1998    Clear data structure at startup and shutdown.
//    04/20/1998    Check if the shared memory is mapped during finalize().
//    09/09/1998    Protect client changes with a shared Mutex.
//    09/17/1998    Fix resize bug.
//    09/28/1999    Only allow Administrators access to mutex.
//    05/19/2000    Fix bug calculating bytes needed.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <iasutil.h>
#include <InfoShare.h>

//////////
// The maximum size of the shared memory segment.
//////////
const DWORD MAX_INFO_SIZE = 0x100000;


InfoShare::InfoShare() throw ()
 : monitor(NULL),
   pageSize(0),
   committed(0),
   reserved(0),
   fileMap(NULL),
   info(NULL)
{ }

InfoShare::~InfoShare() throw ()
{
   if (info != NULL)
   {
      UnmapViewOfFile(info);
   }

   if (fileMap != NULL)
   {
      CloseHandle(fileMap);
   }

   if (monitor != NULL)
   {
      CloseHandle(monitor);
   }
}

RadiusClientEntry* InfoShare::findClientEntry(PCWSTR inetAddress) throw ()
{
   if (!info) { return NULL; }

   DWORD address = ias_inet_wtoh(inetAddress);

   ClientMap::iterator i = clients.find(address);

   // If we found it, return it. Otherwise add a new entry.
   return i != clients.end() ? i->second : addClientEntry(address);
}

void InfoShare::onReset() throw ()
{
   if (info)
   {
      GetSystemTimeAsFileTime((LPFILETIME)&info->seServer.liResetTime);
   }
}

bool InfoShare::initialize() throw ()
{
   // Create the SID for local Administrators.
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
   PSID adminSid = (PSID)_alloca(GetSidLengthRequired(2));
   InitializeSid(
       adminSid,
       &sia,
       2
       );
   *GetSidSubAuthority(adminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
   *GetSidSubAuthority(adminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;

   // Create an ACL giving Administrators all access.
   ULONG cbAcl = sizeof(ACL) +
                 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                 GetLengthSid(adminSid);
   PACL acl = (PACL)_alloca(cbAcl);
   InitializeAcl(
       acl,
       cbAcl,
       ACL_REVISION
       );
   AddAccessAllowedAce(
       acl,
       ACL_REVISION,
       MUTEX_ALL_ACCESS,
       adminSid
       );

   // Create a security descriptor with the above ACL.
   PSECURITY_DESCRIPTOR pSD;
   BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
   pSD = (PSECURITY_DESCRIPTOR)buffer;
   InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
   SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE);

   // Fill in the SECURITY_ATTRIBUTES struct.
   SECURITY_ATTRIBUTES sa;
   sa.nLength = sizeof(sa);
   sa.lpSecurityDescriptor = pSD;
   sa.bInheritHandle = TRUE;

   // Create the mutex.
   monitor = CreateMutex(
                 &sa,
                 FALSE,
                 RadiusStatisticsMutex
                 );
   if (!monitor) { return false; }

   // Determine the page size for this platform.
   SYSTEM_INFO si;
   GetSystemInfo(&si);
   pageSize = si.dwPageSize;

   // Determine the number of pages to reserve.
   reserved = (MAX_INFO_SIZE + pageSize - 1)/pageSize;

   // Create the mapping in the pagefile ...
   PVOID view;
   fileMap = CreateFileMappingW(
                 INVALID_HANDLE_VALUE,
                 NULL,
                 PAGE_READWRITE | SEC_RESERVE,
                 0,
                 reserved * pageSize,
                 RadiusStatisticsName
                 );
   if (!fileMap) { goto close_mutex; }

   // ... and map it into our process.
   view = MapViewOfFile(
              fileMap,
              FILE_MAP_WRITE,
              0,
              0,
              0
              );
   if (!view) { goto close_map; }

   // Commit the first page.
   info = (RadiusStatistics*)VirtualAlloc(
                                 view,
                                 pageSize,
                                 MEM_COMMIT,
                                 PAGE_READWRITE
                                 );
   if (!info) { goto unmap_view; }
   committed = 1;

   Lock();

   // Zero out any data from a previous incarnation.
   clear();

   // Record our start and reset times.
   GetSystemTimeAsFileTime((LPFILETIME)&info->seServer.liStartTime);
   info->seServer.liResetTime = info->seServer.liStartTime;

   Unlock();

   return true;

unmap_view:
   UnmapViewOfFile(view);

close_map:
   CloseHandle(fileMap);
   fileMap = NULL;

close_mutex:
   CloseHandle(monitor);
   monitor = NULL;

   return false;
}

void InfoShare::finalize()
{
   clear();

   UnmapViewOfFile(info);
   info = NULL;

   CloseHandle(fileMap);
   fileMap = NULL;

   CloseHandle(monitor);
   monitor = NULL;
}

RadiusClientEntry* InfoShare::addClientEntry(DWORD address) throw ()
{
   Guard<InfoShare> guard(*this);

   // Double check that the client doesn't exist now that we're serialized.
   ClientMap::iterator i = clients.find(address);
   if (i != clients.end()) { return i->second; }

   // How many bytes will we need to add the new entry?
   DWORD newSize = (info->dwNumClients) * sizeof(RadiusClientEntry) +
                   sizeof(RadiusStatistics);

   // How many pages will we need to add the new entry?
   DWORD pagesNeeded = (newSize + pageSize - 1)/pageSize;

   // Do we have to commit more memory?
   if (pagesNeeded > committed)
   {
      // If we've hit the max or we can't commit anymore, we're done.
      if (pagesNeeded > reserved ||
          !VirtualAlloc(info,
                        pageSize * pagesNeeded,
                        MEM_COMMIT,
                        PAGE_READWRITE))
      {
         return NULL;
      }

      committed = pagesNeeded;
   }

   // Get the next client entry.
   RadiusClientEntry* pce = info->ceClients + info->dwNumClients;

   // Make sure it's zero'ed.
   memset(pce, 0, sizeof(RadiusClientEntry));

   // Set the address.
   pce->dwAddress = address;

   try
   {
      // Insert it into the index.
      clients[address] = pce;
   }
   catch (std::bad_alloc)
   {
      return NULL;
   }

   // Safefly inserted into the index, so increment the number of clients.
   ++(info->dwNumClients);

   return pce;
}


void InfoShare::clear() throw ()
{
   Lock();

   if (info)
   {
      memset(info, 0, sizeof(RadiusStatistics));
   }

   Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\attrcvt.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrcvt.h
//
// SYNOPSIS
//
//    This file declares methods for converting attributes to
//    different formats.
//
// MODIFICATION HISTORY
//
//    02/26/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ATTRCVT_H_
#define _ATTRCVT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaspolcy.h>
#include <winldap.h>

//////////
// Convert a variant to a newly allocated IASATTRIBUTE. The source variant
// will be coerced to the appropriate type.
//////////
PIASATTRIBUTE
WINAPI
IASAttributeFromVariant(
    VARIANT* src,
    IASTYPE type
    ) throw (_com_error);

//////////
// Convert an LDAP berval to a newly allocated IASATTRIBUTE.
//////////
PIASATTRIBUTE
WINAPI
IASAttributeFromBerVal(
    const berval& src,
    IASTYPE type
    ) throw (_com_error);

#endif  // _ATTRCVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\dbconfig.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares functions for loading and storing the database configuration.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef DBCONFIG_H
#define DBCONFIG_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
WINAPI
IASLoadDatabaseConfig(
   PCWSTR server,
   BSTR* initString,
   BSTR* dataSourceName
   );

HRESULT
WINAPI
IASStoreDatabaseConfig(
   PCWSTR server,
   PCWSTR initString,
   PCWSTR dataSourceName
   );

#ifdef __cplusplus
}
#endif
#endif // DBCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\autohdl.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    autohdl.h
//
// SYNOPSIS
//
//    This file defines the class auto_handle.
//
// MODIFICATION HISTORY
//
//    01/27/1998    Original version.
//    02/24/1998    Added the attach() method.
//    11/17/1998    Make type safe.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _AUTOHANDLE_H_
#define _AUTOHANDLE_H_

#include <nocopy.h>

// return type is not a UDT or reference to a UDT.  Will produce errors if
// applied using infix notation
#pragma warning(disable:4284)

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    auto_handle<>
//
///////////////////////////////////////////////////////////////////////////////
template< class T     = HANDLE,
          class PFn   = BOOL (WINAPI*)(HANDLE),
          PFn CloseFn = &CloseHandle
        >
class auto_handle : NonCopyable
{
public:
   typedef T element_type;

   explicit auto_handle(T t = T()) throw ()
      : handle(t)
   { }

   T& operator=(T t) throw ()
   {
      attach(t);

      return handle;
   }

   ~auto_handle() throw ()
   {
      _close();
   }

   T* operator&() throw ()
   {
      close();

      return &handle;
   }

	T operator->() const throw ()
   {
      return handle;
   }

   operator T() throw ()
   {
      return handle;
   }

   operator const T() const throw ()
   {
      return handle;
   }

   bool operator!() const throw ()
   {
      return handle == T();
   }

   operator bool() const throw()
   {
      return !operator!();
   }

   void attach(T t) throw ()
   {
      _close();

      handle = t;
   }

   void close() throw ()
   {
      if (handle != T())
      {
         CloseFn(handle);

         handle = T();
      }
   }

   T get() const throw ()
   {
      return handle;
   }

   T release() throw ()
   {
      T tmp = handle;

      handle = T();

      return tmp;
   }

private:
   void _close() throw ()
   {
      if (handle != T()) { CloseFn(handle); }
   }

   T handle;
};

#endif  // _AUTOHANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\dll_bld\iascore.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    iascore.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    07/09/1997    Original version.
//    11/12/1997    Cleaned up the startup/shutdown code.
//    04/08/1998    Add code for ProductDir registry entry.
//    04/14/1998    Remove SystemMonitor coclass.
//    05/04/1998    Change OBJECT_ENTRY to IASComponentObject.
//    02/18/1999    Move registry values; remove registration code.
//    04/17/2000    Remove Dictionary and DataSource.
//
///////////////////////////////////////////////////////////////////////////////

#include <iascore.h>
#include <loadperf.h>

#include <AuditChannel.h>
#include <InfoBase.h>
#include <NTEventLog.h>

#include <newop.cpp>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(AuditChannel), AuditChannel )
   OBJECT_ENTRY(__uuidof(InfoBase),
                IASTL::IASComponentObject< InfoBase > )
   OBJECT_ENTRY(__uuidof(NTEventLog),
                IASTL::IASComponentObject< NTEventLog > )
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    registerCore
//
// DESCRIPTION
//
//    Add non-COM registry entries for the IAS core.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT registerCore() throw ()
{
   /////////
   // Get the filename for the service DLL.
   /////////

   DWORD error;
   WCHAR filename[MAX_PATH];
   DWORD numberChars = GetModuleFileNameW(
                          _Module.GetModuleInstance(),
                          filename,
                          MAX_PATH
                          );
   if ((numberChars == 0) || (numberChars == MAX_PATH))
   {
      error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   /////////
   // Compute the product dir.
   /////////

   WCHAR prodDir[MAX_PATH];
   wcscpy(wcsrchr(wcscpy(prodDir, filename), L'\\'), L"\\IAS");

   //////////
   // Create the ProductDir entry in the registry.
   //////////

   CRegKey policyKey;
   error = policyKey.Create(
               HKEY_LOCAL_MACHINE,
               IAS_POLICY_KEY,
               NULL,
               REG_OPTION_NON_VOLATILE,
               KEY_SET_VALUE
               );
   if (error) { return HRESULT_FROM_WIN32(error); }

   error = IASPublishLicenseType(policyKey);
   if (error == NO_ERROR)
   {
      error = policyKey.SetValue(prodDir, L"ProductDir");
   }

   return HRESULT_FROM_WIN32(error);
}


extern CRITICAL_SECTION theGlobalLock;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
  if (dwReason == DLL_PROCESS_ATTACH)
  {
     if (!InitializeCriticalSectionAndSpinCount(&theGlobalLock, 0))
     {
        return FALSE;
     }

    _Module.Init(ObjectMap, hInstance);
    DisableThreadLibraryCalls(hInstance);
  }
  else if (dwReason == DLL_PROCESS_DETACH)
  {
    _Module.Term();
    DeleteCriticalSection(&theGlobalLock);
  }
  return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}

// return true is IAS is installed or some other errors occured
// false when the SCM returns ERROR_SERVICE_DOES_NOT_EXIST
bool IsIASInstalled() throw ()
{
   SC_HANDLE manager = OpenSCManager(
                          NULL,
                          SERVICES_ACTIVE_DATABASE,
                          GENERIC_READ
                          );
   if (manager == 0)
   {
      // Should not happen
      _ASSERT(FALSE);
      return true;
   }

   SC_HANDLE service = OpenService(
                          manager,
                          L"IAS",
                          SERVICE_QUERY_STATUS
                          );
   bool iasInstalled;
   if (service != 0)
   {
      // IAS is installed
      CloseServiceHandle(service);
      iasInstalled = true;
   }
   else if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST)
   {
      // This is the only case where it is 100% sure IAS is NOT installed
      iasInstalled = false;
   }

   CloseServiceHandle(manager);

   return iasInstalled;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
   // There was a bug in Win2K that caused the PerfMon counters to be
   // registered even if IAS wasn't installed. 
   BOOL isWow64;
   if (!IsIASInstalled() && 
      ((IsWow64Process(GetCurrentProcess(),&isWow64)) && (!isWow64)))
   {
      // Remove the perf counters only when: 
      // - IAS is not installed
      // - AND the process is native x86 or native ia64, but not wow64
      UnloadPerfCounterTextStringsW(L"LODCTR " IASServiceName, TRUE);   
   }

   HRESULT hr = registerCore();
   if (FAILED(hr)) return hr;

   // registers object, typelib and all interfaces in typelib
   return  _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
  HRESULT hr = _Module.UnregisterServer();
  if (FAILED(hr)) return hr;

  hr = UnRegisterTypeLib(__uuidof(IASCoreLib),
                         1,
                         0,
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                         SYS_WIN32);

  return hr;
}

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\bitvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    BitVec.h
//
// SYNOPSIS
//
//    This file implements the class BitVector
//
// MODIFICATION HISTORY
//
//    02/09/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BITVEC_H_
#define _BITVEC_H_

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    BitVector
//
// DESCRIPTION
//
//    Very simple bit vector optimized for use by the CSimpleTable class.
//
///////////////////////////////////////////////////////////////////////////////
class BitVector
{
public:
   // Type used to store bits.
   typedef unsigned long Bucket;

   BitVector()
      : numBuckets(0), numSet(0), bits(NULL) { }

   ~BitVector()
   {
      delete[] bits;
   }

   // Returns true if any bits are set.
   bool any() const
   {
      return numSet != 0;
   }

   // Returns the number of bits set.
   size_t count() const
   {
      return numSet;
   }

   // Returns true if no bits are set.
   bool none() const
   {
      return numSet == 0;
   }

   // Clears all bits.
   void reset()
   {
      if (any())
      {
         memset(bits, 0, numBuckets * sizeof(Bucket));

         numSet = 0;
      }
   }

   // Resizes the bitvector to have room for at least 'n' bits. Also clears
   // any existing bits.
   void resize(size_t n)
   {
      size_t newBuckets = (n + sizeof(Bucket) - 1)/sizeof(Bucket);

      if (newBuckets >= numBuckets)
      {
         numBuckets = newBuckets;

         delete[] bits;

         bits = new Bucket[numBuckets];
      }

      memset(bits, 0, numBuckets * sizeof(Bucket));

      numSet = 0;
   }

   // Sets the given bit.
   void set(size_t i)
   {
      if (!test(i))
      {
         ++numSet;

         getBucket(i) |= getBit(i);
      }
   }

   // Returns true if the given bit is set.
   bool test(size_t i) const
   {
      return (getBucket(i) & getBit(i)) != 0;
   }

protected:
   // Return the bit for a given index.
   static Bucket getBit(size_t i)
   { return (Bucket)1 << (i % sizeof(Bucket)); }

   // Return the bucket for a given index.
   Bucket& getBucket(size_t i) const
   { return bits[i / sizeof(Bucket)]; }

   size_t numBuckets;  // Number of bit buckets.
   size_t numSet;      // Number of bits currently set.
   Bucket* bits;       // Array of bit buckets.

   // Not implemented.
   BitVector(const BitVector&);
   BitVector& operator=(const BitVector&);
};

#endif  // _BITVEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\eapprofile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class EapProfile.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPROFILE_H
#define EAPPROFILE_H
#pragma once

// Manages the EAP configuration for a profile.
class EapProfile
{
public:
   struct ConstConfigData
   {
      DWORD length;
      const BYTE* value;
   };

   struct ConfigData
   {
      DWORD length;
      BYTE* value;

      operator const ConstConfigData&() const throw ();
      operator ConstConfigData&() throw ();
   };

   EapProfile() throw ();
   ~EapProfile() throw ();

   HRESULT Assign(const EapProfile& rhs) throw ();

   // Load the profile's state from a VARIANT. The VARIANT is in the format
   // used by the SDOs. This function does not clear the supplied VARIANT.
   HRESULT Load(VARIANT& src) throw ();

   // Store the profile's state to a VARIANT. The VARIANT is in the format used
   // by the SDOs. The caller is responsible for deleting the returned VARIANT.
   HRESULT Store(VARIANT& dst) throw ();

   // Returns the number of types configured.
   size_t Size() const throw ();

   // Returns true if there are no types configured.
   bool IsEmpty() const throw ();

   // Clears all the configuration data.
   void Clear() throw ();

   // Clears all the configuration data except the specified type.
   void ClearExcept(BYTE type) throw ();

   // Erases the config for the specified type. Has no effect if the type is
   // not currently set.
   void Erase(BYTE type) throw ();

   // Retrieves the config for the specified EAP type. The data is in the
   // format used by IEAPProviderConfig2. Returns a zero-length value if the
   // per-profile config is not present for the specified type.
   void Get(BYTE type, ConstConfigData& dst) const throw ();

   // Set the config for the specified EAP type. The data is in the format used
   // by IEAPProviderConfig2.
   HRESULT Set(BYTE type, const ConstConfigData& newConfig) throw ();

   // Pop the the configuration for a single type in the format used by the
   // run-time EAP host.  Caller is responsible for freeing the returned buffer
   // using CoTaskMemFree. Behavior is undefined if IsEmpty() == true.
   void Pop(ConfigData& dst) throw ();

   void Swap(EapProfile& other) throw ();

private:
   // The data type used for the sequence.
   typedef unsigned short SeqNum;
   // Size of the sequence number in bytes.
   static const size_t seqNumSize = 2;
   // Maximum number of chunks that the sequence number can support.
   static const size_t maxChunks = 0x10000;
   // Size of the SDO header: type byte + seqNumSize
   static const size_t sdoHeaderSize = 1 + seqNumSize;

   // Extract/Insert the sequence bytes.
   static SeqNum ExtractSequence(const BYTE* src) throw ();
   static void InsertSequence(SeqNum seq, BYTE* dst) throw ();

   // Concatenates the config chunks from the supplied VARIANTs and appends it
   // to the internal array. The chunks must all be from the same EAP type.
   HRESULT GatherAndAppend(
              const VARIANT* first,
              const VARIANT* last
              ) throw ();

   // Breaks the config into chunks and stores it in dst. dst must point to
   // enough storage to hold the scattered config. Upon return, dst points to
   // the element immediately after the scattered chunks.
   HRESULT Scatter(
              const ConstConfigData& src,
              VARIANT*& dst
              ) throw ();

   // Ensures that the internal array can hold at least newCapacity elements.
   HRESULT Reserve(size_t newCapacity) throw ();

   // Returns the number of chunks required to scatter 'data'.
   static size_t ChunksRequired(const ConstConfigData& data) throw ();

   // Returns the length of the embedded SAFEARRAY of BYTEs. Does not check the
   // validity of 'src'.
   static DWORD ExtractLength(const VARIANT& src) throw ();

   // Returns the data from the embedded SAFEARRAY of BYTEs. Does not check the
   // validity of 'src'.
   static const BYTE* ExtractString(const VARIANT& src) throw ();

   // Used for sorting chunks by type and sequence.
   static bool LessThan(const VARIANT& lhs, const VARIANT& rhs) throw ();

   // Ensures that 'value' contains a valid config chunk.
   static HRESULT ValidateConfigChunk(const VARIANT& value) throw ();

   // The maximum size of a chunk, not counting the type and sequence bytes.
   static const size_t maxChunkSize = 4050;

   // The beginning of the config array. This array is stored in run-time
   // format, e.g., all chunks have been gathered and the value contains a lead
   // type byte, but not a sequence number.
   ConfigData* begin;

   // The end of the configured types.
   ConfigData* end;

   // The capacity of the array.
   size_t capacity;

   // Not implemented.
   EapProfile(const EapProfile&);
   EapProfile& operator=(const EapProfile&);
};


inline EapProfile::ConfigData::operator
const EapProfile::ConstConfigData&() const throw ()
{
   return *reinterpret_cast<const ConstConfigData*>(this);
}


inline EapProfile::ConfigData::operator EapProfile::ConstConfigData&() throw ()
{
   return *reinterpret_cast<ConstConfigData*>(this);
}


inline size_t EapProfile::Size() const throw ()
{
   return end - begin;
}


inline bool EapProfile::IsEmpty() const throw ()
{
   return begin == end;
}

#endif // EAPPROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\explicitlink.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ExplicitLink.h
//
// SYNOPSIS
//
//    This file describes the classes ExplicitLinkBase and ExplicitLink<T>.
//
// MODIFICATION HISTORY
//
//    01/12/1998    Original version.
//    06/22/1998    Misc. bug fixes.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EXPLICITLINK_H_
#define _EXPLICITLINK_H_

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ExplicitLinkBase
//
// DESCRIPTION
//
//    This class provides a wrapper around a function pointer that is
//    explicitly loaded from a DLL at run-time.
//
///////////////////////////////////////////////////////////////////////////////
class ExplicitLinkBase
{
public:

   ExplicitLinkBase() throw ()
      : module(NULL), proc(NULL)
   { }

   ExplicitLinkBase(PCWSTR moduleName, PCSTR procName) throw ()
   {
      loadInternal(moduleName, procName);
   }

   ExplicitLinkBase(const ExplicitLinkBase& elb) throw ()
   {
      copyInternal(elb);
   }

   ExplicitLinkBase& operator=(const ExplicitLinkBase& elb) throw ()
   {
      copy(elb);

      return *this;
   }

   ~ExplicitLinkBase() throw ()
   {
      free();
   }

   void copy(const ExplicitLinkBase& original) throw ()
   {
      // Protect against self-assignment.
      if (this != &original)
      {
         free();

         copyInternal(original);
      }
   }

   void free() throw ()
   {
      if (module)
      {
         FreeLibrary(module);

         module = NULL;

         proc = NULL;
      }
   }

   bool isValid() const throw ()
   {
      return proc != NULL;
   }

   bool load(PCWSTR moduleName, PCSTR procName) throw ()
   {
      free();

      loadInternal(moduleName, procName);
      
      return proc != NULL;
   }

   FARPROC operator()() const throw ()
   {
      return proc;
   }

protected:
   HINSTANCE module;   // The DLL containing the function.
   FARPROC proc;       // Pointer to the function.

   // Copy without free.
   void copyInternal(const ExplicitLinkBase& original) throw ()
   {
      WCHAR filename[MAX_PATH + 1];

      if (original.module == NULL ||
          GetModuleFileNameW(original.module, filename, MAX_PATH + 1) == 0)
      {
         module = NULL;
      }
      else
      {
         module = LoadLibraryW(filename);
      }

      proc = module ? original.proc : NULL;
   }

   // Load without free.
   void loadInternal(PCWSTR moduleName, PCSTR procName) throw ()
   {
      module = LoadLibraryW(moduleName);

      proc = module ? GetProcAddress(module, procName) : NULL;
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ExplicitLink<T>
//
// DESCRIPTION
//
//    This class extends ExplicitLinkBase to provide type safety. The template
//    parameter is the actual type of the function pointer.
//
///////////////////////////////////////////////////////////////////////////////
template <class Pfn>
class ExplicitLink : public ExplicitLinkBase
{
public:
   ExplicitLink() throw () { }

   ExplicitLink(PCWSTR moduleName, PCSTR procName) throw ()
      : ExplicitLinkBase(moduleName, procName)
   { }

   Pfn operator()() const throw ()
   {
      return (Pfn)proc;
   }
};

#endif _EXPLICITLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\guard.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Guard.h
//
// SYNOPSIS
//
//    Contains classes for implementing scoped-locking using Win32 criticial
//    sections.
//
// MODIFICATION HISTORY
//
//    07/09/1997    Original version.
//    05/12/1999    Use a spin lock.
//    07/20/1999    Use TryEnterCriticalSection/SwitchToThread
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _GUARD_H_
#define _GUARD_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Guard<class T>
//
// DESCRIPTION
//
//    Implements a scoped lock of type T.  T must define operations Lock() and
//    Unlock().  The lock is acquired in the constructor and released in the
//    destructor.
//
///////////////////////////////////////////////////////////////////////////////
template<class T>
class Guard : NonCopyable
{
public:
   explicit Guard(const T& lock) throw()
      : m_prisoner(const_cast<T&>(lock))
   {
     m_prisoner.Lock();
   }

   ~Guard() throw()
   {
     m_prisoner.Unlock();
   }

protected:
   T& m_prisoner;
};


//////////
//
// Macro used to declare a scoped lock inside a method belonging to a
// subclass of CComObjectRootEx<CComMultiThreadModel>. Useful for free-
// threaded ATL components.
//
//////////
#define _com_serialize \
Guard< CComObjectRootEx<CComMultiThreadModel> > __GUARD__(*this);


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    CCriticalSection
//
// DESCRIPTION
//
//    Simple wrapper around a Win32 critical section.  Suitable for use with
//    the Guard class above.
//
///////////////////////////////////////////////////////////////////////////////
struct CCriticalSection : CRITICAL_SECTION
{
public:
   CCriticalSection()
   {
      InitializeCriticalSection(this);
   }

   ~CCriticalSection()
   {
      DeleteCriticalSection(this);
   }

   void Lock()
   {
      int tries = 0;
      while (!TryEnterCriticalSection(this))
      {
         if (++tries < 100)
         {
            SwitchToThread();
         }
         else
         {
            EnterCriticalSection(this);
            break;
         }
      }
   }

   void Unlock()
   {
      LeaveCriticalSection(this);
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Guardable
//
// DESCRIPTION
//
//    Base class for objects that need to synchronize access. Do not use this
//    for free-threaded COM objects since this functionality already exists in
//    CComObjectRootEx<CComMultiThreadModel>.
//
///////////////////////////////////////////////////////////////////////////////
class Guardable
{
public:
   void Lock() const   { m_monitor.Lock();   }
   void Unlock() const { m_monitor.Unlock(); }
protected:
   mutable CCriticalSection m_monitor;
};


//////////
//
// Macro used to declare a scoped lock inside a method belonging to a
// subclass of Guardable.
//
//////////
#define _serialize Guard<Guardable> __GUARD__(*this);


#endif  // _GUARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\hashmap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    hashmap.h
//
// SYNOPSIS
//
//    This file describes the hash_map template class.
//
// MODIFICATION HISTORY
//
//    11/06/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _HASHMAP_H_
#define _HASHMAP_H_

#include <hashtbl.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    hash_map<Key, Value, Hasher, KeyMatch>
//
// DESCRIPTION
//
//    Extends hash_table (q.v.) to implement a hash map.
//
///////////////////////////////////////////////////////////////////////////////
template <
           class Key,
           class Value,
           class Hasher    = hash_util::Hasher<Key>,
           class KeyMatch  = std::equal_to<Key>
         >
class hash_map
   : public hash_table<
                        Key,
                        Hasher,
                        std::pair<const Key, Value>,
                        ExtractFirst< std::pair<const Key, Value> >,
                        KeyMatch
                      >
{
public:

   typedef typename table_type::const_iterator const_iterator;
   typedef Value referent_type;

   ////////// 
   // The hash map can support a non-const iterator since you can change
   // Value without effecting the hash value.
   ////////// 
   class iterator : public const_iterator
   {
   public:
      iterator(SList* _first, SList* _end)
         : const_iterator(_first, _end)
      {
      }

      value_type& operator*() const
      {
         return node->value;
      }

      value_type* operator->() const
      {
         return &**this;
      }
   };

   hash_map(size_t size = 16)
      : table_type(size) { }

   // non-const version of hash_table::begin
   iterator begin()
   {
      return iterator(table, table + buckets);
   }

   // non-const version of hash_table::find
   value_type* find(const key_type& key)
   {
      return const_cast<value_type*>(table_type::find(key));
   }

   // Duplicates implementation hidden in base class.
   const value_type* find(const key_type& key) const
   {
      return const_cast<value_type*>(table_type::find(key));
   }

   // Allows the map to be indexed like an array.
   referent_type& operator[](const key_type& key)
   {
      // Compute the hash value once.
      size_t hv = hasher(key);

      // See if the key exists.
      const value_type* v = search_bucket(table[hv & mask], key);

      if (!v)
      {
         reserve_space();

         // The key wasn't found, so create a new node using
         // a default referent.

         Node* node = new Node(value_type(key, referent_type()));

         add_entry();

         table[hv & mask].push_front(node);

         v = &node->value;
      }

      return const_cast<referent_type&>(v->second);
   }
};

#endif  // _HASHMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\iascore.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iascore.h
//
// SYNOPSIS
//
//    Common header file for all Everest core components
//
// MODIFICATION HISTORY
//
//    07/09/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASCORE_H_
#define _IASCORE_H_

#define IASCOREAPI

#include <ias.h>

#endif  // _IASCORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\hashtbl.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    hashtbl.h
//
// SYNOPSIS
//
//    This file describes the hash_table template class.
//
// MODIFICATION HISTORY
//
//    09/23/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _HASHTBL_H_
#define _HASHTBL_H_

#include <algorithm>
#include <functional>
#include <string>
#include <iasapi.h>
#include <nocopy.h>


//////////
// TEMPLATE STRUCT identity
//////////
template<class _Ty>
struct identity : std::unary_function<_Ty, _Ty>
{
   _Ty operator()(const _Ty& _X) const
   {
      return _X;
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Caster<Type1, Type2>
//
// DESCRIPTION
//
//    Function class that casts references from Type1 to Type2. Used for
//    the hash table default parameters.
//
///////////////////////////////////////////////////////////////////////////////
template <class Type1, class Type2>
class Caster : public std::unary_function<Type1, const Type2&>
{
public:
   Caster() {}

   const Type2& operator()(const Type1& X) const
   {
      return X;
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ExtractFirst<T>
//
// DESCRIPTION
//
//    Function class that extracts the first item from a pair. Useful for
//    setting up an STL style map where the first item in the pair is the key.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ExtractFirst : public std::unary_function<T, const typename T::first_type&>
{
public:
   const typename T::first_type& operator()(const T& X) const
   {
      return X.first;
   }
};


//////////
// I'm putting all the hash functions inside a namespace since hash
// is such a common identifier.
//////////
namespace hash_util
{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    hash(const std::basic_string<E>& str)
//
// DESCRIPTION
//
//    Function to compute a hash value for an STL string.
//
///////////////////////////////////////////////////////////////////////////////
template <class E>
inline ULONG hash(const std::basic_string<E>& key)
{
   return IASHashBytes((CONST BYTE*)key.data(), key.length() * sizeof(E));
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    hash(ULONG key)
//
//       and
//
//    hash(LONG key)
//
// DESCRIPTION
//
//    Functions to compute a hash value for a 32-bit integer.
//    Uses Robert Jenkins' 32-bit mix function.
//
///////////////////////////////////////////////////////////////////////////////
inline ULONG hash(ULONG key)
{
      key += (key << 12);
      key ^= (key >> 22);

      key += (key <<  4);
      key ^= (key >>  9);

      key += (key << 10);
      key ^= (key >>  2);

      key += (key <<  7);
      key ^= (key >> 12);

      return key;
}

inline ULONG hash(LONG key)
{
   return hash((ULONG)key);
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    hash(const T* key)
//
// DESCRIPTION
//
//    Function to compute a hash value for a pointer.
//    Implements Knuth's multiplicative hash with a bit shift to account for
//    address alignment.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
inline ULONG hash(const T* key)
{
   return 2654435761 * ((unsigned long)key >> 3);
}

//////////
// Overloadings of the above to hash strings.
//////////
template<>
inline ULONG hash<char>(const char* key)
{
   return IASHashBytes((CONST BYTE*)key,
                       key ? strlen(key) : 0);
}

template<>
inline ULONG hash<wchar_t>(const wchar_t* key)
{
   return IASHashBytes((CONST BYTE*)key,
                       key ? wcslen(key) * sizeof(wchar_t) : 0);
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Hasher
//
// DESCRIPTION
//
//    Function class that uses the 'default' hash functions defined above.
//
///////////////////////////////////////////////////////////////////////////////
template <class _Ty>
struct Hasher
   : public std::unary_function<_Ty, ULONG>
{
   ULONG operator()(const _Ty& _X) const
   {
      return hash(_X);
   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ObjectHasher
//
// DESCRIPTION
//
//    Function class that invokes a bound 'hash' method.
//
///////////////////////////////////////////////////////////////////////////////
template <class _Ty>
struct ObjectHasher
   : public std::unary_function<_Ty, ULONG>
{
   ULONG operator()(const _Ty& _X) const
   {
      return _X.hash();
   }
};



} // hash_util


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    hash_table<Key, Hasher, Value, Extractor, KeyMatch>
//
// DESCRIPTION
//
//    Implements a general-purpose hash table. This can implement a map, a
//    set, or a hybrid depending on how Key, Value, and Extractor are
//    specified. Note that the default parameters for Value and Extractor
//    implement a set.
//
// NOTES
//
//    Although I used similar nomenclature, this is not an STL collection.
//    In particular, the iterator does not conform to the STL guidelines.
//
//    This class is not thread safe.
//
///////////////////////////////////////////////////////////////////////////////
template <
           class Key,
           class Hasher    = hash_util::ObjectHasher<Key>,
           class Value     = Key,
           class Extractor = Caster<Value, Key>,
           class KeyMatch  = std::equal_to<Key>
         >
class hash_table : NonCopyable
{
public:
   typedef hash_table<Key, Hasher, Value, Extractor, KeyMatch> table_type;
   typedef Key key_type;
   typedef Value value_type;

protected:

   //////////
   // Singly-linked list node.
   //////////
   struct Node
   {
      Node* next;        // Next node in the list (is NULL for last item).
      value_type value;  // Value stored in this node.

      Node(const value_type& _V) : value(_V) {}

      // Erase the node immediately following this.
      void erase_next()
      {
         Node* node = next;

         next = next->next;

         delete node;
      }
   };

   //////////
   //
   // Singly-linked list. This is not intended to be a general-purpose class;
   // it is only intended to serve as a bucket in a hash table.
   //
   // Note: I have intentionally NOT deleted the list nodes in the destructor.
   //       This is to support the hash_table grow() method.
   //
   //////////
   struct SList
   {
      Node* head;  // The first node in the list (if any).

      SList() : head(NULL) {}

      // Delete all nodes in the list.
      void clear()
      {
         while (head) pop_front();
      }

      // Remove a node from the front of the list.
      void pop_front()
      {
         ((Node*)&head)->erase_next();
      }

      // Add a node to the front of the list.
      void push_front(Node* node)
      {
         node->next = head;

         head = node;
      }
   };

public:

   //////////
   //
   // Hash table iterator.
   //
   // Note: This iterator is NOT safe. If the hash table is resized, the
   //       iterator will no longer be valid.
   //
   //////////
   class const_iterator
   {
   public:
      const_iterator(SList* _first, SList* _end)
         : node(_first->head), bucket(_first), end(_end)
      {
         find_node();
      }

      const value_type& operator*() const
      {
         return node->value;
      }

      const value_type* operator->() const
      {
         return &**this;
      }

      void operator++()
      {
         node = node->next;

         find_node();
      }

      bool more() const
      {
         return bucket != end;
      }

   protected:

      friend table_type;

      Node* MyNode() const
      {
         return node;
      }

      // Advance until we're on a node or we've reached the end.
      void find_node()
      {
         while (!node && ++bucket != end)
         {
            node = bucket->head;
         }
      }

      Node*  node;    // The node under the iterator.
      SList* bucket;  // The current bucket.
      SList* end;     // The end of the bucket array.
   };

   typedef const_iterator iterator;

   //////////
   // Constructor.
   //////////
   hash_table(size_t size = 16,
              const Hasher& h = Hasher(),
              const Extractor& e = Extractor(),
              const KeyMatch& k = KeyMatch())
      : buckets(1),
        entries(0),
        hasher(h),
        extractor(e),
        key_match(k)
   {
      // Set buckets to smallest power of 2 greater than or equal to size.
      while (buckets < size) buckets <<= 1;

      table = new SList[buckets];

      // Calculate the hash mask.
      mask = buckets - 1;
   }

   //////////
   // Destructor.
   //////////
   ~hash_table()
   {
      clear();

      delete[] table;
   }

   //////////
   // Return an iterator positioned at the start of the hash table.
   //////////
   const_iterator begin() const
   {
      return const_iterator(table, table + buckets);
   }

   //////////
   // Clear all entries from the hash table.
   //////////
   void clear()
   {
      if (!empty())
      {
         for (size_t i=0; i<buckets; i++)
         {
            table[i].clear();
         }

         entries = 0;
      }
   }

   bool empty() const
   {
      return entries == 0;
   }

   //////////
   // Erase all entries matching the given key.  Returns the number of entries
   // erased.
   //////////
   size_t erase(const key_type& key)
   {
      size_t erased = 0;

      Node* node = (Node*)&(get_bucket(key).head);

      while (node->next)
      {
         if (key_match(extractor(node->next->value), key))
         {
            node->erase_next();

            ++erased;
         }
         else
         {
            node = node->next;
         }
      }

      entries -= erased;

      return erased;
   }

   //////////
   // Erases the entry under the current iterator.
   //////////
   void erase(iterator& it)
   {
      // Only look in the bucket indicated by the iterator.
      Node* node = (Node*)&(it.bucket->head);

      while (node->next)
      {
         // Look for a pointer match -- not a key match.
         if (node->next == it.node)
         {
            // Advance the iterator to a valid node ...
            ++it;

            // ... then delete the current one.
            node->erase_next();

            break;
         }

         node = node->next;
      }
   }

   //////////
   // Search the hash table for the first entry matching key.
   //////////
   const value_type* find(const key_type& key) const
   {
      return search_bucket(get_bucket(key), key);
   }

   //////////
   // Insert a new entry into the hash table ONLY if the key is unique. Returns
   // true if successful, false otherwise.
   //////////
   bool insert(const value_type& value)
   {
      reserve_space();

      SList& b = get_bucket(extractor(value));

      if (search_bucket(b, extractor(value))) return false;

      b.push_front(new Node(value));

      add_entry();

      return true;
   }

   //////////
   // Insert a new entry into the hash table without checking uniqueness.
   //////////
   void multi_insert(const value_type& value)
   {
      reserve_space();

      get_bucket(extractor(value)).push_front(new Node(value));

      add_entry();
   }

   //////////
   // Inserts the entry if the key is unique. Otherwise, overwrites the first
   // entry found with a matching key. Returns true if an entry was
   // overwritten, false otherwise.
   //////////
   bool overwrite(const value_type& value)
   {
      reserve_space();

      SList& b = get_bucket(extractor(value));

      const value_type* existing = search_bucket(b, extractor(value));

      if (existing)
      {
         // We can get away with modifying the value in place, because we
         // know the hash value must be the same. I destroy the old value
         // and construct a new one inplace, so that Value doesn't need an
         // assignment operator.

         existing->~value_type();

         new ((void*)existing) value_type(value);

         return true;
      }

      b.push_front(new Node(value));

      add_entry();

      return false;
   }

   //////////
   // Return the number of entries in the hash table.
   //////////
   size_t size() const
   {
      return entries;
   }

protected:

   //////////
   // Increment the entries count.
   //////////
   void add_entry()
   {
      ++entries;
   }

   //////////
   // Grow the hash table as needed.  We have to separate reserve_space and
   // add_entry to make the collection exception safe (since there will be
   // an intervening new).
   //////////
   void reserve_space()
   {
      if (entries >= buckets) grow();
   }

   //////////
   // Return the bucket for a given key.
   //////////
   SList& get_bucket(const key_type& key) const
   {
      return table[hasher(key) & mask];
   }

   //////////
   // Increase the capacity of the hash table.
   //////////
   void grow()
   {
      // We must allocate the memory first to be exception-safe.
      SList* newtbl = new SList[buckets << 1];

      // Initialize an iterator for the old table ...
      const_iterator i = begin();

      // ... then swap in the new table.
      std::swap(table, newtbl);

      buckets <<= 1;

      mask = buckets - 1;

      // Iterate through the old and insert the entries into the new.
      while (i.more())
      {
         Node* node = i.MyNode();

         // Increment the iterator ...
         ++i;

         // ... before we clobber the node's next pointer.
         get_bucket(extractor(node->value)).push_front(node);
      }

      // Delete the old table.
      delete[] newtbl;
   }

   //////////
   // Search a bucket for a specified key.
   //////////
   const value_type* search_bucket(SList& bucket, const key_type& key) const
   {
      Node* node = bucket.head;

      while (node)
      {
         if (key_match(extractor(node->value), key))
         {
            return &node->value;
         }

         node = node->next;
      }

      return NULL;
   }

   size_t    buckets;     // The number of buckets in the hash table.
   size_t    mask;        // Bit mask used for reducing hash values.
   size_t    entries;     // The number of entries in the hash table.
   SList*    table;       // An array of buckets.
   Hasher    hasher;      // Used to hash keys.
   Extractor extractor;   // Used to convert values to keys.
   KeyMatch  key_match;   // Used to test keys for equality.
};


#endif  // _HASHTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\iasutf8.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasutf8.h
//
// SYNOPSIS
//
//    Declares functions for converting between UTF-8 and Unicode.
//
// MODIFICATION HISTORY
//
//    01/22/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASUTF8_H_
#define _IASUTF8_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////
// Returns the number of characters required to hold the converted string. The
// source string may not contain nulls.  Returns -1 if 'src' is not a valid
// UTF-8 string.
//////////
LONG
WINAPI
IASUtf8ToUnicodeLength(
    PCSTR src,
    DWORD srclen
    );

//////////
// Returns the number of characters required to hold the converted string.
//////////
LONG
WINAPI
IASUnicodeToUtf8Length(
    PCWSTR src,
    DWORD srclen
    );

/////////
// Converts a UTF-8 string to Unicode.  Returns the number of characters in the
// converted string. The source string may not contain nulls. Returns -1 if
// 'src' is not a valid UTF-8 string.
/////////
LONG
IASUtf8ToUnicode(
    PCSTR src,
    DWORD srclen,
    PWSTR dst
    );

/////////
// Converts a Unicode string to UTF-8.  Returns the number of characters in the
// converted string.
/////////
LONG
IASUnicodeToUtf8(
    PCWSTR src,
    DWORD srclen,
    PSTR dst
    );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // _IASUTF8_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\iasutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasutil.h
//
// SYNOPSIS
//
//    This file declares assorted utility functions, etc.
//
// MODIFICATION HISTORY
//
//    11/14/1997    Original version.
//    12/17/1997    Added conversion routines.
//    01/08/1998    Added RETURN_ERROR macro.
//    02/26/1998    Added ANSI versions of the IP address functions.
//    04/17/1998    Added CComInterlockedPtr.
//    08/11/1998    Major overhaul and consolidation of utility functions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IASUTIL_H_
#define _IASUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// String functions.
//
///////////////////////////////////////////////////////////////////////////////

LPWSTR
WINAPI
ias_wcsdup(
    IN PCWSTR str
    );

LPSTR
WINAPI
com_strdup(
    IN PCSTR str
    );

LPWSTR
WINAPI
com_wcsdup(
    IN PCWSTR str
    );

INT
WINAPI
ias_wcscmp(
    IN PCWSTR str1,
    IN PCWSTR str2
    );

LPWSTR
WINAPIV
ias_makewcs(LPCWSTR, ...);

///////////////////////////////////////////////////////////////////////////////
//
// IP address conversion functions.
//
///////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
ias_inet_wtoh(
    PCWSTR cp
    );

PWSTR
WINAPI
ias_inet_htow(
    IN ULONG addr,
    OUT PWSTR dst
    );

ULONG
WINAPI
ias_inet_atoh(
    PCSTR cp
    );

PSTR
WINAPI
ias_inet_htoa(
    IN ULONG addr,
    OUT PSTR dst
    );

///////////////////////////////////////////////////////////////////////////////
//
// Functions to move integers to and from a buffer.
//
///////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
IASInsertDWORD(
    IN PBYTE pBuffer,
    IN DWORD dwValue
    );

DWORD
WINAPI
IASExtractDWORD(
    IN CONST BYTE *pBuffer
    );

VOID
WINAPI
IASInsertWORD(
    IN PBYTE pBuffer,
    IN WORD wValue
    );

WORD
WINAPI
IASExtractWORD(
    IN CONST BYTE *pBuffer
    );

#ifdef __cplusplus
}
// We need this for std::bad_alloc.
#include <new>

// For _com_error
#include "comdef.h"

///////////////////////////////////////////////////////////////////////////////
//
// Extensions to _com_error to handle Win32 errors.
//
///////////////////////////////////////////////////////////////////////////////

// Exception class for Win32 errors.
class _w32_error : public _com_error
{
public:
   _w32_error(DWORD errorCode) throw ()
      : _com_error(HRESULT_FROM_WIN32(errorCode)) { }

   DWORD Error() const
   {
      return _com_error::Error() & 0x0000FFFF;
   }
};

// Throw a _w32_error.
void __stdcall _w32_issue_error(DWORD errorCode = GetLastError())
   throw (_w32_error);

// Utility functions for checking Win32 return values and throwing an
// exception upon failure.
namespace _w32_util
{
   // Check handles, memory, etc.
   inline void CheckAlloc(const void* p) throw (_w32_error)
   {
      if (p == NULL) { _w32_issue_error(); }
   }

   // Check 32-bit error code.
   inline void CheckError(DWORD errorCode) throw (_w32_error)
   {
      if (errorCode != NO_ERROR) { _w32_issue_error(errorCode); }
   }

   // Check boolean success flag.
   inline void CheckSuccess(BOOL success) throw (_w32_error)
   {
      if (!success) { _w32_issue_error(); }
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous macros.
//
///////////////////////////////////////////////////////////////////////////////

// Allocate an array on the stack.
#define IAS_STACK_NEW(type, count) \
   new (_alloca(sizeof(type) * count)) type[count]

// Safely release an object.
#define IAS_DEREF(obj) \
   if (obj) { (obj)->Release(); (obj) = NULL; }

// Return the error code from a failed COM invocation.  Useful if you don't
// have to do any special clean-up.
#define RETURN_ERROR(expr) \
   { HRESULT __hr__ = (expr); if (FAILED(__hr__)) return __hr__; }

// Catch any exception and return an appropriate error code.
#define CATCH_AND_RETURN() \
   catch (const std::bad_alloc&) { return E_OUTOFMEMORY; } \
   catch (const _com_error& ce)  { return ce.Error(); }    \
   catch (...)                   { return E_FAIL; }

#endif
#endif  // _IASUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\iastl.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Contains class declarations for the Internet Authentication Service
//   Template Library (IASTL).
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASTL_H
#define IASTL_H

//////////
// IASTL must be used in conjuction with ATL.
//////////
#ifndef __ATLCOM_H__
   #error iastl.h requires atlcom.h to be included first
#endif

//////////
// MIDL generated header files containing the interfaces that must be
// implemented by a request handler.
//////////
#include <iascomp.h>
#include <iaspolcy.h>
#include <iastrace.h>

//////////
// Common type library describing all of the request handler interfaces. This
// type library is registered during normal IAS installation; thus, individual
// request handlers should not attempt to install or register this type
// library.
//////////
struct __declspec(uuid("6BC09690-0CE6-11D1-BAAE-00C04FC2E20D")) IASTypeLibrary;

//////////
// The entire library is contained within the IASTL namespace.
//////////
namespace IASTL {

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASComponent
//
// DESCRIPTION
//
//    Serves as an abstract base class for all components that need to
//    implement the IIasComponent interface.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE IASComponent :
   public CComObjectRootEx< CComMultiThreadModel >,
   public IDispatchImpl< IIasComponent,
                         &__uuidof(IIasComponent),
                         &__uuidof(IASTypeLibrary) >,
   private IASTraceInitializer
{
public:

// Interfaces supported by all IAS components.
BEGIN_COM_MAP(IASComponent)
   COM_INTERFACE_ENTRY_IID(__uuidof(IIasComponent), IIasComponent)
   COM_INTERFACE_ENTRY_IID(__uuidof(IDispatch),     IDispatch)
END_COM_MAP()

   // Possible states for a component.
   enum State {
      STATE_SHUTDOWN,
      STATE_UNINITIALIZED,
      STATE_INITIALIZED,
      STATE_SUSPENDED,
      NUM_STATES,
      STATE_UNEXPECTED
   };

   // Events that may trigger state transitions.
   enum Event {
      EVENT_INITNEW,
      EVENT_INITIALIZE,
      EVENT_SUSPEND,
      EVENT_RESUME,
      EVENT_SHUTDOWN,
      NUM_EVENTS
   };

   // Constructor/destructor.
   IASComponent() throw ()
      : state(STATE_SHUTDOWN)
   { }

   // Fire an event on the component.
   HRESULT fireEvent(Event event) throw ();

   // Returns the state of the component.
   State getState() const throw ()
   { return state; }

   //////////
   // IIasComponent.
   //     The derived class may override these as necessary. All of these
   //     methods are serialized by an IASTL subclass, so generally no
   //     additional locking is necessary.
   //////////
   STDMETHOD(InitNew)()
   { return S_OK; }
   STDMETHOD(Initialize)()
   { return S_OK; }
   STDMETHOD(Suspend)()
   { return S_OK; }
   STDMETHOD(Resume)()
   { return S_OK; }
   STDMETHOD(Shutdown)()
   { return S_OK; }
   STDMETHOD(GetProperty)(LONG Id, VARIANT* pValue)
   { return DISP_E_MEMBERNOTFOUND; }
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue)
   { return E_NOTIMPL; }

protected:
   // This should not be defined by the derived class since it is defined in
   // the IASComponentObject<T> class.
   virtual HRESULT attemptTransition(Event event) throw () = 0;

private:
   // State of the component.
   State state;

   // State transition matrix governing the component lifecycle.
   static const State fsm[NUM_EVENTS][NUM_STATES];
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASRequestHandler
//
// DESCRIPTION
//
//    Serves as an abstract base class for all IAS request handlers.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE IASRequestHandler :
   public IASComponent,
   public IDispatchImpl< IRequestHandler,
                         &__uuidof(IRequestHandler),
                         &__uuidof(IASTypeLibrary) >
{
public:

// Interfaces supported by all IAS request handlers.
BEGIN_COM_MAP(IASRequestHandler)
   COM_INTERFACE_ENTRY_IID(__uuidof(IRequestHandler), IRequestHandler)
   COM_INTERFACE_ENTRY_IID(__uuidof(IIasComponent), IIasComponent)
END_COM_MAP()

   //////////
   // IRequestHandler.
   //     This should not be defined by the derived class. Instead handlers
   //     will define either onAsyncRequest or onSyncRequest (q.v.).
   //////////
   STDMETHOD(OnRequest)(IRequest* pRequest);

protected:

   // Must be defined by the derived class to perform actual request
   // processing.
   virtual void onAsyncRequest(IRequest* pRequest) throw () = 0;
};

//////////
// Obsolete.
//////////
#define IAS_DECLARE_OBJECT_ID(id) \
   void getObjectID() const throw () { }

//////////
// Obsolete.
//////////
#define BEGIN_IAS_RESPONSE_MAP()
#define IAS_RESPONSE_ENTRY(val)
#define END_IAS_RESPONSE_MAP()

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASRequestHandlerSync
//
// DESCRIPTION
//
//    Extends IASRequestHandler to provide an abstract base class for request
//    handlers that process requests synchronously.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE IASRequestHandlerSync
   : public IASRequestHandler
{
protected:
   // Must not be defined by the derived class.
   virtual void onAsyncRequest(IRequest* pRequest) throw ();

   // The derived class must define onSyncRequest *instead* of onAsyncRequest.
   // The derived class must not call IRequest::ReturnToSource since this will
   // be invoked automatically after onSyncRequest completes.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw () = 0;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASComponentObject<T>
//
// DESCRIPTION
//
//    Inherits from the user-defined component to enforce the semantics of the
//    component finite state machine.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ATL_NO_VTABLE IASComponentObject
   : public T
{
public:

   DECLARE_NOT_AGGREGATABLE( IASComponentObject<T> );

//////////
// IIasComponent
//////////

   STDMETHOD(InitNew)()
   {
      return fireEvent(EVENT_INITNEW);
   }

   STDMETHOD(Initialize)()
   {
      return fireEvent(EVENT_INITIALIZE);
   }

   STDMETHOD(Suspend)()
   {
      return fireEvent(EVENT_SUSPEND);
   }

   STDMETHOD(Resume)()
   {
      return fireEvent(EVENT_RESUME);
   }

   STDMETHOD(Shutdown)()
   {
      return fireEvent(EVENT_SHUTDOWN);
   }

   STDMETHOD(GetProperty)(LONG Id, VARIANT* pValue)
   {
      // We serialize this method to make it consistent with the others.
      Lock();
      HRESULT hr = T::GetProperty(Id, pValue);
      Unlock();
      return hr;
   }

   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue)
   {
      HRESULT hr;
      Lock();
      // PutProperty is not allowed when the object is shutdown.
      if (getState() != STATE_SHUTDOWN)
      {
         hr = T::PutProperty(Id, pValue);
      }
      else
      {
         hr = E_UNEXPECTED;
      }
      Unlock();
      return hr;
   }

protected:

   //////////
   // Attempt to transition the component to a new state.
   //////////
   virtual HRESULT attemptTransition(IASComponent::Event event) throw ()
   {
      switch (event)
      {
         case EVENT_INITNEW:
            return T::InitNew();
         case EVENT_INITIALIZE:
            return T::Initialize();
         case EVENT_SUSPEND:
            return T::Suspend();
         case EVENT_RESUME:
            return T::Resume();
         case EVENT_SHUTDOWN:
            return T::Shutdown();
      }
      return E_FAIL;
   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASRequestHandlerObject<T>
//
// DESCRIPTION
//
//    This is the most derived class in the inheritance hierarchy. This must
//    be the class instantiated by ATL. Usually, this is accomplished through
//    the ATL Object Map.
//
// EXAMPLE
//
//    class MyHandler : public IASRequestHandlerSync
//    { };
//
//    BEGIN_OBJECT_MAP(ObjectMap)
//       OBJECT_ENTRY(__uuidof(MyHandler), IASRequestHandlerObject<MyHandler> )
//    END_OBJECT_MAP()
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ATL_NO_VTABLE IASRequestHandlerObject
   : public IASComponentObject < T >
{ };

//////////
// End of the IASTL namespace.
//////////
}

#endif  // IASTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\nocopy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    nocopy.h
//
// SYNOPSIS
//
//    This file describes the class NonCopyable.
//
// MODIFICATION HISTORY
//
//    10/19/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NOCOPY_H_
#define _NOCOPY_H_
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NonCopyable
//
// DESCRIPTION
//
//    Prevents instances of derived classes from being copied.
//
///////////////////////////////////////////////////////////////////////////////
class NonCopyable
{
protected:
   NonCopyable() {}
private:
   NonCopyable(const NonCopyable&);
   NonCopyable& operator=(const NonCopyable&);
};

#endif  // _NOCOPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\mempool.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    MemPool.h
//
// SYNOPSIS
//
//    This file describes the class memory_pool.
//
// MODIFICATION HISTORY
//
//    08/04/1997    Original version.
//    11/12/1997    Added the clear() method.
//                  Added code to clobber freed chunks in debug builds.
//    01/08/1998    SunDown changes.
//    04/10/1998    Got rid of the wrapper around InterlockedExchangePointer
//                  since it was causing some inefficient code to be generated.
//    08/06/1998    Support pluggable allocators.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MEMPOOL_H_
#define _MEMPOOL_H_

#include <guard.h>
#include <nocopy.h>

class crt_allocator
{
public:
   static void* allocate(size_t nbyte) throw ()
   {
      return malloc(nbyte);
   }

   static void deallocate(void* p) throw ()
   {
      free(p);
   }
};

class task_allocator
{
public:
   static void* allocate(size_t nbyte) throw ()
   {
      return CoTaskMemAlloc((ULONG)nbyte);
   }

   static void deallocate(void* p) throw ()
   {
      CoTaskMemFree(p);
   }
};

class virtual_allocator
{
public:
   static void* allocate(size_t nbyte) throw ()
   {
      return VirtualAlloc(NULL, (DWORD)nbyte, MEM_COMMIT, PAGE_READWRITE);
   }

   static void deallocate(void* p) throw ()
   {
      VirtualFree(p, 0, MEM_RELEASE);
   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    memory_pool
//
// DESCRIPTION
//
//    Implements a reusable pool of memory chunks of size 'Size'.
//
///////////////////////////////////////////////////////////////////////////////
template < size_t Size, class Allocator >
class memory_pool
   : Guardable, NonCopyable
{
public:
   memory_pool() throw ()
      : pool(NULL)
   { }

   ~memory_pool() throw ()
   {
      clear();
   }

   void clear() throw ()
   {
      Lock();

      // Get the linked list from the pool ...
      void* p = pool;
      pool = NULL;

      Unlock();

      // ... and iterate through deleting each node.
      while (p)
      {
         void* next = *((void**)p);
         Allocator::deallocate(p);
         p = next;
      }
   }

   void* allocate() throw ()
   {
      Lock();

      void* p = pool;

      // Are there any chunks in the pool?
      if (p)
      {
         pool = *(void**)p;

         Unlock();

         return p;
      }

      Unlock();

      // The pool is empty, so call the new operator directly.
      return Allocator::allocate(Size);
   }

   void deallocate(void* p) throw()
   {
      if (p)
      {
#ifdef DEBUG
         memset(p, 0xA3, Size);
#endif

         Lock();

         *((void**)p) = pool;

         pool = p;

         Unlock();
      }
   }

protected:
   void* pool;
};

#endif  // _MEMPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\iastlutl.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    Declares various utility classes, functions, and macros that are useful
//    when implementating a request handler for the Internet Authentication
//    Service.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASTLUTL_H
#define IASTLUTL_H
#pragma once

//////////
// 'C'-style API for manipulating IASATTRIBUTE struct's.
//////////
#include <iasattr.h>

//////////
// 'C'-style API for manipulating dictionary.
//////////
#include <iasapi.h>

//////////
// MIDL generated header files containing interfaces used by request handlers.
//////////
#include <iaspolcy.h>
#include <sdoias.h>

//////////
// The entire library is contained within the IASTL namespace.
//////////
namespace IASTL {

//////////
// This function is called whenever an exception should be thrown. The
// function is declared, but never defined. This allows the user to provide
// their own implementation using an exception class of their choice.
//////////
void __stdcall issue_error(HRESULT hr);

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASAttribute
//
// DESCRIPTION
//
//    Wrapper around an IASATTRIBUTE struct.
//
///////////////////////////////////////////////////////////////////////////////
class IASAttribute
{
public:

   //////////
   // Constructors.
   //////////

   IASAttribute() throw ()
      : p(NULL)
   { }

   explicit IASAttribute(bool alloc)
   {
      if (alloc) { _alloc(); } else { p = NULL; }
   }

   explicit IASAttribute(PIASATTRIBUTE attr, bool addRef = true) throw ()
      : p(attr)
   { if (addRef) { _addref(); } }

   IASAttribute(const IASAttribute& attr) throw ()
      : p(attr.p)
   { _addref(); }

   //////////
   // Destructor.
   //////////

   ~IASAttribute() throw ()
   { _release(); }

   //////////
   // Assignment operators.
   //////////

   IASAttribute& operator=(PIASATTRIBUTE attr) throw ();

   const IASAttribute& operator=(const IASAttribute& attr) throw ()
   { return operator=(attr.p); }

   // Allocate a new attribute. Any existing attribute is first released.
   void alloc()
   {
      _release();
      _alloc();
   }

   // Release the attribute (if any).
   void release() throw ()
   {
      if (p) { IASAttributeRelease(p); p = NULL; }
   }

   // Attach a new attribute to the object. Any existing attribute is first
   // released.
   void attach(PIASATTRIBUTE attr, bool addRef = true) throw ();

   // Detach the attribute from the object. The caller is responsible for
   // releasing the returned attribute.
   PIASATTRIBUTE detach() throw ()
   {
      PIASATTRIBUTE rv = p;
      p = NULL;
      return rv;
   }

   // Load an attribute with the given ID. Returns true if successful, false
   // if no such attribute exists.
   bool load(IAttributesRaw* request, DWORD dwId);

   // Load an attribute with the given ID and verify that it has an
   // appropriate value type. Returns true if successful, false if no such
   // attribute exists.
   bool load(IAttributesRaw* request, DWORD dwId, IASTYPE itType);

   // Store the attribute in a request.
   void store(IAttributesRaw* request) const;

   // Swap the contents of two objects.
   void swap(IASAttribute& attr) throw ()
   {
      PIASATTRIBUTE tmp = p;
      p = attr.p;
      attr.p = tmp;
   }

   //////////
   // Methods for setting the value of an attribute. The object must contain
   // a valid attribute before calling this method. The passed in data is
   // copied.
   //////////

   void setOctetString(DWORD dwLength, const BYTE* lpValue);
   void setOctetString(PCSTR szAnsi);
   void setOctetString(PCWSTR szWide);

   void setString(DWORD dwLength, const BYTE* lpValue);
   void setString(PCSTR szAnsi);
   void setString(PCWSTR szWide);

   //////////
   // Methods for manipulating the dwFlags field.
   //////////

   void clearFlag(DWORD flag) throw ()
   { p->dwFlags &= ~flag; }

   void setFlag(DWORD flag) throw ()
   { p->dwFlags |= flag; }

   bool testFlag(DWORD flag) const throw ()
   { return (p->dwFlags & flag) != 0; }

   // Address-of operator. Any existing attribute is first released.
   PIASATTRIBUTE* operator&() throw ()
   {
      release();
      return &p;
   }

   //////////
   // Assorted useful operators that allow an IASAttribute object to mimic
   // an IASATTRIBUTE pointer.
   //////////

   bool operator !() const throw ()          { return p == NULL; }
   operator bool() const throw ()            { return p != NULL; }
   operator PIASATTRIBUTE() const throw ()   { return p; }
   IASATTRIBUTE& operator*() const throw ()  { return *p; }
   PIASATTRIBUTE operator->() const throw () { return p; }

protected:
   void _addref() throw ()
   { if (p) { IASAttributeAddRef(p); } }

   void _release() throw ()
   { if (p) { IASAttributeRelease(p); } }

   void _alloc()
   { if (IASAttributeAlloc(1, &p)) { issue_error(E_OUTOFMEMORY); } }

   void clearValue() throw ();

   PIASATTRIBUTE p;  // The attribute being wrapped.
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASAttributePosition
//
// DESCRIPTION
//
//    Wrapper around an ATTRIBUTEPOSITION struct.
//
///////////////////////////////////////////////////////////////////////////////
class IASAttributePosition
{
public:
   IASAttributePosition() throw ()
    { pos.pAttribute = 0; }

   explicit IASAttributePosition(const ATTRIBUTEPOSITION& orig) throw ()
      : pos(orig)
   { _addref(); }

   IASAttributePosition(const IASAttributePosition& orig) throw ()
      : pos(orig.pos)
   { _addref(); }

   ~IASAttributePosition() throw ()
   { _release(); }

   IASAttributePosition& operator=(const ATTRIBUTEPOSITION& rhs) throw ();

   IASAttributePosition& operator=(const IASAttributePosition& rhs) throw ()
   { return operator=(rhs.pos); }

   IASAttributePosition& operator=(IASATTRIBUTE* rhs) throw ();

   IASATTRIBUTE* getAttribute() const throw ()
   { return pos.pAttribute; }

   ATTRIBUTEPOSITION* operator&() throw ()
   { return &pos; }

   const ATTRIBUTEPOSITION* operator&() const throw ()
   { return &pos; }

private:
   void _addref() throw ()
   { if (pos.pAttribute) { IASAttributeAddRef(pos.pAttribute); } }

   void _release() throw ()
   { if (pos.pAttribute) { IASAttributeRelease(pos.pAttribute); } }

   ATTRIBUTEPOSITION pos;
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASAttributeVector
//
// DESCRIPTION
//
//    Implements an STL-style vector of ATTRIBUTEPOSITION structs. The user
//    may provide an empty C-style array that will be used for initial storage.
//    This array will not be freed by the IASAttributeVector object and must
//    remain valid for the lifetime of the object. The purpose of this feature
//    is to allow an initial stack-based allocation that will meet most
//    conditions while still allowing a dynamically-sized heap-based array
//    when necessary.
//
///////////////////////////////////////////////////////////////////////////////
class IASAttributeVector
{
public:

   //////////
   // STL typedefs.
   //////////

   typedef DWORD size_type;
   typedef ptrdiff_t difference_type;
   typedef ATTRIBUTEPOSITION& reference;
   typedef const ATTRIBUTEPOSITION& const_reference;
   typedef ATTRIBUTEPOSITION value_type;
   typedef PATTRIBUTEPOSITION iterator;
   typedef const ATTRIBUTEPOSITION* const_iterator;

   // Construct a vector with zero capacity.
   IASAttributeVector() throw ();

   // Construct a vector with heap-allocated capacity of 'N'.
   explicit IASAttributeVector(size_type N);

   // Construct a vector with initial capacity of 'initCap' using the
   // user-provided C-style array beginning at 'init'.
   IASAttributeVector(PATTRIBUTEPOSITION init, size_type initCap) throw ();

   // Copy-constructor.
   IASAttributeVector(const IASAttributeVector& v);

   // Assignment operator.
   IASAttributeVector& operator=(const IASAttributeVector& v);

   // Destructor.
   ~IASAttributeVector() throw ();

   // Returns true if vector contains at least one attribute with the given ID.
   bool contains(DWORD attrID) const throw ();

   // Similar to 'erase' except the attribute is not released.
   iterator discard(iterator p) throw ();

   // Similar to 'discard' except the order of the elements following 'p' is
   // not necessarily preserved.
   iterator fast_discard(iterator p) throw ();

   // Similar to 'erase' except the order of the elements following 'p' is
   // not necessarily preserved.
   iterator fast_erase(iterator p) throw ()
   {
      IASAttributeRelease(p->pAttribute);
      return fast_discard(p);
   }

   // Load the requested attributes into the vector.
   DWORD load(IAttributesRaw* request, DWORD attrIDCount, LPDWORD attrIDs);

   // Load all attributes with a given ID into the vector.
   DWORD load(IAttributesRaw* request, DWORD attrID)
   { return load(request, 1, &attrID); }

   // Load all the attributes in the request into the vector.
   DWORD load(IAttributesRaw* request);

   // Adds an ATTRIBUTEPOSITION struct to the end of the vetor, resizing as
   // necessary. The 'addRef' flag indicates whether IASAttributeAddRef should
   // be called for the embedded attribute.
   void push_back(ATTRIBUTEPOSITION& p, bool addRef = true);

   // Adds an attribute to the end of the vetor, resizing as necessary.
   // The 'addRef' flag indicates whether IASAttributeAddRef should be
   // called for the attribute.
   void push_back(PIASATTRIBUTE p, bool addRef = true)
   {
      ATTRIBUTEPOSITION pos = { 0, p };
      push_back(pos, addRef);
   }

   // Remove the contents of the vector from the request.
   void remove(IAttributesRaw* request);

   // Store the contents of the vector in the request.
   void store(IAttributesRaw* request) const;

   //////////
   // The remainder of the public interface follows the semantics of the
   // STL vector class (q.v.).
   //////////

   const_reference at(size_type pos) const throw ()
   { return *(begin_ + pos); }

   reference at(size_type pos) throw ()
   { return *(begin_ + pos); }

   iterator begin() throw ()
   { return begin_; }

   const_iterator begin() const throw ()
   { return begin_; }

   size_type capacity() const throw ()
   { return capacity_; }

   void clear() throw ();

   bool empty() const throw ()
   { return begin_ == end_; }

   iterator end() throw ()
   { return end_; }

   const_iterator end() const throw ()
   { return end_; }

   iterator erase(iterator p) throw ()
   {
      IASAttributeRelease(p->pAttribute);
      return discard(p);
   }

   reference back() throw ()
   { return *(end_ - 1); }

   const_reference back() const throw ()
   { return *(end_ - 1); }

   reference front() throw ()
   { return *begin_; }

   const_reference front() const throw ()
   { return *begin_; }

   void reserve(size_type N);

   size_type size() const throw ()
   { return (size_type)(end_ - begin_); }

   const_reference operator[](size_type pos) const throw ()
   { return at(pos); }

   reference operator[](size_type pos) throw ()
   { return at(pos); }

protected:
   PATTRIBUTEPOSITION begin_;  // Beginning of the vector.
   PATTRIBUTEPOSITION end_;    // Points one past the last element.
   size_type capacity_;        // Capacity of the vector in elements.
   bool owner;                 // true if the memory should be freed.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASAttributeVectorWithBuffer<N>
//
// DESCRIPTION
//
//    Extens IASAttributeVector to provide an initial non-heap allocation
//    of 'N' elements. The vector will still support heap-based resizing.
//
///////////////////////////////////////////////////////////////////////////////
template <IASAttributeVector::size_type N>
class IASAttributeVectorWithBuffer
   : public IASAttributeVector
{
public:
   IASAttributeVectorWithBuffer()
      : IASAttributeVector(buffer, N)
   { }

   IASAttributeVectorWithBuffer(const IASAttributeVectorWithBuffer& vec)
      : IASAttributeVector(vec)
   { }

   IASAttributeVectorWithBuffer&
      operator=(const IASAttributeVectorWithBuffer& vec)
   {
      IASAttributeVector::operator=(vec);
      return *this;
   }

protected:
   ATTRIBUTEPOSITION buffer[N];  // Initial storage.
};

///////////////////////////////////////////////////////////////////////////////
//
// MACRO
//
//    IASAttributeVectorOnStack(identifier, request, extra)
//
// DESCRIPTION
//
//    Uses _alloca to create an IASAttributeVector on the stack that is
//    exactly the right size to hold all the attributes in 'request' plus
//    'extra' additional attributes.  The 'request' pointer may be null in
//    which case this will allocate space for exactly 'extra' attributes.
//
// CAVEAT
//
//    This can only be used for temporary variables.
//
///////////////////////////////////////////////////////////////////////////////

// Must be included in an enclosing scope prior to IASAttributeVectorOnStack
#define USES_IAS_STACK_VECTOR() \
   ULONG IAS_VECCAP;

#define IASAttributeVectorOnStack(identifier, request, extra) \
   IAS_VECCAP = 0; \
   if (static_cast<IAttributesRaw*>(request) != NULL) \
      static_cast<IAttributesRaw*>(request)->GetAttributeCount(&IAS_VECCAP); \
   IAS_VECCAP += (extra); \
   IASAttributeVector identifier( \
                          (PATTRIBUTEPOSITION) \
                          _alloca(IAS_VECCAP * sizeof(ATTRIBUTEPOSITION)), \
                          IAS_VECCAP \
                          )

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASOrderByID
//
// DESCRIPTION
//
//    Functor class for sorting/searching an IASAttributeVector by ID.
//
///////////////////////////////////////////////////////////////////////////////
class IASOrderByID
{
public:
   bool operator()(const ATTRIBUTEPOSITION& lhs,
                   const ATTRIBUTEPOSITION& rhs) throw ()
   { return lhs.pAttribute->dwId < rhs.pAttribute->dwId; }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASSelectByID<T>
//
// DESCRIPTION
//
//    Functor class for selecting elements from an IASAttributeVector based
//    on the attribute ID.
//
///////////////////////////////////////////////////////////////////////////////
template <DWORD ID>
class IASSelectByID
{
public:
   bool operator()(const ATTRIBUTEPOSITION& pos) throw ()
   { return (pos.pAttribute->dwId == ID); }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASSelectByFlag<T>
//
// DESCRIPTION
//
//    Functor class for selecting elements from an IASAttributeVector based
//    on the attribute flags.
//
///////////////////////////////////////////////////////////////////////////////
template <DWORD Flag, bool Set = true>
class IASSelectByFlag
{
public:
   bool operator()(const ATTRIBUTEPOSITION& pos) throw ()
   {
      return Set ? (pos.pAttribute->dwFlags & Flag) != 0
                 : (pos.pAttribute->dwFlags & Flag) == 0;
   }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASRequest
//
// DESCRIPTION
//
//    Wrapper around a COM-based request object. Note that this is *not* a
//    smart pointer class. There are several important differences:
//
//       1) An IASRequest object is guaranteed to contain a valid request;
//          there is no concept of a NULL IASRequest.
//       2) The IASRequest object does not take ownership of the IRequest
//          interface. In particular, it does not call AddRef or Release.
//       3) Methods are invoked directly on the IASRequest object rather than
//          through the -> operator.
//
///////////////////////////////////////////////////////////////////////////////
class IASRequest
{
public:

   explicit IASRequest(IRequest* request);

   IASRequest(const IASRequest& request) throw ()
      : req(request.req), raw(request.raw)
   { _addref(); }

   IASRequest& operator=(const IASRequest& request) throw ();

   ~IASRequest() throw ()
   { _release(); }

   IASREQUEST get_Request() const
   {
      LONG val;
      checkError(req->get_Request(&val));
      return (IASREQUEST)val;
   }

   void put_Request(IASREQUEST newVal)
   {
      checkError(req->put_Request(newVal));
   }

   IASRESPONSE get_Response() const
   {
      LONG val;
      checkError(req->get_Response(&val));
      return (IASRESPONSE)val;
   }

   DWORD get_Reason() const
   {
      LONG val;
      checkError(req->get_Reason(&val));
      return val;
   }

   IASPROTOCOL get_Protocol() const
   {
      IASPROTOCOL val;
      checkError(req->get_Protocol(&val));
      return val;
   }

   void put_Protocol(IASPROTOCOL newVal)
   {
      checkError(req->put_Protocol(newVal));
   }

   IRequestSource* get_Source() const
   {
      IRequestSource* val;
      checkError(req->get_Source(&val));
      return val;
   }

   void put_Source(IRequestSource* newVal)
   {
      checkError(req->put_Source(newVal));
   }

   void SetResponse(IASRESPONSE eResponse, DWORD dwReason = S_OK)
   {
      checkError(req->SetResponse(eResponse, (LONG)dwReason));
   }

   void ReturnToSource(IASREQUESTSTATUS eStatus)
   {
      checkError(req->ReturnToSource(eStatus));
   }

   void AddAttributes(DWORD dwPosCount, PATTRIBUTEPOSITION pPositions)
   {
      checkError(raw->AddAttributes(dwPosCount, pPositions));
   }

   void RemoveAttributes(DWORD dwPosCount, PATTRIBUTEPOSITION pPositions)
   {
      checkError(raw->RemoveAttributes(dwPosCount, pPositions));
   }

   void RemoveAttributesByType(DWORD dwAttrIDCount, LPDWORD lpdwAttrIDs)
   {
      checkError(raw->RemoveAttributesByType(dwAttrIDCount, lpdwAttrIDs));
   }

   DWORD GetAttributeCount() const
   {
      DWORD count;
      checkError(raw->GetAttributeCount(&count));
      return count;
   }

   // Returns the number of attributes retrieved.
   DWORD GetAttributes(DWORD dwPosCount,
                       PATTRIBUTEPOSITION pPositions,
                       DWORD dwAttrIDCount,
                       LPDWORD lpdwAttrIDs);

   void InsertBefore(
           PATTRIBUTEPOSITION newAttr,
           PATTRIBUTEPOSITION refAttr
           )
   {
      checkError(raw->InsertBefore(newAttr, refAttr));
   }

   //////////
   // Cast operators to extract the embedded interfaces.
   //////////

   operator IRequest*()       { return req; }
   operator IAttributesRaw*() { return raw; }

protected:

   // Throws an exception if a COM method fails.
   static void checkError(HRESULT hr)
   { if (FAILED(hr)) { issue_error(hr); } }

   void _addref()  { raw->AddRef();  }
   void _release() { raw->Release(); }

   IRequest* req;         // Underlying interfaces.
   IAttributesRaw* raw;   // Underlying interfaces.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASDictionary
//
// DESCRIPTION
//
//    Provides access to the attribute dictionary.
//
///////////////////////////////////////////////////////////////////////////////
class IASDictionary
{
public:
   // selectNames: null terminated array of strings containing the columns to
   //              be selected; a column name may be prepended with a hyphen
   //              '-' to indicate that it's optional
   // path:        full path to the dictionary database or NULL to use the
   //              local dictionary
   IASDictionary(
       const WCHAR* const* selectNames,
       PCWSTR path = NULL
       );
   ~IASDictionary() throw ();

   ULONG getNumRows() const throw ()
   { return table->numRows; }

   // Advance to the next row. This must be called on a newly constructed
   // dictionary to advance to the first row.
   bool next() throw ();

   // Reset the dictionary to its initial state.
   void reset() throw ();

   // Returns true if the specified column is empty in the current row.
   bool isEmpty(ULONG ordinal) const;

   // Retrieve column values from the current row.
   VARIANT_BOOL getBool(ULONG ordinal) const;
   BSTR getBSTR(ULONG ordinal) const;
   LONG getLong(ULONG ordinal) const;
   const VARIANT* getVariant(ULONG ordinal) const;

private:
   const IASTable* table;  // The table data.
   ULONG mapSize;          // Number of columns selected.
   PULONG selectMap;       // Maps select ordinals to table ordinals.
   ULONG nextRowNumber;    // Next row.
   VARIANT* currentRow;    // Current row -- may be NULL.

   IASTable data;          // Local storage for non-local dictionaries.
   CComVariant storage;    // Storage associated with the dictionary.

   // Not implemented.
   IASDictionary(const IASDictionary&);
   IASDictionary& operator=(const IASDictionary&);
};


//////////
// End of the IASTL namespace.
//////////
}

///////////////////////////////////////////////////////////////////////////////
//
// OctetString conversion macros and functions.
//
///////////////////////////////////////////////////////////////////////////////

// Compute the size of the buffer required by IASOctetStringToAnsi
#define IAS_OCT2ANSI_LEN(oct) \
   (((oct).dwLength + 1) * sizeof(CHAR))

// Compute the size of the buffer required by IASOctetStringToWide
#define IAS_OCT2WIDE_LEN(oct) \
   (((oct).dwLength + 1) * sizeof(WCHAR))

// Coerce an OctetString to a null-terminated ANSI string. There is no check
// for overflow. The dst buffer must be at least IAS_OCT2ANSI_LEN bytes.
PSTR IASOctetStringToAnsi(const IAS_OCTET_STRING& src, PSTR dst) throw ();

// Coerce an OctetString to a null-terminated Unicode string. There is no
// check for overflow. The dst buffer must be at least IAS_OCT2UNI_LEN bytes.
PWSTR IASOctetStringToWide(const IAS_OCTET_STRING& src, PWSTR dst) throw ();

// Convert an OctetString to ANSI on the stack.
#define IAS_OCT2ANSI(oct) \
   (IASOctetStringToAnsi((oct), (PSTR)_alloca(IAS_OCT2ANSI_LEN(oct))))

// Convert an OctetString to Unicode on the stack.
#define IAS_OCT2WIDE(oct) \
   (IASOctetStringToWide((oct), (PWSTR)_alloca(IAS_OCT2WIDE_LEN(oct))))

///////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous utility functions.
//
///////////////////////////////////////////////////////////////////////////////

// Retrieves and returns a single attribute with the given ID and type. The
// attribute should *not* be released and is only valid while the caller holds
// a reference to 'request'. On error or if the attribute is not found, the
// function returns NULL.
PIASATTRIBUTE IASPeekAttribute(
                  IAttributesRaw* request,
                  DWORD dwId,
                  IASTYPE itType
                  ) throw ();

#endif  // IASTLUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\parser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    parser.h
//
// SYNOPSIS
//
//    This file defines the class Parser.
//
// MODIFICATION HISTORY
//
//    02/06/1998    Original version.
//    03/23/2000    Added erase. Removed the const_cast's.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PARSER_H_
#define _PARSER_H_

#include <climits>
#include <cmath>
#include <cstdlib>

#include <tchar.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Parser
//
// DESCRIPTION
//
//    This class facilitates parsing a null-terminated string. Note that many
//    methods have two forms: findXXX and seekXXX. The difference is that the
//    find methods throw an exception if unsuccessful while the seek methods
//    set the cursor to the end of the string.
//
// NOTE
//
//    The constructor takes a non-const string because the string is
//    temporarily modified while tokenizing. However, the string is returned
//    to its original form when parsing is complete. Therefore, if you know
//    the string isn't in read-only memory and isn't visible to another
//    thread, then you can safely use const_cast to parse a const string.
//
///////////////////////////////////////////////////////////////////////////////
class Parser
{
public:
   class ParseError {};

   Parser(_TCHAR* tcsString)
      : start(tcsString),
        current(tcsString),
        save(__T('\0')),
        tokenLocked(false)
   { }

   ~Parser()
   {
      releaseToken();
   }

   // Marks the current position as the beginning of a token.
   const _TCHAR* beginToken() throw (ParseError)
   {
      if (tokenLocked) { throw ParseError(); }

      return start = current;
   }

   // Erase nchar characters starting at the current position.
   void erase(size_t nchar) throw (ParseError)
   {
      size_t left = remaining();

      if (nchar > left) { throw ParseError(); }

      memmove(current, current + nchar, (left + 1 - nchar) * sizeof(TCHAR));
   }

   // Extracts a double from the string.
   double extractDouble() throw (ParseError)
   {
      _TCHAR* endptr;

      double d = _tcstod(current, &endptr);

      if (endptr == current || d == HUGE_VAL || d == -HUGE_VAL)
      {
         throw ParseError();
      }

      current = endptr;

      return d;
   }

   // Extracts a long from the string.
   long extractLong(int base = 10) throw (ParseError)
   {
      _TCHAR* endptr;

      long l = _tcstol(current, &endptr, base);

      if (endptr == current || l == LONG_MAX || l == LONG_MIN)
      {
         throw ParseError();
      }

      current = endptr;

      return l;
   }

   // Extracts an unsigned long from the string.
   unsigned long extractUnsignedLong(int base = 10) throw (ParseError)
   {
      _TCHAR* endptr;

      unsigned long ul = _tcstoul(current, &endptr, base);

      if (endptr == current || ul == ULONG_MAX)
      {
         throw ParseError();
      }

      current = endptr;

      return ul;
   }

   // Find any character in tcsCharSet.
   const _TCHAR* findAny(const _TCHAR* tcsCharSet) throw (ParseError)
   {
      return notEmpty(seekAny(tcsCharSet));
   }

   // Find the end of the string.
   const _TCHAR* findEnd() throw ()
   {
      return current += _tcslen(current);
   }

   // Find the next occurrence of 'c'.
   const _TCHAR* findNext(_TINT c) throw (ParseError)
   {
      return notEmpty(seekNext(c));
   }

   // Find the last occurrence of 'c' in the string.
   const _TCHAR* findLast(_TINT c) throw (ParseError)
   {
      return notEmpty(seekLast(c));
   }

   // Find the next occurrence of tcsString.
   const _TCHAR* findString(const _TCHAR* tcsString) throw (ParseError)
   {
      return notEmpty(seekString(tcsString));
   }

   // Find the next token delimited by any of the characters in tcsDelimit.
   // This method must be followed by a call to releaseToken before further
   // parsing.
   const _TCHAR* findToken(const _TCHAR* tcsDelimit) throw (ParseError)
   {
      return notEmpty(seekToken(tcsDelimit));
   }

   // Marks the current position as the end of a token. The token does not
   // include the current character. This method must be followed by a call
   // to releaseToken before further parsing.
   const _TCHAR* endToken() throw (ParseError)
   {
      if (tokenLocked) { throw ParseError(); }

      tokenLocked = true;

      save = *current;

      *current = __T('\0');

      return start;
   }

   // Skips the specified character.
   const _TCHAR* ignore(_TINT c) throw (ParseError)
   {
      if (*current++ != c) { throw ParseError(); }

      return current;
   }

   // Skips the specified character string.
   const _TCHAR* ignore(const _TCHAR* tcsString) throw (ParseError)
   {
      size_t len = _tcslen(tcsString);

      if (len > remaining() || _tcsncmp(current, tcsString, len) != 0)
      {
         throw ParseError();
      }

      return current += len;
   }

   // Returns true if the string has not been fully parsed.
   bool more() const throw ()
   {
      return *current != __T('\0');
   }

   // Releases a token returned by findToken, endToken, or seekToken.
   const _TCHAR* releaseToken() throw ()
   {
      if (tokenLocked)
      {
         tokenLocked = false;

         *current = save;
      }

      return start;
   }

   // Returns the number of unparsed characters.
   size_t remaining() const throw ()
   {
      return _tcslen(current);
   }

   //////////
   // The seek family of methods perform like their find counterparts except
   // they do not throw an exception on failure. Instead they set the cursor
   // to the end of the string.
   //////////

   const _TCHAR* seekAny(const _TCHAR* tcsCharSet) throw ()
   {
      return setCurrent(_tcspbrk(current, tcsCharSet));
   }

   const _TCHAR* seekNext(_TINT c) throw ()
   {
      return setCurrent(_tcschr(current, c));
   }

   const _TCHAR* seekLast(_TINT c) throw ()
   {
      return setCurrent(_tcsrchr(current, c));
   }

   const _TCHAR* seekString(const _TCHAR* tcsString) throw ()
   {
      return setCurrent(_tcsstr(current, tcsString));
   }

   const _TCHAR* seekToken(const _TCHAR* tcsDelimit) throw (ParseError)
   {
      skip(tcsDelimit);

      if (!more()) { return NULL; }

      beginToken();

      seekAny(tcsDelimit);

      return endToken();
   }

   // Skip occurrences of any characters in tcsCharSet.
   const _TCHAR* skip(const _TCHAR* tcsCharSet) throw ()
   {
      return current += _tcsspn(current, tcsCharSet);
   }

   // Skip a fixed number of characters.
   const _TCHAR* skip(size_t numChar) throw (ParseError)
   {
      if (numChar > _tcslen(current)) { throw ParseError(); }

      return current += numChar;
   }

   const _TCHAR* operator--(int) throw (ParseError)
   {
      if (current == start) { throw ParseError(); }

      return current--;
   }

   const _TCHAR* operator--() throw (ParseError)
   {
      if (current == start) { throw ParseError(); }

      return --current;
   }

   const _TCHAR* operator++(int) throw (ParseError)
   {
      if (!more()) { throw ParseError(); }

      return current++;
   }

   const _TCHAR* operator++() throw (ParseError)
   {
      if (!more()) { throw ParseError(); }

      return ++current;
   }

   _TCHAR operator*() const throw ()
   {
      return *current;
   }

   operator const _TCHAR*() const throw ()
   {
      return current;
   }

protected:

   // Verifies that the given string is not empty.
   static const _TCHAR* notEmpty(const _TCHAR* tcs) throw (ParseError)
   {
      if (*tcs == __T('\0')) { throw ParseError(); }

      return tcs;
   }

   // Sets the current position to pos or end of string if pos is null.
   const _TCHAR* setCurrent(_TCHAR* pos) throw ()
   {
      return (pos ? (current = pos) : findEnd());
   }

   //////////
   // Not implemented.
   //////////
   Parser(const Parser&);
   Parser& operator=(const Parser&);

   const _TCHAR* start;    // The start of the token.
   _TCHAR* current;        // The current position of the cursor.
   _TCHAR save;            // The actual terminating character of the token.
   bool tokenLocked;       // true if the current token has not been released.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\perimeter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class Perimeter
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PERIMETER_H
#define PERIMETER_H
#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Perimeter
//
// DESCRIPTION
//
//    This class implements a Perimeter synchronization object.  Threads
//    may request either exclusive or shared access to the protected area.
//
///////////////////////////////////////////////////////////////////////////////
class Perimeter
{
public:
   Perimeter() throw ();
   ~Perimeter() throw ();

   HRESULT FinalConstruct() throw ();

   void Lock() throw ();
   void LockExclusive() throw ();
   void Unlock() throw ();

protected:
   LONG sharing;  // Number of threads sharing the perimiter.
   LONG waiting;  // Number of threads waiting for shared access.
   PLONG count;   // Pointer to either sharing or waiting depending
                  // on the current state of the perimiter.

   bool exclusiveInitialized;
   CRITICAL_SECTION exclusive;  // Synchronizes exclusive access.
   HANDLE sharedOK;             // Wakes up threads waiting for shared.
   HANDLE exclusiveOK;          // Wakes up threads waiting for exclusive.

private:
   // Not implemented.
   Perimeter(const Perimeter&) throw ();
   Perimeter& operator=(const Perimeter&) throw ();
};

#endif   // PERIMETER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource ID's for Everest core.
//
// MODIFICATION HISTORY
//
//    7/9/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDR_IASCORE            101
#define IDR_IASCOM             102

#define IDS_IasDataSource      201
#define IDS_Dictionary         202
#define IDS_AuditChannel       210
#define IDS_InfoBase           211
#define IDS_NTEventLog         212
#define IDS_SystemMonitor      213

#endif  // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\regex.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class RegularExpression.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef REGEX_H
#define REGEX_H
#pragma once

struct IRegExp2;
class FastCoCreator;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RegularExpression
//
// DESCRIPTION
//
//    General-purpose regular expression evaluator.
//
///////////////////////////////////////////////////////////////////////////////
class RegularExpression
{
public:
   RegularExpression() throw ();
   ~RegularExpression() throw ();

   HRESULT setGlobal(BOOL fGlobal) throw ();
   HRESULT setIgnoreCase(BOOL fIgnoreCase) throw ();
   HRESULT setPattern(PCWSTR pszPattern) throw ();

   HRESULT replace(
               BSTR sourceString,
               BSTR replaceString,
               BSTR* pDestString
               ) const throw ();

   BOOL testBSTR(BSTR sourceString) const throw ();
   BOOL testString(PCWSTR sourceString) const throw ();

   void swap(RegularExpression& obj) throw ();

protected:
   HRESULT checkInit() throw ();

private:
   IRegExp2* regex;

   // Used for creating RegExp objects.
   static FastCoCreator theCreator;

   // Not implemented.
   RegularExpression(const RegularExpression&);
   RegularExpression& operator=(const RegularExpression&);
};

#endif  // REGEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\varvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    VarVec.h
//
// SYNOPSIS
//
//    This file describes the class CVariantVector
//
// MODIFICATION HISTORY
//
//    08/05/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _VARVEC_H_
#define _VARVEC_H_

#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CVariantVector
//
// DESCRIPTION
//
//    This class provides a wrapper around a one-dimensional SAFEARRAY stored
//    in a VARIANT.
//
// CAVEATS
//
//    This class does not assume ownership of the VARIANT struct.  In other
//    words, you are responsible for calling VariantClear() to free any
//    allocated memory.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class CVariantVector : NonCopyable
{
public:

   // Manipulates an existing array.
   explicit CVariantVector(VARIANT* pv) throw (_com_error);

   // Creates a new array cElements in length.
   CVariantVector(VARIANT* pv, unsigned int cElements) throw (_com_error);

   ~CVariantVector() throw()
   {
      SafeArrayUnaccessData(m_psa);
   }

   T* data() throw()
   {
      return m_pData;
   }

   long size() const throw()
   {
      return m_lSize;
   }

   T& operator[](size_t index) throw()
   {
      return m_pData[index];
   }

protected:

   SAFEARRAY* m_psa;   // The SAFEARRAY being manipulated.
   long m_lSize;       // The number of elements in the array.
   T* m_pData;         // The raw array inside the SAFEARRAY.
};


///////////////////////////////////////////////////////////////////////////////
//
//  These inline functions convert a C++ type to a VARTYPE.
//
///////////////////////////////////////////////////////////////////////////////
inline VARTYPE GetVARTYPE(BSTR*)
{
   return VT_BSTR;
}

inline VARTYPE GetVARTYPE(BYTE*)
{
   return VT_UI1;
}

inline VARTYPE GetVARTYPE(LONG*)
{
   return VT_I4;
}

inline VARTYPE GetVARTYPE(DWORD*)
{
   return VT_UI4;
}

inline VARTYPE GetVARTYPE(IDispatch**)
{
   return VT_DISPATCH;
}

inline VARTYPE GetVARTYPE(IUnknown**)
{
   return VT_UNKNOWN;
}

inline VARTYPE GetVARTYPE(VARIANT*)
{
   return VT_VARIANT;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CVariantVector::CVariantVector
//
// DESCRIPTION
//
//    Creates a CVariantVector that accesses an existing SAFEARRAY (which
//    is contained in the passed in VARIANT).
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
CVariantVector<T>::CVariantVector(VARIANT* pv) throw (_com_error)
   : m_psa(V_ARRAY(pv))
{
   using _com_util::CheckError;

   // Make sure the variant contains a one-dimensional array of the right type.
   if (V_VT(pv) != (VT_ARRAY | GetVARTYPE((T*)NULL)) ||
       SafeArrayGetDim(m_psa) != 1)
   {
      throw _com_error(DISP_E_TYPEMISMATCH);
   }

   // Get the upper and lower bound. 
   long lLBound, lUBound;
   CheckError(SafeArrayGetLBound(m_psa, 1, &lLBound));
   CheckError(SafeArrayGetUBound(m_psa, 1, &lUBound));

   // Compute the size.
   m_lSize = lUBound - lLBound + 1;
   if (m_lSize < 0)
   {
      throw _com_error(DISP_E_BADINDEX);
   }

   // Lock the array data.
   CheckError(SafeArrayAccessData(m_psa, (void**)&m_pData));
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CVariantVector::CVariantVector
//
// DESCRIPTION
//
//    Initializes both the passed in VARIANT and the CVariantVector to
//    manipulate a new array, cElements in length.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
CVariantVector<T>::CVariantVector(VARIANT* pv,
                                  unsigned int cElements) throw (_com_error)
   : m_lSize(cElements)
{
   // Initalize the variant.
   VariantInit(pv);

   // Create the SAFEARRAY.
   V_ARRAY(pv) = SafeArrayCreateVector(GetVARTYPE((T*)NULL), 0, cElements);

   if ((m_psa = V_ARRAY(pv)) == NULL)
   {
      throw _com_error(E_OUTOFMEMORY);
   }

   // Set the type.
   V_VT(pv) = VT_ARRAY | GetVARTYPE((T*)NULL);

   // Lock the array data.
   HRESULT hr = SafeArrayAccessData(m_psa, (void**)&m_pData);

   if (FAILED(hr))
   {
      // Free the memory we allocated.
      VariantClear(pv);

      throw _com_error(hr);
   }
}


#endif  / _VARVEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\portparser.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class CPortParser.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PORTPARSER_H
#define PORTPARSER_H
#pragma once

class CPortParser
{
public:
   CPortParser(const wchar_t* portString) throw ();

   // Use compiler-generated version.
   // ~CPortParser() throw ();

   // IP Address in network order to listen to RADIUS requests on. Returns
   // S_FALSE if there are no more interfaces.
   HRESULT GetIPAddress(DWORD* ipAddress) throw ();

   // UDP Port in host order to listen to RADIUS requests on. Returns S_FALSE
   // if there are no more ports.
   HRESULT GetNextPort(WORD* port) throw ();

   static bool IsPortStringValid(const wchar_t* portString) throw ();

   static size_t CountPorts(const wchar_t* portString) throw ();

private:
   const wchar_t* next;

   // Separates an IP address from a port.
   static const wchar_t addressPortDelim = L':';
   // Separates two ports.
   static const wchar_t portDelim = L',';
   // Separates two interfaces.
   static const wchar_t interfaceDelim = L';';

   // Maximum length in characters of a dotted-decimal IP address not counting
   // the null-terminator.
   static const size_t maxAddrStrLen = 15;

   // Allowed values for ports.
   static const unsigned long minPortValue = 1;
   static const unsigned long maxPortValue = 0xFFFF;

   // Not implemented.
   CPortParser(const CPortParser&);
   CPortParser& operator=(const CPortParser&);
};


inline CPortParser::CPortParser(const wchar_t* portString) throw ()
   : next(portString)
{
}


inline bool CPortParser::IsPortStringValid(const wchar_t* portString) throw ()
{
   return CountPorts(portString) != 0;
}

#endif // PORTPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\inc\propset.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    PropSet.h
//
// SYNOPSIS
//
//    This file describes the class DBPropertySet.
//
// MODIFICATION HISTORY
//
//    10/30/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PROPSET_H_
#define _PROPSET_H_

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DBPropertySet<N>
//
// DESCRIPTION
//
//    This class provides a very basic wrapper around an OLE DB property set.
//    The template parameter 'N' specifies the capacity of the set.
//
///////////////////////////////////////////////////////////////////////////////
template <size_t N>
struct DBPropertySet : DBPROPSET
{
   DBPropertySet(const GUID& guid)
   {
      guidPropertySet = guid;
      cProperties = 0;
      rgProperties = DBProperty;
   }

   ~DBPropertySet()
   {
      for (size_t i = 0; i<cProperties; i++)
         VariantClear(&DBProperty[i].vValue);
   }

   bool AddProperty(DWORD dwPropertyID, LPCWSTR szValue)
   {
      if (cProperties >= N) return false;

      DBProperty[cProperties].dwPropertyID   = dwPropertyID;
      DBProperty[cProperties].dwOptions      = DBPROPOPTIONS_REQUIRED;
      DBProperty[cProperties].colid          = DB_NULLID;
      DBProperty[cProperties].vValue.vt      = VT_BSTR;
      DBProperty[cProperties].vValue.bstrVal = SysAllocString(szValue);

      if (DBProperty[cProperties].vValue.bstrVal == NULL) return false;

      cProperties++;

      return true;
   }

   bool AddProperty(DWORD dwPropertyID, long lValue)
   {
      if (cProperties >= N) return false;

      DBProperty[cProperties].dwPropertyID   = dwPropertyID;
      DBProperty[cProperties].dwOptions      = DBPROPOPTIONS_REQUIRED;
      DBProperty[cProperties].colid          = DB_NULLID;
      DBProperty[cProperties].vValue.vt      = VT_I4;
      DBProperty[cProperties].vValue.lVal    = lValue;

      cProperties++;

      return true;
   }

   DBPROP DBProperty[N];
};

#endif  // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\thrdpool\dispatcher.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    Dispatcher.cpp
//
// SYNOPSIS
//
//    This file implements the class Dispatcher.
//
// MODIFICATION HISTORY
//
//    07/31/1997    Original version.
//    12/04/1997    Check return value of _beginthreadex.
//    02/24/1998    Initialize COM run-time for all threads.
//    04/16/1998    Block in Finalize until all the threads have returned.
//    05/20/1998    GetQueuedCompletionStatus signature changed.
//    08/07/1998    Wait on thread handle to ensure all threads have exited.
//
///////////////////////////////////////////////////////////////////////////////
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <iascore.h>
#include <process.h>
#include <cstddef>

#include <dispatcher.h>

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::initialize
//
///////////////////////////////////////////////////////////////////////////////
BOOL Dispatcher::initialize(DWORD dwMaxThreads, DWORD dwMaxIdle) throw ()
{
   // Initialize the various parameters.
   numThreads = 0;
   maxThreads = dwMaxThreads;
   available  = 0;
   maxIdle    = dwMaxIdle;

   // If maxThreads == 0, then we compute a suitable default.
   if (maxThreads == 0)
   {
      // Threads defaults to 64 times the number of processors.
      SYSTEM_INFO sinf;
      ::GetSystemInfo(&sinf);
      maxThreads = sinf.dwNumberOfProcessors * 64;
   }

   // Initialize the handles.
   hPort   = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
   if (hPort == NULL)
   {
      return FALSE;
   }

   hEmpty  = CreateEvent(NULL, TRUE, TRUE, NULL);
   if (hEmpty == NULL)
   {
      CloseHandle(hPort);
      hPort = NULL;
      return FALSE;
   }

   hLastOut = NULL;
   
   return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::finalize
//
///////////////////////////////////////////////////////////////////////////////
void Dispatcher::finalize()
{
   Lock();

   // Block any new threads from being created.
   maxThreads = 0;

   // How many threads are still in the pool?
   DWORD remaining = numThreads;
   
   Unlock();

   // Post a null request for each existing thread.
   while (remaining--)
   {
      PostQueuedCompletionStatus(hPort, 0, 0, NULL);
   }

   // Wait until the pool is empty.
   WaitForSingleObject(hEmpty, INFINITE);

   if (hLastOut != NULL)
   {
      // Wait for the last thread to exit.
      WaitForSingleObject(hLastOut, INFINITE);
   }

   //////////
   // Clean-up the handles.
   //////////
   
   CloseHandle(hLastOut);
   hLastOut = NULL;

   CloseHandle(hEmpty);
   hEmpty = NULL;

   CloseHandle(hPort);
   hPort = NULL;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::Dispatch
//
// DESCRIPTION
//
//    This is the main loop for all the threads in the pool.
//
///////////////////////////////////////////////////////////////////////////////
inline void Dispatcher::fillRequests() throw ()
{
   DWORD dwNumBytes;
   ULONG_PTR ulKey;
   PIAS_CALLBACK pRequest;

   //////////
   // Loop until we either timeout or get a null request.
   //////////

next:
   BOOL success = GetQueuedCompletionStatus(hPort,
                                            &dwNumBytes,
                                            &ulKey,
                                            (OVERLAPPED**)&pRequest,
                                            maxIdle);

   if (pRequest)
   {
      pRequest->CallbackRoutine(pRequest);

      Lock();

      ++available;
      
      Unlock();

      goto next;
   }

   Lock();

   // We never want to timeout a thread while there's a backlog.
   if (available <= 0 && success == FALSE && GetLastError() == WAIT_TIMEOUT)
   {
      Unlock();

      goto next;
   }

   // Save the current value of 'last out' and replace it with our handle.
   HANDLE previousThread = hLastOut;
   hLastOut = NULL;
   DuplicateHandle(
       NtCurrentProcess(),
       NtCurrentThread(),
       NtCurrentProcess(),
       &hLastOut,
       0,
       FALSE,
       DUPLICATE_SAME_ACCESS
       );

   // We're removing a thread from the pool, so update our state.
   --available;
   --numThreads;
   
   // If there are no threads left, set the 'empty' event.
   if (numThreads == 0) { SetEvent(hEmpty); }

   Unlock();

   // Wait until the previous thread exits. This guarantees that when the
   // 'last out' thread exits, all threads have exited.
   if (previousThread != NULL)
   {
      WaitForSingleObject(previousThread, INFINITE);
      CloseHandle(previousThread);
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::RequestThread
//
///////////////////////////////////////////////////////////////////////////////
BOOL Dispatcher::requestThread(PIAS_CALLBACK OnStart) throw ()
{
   Lock();

   // If there are no threads available AND we're below our limit,
   // create a new thread.
   if (--available < 0 && numThreads < maxThreads)
   {
      unsigned nThreadID;
      HANDLE hThread = (HANDLE)_beginthreadex(NULL,
                                              0,
                                              startRoutine,
                                              (void*)this,
                                              0,
                                              &nThreadID);

      if (hThread)
      {
         // We don't need the thread handle.
         CloseHandle(hThread);

         // We added a thread to the pool, so update our state.
         if (numThreads == 0) { ResetEvent(hEmpty); }
         ++numThreads;
         ++available;
      }
   }

   Unlock();

   //////////
   // Post it to the I/O Completion Port.
   //////////

   return PostQueuedCompletionStatus(hPort, 0, 0, (OVERLAPPED*)OnStart);
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::setMaxNumberOfThreads
//
///////////////////////////////////////////////////////////////////////////////
DWORD Dispatcher::setMaxNumberOfThreads(DWORD dwMaxThreads) throw ()
{
   Lock();

   DWORD oldval = maxThreads;

   maxThreads = dwMaxThreads;

   Unlock();

   return oldval;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::setMaxThreadIdle
//
///////////////////////////////////////////////////////////////////////////////
DWORD Dispatcher::setMaxThreadIdle(DWORD dwMilliseconds)
{
   Lock();

   DWORD oldval = maxIdle;

   maxIdle = dwMilliseconds;

   Unlock();

   return oldval;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    Dispatcher::StartRoutine
//
///////////////////////////////////////////////////////////////////////////////
unsigned __stdcall Dispatcher::startRoutine(void* pArg) throw ()
{
   ((Dispatcher*)pArg)->fillRequests();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\thrdpool\dispatcher.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Dispatcher.h
//
// SYNOPSIS
//
//    This file describes the class Dispatcher.
//
// MODIFICATION HISTORY
//
//    7/31/1997    Original version.
//    4/16/1998    Added 'empty' event.
//    8/07/1998    Added 'last out' thread handle.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _DISPATCHER_H_
#define _DISPATCHER_H_

#include <guard.h>
#include <nocopy.h>

//////////
// Default number of milliseconds that a thread will wait for work.
//////////
const DWORD DEFAULT_MAX_IDLE = 5 * 60 * 1000;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Dispatcher
//
// DESCRIPTION
//
//    This class maintains an upper-bounded recycle bin of threads.  Instead
//    of calling the Win32 CreateThread() function, clients instead call
//    RequestThread().  If a thread is available it will be dispatched 
//    immediately, otherwise the request is placed in a FIFO queue until a
//    thread becomes available.
//
///////////////////////////////////////////////////////////////////////////////
class Dispatcher
   : Guardable, NonCopyable
{
public:
   BOOL initialize(DWORD dwMaxThreads = 0,
                   DWORD dwMaxIdle = DEFAULT_MAX_IDLE) throw ();
   void finalize() throw ();

   BOOL requestThread(PIAS_CALLBACK OnStart) throw ();
   DWORD setMaxNumberOfThreads(DWORD dwMaxThreads) throw ();
	DWORD setMaxThreadIdle(DWORD dwMilliseconds) throw ();

protected:
   // Main loop to dispatch thread requests.
   void fillRequests() throw ();

   DWORD  numThreads;  // Current number of threads.
   DWORD  maxThreads;  // Maximum size of the thread pool.
   LONG   available;   // Number of threads available for work (may be < 0).
	DWORD  maxIdle;     // Max. time (in msec) that a thread will idle.
   HANDLE hPort;       // I/O Completion Port used as the queue.
   HANDLE hEmpty;      // Event indicating that the pool is empty.
   HANDLE hLastOut;    // The last thread to exit from the pool.

   // Start routine for all threads.
   static unsigned __stdcall startRoutine(void* pArg) throw ();
};

#endif _DISPATCHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\attrcvt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrcvt.cpp
//
// SYNOPSIS
//
//    This file defines methods for converting attributes to
//    different formats.
//
// MODIFICATION HISTORY
//
//    02/26/1998    Original version.
//    03/27/1998    InetAddr's are persisted as integers.
//    08/24/1998    Make use of IASTL utility classes.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>
#include <iasutil.h>
#include <varvec.h>

#include <attrcvt.h>

using IASTL::IASAttribute;

PIASATTRIBUTE
WINAPI
IASAttributeFromVariant(
    VARIANT* src,
    IASTYPE type
    ) throw (_com_error)
{
   using _com_util::CheckError;
   using _w32_util::CheckSuccess;

   // Allocate an attribute to hold the result.
   IASAttribute dst(true);

   // Switch off the destination type.
   switch (type)
   {
      case IASTYPE_BOOLEAN:
      {
         CheckError(VariantChangeType(src, src, NULL, VT_BOOL));
         dst->Value.Boolean = (V_BOOL(src) != VARIANT_FALSE) ? TRUE : FALSE;
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_INET_ADDR:
      case IASTYPE_ENUM:
      {
         CheckError(VariantChangeType(src, src, NULL, VT_I4));
         dst->Value.Integer = V_I4(src);
         break;
      }

      case IASTYPE_STRING:
      {
         CheckError(VariantChangeType(src, src, NULL, VT_BSTR));
         dst.setString(V_BSTR(src));
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         PBYTE value;
         DWORD length;

         if (V_VT(src) == (VT_ARRAY | VT_UI1) ||
             V_VT(src) == (VT_ARRAY | VT_I1))
         {
            // If we have a safearray of bytes, we'll use it as is ...
            CVariantVector<BYTE> octets(src);
            dst.setOctetString(octets.size(), octets.data());
         }
         else
         {
            // ... otherwise we'll coerce to a BSTR.
            CheckError(VariantChangeType(src, src, NULL, VT_BSTR));
            dst.setOctetString(V_BSTR(src));
         }

         break;
      }

      case IASTYPE_UTC_TIME:
      {
         CheckError(VariantChangeType(src, src, NULL, VT_DATE));

         SYSTEMTIME st;
         if (!VariantTimeToSystemTime(V_DATE(src), &st))
         {
            _com_issue_error(E_INVALIDARG);
         }

         CheckSuccess(SystemTimeToFileTime(&st, &dst->Value.UTCTime));
         break;
      }

      default:
         _com_issue_error(E_INVALIDARG);
   }

   // We don't set the type until the attribute has been properly initialized.
   // Otherwise IASAttributeRelease will have problems if we throw an
   // exception.
   dst->Value.itType = type;

   return dst.detach();
}


//////////
// Convert an LDAP berval to a newly allocated IASATTRIBUTE.
//////////
PIASATTRIBUTE
WINAPI
IASAttributeFromBerVal(
    const berval& src,
    IASTYPE type
    ) throw (_com_error)
{
   // Allocate an attribute.
   IASAttribute dst(true);

   // Convert the berval based on the IASTYPE.
   switch (type)
   {
      case IASTYPE_BOOLEAN:
      {
         dst->Value.Boolean =
            _strnicmp(src.bv_val, "TRUE", src.bv_len) ? FALSE : TRUE;
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_INET_ADDR:
      case IASTYPE_ENUM:
      {
         dst->Value.Integer = strtoul(src.bv_val, NULL, 10);
         break;
      }

      case IASTYPE_STRING:
      {
         dst.setString((PCSTR)src.bv_val);
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         dst.setOctetString(src.bv_len, (const BYTE*)src.bv_val);
         break;
      }


      case IASTYPE_UTC_TIME:
      default:
         _com_issue_error(E_INVALIDARG);
   }

   // We don't set the type until the attribute has been properly initialized.
   // Otherwise IASAttributeRelease will have problems if we throw an
   // exception.
   dst->Value.itType = type;

   return dst.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\dbconfig.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines functions for loading and storing the database configuration.
//
///////////////////////////////////////////////////////////////////////////////

#include "nt.h"
#include "ntlsa.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "oaidl.h"
#include "dbconfig.h"

static const wchar_t privateKeyName[] = L"NetPolAccountingDbConfig";


HRESULT
WINAPI
IASLoadDatabaseConfig(
   PCWSTR server,
   BSTR* initString,
   BSTR* dataSourceName
   )
{
   OBJECT_ATTRIBUTES objAttrs;
   HANDLE lsa;
   NTSTATUS status;
   LSA_UNICODE_STRING keyName, systemName, *data;
   BSTR bstr1, bstr2;
   ULONG winError;

   // Validate and initialize the out parameters.
   if ((initString == 0) || (dataSourceName == 0))
   {
      return E_POINTER;
   }
   *initString = 0;
   *dataSourceName = 0;

   // Open a connection to the LSA.
   RtlInitUnicodeString(&systemName, server);
   InitializeObjectAttributes(&objAttrs, 0, 0, 0, 0);
   status = LsaOpenPolicy(
               &systemName,
               &objAttrs,
               POLICY_GET_PRIVATE_INFORMATION,
               &lsa
               );
   if (NT_SUCCESS(status))
   {
      RtlInitUnicodeString(&keyName, privateKeyName);

      // Retrieve the private data.
      status = LsaRetrievePrivateData(lsa, &keyName, &data);
      if (NT_SUCCESS(status) && (data != 0))
      {
         if (data->Length > 0)
         {
            // Data is two adjacent null-terminated strings.
            bstr1 = SysAllocString(data->Buffer);
            bstr2 = SysAllocString(data->Buffer + wcslen(data->Buffer) + 1);

            if ((initString == 0) || (dataSourceName == 0))
            {
               SysFreeString(bstr1);
               SysFreeString(bstr2);
               status = STATUS_NO_MEMORY;
            }
            else
            {
               *initString = bstr1;
               *dataSourceName = bstr2;
            }
         }

         LsaFreeMemory(data);
      }
      else if (status == STATUS_OBJECT_NAME_NOT_FOUND)
      {
         status = STATUS_SUCCESS;
      }

      LsaClose(lsa);
   }

   winError = LsaNtStatusToWinError(status);
   return HRESULT_FROM_WIN32(winError);
}


HRESULT
WINAPI
IASStoreDatabaseConfig(
   PCWSTR server,
   PCWSTR initString,
   PCWSTR dataSourceName
   )
{
   LSA_UNICODE_STRING data, systemName, keyName;
   size_t initStringLen, dataSourceNameLen, nbyte;
   OBJECT_ATTRIBUTES objAttribs;
   NTSTATUS status;
   HANDLE lsa;
   ULONG winError;

   if ((initString != 0) && (dataSourceName != 0))
   {
      // Allocate memory to hold the data.
      initStringLen = wcslen(initString) + 1;
      dataSourceNameLen = wcslen(dataSourceName) + 1;
      nbyte = (initStringLen + dataSourceNameLen) * sizeof(wchar_t);

      data.Buffer = CoTaskMemAlloc(nbyte);
      if (data.Buffer == 0)
      {
         return E_OUTOFMEMORY;
      }

      // Data is two adjacent null terminated strings.
      memcpy(
         data.Buffer,
         initString,
         (initStringLen * sizeof(wchar_t))
         );
      memcpy(
         (data.Buffer + initStringLen),
         dataSourceName,
         (dataSourceNameLen * sizeof(wchar_t))
         );

      data.Length = (USHORT)nbyte;
      data.MaximumLength = (USHORT)nbyte;
   }
   else
   {
      // Config is null, so just zero out the data.
      data.Buffer = 0;
      data.Length = 0;
      data.MaximumLength = 0;
   }

   // Open a connection to the LSA.
   RtlInitUnicodeString(&systemName, server);
   InitializeObjectAttributes(&objAttribs, 0, 0, 0, 0);
   status = LsaOpenPolicy(
               &systemName,
               &objAttribs,
               POLICY_CREATE_SECRET,
               &lsa
               );
   if (NT_SUCCESS(status))
   {
      RtlInitUnicodeString(&keyName, privateKeyName);

      // Store the config.
      status = LsaStorePrivateData(lsa, &keyName, &data);
      LsaClose(lsa);
   }

   CoTaskMemFree(data.Buffer);

   winError = LsaNtStatusToWinError(status);
   return HRESULT_FROM_WIN32(winError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\iastl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iastl.cpp
//
// SYNOPSIS
//
//    Used to compile iastlimp.cpp with IAS specific definitions.
//
// MODIFICATION HISTORY
//
//    08/12/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

///////////////////////////////////////////////////////////////////////////////
//
// IASTL implementation.
//
///////////////////////////////////////////////////////////////////////////////

#include <iastlutl.h>
#include <iastlimp.cpp>
void IASTL::issue_error(HRESULT hr) { _com_issue_error(hr); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\iastrace.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the API into the IAS trace facility.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <rtutils.h>

//////////
// Flags passed for all trace calls.
//////////
#define IAS_TRACE_FLAGS \
   (0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC | TRACE_USE_DATE)

//////////
// Trace ID for this module.
//////////
DWORD dwTraceID = INVALID_TRACEID;

//////////
// Initialization ref. count.
//////////
LONG lRefCount = 0;

//////////
// Non-zero if the registration code is locked.
//////////
LONG lLocked = 0;

//////////
// Macros to lock/unlock the registration code.
//////////
#define LOCK_TRACE() \
   while (InterlockedExchange(&lLocked, 1)) Sleep(5)

#define UNLOCK_TRACE() \
   InterlockedExchange(&lLocked, 0)

VOID
WINAPI
IASTraceInitialize( VOID )
{
   LONG state;
   DWORD status;
   MEMORY_BASIC_INFORMATION mbi;
   WCHAR filename[MAX_PATH + 1], *basename, *suffix;

   LOCK_TRACE();

   if (++lRefCount == 1)
   {
      // Find the base address of this module.
      if (VirtualQuery(IASTraceInitialize, &mbi, sizeof(mbi)))
      {
         // Get the module filename.
         status = GetModuleFileNameW(
                      (HINSTANCE)mbi.AllocationBase,
                      filename,
                      MAX_PATH
                      );
         if (status != 0)
         {
            // Strip everything before the last backslash.
            basename = wcsrchr(filename, L'\\');
            if (basename == NULL)
            {
               basename = filename;
            }
            else
            {
               ++basename;
            }

            // Strip everything after the last dot.
            suffix = wcsrchr(basename, L'.');
            if (suffix)
            {
               *suffix = L'\0';
            }

            // Convert to uppercase.
            _wcsupr(basename);

            // Register the module.
            dwTraceID = TraceRegisterExW(basename, 0);
         }
      }
   }

   UNLOCK_TRACE();
}


VOID
WINAPI
IASTraceUninitialize( VOID )
{
   LOCK_TRACE();

   if (--lRefCount == 0)
   {
      TraceDeregisterW(dwTraceID);
      dwTraceID = INVALID_TRACEID;
   }

   UNLOCK_TRACE();
}


//////////
// Formats an error message from the system message table.
//////////
DWORD
WINAPI
IASFormatSysErr(
    DWORD dwError,
    PSTR lpBuffer,
    DWORD nSize
    )
{
   DWORD nChar;

   // Attempt to format the message using the system message table.
   nChar = FormatMessageA(
               FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               dwError,
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               lpBuffer,
               nSize,
               NULL
               );

   if (nChar > 0)
   {
      // Format succeeded, so strip any trailing newline and exit.
      if (lpBuffer[nChar - 1] == '\n')
      {
         --nChar;
         lpBuffer[nChar] = '\0';

         if (lpBuffer[nChar - 1] == '\r')
         {
            --nChar;
            lpBuffer[nChar] = '\0';
         }
      }

      goto exit;
   }

   // Only error condition we can handle is when the message is not found.
   if (GetLastError() != ERROR_MR_MID_NOT_FOUND)
   {
      goto exit;
   }

   // Do we have enough space for the fallback error message ?
   if (nSize < 25)
   {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);

      goto exit;
   }

   // No entry in the message table, so just format the raw error code.
   nChar = wsprintfA(lpBuffer, "Unknown error 0x%0lX", dwError);

exit:
   return nChar;
}

VOID
WINAPIV
IASTracePrintf(
    IN PCSTR szFormat,
    ...
    )
{
   va_list marker;
   va_start(marker, szFormat);
   TraceVprintfExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       szFormat,
       marker
       );
   va_end(marker);
}

VOID
WINAPI
IASTraceString(
    IN PCSTR szString
    )
{
   TracePutsExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       szString
       );
}

VOID
WINAPI
IASTraceBinary(
    IN CONST BYTE* lpbBytes,
    IN DWORD dwByteCount
    )
{
   TraceDumpExA(
       dwTraceID,
       IAS_TRACE_FLAGS,
       (LPBYTE)lpbBytes,
       dwByteCount,
       1,
       FALSE,
       NULL
       );
}

VOID
WINAPI
IASTraceFailure(
    IN PCSTR szFunction,
    IN DWORD dwError
    )
{
   CHAR szMessage[256];
   DWORD nChar;

   nChar = IASFormatSysErr(
               dwError,
               szMessage,
               sizeof(szMessage)
               );

   szMessage[nChar] = '\0';

   IASTracePrintf("%s failed: %s", szFunction, szMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\iasutf8.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasutf8.c
//
// SYNOPSIS
//
//    Defines functions for converting between UTF-8 and Unicode.
//
// MODIFICATION HISTORY
//
//    01/22/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <iasutf8.h>

/////////
// Tests the validity of a UTF-8 trail byte. Must be of the form 10vvvvvv.
/////////
#define NOT_TRAIL_BYTE(b) (((BYTE)(b) & 0xC0) != 0x80)

//////////
// Returns the number of characters required to hold the converted string. The
// source string may not contain nulls.  Returns -1 if 'src' is not a valid
// UTF-8 string.
//////////
LONG
WINAPI
IASUtf8ToUnicodeLength(
    PCSTR src,
    DWORD srclen
    )
{
   LONG nchar;
   PCSTR end;

   if (src == NULL) { return 0; }

   // Number of characters needed.
   nchar = 0;

   // End of string to be converted.
   end = src + srclen;

   // Loop through the UTF-8 string.
   while (src < end)
   {
      if (*src == 0)
      {
         // Do not allow embedded nulls.
         return -1;
      }
      else if ((BYTE)*src < 0x80)
      {
         // 0vvvvvvv = 1 byte character.
      }
      else if ((BYTE)*src < 0xC0)
      {
         // 10vvvvvv = Invalid lead byte.
         return -1;
      }
      else if ((BYTE)*src < 0xE0)
      {
         // 110vvvvv = 2 byte character.
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
      }
      else if ((BYTE)*src < 0xF0)
      {
         // 1110vvvv = 3 byte character.
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
      }
      else
      {
         // In theory, UTF-8 supports 4-6 byte characters, but Windows uses
         // 16-bit integers for Unicode, so we can't handle them.
         return -1;
      }

      // We successfully parsed a UTF-8 character.
      ++src;
      ++nchar;
   }

   // Return the number of characters needed.
   return nchar;
}

//////////
// Returns the number of characters required to hold the converted string.
//////////
LONG
WINAPI
IASUnicodeToUtf8Length(
    PCWSTR src,
    DWORD srclen
    )
{
   LONG nchar;
   PCWSTR end;

   if (src == NULL) { return 0; }

   // Number of characters needed.
   nchar = 0;

   // End of string to be converted.
   end = src + srclen;

   // Loop through the Unicode string.
   while (src < end)
   {
      if (*src < 0x80)
      {
         // 1 byte character.
         nchar += 1;
      }
      else if (*src < 0x800)
      {
         // 2 byte character.
         nchar += 2;
      }
      else
      {
         // 3 byte character.
         nchar += 3;
      }

      // Advance to the next character in the string.
      ++src;
   }

   // Return the number of characters needed.
   return nchar;
}

/////////
// Converts a UTF-8 string to Unicode.  Returns the number of characters in the
// converted string. The source string may not contain nulls. Returns -1 if
// 'src' is not a valid UTF-8 string.
/////////
LONG
IASUtf8ToUnicode(
    PCSTR src,
    DWORD srclen,
    PWSTR dst
    )
{
   PCWSTR start;
   PCSTR end;

   if (!src || !dst) { return 0; }

   // Remember where we started.
   start = dst;

   // End of the string to be converted.
   end = src + srclen;

   // Loop through the source UTF-8 string.
   while (src < end)
   {
      if (*src == 0)
      {
         // Do not allow embedded nulls.
         return -1;
      }
      else if ((BYTE)*src < 0x80)
      {
         // 1 byte character: 0vvvvvvv
         *dst = *src;
      }
      else if ((BYTE)*src < 0xC0)
      {
         // Invalid lead byte: 10vvvvvv
         return -1;
      }
      else if ((BYTE)*src < 0xE0)
      {
         // 2 byte character: 110vvvvv 10vvvvvv
         *dst  = (*src & 0x1F) <<  6;
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
         *dst |= (*src & 0x3F);
      }
      else if ((BYTE)*src < 0xF0)
      {
         // 3 byte character: 1110vvvv 10vvvvvv 10vvvvvv
         *dst  = (*src & 0x0F) << 12;
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
         *dst |= (*src & 0x3f) <<  6;
         if (NOT_TRAIL_BYTE(*++src)) { return -1; }
         *dst |= (*src & 0x3f);
      }
      else
      {
         // In theory, UTF-8 supports 4-6 byte characters, but Windows uses
         // 16-bit integers for Unicode, so we can't handle them.
         return -1;
      }

      // Advance to the next character.
      ++src;
      ++dst;
   }

   // Return the number of characters in the converted string.
   return  (LONG)(dst - start);
}

/////////
// Converts a Unicode string to UTF-8.  Returns the number of characters in the
// converted string.
/////////
LONG
IASUnicodeToUtf8(
    PCWSTR src,
    DWORD srclen,
    PSTR dst
    )
{
   PCSTR start;
   PCWSTR end;

   if (!src || !dst) { return 0; }

   // Remember where we started.
   start = dst;

   // End of the string to be converted.
   end = src + srclen;

   // Loop through the source Unicode string.
   while (src < end)
   {
      if (*src < 0x80)
      {
         // Pack as 0vvvvvvv
         *dst++ = (CHAR)*src;
      }
      else if (*src < 0x800)
      {
         // Pack as 110vvvvv 10vvvvvv 10vvvvvv
         *dst++ = (CHAR)(0xC0 | ((*src >>  6) & 0x3F));
         *dst++ = (CHAR)(0x80 | ((*src      ) & 0x3F));
      }
      else
      {
         // Pack as 1110vvvv 10vvvvvv 10vvvvvv
         *dst++ = (CHAR)(0xE0 | ((*src >> 12)       ));
         *dst++ = (CHAR)(0x80 | ((*src >>  6) & 0x3F));
         *dst++ = (CHAR)(0x80 | ((*src      ) & 0x3F));
      }

      // Advance to the next character.
      ++src;
   }

   // Return the number of characters in the converted string.
   return  (LONG)(dst - start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\eapprofile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class EapProfile.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include <algorithm>
#include "EapProfile.h"
#include <align.h>

EapProfile::EapProfile() throw ()
   : begin(0),
     end(0),
     capacity(0)
{
}


EapProfile::~EapProfile() throw ()
{
   Clear();
   CoTaskMemFree(begin);
}


HRESULT EapProfile::Assign(const EapProfile& rhs) throw ()
{
   if (this == &rhs)
   {
      return S_OK;
   }

   Clear();
   Reserve(rhs.Size());

   for (const ConfigData* i = rhs.begin; i != rhs.end; ++i)
   {
      end->length = i->length;
      end->value = static_cast<BYTE*>(CoTaskMemAlloc(i->length));
      if (end->value == 0)
      {
         Clear();
         return E_OUTOFMEMORY;
      }
      memcpy(end->value, i->value, i->length);
      ++end;
   }

   return S_OK;
}


HRESULT EapProfile::Load(VARIANT& src) throw ()
{
   HRESULT hr;

   Clear();

   if (V_VT(&src) == VT_EMPTY)
   {
      return S_OK;
   }

   if (V_VT(&src) != (VT_ARRAY | VT_VARIANT))
   {
      return DISP_E_TYPEMISMATCH;
   }

   const SAFEARRAY* sa = V_ARRAY(&src);
   if (sa == 0)
   {
      return E_POINTER;
   }

   // Find the first and last elements of the VARIANT array.
   VARIANT* first = static_cast<VARIANT*>(sa->pvData);
   VARIANT* last = first + sa->rgsabound[0].cElements;

   // Ensure that all the VARIANTs contain a valid config value.
   for (const VARIANT* i = first; i != last; ++i)
   {
      hr = ValidateConfigChunk(*i);
      if (FAILED(hr))
      {
         return hr;
      }
   }

   // Sort the VARIANTs by type and sequence.
   std::sort(first, last, LessThan);

   // Gather the config for each type.
   for (const VARIANT* j = first; j != last; )
   {
      BYTE type = ExtractString(*j)[0];

      // Find the end of the type's config.
      const VARIANT* typeEnd = j + 1;
      while ((typeEnd != last) && (ExtractString(*typeEnd)[0] == type))
      {
         ++typeEnd;
      }

      // Gather the config for this type.
      hr = GatherAndAppend(j, typeEnd);
      if (FAILED(hr))
      {
         return hr;
      }

      // Advance to the next type.
      j = typeEnd;
   }

   return S_OK;
}


HRESULT EapProfile::Store(VARIANT& dst) throw ()
{
   HRESULT hr;

   // Clear the out parameter.
   VariantInit(&dst);

   // Computer the number of VARIANTs required.
   DWORD nelem = 0;
   for (const ConfigData* i = begin; i != end; ++i)
   {
      nelem += ChunksRequired(*i);
   }

   // Allocate the SAFEARRAY for the result.
   SAFEARRAY* sa = SafeArrayCreateVector(VT_VARIANT, 0, nelem);
   if (sa == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Scatter the config into the SAFEARRAY.
   VARIANT* nextValue = static_cast<VARIANT*>(sa->pvData);
   for (const ConfigData* j = begin; j != end; ++j)
   {
      hr = Scatter(*j, nextValue);
      if (FAILED(hr))
      {
         SafeArrayDestroy(sa);
         return hr;
      }
   }

   // Store the result.
   V_VT(&dst) = VT_ARRAY | VT_VARIANT;
   V_ARRAY(&dst) = sa;

   return S_OK;
}


void EapProfile::Clear() throw ()
{
   while (end > begin)
   {
      --end;

      CoTaskMemFree(end->value);
   }
}


void EapProfile::ClearExcept(BYTE type) throw ()
{
   for (ConfigData* i = begin; i != end; )
   {
      if (i->value[0] != type)
      {
         // Free the config.
         CoTaskMemFree(i->value);

         // Decrement the number of elements.
         --end;

         // After Load completes we don't care if the array is sorted so we can
         // just move the last element into the empty slot.
         *i = *end;
      }
      else
      {
         ++i;
      }
   }
}


void EapProfile::Erase(BYTE type) throw ()
{
   for (ConfigData* i = begin; i != end; ++i)
   {
      if (i->value[0] == type)
      {
         // Free the config.
         CoTaskMemFree(i->value);

         // Decrement the number of elements.
         --end;

         // After Load completes we don't care if the array is sorted so we can
         // just move the last element into the empty slot.
         *i = *end;

         break;
      }
   }
}


void EapProfile::Get(BYTE type, ConstConfigData& dst) const throw ()
{
   for (const ConfigData* i = begin; i != end; ++i)
   {
      if (i->value[0] == type)
      {
         // The EAP DLL doesn't want the type byte.
         dst.length = i->length - ALIGN_WORST;
         dst.value = i->value + ALIGN_WORST;
         return;
      }
   }

   dst.length = 0;
   dst.value = 0;
}


HRESULT EapProfile::Set(BYTE type, const ConstConfigData& newConfig) throw ()
{
   if (newConfig.length == 0)
   {
      Erase(type);
      return S_OK;
   }

   if (newConfig.value == 0)
   {
      return E_POINTER;
   }

   if (ChunksRequired(newConfig) > maxChunks)
   {
      return E_INVALIDARG;
   }

   // Ensure that we have room for the new element before we copy the value.
   HRESULT hr = Reserve(Size() + 1);
   if (FAILED(hr))
   {
      return hr;
   }

   // One extra byte for the type tag. Rounded to ALIGN_WORST
   DWORD len = newConfig.length + ALIGN_WORST;
   BYTE* val = static_cast<BYTE*>(CoTaskMemAlloc(len));
   if (val == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Erase any existing config for the type.
   Erase(type);

   // Start with the lead type byte.
   val[0] = type;
   // And then the rest of the configuration.
   memcpy(val + ALIGN_WORST, newConfig.value, newConfig.length);

   // Append the result.
   end->length = len;
   end->value = val;
   ++end;

   return S_OK;
}


void EapProfile::Pop(ConfigData& dst) throw ()
{
   --end;
   dst = *end;
}


void EapProfile::Swap(EapProfile& other) throw ()
{
   std::swap(begin, other.begin);
   std::swap(end, other.end);
   std::swap(capacity, other.capacity);
}


inline EapProfile::SeqNum EapProfile::ExtractSequence(const BYTE* src) throw ()
{
   return (static_cast<SeqNum>(src[0]) << 8) | static_cast<SeqNum>(src[1]);
}


inline void EapProfile::InsertSequence(SeqNum seq, BYTE* dst) throw ()
{
   dst[0] = static_cast<BYTE>((seq >> 8) & 0xFF);
   dst[1] = static_cast<BYTE>(seq & 0xFF);
}


HRESULT EapProfile::GatherAndAppend(
                       const VARIANT* first,
                       const VARIANT* last
                       ) throw ()
{
   HRESULT hr = Reserve(Size() + 1);
   if (FAILED(hr))
   {
      return hr;
   }

   // 1 type byte for the entire config.
   DWORD len = ALIGN_WORST;
   for (const VARIANT* i = first; i != last; ++i)
   {
      // Ignore the SDO header.
      len += ExtractLength(*i) - sdoHeaderSize;
   }

   BYTE* val = static_cast<BYTE*>(CoTaskMemAlloc(len));
   if (val == 0)
   {
      return E_OUTOFMEMORY;
   }

   end->length = len;
   end->value = val;
   ++end;

   // Get the type byte out of the first chunk.
   val[0] = ExtractString(*first)[0];
   // keep the real value aligned 
   val += ALIGN_WORST;

   // Now concatenate the chunks, ignoring the header.
   for (const VARIANT* j = first; j != last; ++j)
   {
      size_t chunkSize = (ExtractLength(*j) - sdoHeaderSize);
      memcpy(val, (ExtractString(*j) + sdoHeaderSize), chunkSize);
      val += chunkSize;
   }

   return S_OK;
}


HRESULT EapProfile::Scatter(
                       const ConstConfigData& src,
                       VARIANT*& dst
                       ) throw ()
{
   BYTE type = src.value[0];
   
   const BYTE* val = src.value + ALIGN_WORST;
   DWORD len = src.length - ALIGN_WORST;

   // Sequence number.
   SeqNum sequence = 0;

   // Keep scattering until it's all gone.
   while (len > 0)
   {
      // Compute the size of this chunk.
      size_t chunkSize = (len > maxChunkSize) ? maxChunkSize : len;

      // Create a SAFEARRAY of BYTEs to hold the data.
      SAFEARRAY* sa = SafeArrayCreateVector(
                         VT_UI1,
                         0,
                         (chunkSize + sdoHeaderSize)
                         );
      if (sa == 0)
      {
         return E_OUTOFMEMORY;
      }

      // Add the type byte and sequence number.
      BYTE* chunk = static_cast<BYTE*>(sa->pvData);
      chunk[0] = type;
      InsertSequence(sequence, chunk + 1);
      memcpy(chunk + sdoHeaderSize, val, chunkSize);

      // Store it in the dst VARIANT.
      V_VT(dst) = VT_ARRAY | VT_UI1;
      V_ARRAY(dst) = sa;
      ++dst;

      // Update our cursor.
      val += chunkSize;
      len -= chunkSize;
      ++sequence;
   }

   return S_OK;
}


HRESULT EapProfile::Reserve(size_t newCapacity) throw ()
{
   if (newCapacity <= capacity)
   {
      return S_OK;
   }

   // Ensure we grow wisely.
   const size_t minGrowth = (capacity < 4) ? 4 : ((capacity * 3) / 2);
   if (newCapacity < minGrowth)
   {
      newCapacity = minGrowth;
   }


   // Allocate the new array.
   size_t nbyte = newCapacity * sizeof(ConfigData);
   ConfigData* newBegin = static_cast<ConfigData*>(
                                          CoTaskMemAlloc(nbyte)
                                          );
   if (newBegin == 0)
   {
      return E_OUTOFMEMORY;
   }

   // Save the existing data.
   memcpy(newBegin, begin, Size() * sizeof(ConfigData));

   // Update the state.
   end = newBegin + Size();
   capacity = newCapacity;

   // Now it's safe to free the old array and swap in the new.
   CoTaskMemFree(begin);
   begin = newBegin;

   return S_OK;
}


inline size_t EapProfile::ChunksRequired(const ConstConfigData& str) throw ()
{
   return ((str.length - ALIGN_WORST) + (maxChunkSize - 1)) / maxChunkSize;
}


inline DWORD EapProfile::ExtractLength(const VARIANT& src) throw ()
{
   return V_ARRAY(&src)->rgsabound[0].cElements;
}


inline const BYTE* EapProfile::ExtractString(const VARIANT& src) throw ()
{
   return static_cast<const BYTE*>(V_ARRAY(&src)->pvData);
}


bool EapProfile::LessThan(const VARIANT& lhs, const VARIANT& rhs) throw ()
{
   const BYTE* val1 = ExtractString(lhs);
   const BYTE* val2 = ExtractString(rhs);

   // Sort first by type, then sequence.
   if (val1[0] < val2[0])
   {
      return true;
   }
   else if (val1[0] == val2[0])
   {
      return ExtractSequence(val1 + 1) < ExtractSequence(val2 + 1);
   }
   else
   {
      return false;
   }
}


HRESULT EapProfile::ValidateConfigChunk(const VARIANT& value) throw ()
{
   if (V_VT(&value) != (VT_ARRAY | VT_UI1))
   {
      return DISP_E_TYPEMISMATCH;
   }

   const SAFEARRAY* sa = V_ARRAY(&value);
   if (sa == 0)
   {
      return E_POINTER;
   }

   // The data has to be big enough for the header and 1 data byte.
   if (sa->rgsabound[0].cElements <= sdoHeaderSize)
   {
      return E_INVALIDARG;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\iastlimp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    Provides function definitions for the Internet Authentication Service
//    Template Library (IASTL).
//
///////////////////////////////////////////////////////////////////////////////

//////////
// IASTL must be used in conjuction with ATL.
//////////
#ifndef __ATLCOM_H__
   #error iastlimp.cpp requires atlcom.h to be included first
#endif

#include <windows.h>

//////////
// IASTL declarations.
//////////
#include <iastl.h>

//////////
// The entire library is contained within the IASTL namespace.
//////////
namespace IASTL {

//////////
// FSM governing IAS components.
//////////
const IASComponent::State IASComponent::fsm[NUM_EVENTS][NUM_STATES] =
{
   { STATE_UNINITIALIZED, STATE_UNEXPECTED,    STATE_UNEXPECTED,    STATE_UNEXPECTED  },
   { STATE_UNEXPECTED,    STATE_INITIALIZED,   STATE_INITIALIZED,   STATE_UNEXPECTED  },
   { STATE_UNEXPECTED,    STATE_UNEXPECTED,    STATE_SUSPENDED,     STATE_SUSPENDED   },
   { STATE_UNEXPECTED,    STATE_UNEXPECTED,    STATE_INITIALIZED,   STATE_INITIALIZED },
   { STATE_SHUTDOWN,      STATE_SHUTDOWN,      STATE_UNEXPECTED,    STATE_SHUTDOWN    }
};


///////////////////////////////////////////////////////////////////////////////
//
// IASComponent
//
///////////////////////////////////////////////////////////////////////////////

HRESULT IASComponent::fireEvent(Event event) throw ()
{
   // Check the input parameters.
   if (event >= NUM_EVENTS) { return E_UNEXPECTED; }

   // Compute the next state.
   State next = fsm[event][state];

   Lock();

   HRESULT hr;

   if (next == state)
   {
      // If we're already in that state, there's nothing to do.
      hr = S_OK;
   }
   else if (next == STATE_UNEXPECTED)
   {
      // We received an unexpected event.
      hr = E_UNEXPECTED;
   }
   else
   {
      // Attempt the transition.
      hr = attemptTransition(event);

      // Only change state if the transition was successful.
      if (SUCCEEDED(hr))
      {
         state = next;
      }
   }

   Unlock();

   return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// IASRequestHandler
//
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP IASRequestHandler::OnRequest(IRequest* pRequest)
{
   if (getState() != IASComponent::STATE_INITIALIZED)
   {
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
      pRequest->ReturnToSource(IAS_REQUEST_STATUS_ABORT);
   }
   else
   {
      onAsyncRequest(pRequest);
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// IASRequestHandlerSync
//
///////////////////////////////////////////////////////////////////////////////

void IASRequestHandlerSync::onAsyncRequest(IRequest* pRequest) throw ()
{
   pRequest->ReturnToSource(onSyncRequest(pRequest));
}

//////////
// End of the IASTL namespace.
//////////
}

//////////
// Only pull in the utility classes if necessary.
//////////
#ifdef IASTLUTL_H

//////////
// The utility classes are also contained within the IASTL namespace.
//////////
namespace IASTL {

///////////////////////////////////////////////////////////////////////////////
//
// IASAttribute
//
///////////////////////////////////////////////////////////////////////////////

IASAttribute& IASAttribute::operator=(PIASATTRIBUTE attr) throw ()
{
   // Check for self-assignment.
   if (p != attr)
   {
      _release();
      p = attr;
      _addref();
   }
   return *this;
}

void IASAttribute::attach(PIASATTRIBUTE attr, bool addRef) throw ()
{
   _release();
   p = attr;
   if (addRef) { _addref(); }
}

bool IASAttribute::load(IAttributesRaw* request, DWORD dwId)
{
   // Release any existing attribute.
   release();

   DWORD posCount = 1;
   ATTRIBUTEPOSITION pos;
   HRESULT hr = request->GetAttributes(&posCount, &pos, 1, &dwId);
   if (FAILED(hr))
   {
      if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
      {
         // There was more than one, so release the partial result.
         IASAttributeRelease(pos.pAttribute);
      }
      issue_error(hr);
   }

   p = (posCount ? pos.pAttribute : NULL);

   return p != NULL;
}

bool IASAttribute::load(IAttributesRaw* request, DWORD dwId, IASTYPE itType)
{
   // Get an attribute with the given ID.
   load(request, dwId);

   // Attributes have a fixed type, so if the type doesn't match it must
   // be an error.
   if (p && p->Value.itType != itType)
   {
      release();
      issue_error(DISP_E_TYPEMISMATCH);
   }

   return p != NULL;
}

void IASAttribute::store(IAttributesRaw* request) const
{
   if (p)
   {
      ATTRIBUTEPOSITION pos;
      pos.pAttribute = p;
      HRESULT hr = request->AddAttributes(1, &pos);
      if (FAILED(hr))
      {
         issue_error(hr);
      }
   }
}

void IASAttribute::setOctetString(DWORD dwLength, const BYTE* lpValue)
{
   PBYTE newVal = NULL;

   if (dwLength)
   {
      // Allocate a buffer for the octet string ...
      newVal = (PBYTE)CoTaskMemAlloc(dwLength);
      if (!newVal) { issue_error(E_OUTOFMEMORY); }

      // ... and copy it in.
      if (lpValue != NULL)
      {
         memcpy(newVal, lpValue, dwLength);
      }
   }

   // Clear the old value.
   clearValue();

   // Store the new.
   p->Value.OctetString.lpValue = newVal;
   p->Value.OctetString.dwLength = dwLength;
   p->Value.itType = IASTYPE_OCTET_STRING;
}

void IASAttribute::setOctetString(PCSTR szAnsi)
{
   setOctetString((szAnsi ? strlen(szAnsi) : 0), (const BYTE*)szAnsi);
}

void IASAttribute::setOctetString(PCWSTR szWide)
{
   // Allocate a buffer for the conversion.
   int len = WideCharToMultiByte(CP_ACP, 0, szWide, -1, NULL, 0, NULL, NULL);
   PSTR ansi = (PSTR)_alloca(len);

   // Convert from wide to ansi.
   len = WideCharToMultiByte(CP_ACP, 0, szWide, -1, ansi, len, NULL, NULL);

   // Don't include the null-terminator.
   if (len) { --len; }

   // Set the octet string.
   setOctetString(len, (const BYTE*)ansi);
}

void IASAttribute::setString(DWORD dwLength, const BYTE* lpValue)
{
   // Reserve space for a null terminator.
   LPSTR newVal = (LPSTR)CoTaskMemAlloc(dwLength + 1);
   if (!newVal) { issue_error(E_OUTOFMEMORY); }

   // Copy in the string ...
   memcpy(newVal, lpValue, dwLength);
   // ... and add a null terminator.
   newVal[dwLength] = 0;

   // Clear the old value.
   clearValue();

   // Store the new value.
   p->Value.String.pszAnsi = newVal;
   p->Value.String.pszWide = NULL;
   p->Value.itType = IASTYPE_STRING;

}

void IASAttribute::setString(PCSTR szAnsi)
{
   LPSTR newVal = NULL;

   if (szAnsi)
   {
      // Allocate a buffer for the string ...
      size_t nbyte = strlen(szAnsi) + 1;
      newVal = (LPSTR)CoTaskMemAlloc(nbyte);
      if (!newVal) { issue_error(E_OUTOFMEMORY); }

      // ... and copy it in.
      memcpy(newVal, szAnsi, nbyte);
   }

   // Clear the old value.
   clearValue();

   // Store the new value.
   p->Value.String.pszAnsi = newVal;
   p->Value.String.pszWide = NULL;
   p->Value.itType = IASTYPE_STRING;
}

void IASAttribute::setString(PCWSTR szWide)
{
   LPWSTR newVal = NULL;

   if (szWide)
   {
      // Allocate a buffer for the string ...
      size_t nbyte = sizeof(WCHAR) * (wcslen(szWide) + 1);
      newVal = (LPWSTR)CoTaskMemAlloc(nbyte);
      if (!newVal) { issue_error(E_OUTOFMEMORY); }

      // ... and copy it in.
      memcpy(newVal, szWide, nbyte);
   }

   // Clear the old value.
   clearValue();

   // Store the new value.
   p->Value.String.pszWide = newVal;
   p->Value.String.pszAnsi = NULL;
   p->Value.itType = IASTYPE_STRING;
}

void IASAttribute::clearValue() throw ()
{
   switch (p->Value.itType)
   {
      case IASTYPE_STRING:
         CoTaskMemFree(p->Value.String.pszAnsi);
         CoTaskMemFree(p->Value.String.pszWide);
         break;

      case IASTYPE_OCTET_STRING:
         CoTaskMemFree(p->Value.OctetString.lpValue);
         break;
   }

   p->Value.itType = IASTYPE_INVALID;
}

///////////////////////////////////////////////////////////////////////////////
//
// IASAttributePosition
//
///////////////////////////////////////////////////////////////////////////////

IASAttributePosition& IASAttributePosition::operator=(
                                               const ATTRIBUTEPOSITION& rhs
                                               ) throw ()
{
   operator=(rhs.pAttribute);
   pos.dwReserved = rhs.dwReserved;
   return *this;
}

IASAttributePosition& IASAttributePosition::operator=(
                                               IASATTRIBUTE* rhs
                                               ) throw ()
{
   if (rhs != getAttribute())
   {
      _release();
      pos.pAttribute = rhs;
      _addref();
   }
   return *this;
}

///////////////////////////////////////////////////////////////////////////////
//
// IASAttributeVector
//
///////////////////////////////////////////////////////////////////////////////

IASAttributeVector::IASAttributeVector() throw ()
   : begin_(NULL), end_(NULL), capacity_(0), owner(false)
{ }

IASAttributeVector::IASAttributeVector(size_type N)
   : begin_(NULL), end_(NULL), capacity_(0), owner(false)
{
   reserve(N);
}

IASAttributeVector::IASAttributeVector(
                        PATTRIBUTEPOSITION init,
                        size_type initCap
                        ) throw ()
   : begin_(init), end_(begin_), capacity_(initCap), owner(false)
{ }

IASAttributeVector::IASAttributeVector(const IASAttributeVector& v)
   : begin_(NULL), end_(NULL), capacity_(0), owner(false)
{
   reserve(v.size());

   for (const_iterator i = v.begin(); i != v.end(); ++i, ++end_)
   {
      *end_ = *i;

      IASAttributeAddRef(end_->pAttribute);
   }
}

IASAttributeVector& IASAttributeVector::operator=(const IASAttributeVector& v)
{
   if (this != &v)
   {
      clear();

      reserve(v.size());

      for (const_iterator i = v.begin(); i != v.end(); ++i, ++end_)
      {
         *end_ = *i;

         IASAttributeAddRef(end_->pAttribute);
      }
   }

   return *this;
}

IASAttributeVector::~IASAttributeVector() throw ()
{
   clear();

   if (owner && begin_)
   {
      CoTaskMemFree(begin_);
   }
}

bool IASAttributeVector::contains(DWORD attrID) const throw ()
{
   for (const_iterator i = begin(); i != end(); ++i)
   {
      if ((i->pAttribute != 0) && (i->pAttribute->dwId == attrID))
      {
         return true;
      }
   }

   return false;
}

IASAttributeVector::iterator IASAttributeVector::discard(iterator p) throw ()
{
   // We now have one less attribute.
   --end_;

   // Shift over one.
   memmove(p, p + 1, (size_t)((PBYTE)end_ - (PBYTE)p));

   // The iterator now points to the next element, so no need to update.
   return p;
}

IASAttributeVector::iterator IASAttributeVector::fast_discard(iterator p) throw ()
{
   // We now have one less attribute.
   --end_;

   // Use the attribute from the end to fill the empty slot.
   *p = *end_;

   return p;
}

DWORD IASAttributeVector::load(
                              IAttributesRaw* request,
                              DWORD attrIDCount,
                              LPDWORD attrIDs
                              )
{
   clear();

   // Get the desired attributes.
   DWORD posCount = capacity_;
   HRESULT hr = request->GetAttributes(&posCount,
                                        begin_,
                                        attrIDCount,
                                        attrIDs);
   end_ = begin_ + posCount;

   if (FAILED(hr))
   {
      // Maybe the array just wasn't big enough.
      if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
      {
         // Clear the partial result.
         clear();

         // Find out how much space we really need.
         DWORD needed = 0;
         hr = request->GetAttributes(&needed, NULL, attrIDCount, attrIDs);
         if (FAILED(hr)) { issue_error(hr); }

         // Reserve the necessary space ...
         reserve(needed);

         // ... and try again.
         return load(request, attrIDCount, attrIDs);
      }

      end_ = begin_;

      issue_error(hr);
   }

   return posCount;
}

DWORD IASAttributeVector::load(IAttributesRaw* request)
{
   // Find out how much space we need.
   DWORD needed;
   HRESULT hr = request->GetAttributeCount(&needed);
   if (FAILED(hr)) { issue_error(hr); }

   // Make sure we have enough space.
   reserve(needed);

   return load(request, 0, NULL);
}

void IASAttributeVector::push_back(ATTRIBUTEPOSITION& p, bool addRef) throw ()
{
   // Make sure we have enough room for one more attribute.
   if (size() == capacity())
   {
      reserve(empty() ? 1 : 2 * size());
   }

   if (addRef) { IASAttributeAddRef(p.pAttribute); }

   // Store the attribute at the end.
   *end_ = p;

   // Move the end.
   ++end_;
}

void IASAttributeVector::remove(IAttributesRaw* request)
{
   if (begin_ != end_)
   {
      HRESULT hr = request->RemoveAttributes(size(), begin_);
      if (FAILED(hr)) { issue_error(hr); }
   }
}

void IASAttributeVector::store(IAttributesRaw* request) const
{
   if (begin_ != end_)
   {
      HRESULT hr = request->AddAttributes(size(), begin_);
      if (FAILED(hr)) { issue_error(hr); }
   }
}

void IASAttributeVector::clear() throw ()
{
   while (end_ != begin_)
   {
      --end_;
      IASAttributeRelease(end_->pAttribute);
   }
}

void IASAttributeVector::reserve(size_type N)
{
   // We only worry about growing; shrinking is a nop.
   if (N > capacity_)
   {
      // Allocate memory for the new vector.
      PATTRIBUTEPOSITION tmp =
         (PATTRIBUTEPOSITION)CoTaskMemAlloc(N * sizeof(ATTRIBUTEPOSITION));
      if (tmp == NULL) { issue_error(E_OUTOFMEMORY); }

      // Copy the existing attributes into the new array.
      size_type size_ = size();
      memcpy(tmp, begin_, size_ * sizeof(ATTRIBUTEPOSITION));

      // Free the old array if necessary.
      if (owner) { CoTaskMemFree(begin_); }

      // Update our state to point at the new array.
      begin_ = tmp;
      end_ = begin_ + size_;
      capacity_ = N;
      owner = true;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// IASRequest
//
///////////////////////////////////////////////////////////////////////////////

IASRequest::IASRequest(IRequest* request)
   : req(request)
{
   if (!req)
   {
      // We don't allow NULL request objects.
      issue_error(E_POINTER);
   }

   // Get the 'raw' counterpart.
   checkError(req->QueryInterface(__uuidof(IAttributesRaw), (PVOID*)&raw));
}

IASRequest& IASRequest::operator=(const IASRequest& request) throw ()
{
   // Check for self-assignment.
   if (this != &request)
   {
      _release();
      req = request.req;
      raw = request.raw;
      _addref();
   }
   return *this;
}

DWORD IASRequest::GetAttributes(DWORD dwPosCount,
                                PATTRIBUTEPOSITION pPositions,
                                DWORD dwAttrIDCount,
                                LPDWORD lpdwAttrIDs)
{
   DWORD count = dwPosCount;
   HRESULT hr = raw->GetAttributes(&count,
                                   pPositions,
                                   dwAttrIDCount,
                                   lpdwAttrIDs);
   if (FAILED(hr))
   {
      if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
      {
         // Free the partial results.
         while (count--)
         {
            IASAttributeRelease(pPositions->pAttribute);
            pPositions->pAttribute = NULL;
            ++pPositions;
         }
      }

      issue_error(hr);
   }

   return count;
}

IASDictionary::IASDictionary(
                   const WCHAR* const* selectNames,
                   PCWSTR path
                   )
   : mapSize(0),
     nextRowNumber(0),
     currentRow(NULL)
{
   if (!path)
   {
      // No path, so get the cached local dictionary.
      table = IASGetLocalDictionary();
      if (!table) { issue_error(GetLastError()); }
   }
   else
   {
      // Otherwise, get an arbitrary dictionary.
      HRESULT hr = IASGetDictionary(path, &data, &storage);
      if (FAILED(hr)) { issue_error(hr); }
      table = &data;
   }

   // How many columns are selected ?
   for (const WCHAR* const* p = selectNames; *p; ++p)
   {
      ++mapSize;
   }

   // Allocate memory for the map.
   selectMap = (PULONG)CoTaskMemAlloc(mapSize * sizeof(ULONG));
   if (!selectMap) { issue_error(E_OUTOFMEMORY); }

   // Lookup the column names.
   for (ULONG i = 0; i < mapSize; ++i)
   {
      // If it begins with a '-', it's optional.
      bool optional = false;
      const wchar_t* name = selectNames[i];
      if (*name == L'-')
      {
         optional = true;
         ++name;
      }

      // Find the column number.
      ULONG columnNumber = 0;
      while ((columnNumber < table->numColumns) &&
             (_wcsicmp(name, table->columnNames[columnNumber]) != 0))
      {
         ++columnNumber;
      }

      if ((columnNumber == table->numColumns) && !optional)
      {
         // We didn't find the column.
         CoTaskMemFree(selectMap);
         issue_error(E_INVALIDARG);
      }

      selectMap[i] = columnNumber;
   }
}

IASDictionary::~IASDictionary() throw ()
{
   CoTaskMemFree(selectMap);
}

bool IASDictionary::next() throw ()
{
   // Are there any rows left ?
   if (nextRowNumber >= table->numRows) { return false; }

   // Set currentRow to the next row.
   currentRow = table->table + nextRowNumber * table->numColumns;

   // Advance nextRowNumber.
   ++nextRowNumber;

   return true;
}

void IASDictionary::reset() throw ()
{
   nextRowNumber = 0;
   currentRow = NULL;
}

bool IASDictionary::isEmpty(ULONG ordinal) const
{
   return V_VT(getVariant(ordinal)) == VT_EMPTY;
}

VARIANT_BOOL IASDictionary::getBool(ULONG ordinal) const
{
   const VARIANT* v = getVariant(ordinal);

   if (V_VT(v) == VT_BOOL)
   {
      return V_BOOL(v);
   }
   else if (V_VT(v) != VT_EMPTY)
   {
      issue_error(DISP_E_TYPEMISMATCH);
   }

   return VARIANT_FALSE;
}

BSTR IASDictionary::getBSTR(ULONG ordinal) const
{
   const VARIANT* v = getVariant(ordinal);

   if (V_VT(v) == VT_BSTR)
   {
      return V_BSTR(v);
   }
   else if (V_VT(v) != VT_EMPTY)
   {
      issue_error(DISP_E_TYPEMISMATCH);
   }

   return NULL;
}

LONG IASDictionary::getLong(ULONG ordinal) const
{
   const VARIANT* v = getVariant(ordinal);

   if (V_VT(v) == VT_I4)
   {
      return V_I4(v);
   }
   else if (V_VT(v) != VT_EMPTY)
   {
      issue_error(DISP_E_TYPEMISMATCH);
   }

   return 0L;
}

const VARIANT* IASDictionary::getVariant(ULONG ordinal) const
{
   static VARIANT empty;

   // Are we positioned on a row ?
   if (!currentRow) { issue_error(E_UNEXPECTED); }

   // Is the ordinal valid ?
   if (ordinal >= mapSize) { issue_error(E_INVALIDARG); }

   // Get the table column.
   ULONG column = selectMap[ordinal];

   // If it's out of range, this must have been an optional field, so return
   // an empty VARIANT.
   return (column >= table->numColumns) ? &empty : currentRow + column;
}

//////////
// End of the IASTL namespace.
//////////
}

///////////////////////////////////////////////////////////////////////////////
//
// OctetString conversion macros and functions.
//
///////////////////////////////////////////////////////////////////////////////

PSTR IASOctetStringToAnsi(const IAS_OCTET_STRING& src, PSTR dst) throw ()
{
   dst[src.dwLength] = '\0';
   return (PSTR)memcpy(dst, src.lpValue, src.dwLength);
}

PWSTR IASOctetStringToWide(const IAS_OCTET_STRING& src, PWSTR dst) throw ()
{
   DWORD nChar = MultiByteToWideChar(CP_ACP,
                                     0,
                                     (PSTR)src.lpValue,
                                     src.dwLength,
                                     dst,
                                     src.dwLength);
   dst[nChar] = L'\0';
   return dst;
}

///////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous functions.
//
///////////////////////////////////////////////////////////////////////////////

// Returns 'true' if the IASTYPE maps to a RADIUS integer attribute.
bool isRadiusInteger(IASTYPE type) throw ()
{
   bool retval;

   switch (type)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
         retval = true;
         break;

      default:
         retval = false;
   }

   return retval;
}

PIASATTRIBUTE IASPeekAttribute(
                  IAttributesRaw* request,
                  DWORD dwId,
                  IASTYPE itType
                  ) throw ()
{
   if (request)
   {
      DWORD posCount = 1;
      ATTRIBUTEPOSITION pos;
      HRESULT hr = request->GetAttributes(&posCount, &pos, 1, &dwId);

      if (posCount == 1)
      {
         IASAttributeRelease(pos.pAttribute);

         if (SUCCEEDED(hr))
         {
            // There is some confusion between RAS and IAS regarding which
            // IASTYPEs to use for various RADIUS attributes, so we'll assume
            // any of the RADIUS integer types are interchangeable.
            if (itType == pos.pAttribute->Value.itType ||
                (isRadiusInteger(itType) &&
                 isRadiusInteger(pos.pAttribute->Value.itType)))
            {
               return pos.pAttribute;
            }
         }
      }
   }

   return NULL;
}

//////////
// End of utility classe.
//////////
#endif  // IASTLUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\iasutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasutil.cpp
//
// SYNOPSIS
//
//    This file implements assorted utility functions, etc.
//
// MODIFICATION HISTORY
//
//    11/14/1997    Original version.
//    08/11/1998    Major overhaul and consolidation of utility functions.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasapi.h>
#include <iasutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// String functions.
//
///////////////////////////////////////////////////////////////////////////////

// Duplicates a WSTR using new[].
PWSTR
WINAPI
ias_wcsdup(PCWSTR str)
{
   LPWSTR sz = NULL;

   if (str)
   {
      size_t len = wcslen(str) + 1;

      if (sz = new (std::nothrow) WCHAR[len])
      {
         memcpy(sz, str, len * sizeof(WCHAR));
      }
   }

   return sz;
}


// Duplicates a STR using CoTaskMemAlloc.
PSTR
WINAPI
com_strdup(PCSTR str)
{
   LPSTR sz = NULL;

   if (str)
   {
      size_t size = sizeof(CHAR) * (strlen(str) + 1);

      if (sz = (LPSTR)CoTaskMemAlloc(size))
      {
         memcpy(sz, str, size);
      }
   }

   return sz;
}


// Duplicates a WSTR using CoTaskMemAlloc.
PWSTR
WINAPI
com_wcsdup(PCWSTR str)
{
   LPWSTR sz = NULL;

   if (str)
   {
      size_t size = sizeof(WCHAR) * (wcslen(str) + 1);

      if (sz = (LPWSTR)CoTaskMemAlloc(size))
      {
         memcpy(sz, str, size);
      }
   }

   return sz;
}


// Compares two WSTR's allowing for null pointers.
INT
WINAPI
ias_wcscmp(PCWSTR str1, PCWSTR str2)
{
   if (str1 != NULL && str2 != NULL) return wcscmp(str1, str2);

   return str1 == str2 ? 0 : (str1 > str2 ? 1 : -1);
}


// Concatenate a null-terminated list of strings.
LPWSTR
WINAPIV
ias_makewcs(LPCWSTR str1, ...)
{
   size_t len = 0;

   //////////
   // Iterate through the arguments and calculate how much space we need.
   //////////

   va_list marker;
   va_start(marker, str1);
   LPCWSTR sz = str1;
   while (sz)
   {
      len += wcslen(sz);
      sz = va_arg(marker, LPCWSTR);
   }
   va_end(marker);

   // Add room for the null-terminator.
   ++len;

   //////////
   // Allocate memory to hold the concatentated string.
   //////////

   LPWSTR rv = new (std::nothrow) WCHAR[len];
   if (!rv) return NULL;

   // Initialize the string so wcscat will work.
   *rv = L'\0';

   //////////
   // Concatenate the strings.
   //////////

   va_start(marker, str1);
   sz = str1;
   while (sz)
   {
      wcscat(rv, sz);
      sz = va_arg(marker, LPCWSTR);
   }
   va_end(marker);

   return rv;
}

///////////////////////////////////////////////////////////////////////////////
//
// Functions to move integers to and from a buffer.
//
///////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
IASInsertDWORD(
    PBYTE pBuffer,
    DWORD dwValue
    )
{
   *pBuffer++ = (BYTE)((dwValue >> 24) & 0xFF);
   *pBuffer++ = (BYTE)((dwValue >> 16) & 0xFF);
   *pBuffer++ = (BYTE)((dwValue >>  8) & 0xFF);
   *pBuffer   = (BYTE)((dwValue      ) & 0xFF);
}

DWORD
WINAPI
IASExtractDWORD(
    CONST BYTE *pBuffer
    )
{
   return (DWORD)(pBuffer[0] << 24) | (DWORD)(pBuffer[1] << 16) |
          (DWORD)(pBuffer[2] <<  8) | (DWORD)(pBuffer[3]      );
}

VOID
WINAPI
IASInsertWORD(
    PBYTE pBuffer,
    WORD wValue
    )
{
   *pBuffer++ = (BYTE)((wValue >>  8) & 0xFF);
   *pBuffer   = (BYTE)((wValue      ) & 0xFF);
}

WORD
WINAPI
IASExtractWORD(
    CONST BYTE *pBuffer
    )
{
   return (WORD)(pBuffer[0] << 8) | (WORD)(pBuffer[1]);
}

///////////////////////////////////////////////////////////////////////////////
//
// Extensions to _com_error to handle Win32 errors.
//
///////////////////////////////////////////////////////////////////////////////

void __stdcall _w32_issue_error(DWORD errorCode) throw (_w32_error)
{
   throw _w32_error(errorCode);
}


namespace
{
   // Get the path to a database on the local computer.
   DWORD GetDatabasePath(
            const wchar_t* fileName,
            wchar_t* buffer,
            DWORD* size
            ) throw ()
   {
      // Value where the path to the IAS directory is stored.
      static const wchar_t productDirValue[] = L"ProductDir";

      if ((fileName == 0) || (buffer == 0) || (size == 0))
      {
         return ERROR_INVALID_PARAMETER;
      }

      // Initialize the out parameter.
      DWORD inSize = *size;
      *size = 0;

      // Open the registry key.
      LONG result;
      HKEY hKey;
      result = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   IAS_POLICY_KEY,
                   0,
                   KEY_READ,
                   &hKey
                   );
      if (result != NO_ERROR)
      {
         return result;
      }

      // Read the ProductDir value.
      DWORD dwType;
      DWORD cbData = inSize * sizeof(wchar_t);
      result = RegQueryValueExW(
                   hKey,
                   productDirValue,
                   0,
                   &dwType,
                   reinterpret_cast<BYTE*>(buffer),
                   &cbData
                   );

      // We're done with the registry key.
      RegCloseKey(hKey);

      // Compute the length of the full path in characters.
      DWORD outSize = (cbData / sizeof(WCHAR)) + wcslen(fileName);

      if (result != NO_ERROR)
      {
         // If we overflowed, return the needed size.
         if (result == ERROR_MORE_DATA)
         {
            *size = outSize;
         }

         return result;
      }

      // The registry value must contain a string.
      if (dwType != REG_SZ)
      {
         return REGDB_E_INVALIDVALUE;
      }

      // Do we have enough room to append the filename.
      if (outSize <= inSize)
      {
         wcscat(buffer, fileName);
      }
      else
      {
         result = ERROR_MORE_DATA;
      }

      // Return the size (whether actual or needed).
      *size = outSize;

      return result;
   }
}


DWORD
WINAPI
IASGetConfigPath(
   OUT PWSTR buffer,
   IN OUT PDWORD size
   )
{
   return GetDatabasePath(L"\\ias.mdb", buffer, size);
}


DWORD
WINAPI
IASGetDictionaryPath(
   OUT PWSTR buffer,
   IN OUT PDWORD size
   )
{
   return GetDatabasePath(L"\\dnary.mdb", buffer, size);
}


DWORD
WINAPI
IASGetProductLimitsForType(
   IN IAS_LICENSE_TYPE type,
   OUT IAS_PRODUCT_LIMITS* limits
   )
{
   static const IAS_PRODUCT_LIMITS workstationLimits =
   {
      0,
      FALSE,
      0
   };
   static const IAS_PRODUCT_LIMITS standardServerLimits =
   {
      50,
      FALSE,
      2
   };
   static const IAS_PRODUCT_LIMITS unlimitedServerLimits =
   {
      IAS_NO_LIMIT,
      TRUE,
      IAS_NO_LIMIT
   };

   if (limits == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   switch (type)
   {
      case IASLicenseTypeProfessional:
      case IASLicenseTypePersonal:
      {
         *limits = workstationLimits;
         break;
      }

      case IASLicenseTypeStandardServer:
      case IASLicenseTypeWebBlade:
      case IASLicenseTypeSmallBusinessServer:
      {
         *limits = standardServerLimits;
         break;
      }

      case IASLicenseTypeDownlevel:
      case IASLicenseTypeEnterpriseServer:
      case IASLicenseTypeDataCenter:
      {
         *limits = unlimitedServerLimits;
         break;
      }

      default:
      {
         return ERROR_INVALID_PARAMETER;
      }
   }

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\inet.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    inet.c
//
// SYNOPSIS
//
//    Implements the functions ias_inet_addr and ias_inet_ntoa.
//
// MODIFICATION HISTORY
//
//    09/17/1997    Original version.
//    02/04/1998    Added ias_inet_htow.
//    02/25/1998    Rewritten to use TCHAR macros.
//
///////////////////////////////////////////////////////////////////////////////

#include <tchar.h>

//////////
// Sentinel to indicate an invalid address.
//////////
#define INVALID_ADDRESS (0xFFFFFFFF)

//////////
// Macro to test if a character is a digit.
//////////
#define isdigit(p) ((_TUCHAR)(p - _T('0')) <= 9)

//////////
// Macro to strip whitespace characters
//////////
#define STRIP_WHITESPACE(p) \
   (p) += _tcsspn((p), _T(" \t"))

//////////
// Macro to strip one byte of an IP address from a character string.
//    'p'   pointer to the string to be parsed
//    'ul'  unsigned long that will receive the result.
//////////
#define STRIP_BYTE(p,ul) {                \
   if (!isdigit(*p)) goto error;          \
   ul = *p++ - _T('0');                   \
   if (isdigit(*p)) {                     \
      ul *= 10; ul += *p++ - _T('0');     \
      if (isdigit(*p)) {                  \
         ul *= 10; ul += *p++ - _T('0');  \
      }                                   \
   }                                      \
   if (ul > 0xff) goto error;             \
}

//////////
// Macro to strip a subnet width.
//    'p'   pointer to the string to be parsed
//    'ul'  unsigned long that will receive the result.
//////////
#define STRIP_WIDTH(p,ul) {                \
   if (!isdigit(*p)) goto error;          \
   ul = *p++ - _T('0');                   \
   if (isdigit(*p)) {                     \
      ul *= 10; ul += *p++ - _T('0');     \
   }                                      \
   if (ul > 32) goto error;             \
}

//////////
// Helper function to parse a dotted decimal address.
//////////
static unsigned long __stdcall StringToAddress(
                                  const _TCHAR* cp,
                                  const _TCHAR** endptr
                                  )
{
   unsigned long token;
   unsigned long addr;

   STRIP_WHITESPACE(cp);

   STRIP_BYTE(cp,addr);
   if (*cp++ != _T('.')) goto error;

   STRIP_BYTE(cp,token);
   if (*cp++ != _T('.')) goto error;
   addr <<= 8;
   addr  |= token;

   STRIP_BYTE(cp,token);
   if (*cp++ != _T('.')) goto error;
   addr <<= 8;
   addr  |= token;

   STRIP_BYTE(cp,token);
   addr <<= 8;
   addr  |= token;

   if (endptr) { *endptr = cp; }
   return addr;

error:
   if (endptr) { *endptr = cp; }
   return INVALID_ADDRESS;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    ias_inet_addr
//
// DESCRIPTION
//
//    This function is similar to the WinSock inet_addr function (q.v.) except
//    it returns the address in host order and it can operate on both ANSI
//    and UNICODE strings.
//
///////////////////////////////////////////////////////////////////////////////
unsigned long  __stdcall ias_inet_addr(const _TCHAR* cp)
{
   unsigned long address;
   const _TCHAR* end;

   address = StringToAddress(cp, &end);

   STRIP_WHITESPACE(end);

   return (*end == _T('\0')) ? address : INVALID_ADDRESS;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASStringToSubNet
//
// DESCRIPTION
//
//    Similar to ias_inet_addr except it also parses an optional subnet width.
//
///////////////////////////////////////////////////////////////////////////////
unsigned long __stdcall IASStringToSubNet(
                           const _TCHAR* cp,
                           unsigned long* widthptr
                           )
{
   unsigned long address, width;
   const _TCHAR* end;

   address = StringToAddress(cp, &end);

   if (*end == _T('/'))
   {
      ++end;
      STRIP_WIDTH(end,width);
   }
   else
   {
      width = 32;
   }

   STRIP_WHITESPACE(end);

   if (*end != _T('\0'))
   {
      goto error;
   }

   if (widthptr) { *widthptr = width; }

   return address;

error:
   return INVALID_ADDRESS;
}


int __stdcall IASIsStringSubNet(
                 const _TCHAR* cp
                 )
{
   unsigned long width;
   return (IASStringToSubNet(cp, &width) != INVALID_ADDRESS) && (width != 32);
}


//////////
// Macro to shove one byte of an IP address into a character string.
//    'p'   pointer to the destination string.
//    'ul'  value to be shoved.
//////////
#define SHOVE_BYTE(p, ul) {                  \
   *--p = _T('0') + (_TCHAR)(ul % 10);       \
   if (ul /= 10) {                           \
      *--p = _T('0') + (_TCHAR)(ul % 10);    \
      if (ul /= 10) {                        \
         *--p = _T('0') + (_TCHAR)(ul % 10); \
      }                                      \
   }                                         \
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    ias_inet_ntoa
//
// DESCRIPTION
//
//    This function uses the supplied buffer to convert a host order IPv4
//    network address to dotted-decimal format.
//
///////////////////////////////////////////////////////////////////////////////
_TCHAR* __stdcall ias_inet_ntoa(unsigned long addr, _TCHAR* dst)
{
   unsigned long token;
   _TCHAR buffer[16], *p;

   *(p = buffer + 15) = _T('\0');

   token = (addr      ) & 0xff;
   SHOVE_BYTE(p, token);
   *--p = _T('.');

   token = (addr >>  8) & 0xff;
   SHOVE_BYTE(p, token);
   *--p = _T('.');

   token = (addr >> 16) & 0xff;
   SHOVE_BYTE(p, token);
   *--p = _T('.');

   token = (addr >> 24) & 0xff;
   SHOVE_BYTE(p, token);

   return _tcscpy(dst, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\inet_addra.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the ANSI versions of the IP address helper functions.
//
///////////////////////////////////////////////////////////////////////////////

#ifdef _UNICODE
#undef _UNICODE 
#endif

#define ias_inet_addr ias_inet_atoh
#define ias_inet_ntoa ias_inet_htoa
#define IASStringToSubNet IASStringToSubNetA
#define IASIsStringSubNet IASIsStringSubNetA

#include <inet.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\inet_addrw.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the Unicode versions of the IP address helper functions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _UNICODE
#define _UNICODE
#endif

#define ias_inet_addr ias_inet_wtoh
#define ias_inet_ntoa ias_inet_htow
#define IASStringToSubNet IASStringToSubNetW
#define IASIsStringSubNet IASIsStringSubNetW

#include <inet.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\regex.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class RegularExpression.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <regex.h>
#include <re55.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    FastCoCreator
//
// DESCRIPTION
//
//    Wraps a class factory to allow instances of a particular coclass to
//    be created 'fast'.
//
///////////////////////////////////////////////////////////////////////////////
class FastCoCreator
{
public:
   FastCoCreator(REFCLSID rclsid, DWORD dwClsContext) throw ();
   ~FastCoCreator() throw ();

   HRESULT createInstance(
               LPUNKNOWN pUnkOuter,
               REFIID riid,
               LPVOID* ppv
               ) throw ();

   void destroyInstance(IUnknown* pUnk) throw ();

protected:
   REFCLSID clsid;
   DWORD context;
   CRITICAL_SECTION monitor;
   ULONG refCount;
   IClassFactory* factory;

private:
   FastCoCreator(FastCoCreator&) throw ();
   FastCoCreator& operator=(FastCoCreator&) throw ();
};

FastCoCreator::FastCoCreator(REFCLSID rclsid, DWORD dwClsContext)
   : clsid(rclsid),
     context(dwClsContext),
     refCount(0),
     factory(NULL)
{
   InitializeCriticalSection(&monitor);
}

FastCoCreator::~FastCoCreator() throw ()
{
   if (factory) { factory->Release(); }

   DeleteCriticalSection(&monitor);
}

HRESULT FastCoCreator::createInstance(
                        LPUNKNOWN pUnkOuter,
                        REFIID riid,
                        LPVOID* ppv
                        ) throw ()
{
   HRESULT hr;

   EnterCriticalSection(&monitor);

   // Get a new class factory if necessary.
   if (!factory)
   {
      hr = CoGetClassObject(
               clsid,
               context,
               NULL,
               __uuidof(IClassFactory),
               (PVOID*)&factory
               );
   }

   if (factory)
   {
      hr = factory->CreateInstance(
                           pUnkOuter,
                           riid,
                           ppv
                           );
      if (SUCCEEDED(hr))
      {
         // We successfully created an object, so bump the ref. count.
         ++refCount;
      }
      else if (refCount == 0)
      {
         // Don't hang on to the factory if the ref. count is zero.
         factory->Release();
         factory = NULL;
      }
   }

   LeaveCriticalSection(&monitor);

   return hr;
}

void FastCoCreator::destroyInstance(IUnknown* pUnk) throw ()
{
   if (pUnk)
   {
      EnterCriticalSection(&monitor);

      if (--refCount == 0)
      {
         // Last object went away, so release the class factory.
         factory->Release();
         factory = NULL;
      }

      LeaveCriticalSection(&monitor);

      pUnk->Release();
   }
}

/////////
// Macro that ensures the internal RegExp object has been initalize.
/////////
#define CHECK_INIT() \
{ HRESULT hr = checkInit(); if (FAILED(hr)) { return hr; }}

FastCoCreator RegularExpression::theCreator(
                                     __uuidof(RegExp),
                                     CLSCTX_INPROC_SERVER
                                     );

RegularExpression::RegularExpression() throw ()
   : regex(NULL)
{ }

RegularExpression::~RegularExpression() throw ()
{
   theCreator.destroyInstance(regex);
}

HRESULT RegularExpression::setIgnoreCase(BOOL fIgnoreCase) throw ()
{
   CHECK_INIT();
   return regex->put_IgnoreCase(fIgnoreCase ? VARIANT_TRUE : VARIANT_FALSE);
}

HRESULT RegularExpression::setGlobal(BOOL fGlobal) throw ()
{
   CHECK_INIT();
   return regex->put_Global(fGlobal ? VARIANT_TRUE : VARIANT_FALSE);
}

HRESULT RegularExpression::setPattern(PCWSTR pszPattern) throw ()
{
   CHECK_INIT();

   HRESULT hr;
   BSTR bstr = SysAllocString(pszPattern);
   if (bstr)
   {
      hr = regex->put_Pattern(bstr);
      SysFreeString(bstr);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}

HRESULT RegularExpression::replace(
                               BSTR sourceString,
                               BSTR replaceString,
                               BSTR* pDestString
                               ) const throw ()
{
   VARIANT replace;

#ifdef _X86_
   // The VB team accidentally released a version of IRegExp2 where the second
   // parameter was a VARIANT* instead of a VARIANT. As a result, they attempt
   // to detect at run-time which version of the interface was called. They do
   // this by calling IsBadReadPtr, which in turn generates an AV. To avoid
   // these undesirable breaks, we make sure that the first two 32-bits of the
   // VARIANT are valid pointer addresses. Since the parameters will look valid
   // for both the good and the bad version, VB defaults to the good version --
   // which is what we want. This bug only exists on x86, hence the ifdef.

   // The dummy variable is used to generate a readable address.
   static const void* dummy = 0;

   const void** p = reinterpret_cast<const void**>(&replace);
   p[0] = &dummy;  // The VARIANT*
   p[1] = &dummy;  // The BSTR*
#endif

   V_VT(&replace) = VT_BSTR;
   V_BSTR(&replace) = replaceString;

   return regex->Replace(sourceString, replace, pDestString);
}

BOOL RegularExpression::testBSTR(BSTR sourceString) const throw ()
{
   // Test the regular expression.
   VARIANT_BOOL fMatch = VARIANT_FALSE;
   regex->Test(sourceString, &fMatch);
   return fMatch;
}

BOOL RegularExpression::testString(PCWSTR sourceString) const throw ()
{
   // ByteLen of the BSTR.
   DWORD nbyte = wcslen(sourceString) * sizeof(WCHAR);

   // We need room for the string, the ByteLen, and the null-terminator.
   PDWORD p = (PDWORD)_alloca(nbyte + sizeof(DWORD) + sizeof(WCHAR));

   // Store the ByteLen.
   *p++ = nbyte;

   // Copy in the sourceString.
   memcpy(p, sourceString, nbyte + sizeof(WCHAR));

   // Test the regular expression.
   VARIANT_BOOL fMatch = VARIANT_FALSE;
   regex->Test((BSTR)p, &fMatch);

   return fMatch;
}

void RegularExpression::swap(RegularExpression& obj) throw ()
{
   IRegExp2* tmp = obj.regex;
   obj.regex = regex;
   regex = tmp;
}

HRESULT RegularExpression::checkInit() throw ()
{
   // Have we already initialized?
   return regex ? S_OK : theCreator.createInstance(
                                        NULL,
                                        __uuidof(IRegExp2),
                                        (PVOID*)&regex
                                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\perimeter.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Perimeter.cpp
//
// SYNOPSIS
//
//    This file implements the class Perimeter.
//
// MODIFICATION HISTORY
//
//    09/04/1997    Original version.
//    09/30/1998    Fix bug with recursive LockExclusive calls.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <climits>
#include <Perimeter.h>

//////////
//  Large negative value used to block shared entry into the perimeter.
//////////
const LONG BLOCK_VALUE = (-LONG_MAX)/2;

Perimeter::Perimeter() throw ()
   : sharing(0),
     waiting(0),
     count(&sharing),
     exclusiveInitialized(false),
     sharedOK(0),
     exclusiveOK(0)
{
}

Perimeter::~Perimeter() throw ()
{
   if (exclusiveOK != 0)
   {
      CloseHandle(exclusiveOK);
   }

   if (sharedOK != 0)
   {
      CloseHandle(sharedOK);
   }

   if (exclusiveInitialized)
   {
      DeleteCriticalSection(&exclusive);
   }
}


HRESULT Perimeter::FinalConstruct() throw ()
{
   if (!InitializeCriticalSectionAndSpinCount(&exclusive, 0))
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }
   exclusiveInitialized = true;

   sharedOK = CreateSemaphore(NULL, 0, LONG_MAX, NULL);
   if (sharedOK == 0)
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   exclusiveOK = CreateSemaphore(NULL, 0, 1, NULL);
   if (exclusiveOK == 0)
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   return S_OK;
}


void Perimeter::Lock() throw ()
{
   // If this is less than zero, then an exlusive thread must have inserted
   // the BLOCK_VALUE, so ...
   if (InterlockedIncrement(count) <= 0)
   {
      // ... we have to wait until he's done.
      WaitForSingleObject(sharedOK, INFINITE);
   }
}

void Perimeter::LockExclusive() throw ()
{
   // This limits exclusive access to a single thread.
   EnterCriticalSection(&exclusive);

   // The first time through we have to wait for the sharers to finish.
   if (exclusive.RecursionCount == 1)
   {
      // Block any new shared threads.
      waiting = BLOCK_VALUE;
      InterlockedExchangePointer((PVOID *)&count, &waiting);

      // Find out how many shared threads are already in the perimeter ...
      LONG sharingNow = InterlockedExchangeAdd(&sharing, BLOCK_VALUE);

      if (sharingNow > 0)
      {
         // ... and wait until they're done.
         WaitForSingleObject(exclusiveOK, INFINITE);
      }

      // At this point there is no one left inside the perimeter.
      sharing = 0;
   }
}

void Perimeter::Unlock() throw ()
{
   // If sharing is zero, we must be an exclusive thread.
   if (!sharing)
   {
      // Are we about to release our last lock ?
      if (exclusive.RecursionCount == 1)
      {
         // Allow any new shared access attempts.
         InterlockedExchangePointer((PVOID *)&count, &sharing);

         // Find out how many threads are waiting on the semaphore ...
         LONG waitingNow = waiting - BLOCK_VALUE;

         if (waitingNow > 0)
         {
            // ... and let them go.
            InterlockedExchangeAdd(count, waitingNow);
            ReleaseSemaphore(sharedOK, waitingNow, NULL);
         }
      }

      // Release the exclusive lock.
      LeaveCriticalSection(&exclusive);
   }
   else if (InterlockedDecrement(&sharing) == BLOCK_VALUE)
   {
      // If we end up here, we must have been the last shared thread out of
      // the perimeter while an exlusive thread is waiting, so wake him up.
      ReleaseSemaphore(exclusiveOK, 1, NULL) ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\portparser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class CPortParser.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "iasutil.h"
#include "winsock2.h"
#include "portparser.h"
#include <cwchar>


HRESULT CPortParser::GetIPAddress(DWORD* ipAddress) throw ()
{
   if (ipAddress == 0)
   {
      return E_POINTER;
   }

   // If we're at the end of the string, there's no more interfaces.
   if (*next == L'\0')
   {
      return S_FALSE;
   }

   // Find the end of the IP address.
   const wchar_t* end = wcschr(next, addressPortDelim);
   if (end != 0)
   {
      // Compute the length of the address token.
      size_t nChar = end - next;
      if (nChar > maxAddrStrLen)
      {
         return E_INVALIDARG;
      }

      // Make a null-terminated copy of the address token.
      wchar_t addrStr[maxAddrStrLen + 1];
      wmemcpy(addrStr, next, nChar);
      addrStr[nChar] = L'\0';

      // Convert to a network order integer.
      *ipAddress = htonl(ias_inet_wtoh(addrStr));

      // Was the conversion successful.
      if (*ipAddress == INADDR_NONE)
      {
         return E_INVALIDARG;
      }

      // Position the cursor right after the delimiter.
      next = end + 1;
   }
   else
   {
      // No end, thus no IP address. Defaults to INADDR_ANY.
      *ipAddress = INADDR_ANY;
   }

   // The cursor should be positioned on the first port.
   if (!iswdigit(*next))
   {
      return E_INVALIDARG;
   }

   return S_OK;
}


HRESULT CPortParser::GetNextPort(WORD* port) throw ()
{
   if (port == 0)
   {
      return E_POINTER;
   }

   // If we're at the end of the string, there's no more ports.
   if (*next == L'\0')
   {
      return S_FALSE;
   }

   // Are we at the end of the interface?
   if (*next == interfaceDelim)
   {
      // Skip past the interface delimiter.
      ++next;

      // The cursor should be positioned on an address or a port; either way it
      // has to be a digit.
      return iswdigit(*next) ? S_FALSE : E_INVALIDARG;
   }

   // Convert the port number.
   const wchar_t* end;
   unsigned long value = wcstoul(next, const_cast<wchar_t**>(&end), 10);

   // Make sure we converted something and it's in range.
   if ((end == next) || (value < minPortValue) || (value > maxPortValue))
   {
      return E_INVALIDARG;
   }

   // Set the cursor to just after the port number.
   next = end;

   // Is there another port?
   if (*next == portDelim)
   {
      // Yes, so advance to the next one.
      ++next;

      // Must be a digit.
      if (!iswdigit(*next))
      {
         return E_INVALIDARG;
      }
   }
   // No more ports, so we should either be at the end of the interface or the
   // end of the string.
   else if ((*next != interfaceDelim) && (*next != L'\0'))
   {
      return E_INVALIDARG;
   }

   *port = static_cast<WORD>(value);

   return S_OK;
}


size_t CPortParser::CountPorts(const wchar_t* portString) throw ()
{
   if (portString == 0)
   {
      return 0;
   }

   CPortParser parser(portString);

   // There must be at least one IP address.
   DWORD ipAddr;
   HRESULT hr = parser.GetIPAddress(&ipAddr);
   if (hr != S_OK)
   {
      return 0;
   }

   size_t count = 0;

   do
   {
      // There must be at least one port per IP address.
      WORD port;
      hr = parser.GetNextPort(&port);
      if (hr != S_OK)
      {
         return 0;
      }

      ++count;

      // Get the remaining ports (if any).
      do
      {
         hr = parser.GetNextPort(&port);
         if (FAILED(hr))
         {
            return 0;
         }

         ++count;
      }
      while (hr == S_OK);

      // Get the next IP address (if any).
      hr = parser.GetIPAddress(&ipAddr);
      if (FAILED(hr))
      {
         return 0;
      }

   } while (hr == S_OK);

   return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\ias\iascontrol.cpp ===
//##--------------------------------------------------------------
//        
//  File:		iascontrol.cpp
//        
//  Synopsis:   Implementation of CIasControl methods
//              The class object controls the initialization,
//              shutdown and configuration of the IAS Service
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#include <ias.h>
#include "iascontrol.h"

//
// The ProgID of the ISdoService implementation.
//
const wchar_t SERVICE_PROG_ID[] = IAS_PROGID(SdoService);

//++--------------------------------------------------------------
//
//  Function:   InitializeIas
//
//  Synopsis:   This is the public method which initializes the
//              IAS service
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     09/04/98
//
//----------------------------------------------------------------
HRESULT 
CIasControl::InitializeIas (
                VOID
                )
{
    HRESULT hr = S_OK;

    __try
    {
        ::EnterCriticalSection (&m_CritSect);

        //
        // Lookup the Prog ID in the registry.
        //
        CLSID clsid;
        hr = ::CLSIDFromProgID(SERVICE_PROG_ID, &clsid);
        if (FAILED(hr)) 
        { 
            __leave;
        }

        //
        // Create the service object.
        //
        hr = ::CoCreateInstance(clsid,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         __uuidof(ISdoService),
                         (PVOID*)&m_pService);
        if (FAILED(hr)) 
        { 
            __leave;
        }

        //
        // Initialize the service.
        //
        hr = m_pService->InitializeService(SERVICE_TYPE_IAS);
        if (FAILED(hr)) 
        { 
            __leave;
        }

        //
        //  start the service now
        //
        hr = m_pService->StartService(SERVICE_TYPE_IAS);
        if (FAILED(hr)) 
        { 
            m_pService->ShutdownService (SERVICE_TYPE_IAS);
            __leave;
        }
    }
    __finally
    {
        if ((FAILED (hr)) && (NULL != m_pService))
        {
            //
            // cleanup on failure
            //
            m_pService->Release ();
            m_pService = NULL;
        }
    
        ::LeaveCriticalSection (&m_CritSect);
    }

    return (hr);

}   //  end of CIasControl::InitializeIas method

//++--------------------------------------------------------------
//
//  Function:   ShutdownIas
//
//  Synopsis:   This is the public method which shutdwon of the
//              IAS service
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     09/04/98
//
//----------------------------------------------------------------
HRESULT 
CIasControl::ShutdownIas (  
                VOID
                )
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection (&m_CritSect);

    if (NULL != m_pService)
    {
        //
        // stop the service
        //
        hr = m_pService->StopService (SERVICE_TYPE_IAS);
        if (SUCCEEDED (hr))
        {
            //
            // stop the service
            //
            hr = m_pService->ShutdownService(SERVICE_TYPE_IAS);
        }

        //
        // cleanup
        //
        m_pService->Release();
        m_pService = NULL;
    }

    ::LeaveCriticalSection (&m_CritSect);

    return (hr);

}   //  end of CIasControl::ShutdownIas method

//++--------------------------------------------------------------
//
//  Function:   Configure
//
//  Synopsis:   This is the public method which configure the
//              IAS service
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     09/04/98
//
//----------------------------------------------------------------
HRESULT CIasControl::ConfigureIas (VOID)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection (&m_CritSect);

    if (NULL != m_pService)
    {
        //
        // configure the service now
        //
        hr = m_pService->ConfigureService (SERVICE_TYPE_IAS);
    }
    ::LeaveCriticalSection (&m_CritSect);

    return (hr);

}   // end of CIasControl::ConfigureIas method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\ias\ias.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ias.cpp
//
// SYNOPSIS
//
//    This file contains the DLL entry points for the IAS service.
//
// MODIFICATION HISTORY
//
//    04/09/1998    Original version.
//    04/15/1998    Converted to svchost spec.
//    05/01/1998    Move inside the netsvcs instance of svchost.
//    05/06/1998    Change ServiceDll value to REG_EXPAND_SZ.
//    06/02/1998    Report SERVICE_RUNNING before starting service.
//    06/29/1998    Set SERVICE_INTERACTIVE_PROCESS flag.
//    09/04/1998    MKarki -  changes for dynamic configuration
//    10/13/1998    TLP - log start/stop service
//    02/11/1999    Remove service registration code.
//    04/23/1999    Don't log start/stop.
//    07/02/1999    Register in the Active Directory
//    05/12/2000    General clean-up.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef UNICODE
   #define UNICODE
#endif

#include <windows.h>
#include <atlbase.h>
#include <iasdefs.h>
#include <iasevent.h>
#include "iascontrol.h"
#include "iasdirectory.h"

// Service  control ID for dynamic configuration
const DWORD IAS_CONTROL_CONFIGURE = 128;

// Timeout for the thread after the service's stop
const DWORD IAS_WAIT_DIRECTORY_TIME = 10000;

// Handle to SdoService object
CIasControl g_iasControl;

// Event used to signal the service to stop.
HANDLE theStopEvent = NULL;

// Used for communicating status to the SCM.
SERVICE_STATUS_HANDLE theStatusHandle = NULL;
SERVICE_STATUS theStatus =
{
   SERVICE_WIN32_OWN_PROCESS, // dwServiceType;
   SERVICE_STOPPED,           // dwCurrentState;
   SERVICE_ACCEPT_STOP |
   SERVICE_ACCEPT_SHUTDOWN,   // dwControlsAccepted;
   NO_ERROR,                  // dwWin32ExitCode;
   0,                         // dwServiceSpecificExitCode;
   0,                         // dwCheckPoint;
   0                          // dwWaitHint;
};

//////////
// Notify the SCM of a change in state.
//////////
void changeState(DWORD newState) throw ()
{
   theStatus.dwCurrentState = newState;

   SetServiceStatus(theStatusHandle, &theStatus);
}

//////////
// Service control handler.
//////////
VOID
WINAPI
ServiceHandler(
    DWORD fdwControl   // requested control code
    )
{
   if (fdwControl == SERVICE_CONTROL_STOP ||
       fdwControl == SERVICE_CONTROL_SHUTDOWN)
   {
      SetEvent(theStopEvent);
   }
   else if (fdwControl == IAS_CONTROL_CONFIGURE)
   {
      g_iasControl.ConfigureIas();
   }
}

//////////
// Service Main.
//////////
VOID
WINAPI
ServiceMain(
    DWORD /* dwArgc */,
    LPWSTR* /* lpszArgv */
    )
{
    // Reset the stop event and the exit code since this may not be the first
    // time ServiceMain was called.
    ResetEvent(theStopEvent);
    theStatus.dwWin32ExitCode = NO_ERROR;

    // Register the control request handler
    theStatusHandle = RegisterServiceCtrlHandlerW(
                          IASServiceName,
                          ServiceHandler
                          );

    // Report that we're running even though we haven't started yet. This gets
    // around any long delays starting (due to network problems, etc.).
    changeState(SERVICE_RUNNING);

    // Spawn a thread to register the service in the Active Directory
    HANDLE dirThread = CreateThread(
                           NULL,
                           0,
                           IASDirectoryThreadFunction,
                           NULL,
                           0,
                           NULL
                           );

    // Initialize the COM runtime.
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
       // Intialize IAS Service
       hr = g_iasControl.InitializeIas();
       if (SUCCEEDED(hr))
       {
           // Wait until someone tells us to stop.
           WaitForSingleObject(theStopEvent, INFINITE);

           // Update our state and stop the service.
           changeState(SERVICE_STOP_PENDING);
           g_iasControl.ShutdownIas();
       }
       else
       {
          theStatus.dwWin32ExitCode = hr;
       }

       // Shutdown the COM runtime.
       CoUninitialize();
    }
    else
    {
       theStatus.dwWin32ExitCode = hr;
    }

    // We'll use the last error (if any) as the exit code.
    changeState(SERVICE_STOPPED);
    theStatusHandle = NULL;

    // Wait for the directory thread to finish.
    if (dirThread)
    {
        WaitForSingleObject(dirThread, IAS_WAIT_DIRECTORY_TIME);
        CloseHandle(dirThread);
    }
}

//////////
// DLL entry point.
//////////
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      // Create the stop event.
      theStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
      if (theStopEvent == NULL) { return FALSE; }

      DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      CloseHandle(theStopEvent);
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\services\util\tracex.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    tracex.cpp
//
// SYNOPSIS
//
//    Defines the C++ portion of the trace API.
//
// MODIFICATION HISTORY
//
//    08/20/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <exception>

//////////
// We want this to compile correctly in a retail build.
//////////

#ifdef IASTraceExcept
#undef IASTraceExcept
#endif

#ifdef IASTracePrintf
#undef IASTracePrintf
#endif

#ifdef IASTraceString
#undef IASTraceString
#endif

VOID
WINAPIV
IASTracePrintf(
    IN PCSTR szFormat,
    ...
    );

VOID
WINAPI
IASTraceString(
    IN PCSTR szString
    );

VOID
WINAPI
IASTraceExcept( VOID )
{
   try
   {
      throw;
   }
   catch (const std::exception& x)
   {
      IASTracePrintf("Caught standard exception: %s", x.what());
   }
   catch (const _com_error& ce)
   {
      CHAR szMessage[256];
      DWORD nChar = IASFormatSysErr(
                        ce.Error(),
                        szMessage,
                        sizeof(szMessage)
                        );
      szMessage[nChar] = '\0';

      IASTracePrintf("Caught COM exception: %s", szMessage);
   }
   catch (...)
   {
      IASTraceString("Caught unknown exception");
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\ias\iascontrol.h ===
//#--------------------------------------------------------------
//        
//  File:       iascontrol.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CIasControl class
//              
//
//  History:     09/04/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _IASCONTROL_H_
#define _IASCONTROL_H_

#include <sdoias.h>
#include "sdoiaspriv.h"

class CIasControl
{

public:

    //
    // constructor
    //
    CIasControl (VOID):m_pService (NULL)
    {::InitializeCriticalSection (&m_CritSect);}

    //
    // destructor 
    //
    ~CIasControl (VOID)
    {
        ::EnterCriticalSection (&m_CritSect);
        ::DeleteCriticalSection(&m_CritSect);
    }

    //
    // start the IAS service
    //
    HRESULT InitializeIas (VOID);

    //
    // shutdown the IAS service
    //
    HRESULT ShutdownIas (VOID);

    //
    //  configure the IAS service
    //
    HRESULT ConfigureIas (VOID);

private:

    //
    // holds reference to SdoService object
    //
    ISdoService         *m_pService;

    //
    // restricts access to SdoService object
    //
    CRITICAL_SECTION    m_CritSect;
};

#endif // ifndef _IASCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\acctmib.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    acctmib.h
//
// SYNOPSIS
//
//    Declares the class AcctServMIB.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ACCTMIB_H_
#define _ACCTMIB_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <snmpoid.h>

///////////////////////////////////////////////////////////////////////////////
//
// NAMESPACE
//
//    AcctServMIB
//
// DESCRIPTION
//
//    Implements the RADIUS Accounting Server MIB.
//
///////////////////////////////////////////////////////////////////////////////
namespace AcctServMIB
{
   bool canGetSet(const SnmpOid& name) throw ();
   bool canGetNext(const SnmpOid& name) throw ();

   AsnInteger32 get(
                    const SnmpOid& name,
                    AsnAny* value
                    );

   AsnInteger32 getNext(
                    SnmpOid& name,
                    AsnAny* value
                    );

   AsnInteger32 set(
                    const SnmpOid& name,
                    AsnAny* value
                    );
};

#endif  //  _ACCTMIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\acctmib.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    acctmib.cpp
//
// SYNOPSIS
//
//    Defines the class AcctServMIB.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//    05/26/1999    Fix bug calling GetAcctClientLeaf.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <snmputil.h>
#include <stats.h>
#include <acctmib.h>

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    GetAcctServerLeaf
//
// DESCRIPION
//
//    Computes the value of a server leaf.
//
///////////////////////////////////////////////////////////////////////////////
AsnInteger32
WINAPI
GetAcctServerLeaf(
    IN UINT leaf,
    OUT AsnAny* value
    )
{
   switch (leaf)
   {
      case  1:
         GetServerIdentity(value);
         break;

      case  2:
         GetServerUpTime(value);
         break;

      case  3:
         GetServerResetTime(value);
         break;

      case  4:
         GetServerConfigReset(value);
         break;

      case  5:
         GetTotalCounter(radiusAccServRequests, value);
         break;

      case  6:
         GetServerCounter(radiusAccServTotalInvalidRequests, value);
         break;

      case  7:
         GetTotalCounter(radiusAccServDupRequests, value);
         break;

      case  8:
         GetTotalCounter(radiusAccServResponses, value);
         break;

      case  9:
         GetTotalCounter(radiusAccServMalformedRequests, value);
         break;

      case 10:
         GetTotalCounter(radiusAccServBadAuthenticators, value);
         break;

      case 11:
         GetTotalCounter(radiusAccServPacketsDropped, value);
         break;

      case 12:
         GetTotalCounter(radiusAccServNoRecord, value);
         break;

      case 13:
         GetTotalCounter(radiusAccServUnknownType, value);
         break;

      case 14:
         return SNMP_ERRORSTATUS_NOACCESS;

      default:
         return SNMP_ERRORSTATUS_NOSUCHNAME;
   }

   return SNMP_ERRORSTATUS_NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    GetAcctClientLeaf
//
// DESCRIPION
//
//    Computes the value of a client leaf.
//
///////////////////////////////////////////////////////////////////////////////
AsnInteger32
WINAPI
GetAcctClientLeaf(
    UINT client,
    UINT leaf,
    AsnAny* value
    )
{
   // SNMP indices start from 1, but C++ indices start from 0.
   --client;

   switch (leaf)
   {
      case  1:
         return SNMP_ERRORSTATUS_NOACCESS;

      case  2:
         GetClientAddress(client, value);
         break;

      case  3:
         GetClientIdentity(client, value);
         break;

      case  4:
         GetClientCounter(client, radiusAccServPacketsDropped, value);
         break;

      case  5:
         GetClientCounter(client, radiusAccServRequests, value);
         break;

      case  6:
         GetClientCounter(client, radiusAccServDupRequests, value);
         break;

      case  7:
         GetClientCounter(client, radiusAccServResponses, value);
         break;

      case  8:
         GetClientCounter(client, radiusAccServBadAuthenticators, value);
         break;

      case  9:
         GetClientCounter(client, radiusAccServMalformedRequests, value);
         break;

      case 10:
         GetClientCounter(client, radiusAccServNoRecord, value);
         break;

      case 11:
         GetClientCounter(client, radiusAccServUnknownType, value);
         break;

      default:
         return SNMP_ERRORSTATUS_NOSUCHNAME;
   }

   return SNMP_ERRORSTATUS_NOERROR;
}

//////////
// OID definitions.
//////////
#define OID_radiusAccounting         OID_radiusMIB,2
#define OID_radiusAccServMIB         OID_radiusAccounting,1
#define OID_radiusAccServMIBObjects  OID_radiusAccServMIB,1
#define OID_radiusAccServ            OID_radiusAccServMIBObjects,1
#define OID_radiusAccClientTable     OID_radiusAccServ,14

namespace {

//////////
// ID arrays.
//////////
UINT IDS_serverNode[]      = { OID_radiusAccServ               };
UINT IDS_firstServerLeaf[] = { OID_radiusAccServ,  1           };
UINT IDS_lastServerLeaf[]  = { OID_radiusAccServ, 13           };
UINT IDS_clientNode[]      = { OID_radiusAccClientTable        };
UINT IDS_firstClientLeaf[] = { OID_radiusAccClientTable, 1,  2 };
UINT IDS_lastClientLeaf[]  = { OID_radiusAccClientTable, 1, 11 };
UINT IDS_configReset[]     = { OID_radiusAccServ, 4            };

//////////
// AsnObjectIdentifiers.
//////////
AsnObjectIdentifier serverNode      = DEFINE_OID(IDS_serverNode);
AsnObjectIdentifier firstServerLeaf = DEFINE_OID(IDS_firstServerLeaf);
AsnObjectIdentifier lastServerLeaf  = DEFINE_OID(IDS_lastServerLeaf);

AsnObjectIdentifier clientNode      = DEFINE_OID(IDS_clientNode);
AsnObjectIdentifier firstClientLeaf = DEFINE_OID(IDS_firstClientLeaf);
AsnObjectIdentifier lastClientLeaf  = DEFINE_OID(IDS_lastClientLeaf);

AsnObjectIdentifier configReset     = DEFINE_OID(IDS_configReset);

//////////
// Lengths of valid leaf OID's.
//////////
const UINT serverLength = DEFINE_SIZEOF(IDS_firstServerLeaf);
const UINT clientLength = DEFINE_SIZEOF(IDS_firstClientLeaf);

}

bool AcctServMIB::canGetSet(const SnmpOid& name) throw ()
{
   return name.isChildOf(serverNode);
}

bool AcctServMIB::canGetNext(const SnmpOid& name) throw ()
{
   if (theStats->dwNumClients)
   {
      // Update the last client leaf. This is the highest OID we support.
      lastClientLeaf.ids[clientLength - 2] = theStats->dwNumClients;

      return name < lastClientLeaf;
   }

   return name < lastServerLeaf;
}

AsnInteger32 AcctServMIB::get(
                              const SnmpOid& name,
                              AsnAny* value
                              )
{
   // Is it a client leaf ?
   if (name.isChildOf(clientNode))
   {
      if (name.length() == clientLength)
      {
         return GetAcctClientLeaf(
                    name.id(1),
                    name.id(0),
                    value
                    );
      }
   }

   // Is it a server leaf ?
   else if (name.length() == serverLength)
   {
      return GetAcctServerLeaf(
                 name.id(0),
                 value
                 );
   }

   return SNMP_ERRORSTATUS_NOSUCHNAME;
}

AsnInteger32 AcctServMIB::getNext(
                              SnmpOid& name,
                              AsnAny* value
                              )
{
   if (name < firstServerLeaf)
   {
      name = firstServerLeaf;

      return GetAcctServerLeaf(
                 name.id(0),
                 value
                 );
   }

   if (name < lastServerLeaf)
   {
      // We're in the middle of the server leaves, so just advance
      // to the next one.
      name.resize(serverLength);
      ++name.id(0);

      return GetAcctServerLeaf(
                 name.id(0),
                 value
                 );
   }

   if (name < firstClientLeaf)
   {
      name = firstClientLeaf;

      return GetAcctClientLeaf(
                 name.id(1),
                 name.id(0),
                 value
                 );
   }

   /////////
   // If we made it here, we're in the middle of the client leaves.
   /////////

   name.resize(clientLength);

   if (name.id(0) < 2)
   {
      name.id(0) = 2;
   }
   else if (++name.id(0) > 11)
   {
      name.id(0) = 2;

      // We wrapped around to the next client.
      ++name.id(1);
   }

   return GetAcctClientLeaf(
              name.id(1),
              name.id(0),
              value
              );
}

AsnInteger32 AcctServMIB::set(
                             const SnmpOid& name,
                             AsnAny* value
                             )
{
   if (name == configReset)
   {
      return SetServerConfigReset(value);
   }

   return SNMP_ERRORSTATUS_READONLY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\ias\iasdirectory.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdirectory.h
//
// SYNOPSIS
//
//    Include file for the iasdirectory.cpp
//
// MODIFICATION HISTORY
//
//    06/25/1999    Original version.
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(IAS_DIRECTORY_H__F563CFCA_F5FA_4d87_89E3_7D7CD9B9A534__INCLUDED_)
#define IAS_DIRECTORY__F563CFCA_F5FA_4d87_89E3_7D7CD9B9A534__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

  
//
// Functions exported by ias.dll
//

HRESULT WINAPI IASDirectoryRegisterService();
HRESULT WINAPI IASDirectoryUnregisterService();

//
// Directory Thread Function
//
DWORD WINAPI IASDirectoryThreadFunction( LPVOID pParam );
          

#endif 
// !defined(IAS_DIRECTORY_H__F563CFCA_F5FA_4d87_89E3_7D7CD9B9A534__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\ias\iasdirectory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasdirectory.cpp
//
// SYNOPSIS
//
//    Add IAS to the Active Directory 
//    Remove IAS from the Active Directory
//
// REMARKS
//    CN=IASIdentity under the local Computer Object
//    class = serviceAdministrationPoint
//    simple implementation. 
//
//
// MODIFICATION HISTORY
//
//    06/25/1999    Original version.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _WIN32_WINNT
    #define _WIN32_WINNT 0x0500
#endif

#ifndef UNICODE
    #define UNICODE
#endif

#ifndef _UNICODE
    #define _UNICODE
#endif

#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
//#include <wchar.h>

#ifndef SECURITY_WIN32
    #define SECURITY_WIN32 // Required by Security.h
#endif

#include <security.h>
#include <activeds.h>

#include <dsrole.h>
#include <lmcons.h>   // For lmapibuf.h
#include <lmerr.h>
#include <lmapibuf.h> // For NetApiBufferFree
#include <malloc.h>   // For _alloca

#include "iasdirectory.h"

const WCHAR  IAS_DIRECTORY_NAME[] = L"cn=IASIdentity";

               
//////////////////////////////////////////////////////////////////////////////
//
// IASDirectoryThreadFunction
// try to register the service
//
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
IASDirectoryThreadFunction( LPVOID pParam )
{
    if ( !FAILED(CoInitialize(NULL)) )
    {
        if ( FAILED(IASDirectoryRegisterService()) )
        {
            CoUninitialize();
            return 1;
        }
        else
        {
            // Success
            CoUninitialize();
            return 0;
        }
    }
    else
    {
        return 1;
    }
}
               
               
//////////////////////////////////////////////////////////////////////////////
//
// hasDirectory
// Returns TRUE if the Active Directory is available.
//
//////////////////////////////////////////////////////////////////////////////
BOOL    hasDirectory() throw ()
{
    // Initialized to false because DsRoleGet... can fail
    BOOL    bResult = FALSE; 

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC info;
    DWORD error = DsRoleGetPrimaryDomainInformation(
                        NULL,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE*)&info
                        );

    if (error == NO_ERROR)
    {
        switch (info->MachineRole)
        {
            case DsRole_RoleMemberWorkstation:
            case DsRole_RoleMemberServer:
            case DsRole_RoleBackupDomainController:
            case DsRole_RolePrimaryDomainController:
            {
                bResult = TRUE;
                break;
            }
            
            case DsRole_RoleStandaloneWorkstation:
            case DsRole_RoleStandaloneServer:
            default:
            {
                //
                // don't try to use Active Directory if unknown
                // or not a  member of a domain
                // i.e. bResult still FALSE
                //
            }
        }
        NetApiBufferFree(info);
    }
    return  bResult;
}


//////////////////////////////////////////////////////////////////////////////
//
// IASRegisterService
//
// Create a new Service Administration Point as a child of the local server's
// Computer object
//
//////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
IASDirectoryRegisterService()
{
    if (!hasDirectory())
    {
        ////////////////////////////////
        // Ok if no directory available
        ////////////////////////////////
        return S_OK;
    }

    /////////////////////////////////////////////////////////
    // Obtain the DN of the computer object for this server
    /////////////////////////////////////////////////////////
    WCHAR       *szDn, szPath[MAX_PATH];
    szDn = szPath;
    ULONG       lPathSize = MAX_PATH;

    if ( !GetComputerObjectNameW(NameFullyQualifiedDN, szDn, &lPathSize) )
    {
        if ( lPathSize > MAX_PATH )
        {
            ////////////////////////////////
            // buffer too small
            // try again with the new size
            ////////////////////////////////
            szDn = (WCHAR*) _alloca(lPathSize * sizeof(WCHAR));
            if ( !GetComputerObjectNameW(
                                          NameFullyQualifiedDN, 
                                          szDn, 
                                          &lPathSize
                                        ))
            {
                // Fail again
                return E_FAIL;          
            }
        }
        else
        {
            // other error
            return E_FAIL;          
        }
    }

    ////////////////////////////////////////////////////////
    // Compose the ADSpath and bind to the computer object
    // for this server
    ////////////////////////////////////////////////////////
    WCHAR*  szAdsPath = (WCHAR*) _alloca((lPathSize + 7) * sizeof (WCHAR));
    wcscpy(szAdsPath, L"LDAP://");
    wcscat(szAdsPath, szDn);


	IDirectoryObject*	pComp;     // Computer object
    HRESULT         hr = ADsGetObject(
                                      szAdsPath,
                                      _uuidof(IDirectoryObject),
                                      (void **)&pComp
                                     );
    if (FAILED(hr)) 
    {
        // cannot bind to the computer object
        return hr;
    }
  

    ADSVALUE        objclass;
    
    ADS_ATTR_INFO   ScpAttribs[] = 
    {
        {
            L"objectClass",
            ADS_ATTR_UPDATE,
            ADSTYPE_CASE_IGNORE_STRING,
            &objclass,
            1
        },
    };
    
    ////////////////////////////////////////////
    // Fill in the values for the attributes  
    // Used to create the SCP
    ////////////////////////////////////////////

    objclass.dwType             = ADSTYPE_CASE_IGNORE_STRING;
    objclass.CaseIgnoreString   = L"serviceAdministrationPoint";


    ////////////////////////////////////////////////////////
    //
    // Publish the SCP as a child of the computer object
    //
    ////////////////////////////////////////////////////////

    //////////////////////////////
    // Figure out attribute count
    // one here
    //////////////////////////////
    DWORD				dwAttr;
    dwAttr = sizeof(ScpAttribs)/sizeof(ADS_ATTR_INFO);  

    //////////////////////
    // Create the object
    //////////////////////

    IDispatch*			pDisp = NULL; // returned dispinterface of new object
    hr = pComp->CreateDSObject(
                                (LPWSTR)IAS_DIRECTORY_NAME,     
                                ScpAttribs, 
                                dwAttr,
                                &pDisp
                              );

    //////////////////////////////////////////////////////////
    // we ignore any potential problem. 
    //////////////////////////////////////////////////////////
    if (pDisp)
    {   ////////////////////////////////
        // create object was successful
        ////////////////////////////////
        pDisp->Release();
    }

    pComp->Release();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
//  IASUnregisterService:
//
// Delete the SCP and registry key for this service.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
IASDirectoryUnregisterService() 
{
    if (!hasDirectory())
    {
        ////////////////////////////////
        // Ok if no directory available
        ////////////////////////////////
        return S_OK;
    }
  
    /////////////////////////////////////////////////////////
    // Obtain the DN of the computer object for this server
    /////////////////////////////////////////////////////////

    WCHAR       *szDn, szPath[MAX_PATH];
    szDn = szPath;
    ULONG       lPathSize = MAX_PATH;
    
    if ( !GetComputerObjectNameW(NameFullyQualifiedDN,szDn,&lPathSize) )
    {
        if ( lPathSize > MAX_PATH )
        {
            ////////////////////////////////
            // buffer too small
            // try again with the new size
            ////////////////////////////////
            szDn = (WCHAR*) _alloca(lPathSize * sizeof(WCHAR));
            if ( !GetComputerObjectNameW(
                                          NameFullyQualifiedDN, 
                                          szDn, 
                                          &lPathSize
                                        ))
            {
                // Fail again
                return E_FAIL;         
            }
        }
        else
        {
            // Other error
            return E_FAIL;         
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // Compose the ADSpath and bind to the computer object for this server
    ///////////////////////////////////////////////////////////////////////
    WCHAR*  szAdsPath = (WCHAR*) _alloca((lPathSize + 7) * sizeof (WCHAR));
    wcscpy(szAdsPath, L"LDAP://");
    wcscat(szAdsPath, szDn);


	IDirectoryObject*   pComp;     // Computer object
    HRESULT         hr = ADsGetObject(
                                       szAdsPath,
                                       _uuidof(IDirectoryObject),
                                       (void **)&pComp
                                     );
    if (FAILED(hr)) 
    {
        // cannot bind
        return hr;
    }

    //////////////////////////////////////////////////////
    //
    // Delete the SCP as a child of the computer object
    //
    //////////////////////////////////////////////////////

    hr = pComp->DeleteDSObject( (LPWSTR)IAS_DIRECTORY_NAME);

    //////////////////////////////////////////////////////////
    // we ignore any potential problem. 
    //////////////////////////////////////////////////////////
    pComp->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\authmib.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    authmib.h
//
// SYNOPSIS
//
//    Declares the class AuthServMIB.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _AUTHMIB_H_
#define _AUTHMIB_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <snmpoid.h>

///////////////////////////////////////////////////////////////////////////////
//
// NAMESPACE
//
//    AuthServMIB
//
// DESCRIPTION
//
//    Implements the RADIUS Authentication Server MIB.
//
///////////////////////////////////////////////////////////////////////////////
namespace AuthServMIB
{
   bool canGetSet(const SnmpOid& name) throw ();
   bool canGetNext(const SnmpOid& name) throw ();

   AsnInteger32 get(
                    const SnmpOid& name,
                    AsnAny* value
                    );

   AsnInteger32 getNext(
                    SnmpOid& name,
                    AsnAny* value
                    );

   AsnInteger32 set(
                    const SnmpOid& name,
                    AsnAny* value
                    );
};

#endif  //  _AUTHMIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\authmib.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    authmib.cpp
//
// SYNOPSIS
//
//    Defines the class AuthServMIB.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//    05/26/1999    Fix bug calling GetAuthClientLeaf.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <snmputil.h>
#include <stats.h>
#include <authmib.h>

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    GetAuthServerLeaf
//
// DESCRIPION
//
//    Computes the value of a server leaf.
//
///////////////////////////////////////////////////////////////////////////////
AsnInteger32
WINAPI
GetAuthServerLeaf(
    IN UINT leaf,
    OUT AsnAny* value
    )
{
   switch (leaf)
   {
      case  1:
         GetServerIdentity(value);
         break;

      case  2:
         GetServerUpTime(value);
         break;

      case  3:
         GetServerResetTime(value);
         break;

      case  4:
         GetServerConfigReset(value);
         break;

      case  5:
         GetTotalCounter(radiusAuthServAccessRequests, value);
         break;

      case  6:
         GetServerCounter(radiusAuthServTotalInvalidRequests, value);
         break;

      case  7:
         GetTotalCounter(radiusAuthServDupAccessRequests, value);
         break;

      case  8:
         GetTotalCounter(radiusAuthServAccessAccepts, value);
         break;

      case  9:
         GetTotalCounter(radiusAuthServAccessRejects, value);
         break;

      case 10:
         GetTotalCounter(radiusAuthServAccessChallenges, value);
         break;

      case 11:
         GetTotalCounter(radiusAuthServMalformedAccessRequests, value);
         break;

      case 12:
         GetTotalCounter(radiusAuthServBadAuthenticators, value);
         break;

      case 13:
         GetTotalCounter(radiusAuthServPacketsDropped, value);
         break;

      case 14:
         GetTotalCounter(radiusAuthServUnknownType, value);
         break;

      case 15:
         return SNMP_ERRORSTATUS_NOACCESS;

      default:
         return SNMP_ERRORSTATUS_NOSUCHNAME;
   }

   return SNMP_ERRORSTATUS_NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    GetAuthClientLeaf
//
// DESCRIPION
//
//    Computes the value of a client leaf.
//
///////////////////////////////////////////////////////////////////////////////
AsnInteger32
WINAPI
GetAuthClientLeaf(
    UINT client,
    UINT leaf,
    AsnAny* value
    )
{
   // SNMP indices start from 1, but C++ indices start from 0.
   --client;

   switch (leaf)
   {
      case  1:
         return SNMP_ERRORSTATUS_NOACCESS;

      case  2:
         GetClientAddress(client, value);
         break;

      case  3:
         GetClientIdentity(client, value);
         break;

      case  4:
         GetClientCounter(client, radiusAuthServAccessRequests, value);
         break;

      case  5:
         GetClientCounter(client, radiusAuthServDupAccessRequests, value);
         break;

      case  6:
         GetClientCounter(client, radiusAuthServAccessAccepts, value);
         break;

      case  7:
         GetClientCounter(client, radiusAuthServAccessRejects, value);
         break;

      case  8:
         GetClientCounter(client, radiusAuthServAccessChallenges, value);
         break;

      case  9:
         GetClientCounter(client, radiusAuthServMalformedAccessRequests, value);
         break;

      case 10:
         GetClientCounter(client, radiusAuthServBadAuthenticators, value);
         break;

      case 11:
         GetClientCounter(client, radiusAuthServPacketsDropped, value);
         break;

      case 12:
         GetClientCounter(client, radiusAuthServUnknownType, value);
         break;

      default:
         return SNMP_ERRORSTATUS_NOSUCHNAME;
   }

   return SNMP_ERRORSTATUS_NOERROR;
}

//////////
// OID definitions.
//////////
#define OID_radiusAuthentication      OID_radiusMIB,1
#define OID_radiusAuthServMIB         OID_radiusAuthentication,1
#define OID_radiusAuthServMIBObjects  OID_radiusAuthServMIB,1
#define OID_radiusAuthServ            OID_radiusAuthServMIBObjects,1
#define OID_radiusAuthClientTable     OID_radiusAuthServ,15

namespace {

//////////
// ID arrays.
//////////
UINT IDS_serverNode[]      = { OID_radiusAuthServ               };
UINT IDS_firstServerLeaf[] = { OID_radiusAuthServ,  1           };
UINT IDS_lastServerLeaf[]  = { OID_radiusAuthServ, 14           };
UINT IDS_clientNode[]      = { OID_radiusAuthClientTable        };
UINT IDS_firstClientLeaf[] = { OID_radiusAuthClientTable, 1,  2 };
UINT IDS_lastClientLeaf[]  = { OID_radiusAuthClientTable, 1, 12 };
UINT IDS_configReset[]     = { OID_radiusAuthServ, 4            };

//////////
// AsnObjectIdentifiers.
//////////
AsnObjectIdentifier serverNode      = DEFINE_OID(IDS_serverNode);
AsnObjectIdentifier firstServerLeaf = DEFINE_OID(IDS_firstServerLeaf);
AsnObjectIdentifier lastServerLeaf  = DEFINE_OID(IDS_lastServerLeaf);

AsnObjectIdentifier clientNode      = DEFINE_OID(IDS_clientNode);
AsnObjectIdentifier firstClientLeaf = DEFINE_OID(IDS_firstClientLeaf);
AsnObjectIdentifier lastClientLeaf  = DEFINE_OID(IDS_lastClientLeaf);

AsnObjectIdentifier configReset     = DEFINE_OID(IDS_configReset);

//////////
// Lengths of valid leaf OID's.
//////////
const UINT serverLength = DEFINE_SIZEOF(IDS_firstServerLeaf);
const UINT clientLength = DEFINE_SIZEOF(IDS_firstClientLeaf);

}

bool AuthServMIB::canGetSet(const SnmpOid& name) throw ()
{
   return name.isChildOf(serverNode);
}

bool AuthServMIB::canGetNext(const SnmpOid& name) throw ()
{
   if (theStats->dwNumClients)
   {
      // Update the last client leaf. This is the highest OID we support.
      lastClientLeaf.ids[clientLength - 2] = theStats->dwNumClients;

      return name < lastClientLeaf;
   }

   return name < lastServerLeaf;
}

AsnInteger32 AuthServMIB::get(
                              const SnmpOid& name,
                              AsnAny* value
                              )
{
   // Is it a client leaf ?
   if (name.isChildOf(clientNode))
   {
      if (name.length() == clientLength)
      {
         return GetAuthClientLeaf(
                    name.id(1),
                    name.id(0),
                    value
                    );
      }
   }

   // Is it a server leaf ?
   else if (name.isChildOf(serverNode))
   {
      if (name.length() == serverLength)
      {
         return GetAuthServerLeaf(
                    name.id(0),
                    value
                    );
      }
   }

   return SNMP_ERRORSTATUS_NOSUCHNAME;
}

AsnInteger32 AuthServMIB::getNext(
                              SnmpOid& name,
                              AsnAny* value
                              )
{
   if (name < firstServerLeaf)
   {
      name = firstServerLeaf;

      return GetAuthServerLeaf(
                 name.id(0),
                 value
                 );
   }

   if (name < lastServerLeaf)
   {
      // We're in the middle of the server leaves, so just advance
      // to the next one.
      name.resize(serverLength);
      ++name.id(0);

      return GetAuthServerLeaf(
                 name.id(0),
                 value
                 );
   }

   if (name < firstClientLeaf)
   {
      name = firstClientLeaf;

      return GetAuthClientLeaf(
                 name.id(1),
                 name.id(0),
                 value
                 );
   }

   /////////
   // If we made it here, we're in the middle of the client leaves.
   /////////

   name.resize(clientLength);

   if (name.id(0) < 2)
   {
      name.id(0) = 2;
   }
   else if (++name.id(0) > 12)
   {
      name.id(0) = 2;

      // We wrapped around to the next client.
      ++name.id(1);
   }

   return GetAuthClientLeaf(
              name.id(1),
              name.id(0),
              value
              );
}

AsnInteger32 AuthServMIB::set(
                             const SnmpOid& name,
                             AsnAny* value
                             )
{
   if (name == configReset)
   {
      return SetServerConfigReset(value);
   }

   return SNMP_ERRORSTATUS_READONLY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\iasperf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    This file implements the PerfMon DLL for IAS.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasinfo.h>
#include <iasutil.h>

#include <loadperf.h>
#include <newop.cpp>

#include <iasperf.h>
#include <perflib.h>
#include <resource.h>
#include <stats.h>

//////////
// Schema for the performance objects supported by this DLL.
//////////
extern PerfCollectorDef PERF_SCHEMA;

//////////
// The performance collector.
//////////
PerfCollector theCollector;

//////////
// Last start time of the server -- used to detect restarts.
//////////
LARGE_INTEGER theLastStart;

//////////
// Computes the server time counters.
//////////
PDWORD
WINAPI
ComputeServerTimes(
    PDWORD dst
    ) throw ()
{
   if (theStats->seServer.liStartTime.QuadPart)
   {
      LARGE_INTEGER now, elapsed;
      GetSystemTimeAsFileTime((LPFILETIME)&now);

      elapsed.QuadPart = now.QuadPart - theStats->seServer.liStartTime.QuadPart;
      elapsed.QuadPart /= 10000000;
      *dst++ = elapsed.LowPart;

      elapsed.QuadPart = now.QuadPart - theStats->seServer.liResetTime.QuadPart;
      elapsed.QuadPart /= 10000000;
      *dst++ = elapsed.LowPart;
   }
   else
   {
      // If the start time is zero, then the server's not running.
      *dst++ = 0;
      *dst++ = 0;
   }

   return dst;
}

//////////
// Creates instances for any newly added clients.
//////////
VOID
WINAPI
PopulateInstances(
    PerfObjectType& sink
    ) throw ()
{
   for (DWORD i = sink.size(); i < theStats->dwNumClients; ++i)
   {
      WCHAR buf[16];
      sink.addInstance(ias_inet_htow(theStats->ceClients[i].dwAddress, buf));
   }
}

//////////
// Computes derived authentication counters from raw counters.
//////////
VOID
WINAPI
DeriveAuthCounters(
    PDWORD dst
    ) throw ()
{
   // Compute packets received.
   DWORD rcvd = 0;
   for (DWORD i = 0; i < 6; ++i) rcvd += dst[i];
   dst[9] = rcvd;

   // Compute packets sent.
   DWORD sent = 0;
   for (DWORD j = 6; j < 9; ++j) sent += dst[j];
   dst[10] = sent;

   // Copy raw counters into rate counters.
   memcpy(dst + 11, dst, sizeof(DWORD) * 11);
}

//////////
// Computes derived accounting counters from raw counters.
//////////
VOID
WINAPI
DeriveAcctCounters(
    PDWORD dst
    ) throw ()
{
   // Compute packets received.
   DWORD rcvd = 0;
   for (DWORD i = 0; i < 7; ++i) rcvd += dst[i];
   dst[8] = rcvd;

   // Compute packets sent.
   DWORD sent = 0;
   for (DWORD j = 7; j < 8; ++j) sent += dst[j];
   dst[9] = sent;

   // Copy raw counters into rate counters.
   memcpy(dst + 10, dst, sizeof(DWORD) * 10);
}

//////////
// Callback for the authentication server object.
//////////
VOID WINAPI AuthServerDataSource(PerfObjectType& sink)
{
   PDWORD p = ComputeServerTimes(sink[0].getCounters());

   *p++ = theStats->seServer.dwCounters[radiusAuthServTotalInvalidRequests];
   *p++ = theStats->seServer.dwCounters[radiusAuthServTotalInvalidRequests];

   memset(p, 0, sizeof(DWORD) * 9);

   for (DWORD i = 0; i < theStats->dwNumClients; ++i)
   {
      for (DWORD j = 0; j < 9; ++j)
      {
         p[j] += theStats->ceClients[i].dwCounters[j];
      }
   }

   DeriveAuthCounters(p);
}

//////////
// Callback for the authentication clients object.
//////////
VOID WINAPI AuthClientDataSource(PerfObjectType& sink)
{
   PopulateInstances(sink);

   for (DWORD i = 0; i < theStats->dwNumClients; ++i)
   {
      PDWORD dst = sink[i].getCounters();

      memcpy(dst, theStats->ceClients[i].dwCounters, sizeof(DWORD) * 9);

      DeriveAuthCounters(dst);
   }
}

//////////
// Callback for the accounting server object.
//////////
VOID WINAPI AcctServerDataSource(PerfObjectType& sink)
{
   PDWORD p = ComputeServerTimes(sink[0].getCounters());

   *p++ = theStats->seServer.dwCounters[radiusAccServTotalInvalidRequests];
   *p++ = theStats->seServer.dwCounters[radiusAccServTotalInvalidRequests];

   memset(p, 0, sizeof(DWORD) * 8);

   for (DWORD i = 0; i < theStats->dwNumClients; ++i)
   {
      for (DWORD j = 0; j < 8; ++j)
      {
         p[j] += theStats->ceClients[i].dwCounters[j + 9];
      }
   }

   DeriveAcctCounters(p);
}

//////////
// Callback for the accounting clients object.
//////////
VOID WINAPI AcctClientDataSource(PerfObjectType& sink)
{
   PopulateInstances(sink);

   for (DWORD i = 0; i < theStats->dwNumClients; ++i)
   {
      PDWORD dst = sink[i].getCounters();

      memcpy(dst, theStats->ceClients[i].dwCounters + 9, sizeof(DWORD) * 8);

      DeriveAcctCounters(dst);
   }
}

//////////
// Creates instances for any newly added remote servers.
//////////
VOID
WINAPI
PopulateServers(
    PerfObjectType& sink
    ) throw ()
{
   for (DWORD i = sink.size(); i < theProxy->dwNumRemoteServers; ++i)
   {
      WCHAR buf[16];
      sink.addInstance(
               ias_inet_htow(theProxy->rseRemoteServers[i].dwAddress, buf)
               );
   }
}

VOID
WINAPI
DeriveProxyAuthCounters(
    PDWORD dst
    ) throw ()
{
   // Compute packets received.
   dst[12] =  + dst[radiusAuthClientAccessAccepts]
              + dst[radiusAuthClientAccessRejects]
              + dst[radiusAuthClientAccessChallenges]
              + dst[radiusAuthClientUnknownTypes];

   // Compute requests pending.
   dst[13] = + dst[radiusAuthClientAccessRequests]
             - dst[radiusAuthClientAccessAccepts]
             - dst[radiusAuthClientAccessRejects]
             - dst[radiusAuthClientAccessChallenges]
             + dst[radiusAuthClientMalformedAccessResponses]
             + dst[radiusAuthClientBadAuthenticators]
             + dst[radiusAuthClientPacketsDropped]
             - dst[radiusAuthClientTimeouts];

   // Copy raw counters into rate counters.
   memcpy(dst + 14, dst + 2, sizeof(DWORD) * 10);
}

VOID
WINAPI
DeriveProxyAcctCounters(
    PDWORD dst
    ) throw ()
{
   // Compute packets received.
   dst[10] = + dst[radiusAccClientResponses - 12]
             + dst[radiusAccClientUnknownTypes - 12];

   // Compute requests pending.
   dst[11] = + dst[radiusAccClientRequests - 12]
             - dst[radiusAccClientResponses - 12]
             + dst[radiusAccClientMalformedResponses - 12]
             + dst[radiusAccClientBadAuthenticators - 12]
             + dst[radiusAccClientPacketsDropped - 12]
             - dst[radiusAccClientTimeouts - 12];

   // Copy raw counters into rate counters.
   memcpy(dst + 12, dst + 2, sizeof(DWORD) * 8);
}

//////////
// Callback for the authentication proxy object.
//////////
VOID WINAPI AuthProxyDataSource(PerfObjectType& sink)
{
   PDWORD p = sink[0].getCounters();

   p[0] = theProxy->peProxy.dwCounters[radiusAuthClientInvalidAddresses];
   p[1] = theProxy->peProxy.dwCounters[radiusAuthClientInvalidAddresses];

   memset(p + 2, 0, sizeof(DWORD) * 10);

   for (DWORD i = 0; i < theProxy->dwNumRemoteServers; ++i)
   {
      for (DWORD j = 2; j < 12; ++j)
      {
         p[j] += theProxy->rseRemoteServers[i].dwCounters[j];
      }
   }

   DeriveProxyAuthCounters(p);
}

//////////
// Callback for the accounting proxy object.
//////////
VOID WINAPI AcctProxyDataSource(PerfObjectType& sink)
{
   PDWORD p = sink[0].getCounters();

   p[0] = theProxy->peProxy.dwCounters[radiusAccClientInvalidAddresses];
   p[1] = theProxy->peProxy.dwCounters[radiusAccClientInvalidAddresses];

   memset(p + 2, 0, sizeof(DWORD) * 8);

   for (DWORD i = 0; i < theProxy->dwNumRemoteServers; ++i)
   {
      for (DWORD j = 2; j < 10; ++j)
      {
         p[j] += theProxy->rseRemoteServers[i].dwCounters[j + 12];
      }
   }

   DeriveProxyAcctCounters(p);
}

//////////
// Callback for the remote authentication servers.
//////////
VOID WINAPI AuthRemoteServerDataSource(PerfObjectType& sink)
{
   PopulateServers(sink);

   for (DWORD i = 0; i < theProxy->dwNumRemoteServers; ++i)
   {
      PDWORD dst = sink[i].getCounters();

      memcpy(
          dst,
          theProxy->rseRemoteServers[i].dwCounters,
          sizeof(DWORD) * 12
          );

      DeriveProxyAuthCounters(dst);
   }

}

//////////
// Callback for the remote accounting servers.
//////////
VOID WINAPI AcctRemoteServerDataSource(PerfObjectType& sink)
{
   PopulateServers(sink);

   for (DWORD i = 0; i < theProxy->dwNumRemoteServers; ++i)
   {
      PDWORD dst = sink[i].getCounters();

      memcpy(
          dst,
          theProxy->rseRemoteServers[i].dwCounters + 12,
          sizeof(DWORD) * 10
          );

      DeriveProxyAcctCounters(dst);
   }
}

//////////
// Reference count for API initialization.
//////////
LONG theRefCount;

//////////
// Serialize access to PerfMon.
//////////
CRITICAL_SECTION thePerfLock;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    OpenPerformanceData
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
DWORD
WINAPI
OpenPerformanceData(
    LPWSTR lpDeviceNames
    )
{
   EnterCriticalSection(&thePerfLock);

   DWORD error = NO_ERROR;

   // Are we already initialized?
   if (theRefCount == 0)
   {
      if (StatsOpen())
      {
         try
         {
            theCollector.open(PERF_SCHEMA);

            // Everything succeeded, so update theRefCount.
            theRefCount = 1;
         }
         catch (LONG lErr)
         {
            StatsClose();

            error = (DWORD)lErr;
         }
      }
      else
      {
         error = GetLastError();
      }
   }
   else
   {
      // Already initialized, so just bump the ref. count.
      ++theRefCount;
   }

   LeaveCriticalSection(&thePerfLock);

   return error;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    CollectPerformanceData
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
DWORD
WINAPI
CollectPerformanceData(
    LPWSTR  lpwszValue,
    LPVOID* lppData,
    LPDWORD lpcbBytes,
    LPDWORD lpcObjectTypes
    )
{
   DWORD error = NO_ERROR;

   EnterCriticalSection(&thePerfLock);

   if (theRefCount)
   {
      StatsLock();

      // If the server has restarted, then
      if (theStats->seServer.liStartTime.QuadPart != theLastStart.QuadPart)
      {
         // ... clear out any old instances.
         theCollector.clear();

         theLastStart = theStats->seServer.liStartTime;
      }

      try
      {
         theCollector.collect(
                          lpwszValue,
                          *lppData,
                          *lpcbBytes,
                          *lpcObjectTypes
                          );
      }
      catch (LONG lErr)
      {
         error = (DWORD)lErr;
      }

      StatsUnlock();
   }
   else
   {
      error = ERROR_NOT_READY;
   }

   LeaveCriticalSection(&thePerfLock);

   return error;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    ClosePerformanceData
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
DWORD
WINAPI
ClosePerformanceData()
{
   EnterCriticalSection(&thePerfLock);

   DWORD error = NO_ERROR;

   if (--theRefCount == 0)
   {
      // We're the last man out, so clean-up.

      StatsClose();

      try
      {
         theCollector.close();
      }
      catch (LONG lErr)
      {
         error = (DWORD)lErr;
      }
   }

   LeaveCriticalSection(&thePerfLock);

   return error;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    CreateKey
//
// DESCRIPTION
//
//    Creates a registry key.
//
///////////////////////////////////////////////////////////////////////////////
LONG
WINAPI
CreateKey(
    PCWSTR lpSubKey,
    PHKEY phkResult
    )
{
   DWORD disposition;

   return RegCreateKeyExW(
              HKEY_LOCAL_MACHINE,
              lpSubKey,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_SET_VALUE,
              NULL,
              phkResult,
              &disposition
              );
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    SetStringValue
//
// DESCRIPTION
//
//    Sets a string value on a registry key.
//
///////////////////////////////////////////////////////////////////////////////
LONG
WINAPI
SetStringValue(
    HKEY hKey,
    PCWSTR lpValueName,
    DWORD dwType,
    PCWSTR lpData
    )
{
   return RegSetValueEx(
              hKey,
              lpValueName,
              0,
              dwType,
              (CONST BYTE*)lpData,
              sizeof(WCHAR) * (wcslen(lpData) + 1)
              );
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    DllRegisterServer
//
// DESCRIPTION
//
//    Adds entries to the system registry.
//
///////////////////////////////////////////////////////////////////////////////

const WCHAR MODULE[] =
L"%SystemRoot%\\System32\\iasperf.dll";

const WCHAR PERF_KEY[] =
L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Performance";

extern "C"
STDAPI DllRegisterServer(void)
{
   LONG error;
   HKEY hKey;
   DWORD disposition;

   //////////
   // Blow away the existing counters ...
   //////////

   UnloadPerfCounterTextStringsW(L"LODCTR " IASServiceName, TRUE);

   //////////
   // Update the PerfMon registry entries.
   //////////

   error  = CreateKey(PERF_KEY, &hKey);
   if (error) { return HRESULT_FROM_WIN32(error); }
   SetStringValue(hKey, L"Library", REG_EXPAND_SZ, MODULE);
   SetStringValue(hKey, L"Open",    REG_SZ,        L"OpenPerformanceData");
   SetStringValue(hKey, L"Close",   REG_SZ,        L"ClosePerformanceData");
   SetStringValue(hKey, L"Collect", REG_SZ,        L"CollectPerformanceData");
   RegCloseKey(hKey);

   //////////
   // Install the counters.
   //////////

   LONG ErrorCode = LoadPerfCounterTextStringsW(L"LODCTR IASPERF.INI", TRUE);
   if (ErrorCode == ERROR_ALREADY_EXISTS) { ErrorCode = NO_ERROR; }

   return HRESULT_FROM_WIN32(ErrorCode);
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    DllUnregisterServer
//
// DESCRIPTION
//
//    Removes entries from the system registry.
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
STDAPI DllUnregisterServer(void)
{
   LONG error;
   HKEY hKey;

   /////////
   // Unload the text strings.
   /////////

   UnloadPerfCounterTextStringsW(L"LODCTR " IASServiceName, TRUE);

   //////////
   // Delete the PerfMon registry key.
   //////////

   error  = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services\\IAS",
                0,
                KEY_CREATE_SUB_KEY,
                &hKey
                );
   if (error == NO_ERROR)
   {
      RegDeleteKey(hKey, L"Performance");

      RegCloseKey(hKey);
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    DllMain
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      DisableThreadLibraryCalls(hInstance);

      return InitializeCriticalSectionAndSpinCount(&thePerfLock, 0x80001000);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      DeleteCriticalSection(&thePerfLock);
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\iasperf.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasperf.h
//
// SYNOPSIS
//
//    This file contains the symbolic constants used for the PerfMon counters.
//
// MODIFICATION HISTORY
//
//    09/15/1997    Original version.
//    09/09/1998    Divided authentication and accounting.
//                  Added support for per-client counters.
//    02/18/2000    Added support for proxy counters.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IAS_PERF_H_
#define _IAS_PERF_H_

// Performance objects.
#define RADIUS_AUTH_SERVER_OBJECT             0
#define RADIUS_AUTH_CLIENT_OBJECT             2
#define RADIUS_ACCT_SERVER_OBJECT             4
#define RADIUS_ACCT_CLIENT_OBJECT             6

// Server only.
#define RADIUS_SRV_UP_TIME                    8
#define RADIUS_SRV_RESET_TIME                10
#define RADIUS_SRV_INVALID_CLIENT            12
#define RADIUS_SRV_INVALID_CLIENT_RATE       14

// Server and client.
#define RADIUS_PACKETS_SENT                  16
#define RADIUS_PACKETS_SENT_RATE             18
#define RADIUS_PACKETS_RECEIVED              20
#define RADIUS_PACKETS_RECEIVED_RATE         22
#define RADIUS_MALFORMED_PACKET              24
#define RADIUS_MALFORMED_PACKET_RATE         26
#define RADIUS_BAD_AUTHENTICATOR             28
#define RADIUS_BAD_AUTHENTICATOR_RATE        30
#define RADIUS_DROPPED_PACKET                32
#define RADIUS_DROPPED_PACKET_RATE           34
#define RADIUS_UNKNOWN_TYPE                  36
#define RADIUS_UNKNOWN_TYPE_RATE             38

// Authentication only.
#define RADIUS_AUTH_ACCESS_REQUEST           40
#define RADIUS_AUTH_ACCESS_REQUEST_RATE      42
#define RADIUS_AUTH_DUP_ACCESS_REQUEST       44
#define RADIUS_AUTH_DUP_ACCESS_REQUEST_RATE  46
#define RADIUS_AUTH_ACCESS_ACCEPT            48
#define RADIUS_AUTH_ACCESS_ACCEPT_RATE       50
#define RADIUS_AUTH_ACCESS_REJECT            52
#define RADIUS_AUTH_ACCESS_REJECT_RATE       54
#define RADIUS_AUTH_ACCESS_CHALLENGE         56
#define RADIUS_AUTH_ACCESS_CHALLENGE_RATE    58

// Accounting only.
#define RADIUS_ACCT_REQUEST                  60
#define RADIUS_ACCT_REQUEST_RATE             62
#define RADIUS_ACCT_DUP_REQUEST              64
#define RADIUS_ACCT_DUP_REQUEST_RATE         66
#define RADIUS_ACCT_RESPONSE                 68
#define RADIUS_ACCT_RESPONSE_RATE            70
#define RADIUS_ACCT_NO_RECORD                72
#define RADIUS_ACCT_NO_RECORD_RATE           74

// Performance objects.
#define PROXY_AUTH_PROXY_OBJECT              76
#define PROXY_AUTH_REMSRV_OBJECT             78
#define PROXY_ACCT_PROXY_OBJECT              80
#define PROXY_ACCT_REMSRV_OBJECT             82

// Proxy only.
#define PROXY_INVALID_ADDRESS                84
#define PROXY_INVALID_ADDRESS_RATE           86

// Remote server only
#define PROXY_REMSRV_PORT                    88
#define PROXY_REMSRV_ROUND_TRIP              90

// Authentication & accounting
#define PROXY_PENDING                        92
#define PROXY_TIMEOUT                        94
#define PROXY_TIMEOUT_RATE                   96
#define PROXY_RETRANSMISSION                 98
#define PROXY_RETRANSMISSION_RATE           100

// Authentication only
#define PROXY_AUTH_ACCESS_REQUEST           102
#define PROXY_AUTH_ACCESS_REQUEST_RATE      104
#define PROXY_AUTH_ACCESS_ACCEPT            106
#define PROXY_AUTH_ACCESS_ACCEPT_RATE       108
#define PROXY_AUTH_ACCESS_REJECT            110
#define PROXY_AUTH_ACCESS_REJECT_RATE       112
#define PROXY_AUTH_ACCESS_CHALLENGE         114
#define PROXY_AUTH_ACCESS_CHALLENGE_RATE    116

// Accounting only
#define PROXY_ACCT_REQUEST                  118
#define PROXY_ACCT_REQUEST_RATE             120
#define PROXY_ACCT_RESPONSE                 122
#define PROXY_ACCT_RESPONSE_RATE            124

#endif  // _IAS_PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource ID's for IAS PerfMon DLL.
//
// MODIFICATION HISTORY
//
//    11/13/1997    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDR_IASPERF 101
#define IDR_PERFINI 102
#define IDR_PERFSYM 103


#endif  // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\perflib.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    perflib.h
//
// SYNOPSIS
//
//    Declares classes for implementing a PerfMon DLL.
//
// MODIFICATION HISTORY
//
//    09/06/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PERLIB_H_
#define _PERLIB_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <winperf.h>
#include <vector>

// nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable:4200)

// Forward declaration.
class PerfObjectType;

//////////
// Callback function that populates a PerfObjectType prior to collection.
//////////
typedef VOID (WINAPI *PerfDataSource)(PerfObjectType& sink);

//////////
// Struct defining a counter.
//////////
struct PerfCounterDef
{
   DWORD nameTitleOffset;
   DWORD counterType;
   DWORD defaultScale;
   DWORD detailLevel;
};

//////////
// Struct defining an object type.
//////////
struct PerfObjectTypeDef
{
   DWORD nameTitleOffset;
   DWORD numCounters;
   PerfCounterDef* counters;
   PerfDataSource dataSource;  // May be NULL.
   BOOL multipleInstances;     // TRUE if the type support multiple instances.
   DWORD defaultCounter;
};

//////////
// Struct defining the data collector for an application.
//////////
struct PerfCollectorDef
{
   PCWSTR name;                // Registry key containing the counter offsets.
   DWORD numTypes;
   PerfObjectTypeDef* types;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PerfCounterBlock
//
// DESCRIPTION
//
//    Encapsulates a PERF_COUNTER_BLOCK struct.
//
///////////////////////////////////////////////////////////////////////////////
class PerfCounterBlock
{
public:
   // Returns a pointer to the internal counter array.
   PDWORD getCounters() throw ()
   { return counters; }

   // Zero out all the counters.
   void zeroCounters() throw ()
   { memset(counters, 0, pcb.ByteLength - sizeof(PERF_COUNTER_BLOCK)); }

   // Collects PerfMon data into the buffer bounded by 'first' and 'last'.
   // Returns a pointer to the end of the collected data.
   PBYTE collect(PBYTE first, PBYTE last);

   // Create a new PerfCounterBlock object.
   static PerfCounterBlock* create(DWORD numDWORDs);

protected:
   // Constructor is protected since new objects may only be instantiated
   // through the 'create' method.
   PerfCounterBlock() throw () { }

   PERF_COUNTER_BLOCK pcb;
   DWORD counters[0];

private:
   // Not implemented.
   PerfCounterBlock(const PerfCounterBlock&);
   PerfCounterBlock& operator=(const PerfCounterBlock&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PerfInstanceDefinition
//
// DESCRIPTION
//
//    Encapsulates a PERF_INSTANCE_DEFINITION struct.
//
///////////////////////////////////////////////////////////////////////////////
class PerfInstanceDefinition
{
public:
   // Returns the name of the instance; may be null.
   PCWSTR getName() const throw ()
   { return pid.NameLength ? name : NULL; }

   // Returns the Unique ID of the instance.
   LONG getUniqueID() const throw ()
   { return pid.UniqueID; }

   PBYTE collect(PBYTE first, PBYTE last);

   // Create a new PerfInstanceDefinition object.
   static PerfInstanceDefinition* create(
                                      PCWSTR name,        // May be NULL.
                                      LONG uniqueID
                                      );

protected:
   // Constructor is protected since new objects may only be instantiated
   // through the 'create' method.
   PerfInstanceDefinition() throw () { }

   PERF_INSTANCE_DEFINITION pid;
   WCHAR name[0];

private:
   // Not implemented.
   PerfInstanceDefinition(const PerfInstanceDefinition&);
   PerfInstanceDefinition& operator=(const PerfInstanceDefinition&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PerfInstance
//
// DESCRIPTION
//
//    Represents an instance of a particular performance object type. Consists
//    of an optional PerfInstanceDefinition followed by a mandatory
//    PerfCounterBlock
//
///////////////////////////////////////////////////////////////////////////////
class PerfInstance
{
public:
   PerfInstance(DWORD numCounters)
      : pcb(PerfCounterBlock::create(numCounters))
   { }

   PerfInstance(PCWSTR name, LONG uniqueID, DWORD numCounters)
      : pid(PerfInstanceDefinition::create(name, uniqueID)),
        pcb(PerfCounterBlock::create(numCounters))
   { }

   // Returns a pointer to the internal counter array.
   PDWORD getCounters() throw ()
   { return pcb->getCounters(); }

   PBYTE collect(PBYTE first, PBYTE last);

protected:
   std::auto_ptr<PerfInstanceDefinition> pid;
   std::auto_ptr<PerfCounterBlock> pcb;

private:
   // Not implemented.
   PerfInstance(const PerfInstance&);
   PerfInstance& operator=(const PerfInstance&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PerfObjectType
//
// DESCRIPTION
//
//    Encapsulates a performance object type containing zero or more
//    PerfInstance's.
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectType
{
public:
   typedef std::vector<PerfInstance*> MyVec;
   typedef MyVec::size_type size_type;

   ~PerfObjectType() throw ();

   // Access a given instance of this type.
   PerfInstance& operator[](size_type pos) throw ()
   { return *instances[pos]; }
   PerfInstance& at(size_type pos) throw ()
   { return *instances[pos]; }

   // Returns the index used by PerfMon to identify this object type.
   DWORD getIndex() const throw ()
   { return pot.ObjectNameTitleIndex; }

   // Clears all instances.
   void clear() throw ();

   // Reserves space for at least 'N' instances.
   void reserve(size_type N)
   { instances.reserve(N); }

   // Returns the number of instances.
   size_type size() const throw ()
   { return instances.size(); }

   // Add a new instance of this type.
   void addInstance(
            PCWSTR name = NULL,
            LONG uniqueID = PERF_NO_UNIQUE_ID
            );

   // Collect performance data for this object type.
   PBYTE collect(PBYTE first, PBYTE last);

   // Create a new PerfObjectType.
   static PerfObjectType* create(const PerfObjectTypeDef& def);

protected:
   // Constructor is protected since new objects may only be instantiated
   // through the 'create' method.
   PerfObjectType() throw () { }

   PerfDataSource dataSource;      // Callback for populating objects.
   MyVec instances;                // Vector of existing instances.
   DWORD numDWORDs;                // DWORD's of data for each instance.
   PERF_OBJECT_TYPE pot;
   PERF_COUNTER_DEFINITION pcd[0];

private:
   // Not implemented.
   PerfObjectType(const PerfObjectType&);
   PerfObjectType& operator=(const PerfObjectType&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PerfCollector
//
// DESCRIPTION
//
//    Maintains all the PerfObjectType's for a given application.
//
///////////////////////////////////////////////////////////////////////////////
class PerfCollector
{
public:
   typedef size_t size_type;

   PerfCollector() throw ()
      : types(NULL)
   { }
   ~PerfCollector() throw ();

   // Access a given object type.
   PerfObjectType& operator[](size_type pos) throw ()
   { return *(types[pos]); }

   // Clears all instances (but not all PerfObjectType's).
   void clear() throw ();

   // Initialize the collector for use.
   void open(const PerfCollectorDef& def);

   // Collect performance data for the indicated types.
   void collect(
            PCWSTR values,
            PVOID& data,
            DWORD& numBytes,
            DWORD& numTypes
            );

   // Shutdown the collector.
   void close() throw ();

protected:
   PerfObjectType** types;

private:
   // Not implemented.
   PerfCollector(PerfCollector&);
   PerfCollector& operator=(PerfCollector&);
};

#endif  // _PERLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\schema.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    schema.cpp
//
// SYNOPSIS
//
//    Defines the schema for the PerfMon DLL.
//
// MODIFICATION HISTORY
//
//    09/09/1998    Original version.
//    11/30/1998    "No Record" and "Accounting Reponse" were reversed.
//    09/14/1999    Same as previous for per-client counters.
//    02/18/2000    Added support for proxy counters.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasperf.h>
#include <perflib.h>

//////////
// Callbacks used for populating the performance data.
//////////
VOID WINAPI AuthServerDataSource(PerfObjectType& sink);
VOID WINAPI AuthClientDataSource(PerfObjectType& sink);
VOID WINAPI AcctServerDataSource(PerfObjectType& sink);
VOID WINAPI AcctClientDataSource(PerfObjectType& sink);
VOID WINAPI AuthProxyDataSource(PerfObjectType& sink);
VOID WINAPI AcctProxyDataSource(PerfObjectType& sink);
VOID WINAPI AuthRemoteServerDataSource(PerfObjectType& sink);
VOID WINAPI AcctRemoteServerDataSource(PerfObjectType& sink);

//////////
// Computes the number of elements in an array.
//////////
#define ARRAY_ELEMENTS(a) (sizeof(a)/sizeof((a)[0]))

PerfCounterDef AUTH_SERVER_COUNTERS[] =
{
   {
      RADIUS_SRV_UP_TIME,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_RESET_TIME,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_INVALID_CLIENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_INVALID_CLIENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_DUP_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_ACCEPT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REJECT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_CHALLENGE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_DUP_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_ACCEPT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REJECT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_CHALLENGE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef AUTH_CLIENT_COUNTERS[] =
{
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_DUP_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_ACCEPT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REJECT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_CHALLENGE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_DUP_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_ACCEPT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_REJECT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_AUTH_ACCESS_CHALLENGE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef ACCT_SERVER_COUNTERS[] =
{
   {
      RADIUS_SRV_UP_TIME,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_RESET_TIME,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_INVALID_CLIENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_SRV_INVALID_CLIENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_DUP_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_NO_RECORD,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_RESPONSE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_DUP_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_NO_RECORD_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_RESPONSE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef ACCT_CLIENT_COUNTERS[] =
{
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_DUP_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_NO_RECORD,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_RESPONSE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_DUP_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_NO_RECORD_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_ACCT_RESPONSE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_SENT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef AUTH_PROXY_COUNTERS[] =
{
   {
      PROXY_INVALID_ADDRESS,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_INVALID_ADDRESS_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_ACCEPT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REJECT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_CHALLENGE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_PENDING,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_ACCEPT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REJECT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_CHALLENGE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef ACCT_PROXY_COUNTERS[] =
{
   {
      PROXY_INVALID_ADDRESS,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_INVALID_ADDRESS_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_RESPONSE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_PENDING,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_RESPONSE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef REMOTE_AUTH_SRV_COUNTERS[] =
{
   {
      PROXY_REMSRV_PORT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_REMSRV_ROUND_TRIP,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_ACCEPT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REJECT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_CHALLENGE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_PENDING,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_ACCEPT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_REJECT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_AUTH_ACCESS_CHALLENGE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};

PerfCounterDef REMOTE_ACCT_SRV_COUNTERS[] =
{
   {
      PROXY_REMSRV_PORT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_REMSRV_ROUND_TRIP,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_REQUEST,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_RESPONSE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_PENDING,
      PERF_COUNTER_RAWCOUNT,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_REQUEST_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_RETRANSMISSION_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_ACCT_RESPONSE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_UNKNOWN_TYPE_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_MALFORMED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_BAD_AUTHENTICATOR_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_DROPPED_PACKET_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      PROXY_TIMEOUT_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   },
   {
      RADIUS_PACKETS_RECEIVED_RATE,
      PERF_COUNTER_COUNTER,
      0,
      PERF_DETAIL_NOVICE
   }
};


PerfObjectTypeDef PERF_OBJECTS[] =
{
   {
      RADIUS_AUTH_SERVER_OBJECT,
      ARRAY_ELEMENTS(AUTH_SERVER_COUNTERS),
      AUTH_SERVER_COUNTERS,
      AuthServerDataSource,
      FALSE,
      -1
   },
   {
      RADIUS_AUTH_CLIENT_OBJECT,
      ARRAY_ELEMENTS(AUTH_CLIENT_COUNTERS),
      AUTH_CLIENT_COUNTERS,
      AuthClientDataSource,
      TRUE,
      -1
   },
   {
      RADIUS_ACCT_SERVER_OBJECT,
      ARRAY_ELEMENTS(ACCT_SERVER_COUNTERS),
      ACCT_SERVER_COUNTERS,
      AcctServerDataSource,
      FALSE,
      -1
   },
   {
      RADIUS_ACCT_CLIENT_OBJECT,
      ARRAY_ELEMENTS(ACCT_CLIENT_COUNTERS),
      ACCT_CLIENT_COUNTERS,
      AcctClientDataSource,
      TRUE,
      -1
   },
   {
      PROXY_AUTH_PROXY_OBJECT,
      ARRAY_ELEMENTS(AUTH_PROXY_COUNTERS),
      AUTH_PROXY_COUNTERS,
      AuthProxyDataSource,
      FALSE,
      -1
   },
   {
      PROXY_AUTH_REMSRV_OBJECT,
      ARRAY_ELEMENTS(REMOTE_AUTH_SRV_COUNTERS),
      REMOTE_AUTH_SRV_COUNTERS,
      AuthRemoteServerDataSource,
      TRUE,
      -1
   },
   {
      PROXY_ACCT_PROXY_OBJECT,
      ARRAY_ELEMENTS(ACCT_PROXY_COUNTERS),
      ACCT_PROXY_COUNTERS,
      AcctProxyDataSource,
      FALSE,
      -1
   },
   {
      PROXY_ACCT_REMSRV_OBJECT,
      ARRAY_ELEMENTS(REMOTE_ACCT_SRV_COUNTERS),
      REMOTE_ACCT_SRV_COUNTERS,
      AcctRemoteServerDataSource,
      TRUE,
      -1
   }
};

PerfCollectorDef PERF_SCHEMA =
{
   L"IAS",
   ARRAY_ELEMENTS(PERF_OBJECTS),
   PERF_OBJECTS
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\snmpoid.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    snmpoid.cpp
//
// SYNOPSIS
//
//    Defines the class SnmpOid.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <snmpoid.h>

SnmpOid& SnmpOid::operator=(const AsnObjectIdentifier& a)
{
   // Note: self-assignment is benign, so we don't bother to check.
   resize(a.idLength);

   memcpy(oid.ids, a.ids, length() * sizeof(UINT));

   return *this;
}

bool SnmpOid::isChildOf(const AsnObjectIdentifier& parent) const throw ()
{
   if (length() < parent.idLength)
   {
      return false;
   }

   return SnmpUtilOidNCmp(
              *this,
              const_cast<AsnObjectIdentifier*>(&parent),
              parent.idLength
              ) == 0;
}

void SnmpOid::resize(UINT newLength)
{
   if (newLength <= length())
   {
      // Truncation is easy.
      oid.idLength = newLength;
   }
   else
   {
      // Try to extend our buffer.
      PVOID p = SnmpUtilMemReAlloc(oid.ids, newLength * sizeof(UINT));
      if (p == NULL) { throw (AsnInteger32)SNMP_MEM_ALLOC_ERROR; }

      // Swap in the extended buffer.
      oid.ids = (UINT*)p;

      // Zero out the added ID's.
      memset(oid.ids + length(), 0, (newLength - length()) * sizeof(UINT));

      // Update our length.
      oid.idLength = newLength;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\iassnmp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iassnmp.cpp
//
// SYNOPSIS
//
//    Defines the DLL entry points for the SNMP extension.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//    12/17/1998    Don't return error if OID out of range on GetNext.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <stats.h>
#include <snmp.h>
#include <snmputil.h>
#include <acctmib.h>
#include <authmib.h>

UINT IDS_ourRegion[]  = { OID_mgmt_mib_2, 67 };
UINT IDS_nextRegion[] = { OID_mgmt_mib_2, 68 };

AsnObjectIdentifier ourRegion  = DEFINE_OID(IDS_ourRegion);
AsnObjectIdentifier nextRegion = DEFINE_OID(IDS_nextRegion);

extern "C"
BOOL
SNMP_FUNC_TYPE
SnmpExtensionInit(
    DWORD                 dwUptimeReference,
    HANDLE *              phSubagentTrapEvent,
    AsnObjectIdentifier * pFirstSupportedRegion
    )
{
   if (!StatsOpen()) { return FALSE; }

   *phSubagentTrapEvent = NULL;

   *pFirstSupportedRegion = ourRegion;

   return TRUE;
}

extern "C"
BOOL
SNMP_FUNC_TYPE
SnmpExtensionInitEx(
    AsnObjectIdentifier * pNextSupportedRegion
    )
{
   return FALSE;
}

extern "C"
BOOL
SNMP_FUNC_TYPE
SnmpExtensionQuery(
    BYTE              bPduType,
    SnmpVarBindList * pVarBindList,
    AsnInteger32 *    pErrorStatus,
    AsnInteger32 *    pErrorIndex
    )
{
   // We declare the current index at function scope since we'll need it
   // outside the try block.
   UINT idx = 0;

   // Initialize this to NOERROR just in case pVarBindList is zero length.
   *pErrorStatus = SNMP_ERRORSTATUS_NOERROR;

   // Lock the shared stats.
   StatsLock();

   try
   {
      // Each entry in the pVarBindList is processed independently.
      for ( ; idx < pVarBindList->len; ++idx)
      {
         // Pull out the (name, value) pair.
         SnmpOid name(pVarBindList->list[idx].name);
         AsnAny* value = &pVarBindList->list[idx].value;

         // Process the PDU. Technically, the switch should be outside the
         // for loop, but I thought it was more readable this way.
         switch (bPduType)
         {
            case SNMP_PDU_GET:
            {
               if (AuthServMIB::canGetSet(name))
               {
                  *pErrorStatus = AuthServMIB::get(name, value);
               }
               else if (AcctServMIB::canGetSet(name))
               {
                  *pErrorStatus = AcctServMIB::get(name, value);
               }
               else
               {
                  *pErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
               }

               break;
            }

            case SNMP_PDU_GETNEXT:
            {
               if (AuthServMIB::canGetNext(name))
               {
                  *pErrorStatus = AuthServMIB::getNext(name, value);
               }
               else if (AcctServMIB::canGetNext(name))
               {
                  *pErrorStatus = AcctServMIB::getNext(name, value);
               }
               else
               {
                  // On a failed GETNEXT, we set name to the next region.
                  name = nextRegion;
                  value->asnType = ASN_NULL;
               }

               break;
            }

            case SNMP_PDU_SET:
            {
               if (AuthServMIB::canGetSet(name))
               {
                  *pErrorStatus = AuthServMIB::set(name, value);
               }
               else if (AcctServMIB::canGetSet(name))
               {
                  *pErrorStatus = AcctServMIB::set(name, value);
               }
               else
               {
                  *pErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
               }

               break;
            }

            default:
            {
               *pErrorStatus = SNMP_ERRORSTATUS_GENERR;
            }
         }

         // The first error halts processing.
         if (*pErrorStatus != SNMP_ERRORSTATUS_NOERROR) { break; }
      }
   }
   catch (...)
   {
      // We shouldn't end up here unless there was a memory allocation
      // failure.
      *pErrorStatus = SNMP_ERRORSTATUS_GENERR;
   }

   StatsUnlock();

   // Set the error index appropriately.
   *pErrorIndex = *pErrorStatus ? idx + 1 : 0;

   return TRUE;
}

extern "C"
VOID
SNMP_FUNC_TYPE
SnmpExtensionClose(
    )
{
   StatsClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\perflib.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    perflib.cpp
//
// SYNOPSIS
//
//    Defines classes for implementing a PerfMon DLL.
//
// MODIFICATION HISTORY
//
//    09/06/1998    Original version.
//    10/19/1998    Throw LONG's on error.
//    03/18/1999    Data buffer must be 8-byte aligned.
//    05/13/1999    Fix offset to first help text.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <align.h>
#include <perflib.h>

/////////
// Application offsets into the string title database.
/////////
DWORD theFirstCounter;
DWORD theFirstHelp;

/////////
// Reads the name offsets for a given application.
/////////
LONG GetCounterOffsets(PCWSTR appName) throw ()
{
   // Build the name of the performance key.
   WCHAR keyPath[MAX_PATH + 1] = L"SYSTEM\\CurrentControlSet\\Services\\";
   wcscat(keyPath, appName);
   wcscat(keyPath, L"\\Performance");

   // Open the performance key.
   LONG status;
   HKEY hKey;
   status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                keyPath,
                0,
                KEY_READ,
                &hKey
                );
   if (status != NO_ERROR) { return status; }


   // Get the first counter offset.
   DWORD type, cbData = sizeof(DWORD);
   status = RegQueryValueExW(
                hKey,
                L"First Counter",
                0,
                &type,
                (PBYTE)&theFirstCounter,
                &cbData
                );
   if (status != ERROR_SUCCESS) { goto close_key; };

   // Make sure it's a DWORD.
   if (type != REG_DWORD || cbData != sizeof(DWORD))
   {
      status = ERROR_BADKEY;
      goto close_key;
   }

   // Get the first help offset.
   status = RegQueryValueExW(
                hKey,
                L"First Help",
                0,
                &type,
                (PBYTE)&theFirstHelp,
                &cbData
                );
   if (status != ERROR_SUCCESS) { goto close_key; };

   // Make sure it's a DWORD.
   if (type != REG_DWORD || cbData != sizeof(DWORD))
   {
      status = ERROR_BADKEY;
      goto close_key;
   }

close_key:
   RegCloseKey(hKey);

   return status;
}

PBYTE PerfCounterBlock::collect(PBYTE first, PBYTE last)
{
   PBYTE retval = first + pcb.ByteLength;

   if (retval > last) { throw ERROR_MORE_DATA; }

   memcpy(first, this, pcb.ByteLength);

   return retval;
}

PerfCounterBlock* PerfCounterBlock::create(DWORD numDWORDs)
{
   // Compute various lengths.
   DWORD cntrLength = sizeof(DWORD) * numDWORDs;
   DWORD byteLength = sizeof(PERF_COUNTER_BLOCK) + cntrLength;

   // Allocate enough extra space for the counters.
   PerfCounterBlock* pcb = new (operator new(byteLength)) PerfCounterBlock;

   // Initialize the PERF_COUNTER_BLOCK.
   pcb->pcb.ByteLength = byteLength;

   // Initialize the counters.
   memset(pcb->counters, 0, cntrLength);

   return pcb;
}

PBYTE PerfInstanceDefinition::collect(PBYTE first, PBYTE last)
{
   PBYTE retval = first + pid.ByteLength;

   if (retval > last) { throw ERROR_MORE_DATA; }

   memcpy(first, this, pid.ByteLength);

   return retval;
}

PerfInstanceDefinition* PerfInstanceDefinition::create(
                                                    PCWSTR name,
                                                    LONG uniqueID
                                                    )
{
   // Compute various lengths.
   DWORD nameLength = name ? (wcslen(name) + 1) * sizeof(WCHAR) : 0;
   DWORD byteLength = sizeof(PERF_INSTANCE_DEFINITION) + nameLength;

   // Keep everything DWORD aligned.
   byteLength = ROUND_UP_COUNT(byteLength, ALIGN_DWORD);

   // Allocate enough extra space for the name.
   PerfInstanceDefinition* pid = new (operator new(byteLength))
                                 PerfInstanceDefinition;

   // Initialize the PERF_INSTANCE_DEFINITION.
   pid->pid.ByteLength             = byteLength;
   pid->pid.ParentObjectTitleIndex = 0;
   pid->pid.ParentObjectInstance   = 0;
   pid->pid.UniqueID               = uniqueID;
   pid->pid.NameOffset             = sizeof(PERF_INSTANCE_DEFINITION);
   pid->pid.NameLength             = nameLength;

   // Initialize the name.
   memcpy(pid->name, name, nameLength);

   return pid;
}

PBYTE PerfInstance::collect(PBYTE first, PBYTE last)
{
   return pcb->collect((pid.get() ? pid->collect(first, last) : first), last);
}

PerfObjectType::~PerfObjectType() throw ()
{
   for (MyVec::iterator i = instances.begin(); i != instances.end(); ++i)
   {
      delete *i;
   }
}

void PerfObjectType::clear() throw ()
{
   // Never clear the default instance.
   if (pot.NumInstances != -1)
   {
      for (MyVec::iterator i = instances.begin(); i != instances.end(); ++i)
      {
         delete *i;
      }

      instances.clear();
   }
}

void PerfObjectType::addInstance(PCWSTR name, LONG uniqueID)
{
   // Resize first. If we threw an exception in push_back, we'd leak.
   instances.reserve(size() + 1);

   instances.push_back(new PerfInstance(name, uniqueID, numDWORDs));
}

PBYTE PerfObjectType::collect(PBYTE first, PBYTE last)
{
   // Reserve enough room for the type definition.
   PBYTE retval = first + pot.DefinitionLength;
   if (retval > last) { throw ERROR_MORE_DATA; }

   // Give the user a chance to fill-in the data.
   if (dataSource) { dataSource(*this); }

   if (pot.NumInstances == -1)
   {
      // We always have exactly one instance.
      retval = at(0).collect(retval, last);
   }
   else if (instances.empty())
   {
      // If we're empty, then we right one instance's worth of zeros.
      // Otherwise, PerfMon.exe has a tendency to display garbage.

      DWORD nbyte = sizeof(PERF_INSTANCE_DEFINITION) +
                    sizeof(PERF_COUNTER_BLOCK) +
                    numDWORDs * sizeof(DWORD);

      if (retval + nbyte > last) { throw ERROR_MORE_DATA; }

      memset(retval, 0, nbyte);
      retval += nbyte;

      pot.NumInstances = 0;
   }
   else
   {
      // iterate through and collect all instances.
      for (size_type i = 0; i < size(); ++i)
      {
         retval = at(i).collect(retval, last);
      }

      pot.NumInstances = (DWORD)size();
   }

   // Now that we've collected all the data, we can finish the definition ...
   retval = (PBYTE)ROUND_UP_POINTER(retval, ALIGN_QUAD);
   pot.TotalByteLength = retval - first;
   QueryPerformanceCounter(&pot.PerfTime);

   // ... and copy in the data.
   memcpy(first, &pot, pot.DefinitionLength);

   return retval;
}

PerfObjectType* PerfObjectType::create(const PerfObjectTypeDef& def)
{
   // Allocate a new object.
   size_t counterLength = def.numCounters * sizeof(PERF_COUNTER_DEFINITION);
   size_t nbyte = sizeof(PerfObjectType) + counterLength;
   std::auto_ptr<PerfObjectType> po(new (operator new(nbyte)) PerfObjectType);

   // Save the data source.
   po->dataSource = def.dataSource;

   // Fill in the PERF_COUNTER_DEFINITION structs first since we also
   // need to compute the object detail level.
   DWORD detailLevel = PERF_DETAIL_WIZARD;
   PERF_COUNTER_DEFINITION* dst = po->pcd;
   PerfCounterDef* src = def.counters;
   DWORD offset = sizeof(PERF_COUNTER_BLOCK);

   for (DWORD i = 0; i < def.numCounters; ++i, ++dst, ++src)
   {
      dst->ByteLength            = sizeof(PERF_COUNTER_DEFINITION);
      dst->CounterNameTitleIndex = src->nameTitleOffset + theFirstCounter;
      dst->CounterNameTitle      = 0;
      dst->CounterHelpTitleIndex = src->nameTitleOffset + theFirstHelp;
      dst->CounterHelpTitle      = 0;
      dst->DefaultScale          = src->defaultScale;
      dst->DetailLevel           = src->detailLevel;
      dst->CounterType           = src->counterType;
      dst->CounterOffset         = offset;

      // Compute the counter size.
      switch (dst->CounterOffset & 0x300)
      {
         case PERF_SIZE_DWORD:
            dst->CounterSize = sizeof(DWORD);
            break;

         case PERF_SIZE_LARGE:
            dst->CounterSize = sizeof(LARGE_INTEGER);
            break;

         default:
            dst->CounterSize = 0;
      }

      // Update the offset based on the size.
      offset += dst->CounterSize;

      // The object detail level is the minimum counter detail level.
      if (dst->DetailLevel < detailLevel)
      {
         detailLevel = dst->DetailLevel;
      }
   }

   // Calculate the number of DWORD's of counter data.
   po->numDWORDs = (offset - sizeof(PERF_COUNTER_BLOCK)) / sizeof(DWORD);

   // Fill in the PERF_OBJECT_TYPE struct.
   po->pot.DefinitionLength     = sizeof(PERF_OBJECT_TYPE) + counterLength;
   po->pot.HeaderLength         = sizeof(PERF_OBJECT_TYPE);
   po->pot.ObjectNameTitleIndex = def.nameTitleOffset + theFirstCounter;
   po->pot.ObjectNameTitle      = 0;
   po->pot.ObjectHelpTitleIndex = def.nameTitleOffset + theFirstHelp;
   po->pot.ObjectHelpTitle      = 0;
   po->pot.DetailLevel          = detailLevel;
   po->pot.NumCounters          = def.numCounters;
   po->pot.DefaultCounter       = def.defaultCounter;
   po->pot.NumInstances         = 0;
   po->pot.CodePage             = 0;
   QueryPerformanceFrequency(&(po->pot.PerfFreq));

   // If it doesn't support multiple instances, then it must have exactly one.
   if (!def.multipleInstances)
   {
      po->pot.NumInstances = -1;
      po->instances.reserve(1);
      po->instances.push_back(new PerfInstance(po->numDWORDs));
   }

   return po.release();
}

PerfCollector::~PerfCollector() throw ()
{
   close();
}

void PerfCollector::clear() throw ()
{
   for (PerfObjectType** i = types; *i; ++i)
   {
      (*i)->clear();
   }
}

void PerfCollector::open(const PerfCollectorDef& def)
{
   // Read the registry.
   LONG success = GetCounterOffsets(def.name);
   if (success != NO_ERROR) { throw success; }

   // Allocate a null terminated array to hold the object types.
   DWORD len = def.numTypes + 1;
   types = new PerfObjectType*[len];
   memset(types, 0, sizeof(PerfObjectType*) * len);

   // Create the various object types.
   for (DWORD i = 0; i < def.numTypes; ++i)
   {
      types[i] = PerfObjectType::create(def.types[i]);
   }
}

void PerfCollector::collect(
                        PCWSTR values,
                        PVOID& data,
                        DWORD& numBytes,
                        DWORD& numTypes
                        )
{
   PBYTE cursor = (PBYTE)data;
   PBYTE last = cursor + numBytes;

   numBytes = 0;
   numTypes = 0;

   if (values == NULL || *values == L'\0' || !wcscmp(values, L"Global"))
   {
      // For global we get everything.
      for (PerfObjectType** i = types; *i; ++i)
      {
         cursor = (*i)->collect(cursor, last);
         ++numTypes;
      }
   }
   else if (wcsncmp(values, L"Foreign", 7) && wcscmp(values, L"Costly"))
   {
      // It's not Global, Foreign, or Costly, so we parse the tokens and
      // convert them to title indices.

      PWSTR endptr;
      PCWSTR nptr = values;

      ULONG index = wcstoul(nptr, &endptr, 10);

      while (endptr != nptr)
      {
         // We got a valid index, so find the object ...
         for (PerfObjectType** i = types; *i; ++i)
         {
            if ((*i)->getIndex() == index)
            {
               // ... and collect the data.
               cursor = (*i)->collect(cursor, last);
               ++numTypes;
               break;
            }
         }

         index = wcstoul(nptr = endptr, &endptr, 10);
      }
   }

   numBytes = cursor - (PBYTE)data;
   data = cursor;
}

void PerfCollector::close() throw ()
{
   if (types)
   {
      for (PerfObjectType** i = types ; *i; ++i)
      {
         delete *i;
      }

      delete[] types;
      types = NULL;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\stats.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    stats.h
//
// SYNOPSIS
//
//    Declares functions for accessing the statistics in shared memory.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//    02/18/2000    Added proxy statistics.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _STATS_H_
#define _STATS_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasinfo.h>

#ifdef __cplusplus
extern "C" {
#endif

extern RadiusStatistics* theStats;
extern RadiusProxyStatistics* theProxy;

BOOL
WINAPI
StatsOpen( VOID );

VOID
WINAPI
StatsClose( VOID );

VOID
WINAPI
StatsLock( VOID );

VOID
WINAPI
StatsUnlock( VOID );

#ifdef __cplusplus
}
#endif
#endif  // _STATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\uuid\iasuuid.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasuuid.cpp
//
// SYNOPSIS
//
//    This file initializes the IAS UUID's.
//
// MODIFICATION HISTORY
//
//    11/20/1997    Original version.
//    02/27/1998    Removed the OLE-DB constants.
//
///////////////////////////////////////////////////////////////////////////////

#define INITGUID
#include <guiddef.h>

#include <iasuuid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\snmputil.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    snmputil.h
//
// SYNOPSIS
//
//    Declares various utility functions for computing MIB variables.
//
// MODIFICATION HISTORY
//
//    09/11/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SNMPUTIL_H_
#define _SNMPUTIL_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasinfo.h>
#include <snmp.h>

// .iso.org.dod.internet.mgmt.mib-2 .1.3.6.1.2.1 
#define OID_mgmt_mib_2  1,3,6,1,2,1

//////////
// OID of the 'RADIUS' sub-tree.
//////////
#define OID_radiusMIB       OID_mgmt_mib_2,67

#ifdef __cplusplus
extern "C" {
#endif

VOID
WINAPI
GetServerIdentity(
    OUT AsnAny* value
    );

VOID
WINAPI
GetServerUpTime(
    OUT AsnAny* value
    );

VOID
WINAPI
GetServerResetTime(
    OUT AsnAny* value
    );

VOID
WINAPI
GetServerConfigReset(
    OUT AsnAny* value
    );

AsnInteger32
WINAPI
SetServerConfigReset(
    IN AsnAny* value
    );

VOID
WINAPI
GetTotalCounter(
    IN RadiusClientCounter counter,
    OUT AsnAny* value
    );

VOID
WINAPI
GetServerCounter(
    IN RadiusServerCounter counter,
    OUT AsnAny* value
    );

VOID
WINAPI
GetClientAddress(
    IN UINT client,
    OUT AsnAny* value
    );

VOID
WINAPI
GetClientIdentity(
    IN UINT client,
    OUT AsnAny* value
    );

VOID
WINAPI
GetClientCounter(
    IN UINT client,
    IN RadiusClientCounter counter,
    OUT AsnAny* value
    );

#ifdef __cplusplus
}
#endif
#endif  // _SNMPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\stats.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    stats.cpp
//
// SYNOPSIS
//
//    Defines functions for accessing the statistics in shared memory.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//    10/09/1998    Use a null DACL when creating mutex.
//    09/28/1999    Only allow Administrators access to mutex.
//    02/18/2000    Added proxy statistics.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <stats.h>

//////////
// Zero'ed out stats; used when the shared memory is unavailable.
//////////
RadiusStatistics defaultStats;
RadiusProxyStatistics defaultProxyStats;

//////////
// Handles/pointers to the shared-memory statistics.
//////////
HANDLE theMonitor;
HANDLE theMapping;
HANDLE theProxyMapping;
RadiusStatistics* theStats = &defaultStats;
RadiusProxyStatistics* theProxy = &defaultProxyStats;

BOOL
WINAPI
StatsOpen( VOID )
{
   // Create the SID for local Administrators.
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
   PSID adminSid = (PSID)_alloca(GetSidLengthRequired(2));
   InitializeSid(
       adminSid,
       &sia,
       2
       );
   *GetSidSubAuthority(adminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
   *GetSidSubAuthority(adminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;

   // Create an ACL giving Administrators all access.
   ULONG cbAcl = sizeof(ACL) +
                 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                 GetLengthSid(adminSid);
   PACL acl = (PACL)_alloca(cbAcl);
   InitializeAcl(
       acl,
       cbAcl,
       ACL_REVISION
       );
   AddAccessAllowedAce(
       acl,
       ACL_REVISION,
       MUTEX_ALL_ACCESS,
       adminSid
       );

   // Create a security descriptor with the above ACL.
   PSECURITY_DESCRIPTOR pSD;
   BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
   pSD = (PSECURITY_DESCRIPTOR)buffer;
   InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
   SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE);

   // Fill in the SECURITY_ATTRIBUTES struct.
   SECURITY_ATTRIBUTES sa;
   sa.nLength = sizeof(sa);
   sa.lpSecurityDescriptor = pSD;
   sa.bInheritHandle = TRUE;

   // Create the mutex.
   theMonitor = CreateMutex(
                    &sa,
                    FALSE,
                    L"Global\\" RadiusStatisticsMutex
                    );

   return theMonitor ? TRUE : FALSE;
}

VOID
WINAPI
StatsClose( VOID )
{
   if (theStats != &defaultStats)
   {
      UnmapViewOfFile(theStats);
      theStats = &defaultStats;

      CloseHandle(theMapping);
      theMapping = NULL;
   }

   if (theProxy != &defaultProxyStats)
   {
      UnmapViewOfFile(theProxy);
      theProxy = &defaultProxyStats;

      CloseHandle(theProxyMapping);
      theProxyMapping = NULL;
   }

   CloseHandle(theMonitor);

   theMonitor = NULL;
}

VOID
WINAPI
StatsLock( VOID )
{
   WaitForSingleObject(theMonitor, INFINITE);

   if (theStats == &defaultStats)
   {
      // Open the file mapping ...
      theMapping = OpenFileMappingW(
                       FILE_MAP_READ,
                       FALSE,
                       L"Global\\" RadiusStatisticsName
                       );
      if (theMapping)
      {
         // ... and map a view into our address space.
         PVOID view = MapViewOfFile(theMapping, FILE_MAP_READ, 0, 0, 0);

         if (view)
         {
            theStats = (RadiusStatistics*)view;
         }
         else
         {
            CloseHandle(theMapping);
            theMapping = NULL;
         }
      }
   }
   if (theProxy == &defaultProxyStats)
   {
      // Open the file mapping ...
      theProxyMapping = OpenFileMappingW(
                            FILE_MAP_READ,
                            FALSE,
                            L"Global\\" RadiusProxyStatisticsName
                            );
      if (theProxyMapping)
      {
         // ... and map a view into our address space.
         PVOID view = MapViewOfFile(theProxyMapping, FILE_MAP_READ, 0, 0, 0);

         if (view)
         {
            theProxy = (RadiusProxyStatistics*)view;
         }
         else
         {
            CloseHandle(theProxyMapping);
            theProxyMapping = NULL;
         }
      }
   }
}

VOID
WINAPI
StatsUnlock( VOID )
{
   ReleaseMutex(theMonitor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\snmputil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    snmputil.cpp
//
// SYNOPSIS
//
//    Defines utility functions for computing MIB variables.
//
// MODIFICATION HISTORY
//
//    09/11/1998    Original version.
//    02/18/1999    Move registry values.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <snmputil.h>
#include <stats.h>

const CHAR SERVER_IDENTITY[] = "Microsoft IAS2.0";

VOID
WINAPI
GetServerIdentity(
    OUT AsnAny* value
    )
{
   value->asnType = ASN_OCTETSTRING;
   value->asnValue.string.stream  = (PBYTE)SERVER_IDENTITY;
   value->asnValue.string.length  = sizeof(SERVER_IDENTITY);
   value->asnValue.string.dynamic = FALSE;
}

VOID
WINAPI
GetServerUpTime(
    OUT AsnAny* value
    )
{
   LARGE_INTEGER elapsed;

   if (theStats->seServer.liStartTime.QuadPart)
   {
      GetSystemTimeAsFileTime((LPFILETIME)&elapsed);
      elapsed.QuadPart -= theStats->seServer.liStartTime.QuadPart;
      elapsed.QuadPart /= 100000i64;
   }
   else
   {
      elapsed.LowPart = 0;
   }

   value->asnType = ASN_GAUGE32;
   value->asnValue.gauge = elapsed.LowPart;
}

VOID
WINAPI
GetServerResetTime(
    OUT AsnAny* value
    )
{
   LARGE_INTEGER elapsed;

   if (theStats->seServer.liResetTime.QuadPart)
   {
      GetSystemTimeAsFileTime((LPFILETIME)&elapsed);
      elapsed.QuadPart -= theStats->seServer.liResetTime.QuadPart;
      elapsed.QuadPart /= 100000i64;
   }
   else
   {
      elapsed.LowPart = 0;
   }

   value->asnType = ASN_GAUGE32;
   value->asnValue.gauge = elapsed.LowPart;
}

extern "C"
SC_HANDLE
GetServiceHandle( VOID )
{
   static SC_HANDLE scm, service;

   if (!service)
   {
      if (!scm)
      {
         scm = OpenSCManager(NULL, NULL, GENERIC_READ);
      }

      service = OpenServiceW(
                    scm,
                    IASServiceName,
                    SERVICE_QUERY_STATUS |
                    SERVICE_START |
                    SERVICE_USER_DEFINED_CONTROL
                    );
   }

   return service;
}

VOID
WINAPI
GetServerConfigReset(
    OUT AsnAny* value
    )
{
   value->asnType = ASN_INTEGER32;
   value->asnValue.number = 1;

   SERVICE_STATUS status;
   if (QueryServiceStatus(GetServiceHandle(), &status))
   {
      switch (status.dwCurrentState)
      {
         case SERVICE_START_PENDING:
            value->asnValue.number = 3;
            break;

         case SERVICE_RUNNING:
            value->asnValue.number = 4;
      }
   }
}

AsnInteger32
WINAPI
SetServerConfigReset(
    IN AsnAny* value
    )
{
   static BOOL allowSet, initialized;

   if (!initialized)
   {
      LONG status;
      HKEY hKey;
      status = RegOpenKeyW(
                   HKEY_LOCAL_MACHINE,
                   L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
                   &hKey
                   );
      if (status == NO_ERROR)
      {
         DWORD type, data(0), cbData(sizeof(data));
         status = RegQueryValueExW(
                      hKey,
                      L"Allow SNMP Set",
                      NULL,
                      &type,
                      (LPBYTE)&data,
                      &cbData
                      );
         if (status == NO_ERROR && type == REG_DWORD && data > 0)
         {
            allowSet = TRUE;
         }

         RegCloseKey(hKey);
      }

      initialized = TRUE;
   }

   if (!allowSet)
   {
      return SNMP_ERRORSTATUS_AUTHORIZATIONERROR;
   }

   if (value->asnType != ASN_INTEGER32)
   {
      return SNMP_ERRORSTATUS_WRONGTYPE;
   }

   if (value->asnValue.number != 2)
   {
      return SNMP_ERRORSTATUS_WRONGVALUE;
   }

   SC_HANDLE service = GetServiceHandle();
   if (!service)
   {
      return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
   }

   SERVICE_STATUS status;
   if (StartService(service, 0, NULL) || ControlService(service, 128, &status))
   {
      return SNMP_ERRORSTATUS_NOERROR;
   }

   return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
}

VOID
WINAPI
GetTotalCounter(
    IN RadiusClientCounter counter,
    OUT AsnAny* value
    )
{
   value->asnType = ASN_COUNTER32;
   value->asnValue.counter = 0;

   for (DWORD i = 0; i < theStats->dwNumClients; ++i)
   {
      value->asnValue.counter += theStats->ceClients[i].dwCounters[counter];
   }
}

VOID
WINAPI
GetServerCounter(
    IN RadiusServerCounter counter,
    OUT AsnAny* value
    )
{
   value->asnType = ASN_COUNTER32;
   value->asnValue.counter = theStats->seServer.dwCounters[counter];
}

VOID
WINAPI
GetClientAddress(
    IN UINT client,
    OUT AsnAny* value
    )
{
   value->asnType = ASN_IPADDRESS;
   value->asnValue.string.stream = (PBYTE)SnmpUtilMemAlloc(4);

   if (value->asnValue.string.stream)
   {
      IASInsertDWORD(value->asnValue.string.stream,
                     theStats->ceClients[client].dwAddress);

      value->asnValue.string.length  = 4;
      value->asnValue.string.dynamic = TRUE;
   }
   else
   {
      value->asnValue.string.length = 0;
      value->asnValue.string.dynamic = FALSE;
   }
}

VOID
WINAPI
GetClientIdentity(
    IN UINT client,
    OUT AsnAny* value
    )
{
   value->asnType = ASN_OCTETSTRING;
   value->asnValue.string.stream  = NULL;
   value->asnValue.string.length  = 0;
   value->asnValue.string.dynamic = FALSE;
}

VOID
WINAPI
GetClientCounter(
    IN UINT client,
    IN RadiusClientCounter counter,
    OUT AsnAny* value
    )
{
   value->asnType = ASN_COUNTER32;
   value->asnValue.counter = theStats->ceClients[client].dwCounters[counter];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\system\perfmon\snmpoid.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    snmpoid.h
//
// SYNOPSIS
//
//    Declares the class SnmpOid.
//
// MODIFICATION HISTORY
//
//    09/10/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SNMPOID_H_
#define _SNMPOID_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <snmp.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SnmpOid
//
// DESCRIPTION
//
//    Wrapper around an AsnObjectIdentifier struct.
//
///////////////////////////////////////////////////////////////////////////////
class SnmpOid
{
public:
   // Constructor.
   SnmpOid(AsnObjectIdentifier& a) throw ()
      : oid(a)
   { }

   // Assignment operator.
   SnmpOid& operator=(const AsnObjectIdentifier& a);

   // Returns the number of ID's forming the OID.
   ULONG length() const throw ()
   { return oid.idLength; }

   // Access an individual ID. Count is from the back. Does not check for
   // underflow.
   const UINT id(UINT pos) const throw ()
   { return oid.ids[oid.idLength - 1 - pos]; }
   UINT& id(UINT pos) throw ()
   { return oid.ids[oid.idLength - 1 - pos]; }

   // Returns true if this is a child of 'parent'.
   bool isChildOf(const AsnObjectIdentifier& parent) const throw ();

   // Changes the length of the OID.
   void resize(UINT newLength);

   // Cast operators allows this to be used with C API's.
   operator AsnObjectIdentifier*() const throw ()
   { return const_cast<AsnObjectIdentifier*>(&oid); }
   operator AsnObjectIdentifier&() const throw ()
   { return const_cast<AsnObjectIdentifier&>(oid); }

   // Comparison operators.
   bool SnmpOid::operator<(const AsnObjectIdentifier& a) const throw ()
   { return SnmpUtilOidCmp(*this, const_cast<AsnObjectIdentifier*>(&a)) <  0; }

   bool SnmpOid::operator<=(const AsnObjectIdentifier& a) const throw ()
   { return SnmpUtilOidCmp(*this, const_cast<AsnObjectIdentifier*>(&a)) <= 0; }

   bool SnmpOid::operator==(const AsnObjectIdentifier& a) const throw ()
   { return SnmpUtilOidCmp(*this, const_cast<AsnObjectIdentifier*>(&a)) == 0; }

   bool SnmpOid::operator>=(const AsnObjectIdentifier& a) const throw ()
   { return SnmpUtilOidCmp(*this, const_cast<AsnObjectIdentifier*>(&a)) >= 0; }

   bool SnmpOid::operator>(const AsnObjectIdentifier& a) const throw ()
   { return SnmpUtilOidCmp(*this, const_cast<AsnObjectIdentifier*>(&a)) >  0; }

protected:
   AsnObjectIdentifier& oid;

private:
   // Not implemented.
   SnmpOid(const SnmpOid&);
};

#endif  // _SNMPOID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\arapio.h ===
/********************************************************************/
/**               Copyright(c) 1996 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    arapio.h
//
// Description: Contains all the defines, macros, structures that are needed
//              for the ioctl interface between arap and the stack
//
// History:     Sep 11, 1996    Shirish Koti     Created original version.
//
//***



// range 0x800-0xfff is for private ioctls: pick something!
#define ARAP_IOCTL_BASE 0x900

#define ARAP_CTL(_req_, _method_)   CTL_CODE( FILE_DEVICE_NETWORK,  \
                                    _req_ + ARAP_IOCTL_BASE,        \
                                    _method_,                       \
                                    FILE_ANY_ACCESS )

//
// ioctl codes issued to the stack
//
#define IOCTL_ARAP_START                    ARAP_CTL( 1,  METHOD_BUFFERED)
#define IOCTL_ARAP_EXCHANGE_PARMS           ARAP_CTL( 2,  METHOD_BUFFERED)
#define IOCTL_ARAP_SETUP_CONNECTION         ARAP_CTL( 3,  METHOD_BUFFERED)
#define IOCTL_ARAP_GET_ZONE_LIST            ARAP_CTL( 4,  METHOD_BUFFERED)
#define IOCTL_ARAP_MNP_CONN_INITIATE        ARAP_CTL( 5,  METHOD_BUFFERED)
#define IOCTL_ARAP_MNP_CONN_RESPOND         ARAP_CTL( 6,  METHOD_BUFFERED)
#define IOCTL_ARAP_GET_ADDR                 ARAP_CTL( 7,  METHOD_BUFFERED)
#define IOCTL_ARAP_CONNECTION_UP            ARAP_CTL( 8,  METHOD_BUFFERED)
#define IOCTL_ARAP_SEND                     ARAP_CTL( 9,  METHOD_BUFFERED)
#define IOCTL_ARAP_RECV                     ARAP_CTL( 10, METHOD_BUFFERED)
#define IOCTL_ARAP_SELECT                   ARAP_CTL( 11, METHOD_BUFFERED)
#define IOCTL_ARAP_GET_STATS                ARAP_CTL( 12, METHOD_BUFFERED)
#define IOCTL_ARAP_DISCONNECT               ARAP_CTL( 13, METHOD_BUFFERED)
#define IOCTL_ARAP_CONTINUE_SHUTDOWN        ARAP_CTL( 14, METHOD_BUFFERED)
#define IOCTL_ARAP_SNIFF_PKTS               ARAP_CTL( 15, METHOD_BUFFERED)
#define IOCTL_ATCP_SETUP_CONNECTION         ARAP_CTL( 16, METHOD_BUFFERED)
#define IOCTL_ATCP_SUPPRESS_BCAST           ARAP_CTL( 17, METHOD_BUFFERED)
#define IOCTL_ATCP_CLOSE_CONNECTION         ARAP_CTL( 18, METHOD_BUFFERED)
#define IOCTL_ARAP_END                      ARAP_CTL( 19, METHOD_BUFFERED)

//
//  0x122404  IOCTL_ARAP_START
//  0x122408  IOCTL_ARAP_EXCHANGE_PARMS
//  0x12240c  IOCTL_ARAP_SETUP_CONNECTION
//  0x122410  IOCTL_ARAP_GET_ZONE_LIST
//  0x122414  IOCTL_ARAP_MNP_CONN_INITIATE
//  0x122418  IOCTL_ARAP_MNP_CONN_RESPOND
//  0x12241c  IOCTL_ARAP_GET_ADDR
//  0x122420  IOCTL_ARAP_CONNECTION_UP
//  0x122424  IOCTL_ARAP_SEND
//  0x122428  IOCTL_ARAP_RECV
//  0x12242c  IOCTL_ARAP_SELECT
//  0x122430  IOCTL_ARAP_GET_STATS
//  0x122434  IOCTL_ARAP_DISCONNECT
//  0x122438  IOCTL_ARAP_CONTINUE_SHUTDOWN
//  0x12243c  IOCTL_ARAP_SNIFF_PKTS
//  0x122440  IOCTL_ATCP_SETUP_CONNECTION
//  0x122444  IOCTL_ATCP_SUPPRESS_BCAST
//  0x122448  IOCTL_ATCP_CLOSE_CONNECTION
//  0x12244c  IOCTL_ARAP_END

//
// Error codes used by the various ARAP components
//
#define ARAPERRBASE                     40000
#define ARAPERR_NO_ERROR                0
#define ARAPERR_PENDING                 (ARAPERRBASE + 1)
#define ARAPERR_CANNOT_OPEN_STACK       (ARAPERRBASE + 2)
#define ARAPERR_OUT_OF_RESOURCES        (ARAPERRBASE + 3)
#define ARAPERR_SEND_FAILED             (ARAPERRBASE + 4)
#define ARAPERR_LSA_ERROR               (ARAPERRBASE + 5)
#define ARAPERR_PASSWD_NOT_AVAILABLE    (ARAPERRBASE + 6)
#define ARAPERR_NO_DIALIN_PERMS         (ARAPERRBASE + 7)
#define ARAPERR_AUTH_FAILURE            (ARAPERRBASE + 8)
#define ARAPERR_PASSWORD_TOO_LONG       (ARAPERRBASE + 9)
#define ARAPERR_COULDNT_GET_SAMHANDLE   (ARAPERRBASE + 10)
#define ARAPERR_BAD_PASSWORD            (ARAPERRBASE + 11)
#define ARAPERR_SET_PASSWD_FAILED       (ARAPERRBASE + 12)
#define ARAPERR_CLIENT_OUT_OF_SYNC      (ARAPERRBASE + 13)
#define ARAPERR_IOCTL_FAILURE           (ARAPERRBASE + 14)
#define ARAPERR_UNEXPECTED_RESPONSE     (ARAPERRBASE + 15)
#define ARAPERR_BAD_VERSION             (ARAPERRBASE + 16)
#define ARAPERR_BAD_FORMAT              (ARAPERRBASE + 17)
#define ARAPERR_BUF_TOO_SMALL           (ARAPERRBASE + 18)
#define ARAPERR_FATAL_ERROR             (ARAPERRBASE + 19)
#define ARAPERR_TIMEOUT                 (ARAPERRBASE + 20)
#define ARAPERR_IRP_IN_PROGRESS         (ARAPERRBASE + 21)
#define ARAPERR_DISCONNECT_IN_PROGRESS  (ARAPERRBASE + 22)
#define ARAPERR_LDISCONNECT_COMPLETE    (ARAPERRBASE + 23)
#define ARAPERR_RDISCONNECT_COMPLETE    (ARAPERRBASE + 24)
#define ARAPERR_NO_SUCH_CONNECTION      (ARAPERRBASE + 25)
#define ARAPERR_STACK_NOT_UP            (ARAPERRBASE + 26)
#define ARAPERR_NO_NETWORK_ADDR         (ARAPERRBASE + 27)
#define ARAPERR_BAD_NETWORK_RANGE       (ARAPERRBASE + 28)

#define ARAPERR_INVALID_STATE           (ARAPERRBASE + 29)
#define ARAPERR_CONN_INACTIVE           (ARAPERRBASE + 30)
#define ARAPERR_DATA                    (ARAPERRBASE + 31)
#define ARAPERR_STACK_SHUTDOWN_REQUEST  (ARAPERRBASE + 32)
#define ARAPERR_SHUTDOWN_COMPLETE       (ARAPERRBASE + 33)
#define ARAPERR_STACK_ROUTER_NOT_UP     (ARAPERRBASE + 34)
#define ARAPERR_STACK_PNP_IN_PROGRESS   (ARAPERRBASE + 35)
#define ARAPERR_STACK_IS_NOT_ACTIVE     (ARAPERRBASE + 35)
#define ARAPERR_STACK_IS_ACTIVE         (ARAPERRBASE + 36)


//
// max LTM can be 618 bytes, min is 604: let's be conservative on the way out,
// and liberal on incoming packets
//
#define ARAP_MAXPKT_SIZE_INCOMING   618
#define ARAP_MAXPKT_SIZE_OUTGOING   604


#define MAX_DOMAIN_LEN     15

#define MAX_ZONE_LENGTH     32
#define MAX_ENTITY_LENGTH   32

#define ZONESTR_LEN  MAX_ZONE_LENGTH+2
#define NAMESTR_LEN  MAX_ENTITY_LENGTH+2


#define MNP_SYN             0x16
#define MNP_DLE             0x10
#define MNP_SOH             0x1
#define MNP_ESC             0x1B
#define MNP_STX             0x2
#define MNP_ETX             0x3

#define ARAP_SNIFF_BUFF_SIZE    4080

typedef struct _NET_ADDR
{
    USHORT      ata_Network;
    USHORT      ata_Node;
} NET_ADDR, *PNET_ADDR;


typedef struct _NETWORKRANGE
{
    USHORT  LowEnd;
    USHORT  HighEnd;
} NETWORKRANGE, *PNETWORKRANGE;


typedef struct _HIDZONES
{
    DWORD       BufSize;            // how big is the buffer containing zone names
    DWORD       NumZones;           // number of zones "disallowed" for dial-in users
    UCHAR       ZonesNames[1];      // list of zones "disallowed" for dial-in users
} HIDZONES, *PHIDZONES;


typedef struct _ARAP_PARMS
{
    DWORD           LowVersion;
    DWORD           HighVersion;
    DWORD           accessFlags;        // GuestAccess?|ManualPwd?|MultiPort?
    DWORD           NumPorts;           // number of ras ports on the system
    DWORD           UserCallCBOk;       // user can request callback
    DWORD           CallbackDelay;      // seconds to wait before callback
    DWORD           PasswordRetries;    // allow client to try pwd these many times
    DWORD           MinPwdLen;          // min length of the pwd that server needs
    DWORD           MnpInactiveTime;    // seconds of idle time before disconnect
    DWORD           MaxLTFrames;        // max LT frames outstanding (rcv window)

    BOOLEAN         V42bisEnabled;      //
    BOOLEAN         SmartBuffEnabled;   //
    BOOLEAN         NetworkAccess;      // access to network or only this server
    BOOLEAN         DynamicMode;        // we want the stack to get node address
    NETWORKRANGE    NetRange;

    BOOLEAN         SniffMode;          // give all pkts to ARAP to "sniff"

    DWORD           NumZones;           // # of zones (info provided by the stack)
    NET_ADDR        ServerAddr;         // atalk addr of the srvr (on default node)
    UCHAR           ServerZone[ZONESTR_LEN]; // space padded Pascal string
    UCHAR           ServerName[NAMESTR_LEN]; // space padded Pascal string
    WCHAR           ServerDomain[MAX_DOMAIN_LEN+1];
    UNICODE_STRING  GuestName;

} ARAP_PARMS, *PARAP_PARMS;



typedef struct _EXCHGPARMS
{
    DWORD       StatusCode;
    ARAP_PARMS  Parms;
    HIDZONES    HidZones;
} EXCHGPARMS, *PEXCHGPARMS;


typedef struct _ARAP_BIND_INFO
{
    IN  DWORD           BufLen;          // size of this structure
    IN  PVOID           pDllContext;
    IN  BOOLEAN         fThisIsPPP;      // TRUE if PPP conn, FALSE if ARAP
    IN  NET_ADDR        ClientAddr;      // network addr of the remote client
    OUT PVOID           AtalkContext;
    OUT DWORD           ErrorCode;

} ARAP_BIND_INFO, *PARAP_BIND_INFO;


typedef struct _ARAP_SEND_RECV_INFO
{
    PVOID               AtalkContext;
    PVOID               pDllContext;
    NET_ADDR            ClientAddr;
    DWORD               IoctlCode;
    DWORD               StatusCode;     // returned by the stack
    DWORD               DataLen;
    BYTE                Data[1];

} ARAP_SEND_RECV_INFO, *PARAP_SEND_RECV_INFO;


typedef struct _ARAP_ZONE
{
    BYTE                ZoneNameLen;
    BYTE                ZoneName[1];
} ARAP_ZONE, *PARAP_ZONE;


typedef struct _ZONESTAT
{
    DWORD       BufLen;             // how big is this buffer
    DWORD       BytesNeeded;        // how many bytes are needed
    DWORD       StatusCode;         // returned by the stack
    DWORD       NumZones;           // number of zones (in this buffer)
    UCHAR       ZoneNames[1];       // Names of the zones (Pascal strings)
} ZONESTAT, *PZONESTAT;


typedef struct _STAT_INFO
{
    DWORD   BytesSent;
    DWORD   BytesRcvd;
    DWORD   FramesSent;
    DWORD   FramesRcvd;
    DWORD   BytesTransmittedUncompressed;
    DWORD   BytesReceivedUncompressed;
    DWORD   BytesTransmittedCompressed;
    DWORD   BytesReceivedCompressed;

} STAT_INFO, *PSTAT_INFO;



typedef struct _ATCPINFO
{
    NET_ADDR    ServerAddr;
    NET_ADDR    DefaultRouterAddr;
    UCHAR       ServerZoneName[ZONESTR_LEN];

} ATCPINFO, *PATCPINFO;

typedef struct _ATCP_SUPPRESS_INFO
{
    BOOLEAN     SuppressRtmp;
    BOOLEAN     SuppressAllBcast;

} ATCP_SUPPRESS_INFO, *PATCP_SUPPRESS_INFO;


#define ARAP_SNIFF_SIGNATURE    0xfacebead

typedef struct _SNIFF_INFO
{
    DWORD   Signature;
    DWORD   TimeStamp;
    USHORT  Location;
    USHORT  FrameLen;
    BYTE    Frame[1];
} SNIFF_INFO, *PSNIFF_INFO;


//
// states for the Arap-Atcp engine
//
#define  ENGINE_UNBORN              0   // nothing happened yet
#define  ENGINE_DLL_ATTACHED        1   // dll loaded, and init for globals done
#define  ENGINE_INIT_PENDING        2   // engine init work in progress
#define  ENGINE_INIT_DONE           3   // engine init completed
#define  ENGINE_STACK_OPEN_PENDING  4   // appletalk stack open is pending
#define  ENGINE_STACK_OPENED        5   // appletalk stack has been opened
#define  ENGINE_CONFIGURE_PENDING   6   // configuring appletalk stack in progress
#define  ENGINE_RUNNING             7   // ready to accept arap connections
#define  ENGINE_PNP_PENDING         8   // engine is undergoing a PnP change
#define  ENGINE_STOPPING            9   // engine's stopping

//
// exports from rasarap.lib, used by ATCP
//
DWORD
ArapAtcpGetState(
    IN  VOID
);

HANDLE
ArapAtcpGetHandle(
    IN  VOID
);

DWORD
ArapAtcpPnPNotify(
    IN  VOID
);

DWORD
ArapAtcpStartEngine(
    IN  VOID
);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\arpinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** ARPINFO.H - Information definitions for features specific to ARP.
//
// This file contains all of the definitions for ARP information that is
// not part of the standard MIB (i.e. ProxyARP). The objects defines in
// this file are all in the INFO_CLASS_IMPLEMENTATION class.


#ifndef	ARPINFO_INCLUDED
#define	ARPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of a proxy ARP entry.

typedef struct ProxyArpEntry {
	ulong		pae_status;					// Status of the entry.
	ulong		pae_addr;					// Proxy arp address.
	ulong		pae_mask;					// Mask to use for this address.
} ProxyArpEntry;

#define	PAE_STATUS_VALID		1			// The P-ARP entry is valid.
#define	PAE_STATUS_INVALID		2			// The P-ARP entry is invalid.


#define	AT_ARP_PARP_COUNT_ID	1			// ID to use for finding the
											// number of proxy ARP entries
											// available.
#define	AT_ARP_PARP_ENTRY_ID	0x101		// ID to use for querying/setting
											// proxy ARP entries.
#endif // ARPINFO_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\cmdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C M D E F S . H 
//
//  Contents:   Shared #defines and such between CM (Connection Manager)
//              and the network connections folder, among others
//
//  Notes:      
//
//  Author:     jeffspr   15 Jan 1999
//
//----------------------------------------------------------------------------

#ifndef _CMDEFS_H_
#define _CMDEFS_H_

// Don't change these randomly. These are based on the max temp file name
// prefix in GetTempFileName
//
#define CM_PBK_FILTER_PREFIX        TEXT("_CM")

#endif // _CMDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\beacon.h ===
#pragma once

#define REGKEY_SHAREDACCESSCLIENTKEYPATH L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection"
#define REGVAL_SHAREDACCESSCLIENTENABLECONTROL L"EnableControl"

HRESULT WINAPI InitializeBeaconSvr();
HRESULT WINAPI TerminateBeaconSvr();

HRESULT WINAPI StartBeaconSvr();
HRESULT WINAPI StopBeaconSvr();
HRESULT WINAPI SignalBeaconSvr();
HRESULT WINAPI FireNATEvent_PublicIPAddressChanged(void);
HRESULT WINAPI FireNATEvent_PortMappingsChanged(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\cpolstor.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  IPSEC Policy Storage Component
//  Contract Category: Directory Schema 
//	Copyright (C) 1997 Cisco Systems, Inc. All rights reserved.
//
//  File:       cpolstor.h
//
//  Contents:   C interface for access to Polstore DLL
//
//  Notes:      
/////////////////////////////////////////////////////////////////////////////
#ifndef __C_POLICY_STORAGE_H__
#define __C_POLICY_STORAGE_H__

#include "polguids.h"

// This is a structure that has the policy's name and guid in it
struct C_IPSEC_POLICY_INFO
{
    TCHAR szPolicyName[MAX_PATH];
    TCHAR szPolicyDescription[MAX_PATH];
    GUID  guidPolicyId;

    C_IPSEC_POLICY_INFO * pNextPolicyInfo;
};

STDAPI HrGetLocalIpSecPolicyList(C_IPSEC_POLICY_INFO ** ppPolicyInfoList, C_IPSEC_POLICY_INFO ** ppActivePolicyInfo);

STDAPI HrFreeLocalIpSecPolicyList(C_IPSEC_POLICY_INFO* pPolicyInfoList);

STDAPI HrSetAssignedLocalPolicy(GUID* pActivePolicyGuid);

//HrIsLocalPolicyAssigned() return values:
//	S_OK = Yes, local policy is assigned.
//  S_FALSE = No, local policy not assigned.
STDAPI HrIsLocalPolicyAssigned();

//HrIsDomainPolicyAssigned() return values:
//	S_OK = Yes, domain policy is assigned.
//  S_FALSE = No, domain policy not assigned.
STDAPI HrIsDomainPolicyAssigned();

STDAPI HrGetAssignedDomainPolicyName(LPTSTR strPolicyName, DWORD *pdwBufferSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ddipmcst.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    private\inc\ddipmcst.h

Abstract:

    Public IOCTLS and related structures for IP Multicasting
    See documentation for more details

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#ifndef __DDIPMCAST_H__
#define __DDIPMCAST_H__

#ifndef ANY_SIZE
#define ANY_SIZE    1
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Device Name - this string is the name of the device.  It is the name     //
// that should be passed to NtCreateFile when accessing the device.         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define DD_IPMCAST_DEVICE_NAME  L"\\Device\\IPMULTICAST"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Win32 Name - This is the (Unicode and NonUnicode) name exposed by Win32  //
// subsystem for the device. It is the name that should be passed to        //
// CreateFile(Ex) when opening the device.                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IPMCAST_NAME        L"\\\\.\\IPMULTICAST"
#define IPMCAST_NAME_NUC     "\\\\.\\IPMULTICAST"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IOCTL code definitions and related structures                            //
// All the IOCTLs are synchronous except for IOCTL_POST_NOTIFICATION        //
// All need need administrator privilege                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FSCTL_IPMCAST_BASE     FILE_DEVICE_NETWORK

#define _IPMCAST_CTL_CODE(function, method, access) \
                 CTL_CODE(FSCTL_IPMCAST_BASE, function, method, access)

#define MIN_IPMCAST_CODE        0

#define SET_MFE_CODE            (MIN_IPMCAST_CODE)
#define GET_MFE_CODE            (SET_MFE_CODE           + 1)
#define DELETE_MFE_CODE         (GET_MFE_CODE           + 1)
#define SET_TTL_CODE            (DELETE_MFE_CODE        + 1)
#define GET_TTL_CODE            (SET_TTL_CODE           + 1)
#define POST_NOTIFICATION_CODE  (GET_TTL_CODE           + 1)
#define START_STOP_CODE         (POST_NOTIFICATION_CODE + 1)
#define SET_IF_STATE_CODE       (START_STOP_CODE        + 1)

#define MAX_IPMCAST_CODE        (SET_IF_STATE_CODE)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to set an MFE.                                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IOCTL_IPMCAST_SET_MFE \
    _IPMCAST_CTL_CODE(SET_MFE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

//
// WARNING WARNING!!!
// The following structures are also called MIB_XXX in iprtrmib.h. There
// is code in routing\ip\rtrmgr\access.c which assumes the structures are
// the same. If this ever changes, the code in access.c needs to be fixed
//

typedef struct _IPMCAST_OIF
{
    IN  DWORD   dwOutIfIndex;
    IN  DWORD   dwNextHopAddr;
    IN  DWORD   dwDialContext;
    IN  DWORD   dwReserved;
}IPMCAST_OIF, *PIPMCAST_OIF;

//
// This must be the same as INVALID_WANARP_CONTEXT
//

#define INVALID_DIAL_CONTEXT    0x00000000

typedef struct _IPMCAST_MFE
{
    IN  DWORD   dwGroup;
    IN  DWORD   dwSource;
    IN  DWORD   dwSrcMask;
    IN  DWORD   dwInIfIndex;
    IN  ULONG   ulNumOutIf;
    IN  ULONG   ulTimeOut;
    IN  DWORD   fFlags;
    IN  DWORD   dwReserved;
    IN  IPMCAST_OIF rgioOutInfo[ANY_SIZE];
}IPMCAST_MFE, *PIPMCAST_MFE;

#define SIZEOF_BASIC_MFE    \
    (ULONG)(FIELD_OFFSET(IPMCAST_MFE, rgioOutInfo[0]))

#define SIZEOF_MFE(X)       \
    (SIZEOF_BASIC_MFE + ((X) * sizeof(IPMCAST_OIF)))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  This IOCTL is used to retrieve an MFE and all the related statistics    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPMCAST_GET_MFE \
    _IPMCAST_CTL_CODE(GET_MFE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _IPMCAST_OIF_STATS
{
    OUT DWORD   dwOutIfIndex;
    OUT DWORD   dwNextHopAddr;
    OUT DWORD   dwDialContext;
    OUT ULONG   ulTtlTooLow;
    OUT ULONG   ulFragNeeded;
    OUT ULONG   ulOutPackets;
    OUT ULONG   ulOutDiscards;
}IPMCAST_OIF_STATS, *PIPMCAST_OIF_STATS;

typedef struct _IPMCAST_MFE_STATS
{
    IN  DWORD   dwGroup;
    IN  DWORD   dwSource;
    IN  DWORD   dwSrcMask;
    OUT DWORD   dwInIfIndex;
    OUT ULONG   ulNumOutIf;
    OUT ULONG   ulInPkts;
    OUT ULONG   ulInOctets;
    OUT ULONG   ulPktsDifferentIf;
    OUT ULONG   ulQueueOverflow;
    OUT ULONG   ulUninitMfe;
    OUT ULONG   ulNegativeMfe;
    OUT ULONG   ulInDiscards;
    OUT ULONG   ulInHdrErrors;
    OUT ULONG   ulTotalOutPackets;

    OUT IPMCAST_OIF_STATS   rgiosOutStats[ANY_SIZE];
}IPMCAST_MFE_STATS, *PIPMCAST_MFE_STATS;

#define SIZEOF_BASIC_MFE_STATS    \
    (ULONG)(FIELD_OFFSET(IPMCAST_MFE_STATS, rgiosOutStats[0]))

#define SIZEOF_MFE_STATS(X)       \
    (SIZEOF_BASIC_MFE_STATS + ((X) * sizeof(IPMCAST_OIF_STATS)))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to delete an MFE.                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPMCAST_DELETE_MFE \
    _IPMCAST_CTL_CODE(DELETE_MFE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _IPMCAST_DELETE_MFE
{
    IN  DWORD   dwGroup;
    IN  DWORD   dwSource;
    IN  DWORD   dwSrcMask;
}IPMCAST_DELETE_MFE, *PIPMCAST_DELETE_MFE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL set the TTL scope for an interface.  If a packet has a lower   //
// TTL than the scope, it will be dropped                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPMCAST_SET_TTL \
    _IPMCAST_CTL_CODE(SET_TTL_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define IOCTL_IPMCAST_GET_TTL \
    _IPMCAST_CTL_CODE(GET_TTL_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)


typedef struct _IPMCAST_IF_TTL
{
    IN  OUT DWORD   dwIfIndex;
    IN  OUT BYTE    byTtl;
}IPMCAST_IF_TTL, *PIPMCAST_IF_TTL;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to post a notification to the Multicast Driver.  This     //
// is the only asynchronous IOCTL.  When the IOCTL completes, the driver    //
// returns a message to the user mode component. The message type (dwEvent) //
// and the corresponding data is defined below                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IPMCAST_RCV_PKT_MSG         0
#define IPMCAST_DELETE_MFE_MSG      1
#define IPMCAST_WRONG_IF_MSG        2

#define IOCTL_IPMCAST_POST_NOTIFICATION \
    _IPMCAST_CTL_CODE(POST_NOTIFICATION_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define PKT_COPY_SIZE           256

typedef struct _IPMCAST_PKT_MSG
{
	OUT	DWORD	dwInIfIndex;
    OUT DWORD   dwInNextHopAddress;
    OUT ULONG   cbyDataLen;
	OUT	BYTE    rgbyData[PKT_COPY_SIZE];
}IPMCAST_PKT_MSG, *PIPMCAST_PKT_MSG;

#define SIZEOF_PKT_MSG(p)       \
    (FIELD_OFFSET(IPMCAST_PKT_MSG, rgbyData) + (p)->cbyDataLen)

//
// Since the msg is big because of packet msg, we may as well
// pack more than one MFE into the delete msg
// 

#define NUM_DEL_MFES        PKT_COPY_SIZE/sizeof(IPMCAST_DELETE_MFE)

typedef struct _IPMCAST_MFE_MSG
{
    OUT ULONG               ulNumMfes;
    OUT IPMCAST_DELETE_MFE  idmMfe[NUM_DEL_MFES];
}IPMCAST_MFE_MSG, *PIPMCAST_MFE_MSG;

#define SIZEOF_MFE_MSG(p)       \
    (FIELD_OFFSET(IPMCAST_MFE_MSG, idmMfe) + ((p)->ulNumMfes * sizeof(IPMCAST_DELETE_MFE)))

typedef struct _IPMCAST_NOTIFICATION
{
	OUT	DWORD   dwEvent;
    
    union
	{
		IPMCAST_PKT_MSG ipmPkt;
		IPMCAST_MFE_MSG immMfe;
	};
    
}IPMCAST_NOTIFICATION, *PIPMCAST_NOTIFICATION;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to start or stop multicasting. The corresponding buffer   //
// is a DWORD which is set to 1 to start the driver and to 0 to stop it     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPMCAST_START_STOP \
    _IPMCAST_CTL_CODE(START_STOP_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to set the state on an interface.                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPMCAST_SET_IF_STATE  \
    _IPMCAST_CTL_CODE(SET_IF_STATE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)


typedef struct _IPMCAST_IF_STATE
{
    IN  DWORD   dwIfIndex;
    IN  BYTE    byState;

}IPMCAST_IF_STATE, *PIPMCAST_IF_STATE;

#endif // __DDIPMCST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\dhcpupg.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dhcpupg.c

Abstract:

    Upgrade APIs exported

Environment:

    This header file contains APIs that are present in a library.

--*/

#ifndef _DHCPUPG_
#define _DHCPUPG_

#ifdef __cplusplus
extern "C" {
#endif

#if _MSC_VER > 1000
#pragma once
#endif
    
typedef struct _DHCP_RECORD {
    BOOL fMcast;
    union _INFO {
        struct _DHCP_INFO {
            DWORD Address, Mask;
            BYTE HwLen;
            LPBYTE HwAddr;
            WCHAR UNALIGNED *Name, *Info;
            FILETIME ExpTime;
            BYTE State, Type;
        } Dhcp;
        
        struct _MCAST_INFO {
            DWORD Address, ScopeId;
            BYTE HwLen;
            LPBYTE ClientId;
            WORD UNALIGNED *Info;
            FILETIME Start, End;
            BYTE State;
        } Mcast;
    } Info;

} DHCP_RECORD, *PDHCP_RECORD;

typedef DWORD (__stdcall *DHCP_ADD_RECORD_ROUTINE) (
    IN PDHCP_RECORD Rec
    );

DWORD __stdcall
DhcpUpgConvertTempToDhcpDb(
    IN DHCP_ADD_RECORD_ROUTINE AddRec
    );

DWORD __stdcall
DhcpUpgConvertDhcpDbToTemp(
    VOID
    );

DWORD __stdcall
DhcpUpgCleanupDhcpTempFiles(
    VOID
    );

DWORD __stdcall
DhcpUpgGetLastError(
    VOID
    );
    
#ifdef __cplusplus
}
#endif

#endif _DHCPUPG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\atmarpif.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	atmarpif.h

Abstract:

	This defines structures common to the ATM ARP Client and user
	mode programs that interact with it.

Environment:

	Kernel/User mode

Revision History:

	ArvindM		Jan 9, 98			Created

--*/

#ifndef	__ATMARPC_IF_H
#define __ATMARPC_IF_H

#define ATMARPC_INFO_VERSION						1



//
// PnP reconfiguration structure. This is used to pass indications of
// configuration changes from a user program to the ATMARPC
// protocol. This indication is passed on an Adapter binding,
// and carries the registry key of the Interface affected by the
// configuration change, e.g. on NT 5.0:
//
//   Tcpip\Parameters\Interfaces\{85F11433-3042-11D1-A9E2-0000D10F5214}
//
typedef struct _ATMARPC_PNP_RECONFIG_REQUEST
{
	ULONG				Version;		// Set to ATMARPC_RECONFIG_VERSION
	ULONG				OpType;			// Defined below.
	ULONG				Flags;			// Defined below.
	ULONG				IfKeyOffset;	// Offset from the beginning of this
										// struct to counted Unicode string
										// identifying the affected interface

} ATMARPC_PNP_RECONFIG_REQUEST, *PATMARPC_PNP_RECONFIG_REQUEST;


//
// Reconfig version number.
//
#define ATMARPC_RECONFIG_VERSION					1

//
// Reconfig op types.
//
#define ATMARPC_RECONFIG_OP_ADD_INTERFACE			1
#define ATMARPC_RECONFIG_OP_DEL_INTERFACE			2
#define ATMARPC_RECONFIG_OP_MOD_INTERFACE			3


//
// Bit definitions for Flags in the reconfig structure.
// If an Interface configuration is being modified, these bits
// identify the parameters that have changed.
//
#define ATMARPC_RECONFIG_FLAG_ARPS_LIST_CHANGED		0x00000001
#define ATMARPC_RECONFIG_FLAG_MARS_LIST_CHANGED		0x00000002
#define ATMARPC_RECONFIG_FLAG_MTU_CHANGED			0x00000004
#define ATMARPC_RECONFIG_FLAG_PVC_MODE_CHANGED		0x00000008


#endif // __ATMARPC_IF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ddwanarp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ddwanarp.h

Abstract:

    

Revision History:

    Gurdeep Singh Pall          7/20/95  Created

--*/


#ifndef  __DDWANARP_H__
#define  __DDWANARP_H__

#ifndef ANY_SIZE
#define ANY_SIZE    1
#endif

#define WANARP_SERVICE_NAME_W       L"WANARP"
#define WANARP_SERVICE_NAME_A       "WANARP"
#define WANARP_SERVICE_NAME_T       TEXT("WANARP")

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Device Name - this string is the name of the device.  It is the name     //
// that should be passed to NtCreateFile when accessing the device.         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define DD_WANARP_DEVICE_NAME_W     L"\\Device\\WANARP"
#define DD_WANARP_DEVICE_NAME_A     "\\Device\\WANARP"
#define DD_WANARP_DEVICE_NAME_T     TEXT("\\Device\\WANARP")

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Win32 Name - This is the (Unicode and NonUnicode) name exposed by Win32  //
// subsystem for the device. It is the name that should be passed to        //
// CreateFile(Ex) when opening the device.                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define WANARP_DOS_NAME_W           L"\\\\.\\WANARP"
#define WANARP_DOS_NAME_A           "\\\\.\\WANARP"
#define WANARP_DOS_NAME_T           TEXT("\\\\.\\WANARP")

#define FILE_DEVICE_WANARP  0x00009001

#define WANARP_MAX_DEVICE_NAME_LEN  256


#define _WANARP_CTL_CODE(function, method, access) \
            CTL_CODE(FILE_DEVICE_WANARP, function, method, access)

#define MIN_WANARP_CODE             0

#define NOTIFICATION_CODE           (MIN_WANARP_CODE)
#define ADD_INTERFACE_CODE          (NOTIFICATION_CODE          + 1)
#define DELETE_INTERFACE_CODE       (ADD_INTERFACE_CODE         + 1)
#define CONNECT_FAILED_CODE         (DELETE_INTERFACE_CODE      + 1)
#define GET_IF_STATS_CODE           (CONNECT_FAILED_CODE        + 1)
#define DELETE_ADAPTERS_CODE        (GET_IF_STATS_CODE          + 1)
#define MAP_SERVER_ADAPTER_CODE     (DELETE_ADAPTERS_CODE       + 1)
#define QUEUE_CODE                  (MAP_SERVER_ADAPTER_CODE    + 1)

#define MAX_WANARP_CODE             (QUEUE_CODE                 + 1)


typedef enum _DEMAND_DIAL_EVENT
{

    DDE_CONNECT_INTERFACE       = 0,
    DDE_INTERFACE_CONNECTED     = 1,
    DDE_INTERFACE_DISCONNECTED  = 2,
    DDE_CALLOUT_LINKUP          = 3,
    DDE_CALLOUT_LINKDOWN        = 4,

}DEMAND_DIAL_EVENT, *PDEMAND_DIAL_EVENT;


//
// IOCTL_WANARP_NOTIFICATION
// For DEMAND_DIAL_CONNECT_INTERFACE WANARP fills in as much of the packet
// as can go into the following structure.  The ulPacketLength denotes the whole
// length of the packet and the consumer should copy out the 
// MIN(ulPacketLength, MAX_PACKET_COPY_SIZE);
//

#define IOCTL_WANARP_NOTIFICATION       \
    _WANARP_CTL_CODE(NOTIFICATION_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define MAX_PACKET_COPY_SIZE                128

#pragma warning(disable:4201)

typedef struct _WANARP_NOTIFICATION
{

    DEMAND_DIAL_EVENT   ddeEvent;

    DWORD               dwUserIfIndex;

    DWORD               dwAdapterIndex;

    union
    {
        struct
        {
            DWORD       dwPacketSrcAddr;
  
            DWORD       dwPacketDestAddr;

            ULONG       ulPacketLength;

            BYTE        byPacketProtocol;

            BYTE        rgbyPacket[MAX_PACKET_COPY_SIZE];
        };

        struct
        {
            DWORD       dwLocalAddr;

            DWORD       dwLocalMask;

            DWORD       dwRemoteAddr;

            DWORD       fDefaultRoute;

            WCHAR       rgwcName[WANARP_MAX_DEVICE_NAME_LEN + 2];
        };
    };

}WANARP_NOTIFICATION, *PWANARP_NOTIFICATION;

#pragma warning(default:4201)

//
// IOCTL_WANARP_ADD_INTERFACE
//

#define IOCTL_WANARP_ADD_INTERFACE      \
    _WANARP_CTL_CODE(ADD_INTERFACE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_ADD_INTERFACE_INFO
{

    IN  DWORD   dwUserIfIndex;

    IN  DWORD   bCallinInterface;

    OUT DWORD   dwAdapterIndex;

    OUT WCHAR   rgwcDeviceName[WANARP_MAX_DEVICE_NAME_LEN + 2];

}WANARP_ADD_INTERFACE_INFO, *PWANARP_ADD_INTERFACE_INFO;


//
// The user index can never be 0 (or NULL)
//

#define WANARP_INVALID_IFINDEX          0


//
// IOCTL_WANARP_DELETE_INTERFACE
//

#define IOCTL_WANARP_DELETE_INTERFACE      \
    _WANARP_CTL_CODE(DELETE_INTERFACE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_DELETE_INTERFACE_INFO
{
    IN  DWORD       dwUserIfIndex;

}WANARP_DELETE_INTERFACE_INFO, *PWANARP_DELETE_INTERFACE_INFO;

//
// IOCTL_WANARP_CONNECT_FAILED
//

#define IOCTL_WANARP_CONNECT_FAILED         \
    _WANARP_CTL_CODE(CONNECT_FAILED_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_CONNECT_FAILED_INFO
{
    IN  DWORD       dwUserIfIndex;

}WANARP_CONNECT_FAILED_INFO, *PWANARP_CONNECT_FAILED_INFO;

//
// IOCTL_WANARP_GET_IF_STATS
//

#define IOCTL_WANARP_GET_IF_STATS           \
    _WANARP_CTL_CODE(GET_IF_STATS_CODE,METHOD_BUFFERED,FILE_READ_ACCESS)

typedef struct _WANARP_GET_IF_STATS_INFO
{
    IN  DWORD       dwUserIfIndex;

    IFEntry         ifeInfo;

}WANARP_GET_IF_STATS_INFO, *PWANARP_GET_IF_STATS_INFO;


//
// IOCTL_WANARP_DELETE_ADAPTERS
//

#define IOCTL_WANARP_DELETE_ADAPTERS        \
    _WANARP_CTL_CODE(DELETE_ADAPTERS_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_DELETE_ADAPTERS_INFO
{
    //
    // IN:  Number of adapters to delete
    // OUT: If == IN, then number of adapters deleted
    //      If < IN, then number of adapters that can be deleted
    //

    IN OUT  ULONG   ulNumAdapters;

    OUT     GUID    rgAdapterGuid[ANY_SIZE];

}WANARP_DELETE_ADAPTERS_INFO, *PWANARP_DELETE_ADAPTERS_INFO;

//
// IOCTL_WANARP_MAP_SERVER_ADAPTER
//

#define IOCTL_WANARP_MAP_SERVER_ADAPTER     \
    _WANARP_CTL_CODE(MAP_SERVER_ADAPTER_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_MAP_SERVER_ADAPTER_INFO
{
    IN  DWORD   fMap;

    OUT DWORD   dwAdapterIndex;

}WANARP_MAP_SERVER_ADAPTER_INFO, *PWANARP_MAP_SERVER_ADAPTER_INFO;

//
// IOCTL_WANARP_QUEUE
//

#define IOCTL_WANARP_QUEUE                  \
    _WANARP_CTL_CODE(QUEUE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _WANARP_IF_INFO
{
    GUID        InterfaceGuid;
    DWORD       dwAdapterIndex;
    DWORD       dwLocalAddr;
    DWORD       dwLocalMask;
    DWORD       dwRemoteAddr;

}WANARP_IF_INFO, *PWANARP_IF_INFO;

typedef struct _WANARP_QUEUE_INFO
{
    IN  DWORD           fQueue;

    OUT ULONG           ulNumCallout;

    OUT WANARP_IF_INFO  rgIfInfo[ANY_SIZE];

}WANARP_QUEUE_INFO, *PWANARP_QUEUE_INFO;


//
// IP Struct passed up in lineup indication
//

typedef enum _DIAL_USAGE
{
    DU_CALLIN   = 0,
    DU_CALLOUT  = 1,
    DU_ROUTER   = 2

}DIAL_USAGE, *PDIAL_USAGE;


typedef struct _IP_WAN_LINKUP_INFO
{

    DIAL_USAGE  duUsage;

    DWORD       dwUserIfIndex;

    DWORD       dwLocalAddr;

    DWORD       dwLocalMask;

    DWORD       dwRemoteAddr;

    DWORD       fFilterNetBios;

    DWORD       fDefaultRoute;

}IP_WAN_LINKUP_INFO, *PIP_WAN_LINKUP_INFO;

#define WANARP_RECONFIGURE_VERSION      (DWORD)0x01

typedef enum _WANARP_RECONFIGURE_CODE
{
    WRC_ADD_INTERFACES = 1,
    WRC_TCP_WINDOW_SIZE_UPDATE = 2,
}WANARP_RECONFIGURE_CODE, *PWANARP_RECONFIGURE_CODE;

typedef struct _WANARP_RECONFIGURE_INFO
{
    //
    // Version of this request
    //

    DWORD                   dwVersion;

    //
    // Code, see above
    //

    WANARP_RECONFIGURE_CODE wrcOperation;
   
    //
    // Number of Guids in the array below
    //
 
    ULONG                   ulNumInterfaces;

    //
    // Guids themselves
    //

    GUID                    rgInterfaces[ANYSIZE_ARRAY];

}WANARP_RECONFIGURE_INFO, *PWANARP_RECONFIGURE_INFO;

#endif // _WANARPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\cxport.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */


//**    cxport.h - Common transport environment include file.
//
//  This file defines the structures and external declarations needed
//  to use the common transport environment.
//

#ifndef _CXPORT_H_INCLUDED_
#define _CXPORT_H_INCLUDED_

#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parentheses

//
// Typedefs used in this file
//
#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED  1

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#ifdef NT
//////////////////////////////////////////////////////////////////////////////
//
// Following are the NT environment definitions
//
//////////////////////////////////////////////////////////////////////////////

//
// Structure manipulation macros
//
#ifndef offsetof
#define offsetof(type, field) FIELD_OFFSET(type, field)
#endif
#define STRUCT_OF(type, address, field) CONTAINING_RECORD(address, type, field)

//
//* CTE Initialization.
//

//++
//
// int
// CTEInitialize(
//     void
//     );
//
// Routine Description:
//
//     Initializes the Common Transport Environment. All users of the CTE
//     must call this routine during initialization before calling any
//     other CTE routines.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     Returns zero on failure, non-zero if it succeeds.
//
//--

extern int
CTEInitialize(
    void
    );


//
//* Lock related definitions.
//
typedef KSPIN_LOCK  CTELock;
typedef KIRQL       CTELockHandle;

#define DEFINE_LOCK_STRUCTURE(x)    CTELock x;
#define LOCK_STRUCTURE_SIZE         sizeof(CTELock)
#define EXTERNAL_LOCK(x)            extern CTELock x;

//++
//
// VOID
// CTEInitLock(
//     CTELOCK *SpinLock
//     );
//
// Routine Description:
//
//     Initializes a spin lock.
//
// Arguments:
//
//     SpinLock - Supplies a pointer to the lock structure.
//
// Return Value:
//
//     None.
//
//--

#define CTEInitLock(l) KeInitializeSpinLock(l)

#if MILLEN

VOID TcpipMillenGetLock(CTELock *pLock);
VOID TcpipMillenFreeLock(CTELock *pLock);

#define CTEGetLock(l, h)         TcpipMillenGetLock(l); *(h) = 0
#define CTEGetLockAtDPC(l)       TcpipMillenGetLock(l)
#define CTEFreeLock(l, h)        TcpipMillenFreeLock(l)
#define CTEFreeLockFromDPC(l)    TcpipMillenFreeLock(l)
#else // MILLEN
//++
//
// VOID
// CTEGetLock(
//     CTELock        *SpinLock,
//     CTELockHandle  *OldIrqlLevel
//     );
//
// Routine Description:
//
//     Acquires a spin lock
//
// Arguments:
//
//     SpinLock     - A pointer to the lock structure.
//     OldIrqlLevel - A pointer to a variable to receive the old IRQL level .
//
// Return Value:
//
//     None.
//
//--

#define CTEGetLock(l, h) KeAcquireSpinLock((l),(h))


//++
//
// VOID
// CTEGetLockAtDPC(
//     CTELock        *SpinLock
//     );
//
// Routine Description:
//
//     Acquires a spin lock when the processor is already running at
//     DISPATCH_LEVEL.
//
// Arguments:
//
//     SpinLock     - A pointer to the lock structure.
//
// Return Value:
//
//     None.
//
//--

#define CTEGetLockAtDPC(l) KeAcquireSpinLockAtDpcLevel((l))


//++
//
// VOID
// CTEFreeLock(
//     CTELock        *SpinLock,
//     CTELockHandle   OldIrqlLevel
//     );
//
// Routine Description:
//
//     Releases a spin lock
//
// Arguments:
//
//     SpinLock     - A pointer to the lock variable.
//     OldIrqlLevel - The IRQL level to restore.
//
// Return Value:
//
//     None.
//
//--

#define CTEFreeLock(l, h) KeReleaseSpinLock((l),(h))


//++
//
// VOID
// CTEFreeLockFromDPC(
//     CTELock        *SpinLock
//     );
//
// Routine Description:
//
//     Releases a spin lock
//
// Arguments:
//
//     SpinLock     - A pointer to the lock variable.
//
// Return Value:
//
//     None.
//
//--


#define CTEFreeLockFromDPC(l) KeReleaseSpinLockFromDpcLevel((l))

#endif // !MILLEN

//
// Interlocked counter management routines.
//


//++
//
// ulong
// CTEInterlockedAddUlong(
//     ulong     *AddendPtr,
//     ulong      Increment,
//     CTELock   *LockPtr
//     );
//
// Routine Description:
//
//     Adds an increment to an unsigned long quantity using a spinlock
//     for synchronization.
//
// Arguments:
//
//     AddendPtr  - A pointer to the quantity to be updated.
//     LockPtr    - A pointer to the spinlock used to synchronize the operation.
//
// Return Value:
//
//     The initial value of the Added variable.
//
// Notes:
//
//     It is not permissible to mix calls to CTEInterlockedAddULong with
//     calls to the CTEInterlockedIncrement/DecrementLong routines on the
//     same value.
//
//--

#define CTEInterlockedAddUlong(AddendPtr, Increment, LockPtr) \
            ExInterlockedAddUlong(AddendPtr, Increment, LockPtr)

//++
//
// ulong
// CTEInterlockedExchangeAdd(
//     ulong     *AddendPtr,
//     ulong      Increment,
//     );
//
// Routine Description:
//
//     Adds an increment to an unsigned long quantity without using a spinlock.
//
// Arguments:
//
//     AddendPtr  - A pointer to the quantity to be updated.
//     Increment  - The amount to be added to *AddendPtr
//
// Return Value:
//
//     The initial value of the Added variable.
//
// Notes:
//
//--

#define CTEInterlockedExchangeAdd(AddendPtr, Increment) \
            InterlockedExchangeAdd(AddendPtr, Increment)

//++
//
// long
// CTEInterlockedDecrementLong(
//     ulong     *AddendPtr
//     );
//
// Routine Description:
//
//     Decrements a long quantity atomically
//
// Arguments:
//
//     AddendPtr  - A pointer to the quantity to be decremented
//
// Return Value:
//
//     < 0  if Addend is < 0 after decrement.
//     == 0 if Addend is = 0 after decrement.
//     > 0  if Addend is > 0 after decrement.
//
// Notes:
//
//     It is not permissible to mix calls to CTEInterlockedAddULong with
//     calls to the CTEInterlockedIncrement/DecrementLong routines on the
//     same value.
//
//--

#define CTEInterlockedDecrementLong(AddendPtr) \
            InterlockedDecrement( (PLONG) (AddendPtr))

//++
//
// long
// CTEInterlockedIncrementLong(
//     ulong     *AddendPtr
//     );
//
// Routine Description:
//
//     Increments a long quantity atomically
//
// Arguments:
//
//     AddendPtr  - A pointer to the quantity to be incremented.
//
// Return Value:
//
//     < 0  if Addend is < 0 after decrement.
//     == 0 if Addend is = 0 after decrement.
//     > 0  if Addend is > 0 after decrement.
//
// Notes:
//
//     It is not permissible to mix calls to CTEInterlockedAddULong with
//     calls to the CTEInterlockedIncrement/DecrementLong routines on the
//     same value.
//
//--

#define CTEInterlockedIncrementLong(AddendPtr) \
            InterlockedIncrement((PLONG) (AddendPtr))


//
// Large Integer manipulation routines.
//

typedef ULARGE_INTEGER CTEULargeInt;

//++
//
// ulong
// CTEEnlargedUnsignedDivide(
//     CTEULargeInt  Dividend,
//     ulong         Divisor,
//     ulong        *Remainder
//     );
//
// Routine Description:
//
//     Divides an unsigned large integer quantity by an unsigned long quantity
//     to yield an unsigned long quotient and an unsigned long remainder.
//
// Arguments:
//
//     Dividend   - The dividend value.
//     Divisor    - The divisor value.
//     Remainder  - A pointer to a variable to receive the remainder.
//
// Return Value:
//
//     The unsigned long quotient of the division.
//
//--

#define CTEEnlargedUnsignedDivide(Dividend, Divisor, Remainder) \
    RtlEnlargedUnsignedDivide (Dividend, Divisor, Remainder)


//
//* String definitions and manipulation routines
//
//

//++
//
// BOOLEAN
// CTEInitString(
//     PNDIS_STRING   DestinationString,
//     char          *SourceString
//     );
//
// Routine Description:
//
//     Converts a C style ASCII string to an NDIS_STRING. Resources needed for
//     the NDIS_STRING are allocated and must be freed by a call to
//     CTEFreeString.
//
// Arguments:
//
//     DestinationString  - A pointer to an NDIS_STRING variable with no
//                          associated data buffer.
//
//     SourceString       - The C style ASCII string source.
//
//
// Return Value:
//
//     TRUE if the initialization succeeded. FALSE otherwise.
//
//--

BOOLEAN
CTEInitString(
    PUNICODE_STRING  DestinationString,
    char            *SourceString
    );


//++
//
// BOOLEAN
// CTEAllocateString(
//     PNDIS_STRING    String,
//     unsigned short  Length
//     );
//
// Routine Description:
//
//     Allocates a data buffer for Length characters in an uninitialized
//     NDIS_STRING. The allocated space must be freed by a call to
//     CTEFreeString.
//
//
// Arguments:
//
//     String         - A pointer to an NDIS_STRING variable with no
//                          associated data buffer.
//
//     MaximumLength  - The maximum length of the string. The unit of this
//                          value is system dependent.
//
// Return Value:
//
//     TRUE if the initialization succeeded. FALSE otherwise.
//
//--

BOOLEAN
CTEAllocateString(
    PUNICODE_STRING     String,
    unsigned short      Length
    );


//++
//
// VOID
// CTEFreeString(
//     PNDIS_STRING  String,
//     );
//
// Routine Description:
//
//     Frees the string buffer associated with an NDIS_STRING. The buffer must
//     have been allocated by a previous call to CTEInitString.
//
// Arguments:
//
//     String - A pointer to an NDIS_STRING variable.
//
//
// Return Value:
//
//     None.
//
//--

#define CTEFreeString(String) ExFreePool((String)->Buffer)


//++
//
// unsigned short
// CTELengthString(
//     PNDIS_STRING String
//     );
//
// Routine Description:
//
//     Calculates the length of an NDIS_STRING.
//
// Arguments:
//
//     The string to test.
//
// Return Value:
//
//     The length of the string parameter. The unit of this value is
//         system dependent.
//
//--

#define CTELengthString(String) ((String)->Length)


//++
//
// BOOLEAN
// CTEEqualString(
//     CTEString *String1,
//     CTEString *String2
//     );
//
// Routine Description:
//
//     Compares two NDIS_STRINGs for case-sensitive equality
//
// Arguments:
//
//     String1 - A pointer to the first string to compare.
//     String2 - A pointer to the second string to compare.
//
// Return Value:
//
//     TRUE if the strings are equivalent. FALSE otherwise.
//
//--

#define CTEEqualString(S1, S2) RtlEqualUnicodeString(S1, S2, FALSE)


//++
//
// VOID
// CTECopyString(
//     CTEString *DestinationString,
//     CTEString *SourceString
//     );
//
// Routine Description:
//
//     Copies one NDIS_STRING to another. Behavior is undefined if the
//     destination is not long enough to hold the source.
//
// Arguments:
//
//     DestinationString - A pointer to the destination string.
//     SourceString      - A pointer to the source string.
//
// Return Value:
//
//     None.
//
//--

#define CTECopyString(D, S) RtlCopyUnicodeString(D, S)


//
//* Delayed event definitions
//
// Delayed events are events scheduled that can be scheduled to
// occur 'later', without a timeout. They happen as soon as the system
// is ready for them. The caller specifies a parameter that will be
// passed to the event proc when the event is called.
//
// In the NT environmnet, delayed events are implemented using Executive
// worker threads.
//
// NOTE: The event handler routine may not block.
//

#pragma warning(push)
#pragma warning(disable:4115) //named type definition in parenthesis
typedef void (*CTEEventRtn)(struct CTEEvent *, void *);
#pragma warning(pop)

struct CTEEvent {
    uint             ce_scheduled;
    CTELock          ce_lock;
    CTEEventRtn      ce_handler;     // Procedure to be called.
    void            *ce_arg;         // Argument to pass to handler.
    WORK_QUEUE_ITEM  ce_workitem;    // Kernel ExWorkerThread queue item.
}; /* CTEEvent */

typedef struct CTEEvent CTEEvent;


//++
//
// void
// CTEInitEvent(
//     IN CTEEvent     *Event,
//     IN CTEEventRtn  *Handler
//     );
//
// Routine Description:
//
//    Initializes a delayed event structure.
//
// Arguments:
//
//    Event    - Pointer to a CTE Event variable
//    Handler  - Pointer to the function to be called when the event is
//                 scheduled.
//
// Return Value:
//
//    None.
//
//--

extern void
CTEInitEvent(
    IN CTEEvent    *Event,
    IN CTEEventRtn  Handler
    );


//++
//
// int
// CTEScheduleCriticalEvent(
//     IN CTEEvent    *Event,
//     IN void        *Argument
//     );
//
// Routine Description:
//
//    Schedules a routine to be executed later in a different context. In the
//    NT environment, the event is implemented as a kernel DPC using CriticalWorkerQueue.
//
// Arguments:
//
//    Event    - Pointer to a CTE Event variable
//    Argument - An argument to pass to the event handler when it is called
//
// Return Value:
//
//    0 if the event could not be scheduled. Nonzero otherwise.
//
//--

int
CTEScheduleCriticalEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    );


//++
//
// int
// CTEScheduleEvent(
//     IN CTEEvent    *Event,
//     IN void        *Argument
//     );
//
// Routine Description:
//
//   See CTEScheduleDelayedEvent right below, this function
//   is exactly the same.
//--

int
CTEScheduleEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    );



// int
// CTEScheduleDelayedEvent(
//     IN CTEEvent    *Event,
//     IN void        *Argument
//     );
//
// Routine Description:
//
//    Schedules a routine to be executed later in a different context. In the
//    NT environment, the event is implemented as a kernel DPC, using DealyedWorkerQueue.
//
// Arguments:
//
//    Event    - Pointer to a CTE Event variable
//    Argument - An argument to pass to the event handler when it is called
//
// Return Value:
//
//    0 if the event could not be scheduled. Nonzero otherwise.
//
//--

int
CTEScheduleDelayedEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    );





#if MILLEN
#define CTEScheduleDelayedEvent CTEScheduleEvent
#endif // MILLEN

//++
//
// int
// CTECancelEvent(
//     IN CTEEvent *Event
//     );
//
// Routine Description:
//
//     Cancels a previously scheduled delayed event routine.
//
// Arguments:
//
//     Event - Pointer to a CTE Event variable
//
// Return Value:
//
//     0 if the event couldn't be cancelled. Nonzero otherwise.
//
// Notes:
//
//     In the NT environment, a delayed event cannot be cancelled.
//
//--

#define CTECancelEvent(Event)   0


//
//* Timer related declarations
//

struct  CTETimer {
    uint             t_running;
    CTELock          t_lock;
    CTEEventRtn      t_handler;
    void            *t_arg;
#if !MILLEN
    KDPC             t_dpc;     // DPC for this timer.
    KTIMER           t_timer;   // Kernel timer structure.
#else
    NDIS_TIMER       t_timer;
#endif 
}; /* CTETimer */

typedef struct CTETimer CTETimer;

//++
//
// void
// CTEInitTimer(
//     IN CTETimer *Timer
//     );
//
// Routine Description:
//
//     Initializes a CTE Timer structure. This routine must be used
//     once on every timer before it is set. It may not be invoked on
//     a running timer.
//
// Arguments:
//
//     Timer - Pointer to the CTE Timer to be initialized.
//
// Return Value:
//
//     0 if the timer could not be initialized. Nonzero otherwise.
//
//--

extern void
CTEInitTimer(
    IN CTETimer *Timer
    );


//++
//
// extern void *
// CTEStartTimer(
//     IN CTETimer *Timer
//     );
//
// Routine Description:
//
//     This routine starts a CTE timer running.
//
// Arguments:
//
//     Timer      - Pointer to the CTE Timer to start.
//     DueTime    - The time in milliseconds from the present at which the
//                    timer will be due.
//     Handler    - The function to call when the timer expires.
//     Context    - A value to pass to the Handler routine.
//
// Return Value:
//
//     NULL if the timer could not be started. Non-NULL otherwise.
//
// Notes:
//
//     In the NT environment, the first argument to the Handler function is
//     a pointer to the timer structure, not to a CTEEvent structure.
//
//--

extern void *
CTEStartTimer(
    IN CTETimer       *Timer,
    IN unsigned long   DueTime,
    IN CTEEventRtn     Handler,
    IN void           *Context   OPTIONAL
    );


//++
//
// int
// CTEStopTimer(
//     IN CTETimer *Timer
//     );
//
// Routine Description:
//
//     Cancels a running CTE timer.
//
// Arguments:
//
//     Timer - Pointer to the CTE Timer to be cancelled.
//
// Return Value:
//
//     0 if the timer could not be cancelled. Nonzero otherwise.
//
// Notes:
//
//     Calling this function on a timer that is not active has no effect.
//     If this routine fails, the timer may be in the process of expiring
//     or may have already expired. In either case, the caller must
//     sychronize with the Handler function as appropriate.
//
//--

#if !MILLEN
#define CTEStopTimer(Timer)  ((int) KeCancelTimer(&((Timer)->t_timer)))
#else
extern int
CTEStopTimer(
    IN CTETimer *Timer
    );
#endif 


//++
//
// unsigned long
// CTESystemUpTime(
//     void
//     );
//
// Routine Description:
//
//     Returns the time in milliseconds that the system has been running.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The time in milliseconds.
//
//--

extern unsigned long
CTESystemUpTime(
    void
    );


//
//* Memory allocation functions.
//
// There are only two main functions, CTEAllocMem and CTEFreeMem. Locks
// should not be held while calling these functions, and it is possible
// that they may yield when called, particularly in the VxD environment.
//
//  In the VxD environment there is a third auxillary function CTERefillMem,
//  used to refill the VxD heap manager.
//

//++
//
// void *
// CTEAllocMem(
//     ulong Size
//     );
//
// Routine Description:
//
//     Allocates a block of memory from nonpaged pool.
//
// Arguments:
//
//     Size   -  The size in bytes to allocate.
//
// Return Value:
//
//     A pointer to the allocated block, or NULL.
//
//--

#define CTEAllocMem(Size)  ExAllocatePoolWithTag(NonPagedPool, (Size), ' ETC')


//++
//
// void
// CTEFreeMem(
//     void *MemoryPtr
//     );
//
// Routine Description:
//
//     Frees a block of memory allocated with CTEAllocMem.
//
// Arguments:
//
//     MemoryPtr   - A pointer to the memory to be freed.
//
// Return Value:
//
//     None.
//
//--

#define CTEFreeMem(MemoryPtr)   ExFreePool((MemoryPtr));


// Routine to Refill memory. Not used in NT environment.
#define CTERefillMem()


//
//* Memory manipulation routines.
//

//++
//
// void
// CTEMemCopy(
//     void          *Source,
//     void          *Destination,
//     unsigned long  Length
//     );
//
// RoutineDescription:
//
//     Copies data from one buffer to another.
//
// Arguments:
//
//     Source       - Source buffer.
//     Destination  - Destination buffer,
//     Length       - Number of bytes to copy.
//
// Return Value:
//
//     None.
//
//--

#define CTEMemCopy(Dst, Src, Len)   RtlCopyMemory((Dst), (Src), (Len))


//++
//
// void
// CTEMemSet(
//     void          *Destination,
//     unsigned char *Fill
//     unsigned long  Length
//     );
//
// RoutineDescription:
//
//     Sets the bytes of the destination buffer to a specific value.
//
// Arguments:
//
//     Destination  - Buffer to fill.
//     Fill         - Value with which to fill buffer.
//     Length       - Number of bytes of buffer to fill.
//
// Return Value:
//
//     None.
//
//--

#define CTEMemSet(Dst, Fill, Len)   RtlFillMemory((Dst), (Len), (Fill))


//++
//
// unsigned long
// CTEMemCmp(
//     void          *Source1,
//     void          *Source2,
//     unsigned long  Length
//     );
//
// RoutineDescription:
//
//     Compares Length bytes of Source1 to Source2 for equality.
//
// Arguments:
//
//     Source1   - First source buffer.
//     Source2   - Second source buffer,
//     Length    - Number of bytes of Source1 to compare against Source2.
//
// Return Value:
//
//     Zero if the data in the two buffers are equal for Length bytes.
//     NonZero otherwise.
//
//--

#define CTEMemCmp(Src1, Src2, Len)    \
            ((RtlCompareMemory((Src1), (Src2), (Len)) == (Len)) ? 0 : 1)


//
//* Blocking routines. These routines allow a limited blocking capability.
//

struct CTEBlockStruc {
    uint        cbs_status;
    KEVENT      cbs_event;
}; /* CTEBlockStruc */

typedef struct CTEBlockStruc CTEBlockStruc;

struct CTEBlockTracker {
    LIST_ENTRY  cbt_link;
    PKTHREAD    cbt_thread;
    void*       cbt_context;
};

typedef struct CTEBlockTracker CTEBlockTracker;


//++
//
// VOID
// CTEInitBlockStruc(
//     IN CTEBlockStruc *BlockEvent
//     );
//
// Routine Description:
//
//     Initializes a CTE blocking structure
//
// Arguments:
//
//     BlockEvent - Pointer to the variable to intialize.
//
// Return Value:
//
//     None.
//
//--

#define CTEInitBlockStruc(Event) \
            {                                                        \
            (Event)->cbs_status = NDIS_STATUS_SUCCESS;               \
            KeInitializeEvent(                                       \
                &((Event)->cbs_event),                               \
                SynchronizationEvent,                                \
                FALSE                                                \
                );                                                   \
            }


//++
//
// VOID
// CTEInitBlockStrucEx(
//     IN CTEBlockStruc *BlockEvent
//     );
//
// Routine Description:
//
//     Initializes a CTE blocking structure
//
// Arguments:
//
//     BlockEvent - Pointer to the variable to intialize.
//
// Return Value:
//
//     None.
//
//--

#define CTEInitBlockStrucEx(Event) \
            {                                                        \
            (Event)->cbs_status = NDIS_STATUS_SUCCESS;               \
            KeInitializeEvent(                                       \
                &((Event)->cbs_event),                               \
                NotificationEvent,                                   \
                FALSE                                                \
                );                                                   \
            }

//++
//
// uint
// CTEBlock(
//     IN CTEBlockStruc    *BlockEvent
//     );
//
// uint
// CTEBlockWithTracker(
//     IN CTEBlockStruc    *BlockEvent,
//     IN CTEBlockTracker  *BlockTracker,
//     IN void             *Context
//     );
//
// Routine Descriptions:
//
//     Block the current thread of execution on the occurrence of an event.
//     CTEBlockWithTracker also queues a record of the blocking request.
//
// Arguments:
//
//     BlockEvent - Pointer to the event on which to block.
//     BlockTracker - Pointer to space to be used for tracking the request.
//     Context - Optional context to be stored with the tracking structure.
//
// Return Value:
//
//     The status value provided by the signaller of the event.
//
//--

extern uint
CTEBlock(
    IN CTEBlockStruc *BlockEvent
    );

extern uint
CTEBlockWithTracker(
    IN CTEBlockStruc *BlockEvent,
    IN CTEBlockTracker *BlockTracker,
    IN void *Context
    );

//++
//
// extern void
// CTEInsertBlockTracker(
//     IN CTEBlockTracker  *BlockTracker,
//     IN void             *Context
//     );
// 
// extern void
// CTERemoveBlockTracker(
//     IN CTEBlockTracker  *BlockTracker
//     );
//
// Routine Descriptions:
//
//      Insert and remove records from the global list of blocking requests.
//
// Arguments:
//
//      BlockTracker - Space to be used for tracking the blocking request.
//      Context - Optional context to be stored with the tracking structure.
//
// Return Value:
//
//      None.
//
//--

extern void
CTEInsertBlockTracker(
    IN CTEBlockTracker *BlockTracker,
    IN void *Context
    );

extern void
CTERemoveBlockTracker(
    IN CTEBlockTracker *BlockTracker
    );

//++
//
// VOID
// CTESignal(
//     IN CTEBlockStruc *BlockEvent,
//     IN uint           Status
//     );
//
// Routine Description:
//
//     Releases one thread of execution blocking on an event. Any other
//     threads blocked on the event remain blocked.
//
// Arguments:
//
//     BlockEvent - Pointer to the event to signal.
//     Status     - Status to return to the blocking thread.
//
// Return Value:
//
//     None.
//
//--

extern void
CTESignal(
    IN CTEBlockStruc *BlockEvent,
    IN uint Status
    );


//++
//
// VOID
// CTEClearSignal(
//     IN CTEBlockStruc *BlockEvent
//     );
//
// Routine Description:
//
//     Returns the event structure to the unsignaled state.
//
// Arguments:
//
//     BlockEvent - Pointer to the event to be cleared.
//
// Return Value:
//
//     None.
//
//--

#define CTEClearSignal(Event)       KeResetEvent(&((Event)->cbs_event))


//
// Event Logging routines.
//
// NOTE: These definitions are tentative and subject to change!!!!!!
//

#define CTE_MAX_EVENT_LOG_DATA_SIZE                                       \
            ( ( ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) +    \
                sizeof(ULONG)                                             \
              ) & 0xFFFFFFFC                                              \
            )

//
//
// Routine Description:
//
//     This function allocates an I/O error log record, fills it in and
//     writes it to the I/O error log.
//
//
// Arguments:
//
//     LoggerId          - Pointer to the driver object logging this event.
//
//     EventCode         - Identifies the error message.
//
//     UniqueEventValue  - Identifies this instance of a given error message.
//
//     NumStrings        - Number of unicode strings in strings list.
//
//     DataSize          - Number of bytes of data.
//
//     Strings           - Array of pointers to unicode strings (PWCHAR').
//
//     Data              - Binary dump data for this message, each piece being
//                         aligned on word boundaries.
//
// Return Value:
//
//     TDI_SUCCESS                  - The error was successfully logged.
//     TDI_BUFFER_TOO_SMALL         - The error data was too large to be logged.
//     TDI_NO_RESOURCES             - Unable to allocate memory.
//
// Notes:
//
//     This code is paged and may not be called at raised IRQL.
//
LONG
CTELogEvent(
    IN PVOID             LoggerId,
    IN ULONG             EventCode,
    IN ULONG             UniqueEventValue,
    IN USHORT            NumStrings,
    IN PVOID             StringsList,        OPTIONAL
    IN ULONG             DataSize,
    IN PVOID             Data                OPTIONAL
    );


//
// Debugging routines.
//
#if DBG
#ifndef DEBUG
#define DEBUG 1
#endif
#endif //DBG


#ifdef DEBUG

#define DEBUGCHK    DbgBreakPoint()

#define DEBUGSTRING(v, s) uchar v[] = s

#define CTECheckMem(s)

#define CTEPrint(String)   DbgPrint(String)
#define CTEPrintNum(Num)   DbgPrint("%d", Num)
#define CTEPrintCRLF()     DbgPrint("\n");


#define CTEStructAssert(s, t) if ((s)->t##_sig != t##_signature) {\
                CTEPrint("Structure assertion failure for type " #t " in file " __FILE__ " line ");\
                CTEPrintNum(__LINE__);\
                CTEPrintCRLF();\
                DEBUGCHK;\
                }

#define CTEAssert(c)    if (!(c)) {\
                CTEPrint("Assertion failure in file " __FILE__ " line ");\
                CTEPrintNum(__LINE__);\
                CTEPrintCRLF();\
                DEBUGCHK;\
                }

#else // DEBUG

#define DEBUGCHK
#define DEBUGSTRING(v,s)
#define CTECheckMem(s)
#define CTEStructAssert(s,t )
#define CTEAssert(c)
#define CTEPrint(s)
#define CTEPrintNum(Num)
#define CTEPrintCRLF()

#endif // DEBUG


//* Request completion routine definition.
typedef void    (*CTEReqCmpltRtn)(void *, unsigned int , unsigned int);

//* Defintion of CTEUnload
#define CTEUnload(Name)

//* Definition of a load/unload notification procedure handler.
typedef void    (*CTENotifyRtn)(uchar *);

//* Defintion of set load and unload notification handlers.
#define CTESetLoadNotifyProc(Handler)
#define CTESetUnloadNotifyProc(Handler)

#else // NT

/////////////////////////////////////////////////////////////////////////////
//
// Definitions for additional environments go here
//
/////////////////////////////////////////////////////////////////////////////

#error Environment specific definitions missing

#endif // NT
/*INC*/

#pragma warning(pop)

#endif // _CXPORT_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\iasext.h ===
//#--------------------------------------------------------------
//        
//  File:       iasext.h
//        
//  Synopsis:   This file holds declarations of APIs being
//              exported from the IASHLPR.DLL used in the
//              Internet Authentication Server (IAS) project
//              
//
//  History:     2/10/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _IASEXT_H_
#define _IASEXT_H_

#ifdef __cplusplus
extern  "C" {
#endif

//
//  initialize the IAS Helper Component
//
STDAPI
InitializeIas(
        /*[in]*/    BOOL    bComInit
        );

//
//  cleanup and shutdown of the IAS Helper Component
//
STDAPI_(VOID)  
ShutdownIas (VOID);

//
//  Load IAS configuration information
//
STDAPI
ConfigureIas (VOID);
    
//
//  Allocate the specified number of empty attributs and
//  put them in the array provided
//
STDAPI 
AllocateAttributes (
        /*[in]*/    DWORD           dwAttributeCount,
        /*[in]*/    PIASATTRIBUTE   *ppIasAttribute
       );

//
//  Free all the attributes allocated earlier
//
STDAPI  
FreeAttributes (
        /*[in]*/    DWORD           dwAttributeCount,
        /*[in]*/    PIASATTRIBUTE   *ppIasAttribute
        );

//
//  process the filled attributes
//
STDAPI 
DoRequest (
    /*[in]*/        DWORD           dwAttributeCount,
    /*[in]*/        PIASATTRIBUTE   *ppInIasAttribute,
    /*[out]*/       PDWORD          pdwOutAttributeCount,
    /*[out]*/       PIASATTRIBUTE   **pppOutIasAttribute,
    /*[in]*/        LONG            IasRequest,
    /*[in/out]*/    LONG            *pIasResponse,
    /*[in]*/        IASPROTOCOL     IasProtocol,
    /*[out]*/       PLONG           plReason,
    /*[in]*/        BOOL            bProcessVSA
    );

//
//  allocate dynamic memory
//
STDAPI_(PVOID)
MemAllocIas (
    /*[in]*/    DWORD   dwSize 
    );

//
//  free dynamic memory
//
STDAPI_(VOID)
MemFreeIas (
    /*[in]*/    PVOID   pAllocatedMem
    );

//
//  reallocate dynamic memory passing in the address of the allocated
//  memory and the size needed
//
STDAPI_(PVOID)
MemReallocIas (
    /*[in]*/    PVOID   pAllocatedMem,
    /*[in]*/    DWORD   dwNewSize 
    );
    

#ifdef __cplusplus
}
#endif

#endif // ifndef _IASEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\dialinusr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp.,                     **/
/**********************************************************************/

/*
   dialinusr.h
      Definition of names, values, default values, containers information
      related to msRASUser, msRASProfile in DS
      
    Author:
        Wei Jiang (weijiang) 13-Oct-97

    Revision History:
      Wei Jiang (weijiang) 20-Oct-97   -- define more bits for msRASAllowDialin Attribute
                              -- static IP address
                              -- callback number
                              -- caller id
                              -- default profile name --> "DefaultRASProfile"
        
      Wei Jiang (weijiang) 13-Nov-97   -- move definition of timeOfDay into this header

      Wei Jiang (weijiang) 29-APR-98  -- SDO Wrapper APIs

      Wei Jiang (weijiang) 29-APR-98  -- move profile UI APIs into this folder
*/
// dsrasuse.h : header file for RAS User and Profile definition
//

#ifndef _RAS_USER_PROFILE_
#define _RAS_USER_PROFILE_

// Attribute DN
#define  RAS_DSAN_DN       L"distinguishedName"

// Callback number length
#define RAS_CALLBACK_NUMBER_LEN     MAX_PHONE_NUMBER_LEN
#define RAS_CALLBACK_NUMBER_LEN_NT4 48

// IP Address Policy, used in profile msRASIPAddressPolicy
#define RAS_IP_USERSELECT   0xffffffff
#define RAS_IP_SERVERASSIGN 0xfffffffe
#define RAS_IP_STATIC       0xfffffffd
#define RAS_IP_NONE         0x0

// Radius Service type
#define  RAS_RST_FRAMED       0x2
#define RAS_RST_FRAMEDCALLBACK   0x4

// Authentication Type, used in profile, for msRASAuthenticationType

/*
1 PAP/SPAP
2 CHAP
3 MS-CHAP-1
4 MS-CHAP-2
5 EAP
6 ARAP
7 None >>  Can we rename it to:- Unauthenticated Access.
8 Custom Authentication Module
9 MS-CHAP-1 with password change
10 MS-CHAP-2 with Password change

// replace old value  == (EAP=1, CHAP=2, MS-CHAP=3, PAP=4, SPAP=5)
*/

#define RAS_AT_PAP_SPAP    1
#define RAS_AT_MD5CHAP     2
#define RAS_AT_MSCHAP      3
#define RAS_AT_MSCHAP2     4
#define RAS_AT_EAP         5

#if   0
#define RAS_AT_ARAP        6
#endif

#define RAS_AT_UNAUTHEN      7
#define RAS_AT_EXTENSION_DLL 8
#define RAS_AT_MSCHAPPASS    9
#define RAS_AT_MSCHAP2PASS   10

// Authentication Type Names
#define RAS_ATN_MSCHAP     _T("MSCHAP")
#define RAS_ATN_MD5CHAP    _T("MD5CHAP")
#define RAS_ATN_CHAP    _T("CHAP")
#define RAS_ATN_EAP     _T("EAP")
#define RAS_ATN_PAP     _T("PAP")

// Encryption Policy, used in profile for msRASAllowEncryption
#define  RAS_EP_DISALLOW   1   // the type should set to ET_NONE
#define RAS_EP_ALLOW       1
#define RAS_EP_REQUIRE     2

// Encrpytiopn Type
#define RAS_ET_BASIC       0x00000002
#define RAS_ET_STRONGEST   0x00000004
#define RAS_ET_STRONG      0x00000008
#define RAS_ET_AUTO        (RAS_ET_BASIC  | RAS_ET_STRONG | RAS_ET_STRONGEST)

#if 0   // old values
// Encryption Types, profile, for msRASEncryptionType
#define  RAS_ET_NONE    0x0
#define RAS_ET_IPSEC    0x00000001
#define RAS_ET_40       0x00000002
#define RAS_ET_128      0x00000004
#define RAS_ET_56       0x00000008

// change it back after beta3 
#define RAS_ET_DES_40      0x00000010
// #define RAS_ET_DES_40      RAS_ET_IPSEC
#define RAS_ET_DES_56      0x00000020
#define RAS_ET_3DES        0x00000040

#endif

// Framed Routing
#define  RAS_FR_FALSE      0x0   // or absent
#define  RAS_FR_TRUE       0x1

// BAP Policy -- profile, for msRASBAPRequired
#define RAS_BAP_ALLOW      1
#define RAS_BAP_REQUIRE    2

// Port Types -- profile, for msRASAllowPortType
#define RAS_PT_ISDN        0x00000001
#define RAS_PT_MODEM       0x00000002
#define RAS_PT_VPN         0x00000004
#define RAS_PT_OTHERS      0xFFFFFFF8
#define  RAS_PT_ALL        0xffffffff

#ifdef   _TUNNEL

//Tunnel Types
#define RAS_TT_PPTP     1
#define RAS_TT_L2F      2
#define RAS_TT_L2TP     3
#define RAS_TT_ATMP     4
#define RAS_TT_VTP      5
#define RAS_TT_AH       6
#define RAS_TT_IP_IP    7
#define RAS_TT_MIN_IP_IP   8
#define RAS_TT_ESP         9
#define RAS_TT_GRE         10
#define RAS_TT_DVS         11

//Tunnel Type Names
#define RAS_TTN_PPTP    _T("PPTP")  // Point-to-Point Tunneling Protocol (PPTP)
#define RAS_TTN_L2F     _T("L2F")   // Layer Two Forwarding 
#define RAS_TTN_L2TP    _T("L2TP")  // Layer Two Tunneling Protocol 
#define RAS_TTN_ATMP    _T("ATMP")  // Ascend Tunnel Management Protocol 
#define RAS_TTN_VTP     _T("VTP")   // Virtual Tunneling Protocol 
#define RAS_TTN_AH         _T("AH") // IP Authentication Header in the Tunnel-mode 
#define RAS_TTN_IP_IP      _T("IP-IP") // IP-in-IP Encapsulation 
#define RAS_TTN_MIN_IP_IP  _T("MIN-IP-IP") // Minimal IP-in-IP Encapsulation 
#define RAS_TTN_ESP     _T("ESP")   // IP Encapsulation Security Payload in the Tunnel-mode 
#define RAS_TTN_GRE     _T("GRE")   // Generic Route Encapsulation 
#define RAS_TTN_DVS     _T("DVS")   // Bay Dial Virtual Services 

// Tunnel Medium Types
#define RAS_TMT_IP         1
#define RAS_TMT_X25        2
#define RAS_TMT_ATM        3
#define RAS_TMT_FRAMEDELAY 4

// Tunnel Medium Type Names
#define RAS_TMTN_IP     _T("IP")
#define RAS_TMTN_X25    _T("X.25")
#define RAS_TMTN_ATM    _T("ATM")
#define RAS_TMTN_FRAMEDELAY   _T("Frame Relay")

#endif   // _TUNNEL

//=========================================================
// for msRASAllowDialin attribute of RAS User object
// dialin policy, RASUser, msRASAllowDialin
/*
 #define RASPRIV_NoCallback        0x01
 #define RASPRIV_AdminSetCallback  0x02
 #define RASPRIV_CallerSetCallback 0x04
 #define RASPRIV_DialinPrivilege   0x08
*/ 
#define  RAS_DIALIN_MASK         RASPRIV_DialinPrivilege
#define  RAS_DIALIN_ALLOW        RASPRIV_DialinPrivilege
#define  RAS_DIALIN_DISALLOW     0

// callback policy, RASUser, msRASAllowDialin
#define  RAS_CALLBACK_MASK       0x00000007
#define RAS_CALLBACK_NOCALLBACK  RASPRIV_NoCallback
#define  RAS_CALLBACK_CALLERSET  RASPRIV_CallerSetCallback
#define  RAS_CALLBACK_SECURE     RASPRIV_AdminSetCallback
#define  RAS_USE_CALLBACK        RASPRIV_AdminSetCallback

#define RADUIS_SERVICETYPE_CALLBACK_FRAME   RAS_RST_FRAMEDCALLBACK

// caller id -- uses the caller id attribute, RASUser, msRASAllowDialin
#define  RAS_USE_CALLERID        0x00000010

// static IP address -- uses the framed Ip address attribute, RASUser, msRASAllowDialin
#define  RAS_USE_STATICIP        0x00000020

// static routes -- uses the framed routes attribute, RASUser, msRASAllowDialin
#define  RAS_USE_STATICROUTES    0x00000040

//==========================================================
// msRASTimeOfDay
//
// msRASTimeOfDay is multi-valued string attribute of ras profile
// when it's absent, no restriction
// sample values: 0 10:00-15:00 18:00-20:00     --> meaning allow dailin Monday, 10:00 to 15:00, 18:00 to 20:00 GMT

// day of week definition
// changed to start 0 from SUNDAY rather that MON, and SAT to 6, BUG -- 171343
#define  RAS_DOW_SUN       _T("0")
#define  RAS_DOW_MON       _T("1")
#define  RAS_DOW_TUE       _T("2")
#define  RAS_DOW_WED       _T("3")
#define  RAS_DOW_THU       _T("4")
#define  RAS_DOW_FRI       _T("5")
#define  RAS_DOW_SAT       _T("6")

//==========================================================
// the default 
// ras user object
#define  RAS_DEF_ALLOWDIALIN        RAS_DIALIN_DISALLOW
#define RAS_DEF_CALLBACKPOLICY      RAS_CALLBACK_NOCALLBACK
#define RAS_DEF_IPADDRESSPOLICY     RAS_IP_NONE
#define RAS_DEF_FRAMEDROUTE         // not route
#define RAS_DEF_PROFILE          L"DefaultRASProfile"
#define RAS_DEF_PROFILE_T        _T("DefaultRASProfile")
// ras profile object
// constraints
#define  RAS_DEF_SESSIONSALLOWED    0
#define  RAS_DEF_IDLETIMEOUT        0
#define  RAS_DEF_SESSIONTIMEOUT     0
#define  RAS_DEF_TIMEOUTDAY         // no restriction
#define  RAS_DEF_CALLEDSTATIONID    // no checking
#define  RAS_DEF_ALLOWEDPORTTYPE    RAS_PT_ALL
// networking
#ifdef   _RIP
#define  RAS_DEF_FRAMEDROUTING      RAS_FR_FALSE
#endif
#ifdef   _FILTER
#define  RAS_DEF_FILTERID        // no filter
#endif
#define  RAS_DEF_FRAMEDIPADDRESS    RAS_IP_NONE
// multilink
#define  RAS_DEF_PORTLIMIT          1
#define  RAS_DEF_BAPLINEDNLIMIT     50  // percentage 
#define  RAS_DEF_BAPLINEDNTIME      120 // second
#define  RAS_DEF_BAPREQUIRED        0
// Authentication
#define  RAS_DEF_AUTHENTICATIONTYPE RAS_AT_MSCHAP
#define  RAS_DEF_EAPTYPE            0
// encryption
#define  RAS_DEF_ENCRYPTIONPOLICY   RAS_EP_ALLOW
#define  RAS_DEF_ENCRYPTIONTYPE     RAS_ET_AUTO
// tunneling -- default to no tunneling
#define RAS_DEF_TUNNELTYPE          0
#define RAS_DEF_TUNNELMEDIUMTYPE    0
#define RAS_DEF_TUNNELSERVERENDPOINT   _T("")
#define RAS_DEF_TUNNELPRIVATEGROUPID   _T("")

// the relative path from the DS (DSP-DS PATH)
#define  RAS_DSP_HEADER             L"LDAP://"  // DS provider header
#define  RAS_DSP_ROOTDSE            L"LDAP://RootDSE" // DS Root
#define  RAS_DSP_HEADER_T           _T("LDAP://")
#define  RAS_DSP_GLUE               L","
#define  RAS_DSP_GLUE_T             _T(",")     // glue to put path together

#define RAS_DSA_CONFIGCONTEXT       L"configurationNamingContext"

// DS user userparameters attribute name
#define  DSUSER_USERPARAMETERS      L"userParameters"

// the name of the radius user object within the DS user object container
#define  RAS_OBJN_USER           L"rasDialin"

// the relative path (RPATH - Relative Path to DC)
#define  RAS_RPATH_USERCONTAINER       L"CN=Users"
#define  RAS_RPATH_USERCONTAINER_T     _T("CN=Users")
#define  RAS_RPATH_PROFILECONTAINERINCONFIG     L"CN=Profiles,CN=RAS,CN=Services,"
#define  RAS_RPATH_PROFILECONTAINERINONFIG_T    _T("CN=Profiles,CN=RAS,CN=Services,")
#define  RAS_RPATH_EAPDICTIONARYINCONFIG        L"CN=EapDictionary,CN=RAS,CN=Services,"
#define  RAS_RPATH_EAPDICTIONARYINCONFIG_T      _T("CN=EapDictionary,CN=RAS,CN=Services,")

// Radius Class name definitions -- in UniCode ??
#define  RAS_CLSN_USER           L"msRASUserClass"
#define RAS_CLSN_PROFILE         L"msRASProfileClass"
#define RAS_CLSN_EAPDICTIONARY      L"msRASEapDictionaryClass"

// RAS Eap Dictionary Attribute Name
#define  RAS_EAN_EAPDICTIONARYENTRY L"msRASEapDictionaryEntry" 
// in format "Description name : typeid"

// Radius User Attributes Names  -- in Unicode
#define  RAS_UAN_ALLOWDIALIN        L"msRASAllowDialin"
#define RAS_UAN_FRAMEDIPADDRESS     L"msRASFramedIPAddress"
#define  RAS_UAN_CALLBACKNUMBER     L"msRASCallbackNumber"
#define  RAS_UAN_FRAMEDROUTE        L"msRASFramedRoute"
#define  RAS_UAN_CALLINGSTATIONID   L"msRASCallingStationId"

#define RAS_UAN_RADIUSPROFILE    L"msRASProfilePointer"

// Radius Profile Attributes Names  -- in Unicode
#define RAS_PAN_FRAMEDIPADDRESS     L"msRASIPAddressPolicy"
#ifdef   _RIP
#define RAS_PAN_FORWARDROUTING      L"msRASFramedRouting"
#endif
#ifdef   _FILTER
#define RAS_PAN_FILTERID         L"msRASFilterId"
#endif
#define RAS_PAN_SESSIONTIMEOUT      L"msRASSessionTimeout"
#define RAS_PAN_IDLETIMEOUT         L"msRASIdleTimeout"

#define RAS_PAN_CALLEDSTATIONID     L"msRASCalledStationId"
#define RAS_PAN_PORTLIMIT        L"msRASPortLimit"
#define RAS_PAN_ALLOWEDPORTTYPE     L"msRASAllowedPortType"
#define RAS_PAN_BAPLINEDNLIMIT      L"msRASBapLineDnLimit"
#define RAS_PAN_BAPLINEDNTIME    L"msRASBapLineDnTime"

#define RAS_PAN_BAPREQUIRED         L"msRASBapRequired"
#define  RAS_PAN_CACHETIMEOUT    L"msRASCacheTimeout"
#define RAS_PAN_EAPTYPE          L"msRASEapType"
#define RAS_PAN_SESSIONSALLOWED     L"msRASSessionsAllowed"
#define RAS_PAN_TIMEOFDAY        L"msRASTimeOfDay"

#define RAS_PAN_AUTHENTICATIONTYPE  L"msRASAuthenticationType"
#define RAS_PAN_ENCRYPTIONPOLICY L"msRASAllowEncryption"
#define RAS_PAN_ENCRYPTIONTYPE      L"msRASEncryptionType"

#ifdef   _TUNNEL
#define RAS_PAN_TUNNELTYPE       L"msRASTunnelType"
#define RAS_PAN_TUNNELMEDIUMTYPE L"msRASTunnelMediumType"
#define RAS_PAN_TUNNELSERVERENDPOINT   L"msRASTunnelServerEndpoint"
#define RAS_PAN_TUNNELPRIVATEGROUPID   L"msRASTunnelPrivateGroupId"
#endif   //_TUNNEL


//===============================================================
// for local case, neet to set footprint after saving data
#define REGKEY_REMOTEACCESS_PARAMS  L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters"
#define  REGVAL_NAME_USERSCONFIGUREDWITHMMC  L"UsersConfiguredWithMMC"
#define  REGVAL_VAL_USERSCONFIGUREDWITHMMC   1

//=====================================================================
// For machine with NO DS, ras profiles are stored in registry,
// Registry key definitions

// Root of RAS
#define RAS_REG_ROOT          HKEY_LOCAL_MACHINE
#define  RAS_REG_RAS             L"SOFTWARE\\Microsoft\\Ras"
#define  RAS_REG_RAS_T           _T("SOFTWARE\\Microsoft\\Ras")

#define  RAS_REG_PROFILES        L"Profiles"
#define  RAS_REG_PROFILES_T         _T("Profiles")

#define  RAS_REG_DEFAULT_PROFILE    L"SOFTWARE\\Microsoft\\Ras\\Profiles\\DefaultRASProfile"
#define  RAS_REG_DEFAULT_PROFILE_T  _T("SOFTWARE\\Microsoft\\Ras\\Profiles\\DefaultRASProfile")


//=================================================
// APIs
#define DllImport    __declspec( dllimport )
#define DllExport    __declspec( dllexport )

#ifndef __NOT_INCLUDE_OpenRAS_IASProfileDlg__

// =======================================================
// APIs to start profile UI
#define  RAS_IAS_PROFILEDLG_SHOW_RASTABS  0x00000001
#define  RAS_IAS_PROFILEDLG_SHOW_IASTABS  0x00000002
#define  RAS_IAS_PROFILEDLG_SHOW_WIN2K    0x00000004

DllExport HRESULT OpenRAS_IASProfileDlg(
   LPCWSTR pMachineName,   // the machine name where the snapin is focused
   ISdo* pProfile,      // profile SDO pointer
   ISdoDictionaryOld*   pDictionary,   // dictionary SDO pointer
   BOOL  bReadOnly,     // if the dlg is for readonly
   DWORD dwTabFlags,    // what to show
   void  *pvData        // additional data
);

#endif //  __NOT_INCLUDE_OpenRAS_IASProfileDlg__

#endif   // _RAS_USER_PROFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\icmp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    icmp.h

Abstract:

    This module declares the ICMP APIs that are provided for use
    primarily by the NT tcp/ip utilities.

Author:

    John Ballard (jballard)           April 1, 1993

Revision History:



--*/

#ifndef _ICMP_
#define _ICMP_


#if (_MSC_VER >= 800)
#define STRMAPI __stdcall
#else
#define _cdecl
#define STRMAPI
#endif

/*
 *
 * register_icmp returns a handle to an open stream to icmp or
 * ICMP_ERROR if an error occurs.
 *
 */

extern HANDLE STRMAPI register_icmp(void);

#define ICMP_ERROR  ((HANDLE) -3)

/*
 *
 * If an error occurs a GetLastError() will return the reason for the error.
 *
 */

#define ICMP_OPEN_ERROR     1
#define ICMP_PUTMSG_ERROR   2
#define ICMP_GETMSG_ERROR   3
#define ICMP_IN_USE         4
#define ICMP_INVALID_PROT   5

/*
 *
 * do_echo_req generates an icmp echo request packet
 *
 * parameters are:
 *
 * fd      - handle of stream to icmp (returned by register_icmp call)
 * addr    - ip address of host to ping in form returned by inet_addr()
 * data    - buffer containing data for ping packet
 * datalen - length of data buffer
 * optptr  - buffer containing ip options to use for this packet
 * optlen  - option buffer length
 * df      - don't fragment flag
 * ttl     - time to live value
 * tos     - type of service value
 * preced  - precedence value
 *
 * returns:
 *
 * 0 if no error occured or
 * standard unix error values ENOMEM, ERANGE, etc.
 *
 */

extern int STRMAPI
do_echo_req( HANDLE fd, long addr, char * data, int datalen,
             char *optptr, int optlen, int df, int ttl, int tos, int preced);


/*
 *
 * do_echo_rep receives the reply to an icmp echo request packet
 *
 * parameters are:
 *
 * fd       - handle of stream to icmp (returned by register_icmp call)
 * rdata    - buffer containing data for ping packet
 * rdatalen - length of data buffer
 * rtype    - type of packet returned (see
 * rttl     - time to live value
 * rtos     - type of service value
 * rpreced  - precedence value
 * rdf      - don't fragment flag
 * roptptr  - buffer containing ip options to use for this packet
 * roptlen  - option buffer length
 *
 * returns:
 *
 * 0 if no error occured. rtype will indicate type of packet received.
 * -1 if error occured. GetLastError() will indicate actual error.
 * -3 if invalid msg returned. GetLastError() will indicate type.
 *
 */

extern int STRMAPI
do_echo_rep( HANDLE fd, char *rdata, int rdatalen, int *rtype,
             int *rttl, int *rtos, int *rpreced, int *rdf,
             char *roptptr, int *roptlen);


/*
 * If -1 return then GetLastError returns the following.
 */

#define POLL_TIMEOUT            0
#define POLL_FAILED             1

/*
 * Values returned by do_echo_rep in rtype
 */

#define ECHO_REPLY              0               /* echo reply */
#define DEST_UNR                3               /* destination unreachable: */
#define TIME_EXCEEDED           11              /* time exceeded: */
#define PARAMETER_ERROR         12              /* parameter problem */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\icmp6.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions derived from the IPv6 specifications.
//


#ifndef ICMP6_INCLUDED
#define ICMP6_INCLUDED 1

//
// ICMPv6 Header.
// The actual message body follows this header and is type-specific.
//
typedef struct ICMPv6Header {
    UCHAR Type;       // Type of message (high bit zero for error messages).
    UCHAR Code;       // Type-specific differentiater.
    USHORT Checksum;  // Calculated over ICMPv6 message and IPv6 psuedo-header.
} ICMPv6Header;


//
// ICMPv6 Type field definitions.
//
#define ICMPv6_DESTINATION_UNREACHABLE    1
#define ICMPv6_PACKET_TOO_BIG             2
#define ICMPv6_TIME_EXCEEDED              3
#define ICMPv6_PARAMETER_PROBLEM          4

#define ICMPv6_ECHO_REQUEST               128
#define ICMPv6_ECHO_REPLY                 129
#define ICMPv6_MULTICAST_LISTENER_QUERY   130
#define ICMPv6_MULTICAST_LISTENER_REPORT  131
#define ICMPv6_MULTICAST_LISTENER_DONE    132

#define ICMPv6_ROUTER_SOLICIT             133
#define ICMPv6_ROUTER_ADVERT              134
#define ICMPv6_NEIGHBOR_SOLICIT           135
#define ICMPv6_NEIGHBOR_ADVERT            136
#define ICMPv6_REDIRECT                   137
#define ICMPv6_ROUTER_RENUMBERING         138 

#define ICMPv6_INFORMATION_TYPE(type)   ((type) & 0x80)
#define ICMPv6_ERROR_TYPE(type)         (((type) & 0x80) == 0)

// Max amount of packet data in an ICMP error message.
#define ICMPv6_ERROR_MAX_DATA_LEN                       \
        (IPv6_MINIMUM_MTU - sizeof(IPv6Header) -        \
         sizeof(ICMPv6Header) - sizeof(UINT))


//
// ICMPv6 Code field definitions.
//

// For Destination Unreachable errors:
#define ICMPv6_NO_ROUTE_TO_DESTINATION          0
#define ICMPv6_COMMUNICATION_PROHIBITED         1
//  was ICMPv6_NOT_NEIGHBOR                     2
#define ICMPv6_SCOPE_MISMATCH                   2
#define ICMPv6_ADDRESS_UNREACHABLE              3
#define ICMPv6_PORT_UNREACHABLE                 4

// For Time Exceeded errors:
#define ICMPv6_HOP_LIMIT_EXCEEDED               0
#define ICMPv6_REASSEMBLY_TIME_EXCEEDED         1

// For Parameter Problem errors:
#define ICMPv6_ERRONEOUS_HEADER_FIELD           0
#define ICMPv6_UNRECOGNIZED_NEXT_HEADER         1
#define ICMPv6_UNRECOGNIZED_OPTION              2

//
//  Neighbor Discovery message option definitions.
//
#define ND_OPTION_SOURCE_LINK_LAYER_ADDRESS     1
#define ND_OPTION_TARGET_LINK_LAYER_ADDRESS     2
#define ND_OPTION_PREFIX_INFORMATION            3
#define ND_OPTION_REDIRECTED_HEADER             4
#define ND_OPTION_MTU                           5
#define ND_NBMA_SHORTCUT_LIMIT                  6  // Related to IPv6-NBMA.
#define ND_ADVERTISEMENT_INTERVAL               7  // For IPv6 Mobility.
#define ND_HOME_AGENT_INFO                      8  // For IPv6 Mobility.
#define ND_OPTION_ROUTE_INFORMATION             9

//
//  Neighbor Advertisement message flags.
//
#define ND_NA_FLAG_ROUTER    0x80000000
#define ND_NA_FLAG_SOLICITED 0x40000000
#define ND_NA_FLAG_OVERRIDE  0x20000000

typedef struct NDRouterAdvertisement {
  UCHAR  CurHopLimit;
  UCHAR  Flags;
  USHORT RouterLifetime;
  UINT   ReachableTime;
  UINT   RetransTimer;
} NDRouterAdvertisement;

//
// Router Advertisement message flags.
//
#define ND_RA_FLAG_MANAGED      0x80
#define ND_RA_FLAG_OTHER        0x40
#define ND_RA_FLAG_HOME_AGENT   0x20
#define ND_RA_FLAG_PREFERENCE   0x18    // A two-bit field.

typedef struct NDOptionMTU {
    UCHAR Type;
    UCHAR Length;
    USHORT Reserved;
    UINT MTU;
} NDOptionMTU;

typedef struct NDOptionPrefixInformation {
    UCHAR Type;
    UCHAR Length;
    UCHAR PrefixLength;
    UCHAR Flags;
    UINT ValidLifetime;
    UINT PreferredLifetime;
    union { // Preserve compatibility with the pre-SitePrefixLength version.
        UINT Reserved2;
        struct {
            UCHAR Reserved3[3];
            UCHAR SitePrefixLength;
        };
    };
    IN6_ADDR Prefix;
} NDOptionPrefixInformation;

//
// Prefix Information option flags.
//
#define ND_PREFIX_FLAG_ON_LINK          0x80
#define ND_PREFIX_FLAG_AUTONOMOUS       0x40
#define ND_PREFIX_FLAG_ROUTER_ADDRESS   0x20
#define ND_PREFIX_FLAG_SITE_PREFIX      0x10
#define ND_PREFIX_FLAG_ROUTE            0x01

//
// NDOptionRouteInformation is actually variable-sized.
// If PrefixLength is zero, then the Prefix field may be 0 bytes.
// If PrefixLength is <= 64, then the Prefix field may be 8 bytes.
// Otherwise the Prefix field is a full 16 bytes.
//
typedef struct NDOptionRouteInformation {
    UCHAR Type;
    UCHAR Length;
    UCHAR PrefixLength;
    UCHAR Flags;
    UINT RouteLifetime;
    IN6_ADDR Prefix;
} NDOptionRouteInformation;


//
// MLD message struct - this immediately follows the ICMPv6 header.
// NB: If IN6_ADDR ever has stricter alignment than USHORT,
// this definition will need to change. Probably it should
// include ICMPv6Header so that GroupAddr is aligned properly.
//
typedef struct MLDMessage {
    USHORT MaxResponseDelay;
    USHORT Unused;
    IN6_ADDR GroupAddr;
} MLDMessage;

C_ASSERT(__builtin_alignof(MLDMessage) == __builtin_alignof(USHORT));

//
// Router Renumbering code values.
//
#define RR_COMMAND           0
#define RR_RESULT            1                                       
#define RR_SEQUENCE_NO_RESET 255                               

#endif // ICMP6_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ip.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IP.H - IP public definitions.
//
// This file contains all of the definitions that are exported
// out of the IP module to other VxDs. Some other information (such
// as error codes and the IPOptInfo structure) is define in ipexport.h

#pragma once
#ifndef IP_H_INCLUDED
#define IP_H_INCLUDED

#ifndef IP_EXPORT_INCLUDED
#include "ipexport.h"
#endif

#if !MILLEN
#define TCP_NAME                    L"TCPIP"
#else // !MILLEN
#define TCP_NAME                    L"MSTCP"
#endif // MILLEN

#define IP_NET_STATUS               0
#define IP_HW_STATUS                1
#define IP_RECONFIG_STATUS          2

#define MASK_NET                    0
#define MASK_SUBNET                 1

#define IP_DRIVER_VERSION           1

#define TOS_DEFAULT                 0x00
#define TOS_MASK                    0x03

//* IP offload capability flags (OffloadFlags)

#define TCP_XMT_CHECKSUM_OFFLOAD        0x00000001
#define IP_XMT_CHECKSUM_OFFLOAD         0x00000002
#define TCP_RCV_CHECKSUM_OFFLOAD        0x00000004
#define IP_RCV_CHECKSUM_OFFLOAD         0x00000008
#define TCP_LARGE_SEND_OFFLOAD          0x00000010

#define IP_CHECKSUM_OPT_OFFLOAD         0x00000020
#define TCP_CHECKSUM_OPT_OFFLOAD        0x00000040
#define TCP_LARGE_SEND_TCPOPT_OFFLOAD   0x00000080
#define TCP_LARGE_SEND_IPOPT_OFFLOAD    0x00000100

#define TCP_IP_OFFLOAD_TYPES           (TCP_XMT_CHECKSUM_OFFLOAD        | \
                                        IP_XMT_CHECKSUM_OFFLOAD         | \
                                        TCP_RCV_CHECKSUM_OFFLOAD        | \
                                        IP_RCV_CHECKSUM_OFFLOAD         | \
                                        TCP_LARGE_SEND_OFFLOAD          | \
                                        IP_CHECKSUM_OPT_OFFLOAD         | \
                                        TCP_CHECKSUM_OPT_OFFLOAD        | \
                                        TCP_LARGE_SEND_TCPOPT_OFFLOAD   | \
                                        TCP_LARGE_SEND_IPOPT_OFFLOAD)

//* IPSec offload capability flags (IPSecOffloadFlags)
//
// IPSEC General Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_CRYPTO_ONLY       0x00000001  // Raw crypto mode supported
#define IPSEC_OFFLOAD_AH_ESP            0x00000002  // Combined AH+ESP supported
#define IPSEC_OFFLOAD_TPT_TUNNEL        0x00000004  // Combined Tpt+Tunnel supported
#define IPSEC_OFFLOAD_V4_OPTIONS        0x00000008  // IPV4 Options supported
#define IPSEC_OFFLOAD_QUERY_SPI         0x00000010  // Get SPI supported

//
// IPSEC AH Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_AH_XMT            0x00000020  // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_AH_RCV            0x00000040  // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_AH_TPT            0x00000080  // IPSEC transport mode supported
#define IPSEC_OFFLOAD_AH_TUNNEL         0x00000100  // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_AH_MD5            0x00000200  // MD5 supported as AH and ESP algo
#define IPSEC_OFFLOAD_AH_SHA_1          0x00000400  // SHA_1 supported as AH and ESP algo

//
// IPSEC ESP Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_ESP_XMT           0x00000800  // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_ESP_RCV           0x00001000  // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_ESP_TPT           0x00002000  // IPSEC transport mode supported
#define IPSEC_OFFLOAD_ESP_TUNNEL        0x00004000  // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_ESP_DES           0x00008000  // DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_DES_40        0x00010000  // DES40 supported as ESP algo
#define IPSEC_OFFLOAD_ESP_3_DES         0x00020000  // 3DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_NONE          0x00040000  // Null ESP supported as ESP algo

#define IPSEC_OFFLOAD_TPT_UDPESP_IKE                    0x00080000
#define IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE                 0x00100000
#define IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_IKE        0x00200000
#define IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_IKE   0x00400000

#define IPSEC_OFFLOAD_TPT_UDPESP_OTHER                  0x00800000
#define IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER               0x01000000
#define IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_OTHER      0x02000000
#define IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_OTHER 0x04000000


#define PROTOCOL_ANY                0

// IP interface characteristics

#define IF_FLAGS_P2P             1      // Point to point interface
#define IF_FLAGS_DELETING        2      // Interface is in the process of going away
#define IF_FLAGS_NOIPADDR        4      // unnumbered interface
#define IF_FLAGS_P2MP            8      // Point to multi-point
#define IF_FLAGS_REMOVING_POWER  0x10   // interface power is about to go away.
#define IF_FLAGS_POWER_DOWN      0x20   // interface power is gone.
#define IF_FLAGS_REMOVING_DEVICE 0x40   // query remove was indicated to us.
#define IF_FLAGS_NOLINKBCST      0x80   // Needed for P2MP
#define IF_FLAGS_UNI             0x100  // Uni-direction interface.
#define IF_FLAGS_MEDIASENSE      0x200  // Indicates mediasense enabled on IF.

typedef enum _IP_DF_ENCAP {
    CopyDfEncap,
    DefaultDfEncap = CopyDfEncap,
    SetDfEncap,
    ClearDfEncap,
    MaxDfEncap
} IP_DF_ENCAP, *PIP_DF_ENCAP;

//* IP Header format.
typedef struct IPHeader {
    uchar       iph_verlen;             // Version and length.
    uchar       iph_tos;                // Type of service.
    ushort      iph_length;             // Total length of datagram.
    ushort      iph_id;                 // Identification.
    ushort      iph_offset;             // Flags and fragment offset.
    uchar       iph_ttl;                // Time to live.
    uchar       iph_protocol;           // Protocol.
    ushort      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
} IPHeader;

/*NOINC*/
#define NULL_IP_ADDR        0
#define IP_ADDR_EQUAL(x,y)  ((x) == (y))
#define IP_LOOPBACK_ADDR(x) (((x) & 0xff) == 0x7f)
#define CLASSD_ADDR(a)      (( (*((uchar *)&(a))) & 0xf0) == 0xe0)

typedef void *IPContext; // An IP context value.

//* Structure of a route cache entry. A route cache entry functions as a pointer
//  to some routing info. There is one per remote destination, and the memory
//  is owned by the IP layer.
//
#define RCE_CONTEXT_SIZE    (sizeof(void *) * 2) // Right now we use two contexts.

typedef struct RouteCacheEntry {
    struct RouteCacheEntry  *rce_next;      // Next RCE in list.
    struct RouteTableEntry  *rce_rte;       // Back pointer to owning RTE.
    IPAddr                  rce_dest;       // Destination address being cached.
    IPAddr                  rce_src;        // Source address for this RCE.
    uchar                   rce_flags;      // Valid flags.
    uchar                   rce_dtype;      // Type of destination address.
    uchar                   rce_TcpDelAckTicks;
    uchar                   rce_TcpAckFrequency;
    uint                    rce_usecnt;     // Count of people using it.
    uchar                   rce_context[RCE_CONTEXT_SIZE]; // Space for lower layer context

    //
    // DEFINE_LOCK_STRUCTURE resolves to NULL on retail builds.
    // Moved this down so that debug ARP modules can co-exist with retail IP.
    //
    DEFINE_LOCK_STRUCTURE(rce_lock)         // Lock for this RCE

    uint                     rce_OffloadFlags;   // interface chksum capability flags
    NDIS_TASK_TCP_LARGE_SEND rce_TcpLargeSend;
    uint                     rce_TcpWindowSize;
    uint                     rce_TcpInitialRTT;
    uint                     rce_cnt;
    uint                     rce_mediaspeed;  // for initial options selection.
    uint                     rce_newmtu;
} RouteCacheEntry;

//
// Definiton for a rt table change callout.
// TODO - pass a rt table entry and action - add, delete, update
// In case of delete, it means that this route went away
//
typedef void (*IPRtChangePtr)( VOID );

#define RCE_VALID           0x1
#define RCE_CONNECTED       0x2
#define RCE_REFERENCED      0x4
#define RCE_DEADGW          0x8
#define RCE_LINK_DELETED           0x10
#define RCE_ALL_VALID       (RCE_VALID | RCE_CONNECTED | RCE_REFERENCED)

/*INC*/

//* Structure of option info.
typedef struct IPOptInfo {
    uchar       *ioi_options;       // Pointer to options (NULL if none).
    IPAddr      ioi_addr;           // First hop address, if this is source routed.
    uchar       ioi_optlength;      // Length (in bytes) of options.
    uchar       ioi_ttl;            // Time to live of this packet.
    uchar       ioi_tos;            // Type of service for packet.
    uchar       ioi_flags;          // Flags for this packet.
    uchar       ioi_hdrincl : 1;        // use IP header coming from the user
    uchar       ioi_TcpChksum : 1;
    uchar       ioi_UdpChksum : 1;
    uchar       ioi_limitbcasts : 2;
    uint        ioi_uni;            // UN numbered interface index
    uint        ioi_ucastif;        // strong host routing
    uint        ioi_mcastif;        // mcastif on unnumbered interface
    int         ioi_GPCHandle;
} IPOptInfo;

#define IP_FLAG_SSRR    0x80        // There options have a SSRR in them.
#define IP_FLAG_IPSEC   0x40        // Set if reinjected from IPSEC.

typedef enum _IP_LIMIT_BCASTS {
    DisableSendOnSource,
    EnableSendOnSource,
    OnlySendOnSource
} IP_LIMIT_BCASTS, *PIP_LIMIT_BCASTS;

/*NOINC*/
//* Structure of a packet context.
typedef struct PacketContext {
    struct PCCommon {
        PNDIS_PACKET        pc_link;        // Link on chain of packets.
        uchar               pc_owner;       // Owner of packet.
        uchar               pc_flags;       // Flags concerning this packet.
        ushort              pc_pad;         // Pad to 32 bit boundary.
        PVOID               pc_IpsecCtx;    // send complete ctx for IPSEC
    } pc_common;

    struct BufferReference  *pc_br;         // Pointer to buffer reference structure.
    struct ProtInfo         *pc_pi;         // Protocol info structure for this packet.
    void                    *pc_context;    // Protocol context to be passed back on send cmplt.
    struct Interface        *pc_if;         // Interface this packet was sent on.
    PNDIS_BUFFER            pc_hdrincl;
    PNDIS_BUFFER            pc_firewall;
    struct IPRcvBuf         *pc_firewall2;
    struct LinkEntry        *pc_iflink;
    uchar                   pc_ipsec_flags; // for ipsec fragment path
} PacketContext;

// Different Modes we pass to ipsetndisrequest
#define CLEAR_IF    0   // clear the option on the netcard plus the interface
#define SET_IF      1   // set the option on the netcard plus the interface
#define CLEAR_CARD  2   // clear the option only on the card

// Flags passed to ipi_checkroute
#define CHECK_RCE_ONLY  0x00000001

//* The structure of configuration information passed to an upper layer.
//
typedef struct IPInfo {
    uint        ipi_version;            // Version of the IP driver.
    uint        ipi_hsize;              // Size of the header.
    IP_STATUS   (*ipi_xmit)(void *, void *, PNDIS_BUFFER, uint, IPAddr, IPAddr,
                    IPOptInfo *, RouteCacheEntry *, uchar, IRP *);
    void        *(*ipi_protreg)(uchar, void *, void *, void *, void *, void *, void *);
    IPAddr      (*ipi_openrce)(IPAddr, IPAddr, RouteCacheEntry **, uchar *,
                    ushort *, IPOptInfo *);
    void        (*ipi_closerce)(RouteCacheEntry *);
    uchar       (*ipi_getaddrtype)(IPAddr);
    uchar       (*ipi_getlocalmtu)(IPAddr, ushort *);
    IP_STATUS   (*ipi_getpinfo)(IPAddr, IPAddr, uint *, uint *, RouteCacheEntry *);
    void        (*ipi_checkroute)(IPAddr, IPAddr, RouteCacheEntry *, IPOptInfo *, uint);
    void        (*ipi_initopts)(struct IPOptInfo *);
    IP_STATUS   (*ipi_updateopts)(struct IPOptInfo *, struct IPOptInfo *, IPAddr, IPAddr);
    IP_STATUS   (*ipi_copyopts)(uchar *, uint, struct IPOptInfo *);
    IP_STATUS   (*ipi_freeopts)(struct IPOptInfo *);
    long        (*ipi_qinfo)(struct TDIObjectID *ID, PNDIS_BUFFER Buffer,
                    uint *Size, void *Context);
    long        (*ipi_setinfo)(struct TDIObjectID *ID, void *Buffer, uint Size);
    long        (*ipi_getelist)(void *, uint *);
    IP_STATUS   (*ipi_setmcastaddr)(IPAddr, IPAddr, uint, uint, IPAddr *,
                                    uint, IPAddr *);
    uint        (*ipi_invalidsrc)(IPAddr);
    uint        (*ipi_isdhcpinterface)(void *IPContext);
    ulong       (*ipi_setndisrequest)(IPAddr, NDIS_OID, uint, uint);
    IP_STATUS   (*ipi_largexmit)(void *, void *, PNDIS_BUFFER, uint, IPAddr, IPAddr,
                    IPOptInfo *, RouteCacheEntry *, uchar,uint *, uint);
    ulong       (*ipi_absorbrtralert)(IPAddr Addr, uchar Protocol, uint IfIndex);
    IPAddr      (*ipi_isvalidindex)(uint Index);
    uint        (*ipi_getifindexfromnte)(void *NTE, uint Capabilities);
    BOOLEAN     (*ipi_isrtralertpacket)(IPHeader UNALIGNED *Header);
    ulong       (*ipi_getifindexfromaddr)(IPAddr Addr, uint Capabilities);
    void        (*ipi_cancelpackets)(void *, void *);

    IP_STATUS   (*ipi_setmcastinclude)(IPAddr, IPAddr, uint, IPAddr *,
                                       uint, IPAddr *);
    IP_STATUS   (*ipi_setmcastexclude)(IPAddr, IPAddr, uint, IPAddr *,
                                       uint, IPAddr *);
    IPAddr      (*ipi_getmcastifaddr)();
    ushort      (*ipi_getipid)();
    void        *(*ipi_protdereg)(uchar);
    uint        (*ipi_getifindexfromindicatecontext)(void *NTE);
} IPInfo;

/*INC*/

#define MCAST_INCLUDE 0
#define MCAST_EXCLUDE 1

#define PACKET_OWNER_LINK   0
#define PACKET_OWNER_IP     1

//  Definition of destination types. We use the low bit to indicate that a type is a broadcast
//  type. All local types must be less than DEST_REMOTE.

//
// The various bits for this are set as follows:
//
//  |--------|
//        MOB
//
//  B   Broadcast bit
//  O   Offnet bit
//  M   Multicast bit --> must also have the B bit set
//

#define DEST_LOCAL      0                       // Destination is local.
#define DEST_BCAST      1                       // Destination is net or local bcast.
#define DEST_SN_BCAST   3                       // A subnet bcast.
#define DEST_MCAST      5                       // A local mcast.
#define DEST_REMOTE     8                       // Destination is remote.
#define DEST_REM_BCAST  11                      // Destination is a remote broadcast
#define DEST_REM_MCAST  13                      // Destination is a remote mcast.
#define DEST_INVALID    0xff                    // Invalid destination
#define DEST_PROMIS     32                      // Dest is promiscuous(32=0x20)
#define DEST_BCAST_BIT  1
#define DEST_OFFNET_BIT 0x10                    // Destination is offnet -
                                                // used only by upper layer
                                                // callers.
#define DEST_MCAST_BIT  5

/*NOINC*/
#define IS_BCAST_DEST(D)    ((D) & DEST_BCAST_BIT)

// The following macro is to be used ONLY on the destination returned from
// OpenRCE, and only by upper layer callers.
#define IS_OFFNET_DEST(D)   ((D) & DEST_OFFNET_BIT)
#define IS_MCAST_DEST(D)    (((D) & DEST_MCAST_BIT) == DEST_MCAST_BIT)
/*INC*/

//  Definition of an IP receive buffer chain.
typedef struct IPRcvBuf {
    struct IPRcvBuf     *ipr_next;              // Next buffer descriptor in chain.
    uint                ipr_owner;              // Owner of buffer.
    uchar               *ipr_buffer;            // Pointer to buffer.
    uint                ipr_size;               // Buffer size.
    PMDL                ipr_pMdl;
    uint                *ipr_pClientCnt;
    uchar               *ipr_RcvContext;
    uint                ipr_RcvOffset;
    ulong               ipr_flags;
} IPRcvBuf;

#define IPR_OWNER_IP    0
#define IPR_OWNER_ICMP  1
#define IPR_OWNER_UDP   2
#define IPR_OWNER_TCP   3
#define IPR_OWNER_FIREWALL 4
#define IPR_OWNER_STACK 5

#define MIN_FIRST_SIZE  200                     // Minimum size of first buffer.

#define IPR_FLAG_PROMISCUOUS        0x00000001
#define IPR_FLAG_CHECKSUM_OFFLOAD   0x00000002
#define IPR_FLAG_IPSEC_TRANSFORMED  0x00000004
#define IPR_FLAG_BUFFER_UNCHANGED   0x00000008
#define IPR_FLAG_LOOPBACK_PACKET    0x00000010

//  Flags that characterize receive indications to the transports.
#define IS_BROADCAST                0x01        // Indicates a broadcast packet.
#define IS_BOUND                    0x02        // Receive happened on the same 
                                                // processor as the previous one.

//* Structure of context info. passed down for query entity list.
typedef struct QEContext {
    uint                qec_count;              // Number of IDs currently in
                                                // buffer.
    struct TDIEntityID  *qec_buffer;            // Pointer to buffer.
} QEContext;


//
// Function to get time ticks value to save in if_lastchange.
//

__inline
ULONG
GetTimeTicks()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    //
    // Convert to 100ns (10^-7 seconds) to centaseconds (10^-2 seconds)
    //
    Time.QuadPart /= 100000;

    //
    // Return the result (mod 2^32)
    //
    return Time.LowPart;
}


//
// Functions exported in NT by the IP driver for use by transport
// layer drivers.
//

IP_STATUS
IPGetInfo(
    IPInfo  *Buffer,
    int      Size
    );

void *
IPRegisterProtocol(
    uchar  Protocol,
    void  *RcvHandler,
    void  *XmitHandler,
    void  *StatusHandler,
    void  *RcvCmpltHandler,
    void  *PnPHandler,
    void  *ElistHandler
    );

void *
IPDeregisterProtocol(
    uchar  Protocol
    );



#endif // IP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\icmpif.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** ICMPIF.H - ICMP echo private kernel/user request interface
//

#ifndef	ICMPIF_INCLUDED
#define	ICMPIF_INCLUDED


//
// Common ICMP request structure
//
typedef struct icmp_echo_request {
    unsigned long         Address;          // Destination address
    unsigned long         Timeout;          // Request timeout
    unsigned short        DataOffset;       // Echo data
    unsigned short        DataSize;         // Echo data size
    unsigned char         OptionsValid;     // nonzero if options data is valid.
    unsigned char         Ttl;              // IP header Time To Live
    unsigned char         Tos;              // IP header Type of Service
    unsigned char         Flags;            // IP header flags
    unsigned short        OptionsOffset;    // IP options data
    unsigned char         OptionsSize;      // IP options data size
    unsigned char         Padding;          // 32-bit alignment padding
} ICMP_ECHO_REQUEST, *PICMP_ECHO_REQUEST;


//
// The reply structure is defined in ipexport.h
//

#endif // ICMPIF_INCLUDED

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\intrface.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    intrface.h

Abstract:

    Definition for user-mode/kernel-mode tapi/connection wrapper interface.

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Revision History:

--*/



#define NDISTAPIERR_UNINITIALIZED   0x00001001
#define NDISTAPIERR_BADDEVICEID     0x00001002
#define NDISTAPIERR_DEVICEOFFLINE   0x00001003



//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_NDISTAPI  0x00008fff



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define NDISTAPI_IOCTL_INDEX  0x8f0



//
// The NDISTAPI device driver IOCTLs
//

#define IOCTL_NDISTAPI_CONNECT           CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX,     \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_DISCONNECT        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 1, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_QUERY_INFO        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 2, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_SET_INFO          CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 3, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_GET_LINE_EVENTS   CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 4, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_CREATE            CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 5, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

//
// Type definitions
//

typedef struct _NDISTAPI_REQUEST
{
    //
    // Return value
    //

    OUT     ULONG   ulReturnValue;

    //
    // Operation idenfifier
    //

    IN      ULONG   Oid;

    //
    // Target line device ID
    //

    IN      ULONG   ulDeviceID;

    //
    // Total size of request data in buffer
    //

    IN      ULONG   ulDataSize;

    //
    // Buffer for request data
    //

    IN OUT  UCHAR   Data[1];

} NDISTAPI_REQUEST, *PNDISTAPI_REQUEST;

//
// Returns info to kmddsp in the LINE_OPEN OID
//
typedef struct _NDISTAPI_OPENDATA {

	//
	// GUID of the adapter that owns this line
	//
	OUT		GUID	Guid;

	//
	// Media type of the adapter that owns this line
	//
	OUT		NDIS_WAN_MEDIUM_SUBTYPE	MediaType;

} NDISTAPI_OPENDATA, *PNDISTAPI_OPENDATA;

typedef struct _NDISTAPI_EVENT_DATA
{
    //
    // Total size of the event data buffer
    //

    IN      ULONG   ulTotalSize;

    //
    // Size of the returned event data
    //

    OUT     ULONG   ulUsedSize;

    //
    // Event data buffer
    //

    OUT     UCHAR   Data[1];

} NDISTAPI_EVENT_DATA, *PNDISTAPI_EVENT_DATA;

//
// Info for a LINE_CREATE
//
typedef struct _NDISTAPI_CREATE_INFO {

    //
    // Given by NdisTapi in LINE_CREATE indication
    //
    IN  ULONG_PTR TempID;

    //
    // The ID for this device
    //
    IN  ULONG   DeviceID;
} NDISTAPI_CREATE_INFO, *PNDISTAPI_CREATE_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipcmp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ipcmp.h

Abstract:
    Compare utility functions for IP

Revision History:

    Amritansh Raghav          6/16/95  Created

--*/

#ifndef __IPUTILS_H__
#define __IPUTILS_H__

//
// ULONG
// Cmp(DWORD dwFirst, DWORD dwSecond, ULONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((ULONG)((lResult) = ((dwFirst) - (dwSecond))))

//
// LONG
// PortCmp(WORD wPort1, WORD wPort2, LONG lResult)
//

#define PortCmp(dwPort1, dwPort2,lResult) ((LONG)((lResult) = ((ntohs((WORD)dwPort1)) - (ntohs((WORD)dwPort2)))))

// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                            \
            ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
                    (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
                     (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
                      ((res) = ((((dwIpAddr1) & 0xff000000)>>8) - (((dwIpAddr2) & 0xff000000)>>8)))))))


#endif // __IPUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\iphlpint.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    public\sdk\inc\iphlpapi.h

Abstract:
    Some private APIs. These are used by multimedia streaming code and
    MIB-II subagent. From the days this was mib2util.dll

Revision History:
    Amritansh Raghav    Created


--*/

#ifndef __IPHLPINT_H__
#define __IPHLPINT_H__

#include <iprtrmib.h>


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The InternalGetXXXTable APIs take a pointer to a pointer to a buffer,    //
// a heap from which to allocate from, and flags used for allocation.  The  //
// APIs allocate a buffer for the user.  If NO_ERROR is returned, the       //
// the returned buffer is valid (even if it has no entries) and it is the   //
// callers duty to free the memory. This is different from the external     //
// APIs in that those return ERROR_NO_DATA if there are no entries          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
InternalGetIfTable(
    OUT  MIB_IFTABLE  **ppIfTable,
    IN   HANDLE       hHeap,
    IN   DWORD        dwAllocFlags
    );

DWORD
InternalGetIpAddrTable(
    OUT  MIB_IPADDRTABLE  **ppIpAddrTable,
    IN   HANDLE           hHeap,
    IN   DWORD            dwAllocFlags
    );

DWORD
InternalGetIpNetTable(
    OUT   MIB_IPNETTABLE    **ppIpNetTable,
    IN    HANDLE            hHeap,
    IN    DWORD             dwAllocFlags
    );

DWORD
InternalGetIpForwardTable(
    OUT   MIB_IPFORWARDTABLE    **ppIpForwardTable,
    IN    HANDLE                hHeap,
    IN    DWORD                 dwAllocFlags
    );

DWORD
InternalGetTcpTable(
    OUT MIB_TCPTABLE    **ppTcpTable,
    IN  HANDLE          hHeap,
    IN  DWORD           dwAllocFlags
    );

DWORD
InternalGetUdpTable(
    OUT MIB_UDPTABLE    **ppUdpTable,
    IN  HANDLE          hHeap,
    IN  DWORD           dwAllocFlags
    );

DWORD
InternalSetIfEntry(
    IN   PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalCreateIpForwardEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalSetIpForwardEntry(
    IN    PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalDeleteIpForwardEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalSetIpStats(
    IN   PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalCreateIpNetEntry(
    IN PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalSetIpNetEntry(
    PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalDeleteIpNetEntry(
    PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
InternalSetTcpEntry(
    PMIB_OPAQUE_INFO pInfoRow
    );

DWORD
OpenAdapterKey(
    LPSTR Name,
    PHKEY Key
    );

DWORD
ReadRegistryDword(
    HKEY Key,
    LPSTR ParameterName,
    PULONG Value
    );

DWORD
GetAdapterIPInterfaceContext(
    IN LPSTR  AdapterName,
    OUT PULONG Context
    );

DWORD
GetAdapterIndex(
    IN LPWSTR  AdapterName,
    OUT PULONG IfIndex
    );

DWORD
AddIPAddress(
    IPAddr  Address,
    IPMask  IpMask,
    ULONG   IfIndex,
    PULONG  NTEContext,
    PULONG  NTEInstance
    );

DWORD
DeleteIPAddress(
    ULONG NTEContext
    );

BOOL
GetRTT(
    IPAddr DestIpAddress,
    PULONG Rtt
    );

BOOLEAN
GetHopCounts(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops
    );


BOOL
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    );

DWORD
GetInterfaceInfo(OUT PIP_INTERFACE_INFO pIPIfInfo,
                 OUT PULONG dwOutBufLen
                );



DWORD
IsLocalAddress(
    IPAddr InAddress
    );

DWORD
AddArpEntry(
    IPAddr IPAddress,
    PUCHAR pPhyAddress,
    ULONG  PhyAddrLen,
    ULONG IfIndex,
    BOOLEAN Dynamic

    );

DWORD
DeleteArpEntry(
    IPAddr IPAddress,
    ULONG IfIndex
    );

DWORD
NotifyAddrChange(
    HANDLE *pHandle, 
    OVERLAPPED *pOverlapped
    );

DWORD
NotifyRouteChange(
    HANDLE *pHandle, 
    OVERLAPPED *pOverlapped
    );

DWORD
DhcpReleaseParameters(
    LPWSTR AdapterName
    );

DWORD
DhcpRenewAddress(
    LPWSTR AdapterName
    );

#endif // __IPHLPINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipfilter.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//***   ipfilter.h - IP filterng and demand dial header file.
//
//  Contains definitions for constants and prototypes related to IP filtering and
//  dial on demand support.
#pragma once
#ifndef IPFILTER_INCLUDED
#define IPFILTER_INCLUDED

#include <ipexport.h>
#include <ipfltinf.h>

#include <gpcifc.h>

#define RESERVED_IF_INDEX   0xffffffff      // The reserved inteface index.
#define INVALID_IF_INDEX    0xffffffff      // The invalid inteface index.

#define LOCAL_IF_INDEX          0           // Local inteface index.

typedef ulong    ROUTE_CONTEXT;     // Context in an unattached route.


//
// Indicates whether it is a transmitted or received packet.
//
typedef enum _IP_DIRECTION_E {
    IP_TRANSMIT,
    IP_RECEIVE
} DIRECTION_E, *PDIRECTION_E;

typedef struct _FIREWALL_CONTEXT_T {
    DIRECTION_E  Direction;
    void         *NTE;
    void         *LinkCtxt;
    NDIS_HANDLE  LContext1;
    UINT         LContext2;
} FIREWALL_CONTEXT_T, *PFIREWALL_CONTEXT_T;

// Definition for pointer to callout that maps a route to an interface.
typedef unsigned int (*IPMapRouteToInterfacePtr)(ROUTE_CONTEXT Context,
    IPAddr Destination, IPAddr Source, unsigned char Protocol,
    unsigned char *Buffer, unsigned int Length, IPAddr HdrSrc);

// Definiton for a filter routine callout.
typedef FORWARD_ACTION (*IPPacketFilterPtr)(
                              struct IPHeader UNALIGNED *PacketHeader,
                              uchar     *Packet,
                              uint      PacketLength,
                              uint      RecvInterfaceIndex,
                              uint      SendInterfaceIndex,
                              IPAddr    RecvLinkNextHop,
                              IPAddr    SendLinkNextHop);

// Definiton for a firewall routine callout.
typedef FORWARD_ACTION (*IPPacketFirewallPtr)(
                              void      **pData,  //can be pMdl or pRcvBuf
                              uint      RecvInterfaceIndex,
                              uint      *pSendInterfaceIndex,
                              uchar     *pDestinationType,
                              void      *pContext,
                              UINT      ContextLength,
                              struct IPRcvBuf      **pRcvBuf
                              );
extern
int
IPAllocBuff(
    struct IPRcvBuf*   pRcvBuf,
    UINT Size
    );

extern
VOID
IPFreeBuff(
    struct IPRcvBuf*   pRcvBuf
    );

extern
VOID
FreeIprBuff(
    struct IPRcvBuf* pRcvBuf
    );

extern
VOID
IPFreeHeaders(
     struct IPRcvBuf  *pRcvBuf
    );

typedef enum _IPROUTEINFOCLASS {
    IPRouteNoInformation,
    IPRouteOutgoingFirewallContext,
    IPRouteOutgoingFilterContext,
    MaxIPRouteInfoClass
} IPROUTEINFOCLASS;

extern
NTSTATUS
LookupRouteInformation(
    IN      VOID*               RouteLookupData,
    OUT     VOID*               RouteEntry      OPTIONAL,
    IN      IPROUTEINFOCLASS    RouteInfoClass  OPTIONAL,
    OUT     VOID*               RouteInformation    OPTIONAL,
    IN OUT  UINT*               RouteInfoLength OPTIONAL
    );

extern
NTSTATUS
LookupRouteInformationWithBuffer(
    IN      VOID*               RouteLookupData,
    IN      PUCHAR              Buffer          OPTIONAL,
    IN      UINT                BufferLength    OPTIONAL,
    OUT     VOID*               RouteEntry      OPTIONAL,
    IN      IPROUTEINFOCLASS    RouteInfoClass  OPTIONAL,
    OUT     VOID*               RouteInformation    OPTIONAL,
    IN OUT  UINT*               RouteInfoLength OPTIONAL
    );

//
// IPSEC stuff - shd this be in a new header??
//
#define IPSEC_RESERVED  110
#define PROTOCOL_AH     51
#define PROTOCOL_ESP    50
#define PROTOCOL_COMP   108
#define PROTOCOL_TCP    6
#define PROTOCOL_UDP    17
#define PROTOCOL_RSVP   46
#define PROTOCOL_ICMP   1
#define IP_IN_IP        4

//
// Context passed to IPSEC on send complete
//
typedef struct _IPSEC_SEND_COMPLETE_CONTEXT {
    UCHAR Signature[4];                  // contains "ISC?" for debug build
    ULONG   Flags;
    PNDIS_BUFFER    OptMdl;
    PNDIS_BUFFER    OriAHMdl;
    PNDIS_BUFFER    OriHUMdl;
    PNDIS_BUFFER    OriTuMdl;
    PNDIS_BUFFER    PrevMdl;
    PNDIS_BUFFER    PrevTuMdl;
    PNDIS_BUFFER    AHMdl;
    PNDIS_BUFFER    AHTuMdl;
    PNDIS_BUFFER    PadMdl;
    PNDIS_BUFFER    PadTuMdl;
    PNDIS_BUFFER    HUMdl;
    PNDIS_BUFFER    HUTuMdl;
    PNDIS_BUFFER    BeforePadMdl;
    PNDIS_BUFFER    BeforePadTuMdl;
    PNDIS_BUFFER    HUHdrMdl;
    PNDIS_BUFFER    OriAHMdl2;
    PNDIS_BUFFER    PrevAHMdl2;
    PNDIS_BUFFER    AHMdl2;
    PNDIS_BUFFER    FlushMdl;
    PVOID           pSA;
    PVOID           pNextSA;
    PVOID           PktExt;
    PVOID           pMTUContext;
    PNDIS_IPSEC_PACKET_INFO PktInfo;
} IPSEC_SEND_COMPLETE_CONTEXT, *PIPSEC_SEND_COMPLETE_CONTEXT;

//
// Flags used on send complete
//
#define SCF_AH      0x00000001
#define SCF_AH_TU   0x00000002
#define SCF_HU_TPT  0x00000004
#define SCF_HU_TU   0x00000008
#define SCF_FLUSH   0x00000010
#define SCF_FRAG    0x00000020
#define SCF_NOE_TPT 0x00000040
#define SCF_NOE_TU  0x00000080
#define SCF_AH_2    0x00000100
#define SCF_PKTINFO 0x00000200
#define SCF_PKTEXT  0x00000400
#define SCF_MTU     0x00000800

#define IPSEC_FLAG_FLUSH                0x00000001
#define IPSEC_FLAG_FRAG_DONE            0x00000002
#define IPSEC_FLAG_LOOPBACK             0x00000004
#define IPSEC_FLAG_SSRR                 0x00000008
#define IPSEC_FLAG_FORWARD              0x00000010
#define IPSEC_FLAG_INCOMING             0x00000020
#define IPSEC_FLAG_FASTRCV              0x00000040
#define IPSEC_FLAG_TRANSFORMED          0x00000080
#define IPSEC_FLAG_TCP_CHECKSUM_VALID   0x00000100
#define IPSEC_FLAG_UDP_CHECKSUM_VALID   0x00000200

//
// Definiton for a packet handler routine callout.
//
typedef IPSEC_ACTION
(*IPSecHandlerRtn) (
    PUCHAR          pIPHeader,
    PVOID           pData,
    PVOID           DestIF,
    PNDIS_PACKET    Packet,
    PULONG          pExtraBytes,
    PULONG          pMTU,
    PVOID           *ppNewData,
    PULONG          pIpsecFlags,
    UCHAR           DestType
    );

typedef BOOLEAN
(*IPSecQStatusRtn) (
    IN  CLASSIFICATION_HANDLE   GpcHandle
    );

typedef VOID
(*IPSecSendCompleteRtn) (
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,
    OUT PVOID           *ppNewData
    );

typedef NTSTATUS
(*IPSecNdisStatusRtn) (
    IN  PVOID           IPContext,
    IN  UINT            Status
    );

typedef IPSEC_ACTION
(*IPSecRcvFWPacketRtn) (
    PCHAR           pIPHeader,
    PVOID           pData,
    UINT            DataLength,
    UCHAR           DestType
    );

#define IP_IPSEC_BIND_VERSION   1

typedef struct _IPSEC_FUNCTIONS {
    ULONG                   Version;
    IPSecHandlerRtn         IPSecHandler;
    IPSecQStatusRtn         IPSecQStatus;
    IPSecSendCompleteRtn    IPSecSendCmplt;
    IPSecNdisStatusRtn      IPSecNdisStatus;
    IPSecRcvFWPacketRtn     IPSecRcvFWPacket;
} IPSEC_FUNCTIONS, *PIPSEC_FUNCTIONS;

extern
IP_STATUS
SetIPSecPtr(PIPSEC_FUNCTIONS    IpsecFns);

extern
IP_STATUS
UnSetIPSecPtr(PIPSEC_FUNCTIONS    IpsecFns);

extern
IP_STATUS
UnSetIPSecSendPtr(PIPSEC_FUNCTIONS    IpsecFns);

extern
IP_STATUS
IPTransmit(void *Context, void *SendContext,
            PNDIS_BUFFER Buffer, uint DataSize,
            IPAddr Dest, IPAddr Source,
            IPOptInfo *OptInfo, RouteCacheEntry *RCE,
            uchar Protocol, IRP *Irp);

extern
NDIS_STATUS
IPProxyNdisRequest(
    IN  PVOID               DestIF,
    IN  NDIS_REQUEST_TYPE   RT,
    IN  NDIS_OID            Oid,
    IN  VOID                *Buffer,
    IN  UINT                Length,
    IN  UINT                *Needed
    );

extern
NTSTATUS
IPGetBestInterface(
   IN   IPAddr  Address,
   OUT  PVOID   *ppIF
   );

extern
NTSTATUS
IPEnableSniffer(
    IN  PUNICODE_STRING AdapterName,
    IN  PVOID           Context
    );

extern
NTSTATUS
IPDisableSniffer(
    IN  PUNICODE_STRING AdapterName
    );

extern
NTSTATUS
IPSetIPSecStatus(
    IN  BOOLEAN fActivePolicy
    );

extern
IP_STATUS
SendICMPErr(
    IN IPAddr Src,
    IN IPHeader UNALIGNED * Header,
    IN uchar Type,
    IN uchar Code,
    IN ulong Pointer,
    IN uchar Length
    );

extern
LONG
GetIFAndLink(
    IN  PVOID   RCE,
    OUT PULONG  IFIndex,
    OUT IPAddr  *NextHop
    );

// Structure passed to the IPSetFilterHook call

typedef struct _IP_SET_FILTER_HOOK_INFO {
    IPPacketFilterPtr       FilterPtr;      // Packet filter callout.
} IP_SET_FILTER_HOOK_INFO, *PIP_SET_FILTER_HOOK_INFO;

// Structure passed to the IPSetFirewallHook call

typedef struct _IP_SET_FIREWALL_HOOK_INFO {
    IPPacketFirewallPtr FirewallPtr;    // Packet filter callout.
    UINT                Priority;       // Priority of the hook
    BOOLEAN             Add;            // if TRUE then ADD else DELETE
} IP_SET_FIREWALL_HOOK_INFO, *PIP_SET_FIREWALL_HOOK_INFO;

// Structure passed to the IPSetMapRouteHook call.

typedef struct _IP_SET_MAP_ROUTE_HOOK_INFO {
    IPMapRouteToInterfacePtr    MapRoutePtr;    // Map route callout.
} IP_SET_MAP_ROUTE_HOOK_INFO, *PIP_SET_MAP_ROUTE_HOOK_INFO;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\iprtinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\inc\iprtinfo.h

Abstract:
    Header for IP Router Manager Information Structures

Revision History:

    Gurdeep Singh Pall          6/8/95  Created

--*/

#ifndef __IPRTINFO_H__
#define __IPRTINFO_H__

//
// This file uses structures from fltdefs.h rtinfo.h ipinfoid.h and
// iprtrmib.h
//

#ifndef ANY_SIZE

#define ANY_SIZE    1

#endif

#define TOCS_ALWAYS_IN_INTERFACE_INFO   4
#define TOCS_ALWAYS_IN_GLOBAL_INFO      2


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Filter information is passed in two blocks, one for IN and one for OUT   //
// Each is a RTR_INFO_BLOCK_HEADER with ONE TOC. The ID for the in filters  //
// is IP_IN_FILTER_INFO and for the out filters is IP_OUT_FILTER_INFO       //
// The structure describing the filters is a FILTER_DESCRIPTOR and within   //
// it is a FILTER_INFO structure, one for each FILTER. These structures are //
// in ipfltdrv.h                                                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  IP_ROUTE_INFO type, for backwards compatability, this structure is      //
//  currently the same length as MIB_IPFORWARDROW, but a few fields are     //
//  different.                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _INTERFACE_ROUTE_INFO
{
    DWORD       dwRtInfoDest;
    DWORD       dwRtInfoMask;
    DWORD       dwRtInfoPolicy;
    DWORD       dwRtInfoNextHop;
    DWORD       dwRtInfoIfIndex;
    DWORD       dwRtInfoType;
    DWORD       dwRtInfoProto;
    DWORD       dwRtInfoAge;
    DWORD       dwRtInfoNextHopAS;
    DWORD       dwRtInfoMetric1;
    DWORD       dwRtInfoMetric2;
    DWORD       dwRtInfoMetric3;
    DWORD       dwRtInfoPreference;
    DWORD       dwRtInfoViewSet;
}INTERFACE_ROUTE_INFO, *PINTERFACE_ROUTE_INFO;

typedef struct _INTERFACE_ROUTE_TABLE
{
    DWORD               dwNumEntries;
    INTERFACE_ROUTE_INFO    table[ANY_SIZE];
}INTERFACE_ROUTE_TABLE, *PINTERFACE_ROUTE_TABLE;

#define SIZEOF_INTERFACEROUTETABLE(X) (FIELD_OFFSET(INTERFACE_ROUTE_TABLE,table[0]) + ((X) * sizeof(INTERFACE_ROUTE_INFO)) + ALIGN_SIZE)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  IP_INTERFACE_STATUS_INFO                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _INTERFACE_STATUS_INFO
{
    IN  OUT DWORD   dwAdminStatus;
}INTERFACE_STATUS_INFO, *PINTERFACE_STATUS_INFO;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IP_GLOBAL_INFO type                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_DLL_NAME    48

#define IPRTR_LOGGING_NONE  ((DWORD) 0)
#define IPRTR_LOGGING_ERROR ((DWORD) 1)
#define IPRTR_LOGGING_WARN  ((DWORD) 2)
#define IPRTR_LOGGING_INFO  ((DWORD) 3)

typedef struct _GLOBAL_INFO
{
    IN OUT BOOL     bFilteringOn;
    IN OUT DWORD    dwLoggingLevel;
}GLOBAL_INFO, *PGLOBAL_INFO;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IP_PRIORITY_INFO type                                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IP_PRIORITY_MAX_METRIC      255
#define IP_PRIORITY_DEFAULT_METRIC  127

typedef struct _PROTOCOL_METRIC
{
    IN OUT DWORD   dwProtocolId;
    IN OUT DWORD   dwMetric;
}PROTOCOL_METRIC, *PPROTOCOL_METRIC;

typedef struct _PRIORITY_INFO
{
    IN OUT DWORD           dwNumProtocols;
    IN OUT PROTOCOL_METRIC ppmProtocolMetric[1];
}PRIORITY_INFO, *PPRIORITY_INFO;

#define SIZEOF_PRIORITY_INFO(X)     \
    (FIELD_OFFSET(PRIORITY_INFO, ppmProtocolMetric[0]) + ((X) * sizeof(PROTOCOL_METRIC)))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Constants and structures related to ICMP Router Discovery. See RFC 1256  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The Maximum Advertisement Interval is the max time (in seconds) between  //
// two advertisements.                                                      //
// Its minimum value is MIN_MAX_ADVT_INTERVAL                               //
// Its maximum value is MAX_MAX_ADVT_INTERVAL                               //
// Its default value is DEFAULT_MAX_ADVT_INTERVAL                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define DEFAULT_MAX_ADVT_INTERVAL                600
#define MIN_MAX_ADVT_INTERVAL                    4
#define MAX_MAX_ADVT_INTERVAL                    1800

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The Minimum Advertisement Interval is the min time (in seconds) between  //
// two unsolicited advertisements                                           //
// It must be greater than MIN_MIN_ADVT_INTERVAL                            //
// Obviously must be less than the Maximum Advertisement Interval           //
// Its default value for a given Maximum Advertisement Interval is:         //
//       DEFAULT_MIN_ADVT_INTERVAL_RATIO * Maximum Advertisement Interval   //
//                                                                          //
// When using the ratio, BE CAREFUL ABOUT FLOATING POINT VALUES             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MIN_MIN_ADVT_INTERVAL                    3
#define DEFAULT_MIN_ADVT_INTERVAL_RATIO          0.75

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The Advertisement Lifetime is the value (of time in seconds) placed in   //
// the advertisement's lifetime field.                                      //
// It must be greater than the Maximum Advertisement Interval               //
// Its maximum value is MAX_ADVT_LIFETIME                                   //
// Its default value for a given Maximum Advertisement Interval is:         //
//      DEFAULT_ADVT_LIFETIME_RATIO * Maximum Advertisement Interval        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define DEFAULT_ADVT_LIFETIME_RATIO              3
#define MAX_ADVT_LIFETIME                        9000

#define DEFAULT_PREF_LEVEL                       0

#define MAX_INITIAL_ADVTS                        3
#define MAX_INITIAL_ADVT_TIME                    16
#define MIN_RESPONSE_DELAY                       1
#define RESPONSE_DELAY_INTERVAL                  1

typedef struct _RTR_DISC_INFO
{
    IN OUT WORD             wMaxAdvtInterval;
    IN OUT WORD             wMinAdvtInterval;
    IN OUT WORD             wAdvtLifetime;
    IN OUT BOOL             bAdvertise;
    IN OUT LONG             lPrefLevel;
}RTR_DISC_INFO, *PRTR_DISC_INFO;


#define IP_FILTER_DRIVER_VERSION_1    1
#define IP_FILTER_DRIVER_VERSION_2    1
#define IP_FILTER_DRIVER_VERSION    IP_FILTER_DRIVER_VERSION_2

typedef struct _FILTER_INFO
{
    DWORD   dwSrcAddr;
    DWORD   dwSrcMask;
    DWORD   dwDstAddr;
    DWORD   dwDstMask;
    DWORD   dwProtocol;
    DWORD   fLateBound;
    WORD    wSrcPort;
    WORD    wDstPort;
}FILTER_INFO, *PFILTER_INFO;

typedef struct _FILTER_DESCRIPTOR
{
    DWORD             dwVersion;
    DWORD             dwNumFilters;
    PFFORWARD_ACTION  faDefaultAction;
    FILTER_INFO       fiFilter[1];
}FILTER_DESCRIPTOR, *PFILTER_DESCRIPTOR;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// For WAN interfaces, the address is unknown at the time the filters are   //
// set. Use these two constants two specify "Local Address". The address    //
// and mask are set with IOCTL_INTERFACE_BOUND                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The constants that should be used to set up the FILTER_INFO_STRUCTURE    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)

#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

#define SRC_ADDR_USE_LOCAL_FLAG     0x00000001
#define SRC_ADDR_USE_REMOTE_FLAG    0x00000002
#define DST_ADDR_USE_LOCAL_FLAG     0x00000004
#define DST_ADDR_USE_REMOTE_FLAG    0x00000008
#define SRC_MASK_LATE_FLAG          0x00000010
#define DST_MASK_LATE_FLAG          0x00000020

#define TCP_ESTABLISHED_FLAG        0x00000040

#define SetSrcAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_LOCAL_FLAG)

#define SetSrcAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_REMOTE_FLAG)

#define SetDstAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= DST_ADDR_USE_LOCAL_FLAG)

#define SetDstAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= DST_ADDR_USE_REMOTE_FLAG)

#define SetSrcMaskLateFlag(pFilter)         \
    ((pFilter)->fLateBound |= SRC_MASK_LATE_FLAG)

#define SetDstMaskLateFlag(pFilter)         \
    ((pFilter)->fLateBound |= DST_MASK_LATE_FLAG)

#define AreAllFieldsUnchanged(pFilter)      \
    ((pFilter)->fLateBound == 0x00000000)

#define DoesSrcAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & SRC_ADDR_USE_LOCAL_FLAG)

#define DoesSrcAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & SRC_ADDR_USE_REMOTE_FLAG)

#define DoesDstAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & DST_ADDR_USE_LOCAL_FLAG)

#define DoesDstAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & DST_ADDR_USE_REMOTE_FLAG)

#define IsSrcMaskLateBound(pFilter)         \
    ((pFilter)->fLateBound & SRC_MASK_LATE_FLAG)

#define IsDstMaskLateBound(pFilter)         \
    ((pFilter)->fLateBound & DST_MASK_LATE_FLAG)

#define IsTcpEstablished(pFilter)           \
    ((pFilter)->fLateBound & TCP_ESTABLISHED_FLAG)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Multicast Heartbeat information                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MAX_GROUP_LEN   64

typedef struct _MCAST_HBEAT_INFO
{
    //
    // The multicast address or group name which we wish to listen to in order
    // to receive heartbeat info
    // The code first tries to see if the stored string is a valid 
    // IP Address using inet_addr. If so, then that is used as the group .
    // Otherwise, gethostbyname is used to retrieve the group information
    //

    WCHAR       pwszGroup[MAX_GROUP_LEN];

    //
    // TRUE if heartbeat detection is on
    //

    BOOL        bActive;

    //
    // The dead interval in minutes
    //

    ULONG       ulDeadInterval;

    //
    // The protocol on which to listen for packets. Currently this can be
    // UDP or RAW. If the protocol is UDP, then the wPort field has the 
    // destination port number (which could be 0 => any port). 
    // If RAW, then it has the protocolId (which must be less than 255)
    //

    BYTE        byProtocol;

    WORD        wPort;

}MCAST_HBEAT_INFO, *PMCAST_HBEAT_INFO;

typedef struct _IPINIP_CONFIG_INFO
{
    DWORD   dwRemoteAddress;
    DWORD   dwLocalAddress;
    BYTE    byTtl;
}IPINIP_CONFIG_INFO, *PIPINIP_CONFIG_INFO;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Per Interfce filter settings                                             //
// (IP_IFFILTER_INFO)                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _IFFILTER_INFO
{
    BOOL    bEnableFragChk;

}IFFILTER_INFO, *PIFFILTER_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipsecshr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecshr.h

Abstract:

    Header file for IPSec Shared lib

Author:

    BrianSw  10-19-2000

Environment:

    User Level: Win32 / kernel

Revision History:


--*/


#ifndef _IPSECSHR_
#define _IPSECSHR_


#ifdef __cplusplus
extern "C" {
#endif

#include <validate.h>

#define IN_CLASSE(i)    (((long)(i) != 0xffffffff) && (((long)(i) & 0xF0000000) == 0xF0000000))

BOOL WINAPI IsAllZero(BYTE *c, DWORD dwSize);

BOOL WINAPI CmpBlob(IPSEC_BYTE_BLOB* c1, IPSEC_BYTE_BLOB *c2);
BOOL WINAPI CmpData(BYTE* c1, BYTE *c2, DWORD size);
BOOL WINAPI CmpAddr(ADDR *Template, ADDR *a2);
BOOL WINAPI CmpTypeStruct(BYTE *Template, BYTE *comp,
                   DWORD dwTypeSize, DWORD dwStructSize);
BOOL WINAPI CmpFilter(IPSEC_QM_FILTER *Template, IPSEC_QM_FILTER* f2);
BOOL WINAPI CmpQMAlgo(PIPSEC_QM_ALGO Template, PIPSEC_QM_ALGO a2);
BOOL WINAPI CmpQMOffer(PIPSEC_QM_OFFER Template, PIPSEC_QM_OFFER o2);
BOOL WINAPI MatchQMSATemplate(IPSEC_QM_SA *Template,IPSEC_QM_SA *CurInfo);
BOOL WINAPI MatchMMSATemplate(IPSEC_MM_SA *MMTemplate, IPSEC_MM_SA *SaData);

typedef struct _INT_IPSEC_MM_AUTH_INFO {
    MM_AUTH_ENUM AuthMethod;
    DWORD dwAuthInfoSize;
    LPBYTE pAuthInfo;
    DWORD dwAuthFlags;
} INT_IPSEC_MM_AUTH_INFO, * PINT_IPSEC_MM_AUTH_INFO;

typedef struct _INT_MM_AUTH_METHODS {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD dwNumAuthInfos;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo;
} INT_MM_AUTH_METHODS, * PINT_MM_AUTH_METHODS;

DWORD
ValidateAddr(
    PADDR pAddr
    );


BOOL
IsMulticastAddress(
	PADDR pAddr
	);


BOOL
IsBroadcastAddress(
	PADDR pAddr
	);


BOOL
IsSubnetBroadcastAddress(
	PADDR pAddr
	);


BOOL
IsUnicastAddress(
	PADDR pAddr
	);


BOOL
IsSupportedAddress(
	PADDR pAddr
	);


BOOL
IsLoopbackAddress(
	PADDR pAddr
	);


BOOL
IsValidTunnelEndpointAddress(
	PADDR pAddr
	);


BOOL
IsSpecialServer(
	PADDR pAddr
	);


BOOL
IsValidSubnet(
	PADDR pAddr
	);


BOOL
IsValidSubnettedAddress(
	PADDR pAddr
	);


DWORD
ValidateQMFilterAddresses(
    PIPSEC_QM_FILTER pIpsecQMFilter
    );


DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    );


DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );


DWORD
ValidateMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    );


DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    );


DWORD
VerifyAddresses(
    PADDR pAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    );


BOOL
bIsValidIPMask(
    ULONG uMask
    );


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    );


BOOL
AddressesConflict(
    ADDR SrcAddr,
    ADDR DesAddr
    );

BOOL
HtoNAddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    );

DWORD
ValidateTransportFilter(
    PTRANSPORT_FILTER pTransportFilter
    );

DWORD
ValidateIPSecQMFilter(
    PIPSEC_QM_FILTER pQMFilter
    );

DWORD
VerifyProtocols(
    PROTOCOL Protocol
    );


DWORD
VerifyPortsForProtocol(
    PORT Port,
    PROTOCOL Protocol
    );


DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    );


DWORD
ValidateTxFilterTemplate(
    PTRANSPORT_FILTER pTxFilter
    );


DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTunnelFilter
    );


DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    );


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    );


BOOLEAN
IsSpecialServ(
    ADDR_TYPE AddrType
    );


ADDR_TYPE 
ExTypeToAddrType(
    UCHAR ExType
    );


DWORD
WINAPI
ConvertExtMMAuthToInt(
    PMM_AUTH_METHODS pMMAuthMethods,
    PINT_MM_AUTH_METHODS * pIntMMAuthMethods
    );


DWORD
WINAPI
FreeIntMMAuthMethods(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods
    );


DWORD
WINAPI
SPDFreeIntMMAuthMethods(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    BOOLEAN FreeTop
    );


DWORD
WINAPI
SPDFreeIntMMAuthMethodsArray(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    DWORD dwNumAuthMeths
    );


DWORD
WINAPI
ConvertIntMMAuthToExt(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    PMM_AUTH_METHODS * pMMAuthMethods
    );

    
DWORD
WINAPI
SPDConvertArrayIntMMAuthToExt(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    PMM_AUTH_METHODS *ppMMAuthMethods,
    DWORD dwNumAuthMeths
    );


DWORD
WINAPI
FreeExtMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
SPDFreeExtMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
SPDConvertIntMMAuthToExt(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    PMM_AUTH_METHODS * pMMAuthMethods
    );


#ifdef __IPSEC_VALIDATE

DWORD
ValidateInitiateIKENegotiation(
    STRING_HANDLE pServerName,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    IKENEGOTIATION_HANDLE * phIKENegotiation
    );


DWORD
ValidateQueryIKENegotiationStatus(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus
    );


DWORD
ValidateCloseIKENegotiationHandle(
    IKENEGOTIATION_HANDLE * phIKENegotiation
    );

DWORD
ValidateEnumMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    PMM_SA_CONTAINER *ppMMSAContainer,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    );

DWORD
ValidateDeleteMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags
    );


DWORD
ValidateQueryIKEStatistics(
    STRING_HANDLE pServerName, 
    IKE_STATISTICS *pIKEStatistics
    );


DWORD
ValidateRegisterIKENotifyClient(
    STRING_HANDLE pServerName,    
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    PQM_SA_CONTAINER pQMSATemplateContainer,
    IKENOTIFY_HANDLE *phNotifyHandle,
    DWORD dwFlags
    );


DWORD ValidateQueryNotifyData(
    IKENOTIFY_HANDLE uhNotifyHandle,
    PDWORD pdwNumEntries,
    PQM_SA_CONTAINER *ppQMSAContainer,
    DWORD dwFlags
    );


DWORD ValidateCloseNotifyHandle(
    IKENOTIFY_HANDLE *phHandle
    );

DWORD ValidateIPSecAddSA(
    STRING_HANDLE pServerName,
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD *puhLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    DWORD dwFlags);

DWORD ValidateSetConfigurationVariables(
    LPWSTR pServerName,
    IKE_CONFIG IKEConfig
    );

DWORD ValidateGetConfigurationVariables(
    LPWSTR pServerName,
    PIKE_CONFIG pIKEConfig
    );

#endif //__IPSEC_VALIDATE

#ifdef __cplusplus
}
#endif


#endif // _WINIPSEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipnat.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    ipnat.h

Abstract:

    Contains semi-public IOCTLS and data-structures related to
    the IP Network Address Translator.

    For kernel-mode load-balancing support, see the director-registration
    declarations below (IOCTL_IP_NAT_REGISTER_DIRECTOR).

    For kernel-mode data-stream editing support, see the editor-registration
    declarations below (IOCTL_IP_NAT_REGISTER_EDITOR).

Author:

    Abolade Gbadegesin (t-abolag) 11-July-1997

Revision History:

--*/

#ifndef _ROUTING_IP_NAT_H_
#define _ROUTING_IP_NAT_H_

#include <rtinfo.h>             // for RTR_INFO_BLOCK_HEADER
#include <ipinfoid.h>           // for IP_GENERAL_INFO_BASE

#ifdef __cplusplus
extern "C" {
#endif

//
// MISCELLANEOUS DECLARATIONS
//

#define IP_NAT_VERSION          1

#define IP_NAT_SERVICE_NAME     "IPNAT"

#define DD_IP_NAT_DEVICE_NAME   L"\\Device\\IPNAT"

//
// IP header protocol-field constants
//

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_IP6IN4     0x29
#define NAT_PROTOCOL_PPTP       0x2F
#define NAT_PROTOCOL_IPSEC_ESP  0x32
#define NAT_PROTOCOL_IPSEC_AH   0x33

typedef enum {
    NatInboundDirection = 0,
    NatOutboundDirection,
    NatMaximumDirection
} IP_NAT_DIRECTION, *PIP_NAT_DIRECTION;

typedef enum {
    NatForwardPath = 0,
    NatReversePath,
    NatMaximumPath
} IP_NAT_PATH, *PIP_NAT_PATH;

typedef enum {
    NatCreateFailureDeleteReason = 0,
    NatCleanupSessionDeleteReason,
    NatCleanupDirectorDeleteReason,
    NatDissociateDirectorDeleteReason,
    NatMaximumDeleteReason
} IP_NAT_DELETE_REASON, *PIP_NAT_DELETE_REASON;


//
// IOCTL DECLARATIONS
//

#define FSCTL_IP_NAT_BASE       FILE_DEVICE_NETWORK

#define _IP_NAT_CTL_CODE(function, method, access) \
    CTL_CODE(FSCTL_IP_NAT_BASE, function, method, access)

//
// NAT-supported IOCTL constant declarations
//

#define IOCTL_IP_NAT_SET_GLOBAL_INFO \
    _IP_NAT_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REQUEST_NOTIFICATION \
    _IP_NAT_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_INTERFACE \
    _IP_NAT_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_INTERFACE \
    _IP_NAT_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// Unused: Functions 4-5

#define IOCTL_IP_NAT_SET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_EDITOR \
    _IP_NAT_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_STATISTICS \
    _IP_NAT_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_MAPPING_TABLE \
    _IP_NAT_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_DIRECTOR \
    _IP_NAT_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_REDIRECT \
    _IP_NAT_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CANCEL_REDIRECT \
    _IP_NAT_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE \
    _IP_NAT_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_REDIRECT_STATISTICS \
    _IP_NAT_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET \
    _IP_NAT_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET \
    _IP_NAT_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING \
    _IP_NAT_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_EDITOR_TABLE \
    _IP_NAT_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_DIRECTOR_TABLE \
    _IP_NAT_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_REDIRECT_DESTINATION_MAPPING \
    _IP_NAT_CTL_CODE(21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY \
    _IP_NAT_CTL_CODE(22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_STATISTICS \
    _IP_NAT_CTL_CODE(23, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY_EX \
    _IP_NAT_CTL_CODE(24, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_REDIRECT_EX \
    _IP_NAT_CTL_CODE(25, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_TICKET \
    _IP_NAT_CTL_CODE(26, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_TICKET \
    _IP_NAT_CTL_CODE(27, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_LOOKUP_TICKET \
    _IP_NAT_CTL_CODE(28, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// IOCTL_IP_NAT_SET_GLOBAL_INFO
//
// Invoked to supply the NAT with its configuration.
//
// InputBuffer: IP_NAT_GLOBAL_INFO
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_GET_GLOBAL_INFO
//
// Invoked to retrieve the NAT's configuration.
//
// InputBuffer: none.
// OutputBuffer: IP_NAT_GLOBAL_INFO
//

//
// IOCTL_IP_NAT_CREATE_INTERFACE
//
// Invoked to add router-interfaces to the NAT.
//
// InputBuffer: IP_NAT_CREATE_INTERFACE
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_DELETE_INTERFACE
//
// Invoked to delete router-interfaces from the NAT.
//
// InputBuffer: the 32-bit index of the interface to be deleted.
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_SET_INTERFACE_INFO
//
// Invoked to set configuration information for an interface.
//
// InputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_GET_INTERFACE_INFO
//
// Invoked to retrieve the configuration information of an interface.
//
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
//

//
// IOCTL_IP_NAT_GET_INTERFACE_STATISTICS
//
// This IOCTL is invoked to retrieve per-interface statistics.
//
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_STATISTICS' with the interface's statistics
//

//
// IOCTL_IP_NAT_GET_MAPPING_TABLE
// IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE
//
// This IOCTL is invoked to enumerate the dynamic TCP and UDP mappings
// globally, and for each interface.
//
// InputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with input parameters set
// OutputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with output parameters
//      filled in.
//

//
// IOCTL_IP_NAT_REGISTER_EDITOR
//
// This IOCTL is invoked by a kernel-mode component which wishes to act
// as an editor for packets which match a particular session-description.
//
// InputBuffer: 'IP_NAT_REGISTER_EDITOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_EDITOR' with output parameters filled in
//

//
// IOCTL_IP_NAT_GET_EDITOR_TABLE
//
// This IOCTL is invoked to enumerate the editors which are currently
// registered.
//
// InputBuffer: 'IP_NAT_ENUMERATE_EDITORS' with input parameters set
// OutputBuffer: 'Ip_NAT_ENUMERATE_EDITORS' with output parameters filled in.
//

//
// IOCTL_IP_NAT_REGISTER_DIRECTOR
//
// This IOCTL is invoked by a kernel-mode component that wishes to be consulted
// about the direction of incoming TCP/UDP sessions.
//
// InputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with output parameters filled in
//

//
// IOCTL_IP_NAT_GET_DIRECTOR_TABLE
//
// This IOCTL is invoked to enumerate the directors which are currently
// registered.
//
// InputBuffer: 'IP_NAT_ENUMERATE_DIRECTORS' with input parameters set
// OutputBuffer: 'Ip_NAT_ENUMERATE_DIRECTORS' with output parameters filled in.
//

//
// IOCTL_IP_NAT_CREATE_REDIRECT
//
// Invoked to cancel or query a 'redirect' which instructs the NAT
// to modify a specific session.
//
// InputBuffer: 'IP_NAT_CREATE_REDIRECT'
// OutputBuffer: 'IP_NAT_REDIRECT_STATISTICS'
//

//
// IOCTL_IP_NAT_CREATE_REDIRECT_EX
//
// Invoked to cancel or query a 'redirect' which instructs the NAT
// to modify a specific session. Can include an optional adapter restriction.
//
// InputBuffer: 'IP_NAT_CREATE_REDIRECT_EX'
// OutputBuffer: 'IP_NAT_REDIRECT_STATISTICS'
//

//
// IOCTL_IP_NAT_CANCEL_REDIRECT
// IOCTL_IP_NAT_GET_REDIRECT_STATISTICS
// IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING
// IOCTL_IP_NAT_GET_REDIRECT_DESTINATION_MAPPING
//
// Invoked to cancel or query a 'redirect' which instructs the NAT
// to modify a specific session.
//
// InputBuffer: 'IP_NAT_LOOKUP_REDIRECT'
// OutputBuffer:
//  cancel: Unused
//  statistics: 'IP_NAT_REDIRECT_STATISTICS'
//  source mapping: 'IP_NAT_REDIRECT_SOURCE_MAPPING'
//  destination mapping: 'IP_NAT_REDIRECT_DESTINATION_MAPPING'
//

//
// IOCTL_IP_NAT_REQUEST_NOTIFICATION
//
// Invoked to request notification of a specific event from the NAT.
//
// InputBuffer: 'IP_NAT_NOTIFICATION' indicating the notification required
// OutputBuffer: depends on 'IP_NAT_NOTIFICATION'.
//

//
// IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET
//
// Invoked to create a dynamic ticket, which becomes active when specific
// outbound session is seen.
//
// InputBuffer: 'IP_NAT_CREATE_DYNAMIC_TICKET' describes the ticket
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET
//
// Invoked to delete a dynamic ticket.
//
// InputBuffer: 'IP_NAT_DELETE_DYNAMIC_TICKET' describes the ticket.
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY
// IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY_EX
// IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_STATISTICS
//
// Invoked to search for a mapping and retrieve information about it.
// InputBuffer: 'IP_NAT_LOOKUP_SESSION_MAPPING'
// OutputBuffer:
//  key: 'IP_NAT_SESSION_MAPPING_KEY'
//  key_ex: 'IP_NAT_SESSION_MAPPING_KEY_EX'
//  statistics: 'IP_NAT_SESSION_MAPPING_STATISTICS'
//

//
// IOCTL_IP_NAT_CREATE_TICKET
//
// Invoked to create a ticket on an interface.
//
// InputBuffer: 'IP_NAT_CREATE_TICKET' describes the ticket.
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_DELETE_TICKET
//
// Invoked to create a ticket on an interface.
//
// InputBuffer: 'IP_NAT_CREATE_TICKET' describes the ticket.
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_LOOKUP_TICKET
//
// Invoked to lookup a ticket on an interface.
//
// InputBuffer: 'IP_NAT_CREATE_TICKET' describes the ticket. The private
//               parameters are ignored.
// OutputBuffer: IP_NAT_PORT_MAPPING.
//



//
// Structure:   IP_NAT_GLOBAL_INFO
//
// Holds global configuration information for the NAT.
//

typedef struct _IP_NAT_GLOBAL_INFO {
    ULONG LoggingLevel; // see IPNATHLP.H (IPNATHLP_LOGGING_*).
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_GLOBAL_INFO, *PIP_NAT_GLOBAL_INFO;

#define IP_NAT_ALLOW_RAS_CLIENTS            0x00000001

//
// Type-codes for the IP_NAT_GLOBAL_INFO.Header.TocEntry[] array.
//
// The structures which correspond to each info-type are given below.
//

#define IP_NAT_TIMEOUT_TYPE             IP_GENERAL_INFO_BASE + 1
#define IP_NAT_PROTOCOLS_ALLOWED_TYPE   IP_GENERAL_INFO_BASE + 2

//
// Structure:   IP_NAT_TIMEOUT
//
// Used to amend the default timeouts for TCP and UDP session mappings.
//

typedef struct _IP_NAT_TIMEOUT {
    ULONG TCPTimeoutSeconds;
    ULONG UDPTimeoutSeconds;
} IP_NAT_TIMEOUT, *PIP_NAT_TIMEOUT;


//
// Structure:   IP_NAT_PROTOCOLS_ALLOWED
//
// Used to define which IP-layer protocols (other than TCP/UDP/ICMP/PPTP)
// may be translated by the NAT. Only one session for each such protocol
// is supported for each remote destination.
//

typedef struct _IP_NAT_PROTOCOLS_ALLOWED {
    ULONG Bitmap[256 / (sizeof(ULONG) * 8)];
} IP_NAT_PROTOCOLS_ALLOWED, *PIP_NAT_PROTOCOLS_ALLOWED;


//
// Structure:   IP_NAT_CREATE_INTERFACE
//
// 'Index' must correspond to a valid IP adapter-index.
// This implies that addition of a demand-dial interface can only occur
// when such an interface is connected.
//
// The field 'BindingInfo' should be the beginning of
// an IP_ADAPTER_BINDING_INFO structure (see routprot.h) which
// contains the interface's binding.
//

#pragma warning(disable:4200) // 0-element array

typedef struct _IP_NAT_CREATE_INTERFACE {
    IN ULONG Index;
    IN ULONG BindingInfo[0];
} IP_NAT_CREATE_INTERFACE, *PIP_NAT_CREATE_INTERFACE;

#pragma warning(default:4200)

//
// Structure:   IP_NAT_INTERFACE_INFO
//
// 'Index' identifies the interface to be configured.
//
// The configuration information uses the RTR_INFO_BLOCK_HEADER structure
// of rtinfo.h. See below for the type-codes for structures which may appear
// after IP_NAT_INTERFACE_INFO.Header within the RTR_TOC_ENTRY.InfoType field.
//

typedef struct _IP_NAT_INTERFACE_INFO {
    ULONG Index;
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_INTERFACE_INFO, *PIP_NAT_INTERFACE_INFO;

//
// Flags for IP_NAT_INTERFACE_INFO.Flags
//
// _BOUNDARY: set to mark interface as boundary-interface.
//
// _NAPT: set to enable address-sharing via port-translation.
//
// _FW: set to enable firewall mode on the interface. This works with all
//      other flags. An interface in firewall mode is much more strict on what
//      inbound packets it will allow to propogate up the stack; in general,
//      it will only allow packets that are part of a locally-initiated connection
//      flow (i.e., packets for which a mapping or ticket exists)
//

#define IP_NAT_INTERFACE_FLAGS_BOUNDARY     0x00000001
#define IP_NAT_INTERFACE_FLAGS_NAPT         0x00000002
#define IP_NAT_INTERFACE_FLAGS_DISABLE_PPTP 0x00000004
#define IP_NAT_INTERFACE_FLAGS_FW           0x00000010
#define IP_NAT_INTERFACE_FLAGS_ALL          0x0000001f

//
// Type-codes for the IP_NAT_INTERFACE_INFO.Header.TocEntry[] array.
//
// The structures which correspond to each info-type are given below.
//

#define IP_NAT_ADDRESS_RANGE_TYPE       IP_GENERAL_INFO_BASE + 2
#define IP_NAT_PORT_MAPPING_TYPE        IP_GENERAL_INFO_BASE + 3
#define IP_NAT_ADDRESS_MAPPING_TYPE     IP_GENERAL_INFO_BASE + 4
#define IP_NAT_ICMP_CONFIG_TYPE         IP_GENERAL_INFO_BASE + 5

//
// Structure:   IP_NAT_ADDRESS_RANGE
//
// Holds a range of addresses which are part of the address-pool
// for a boundary interface.
//
// An address-pool consists of a list of these structures.
//
// N.B. Overlapping address-ranges are not supported;
//  discontiguous subnet masks are also unsupported.
//

typedef struct _IP_NAT_ADDRESS_RANGE {
    ULONG StartAddress;
    ULONG EndAddress;
    ULONG SubnetMask;
} IP_NAT_ADDRESS_RANGE, *PIP_NAT_ADDRESS_RANGE;

//
// Structure:   IP_NAT_PORT_MAPPING
//
// Holds a static mapping which ties a public-side port on this NAT interface
// to a particular private machine's address/port.
//
// In the case of an interface with a pool of addresses, 'PublicAddress'
// should specify which of those addresses this static-mapping applies to.
//

typedef struct _IP_NAT_PORT_MAPPING {
    UCHAR Protocol;
    USHORT PublicPort;
    ULONG PublicAddress;  // OPTIONAL - see IP_NAT_ADDRESS_UNSPECIFIED
    USHORT PrivatePort;
    ULONG PrivateAddress;
} IP_NAT_PORT_MAPPING, *PIP_NAT_PORT_MAPPING;

//
// Constant for 'PublicAddress' in IP_NAT_PORT_RANGE and IP_NAT_PORT_MAPPING;
// may be specified for boundary-interfaces which have no address-pool, in
// which case the range/mapping is for the boundary-interface's sole address.
//

#define IP_NAT_ADDRESS_UNSPECIFIED  ((ULONG)0)

//
// Structure:   IP_NAT_ADDRESS_MAPPING
//
// Holds a static mapping which ties an address from this NAT interface's
// address pool to a particular private-machine's address.
//
// Note that this address must fall within one of the ranges comprising
// the pool as specified by the IP_NAT_ADDRESS_RANGE structures.
//

typedef struct _IP_NAT_ADDRESS_MAPPING {
    ULONG PrivateAddress;
    ULONG PublicAddress;
    BOOLEAN AllowInboundSessions;
} IP_NAT_ADDRESS_MAPPING, *PIP_NAT_ADDRESS_MAPPING;

//
// There is no structure for IP_NAT_ICMP_CONFIG -- it's just a ULONG,
// with the following flags defining the behavior. These flags are
// only for exceptions to our default (very strict) security policy.
//
// IB == inbound, OB == outbound. Redirect is for either direction.
//
// The numerical values for the flags are derived from the ICMP
// message type code -- 1 << MessageType.
//
//

#define IP_NAT_ICMP_ALLOW_OB_DEST_UNREACH   0x00000008
#define IP_NAT_ICMP_ALLOW_OB_SOURCE_QUENCH  0x00000010
#define IP_NAT_ICMP_ALLOW_REDIRECT          0x00000020
#define IP_NAT_ICMP_ALLOW_IB_ECHO           0x00000100
#define IP_NAT_ICMP_ALLOW_IB_ROUTER         0x00000200
#define IP_NAT_ICMP_ALLOW_OB_TIME_EXCEEDED  0x00000800
#define IP_NAT_ICMP_ALLOW_OB_PARAM_PROBLEM  0x00001000
#define IP_NAT_ICMP_ALLOW_IB_TIMESTAMP      0x00002000
#define IP_NAT_ICMP_ALLOW_IB_MASK           0x00020000

//
// Structure:   IP_NAT_INTERFACE_STATISTICS
//
// This structure holds statistics for an interface
//

typedef struct _IP_NAT_INTERFACE_STATISTICS {
    OUT ULONG TotalMappings;
    OUT ULONG InboundMappings;
    OUT ULONG64 BytesForward;
    OUT ULONG64 BytesReverse;
    OUT ULONG64 PacketsForward;
    OUT ULONG64 PacketsReverse;
    OUT ULONG64 RejectsForward;
    OUT ULONG64 RejectsReverse;
} IP_NAT_INTERFACE_STATISTICS, *PIP_NAT_INTERFACE_STATISTICS;

//
// Structure:   IP_NAT_SESSION_MAPPING
//
// This structure holds information for a single mapping
//

typedef struct _IP_NAT_SESSION_MAPPING {
    UCHAR Protocol;       // see NAT_PROTOCOL_* above
    ULONG PrivateAddress;
    USHORT PrivatePort;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG RemoteAddress;
    USHORT RemotePort;
    IP_NAT_DIRECTION Direction;
    ULONG IdleTime;       // in seconds
} IP_NAT_SESSION_MAPPING, *PIP_NAT_SESSION_MAPPING;

//
// Structure:   IP_NAT_SESSION_MAPPING_STATISTICS
//
// Holds statistics for a single session-mapping.
//

typedef struct _IP_NAT_SESSION_MAPPING_STATISTICS {
    ULONG64 BytesForward;
    ULONG64 BytesReverse;
    ULONG64 PacketsForward;
    ULONG64 PacketsReverse;
    ULONG64 RejectsForward;
    ULONG64 RejectsReverse;
} IP_NAT_SESSION_MAPPING_STATISTICS, *PIP_NAT_SESSION_MAPPING_STATISTICS;

//
// Structure:   IP_NAT_SESSION_MAPPING_KEY
//
// Holds key-information for a single session-mapping.
//

typedef struct _IP_NAT_SESSION_MAPPING_KEY {
    UCHAR Protocol;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
} IP_NAT_SESSION_MAPPING_KEY, *PIP_NAT_SESSION_MAPPING_KEY;

//
// Structure:   IP_NAT_SESSION_MAPPING_KEY_EX
//
// Holds key-information for a single session-mapping, including
// the AdapterIndex if this session was created by the redirector.
//

typedef struct _IP_NAT_SESSION_MAPPING_KEY_EX {
    UCHAR Protocol;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
    ULONG AdapterIndex;
} IP_NAT_SESSION_MAPPING_KEY_EX, *PIP_NAT_SESSION_MAPPING_KEY_EX;

//
// Structure:   IP_NAT_ENUMERATE_SESSION_MAPPINGS
//
// Used for enumerating session mappings.
// On the first call to this routine, 'EnumerateContext' should be zeroed out;
// it will be filled by the NAT with information to be passed back down
// as the enumeration continues. To indicate there are no items remaining,
// the NAT will set EnumerateContext[0] to 0.
//

typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {
    IN ULONG Index;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;

//
// Structure:   IP_NAT_LOOKUP_SESSION_MAPPING
//
// Used to search for and query a specified session mapping.
// On input, the address/port fields are initialized either to
// pre-translation values or post-translation values.
// The NAT attempts to find a session mapping with matching values,
// and retrieves the requested information for that session mapping, if found.
//

typedef struct _IP_NAT_LOOKUP_SESSION_MAPPING {
    UCHAR Protocol;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG SourceAddress;
    USHORT SourcePort;
} IP_NAT_LOOKUP_SESSION_MAPPING, *PIP_NAT_LOOKUP_SESSION_MAPPING;


//
// Editor function prototypes
//

//
// For synchronization reasons, 'CreateHandler' and 'DeleteHandler'
// CANNOT invoke any helper functions other than 'QueryInfoSession'.
//

typedef NTSTATUS
(*PNAT_EDITOR_CREATE_HANDLER)(
    IN PVOID EditorContext,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG PublicAddress,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress,
    IN USHORT RemotePort,
    OUT PVOID* EditorSessionContextp OPTIONAL
    );

typedef NTSTATUS
(*PNAT_EDITOR_DELETE_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext
    );

typedef NTSTATUS
(*PNAT_EDITOR_DATA_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

//
// Helper function prototypes
//

typedef NTSTATUS
(*PNAT_EDITOR_CREATE_TICKET)(
    IN PVOID InterfaceHandle,
    IN UCHAR Protocol,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress,
    OUT PUSHORT PublicPort
    );

typedef NTSTATUS
(*PNAT_EDITOR_DELETE_TICKET)(
    IN PVOID InterfaceHandle,
    IN ULONG PublicAddress,
    IN UCHAR Protocol,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL
    );

typedef NTSTATUS
(*PNAT_EDITOR_DEREGISTER)(
    IN PVOID EditorHandle
    );

typedef NTSTATUS
(*PNAT_EDITOR_DISSOCIATE_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

typedef NTSTATUS
(*PNAT_EDITOR_EDIT_SESSION)(
    IN PVOID DataHandle,
    IN PVOID RecvBuffer,
    IN ULONG OldDataOffset,
    IN ULONG OldDataLength,
    IN PUCHAR NewData,
    IN ULONG NewDataLength
    );

typedef VOID
(*PNAT_EDITOR_QUERY_INFO_SESSION)(
    IN PVOID SessionHandle,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

typedef VOID
(*PNAT_EDITOR_TIMEOUT_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

//
// Structure:   IP_NAT_REGISTER_EDITOR
//
// The editor uses this structure to register itself with the NAT,
// and to obtain entrypoints of helper-functions provided by the NAT.
//
// On input, 'EditorContext' should contain a value which the NAT will
// pass to the editor's provided functions to serve as identification.
//
// On output, 'EditorHandle' contains the handle which the editor should
// pass to the NAT's helper functions to identify itself.
//

typedef struct _IP_NAT_REGISTER_EDITOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN IP_NAT_DIRECTION Direction;
    IN PVOID EditorContext;
    IN PNAT_EDITOR_CREATE_HANDLER CreateHandler;            // OPTIONAL
    IN PNAT_EDITOR_DELETE_HANDLER DeleteHandler;            // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ForwardDataHandler;         // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ReverseDataHandler;         // OPTIONAL
    OUT PVOID EditorHandle;
    OUT PNAT_EDITOR_CREATE_TICKET CreateTicket;
    OUT PNAT_EDITOR_DELETE_TICKET DeleteTicket;
    OUT PNAT_EDITOR_DEREGISTER Deregister;
    OUT PNAT_EDITOR_DISSOCIATE_SESSION DissociateSession;
    OUT PNAT_EDITOR_EDIT_SESSION EditSession;
    OUT PNAT_EDITOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_EDITOR_TIMEOUT_SESSION TimeoutSession;
} IP_NAT_REGISTER_EDITOR, *PIP_NAT_REGISTER_EDITOR;

#define IP_NAT_EDITOR_FLAGS_RESIZE      0x00000001

//
// Structure:   IP_NAT_EDITOR
//
// This structure contains information describing a registered editor.
//

typedef struct _IP_NAT_EDITOR {
    IP_NAT_DIRECTION Direction;
    UCHAR Protocol;
    USHORT Port;
} IP_NAT_EDITOR, *PIP_NAT_EDITOR;

//
// Structure:   IP_NAT_ENUMERATE_EDITORS
//
// Used for enumerating editors.
// On the first call to this routine, 'EnumerateContext' should be zeroed out;
// it will be filled by the NAT with information to be passed back down
// as the enumeration continues. To indicate there are no items remaining,
// the NAT will set EnumerateContext[0] to 0.
//

typedef struct _IP_NAT_ENUMERATE_EDITORS {
    IN OUT ULONG EnumerateContext;
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_EDITOR EnumerateTable[1];
} IP_NAT_ENUMERATE_EDITORS, *PIP_NAT_ENUMERATE_EDITORS;


//
// Director function prototypes
//

typedef struct _IP_NAT_DIRECTOR_QUERY {
    IN PVOID DirectorContext;
    IN ULONG ReceiveIndex;
    IN ULONG SendIndex;
    IN UCHAR Protocol;
    IN ULONG DestinationAddress;
    IN USHORT DestinationPort;
    IN ULONG SourceAddress;
    IN USHORT SourcePort;
    IN OUT ULONG Flags;
    OUT ULONG NewDestinationAddress;
    OUT USHORT NewDestinationPort;
    OUT ULONG NewSourceAddress OPTIONAL;
    OUT USHORT NewSourcePort OPTIONAL;
    OUT PVOID DirectorSessionContext;
} IP_NAT_DIRECTOR_QUERY, *PIP_NAT_DIRECTOR_QUERY;

#define IP_NAT_DIRECTOR_QUERY_FLAG_LOOPBACK         0x00000001
#define IP_NAT_DIRECTOR_QUERY_FLAG_DROP             0x80000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_STATISTICS       0x40000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT       0x20000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_UNIDIRECTIONAL   0x10000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_DELETE_ON_DISSOCIATE 0x08000000

typedef NTSTATUS
(*PNAT_DIRECTOR_QUERY_SESSION)(
    PIP_NAT_DIRECTOR_QUERY DirectorQuery
    );

typedef VOID
(*PNAT_DIRECTOR_CREATE_SESSION)(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext
    );

typedef VOID
(*PNAT_DIRECTOR_DELETE_SESSION)(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext,
    IN IP_NAT_DELETE_REASON DeleteReason
    );

typedef VOID
(*PNAT_DIRECTOR_UNLOAD)(
    IN PVOID DirectorContext
    );

//
// Director-helper function prototypes
//

typedef NTSTATUS
(*PNAT_DIRECTOR_DEREGISTER)(
    IN PVOID DirectorHandle
    );

typedef NTSTATUS
(*PNAT_DIRECTOR_DISSOCIATE_SESSION)(
    IN PVOID DirectorHandle,
    IN PVOID SessionHandle
    );

typedef VOID
(*PNAT_DIRECTOR_QUERY_INFO_SESSION)(
    IN PVOID SessionHandle,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

//
// Structure:   IP_NAT_REGISTER_DIRECTOR
//
// The director uses this structure to register itself with the NAT.
//

typedef struct _IP_NAT_REGISTER_DIRECTOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN PVOID DirectorContext;
    IN PNAT_DIRECTOR_QUERY_SESSION QueryHandler;
    IN PNAT_DIRECTOR_CREATE_SESSION CreateHandler;
    IN PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;
    IN PNAT_DIRECTOR_UNLOAD UnloadHandler;
    OUT PVOID DirectorHandle;
    OUT PNAT_DIRECTOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_DIRECTOR_DEREGISTER Deregister;
    OUT PNAT_DIRECTOR_DISSOCIATE_SESSION DissociateSession;
} IP_NAT_REGISTER_DIRECTOR, *PIP_NAT_REGISTER_DIRECTOR;

//
// Structure:   IP_NAT_DIRECTOR
//
// This structure contains information describing a registered director.
//

typedef struct _IP_NAT_DIRECTOR {
    UCHAR Protocol;
    USHORT Port;
} IP_NAT_DIRECTOR, *PIP_NAT_DIRECTOR;

//
// Structure:   IP_NAT_ENUMERATE_DIRECTORS
//
// Used for enumerating directors.
// On the first call to this routine, 'EnumerateContext' should be zeroed out;
// it will be filled by the NAT with information to be passed back down
// as the enumeration continues. To indicate there are no items remaining,
// the NAT will set EnumerateContext[0] to 0.
//

typedef struct _IP_NAT_ENUMERATE_DIRECTORS {
    IN OUT ULONG EnumerateContext;
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_DIRECTOR EnumerateTable[1];
} IP_NAT_ENUMERATE_DIRECTORS, *PIP_NAT_ENUMERATE_DIRECTORS;

//
// Structure:   IP_NAT_REDIRECT
//
// Describes the manner in which a specific session is to be modified.
//

typedef struct _IP_NAT_REDIRECT {
    UCHAR Protocol;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
} IP_NAT_REDIRECT, *PIP_NAT_REDIRECT;

typedef struct _IP_NAT_CREATE_REDIRECT {
    IN ULONG Flags;
    IN HANDLE NotifyEvent OPTIONAL;
    IN ULONG RestrictSourceAddress OPTIONAL;
#ifdef __cplusplus
    IN IP_NAT_REDIRECT Redirect;
#else
    IN IP_NAT_REDIRECT;
#endif
} IP_NAT_CREATE_REDIRECT, *PIP_NAT_CREATE_REDIRECT;

typedef struct _IP_NAT_CREATE_REDIRECT_EX {
    IN ULONG Flags;
    IN HANDLE NotifyEvent OPTIONAL;
    IN ULONG RestrictSourceAddress OPTIONAL;
    ULONG RestrictAdapterIndex OPTIONAL;
#ifdef __cplusplus
    IN IP_NAT_REDIRECT Redirect;
#else
    IN IP_NAT_REDIRECT;
#endif
} IP_NAT_CREATE_REDIRECT_EX, *PIP_NAT_CREATE_REDIRECT_EX;

#define IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS       0x00000001
#define IP_NAT_REDIRECT_FLAG_STATISTICS         0x00000002
#define IP_NAT_REDIRECT_FLAG_NO_TIMEOUT         0x00000004
#define IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL     0x00000008
#define IP_NAT_REDIRECT_FLAG_RESTRICT_SOURCE    0x00000010
#define IP_NAT_REDIRECT_FLAG_IO_COMPLETION      0x00000020
#define IP_NAT_REDIRECT_FLAG_PORT_REDIRECT      0x00000040
#define IP_NAT_REDIRECT_FLAG_RECEIVE_ONLY       0x00000080
#define IP_NAT_REDIRECT_FLAG_LOOPBACK           0x00000100
#define IP_NAT_REDIRECT_FLAG_SEND_ONLY          0x00000200
#define IP_NAT_REDIRECT_FLAG_RESTRICT_ADAPTER   0x00000400
#define IP_NAT_REDIRECT_FLAG_SOURCE_REDIRECT    0x00000800

typedef struct _IP_NAT_LOOKUP_REDIRECT {
    IN ULONG Flags;
    IN PVOID RedirectApcContext;
#ifdef __cplusplus
    IN IP_NAT_REDIRECT Redirect;
#else
    IN IP_NAT_REDIRECT;
#endif
} IP_NAT_LOOKUP_REDIRECT, *PIP_NAT_LOOKUP_REDIRECT;

#define IP_NAT_LOOKUP_REDIRECT_FLAG_MATCH_APC_CONTEXT 0x00000001

typedef struct _IP_NAT_SESSION_MAPPING_STATISTICS
IP_NAT_REDIRECT_STATISTICS, *PIP_NAT_REDIRECT_STATISTICS;

typedef struct _IP_NAT_REDIRECT_SOURCE_MAPPING {
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
} IP_NAT_REDIRECT_SOURCE_MAPPING, *PIP_NAT_REDIRECT_SOURCE_MAPPING;

typedef struct _IP_NAT_REDIRECT_DESTINATION_MAPPING {
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
} IP_NAT_REDIRECT_DESTINATION_MAPPING, *PIP_NAT_REDIRECT_DESTINATION_MAPPING;


//
// Enumeration: IP_NAT_NOTIFICATION
//
// Lists the forms of notification supported by the NAT.
//

typedef enum {
    NatRoutingFailureNotification = 0,
    NatMaximumNotification
} IP_NAT_NOTIFICATION, *PIP_NAT_NOTIFICATION;

//
// Structure:   IP_NAT_REQUEST_NOTIFICATION
//
// Used to request notification from the NAT.
//

typedef struct _IP_NAT_REQUEST_NOTIFICATION {
    IP_NAT_NOTIFICATION Code;
} IP_NAT_REQUEST_NOTIFICATION, *PIP_NAT_REQUEST_NOTIFICATION;

//
// Structure:   IP_NAT_ROUTING_FAILURE_NOTIFICATION
//
// Supplies information on a packet which could not be routed.
//

typedef struct _IP_NAT_ROUTING_FAILURE_NOTIFICATION {
    ULONG DestinationAddress;
    ULONG SourceAddress;
} IP_NAT_ROUTING_FAILURE_NOTIFICATION, *PIP_NAT_ROUTING_FAILURE_NOTIFICATION;


//
// Structure:   IP_NAT_CREATE_DYNAMIC_TICKET
//
// Used to describe a dynamic ticket to be created.
//

#pragma warning(disable:4200) // 0-element array

typedef struct _IP_NAT_CREATE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
    ULONG ResponseCount;
    struct {
        UCHAR Protocol;
        USHORT StartPort;
        USHORT EndPort;
    } ResponseArray[0];
} IP_NAT_CREATE_DYNAMIC_TICKET, *PIP_NAT_CREATE_DYNAMIC_TICKET;

#pragma warning(default:4200)

//
// Structure:   IP_NAT_DELETE_DYNAMIC_TICKET
//
// Used to describe a dynamic ticket to be deleted.
//

typedef struct _IP_NAT_DELETE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
} IP_NAT_DELETE_DYNAMIC_TICKET, *PIP_NAT_DELETE_DYNAMIC_TICKET;

//
// Structure:   IP_NAT_CREATE_TICKET
//
// Used to describe a ticket to be created or deleted.
//

typedef struct _IP_NAT_CREATE_TICKET {
    IN ULONG InterfaceIndex;
    IN IP_NAT_PORT_MAPPING PortMapping;
} IP_NAT_CREATE_TICKET, *PIP_NAT_CREATE_TICKET;

#ifdef __cplusplus
}
#endif

#endif // _ROUTING_IP_NAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipxfwd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ipxfwd.h

Abstract:
    Router Manager Interface to IPX Forwarder Driver


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_
#define _IPXFWD_

#define FWD_INTERNAL_INTERFACE_INDEX	0

// Forwarder interface statistic structure
typedef struct _FWD_IF_STATS {
	ULONG	OperationalState;	// Real state of the interface
#define FWD_OPER_STATE_UP		0
#define FWD_OPER_STATE_DOWN		1
#define FWD_OPER_STATE_SLEEPING	2
	ULONG	MaxPacketSize;		// Maximum packet size allowed on the intf
	ULONG	InHdrErrors;		// Num. of packets received with header errors
	ULONG	InFiltered;			// Num. of received packets that were filtered out
	ULONG	InNoRoutes;			// Num, of received packets with unknonw dest.
	ULONG	InDiscards;			// Num. of received packets discarded for other reasons
	ULONG	InDelivers;			// Num. of received packets delivered to dest
	ULONG	OutFiltered;		// Num. of sent packets fitered out
	ULONG	OutDiscards;		// Num. of sent packets discarded for other reasons
	ULONG	OutDelivers;		// Num. of sent packets delivered to dest
	ULONG	NetbiosReceived;	// Num. of received Netbios packets 
	ULONG	NetbiosSent;		// Num. of sent Netbios packets
	} FWD_IF_STATS, *PFWD_IF_STATS;


typedef struct	_FWD_ADAPTER_BINDING_INFO {
    ULONG	AdapterIndex;
    ULONG	Network;
    UCHAR	LocalNode[6];
    UCHAR	RemoteNode[6];
    ULONG	MaxPacketSize;
    ULONG	LinkSpeed;
    } FWD_ADAPTER_BINDING_INFO, *PFWD_ADAPTER_BINDING_INFO;

typedef struct FWD_NB_NAME {
	UCHAR	Name[16];
} FWD_NB_NAME, *PFWD_NB_NAME;

typedef struct _FWD_PERFORMANCE {
	LONGLONG		TotalPacketProcessingTime;
	LONGLONG		TotalNbPacketProcessingTime;
	LONGLONG		MaxPacketProcessingTime;
	LONGLONG		MaxNbPacketProcessingTime;
	LONG			PacketCounter;
	LONG			NbPacketCounter;
} FWD_PERFORMANCE, *PFWD_PERFORMANCE;

typedef struct _FWD_DIAL_REQUEST {
    ULONG           IfIndex;
    UCHAR           Packet[30];
} FWD_DIAL_REQUEST, *PFWD_DIAL_REQUEST;

#define IPXFWD_NAME		L"\\Device\\NwLnkFwd"

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_IPXFWD		FILE_DEVICE_NETWORK



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define IPXFWD_IOCTL_INDEX	(ULONG)0x00000800

//
// Define our own private IOCTLs
//

// Adds interface to the forwarder table, FWD_IF_SET_PARAMS should be passed in
// the input buffer
#define IOCTL_FWD_CREATE_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+1,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Deletes interface from the forwarder table, Interface index should be passed in
// the input buffer
#define IOCTL_FWD_DELETE_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+2,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Sets interface parameters, FWD_IF_SET_PARAMS should be passed in
// the input buffer
#define IOCTL_FWD_SET_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+3,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Gets interface parameters, FWD_IF_GET_PARAMS will be returned in
// the input buffer
#define IOCTL_FWD_GET_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+4,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Binds interface to physical adapter, FWD_IF_BIND_PARAMS should be passed in
// the input buffer
#define IOCTL_FWD_BIND_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+5,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Unbinds interface from the adapter, Interface index should be passed in
// the input buffer
#define IOCTL_FWD_UNBIND_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+6,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Disables forwarder operations in the interface, Interface index should be
// passed in the input buffer
#define IOCTL_FWD_DISABLE_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+7,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Enables forwarder operations in the interface, Interface index should be
// passed in the input buffer
#define IOCTL_FWD_ENABLE_INTERFACE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+8,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Sets netbios names in to resolve netbios broadcasts to this interface,
// Interface index should be passed in the input buffer,
// FWD_NB_NAMES_PARAMS structure should be passed in the output buffer
#define IOCTL_FWD_SET_NB_NAMES	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+9,METHOD_IN_DIRECT,FILE_ANY_ACCESS)

// Resets netbios names on the interface (deletes all of them).
// Interface index should be passed in the input buffer,
#define IOCTL_FWD_RESET_NB_NAMES	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+9,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Sets netbios names in to resolve netbios broadcasts to this interface,
// Interface index should be passed in the input buffer,
// FWD_NB_NAMES_PARAMS structure will be returned in the output buffer
#define IOCTL_FWD_GET_NB_NAMES	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+10,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)

// Adds/deletes/updates routes in forwarder table, array of FWD_ROUTE_SET_PARAMS
// should be passed in the input buffer. Returns number of processed routes in the
// ioStatus.Information field
#define IOCTL_FWD_SET_ROUTES	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+11,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Returns forwarder dial requests, FWD_DIAL_REQUEST_PARAMS structure
// for interfaces for which connection should be established returned
// in the output buffer (number of bytest returned is placed in the
// Information field of IO_STATUS block)
#define IOCTL_FWD_GET_DIAL_REQUEST	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+12,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Informs forwarder that its connection request could not be satisfied,
// Interface index should be passed in the input buffer
#define IOCTL_FWD_DIAL_REQUEST_FAILED	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+13,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Initializes and start forwarder
// FWD_START_PARAMS structure should be passed in the input buffer
#define IOCTL_FWD_START	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+14,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_FWD_GET_PERF_COUNTERS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+15,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Instructs the forwarder to renumber it's nicids according to an opcode and 
// threshold passed in the input buffer.  No data is returned.
#define IOCTL_FWD_RENUMBER_NICS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+16,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Dumps as much of the ipx interface table into the given buffer as possible.
#define IOCTL_FWD_GET_IF_TABLE	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+17,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Updates the configuration of the forwarder for pnp
#define IOCTL_FWD_UPDATE_CONFIG \
    CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+18,METHOD_BUFFERED,FILE_ANY_ACCESS)
    
// Structure passed with IOCTL_FWD_CREATE_INTERFACE call
typedef struct _FWD_IF_CREATE_PARAMS {
	ULONG		Index;			// Interface index
	BOOLEAN		NetbiosAccept;	// Whether to accept nb packets
	UCHAR		NetbiosDeliver;	// NB deliver mode
// Forwarder netbios broadcast delivery options
#define FWD_NB_DONT_DELIVER			0
#define FWD_NB_DELIVER_STATIC		1
#define FWD_NB_DELIVER_IF_UP		2
#define FWD_NB_DELIVER_ALL			3
	UCHAR		InterfaceType;	// Interface type
// Forwarder interface types
#define FWD_IF_PERMANENT			0
#define FWD_IF_DEMAND_DIAL			1
#define FWD_IF_LOCAL_WORKSTATION	2
#define FWD_IF_REMOTE_WORKSTATION	3
} FWD_IF_CREATE_PARAMS, *PFWD_IF_CREATE_PARAMS;

// Structure passed with IOCTL_FWD_SET_INTERFACE call
typedef struct _FWD_IF_SET_PARAMS {
	ULONG		Index;			// Interface index
	BOOLEAN		NetbiosAccept;	// Whether to accept nb packets
	UCHAR		NetbiosDeliver;	// NB deliver mode
} FWD_IF_SET_PARAMS, *PFWD_IF_SET_PARAMS;

// Structure returned in IOCTL_FWD_GET_INTERFACE call
typedef struct _FWD_IF_GET_PARAMS {
	FWD_IF_STATS	Stats;			// Interface statistics
	BOOLEAN			NetbiosAccept;	// Whether to accept nb packets
	UCHAR			NetbiosDeliver;	// NB deliver mode
} FWD_IF_GET_PARAMS, *PFWD_IF_GET_PARAMS;

// Structure returned in IOCTL_FWD_BIND_INTERFACE call
typedef struct _FWD_IF_BIND_PARAMS {
	ULONG						Index;	// Interface index
	FWD_ADAPTER_BINDING_INFO	Info;	// Interface binding information
} FWD_IF_BIND_PARAMS, *PFWD_IF_BIND_PARAMS;

// Structure passed with IOCTL_FWD_SET_ROUTES call
typedef struct _FWD_ROUTE_SET_PARAMS {
	ULONG		Network;				// Route's destination network
	UCHAR		NextHopAddress[6];		// Node address of the next hop
										// router if network is not
										// connected directly
	USHORT		TickCount;
	USHORT		HopCount;
	ULONG		InterfaceIndex;			// Interface to use to route to
										// the dest network
	ULONG		Action;					// Action to take with the route:
#define	FWD_ADD_ROUTE			0		//	route should be added to the table
#define FWD_DELETE_ROUTE		1		//	route should be deleted from the table
#define FWD_UPDATE_ROUTE		2		//	route should be updated
} FWD_ROUTE_SET_PARAMS, *PFWD_ROUTE_SET_PARAMS;

typedef struct _FWD_START_PARAMS {
	ULONG		RouteHashTableSize;	// Size of route hash table
	BOOLEAN		ThisMachineOnly;	// allow access to this machine only
									// for dialin clients
#define FWD_SMALL_ROUTE_HASH_SIZE			31
#define FWD_MEDIUM_ROUTE_HASH_SIZE			257
#define FWD_LARGE_ROUTE_HASH_SIZE			1027
} FWD_START_PARAMS, *PFWD_START_PARAMS;

typedef struct _FWD_NB_NAMES_PARAMS {
	ULONG		TotalCount;
	FWD_NB_NAME	Names[1];
} FWD_NB_NAMES_PARAMS, *PFWD_NB_NAMES_PARAMS;

typedef struct _FWD_PERFORMANCE FWD_PERFORMANCE_PARAMS, *PFWD_PERFORMANCE_PARAMS;

// Structure and definitions passed with IOCTL_FWD_RENUMBER_NICS call
#define FWD_NIC_OPCODE_DECREMENT 1
#define FWD_NIC_OPCODE_INCREMENT 2
typedef struct _FWD_RENUMBER_NICS_DATA {
    ULONG ulOpCode;
    USHORT usThreshold;
} FWD_RENUMBER_NICS_DATA;

// Structures to use with IOCTL_FWD_GET_IF_TABLE
typedef struct _FWD_INTERFACE_TABLE_ROW {
    ULONG dwIndex;
    ULONG dwNetwork;
    UCHAR uNode[6];
    UCHAR uRemoteNode[6];
    USHORT usNicId;
    UCHAR ucType;
} FWD_INTERFACE_TABLE_ROW;

typedef struct _FWD_INTERFACE_TABLE {
    ULONG dwNumRows;
    FWD_INTERFACE_TABLE_ROW * pRows;
} FWD_INTERFACE_TABLE;     

// Structure to use with IOCTL_FWD_UPDATE_CONFIG
typedef struct _FWD_UPDATE_CONFIG_PARAMS {
    BOOLEAN bThisMachineOnly;
} FWD_UPDATE_CONFIG_PARAMS;    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipxfltdf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ipxtfflt.h

Abstract:
    Interface with ipx filter driver
	Filter structure definitions

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXTFFLT_
#define _IPXTFFLT_

// Filter driver exported device object name
#define IPXFLT_NAME		L"\\Device\\NwLnkFlt"
// Networks device (implies certain admin access privilegies)
#define FILE_DEVICE_IPXFLT		FILE_DEVICE_NETWORK

// All our IOCLTS are custom (private to this driver only)
#define IPXFWD_IOCTL_INDEX	(ULONG)0x00000800

// Starts the driver
// Parameters:
//		IN InputBuffer		- NULL
//		IN InputBufferSize	- 0
//		IN OutputBuffer		- NULL
//		IN OutputBufferSize	- 0
// Returns:
//	Status:
//		STATUS_SUCCESS	- driver was started ok
//		STATUS_INVALID_PARAMETER - invalid input parameter
//		STATUS_INSUFFICIENT_RESOURCES - not enough resources to allocate
//										all internal structures
#define IOCTL_FLT_START		\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+0,METHOD_IN_DIRECT,FILE_ANY_ACCESS)

// Sets input filters on interface
// Parameters:
//		IN InputBuffer		- FLT_IF_SET_PARAMS
//		IN InputBufferSize	- sizeof (FLT_IF_SET_PARAMS)
//		IN OutputBuffer		- array of TRAFFIC_FILTER_INFO blocks
//		IN OutputBufferSize	- size of the OutputBuffer
// Returns:
//	Status:
//		STATUS_SUCCESS	- filters were set ok
//		STATUS_INVALID_PARAMETER - invalid input parameter
//		STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
//							filter description block
#define IOCTL_FLT_IF_SET_IN_FILTERS		\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+1,METHOD_IN_DIRECT,FILE_ANY_ACCESS)

// Sets output filters on interface
// Parameters:
//		IN InputBuffer		- FLT_IF_SET_PARAMS
//		IN InputBufferSize	- sizeof (FLT_IF_SET_PARAMS)
//		IN OutputBuffer		- array of TRAFFIC_FILTER_INFO blocks
//		IN OutputBufferSize	- size of the OutputBuffer
// Returns:
//	Status:
//		STATUS_SUCCESS	- filters were set ok
//		STATUS_INVALID_PARAMETER - invalid input parameter
//		STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
//							filter description block
#define IOCTL_FLT_IF_SET_OUT_FILTERS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+2,METHOD_IN_DIRECT,FILE_ANY_ACCESS)


// Resets (deletes) all input filters on interface
// Parameters:
//		IN InputBuffer		- interface index
//		IN InputBufferSize	- sizeof (ULONG)
//		IN OutputBuffer		- NULL
//		IN OutputBufferSize	- 0
// Returns:
//	Status:
//		STATUS_SUCCESS	- filters were reset ok
//		STATUS_INVALID_PARAMETER - invalid input parameter
#define IOCTL_FLT_IF_RESET_IN_FILTERS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+3,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Resets (deletes) all output filters on interface
// Parameters:
//		IN InputBuffer		- interface index
//		IN InputBufferSize	- sizeof (ULONG)
//		IN OutputBuffer		- NULL
//		IN OutputBufferSize	- 0
// Returns:
//	Status:
//		STATUS_SUCCESS	- filters were reset ok
//		STATUS_INVALID_PARAMETER - invalid input parameter
#define IOCTL_FLT_IF_RESET_OUT_FILTERS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+4,METHOD_BUFFERED,FILE_ANY_ACCESS)

// Returns input filters on interface
// Parameters:
//		IN InputBuffer		- interface index
//		IN InputBufferSize	- sizeof (ULONG)
//		OUT OutputBuffer	- buffer to receive FLT_IF_GET_PARAMS followed
//								by the TRAFFIC_FILTER_INFO array
//		IN OutputBufferSize	- at least sizeof (FLT_IF_GET_PARAMS)
// Returns:
//	Status:
//		STATUS_SUCCESS	- all filters on interface were returned in
//							the output buffer
//		STATUS_BUFFER_OVERFLOW - out but buffer is too small to return
//						all the filters, only those that fit were
//						placed in the buffer
//		STATUS_INVALID_PARAMETER - invalid input parameter
//	Information:
//		Total number of bytes placed in the output buffer
#define IOCTL_FLT_IF_GET_IN_FILTERS		\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+5,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)

// Returns input filters on interface
// Parameters:
//		IN InputBuffer		- interface index
//		IN InputBufferSize	- sizeof (ULONG)
//		OUT OutputBuffer	- buffer to receive FLT_IF_GET_PARAMS followed
//								by the TRAFFIC_FILTER_INFO array
//		IN OutputBufferSize	- at least sizeof (FLT_IF_GET_PARAMS)
// Returns:
//	Status:
//		STATUS_SUCCESS	- all filters on interface were returned in
//							the output buffer
//		STATUS_BUFFER_OVERFLOW - out but buffer is too small to return
//						all the filters, only those that fit were
//						placed in the buffer
//		STATUS_INVALID_PARAMETER - invalid input parameter
//	Information:
//		Total number of bytes placed in the output buffer
#define IOCTL_FLT_IF_GET_OUT_FILTERS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+6,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)

// Returns logged packets
// Parameters:
//		IN InputBuffer		- NULL
//		IN InputBufferSize	- 0
//		OUT OutputBuffer	- buffer to receive logged packets
//		IN OutputBufferSize	- at least sizeof (FLT_PACKET_LOG)
// Returns:
//	Status:
//		STATUS_SUCCESS	- all filters on interface were returned in
//							the output buffer
//		STATUS_INVALID_PARAMETER - invalid input parameter
//	Information:
//		Total number of bytes placed in the output buffer
#define IOCTL_FLT_GET_LOGGED_PACKETS	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+7,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ipxfwtbl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\tables.h

Abstract:
    IPX Forwarder Driver Tables


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_TABLES_
#define _IPXFWD_TABLES_

// Ranges and defaults for registry configurable parameters
#define MIN_ROUTE_SEGMENT_SIZE			PAGE_SIZE
#define MAX_ROUTE_SEGMENT_SIZE			(PAGE_SIZE*8)
#define DEF_ROUTE_SEGMENT_SIZE			MIN_ROUTE_SEGMENT_SIZE

#define MIN_INTERFACE_HASH_SIZE			31
#define MAX_INTERFACE_HASH_SIZE			257
#define DEF_INTERFACE_HASH_SIZE			MAX_INTERFACE_HASH_SIZE

#define MIN_CLIENT_HASH_SIZE			31
#define MAX_CLIENT_HASH_SIZE			257
#define DEF_CLIENT_HASH_SIZE			MAX_CLIENT_HASH_SIZE

#define MIN_NB_ROUTE_HASH_SIZE			31
#define MAX_NB_ROUTE_HASH_SIZE			1023
#define DEF_NB_ROUTE_HASH_SIZE			257

#define MAX_SEND_PKTS_QUEUED			256	// No defined range

#define NUM_INTERFACES_PER_SEGMENT		16	// Not configurable currently
#define NUM_NB_ROUTES_PER_SEGMENT		16	// Not configurable currently
											

// Special number reserved for routes that point to
// client on global net
#define GLOBAL_INTERFACE_REFERENCE ((PINTERFACE_CB)-1)

// All types of WAN are emulated as ETHERNET by NDIS
#define WAN_PACKET_SIZE					1500


#define INVALID_NETWORK_NUMBER			0xFFFFFFFF
#define INVALID_NIC_ID					0xFFFF

					
// Interface control block
struct _INTERFACE_CB;
typedef struct _INTERFACE_CB * PINTERFACE_CB;
struct _FWD_ROUTE;
typedef struct _FWD_ROUTE * PFWD_ROUTE;
struct _NB_ROUTE;
typedef struct _NB_ROUTE *PNB_ROUTE;

typedef struct _FWD_ROUTE {
	ULONG						FR_Network;			// Dest network
	USHORT						FR_TickCount;		// Route params
	USHORT						FR_HopCount;		//
	UCHAR						FR_NextHopAddress[6]; // Next hop router
	PINTERFACE_CB				FR_InterfaceReference; // Associated if CB
													// or NULL if global
													// network for clients
	LONG						FR_ReferenceCount;	// Number of external
													// references for this
													// block (must keep the
													// it till all of them
													// are released
	PFWD_ROUTE					FR_Next;			// Next route in the
													// table
} FWD_ROUTE;

typedef struct _INTERFACE_CB {
	ULONG						ICB_Index;			// Unique ID
	ULONG						ICB_Network;		// Network we boud to
	union {
		ULONGLONG				ICB_ClientNode64[1];// For clients on
													// global net (faster
													// comparisons and
													// hashing using 64
													// bit support)
		UCHAR					ICB_RemoteNode[6];	// Peer node for demand
													// dial connections
	};
	UCHAR						ICB_LocalNode[6];	// Node we bound to
	USHORT						ICB_Flags;
#define FWD_IF_ENABLED				0x0001
#define SET_IF_ENABLED(ifCB)		ifCB->ICB_Flags |= FWD_IF_ENABLED;
#define SET_IF_DISABLED(ifCB)		ifCB->ICB_Flags &= ~FWD_IF_ENABLED;
#define IS_IF_ENABLED(ifCB)			(ifCB->ICB_Flags&FWD_IF_ENABLED)

#define FWD_IF_CONNECTING			0x0002
#define SET_IF_CONNECTING(ifCB)		ifCB->ICB_Flags |= FWD_IF_CONNECTING;
#define SET_IF_NOT_CONNECTING(ifCB) ifCB->ICB_Flags &= ~FWD_IF_CONNECTING;
#define IS_IF_CONNECTING(ifCB)		(ifCB->ICB_Flags&FWD_IF_CONNECTING)
	USHORT						ICB_NicId;			// Nic id we bound to
	UCHAR						ICB_InterfaceType;
	UCHAR						ICB_NetbiosDeliver;
	BOOLEAN						ICB_NetbiosAccept;

	PNB_ROUTE					ICB_NBRoutes;		// Array of associated
													// NB routes
	ULONG						ICB_NBRouteCount;	// Number of nb routes

	LONGLONG					ICB_DisconnectTime;	// Time when if was disconnected
	FWD_IF_STATS				ICB_Stats;			// Accumulated
	PFWD_ROUTE					ICB_CashedRoute;	// MRU dest route
	PINTERFACE_CB				ICB_CashedInterface;// MRU dest if
	NIC_HANDLE					ICB_AdapterContext;	// IPX stack supplied
	PVOID						ICB_FilterInContext;
	PVOID						ICB_FilterOutContext;
	LONG						ICB_PendingQuota;	// Remaining quota of
													// packets that can be
													// pending on
													// the interface
	LIST_ENTRY					ICB_ExternalQueue;	// Queue of external (received)
													// packets
	LIST_ENTRY					ICB_InternalQueue;	// Queue of internal (send)
													// requests
#if DBG
	LIST_ENTRY					ICB_InSendQueue;	// packets being
													// sent by ipx
#endif
	INT							ICB_PacketListId;	// ID of the packet list
													// (for the max frame size
													// on this interface)
	LIST_ENTRY					ICB_IndexHashLink;	// Link in interface idx hash
	LIST_ENTRY					ICB_ConnectionLink;	// Link in connection queue
    PNDIS_PACKET                ICB_ConnectionPacket; // Packet that caused connection
                                                    // request
    PUCHAR                      ICB_ConnectionData; // Pointer into packet to
                                                    // place where actual data
                                                    // (header) starts
	PINTERFACE_CB				ICB_NodeHashLink;	// Link in client node hash
	ULONG						ICB_ReferenceCount;	// Number of routes that
													// point to this CB
	KSPIN_LOCK					ICB_Lock;			// Protects state,
													// queues
} INTERFACE_CB;

#define InitICB(ifCB,IfIndex,IfType,NbAccept,NbDeliver) {	\
		(ifCB)->ICB_Index = IfIndex;						\
		(ifCB)->ICB_Network = INVALID_NETWORK_NUMBER;		\
		(ifCB)->ICB_Flags = 0;								\
		(ifCB)->ICB_NicId = INVALID_NIC_ID;					\
		(ifCB)->ICB_InterfaceType = IfType;					\
		(ifCB)->ICB_NetbiosAccept = NbAccept;				\
		(ifCB)->ICB_NetbiosDeliver = NbDeliver;				\
		memset (&(ifCB)->ICB_Stats, 0, sizeof (FWD_IF_STATS));\
		KeInitializeSpinLock (&(ifCB)->ICB_Lock);			\
		(ifCB)->ICB_CashedInterface = NULL;					\
		(ifCB)->ICB_CashedRoute = NULL;						\
		(ifCB)->ICB_ReferenceCount = 0;						\
		(ifCB)->ICB_FilterInContext = NULL;					\
		(ifCB)->ICB_FilterOutContext = NULL;				\
		(ifCB)->ICB_ClientNode64[0] = 0;					\
		(ifCB)->ICB_NBRoutes = NULL;						\
		(ifCB)->ICB_PacketListId = -1;						\
		InitializeListHead (&(ifCB)->ICB_InternalQueue);	\
		InitializeListHead (&(ifCB)->ICB_ExternalQueue);	\
		(ifCB)->ICB_PendingQuota = MaxSendPktsQueued;		\
		switch ((ifCB)->ICB_InterfaceType) {				\
		case FWD_IF_PERMANENT:								\
			(ifCB)->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;\
			break;											\
		case FWD_IF_DEMAND_DIAL:							\
		case FWD_IF_LOCAL_WORKSTATION:						\
		case FWD_IF_REMOTE_WORKSTATION:						\
			(ifCB)->ICB_Stats.OperationalState = FWD_OPER_STATE_SLEEPING;\
            KeQuerySystemTime ((PLARGE_INTEGER)&(ifCB)->ICB_DisconnectTime);\
            (ifCB)->ICB_DisconnectTime -= (LONGLONG)SpoofingTimeout*10000000;\
			break;											\
		}													\
}
	

// Routes for netbios names (staticly seeded to reduce
// internet broadcast traffic)
typedef struct _NB_ROUTE {
	union {
		ULONGLONG		NBR_Name128[2];
		UCHAR			NBR_Name[16];		// Netbios name of destination
	};
	PINTERFACE_CB	NBR_Destination;	// Interface to send to
	PNB_ROUTE		NBR_Next;		// Next route in the name list
} NB_ROUTE;


// List used to allocate packets destined to WAN interfaces
extern INT				WanPacketListId;
// Max number of outstanding sends
extern ULONG			MaxSendPktsQueued;

// Segment sizes
extern ULONG			RouteSegmentSize;
extern ULONG			InterfaceSegmentSize;
extern ULONG			NBNameSegementSize;

// Sizes of hash tables
extern ULONG			RouteHashSize;
extern ULONG			InterfaceHashSize;
extern ULONG			ClientHashSize;
extern ULONG			NBRouteHashSize;

// Number of global client network
extern ULONG			GlobalNetwork;
// Interface reserved for internal network
extern PINTERFACE_CB	InternalInterface;

/*++
*******************************************************************
    C r e a t e T a b l e s

Routine Description:
	Allocates and intializes all hash tables and related structures
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
*******************************************************************
--*/
NTSTATUS
CreateTables (
	void
	);
	
/*++
*******************************************************************
    D e l e t e T a b l e s

Routine Description:
	Releases resources allocated for all hash tables
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were freed ok
*******************************************************************
--*/
NTSTATUS
DeleteTables (
	void
	);
	
/*++
*******************************************************************
    F r e e I n t e r f a c e

Routine Description:
    Releases memory allocated for interface to interface memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeInterface (
	PINTERFACE_CB	ifCB
	);

/*++
*******************************************************************
    F r e e R o u t e

Routine Description:
    Releases memory allocated for route to route memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeRoute (
	PFWD_ROUTE	fwRoute
	);
/*++
*******************************************************************
    A c q u i r e I n t e r f a c e R e f e r e n c e

Routine Description:
	Increments refernce count of interface control block
	ICB can't be freed until all references to it are released.
	The caller of this routine should have already had a reference
	to the interface or must hold an InterfaceLock
Arguments:
	ifCB - interface control block to reference
Return Value:
	None
*******************************************************************
--*/
//VOID
//AcquireInterfaceReference (
//	PINTERFACE_CB	ifCB
//	);
#if DBG
#define AcquireInterfaceReference(ifCB)							\
	do {														\
		ASSERTMSG ("Referenced ifCB is dead ",					\
			InterlockedIncrement(&ifCB->ICB_ReferenceCount)>0);	\
	} while (0)
#else
#define AcquireInterfaceReference(ifCB) \
		InterlockedIncrement(&ifCB->ICB_ReferenceCount)
#endif
/*++
*******************************************************************
    R e l e a s e I n t e r f a c e R e f e r e n c e

Routine Description:
	Decrements refernce count of interface control block
Arguments:
	ifCB - interface control block to release
Return Value:
	None
*******************************************************************
--*/
//PINTERFACE_CB
//ReleaseInterfaceReference (
//	PINTERFACE_CB	ifCB
//	);
// if it drops below 0, it has alredy been removed from the table
#define ReleaseInterfaceReference(ifCB) (						\
	 (InterlockedDecrement (&ifCB->ICB_ReferenceCount)>=0) 		\
		? ifCB													\
		: (FreeInterface (ifCB), (ifCB = NULL))					\
)

/*++
*******************************************************************
    I n t e r f a c e C o n t e x t T o R e f e r e n c e

Routine Description:
	Verifies that context supplied by the IPX stack is a valid
	interface block and is still bound to the adapter with which
	it is associated in the IPX stack
Arguments:
	ifCB - interface control block to reference
	NicId - id of the adapter to which interface is bound
Return Value:
	None
*******************************************************************
--*/
//PINTERFACE_CB
//InterfaceContextToReference (
//	PVOID	Context
//	);
#define InterfaceContextToReference(Context,NicId) (						\
	(InterlockedIncrement(&((PINTERFACE_CB)Context)->ICB_ReferenceCount)>0)	\
		? ((NicId==((PINTERFACE_CB)Context)->ICB_NicId)						\
			? (PINTERFACE_CB)Context										\
			: (ReleaseInterfaceReference(((PINTERFACE_CB)Context)), NULL))	\
		: NULL																\
	)

/*++
*******************************************************************
    G e t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference interface based on its index
Arguments:
	InterfaceIndex - unique id of the interface
Return Value:
	Pointer to interface control block if there is one in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetInterfaceReference (
	ULONG			InterfaceIndex
	);


/*++
*******************************************************************
    G e t N e x t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference to the next interface in the table
	Reference to the provided interface is released
Arguments:
	ifCB - interface to start with or NULL to start from the
			beginning of the interface table
Return Value:
	Pointer to interface control block if thare are any more interfaces
	in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetNextInterfaceReference (
	PINTERFACE_CB	ifCB
	);
	
/*++
*******************************************************************
        A d d I n t e r f a c e

Routine Description:
	Adds interface control block to the table.
Arguments:
	InterfaceIndex - unique if of the interface
	Info - interface paramters
Return Value:
	STATUS_SUCCESS - interface added ok
	STATUS_UNSUCCESSFULL - interface is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				interface CB
*******************************************************************
--*/
NTSTATUS
AddInterface (
	ULONG		InterfaceIndex,
	UCHAR		InterfaceType,
	BOOLEAN		NetbiosAccept,
	UCHAR		NetbiosDeliver
	);

/*++
*******************************************************************
    A d d G l o b a l N e t C l i e n t

Routine Description:
	Adds interface control block to the table of
	clients on the global network (should be done when
	client connects)
Arguments:
	ifCB - interface control block to add to the table
Return Value:
	STATUS_SUCCESS - interface was added ok
	STATUS_UNSUCCESSFULL - another interface with the same
					node address is already in the table
*******************************************************************
--*/
NTSTATUS
AddGlobalNetClient (
	PINTERFACE_CB	ifCB
	);

/*++
*******************************************************************
    D e l e t e G l o b a l N e t C l i e n t

Routine Description:
	Removes interface control block from the table of
	clients on the global network (should be done when
	client disconnects)
Arguments:
	ifCB - interface control block to remove from the table
Return Value:
	STATUS_SUCCESS - interface was removed ok
*******************************************************************
--*/
NTSTATUS
DeleteGlobalNetClient (
	PINTERFACE_CB	ifCB
	);

/*++
*******************************************************************
    D e l e t e I n t e r f a c e

Routine Description:
	Deletes interface control block (the block is not actually 
	disposed of until all references to it are released).
Arguments:
	InterfaceIndex - unique if of the interface
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFULL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteInterface (
	ULONG		InterfaceIndex
	);

/*++
*******************************************************************
    A d d R o u t e

Routine Description:
	Adds route to the hash table and finds and stores the reference
	to the associated interface control block in the route.
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - route was added ok
	STATUS_UNSUCCESSFUL - route is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route block
*******************************************************************
--*/
NTSTATUS
AddRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	);

/*++
*******************************************************************
    D e l e t e R o u t e

Routine Description:
	Deletes route from the hash table and releases the reference
	to the interface control block associated with the route.
Arguments:
	Network - route's destination network
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteRoute (
	ULONG	Network
	);

/*++
*******************************************************************
    U p d a t e R o u t e

Routine Description:
	Updates route in the hash table
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFUL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
UpdateRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	);

/*++
*******************************************************************
    F i n d D e s t i n a t i o n

Routine Description:
	Finds destination interface for IPX address and
	returns reference to its control block.
Arguments:
	Network - destination network
	Node	- destination node (needed in case of global client)
	Route	- buffer to place route reference
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindDestination (
	IN ULONG			Network,
	IN PUCHAR			Node,
	OUT PFWD_ROUTE		*Route
	);
/*++
*******************************************************************
    A c q u i r e R o u t e R e f e r e n c e

Routine Description:
	Increments refernce count of the route block
	Route block can't be freed until all references to it are released.
	The caller of this routine should have already had a reference
	to the route or must hold an TableWriteLock
Arguments:
	fwRoute - route block to reference
Return Value:
	None
*******************************************************************
--*/
//VOID
//AcquireRouteReference (
//	PFW+ROUTE	fwRoute
//	);
#define AcquireRouteReference(fwRoute) \
			InterlockedIncrement(&fwRoute->FR_ReferenceCount)


	
/*++
*******************************************************************
    R e l e a s e R o u t e R e f e r e n c e

Routine Description:
	Decrements refernce count of route block
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
//VOID
//ReleaseRouteReference (
//	PFW_ROUTE	fwRoute
//	);
// if it drops below 0, it has alredy been removed from the table
#define ReleaseRouteReference(fwRoute) {						\
	if (InterlockedDecrement (&fwRoute->FR_ReferenceCount)<0) {	\
		FreeRoute (fwRoute);									\
		fwRoute = NULL;											\
	}															\
}


/*++
*******************************************************************
    A d d N B R o u t e s

Routine Description:
	Adds netbios names associated with interface to netbios
	route hash table
Arguments:
	ifCB	- interface with which names are associated
	Names	- array of names
	Count	- number of names in the array
	routeArray - buffer to place pointer to allocated array of routes
Return Value:
	STATUS_SUCCESS - names were added ok
	STATUS_UNSUCCESSFUL - one of the names is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route array
*******************************************************************
--*/
NTSTATUS
AddNBRoutes (
	PINTERFACE_CB	ifCB,
	FWD_NB_NAME		Names[],
	ULONG			Count,
	PNB_ROUTE		*routeArray
	);

/*++
*******************************************************************
    D e l e t e N B R o u t e s

Routine Description:
	Deletes nb routes in the array from the route table and frees
	the array
Arguments:
	nbRoutes - array of routes
	Count	- number of routes in the array
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteNBRoutes (
	PNB_ROUTE		nbRoutes,
	ULONG			Count
	);

/*++
*******************************************************************
    F i n d N B D e s t i n a t i o n

Routine Description:
	Finds destination interface for nb name and
	returns reference to its control block.
Arguments:
	Name	- name to look for
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindNBDestination (
	IN PUCHAR		Name
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\llip6if.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Link-layer IPv6 interface definitions.
//
// This file contains the definitions defining the interface between IPv6
// and a link layer, such as Ethernet or Token-Ring.
//
// Also see Packet6Context and IPv6Packet in ip6imp.h.
//
// NB: We implicitly assume that all link-layer addresses that a
// particular interface will communicate with are the same length,
// although different interfaces/links may be using addresses of
// different lengths.
//


#ifndef LLIP6IF_INCLUDED
#define LLIP6IF_INCLUDED

#define MAX_LINK_LAYER_ADDRESS_LENGTH   64

//
// Structure of information passed to IPAddInterface.
//
// lip_defmtu must be less than or equal to lip_maxmtu.
// lip_defmtu and lip_maxmtu do NOT include lip_hdrsize.
//
typedef struct LLIPv6BindInfo {
    void *lip_context;  // LL context handle.
    uint lip_maxmtu;    // Max MTU that the link can use.
    uint lip_defmtu;    // Default MTU for the link.
    uint lip_flags;     // Various indicators, defined in ntddip6.h.
    uint lip_type;      // What kind of link - defined in ntddip6.h.
    uint lip_hdrsize;   // Size of link-layer header.
    uint lip_addrlen;   // Length of address in bytes - see max above.
    uchar *lip_addr;    // Pointer to interface address.
    uint lip_dadxmit;   // Default value for DupAddrDetectTransmits.
    uint lip_pref;      // Interface preference for routing decisions.

    //
    // The following five link-layer functions should return quickly.
    // They may be called from DPC context or with spin-locks held.
    //

    //
    // Initializes the interface identifier portion of the Address
    // with the interface identifier of this interface.
    // The interface identifier may depend on state (like the ifindex)
    // that is determined during CreateInterface, so it can't
    // be passed as a parameter to CreateInterface.
    //
    void (*lip_token)(IN void *LlContext, OUT IPv6Addr *Address);

    //
    // Given a pointer to a Source/Target Link-Layer Address Option
    // (see RFC 2461), return a pointer to the link-layer address.
    // Returns NULL if the option is misformatted (eg, the length is bad).
    //
    // lip_rdllopt may be NULL if the interface does not support
    // Neighbor Discovery (IF_FLAG_NEIGHBOR_DISCOVERS).
    //
    const void *(*lip_rdllopt)(IN void *LlContext, IN const uchar *OptionData);

    //
    // Given a pointer to a Source/Target Link-Layer Address Option
    // (see RFC 2461), initializes the option data with the link-layer
    // address and zeroes any padding bytes in the option data.
    // Does not modify the option type/length bytes.
    //
    // lip_wrllopt may be NULL if the interface does not support
    // Neighbor Discovery (IF_FLAG_NEIGHBOR_DISCOVERS).
    //
    void (*lip_wrllopt)(IN void *LlContext, OUT uchar *OptionData,
                        IN const void *LinkAddress);

    //
    // Statically converts an IPv6 address into a link-layer address.
    // The return value is a Neighbor Discovery state value.
    // If static conversion is not possible (a common case),
    // returns ND_STATE_INCOMPLETE to indicate the use of Neighbor Discovery.
    // If static conversion is possible (for example with multicast
    // addresses or with a p2p interface), returns (typically)
    // ND_STATE_PERMANENT or ND_STATE_STALE.  ND_STATE_STALE indicates
    // that Neighbor Unreachability Detection should be performed.
    //
    ushort (*lip_cvaddr)(IN void *LlContext,
                         IN const IPv6Addr *Address,
                         OUT void *LinkAddress);

    //
    // Set the default router's link-layer address on an NBMA link,
    // as well as our own link-layer address to use in stateless
    // address configuration, since we may have multiple choices available.
    //
    NTSTATUS (*lip_setrtrlladdr)(IN void *LlContext, 
                                 IN const void *TokenLinkAddress,
                                 IN const void *RouterLinkAddress);

    //
    // Transmits the packet to the link-layer address.
    // The Offset argument indicates the location of the IPv6 header
    // in the packet. The IPv6 layer guarantees that Offset >= lip_hdrsize,
    // leaving room for the link-layer header.
    //
    // May be called from thread or DPC context, but should not be called
    // with spin-locks held. Calls are not serialized.
    //
    void (*lip_transmit)(IN void *LlContext, IN PNDIS_PACKET Packet,
                         IN uint Offset, IN const void *LinkAddress);

    //
    // Sets the multicast address list on the interface.
    // LinkAddresses is an array of link-layer addresses.
    // The first NumKeep addresses were part of the previous
    // multicast list and are to be kept. The next NumAdd
    // addresses are new additions to the multicast address list.
    // The remaining NumDel addresses should be removed
    // from the multicast address list.
    //
    // A NULL lip_mclist function is valid and indicates
    // that the interface does not support link-layer multicast.
    // For example, a point-to-point or NBMA interface.
    // If lip_mclist is non-NULL, then lip_cvaddr must be non-NULL
    // and it should return ND_STATE_PERMANENT for multicast addresses.
    //
    // Called only from thread context; may block or otherwise
    // take a long time. The IPv6 layer serializes its calls.
    // Also see RestartLinkLayerMulticast below.
    //
    NDIS_STATUS (*lip_mclist)(IN void *LlContext, IN const void *LinkAddresses,
                              IN uint NumKeep, IN uint NumAdd, IN uint NumDel);

    //
    // Initiate shut down of the link-layer connection.
    // The link layer should release its reference(s) for the IPv6 interface.
    // However, the IPv6 interface is not freed until after the call
    // to lip_cleanup and the link layer can make some use of it until then.
    //
    // Called only from thread context; may block or otherwise
    // take a long time. The IPv6 layer will only call once.
    //
    void (*lip_close)(IN void *LlContext);

    //
    // Final cleanup of the link-layer connection.
    // Called by the IPv6 layer when there are no more references.
    //
    // Called only from thread context; may block or otherwise
    // take a long time. The IPv6 layer will only call once,
    // after lip_close has returned.
    //
    // Up until the call to lip_cleanup, the IPv6 layer
    // may still make calls down to the link layer.
    // In lip_cleanup, the link layer should release any references
    // that it has for lower-layer data structures and
    // free its own context structure.
    //
    void (*lip_cleanup)(IN void *LlContext);
} LLIPv6BindInfo;

//
// These values should agree with definitions also
// found in ip6def.h and ntddip6.h.
//
#define IF_TYPE_LOOPBACK           0
#define IF_TYPE_ETHERNET           1
#define IF_TYPE_FDDI               2
#define IF_TYPE_TUNNEL_AUTO        3
#define IF_TYPE_TUNNEL_6OVER4      4
#define IF_TYPE_TUNNEL_V6V4        5
#define IF_TYPE_TUNNEL_6TO4        6
#define IF_TYPE_TUNNEL_TEREDO      7

//
// These values should agree with definitions also
// found in ip6def.h and ntddip6.h.
//
#define IF_FLAG_PSEUDO                  0x00000001
#define IF_FLAG_P2P                     0x00000002
#define IF_FLAG_NEIGHBOR_DISCOVERS      0x00000004
#define IF_FLAG_FORWARDS                0x00000008
#define IF_FLAG_ADVERTISES              0x00000010
#define IF_FLAG_MULTICAST               0x00000020
#define IF_FLAG_ROUTER_DISCOVERS        0x00000040
#define IF_FLAG_PERIODICMLD             0x00000080
#define IF_FLAG_MEDIA_DISCONNECTED      0x00001000

//
// Return values for lip_cvaddr.
// These definitions are also in ip6def.h.
//
#define ND_STATE_INCOMPLETE 0
#define ND_STATE_PROBE      1
#define ND_STATE_DELAY      2
#define ND_STATE_STALE      3
#define ND_STATE_REACHABLE  4
#define ND_STATE_PERMANENT  5

//
// The link-layer code calls these IPv6 functions.
// See the function definitions for explanatory comments.
//

extern NTSTATUS
CreateInterface(IN const GUID *Guid, IN const LLIPv6BindInfo *BindInfo,
                OUT void **IpContext);

extern void *
AdjustPacketBuffer(IN PNDIS_PACKET Packet,
                   IN uint SpaceAvail, IN uint SpaceNeeded);

extern void
UndoAdjustPacketBuffer(IN PNDIS_PACKET Packet);

extern void
IPv6ReceiveComplete(void);

//
// The packet itself holds a reference for the IPv6 interface,
// so the link layer does not need to hold another reference.
//
extern void
IPv6SendComplete(IN void *IpContext,
                 IN PNDIS_PACKET Packet, IN IP_STATUS Status);

//
// The following calls must be made before lip_cleanup
// returns. Normally they require a reference for the IPv6 interface,
// but between lip_close and lip_cleanup the link layer may call them
// without holding a reference for the IPv6 interface.
//
// NB: IPv6Receive does not take IpContext (the IPv6 interface)
// as an explicit argument. Instead it is passed as Packet->NTEorIF.
//
extern int
IPv6Receive(IN IPv6Packet *Packet);

extern void
SetInterfaceLinkStatus(IN void *IpContext, IN int MediaConnected);

extern void
DestroyInterface(IN void *IpContext);

//
// This function asks the IPv6 layer to call lip_mclist again,
// adding all the link-layer multicast addresses to the interface
// as if for the first time. In other words, with NumKeep zero.
// The ResetDone function is called under a lock that serializes
// the ResetDone call with lip_mclist calls on this interface.
// Hence the link layer can know at what point in the sequence
// of lip_mclist calls the reset took place.
//
extern void
RestartLinkLayerMulticast(IN void *IpContext,
                          IN void (*ResetDone)(IN void *LlContext));

//
// The link layer must hold a reference
// for the IPv6 interface to make the following calls.
//
extern void
ReleaseInterface(IN void *IpContext);

#endif // LLIP6IF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\isnipx.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    isnipx.h

Abstract:

    This module contains definitions specific to the
    IPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:


--*/

#ifndef _ISNIPX_
#define _ISNIPX_

#define MAC_HEADER_SIZE  ((IPX_MAXIMUM_MAC + 3) & ~3)
#define RIP_PACKET_SIZE     ((sizeof(RIP_PACKET) + 3) & ~3)
#define IPX_HEADER_SIZE  ((sizeof(IPX_HEADER) + 3) & ~3)

//
// Frame type definitions
//

#define ISN_FRAME_TYPE_ETHERNET_II  0
#define ISN_FRAME_TYPE_802_3        1
#define ISN_FRAME_TYPE_802_2        2
#define ISN_FRAME_TYPE_SNAP         3
#define ISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define ISN_FRAME_TYPE_MAX          4    // of the four standard ones

#define ISN_FRAME_TYPE_AUTO         0xff


//
// This defines the size of the maximum MAC header required
// (token-ring: MAC 14 bytes, RI 18 bytes, LLC 3 bytes, SNAP 5 bytes).
//

#define IPX_MAXIMUM_MAC 40

//
// This is an internal identifier used for RIP query packets.
//

#define IDENTIFIER_RIP_INTERNAL  4

//
// This is an internal identifier used for RIP response packets.
//

#define IDENTIFIER_RIP_RESPONSE  5


//
// This is the total number of "real" identifiers.
//

#define IDENTIFIER_TOTAL         4


//
// Some definitions (in the correct on-the-wire order).
//

#define RIP_PACKET_TYPE   0x01
#define RIP_SOCKET      0x5304
#define RIP_REQUEST     0x0100
#define RIP_RESPONSE    0x0200
#define RIP_DOWN        0x8200    // use high bit to indicate it

#define SAP_PACKET_TYPE   0x04
#define SAP_SOCKET      0x5204

#define SPX_PACKET_TYPE   0x05

#define NB_SOCKET       0x5504


#include <packon.h>

//
// Definition of the IPX header.
//

typedef struct _IPX_HEADER {
    USHORT CheckSum;
    UCHAR PacketLength[2];
    UCHAR TransportControl;
    UCHAR PacketType;
    UCHAR DestinationNetwork[4];
    UCHAR DestinationNode[6];
    USHORT DestinationSocket;
    UCHAR SourceNetwork[4];
    UCHAR SourceNode[6];
    USHORT SourceSocket;
} IPX_HEADER, *PIPX_HEADER;


//
// Definition of a RIP network entry.
//

typedef struct _RIP_NETWORK_ENTRY {
    ULONG NetworkNumber;
    USHORT HopCount;
    USHORT TickCount;
} RIP_NETWORK_ENTRY, *PRIP_NETWORK_ENTRY;

//
// Definition of a single entry rip packet.
//

typedef struct _RIP_PACKET {
    USHORT Operation;
    RIP_NETWORK_ENTRY NetworkEntry;
} RIP_PACKET, *PRIP_PACKET;

#include <packoff.h>


#define IPX_DEVICE_SIGNATURE        0x1401
#define IPX_ADAPTER_SIGNATURE       0x1402
#define IPX_BINDING_SIGNATURE       0x1403
#define IPX_ADDRESS_SIGNATURE       0x1404
#define IPX_ADDRESSFILE_SIGNATURE   0x1405
#define IPX_RT_SIGNATURE            0x1406

#define IPX_FILE_TYPE_CONTROL   (ULONG)0x4701   // file is type control


//
// Defined granularity of RIP timeouts in milliseconds
//

#define RIP_GRANULARITY  55


//
// The default number of segments in the RIP table.
//

#define RIP_SEGMENTS     7



//
// Convert a ushort netware order <-> machine order
//

#define REORDER_USHORT(_Ushort) ((((_Ushort) & 0xff00) >> 8) | (((_Ushort) & 0x00ff) << 8))

//
// Convert a ulong netware order <-> machine order
//

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))



#if DBG

extern ULONG IpxDebug;
extern ULONG IpxMemoryDebug;

#define IPX_MEMORY_LOG_SIZE 128
extern UCHAR IpxDebugMemory[IPX_MEMORY_LOG_SIZE][192];
extern PUCHAR IpxDebugMemoryLoc;
extern PUCHAR IpxDebugMemoryEnd;

VOID
IpxDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
);

#define IPX_DEBUG(_Flag, _Print) { \
    if (IpxDebug & (IPX_DEBUG_ ## _Flag)) { \
        DbgPrint ("IPX: "); \
        DbgPrint _Print; \
    } \
    if (IpxMemoryDebug & (IPX_DEBUG_ ## _Flag)) { \
        IpxDebugMemoryLog _Print; \
    } \
}

#else

#define IPX_DEBUG(_Flag, _Print)

#endif


//
// These definitions are for abstracting IRPs from the
// transport for portability.
//

#if ISN_NT

typedef IRP REQUEST, *PREQUEST;


//
// PREQUEST
// IpxAllocateRequest(
//     IN PDEVICE Device,
//     IN PIRP Irp
// );
//
// Allocates a request for the system-specific request structure.
//

#define IpxAllocateRequest(_Device,_Irp) \
    (_Irp)


//
// BOOLEAN
// IF_NOT_ALLOCATED(
//     IN PREQUEST Request
// );
//
// Checks if a request was not successfully allocated.
//

#define IF_NOT_ALLOCATED(_Request) \
    if (0)


//
// VOID
// IpxFreeRequest(
//     IN PDEVICE Device,
//     IN PREQUEST Request
// );
//
// Frees a previously allocated request.
//

#define IpxFreeRequest(_Device,_Request) \
    ;


//
// VOID
// MARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will pend.
//

#define MARK_REQUEST_PENDING(_Request) \
    IoMarkIrpPending(_Request)


//
// VOID
// UNMARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will not pend.
//

#define UNMARK_REQUEST_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)


//
// UCHAR
// REQUEST_MAJOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the major function code of a request.
//

#define REQUEST_MAJOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MajorFunction)


//
// UCHAR
// REQUEST_MINOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the minor function code of a request.
//

#define REQUEST_MINOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MinorFunction)


//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER
//     IN PREQUEST Request
// );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))


//
// PVOID
// REQUEST_OPEN_CONTEXT(
//     IN PREQUEST Request
// );
//
// Gets the context associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_CONTEXT(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext)


//
// PVOID
// REQUEST_OPEN_TYPE(
//     IN PREQUEST Request
// );
//
// Gets the type associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_TYPE(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext2)


//
// PFILE_FULL_EA_INFORMATION
// OPEN_REQUEST_EA_INFORMATION(
//     IN PREQUEST Request
// );
//
// Returns the EA information associated with an open/close request.
//

#define OPEN_REQUEST_EA_INFORMATION(_Request) \
    ((PFILE_FULL_EA_INFORMATION)((_Request)->AssociatedIrp.SystemBuffer))


#define OPEN_REQUEST_EA_LENGTH(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Parameters.DeviceIoControl.InputBufferLength))

#define OPEN_REQUEST_RCV_LEN(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Parameters.DeviceIoControl.OutputBufferLength))

#define REQUEST_SPECIAL_RECV(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Parameters.DeviceIoControl.IoControlCode) == MIPX_RCV_DATAGRAM)

#define REQUEST_SPECIAL_SEND(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Parameters.DeviceIoControl.IoControlCode) == MIPX_SEND_DATAGRAM)


#define REQUEST_CODE(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->Parameters.DeviceIoControl.IoControlCode)

//
// The following value does not clash with TDI_TRANSPORT_ADDRESS_FILE value of
// 0x1
//
#define ROUTER_ADDRESS_FILE 0x4

//
// PTDI_REQUEST_KERNEL
// REQUEST_PARAMETERS(
//     IN PREQUEST Request
// );
//
// Obtains a pointer to the parameters of a request.
//

#define REQUEST_PARAMETERS(_Request) \
    (&((IoGetCurrentIrpStackLocation(_Request))->Parameters))


//
// VOID
// REQUEST_OPEN_CONTEXT_AND_PARAMS(
//     IN PREQUEST Request
//     OUT PVOID * OpenContext,
//     OUT PTDI_REQUEST_KERNEL * Parameters
// );
//
// Simultaneously returns the open context and the parameters
// for a request (this is an optimization since the send
// datagram code needs them both).
//

#define REQUEST_OPEN_CONTEXT_AND_PARAMS(_Request,_OpenContext,_Parameters) { \
    PIO_STACK_LOCATION _IrpSp = IoGetCurrentIrpStackLocation(_Request); \
    *(_OpenContext) = _IrpSp->FileObject->FsContext; \
    *(_Parameters) = (PTDI_REQUEST_KERNEL)(&_IrpSp->Parameters); \
}


//
// PLIST_ENTRY
// REQUEST_LINKAGE(
//     IN PREQUEST Request
// );
//
// Returns a pointer to a linkage field in the request.
//

#define REQUEST_LINKAGE(_Request) \
    (&((_Request)->Tail.Overlay.ListEntry))


//
// PREQUEST
// LIST_ENTRY_TO_REQUEST(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_REQUEST(_ListEntry) \
    ((PREQUEST)(CONTAINING_RECORD(_ListEntry, REQUEST, Tail.Overlay.ListEntry)))


//
// NTSTATUS
// REQUEST_STATUS(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUS(_Request) \
    (_Request)->IoStatus.Status


//
// ULONG
// REQUEST_INFORMATION(
//     IN PREQUEST Request)
// );
//
// Used to access the information field of a request.
//

#define REQUEST_INFORMATION(_Request) \
    (_Request)->IoStatus.Information


//
// VOID
// IpxCompleteRequest(
//     IN PREQUEST Request
// );
//
// Completes a request whose status and information fields have
// been filled in.
//

#define IpxCompleteRequest(_Request) \
    IoCompleteRequest (_Request, IO_NETWORK_INCREMENT)

#else

//
// These routines must be defined for portability to a VxD.
//

#endif


#define IPX_INCREMENT(_Long, _Lock)  InterlockedIncrement(_Long)
#define IPX_DECREMENT(_Long, _Lock)  InterlockedDecrement(_Long)

#define IPX_ADD_ULONG(_Pulong, _Ulong, _Lock)  InterlockedExchangeAdd(_Pulong, _Ulong)

#define IPX_DEFINE_SYNC_CONTEXT(_SyncContext)
#define IPX_BEGIN_SYNC(_SyncContext)
#define IPX_END_SYNC(_SyncContext)

#define IPX_DEFINE_LOCK_HANDLE(_LockHandle) CTELockHandle _LockHandle;
#define IPX_DEFINE_LOCK_HANDLE_PARAM(_LockHandle) CTELockHandle _LockHandle;

#define IPX_GET_LOCK(_Lock, _LockHandle) \
	CTEGetLock(_Lock, _LockHandle)

#define IPX_FREE_LOCK(_Lock, _LockHandle) \
	CTEFreeLock(_Lock, _LockHandle)

#define IPX_GET_LOCK1(_Lock, _LockHandle)

#define IPX_FREE_LOCK1(_Lock, _LockHandle)

#define IPX_REMOVE_HEAD_LIST(_Queue, _Lock)   ExInterlockedRemoveHeadList(_Queue, _Lock)
#define IPX_LIST_WAS_EMPTY(_Queue, _OldHead)  ((_OldHead) == NULL)
#define IPX_INSERT_HEAD_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertHeadList(_Queue, _Entry, _Lock)
#define IPX_INSERT_TAIL_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertTailList(_Queue, _Entry, _Lock)

#define IPX_POP_ENTRY_LIST(_Queue, _Lock)           ExInterlockedPopEntrySList(_Queue, _Lock)
#define IPX_PUSH_ENTRY_LIST(_Queue, _Entry, _Lock)  ExInterlockedPushEntrySList(_Queue, _Entry, _Lock)

//
// This macro adds a ULONG to a LARGE_INTEGER.
//

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((_LargeInteger),(ULONG)(_Ulong))

#define IPX_DEBUG_DEVICE              0x00000001
#define IPX_DEBUG_ADAPTER             0x00000002
#define IPX_DEBUG_ADDRESS             0x00000004
#define IPX_DEBUG_SEND                0x00000008
#define IPX_DEBUG_NDIS                0x00000010
#define IPX_DEBUG_RECEIVE             0x00000020
#define IPX_DEBUG_CONFIG              0x00000040
#define IPX_DEBUG_PACKET              0x00000080
#define IPX_DEBUG_RIP                 0x00000100
#define IPX_DEBUG_BIND                0x00000200
#define IPX_DEBUG_ACTION              0x00000400
#define IPX_DEBUG_BAD_PACKET          0x00000800
#define IPX_DEBUG_SOURCE_ROUTE        0x00001000
#define IPX_DEBUG_WAN                 0x00002000
#define IPX_DEBUG_AUTO_DETECT         0x00004000

#define IPX_DEBUG_PNP				  0x00008000

#define IPX_DEBUG_LOOPB				  0x00010000

#define IPX_DEBUG_TEMP                0x00020000
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\laneinfo.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	laneinfo.h

Abstract:

	Data structures of state data for the ATM LAN Emulation Driver
	that can be queried by a user pgm.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	__ATMLANE_LANEINFO_H
#define __ATMLANE_LANEINFO_H

#define ATMLANE_INFO_VERSION	1

#define ATMLANE_IOCTL_GET_INFO_VERSION \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x100, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ATMLANE_IOCTL_ENUM_ADAPTERS \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x101, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ATMLANE_IOCTL_ENUM_ELANS \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x102, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ATMLANE_IOCTL_GET_ELAN_INFO \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x103, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ATMLANE_IOCTL_GET_ELAN_ARP_TABLE \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x104, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ATMLANE_IOCTL_GET_ELAN_CONNECT_TABLE \
	CTL_CODE(FILE_DEVICE_NETWORK, 0x105, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _adapterlist
{
	ULONG			AdapterCountAvailable;
	ULONG			AdapterCountReturned;
	UNICODE_STRING	AdapterList;
}
	ATMLANE_ADAPTER_LIST,
	*PATMLANE_ADAPTER_LIST;

typedef struct _elanlist
{
	ULONG			ElanCountAvailable;
	ULONG			ElanCountReturned;
	UNICODE_STRING	ElanList;
}
	ATMLANE_ELAN_LIST,
	*PATMLANE_ELAN_LIST;

typedef struct _elaninfo
{
	ULONG			ElanNumber;
	ULONG			ElanState;
	PUCHAR			AtmAddress[20];
	PUCHAR			LecsAddress[20];
	PUCHAR			LesAddress[20];
	PUCHAR			BusAddress[20];
	UCHAR			LanType;
	UCHAR			MaxFrameSizeCode;
	USHORT			LecId;
	UCHAR 			ElanName[32];
	PUCHAR			MacAddress[6];
	ULONG			ControlTimeout;
	ULONG			MaxUnkFrameCount;
	ULONG			MaxUnkFrameTime;
	ULONG			VccTimeout;
	ULONG			MaxRetryCount;
	ULONG			AgingTime;
	ULONG			ForwardDelayTime;
	ULONG			TopologyChange;
	ULONG			ArpResponseTime;
	ULONG			FlushTimeout;
	ULONG			PathSwitchingDelay;
	ULONG			LocalSegmentId;		
	ULONG			McastSendVcType;	
	ULONG			McastSendVcAvgRate; 
	ULONG			McastSendVcPeakRate;
	ULONG			ConnComplTimer;
}
	ATMLANE_ELANINFO,
	*PATMLANE_ELANINFO;

typedef struct _ArpEntry
{
	PUCHAR			MacAddress[6];
	PUCHAR			AtmAddress[20];
}
	ATMLANE_ARPENTRY,
	*PATMLANE_ARPENTRY;

typedef struct _ArpTable
{
	ULONG			ArpEntriesAvailable;
	ULONG			ArpEntriesReturned;
}
	ATMLANE_ARPTABLE,
	*PATMLANE_ARPTABLE;

typedef struct _ConnectEntry
{
	PUCHAR			AtmAddress[20];
	ULONG			Type;
	ULONG			Vc;
	ULONG			VcIncoming;
}
	ATMLANE_CONNECTENTRY,
	*PATMLANE_CONNECTENTRY;

typedef struct _ConnectTable
{
	ULONG			ConnectEntriesAvailable;
	ULONG			ConnectEntriesReturned;
}
	ATMLANE_CONNECTTABLE,
	*PATMLANE_CONNECTTABLE;

//
// PnP reconfig struct. This is used to pass indications of
// configuration changes from a user program to the ATMLANE
// protocol. This indication is passed on an Adapter binding,
// and carries the name of the ELAN affected by the configuration
// change.
//
typedef struct atmlane_pnp_reconfig_request
{
	ULONG				Version;		// ATMLANE_RECONFIG_VERSION
	ULONG				OpType;			// Defined below.
	ULONG				ElanKeyLength;	// Number of WCHARs following.
	WCHAR				ElanKey[1];		// ELAN Key name under the adapter

} ATMLANE_PNP_RECONFIG_REQUEST, *PATMLANE_PNP_RECONFIG_REQUEST;


//
// Reconfig version number.
//
#define ATMLANE_RECONFIG_VERSION		1

//
// Reconfig op types.
//
#define ATMLANE_RECONFIG_OP_ADD_ELAN	1
#define ATMLANE_RECONFIG_OP_DEL_ELAN	2
#define ATMLANE_RECONFIG_OP_MOD_ELAN	3

	

#endif // __ATMLANE_LANEINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\mprapip.h ===
/*
    File    mprapip.h

    Declarations for private mprapi.dll functions.

    6/24/98
*/

#ifndef __ROUTING_MPRADMINP_H__
#define __ROUTING_MPRADMINP_H__

#include <mprapi.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Definitions of flags to be used with
// MprAdminUserReadProfFlags/MprAdminUserWriteProfFlags
//
#define MPR_USER_PROF_FLAG_SECURE               0x1
#define MPR_USER_PROF_FLAG_UNDETERMINED         0x2

//
// Only valid for MprAdminUserWriteProfFlags
//
#define MPR_USER_PROF_FLAG_FORCE_STRONG_ENCRYPTION 0x4
#define MPR_USER_PROF_FLAG_FORCE_ENCRYPTION        0x8

// 
// Definition for new information to be reported
// through user parms
//
#define RASPRIV_DialinPolicy                    0x10

// 
// Defines the type of access a domain can give
//
// See MprDomainSetAccess, MprDomainQueryAccess
//
#define MPRFLAG_DOMAIN_NT4_SERVERS              0x1
#define MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS       0x2

#define MPRFLAG_PORT_Dialin           0x1  // set ports to dialin usage
#define MPRFLAG_PORT_Router           0x2  // set ports to router usage
#define MPRFLAG_PORT_NonVpnDialin     0x4  // set non-vpn ports to dialin

//
// Flags that govern the behavior of MprPortSetUsage
//
#define MPRFLAG_PORT_Dialin     0x1
#define MPRFLAG_PORT_Router     0x2

//
// Connects to a user server
//
DWORD WINAPI
MprAdminUserServerConnect (
    IN  PWCHAR pszMachine,
    IN  BOOL bLocal,
    OUT PHANDLE phUserServer);

//
// Disconnects from a user server
//
DWORD WINAPI
MprAdminUserServerDisconnect (
    IN HANDLE hUserServer);

//
// Opens the given user on the given user server
//
DWORD WINAPI
MprAdminUserOpen (
    IN  HANDLE hUserServer,
    IN  PWCHAR pszUser,
    OUT PHANDLE phUser);

//
// Closes the given user
//
DWORD WINAPI
MprAdminUserClose (
    IN HANDLE hUser);

//
// Reads in user ras-specific values
//
DWORD WINAPI
MprAdminUserRead (
    IN HANDLE hUser,
    IN DWORD dwLevel,
    IN const LPBYTE pRasUser);

//
// Writes out user ras-specific values
//
DWORD WINAPI
MprAdminUserWrite (
    IN HANDLE hUser,
    IN DWORD dwLevel,
    IN const LPBYTE pRasUser);

//
// Reads default profile flags
//
DWORD WINAPI
MprAdminUserReadProfFlags(
    IN  HANDLE hUserServer,
    OUT LPDWORD lpdwFlags);

//
// Writes default profile flags
//
DWORD WINAPI
MprAdminUserWriteProfFlags(
    IN  HANDLE hUserServer,
    IN  DWORD dwFlags);

//
// Upgrades users from previous OS version to current.
//
DWORD APIENTRY
MprAdminUpgradeUsers(
    IN  PWCHAR pszServer,
    IN  BOOL bLocal);

//
// Registers/Unregisters a ras server in a domain.
// Must be called from context of a domain admin.
//
DWORD 
WINAPI 
MprDomainRegisterRasServer (
    IN PWCHAR pszDomain,
    IN PWCHAR pszMachine,
    IN BOOL bEnable);

DWORD 
WINAPI 
MprAdminEstablishDomainRasServer (
    IN PWCHAR pszDomain,
    IN PWCHAR pszMachine,
    IN BOOL bEnable);

DWORD 
WINAPI 
MprAdminIsDomainRasServer (
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine,
    OUT PBOOL pbIsRasServer);
    
//
// Determines whether the given machine is registered
// in the given domain.
//
DWORD 
WINAPI 
MprDomainQueryRasServer (
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine,
    OUT PBOOL pbIsRasServer);
    

//
// Modifies the given domain with so that it yeilds the given access.
//
// See MPR_DOMAIN_ACCESS_* values for the flags
//
DWORD
WINAPI
MprDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Discovers what if any access is yeilded by the given domain.
//
// See MPR_DOMAIN_ACCESS_* values for the flags
//
DWORD
WINAPI
MprDomainQueryAccess(
    IN PWCHAR pszDomain,
    IN LPDWORD lpdwAccessFlags);

// 
// Sets all port usages to the given mode.  See MPRFLAG_PORT_*.
// The naming convention here is intentionally private.  Eventually,
// there should be MprAdmin and MprConfig api's to set port usage.
//
DWORD
APIENTRY
MprPortSetUsage(
    IN DWORD dwModes);

//
// Internal credentials functions shared by mprapi.dll and rasppp.dll
//
DWORD APIENTRY
MprAdminInterfaceSetCredentialsInternal(
    IN      LPWSTR                  lpwsServer          OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName        OPTIONAL,
    IN      LPWSTR                  lpwsDomainName      OPTIONAL,
    IN      LPWSTR                  lpwsPassword        OPTIONAL
);

DWORD APIENTRY
MprAdminInterfaceGetCredentialsInternal(
    IN      LPWSTR                  lpwsServer          OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName        OPTIONAL,
    IN      LPWSTR                  lpwsPassword        OPTIONAL,
    IN      LPWSTR                  lpwsDomainName      OPTIONAL
);

// 
// Utilities
//
DWORD 
MprUtilGetSizeOfMultiSz(
    IN LPWSTR lpwsMultiSz);

//
// Internal on-the-wire representations of the structures exposed
// in mprapi.h
//
typedef struct _MPRI_INTERFACE_0
{
    IN OUT  WCHAR                   wszInterfaceName[MAX_INTERFACE_NAME_LEN+1];
    OUT     DWORD                   dwInterface;
    IN OUT  BOOL                    fEnabled;
    IN OUT  ROUTER_INTERFACE_TYPE   dwIfType;
    OUT     ROUTER_CONNECTION_STATE dwConnectionState;
    OUT     DWORD                   fUnReachabilityReasons;
    OUT     DWORD                   dwLastError;

}
MPRI_INTERFACE_0, *PMPRI_INTERFACE_0;

typedef struct _MPRI_INTERFACE_1
{
    IN OUT  WCHAR                   wszInterfaceName[MAX_INTERFACE_NAME_LEN+1];
    OUT     DWORD                   dwInterface;
    IN OUT  BOOL                    fEnabled;
    IN OUT  ROUTER_INTERFACE_TYPE   dwIfType;
    OUT     ROUTER_CONNECTION_STATE dwConnectionState;
    OUT     DWORD                   fUnReachabilityReasons;
    OUT     DWORD                   dwLastError;
    OUT     DWORD                   dwDialoutHoursRestrictionOffset;
}
MPRI_INTERFACE_1, *PMPRI_INTERFACE_1;

typedef struct _MPRI_INTERFACE_2
{
    IN OUT  WCHAR                   wszInterfaceName[MAX_INTERFACE_NAME_LEN+1];
    OUT     DWORD                   dwInterface;
    IN OUT  BOOL                    fEnabled;
    IN OUT  ROUTER_INTERFACE_TYPE   dwIfType;
    OUT     ROUTER_CONNECTION_STATE dwConnectionState;
    OUT     DWORD                   fUnReachabilityReasons;
    OUT     DWORD                   dwLastError;

    //
    // Demand dial-specific properties
    //

    DWORD       dwfOptions;

    //
    // Location/phone number
    //

    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternatesOffset;

    //
    // PPP/Ip
    //

    DWORD       ipaddr;
    DWORD       ipaddrDns;
    DWORD       ipaddrDnsAlt;
    DWORD       ipaddrWins;
    DWORD       ipaddrWinsAlt;

    //
    // NetProtocols
    //

    DWORD       dwfNetProtocols;

    //
    // Device
    //

    WCHAR       szDeviceType[ MPR_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ MPR_MaxDeviceName + 1 ];

    //
    // X.25
    //

    WCHAR       szX25PadType[ MPR_MaxPadType + 1 ];
    WCHAR       szX25Address[ MPR_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ MPR_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ MPR_MaxUserData + 1 ];
    DWORD       dwChannels;

    //
    // Multilink
    //

    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;

    //
    // Idle timeout
    //

    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //

    DWORD       dwType;

    //
    // EncryptionType
    //

    DWORD       dwEncryptionType;

    //
    // EAP information
    //

    DWORD       dwCustomAuthKey;
    DWORD       dwCustomAuthDataSize;
    DWORD       dwCustomAuthDataOffset;

    //
    // Guid of the connection
    //

    GUID        guidId;

    //
    // Vpn Strategy
    //

    DWORD       dwVpnStrategy;

} MPRI_INTERFACE_2, *PMPRI_INTERFACE_2;

typedef struct _RASI_PORT_0
{
    OUT DWORD                   dwPort;
    OUT DWORD                   dwConnection;
    OUT RAS_PORT_CONDITION      dwPortCondition;
    OUT DWORD                   dwTotalNumberOfCalls;
    OUT DWORD                   dwConnectDuration;      // In seconds
    OUT WCHAR                   wszPortName[ MAX_PORT_NAME + 1 ];
    OUT WCHAR                   wszMediaName[ MAX_MEDIA_NAME + 1 ];
    OUT WCHAR                   wszDeviceName[ MAX_DEVICE_NAME + 1 ];
    OUT WCHAR                   wszDeviceType[ MAX_DEVICETYPE_NAME + 1 ];

}
RASI_PORT_0, *PRASI_PORT_0;

typedef struct _RASI_PORT_1
{
    OUT DWORD                   dwPort;
    OUT DWORD                   dwConnection;
    OUT RAS_HARDWARE_CONDITION  dwHardwareCondition;
    OUT DWORD                   dwLineSpeed;            // in bits/second
    OUT DWORD                   dwBytesXmited;
    OUT DWORD                   dwBytesRcved;
    OUT DWORD                   dwFramesXmited;
    OUT DWORD                   dwFramesRcved;
    OUT DWORD                   dwCrcErr;
    OUT DWORD                   dwTimeoutErr;
    OUT DWORD                   dwAlignmentErr;
    OUT DWORD                   dwHardwareOverrunErr;
    OUT DWORD                   dwFramingErr;
    OUT DWORD                   dwBufferOverrunErr;
    OUT DWORD                   dwCompressionRatioIn;
    OUT DWORD                   dwCompressionRatioOut;
}
RASI_PORT_1, *PRASI_PORT_1;

typedef struct _RASI_CONNECTION_0
{
    OUT DWORD                   dwConnection;
    OUT DWORD                   dwInterface;
    OUT DWORD                   dwConnectDuration; 
    OUT ROUTER_INTERFACE_TYPE   dwInterfaceType;
    OUT DWORD                   dwConnectionFlags;
    OUT WCHAR                   wszInterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
    OUT WCHAR                   wszUserName[ UNLEN + 1 ];
    OUT WCHAR                   wszLogonDomain[ DNLEN + 1 ];
    OUT WCHAR                   wszRemoteComputer[ NETBIOS_NAME_LEN + 1 ];

}
RASI_CONNECTION_0, *PRASI_CONNECTION_0;

typedef struct _RASI_CONNECTION_1
{
    OUT DWORD                   dwConnection;
    OUT DWORD                   dwInterface;
    OUT PPP_INFO                PppInfo;
    OUT DWORD                   dwBytesXmited;
    OUT DWORD                   dwBytesRcved;
    OUT DWORD                   dwFramesXmited;
    OUT DWORD                   dwFramesRcved;
    OUT DWORD                   dwCrcErr;
    OUT DWORD                   dwTimeoutErr;
    OUT DWORD                   dwAlignmentErr;
    OUT DWORD                   dwHardwareOverrunErr;
    OUT DWORD                   dwFramingErr;
    OUT DWORD                   dwBufferOverrunErr;
    OUT DWORD                   dwCompressionRatioIn;
    OUT DWORD                   dwCompressionRatioOut;
}
RASI_CONNECTION_1, *PRASI_CONNECTION_1;

typedef struct _RASI_CONNECTION_2
{
    OUT DWORD                   dwConnection;
    OUT WCHAR                   wszUserName[ UNLEN + 1 ];
    OUT ROUTER_INTERFACE_TYPE   dwInterfaceType;
    OUT GUID                    guid;
    OUT PPP_INFO_2              PppInfo2;
}
RASI_CONNECTION_2, *PRASI_CONNECTION_2;

typedef struct _MPR_CREDENTIALSEXI
{
    DWORD   dwSize;
    DWORD   dwOffset;
    BYTE    bData[1];
} MPR_CREDENTIALSEXI, *PMPR_CREDENTIALSEXI;

//
// Thunking api's
//

typedef
VOID
(* MprThunk_Free_Func)(
    IN PVOID pvData);

typedef
PVOID
(* MprThunk_Allocation_Func)(
    IN DWORD dwSize);

DWORD
MprThunkInterfaceFree(   
    IN PVOID pvData,
    IN DWORD dwLevel);

DWORD
MprThunkInterface_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer);

DWORD
MprThunkInterface_HtoW(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    OUT     LPBYTE* lplpbBuffer,
    OUT     LPDWORD lpdwSize);

DWORD
MprThunkPort_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer);

DWORD
MprThunkConnection_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer);

DWORD
MprThunkCredentials_HtoW(
    IN      DWORD dwLevel,
    IN      BYTE *pBuffer,
    IN      MprThunk_Allocation_Func pAlloc,
   OUT      DWORD *pdwSize,
   OUT      PBYTE *lplpbBuffer);

DWORD
MprThunkCredentials_WtoH(
    IN      DWORD dwLevel,
    IN      MPR_CREDENTIALSEXI  *pBuffer,
    IN      MprThunk_Allocation_Func pAlloc,
    OUT     PBYTE *lplpbBuffer);

PVOID
MprThunkAlloc(
    IN DWORD dwSize);

VOID
MprThunkFree(   
    IN PVOID pvData);
    
#ifdef __cplusplus
}   // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nbfconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbfconst.h

Abstract:

    This header file defines manifest constants for the NT NBF transport
    provider.  It is included by nbf.h.

Author:

    Stephen E. Jones (stevej) 25-Oct-1989

Revision History:

    David Beaver (dbeaver) 24-Sep-1990
        Remove pc586- and PDI-specific support. Add NDIS support. Note
        changes to be made here if MAC dependence of NDIS changes. (search
        for (PDI)

--*/

#ifndef _NBFCONST_
#define _NBFCONST_


//
// DEBUGGING SUPPORT.  DBG is a macro that is turned on at compile time
// to enable debugging code in the system.  If this is turned on, then
// you can use the IF_NBFDBG(flags) macro in the NBF code to selectively
// enable a piece of debugging code in the transport.  This macro tests
// NbfDebug, a global ULONG defined in NBFDRVR.C.
//

#if DBG

#define NBF_DEBUG_SENDENG       0x00000001      // sendeng.c debugging.
#define NBF_DEBUG_RCVENG        0x00000002      // rcveng.c debugging.
#define NBF_DEBUG_IFRAMES       0x00000004      // displays sent/rec'd iframes.
#define NBF_DEBUG_UFRAMES       0x00000008      // displays sent/rec'd uframes.
#define NBF_DEBUG_DLCFRAMES     0x00000010      // displays sent/rec'd dlc frames.
#define NBF_DEBUG_ADDRESS       0x00000020      // address.c debugging.
#define NBF_DEBUG_CONNECT       0x00000040      // connect.c debugging.
#define NBF_DEBUG_CONNOBJ       0x00000080      // connobj.c debugging.
#define NBF_DEBUG_DEVCTX        0x00000100      // devctx.c debugging.
#define NBF_DEBUG_DLC           0x00000200      // dlc.c data link engine debugging.
#define NBF_DEBUG_PKTLOG        0x00000400      // used to debug packet logging
#define NBF_DEBUG_PNP           0x00000800      // used in debugging PnP functions
#define NBF_DEBUG_FRAMECON      0x00001000      // framecon.c debugging.
#define NBF_DEBUG_FRAMESND      0x00002000      // framesnd.c debugging.
#define NBF_DEBUG_DYNAMIC       0x00004000      // dynamic allocation debugging.
#define NBF_DEBUG_LINK          0x00008000      // link.c debugging.
#define NBF_DEBUG_RESOURCE      0x00010000      // resource allocation debugging.
#define NBF_DEBUG_DISPATCH      0x00020000      // IRP request dispatching.
#define NBF_DEBUG_PACKET        0x00040000      // packet.c debugging.
#define NBF_DEBUG_REQUEST       0x00080000      // request.c debugging.
#define NBF_DEBUG_TIMER         0x00100000      // timer.c debugging.
#define NBF_DEBUG_DATAGRAMS     0x00200000      // datagram send/receive
#define NBF_DEBUG_REGISTRY      0x00400000      // registry access.
#define NBF_DEBUG_NDIS          0x00800000      // NDIS related information
#define NBF_DEBUG_LINKTREE      0x01000000      // Link splay tree debugging
#define NBF_DEBUG_TEARDOWN      0x02000000      // link/connection teardown info
#define NBF_DEBUG_REFCOUNTS     0x04000000      // link/connection ref/deref information
#define NBF_DEBUG_IRP           0x08000000      // irp completion debugging
#define NBF_DEBUG_SETUP         0x10000000      // debug session setup

//
// past here are debug things that are really frequent; don't use them
// unless you want LOTS of output
//
#define NBF_DEBUG_TIMERDPC      0x20000000      // the timer DPC
#define NBF_DEBUG_PKTCONTENTS   0x40000000      // dump packet contents in dbg
#define NBF_DEBUG_TRACKTDI      0x80000000      // store tdi info when set


extern ULONG NbfDebug;                          // in NBFDRVR.C.
extern BOOLEAN NbfDisconnectDebug;              // in NBFDRVR.C.

#define TRACK_TDI_LIMIT 25
#define TRACK_TDI_CAPTURE 36      // chosen to make debug line up nice
typedef  struct {
        PVOID Request;
        PIRP Irp;
        PVOID Connection;
        UCHAR Contents[TRACK_TDI_CAPTURE];
    }  NBF_SEND;

typedef struct {
        PVOID Request;
        PIRP Irp;
        NTSTATUS Status;
        PVOID NothingYet;
    } NBF_SEND_COMPLETE;

typedef struct {
        PVOID Request;
        PIRP Irp;
        PVOID Connection;
        PVOID NothingYet;
    } NBF_RECEIVE;

typedef  struct {
        PVOID Request;
        PIRP Irp;
        NTSTATUS Status;
        UCHAR Contents[TRACK_TDI_CAPTURE];
    } NBF_RECEIVE_COMPLETE;

extern NBF_SEND NbfSends[TRACK_TDI_LIMIT+1];
extern LONG NbfSendsNext;

extern NBF_SEND_COMPLETE NbfCompletedSends[TRACK_TDI_LIMIT+1];
extern LONG NbfCompletedSendsNext;

extern NBF_RECEIVE NbfReceives[TRACK_TDI_LIMIT+1];
extern LONG NbfReceivesNext;

extern NBF_RECEIVE_COMPLETE NbfCompletedReceives[TRACK_TDI_LIMIT+1];
extern LONG NbfCompletedReceivesNext;

#endif

//
// some convenient constants used for timing. All values are in clock ticks.
//

#define MICROSECONDS 10
#define MILLISECONDS 10000              // MICROSECONDS*1000
#define SECONDS 10000000                // MILLISECONDS*1000


//
// temporary things used by nbf that are caused by the change-over from
// (never implimented) PDI support to NDIS support. They may be removed pending
// resolution of NDIS issues about MAC support.
//

#define PDI_SOURCE_ROUTE        0x00000002 // source routing field is specified.
#define PDI_HARDWARE_ADDRESS    0x00000004 // hardware address field is specified.
#define PDI_TRUNCATED           0x00000001 // PSDU was truncated.
#define PDI_FRAGMENT            0x00000002 // PSDU was fragmented.
#define PDI_BROADCAST           0x00000004 // PSDU was broadcast.
#define PDI_MULTICAST           0x00000008 // PSDU was multicast/functional.
#define PDI_SOURCE_ROUTING      0x00000010 // PSDU contained source routing information.



//
// MAJOR PROTOCOL IDENTIFIERS THAT CHARACTERIZE THIS DRIVER.
//

#define NBF_DEVICE_NAME         L"\\Device\\Nbf"// name of our driver.
#define NBF_NAME                L"Nbf"          // name for protocol chars.
#define DSAP_NETBIOS_OVER_LLC   0xf0            // NETBEUI always has DSAP 0xf0.
#define PSAP_LLC                0               // LLC always runs over PSAP 0.
#define MAX_SOURCE_ROUTE_LENGTH 32              // max. bytes of SR. info.
#define MAX_NETWORK_NAME_LENGTH 128             // # bytes in netname in TP_ADDRESS.
#define MAX_USER_PACKET_DATA    1500            // max. user bytes per DFM/DOL.

#define NBF_FILE_TYPE_CONTROL   (ULONG)0x4701   // file is type control


//
// MAJOR CONFIGURATION PARAMETERS THAT WILL BE MOVED TO THE INIT-LARGE_INTEGER
// CONFIGURATION MANAGER.
//

#define MAX_REQUESTS           30
#define MAX_UI_FRAMES          25
#define MAX_SEND_PACKETS       40
#define MAX_RECEIVE_PACKETS    30
#define MAX_RECEIVE_BUFFERS    15
#define MAX_LINKS              10
#define MAX_CONNECTIONS        10
#define MAX_ADDRESSFILES       10
#define MAX_ADDRESSES          10

#define MIN_UI_FRAMES           5   // + one per address + one per connection
#define MIN_SEND_PACKETS       20   // + one per link + one per connection
#define MIN_RECEIVE_PACKETS    10   // + one per link + one per address
#define MIN_RECEIVE_BUFFERS     5   // + one per address

#define SEND_PACKET_RESERVED_LENGTH (sizeof (SEND_PACKET_TAG))
#define RECEIVE_PACKET_RESERVED_LENGTH (sizeof (RECEIVE_PACKET_TAG))


#define ETHERNET_HEADER_SIZE      14    // used for current NDIS compliance
#define ETHERNET_PACKET_SIZE    1514

#define MAX_DEFERRED_TRAVERSES     6    // number of times we can go through
                                        // the deferred operations queue and
                                        // not do anything without causing an
                                        // error indication


//
// NETBIOS PROTOCOL CONSTANTS.
//

#define NETBIOS_NAME_LENGTH     16
#define NETBIOS_SESSION_LIMIT   254             // max # of sessions/link. (abs limit is 254)

#define NAME_QUERY_RETRIES      3               // 2 retrie(s), plus the first one.
#define ADD_NAME_QUERY_RETRIES  3               // 1 retrie(s) plus the first one.
#define WAN_NAME_QUERY_RETRIES  5               // for NdisMediumWan only.

#define NAME_QUERY_TIMEOUT      (500*MILLISECONDS)
#define ADD_NAME_QUERY_TIMEOUT  (500*MILLISECONDS)

//
// DATA LINK PROTOCOL CONSTANTS.
//
// There are two timers, short and long. T1, T2, and the purge
// timer are run off of the short timer, Ti and the adaptive timer
// is run off of the long one.
//

#define SHORT_TIMER_DELTA        (50*MILLISECONDS)
#define LONG_TIMER_DELTA         (1*SECONDS)

#define DLC_MINIMUM_T1           (400 * MILLISECONDS)
#define DLC_DEFAULT_T1           (600 * MILLISECONDS)
#define DLC_DEFAULT_T2           (150 * MILLISECONDS)
#define DLC_DEFAULT_TI           (30 * SECONDS)
#define DLC_RETRIES              (8)  // number of poll retries at LLC level.
#define DLC_RETRANSMIT_THRESHOLD (10)  // up to n retransmissions acceptable.
#define DLC_WINDOW_LIMIT         (10)  // incr. to 127 when packet pool expanded.

#define DLC_TIMER_ACCURACY       8    // << between BaseT1Timeout and CurrentT1Timeout


#define TIMER_ADAPTIVE_TICKS  ((DLC_DEFAULT_T1*60)/LONG_TIMER_DELTA) // time between adaptive runs.
#define TIMER_PURGE_TICKS     ((DLC_DEFAULT_T1*10)/SHORT_TIMER_DELTA) // time between adaptive purges.


//
// TDI defined timeouts
//

#define TDI_TIMEOUT_SEND                 60L        // sends go 120 seconds
#define TDI_TIMEOUT_RECEIVE               0L        // receives
#define TDI_TIMEOUT_CONNECT              60L
#define TDI_TIMEOUT_LISTEN                0L        // listens default to never.
#define TDI_TIMEOUT_DISCONNECT           60L        // should be 30
#define TDI_TIMEOUT_NAME_REGISTRATION    60L



//
// GENERAL CAPABILITIES STATEMENTS THAT CANNOT CHANGE.
//

#define NBF_MAX_TSDU_SIZE 65535     // maximum TSDU size supported by NetBIOS.
#define NBF_MAX_DATAGRAM_SIZE 512   // maximum Datagram size supported by NetBIOS.
#define NBF_MAX_CONNECTION_USER_DATA 0  // no user data supported on connect.
#define NBF_SERVICE_FLAGS  (                            \
                TDI_SERVICE_FORCE_ACCESS_CHECK |        \
                TDI_SERVICE_CONNECTION_MODE |           \
                TDI_SERVICE_CONNECTIONLESS_MODE |       \
                TDI_SERVICE_MESSAGE_MODE |              \
                TDI_SERVICE_ERROR_FREE_DELIVERY |       \
                TDI_SERVICE_BROADCAST_SUPPORTED |       \
                TDI_SERVICE_MULTICAST_SUPPORTED |       \
                TDI_SERVICE_DELAYED_ACCEPTANCE  )

#define NBF_MIN_LOOKAHEAD_DATA 256      // minimum guaranteed lookahead data.
#define NBF_MAX_LOOKAHEAD_DATA 256      // maximum guaranteed lookahead data.

#define NBF_MAX_LOOPBACK_LOOKAHEAD  192  // how much is copied over for loopback

//
// Number of TDI resources that we report.
//

#define NBF_TDI_RESOURCES      9


//
// NetBIOS name types used in the NetBIOS Frames Protocol Connectionless PDUs.
//

#define NETBIOS_NAME_TYPE_UNIQUE        0x00    // name is unique on the network.
#define NETBIOS_NAME_TYPE_GROUP         0x01    // name is a group name.
#define NETBIOS_NAME_TYPE_EITHER        0x02    // used in NbfMatchNetbiosAddress

//
// STATUS_QUERY request types.  If the sender is following pre-2.1 protocol,
// then a simple request-response exchange is performed.  Later versions
// store the "total number of names received so far" in the request type
// field, except for the first request, which must contain a 1 in this field.
//

#define STATUS_QUERY_REQUEST_TYPE_PRE21 0x00 // request is 1.x or 2.0.
#define STATUS_QUERY_REQUEST_TYPE_FIRST 0x01 // first request, 2.1 or above.

//
// If the LocalSessionNumber field contains a 0, then the request is really
// a FIND.NAME.  If the field is non-zero, then it is the local session
// number that will be provided in all connection-oriented headers thereafter.
//

#define NAME_QUERY_LSN_FIND_NAME        0x00 // LSN for FIND.NAME request.

//
// NAME_RECOGNIZED LocalSessionNumber status values.  If the connection
// request was rejected, then one of the following values is placed in
// the LocalSessionNumber field.  NAME_RECOGNIZED can also be used as a
// FIND.NAME response, in which case the NO_LISTENS status is overloaded
// to also mean a FIND.NAME.
//

#define NAME_RECOGNIZED_LSN_NO_LISTENS  0x00    // no listens available.
#define NAME_RECOGNIZED_LSN_FIND_NAME   0x00    // this is a find name response.
#define NAME_RECOGNIZED_LSN_NO_RESOURCE 0xff    // listen available, but no resources.

//
// STATUS_RESPONSE response types.  If the sender is following pre-2.1
// protocol, then a simple request-response exchange is performed.  Later
// versions store the "total number of names sent so far" in the request
// type field.  This value is cumulative, and includes the count of names
// sent with the current response, as well as from previous responses.
//

#define STATUS_RESPONSE_PRE21 0x00      // request is 1.x or 2.0.
#define STATUS_RESPONSE_FIRST 0x01      // first request, 2.1 or above.

//
// DATA_FIRST_MIDDLE option bitflags.
//

#define DFM_OPTIONS_RECEIVE_CONTINUE    0x01 // RECEIVE_CONTINUE requested.
#define DFM_OPTIONS_NO_ACK              0x02 // no DATA_ACK frame expected.
#define DFM_OPTIONS_RESYNCH             0x04 // set resynch indicator/this frame.
#define DFM_OPTIONS_ACK_INCLUDED        0x08 // piggyback ack included.

//
// DATA_ONLY_LAST option bitflags.
//

#define DOL_OPTIONS_RESYNCH             0x01 // set resynch indicator/this frame.
#define DOL_OPTIONS_NO_ACK              0x02 // no DATA_ACK frame expected.
#define DOL_OPTIONS_ACK_W_DATA_ALLOWED  0x04 // piggyback ack allowed.
#define DOL_OPTIONS_ACK_INCLUDED        0x08 // piggyback ack included.

//
// SESSION_CONFIRM option bitflags.
//

#define SESSION_CONFIRM_OPTIONS_20      0x01 // set if NETBIOS 2.0 or above.
#define SESSION_CONFIRM_NO_ACK          0x80 // set if NO.ACK protocol supported.

//
// SESSION_END reason codes.
//

#define SESSION_END_REASON_HANGUP       0x0000  // normal termination via HANGUP.
#define SESSION_END_REASON_ABEND        0x0001  // abnormal session termination.

//
// SESSION_INITIALIZE option bitflags.
//

#define SESSION_INIT_OPTIONS_20         0x01    // set if NETBIOS 2.0 or above.
#define SESSION_INIT_OPTIONS_LF         0x0E    // Maximum largest frame value
#define SESSION_INIT_NO_ACK             0x80    // set if NO.ACK protocol supported.

//
// NO_RECEIVE option bitflags.
//

#define NO_RECEIVE_PARTIAL_NO_ACK 0x02         // NO.ACK data partially received.

//
// Resource IDs for query and error logging.
//

#define LINK_RESOURCE_ID                 11
#define ADDRESS_RESOURCE_ID              12
#define ADDRESS_FILE_RESOURCE_ID         13
#define CONNECTION_RESOURCE_ID           14
#define REQUEST_RESOURCE_ID              15

#define UI_FRAME_RESOURCE_ID             21
#define PACKET_RESOURCE_ID               22
#define RECEIVE_PACKET_RESOURCE_ID       23
#define RECEIVE_BUFFER_RESOURCE_ID       24


//
// memory management additions
//

//
// Fake IOCTLs used for kernel mode testing.
//

#define IOCTL_NBF_BASE FILE_DEVICE_TRANSPORT

#define _NBF_CONTROL_CODE(request,method) \
                ((IOCTL_NBF_BASE)<<16 | (request<<2) | method)

#define IOCTL_TDI_SEND_TEST      _NBF_CONTROL_CODE(26,0)
#define IOCTL_TDI_RECEIVE_TEST   _NBF_CONTROL_CODE(27,0)
#define IOCTL_TDI_SERVER_TEST    _NBF_CONTROL_CODE(28,0)

//
// More debugging stuff
//

#define NBF_REQUEST_SIGNATURE        ((CSHORT)0x4702)
#define NBF_LINK_SIGNATURE           ((CSHORT)0x4703)
#define NBF_CONNECTION_SIGNATURE     ((CSHORT)0x4704)
#define NBF_ADDRESSFILE_SIGNATURE    ((CSHORT)0x4705)
#define NBF_ADDRESS_SIGNATURE        ((CSHORT)0x4706)
#define NBF_DEVICE_CONTEXT_SIGNATURE ((CSHORT)0x4707)
#define NBF_PACKET_SIGNATURE         ((CSHORT)0x4708)

#if DBG
extern PVOID * NbfConnectionTable;
extern PVOID * NbfRequestTable;
extern PVOID * NbfUiFrameTable;
extern PVOID * NbfSendPacketTable;
extern PVOID * NbfLinkTable;
extern PVOID * NbfAddressFileTable;
extern PVOID * NbfAddressTable;
#endif

//
// Tags used in Memory Debugging
//
#define NBF_MEM_TAG_GENERAL_USE         ' FBN'

#define NBF_MEM_TAG_TP_ADDRESS          'aFBN'
#define NBF_MEM_TAG_RCV_BUFFER          'bFBN'
#define NBF_MEM_TAG_TP_CONNECTION       'cFBN'
#define NBF_MEM_TAG_POOL_DESC           'dFBN'
#define NBF_MEM_TAG_DEVICE_EXPORT       'eFBN'
#define NBF_MEM_TAG_TP_ADDRESS_FILE     'fFBN'
#define NBF_MEM_TAG_REGISTRY_PATH       'gFBN'

#define NBF_MEM_TAG_TDI_CONNECTION_INFO 'iFBN'

#define NBF_MEM_TAG_LOOPBACK_BUFFER     'kFBN'
#define NBF_MEM_TAG_TP_LINK             'lFBN'

#define NBF_MEM_TAG_NETBIOS_NAME        'nFBN'
#define NBF_MEM_TAG_CONFIG_DATA         'oFBN'
#define NBF_MEM_TAG_TP_PACKET           'pFBN'
#define NBF_MEM_TAG_TDI_QUERY_BUFFER    'qFBN'
#define NBF_MEM_TAG_TP_REQUEST          'rFBN'
#define NBF_MEM_TAG_TDI_PROVIDER_STATS  'sFBN'
#define NBF_MEM_TAG_CONNECTION_TABLE    'tFBN'
#define NBF_MEM_TAG_TP_UI_FRAME         'uFBN'

#define NBF_MEM_TAG_WORK_ITEM           'wFBN'

#define NBF_MEM_TAG_DEVICE_PDO          'zFBN'

#endif // _NBFCONST_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\llipif.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** LLIPIF.H - Lower layer IP interface definitions.
//
// This file contains the definitions defining the interface between IP
// and a lower layer, such as ARP or SLIP.

/*
    This file defines a new and improved IP to ARP Module interface definition and will replace llipif.h.
    This will also retire the IOCTL method of registering ARP interfaces. The main points are:

    - It simplifies setup such that the ARP Modules do not have their own bindings in addition to IP bindings.
    - Lets ARP Modules expose multiple IP interfaces per binding.
    - Adds version numbering for future compatibility.
    - Adds Multi-send capability to ARP
    - Lets ARP indicate a packet up in NDIS 4.0 style and IP hang onto the packet and avoid copying.

    The flow today is:
    ------------------

    ARP gets a bind indication from NDIS.
    ARP calls IPAddInterface
    IP calls ARP_REGISTER

    The proposed flow is:
    ---------------------

    ARP Registers itself with IP via IPRegisterARP(). The ARP is identified by its Name which is case insensitive.

    IP gets a bind indication from NDIS. It opens the config section and read the ARP name. Empty name implies
    built in ARP as usual.
    IP calls ARP's bind handler passing in the config handle.
    ARP then opens the adapter and adds one or more IP interfaces via IP_ADD_INTERFACE. For each of up-call ARP
    passes in the config-handle for that interface to IP. In most cases it is the same handle which IP passed
    to ARP. In case of multiple IP interfaces per adapter it is not.
    Calls IPBindComplete() when done.
*/

#pragma once
#ifndef LLIPIF_INCLUDED
#define LLIPIF_INCLUDED

#define IP_ARP_BIND_VERSION     0x50000

//
// IP Interface routines called by the ARP interface.
//
typedef
void
(__stdcall *IPRcvRtn)(
    IN  void *                  IpInterfaceContext,
    IN  void *                  Data,
    IN  uint                    DataSize,
    IN  uint                    TotalSize,
    IN  NDIS_HANDLE             LinkContext1,
    IN  uint                    LinkContext2,
    IN  uint                    Bcast,
    IN      void *                                  LinkCtxt
    );

typedef
void
(__stdcall *IPRcvPktRtn)(
    void *,
    void *,
    uint ,
    uint ,
    NDIS_HANDLE ,
    uint,
    uint,
    uint,
    PMDL,
    uint *,
    void *
    );

typedef
void
(__stdcall *IPRcvCmpltRtn)(void);

typedef
void
(__stdcall *IPTxCmpltRtn)(
    IN  void *                  IpInterfaceContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             CompletionStatus
    );

typedef
void
(__stdcall *IPTDCmpltRtn)(
    IN  void *                  IpInterfaceContext,
    PNDIS_PACKET                DestinationPacket,
    NDIS_STATUS                 Status,
    uint                        BytesCopied
    );

typedef
void
(__stdcall *IPStatusRtn)(
    IN  void *                  IpInterfaceContext,
    IN  uint                    StatusCode,
    IN  void *                  Buffer,
    IN  uint                    BufferSize,
    IN  void *                  LinkCtxt
    );

typedef
NDIS_STATUS
(__stdcall *IP_PNP)(
    IN  void *                  IpInterfaceContext,
    IN  PNET_PNP_EVENT          NetPnPEvent
);
typedef
void
(__stdcall *IPAddAddrCmpltRtn)(
    IN  IPAddr                   Address,
    IN  void                    *Context,
    IN  IP_STATUS                Status
);

typedef struct _IP_HANDLERS
{
    IPRcvRtn                    IpRcvHandler;
    IPRcvCmpltRtn               IpRcvCompleteHandler;
    IPTxCmpltRtn                IpTxCompleteHandler;
    IPTDCmpltRtn                IpTransferCompleteHandler;
    IPStatusRtn                 IpStatusHandler;
    IP_PNP                      IpPnPHandler;
    IPRcvPktRtn                 IpRcvPktHandler;
    IPAddAddrCmpltRtn           IpAddAddrCompleteRtn;  // called when arp detects address conflicts.
} IP_HANDLERS, *PIP_HANDLERS;



#define LLIP_ADDR_LOCAL     0
#define LLIP_ADDR_MCAST     1
#define LLIP_ADDR_BCAST     2
#define LLIP_ADDR_PARP      4

//
// ARP Handlers passed to IP when IP_ADD_INTERFACE is called.
//
typedef
NDIS_STATUS
(__stdcall *ARP_TRANSMIT)(
    IN  void *                  ARPInterfaceContext,
#ifdef  NT
    IN  PNDIS_PACKET *          PacketArray,
    IN  uint                    NumberOfPackets,
#else
    IN  PNDIS_PACKET            Packet,
#endif
    IN  IPAddr                  IpAddr,
    IN  RouteCacheEntry *       Rce     OPTIONAL,
    IN  void *                  ArpCtxt
    );

typedef
NDIS_STATUS
(__stdcall *ARP_TRANSFER)(
    IN  void *                  ARPInterfaceContext,
    IN  NDIS_HANDLE             TransferContext,
    IN  uint                    HdrOffset,
    IN  uint                    ProtocolOffset,
    IN  uint                    BytesNeeded,
    IN  PNDIS_PACKET            DestinationPacket,
    OUT uint *                  BytesCopied
    );

typedef
void
(__stdcall *ARP_RETURN_PKT)(
    IN  void *                  ARPInterfaceContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
void
(__stdcall *ARP_CLOSE)(
    IN  void *                  ArpInterfaceContext
    );

typedef
uint
(__stdcall *ARP_ADDADDR)(
    IN  void *                  ArpInterfaceContext,
    IN  uint                    AddressType,
    IN  IPAddr                  IpAddress,
    IN  IPMask                  IpMask,
    IN  void *                  Context
    );

typedef
uint
(__stdcall *ARP_DELADDR)(
    IN  void *                  ArpInterfaceContext,
    IN  uint                    AddressType,
    IN  IPAddr                  IpAddress,
    IN  IPMask                  IpMask
    );

typedef
void
(__stdcall *ARP_INVALIDATE)(
    IN  void *                  ArpInterfaceContext,
    IN  RouteCacheEntry *       Rce
    );

typedef
void
(__stdcall *ARP_OPEN)(
    IN  void *                  ArpInterfaceContext
    );

typedef
int
(__stdcall *ARP_QINFO)(
    IN  void *                  ArpInterfaceContext,
    IN  struct TDIObjectID *    pId,
    IN  PNDIS_BUFFER            Buffer,
    IN OUT uint *               BufferSize,
    IN  void *                  QueryContext
    );

typedef
int
(__stdcall *ARP_SETINFO)(
    IN  void *                  ArpInterfaceContext,
    IN  struct TDIObjectID *    pId,
    IN  void *                  Buffer,
    IN  uint                    BufferSize
    );

typedef
int
(__stdcall *ARP_GETELIST)(
    IN  void *                  ArpInterfaceContext,
    IN  void *                  pEntityList,
    IN OUT  PUINT               pEntityListSize
    );

typedef
NDIS_STATUS
(__stdcall *ARP_DONDISREQ)(
    IN  void *  ArpInterfaceContext,
   IN NDIS_REQUEST_TYPE RT,
   IN NDIS_OID OID,
   IN void *   Info,
   IN uint     Length,
   IN uint *   Needed,
   IN BOOLEAN Blocking
    );

typedef
void
(__stdcall *ARP_CANCEL)(
    IN  void *  ArpInterfaceContext,
    IN  void *  CancelCtxt
    );

//
// Structure of information returned from ARP register call.
//
struct LLIPBindInfo {
    PVOID           lip_context;    // LL context handle.
    uint            lip_mss;        // Maximum segment size.
    uint            lip_speed;      // Speed of this i/f.
    uint            lip_index;      // Interface index ID.
    uint            lip_txspace;    // Space required in the packet header for ARP use
    ARP_TRANSMIT    lip_transmit;
    ARP_TRANSFER    lip_transfer;
    ARP_RETURN_PKT  lip_returnPkt;
    ARP_CLOSE       lip_close;
    ARP_ADDADDR     lip_addaddr;
    ARP_DELADDR     lip_deladdr;
    ARP_INVALIDATE  lip_invalidate;
    ARP_OPEN        lip_open;
    ARP_QINFO       lip_qinfo;
    ARP_SETINFO     lip_setinfo;
    ARP_GETELIST    lip_getelist;
    ARP_DONDISREQ   lip_dondisreq;
    uint            lip_flags;      // Flags for this interface.
    uint            lip_addrlen;    // Length in bytes of address.
    uchar   *       lip_addr;       // Pointer to interface address.
    uint            lip_OffloadFlags;   // IP offload capabilities flag
    uint            lip_IPSecOffloadFlags;   // IPSec offload capabilities flag
    ulong           lip_ffpversion;   // Version of FFP Supported or 0
    ULONG_PTR       lip_ffpdriver;    // Corr. NDIS driver handle for IF

    NDIS_STATUS     (__stdcall *lip_setndisrequest)(void *, NDIS_OID, uint);
    NDIS_STATUS     (__stdcall *lip_dowakeupptrn)(void *, PNET_PM_WAKEUP_PATTERN_DESC, USHORT, BOOLEAN);
    void            (__stdcall *lip_pnpcomplete)(void *, NDIS_STATUS, PNET_PNP_EVENT);
    NDIS_STATUS     (__stdcall *lip_arpresolveip)(void *, IPAddr, void *);

    uint            lip_MaxOffLoadSize;
    uint            lip_MaxSegments;

    BOOLEAN         (__stdcall *lip_arpflushate)(void *, IPAddr );
    void            (__stdcall *lip_arpflushallate)(void *);

    void            (__stdcall *lip_closelink)(void *, void *);

    uint            lip_pnpcap;

#if !MILLEN
    ARP_CANCEL      lip_cancelpackets;
#endif
};



#define LIP_COPY_FLAG       1       // Copy lookahead flag.
#define LIP_P2P_FLAG        2       // Interface is point to point
#define LIP_NOIPADDR_FLAG   4      // Unnumbered interface
#define LIP_P2MP_FLAG       8      // P2MP interface
#define LIP_NOLINKBCST_FLAG 0x10   // No link bcast
#define LIP_UNI_FLAG        0x20   // Uni-direction adapter.

typedef struct LLIPBindInfo LLIPBindInfo;

//* Status codes from the lower layer.
#define LLIP_STATUS_MTU_CHANGE      1
#define LLIP_STATUS_SPEED_CHANGE    2
#define LLIP_STATUS_ADDR_MTU_CHANGE 3

//* The LLIP_STATUS_MTU_CHANGE passed a pointer to this structure.
struct LLIPMTUChange {
    uint        lmc_mtu;            // New MTU.
}; /* LLIPMTUChange */

typedef struct LLIPMTUChange LLIPMTUChange;

//* The LLIP_STATUS_SPEED_CHANGE passed a pointer to this structure.
struct LLIPSpeedChange {
    uint        lsc_speed;          // New speed.
}; /* LLIPSpeedChange */

typedef struct LLIPSpeedChange LLIPSpeedChange;

//* The LLIP_STATUS_ADDR_MTU_CHANGE passed a pointer to this structure.
struct LLIPAddrMTUChange {
    uint        lam_mtu;            // New MTU.
    uint        lam_addr;           // Address that changed.
}; /* LLIPAddrMTUChange */

typedef struct LLIPAddrMTUChange LLIPAddrMTUChange;

typedef
int
(__stdcall *LLIPRegRtn)(
    IN  PNDIS_STRING            InterfaceName,
    IN  void *                  IpInterfaceContext,
    IN  struct _IP_HANDLERS *   IpHandlers,
    OUT struct LLIPBindInfo *   ARPBindInfo,
    IN  uint                    InterfaceNumber
    );
//
// ARP Module interface prototypes used during IP <-> ARP interface initialization.
//
typedef
IP_STATUS
(__stdcall *IP_ADD_INTERFACE)(

    IN  PNDIS_STRING            DeviceName,
    IN  PNDIS_STRING            IfName,     OPTIONAL

    IN  PNDIS_STRING            ConfigurationHandle,
    IN  void *                  PNPContext,
    IN  void *                  ARPInterfaceContext,
    IN  LLIPRegRtn              RegRtn,
    IN  struct LLIPBindInfo *   ARPBindInfo,
    IN  UINT                    RequestedIndex,
    IN  ULONG                   MediaType,
    IN  UCHAR                   AccessType,
    IN  UCHAR                   ConnectionType
    );

typedef
void
(__stdcall *IP_DEL_INTERFACE)(
    IN  void *                  IPInterfaceContext,
    IN  BOOLEAN                 DeleteIndex
    );

typedef
void
(__stdcall *IP_BIND_COMPLETE)(
    IN  IP_STATUS               BindStatus,
    IN  void *                  BindContext
    );

typedef
int
(__stdcall *ARP_BIND)(
    IN  PNDIS_STATUS    RetStatus,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    AdapterName,
    IN  PVOID           SS1,
    IN  PVOID           SS2
    );

typedef
IP_STATUS
(__stdcall *IP_ADD_LINK)(
    IN  void *IpIfCtxt,
    IN  IPAddr NextHop,
    IN  void *ArpLinkCtxt,
    OUT void **IpLnkCtxt,
    IN  uint mtu
    );

typedef
IP_STATUS
(__stdcall *IP_DELETE_LINK)(
    IN  void *IpIfCtxt,
    IN  void *LnkCtxt
    );

typedef
NTSTATUS
(__stdcall *IP_RESERVE_INDEX)(
    IN  ULONG   ulNumIndices,
    OUT PULONG  pulStartIndex,
    OUT PULONG  pulLongestRun
    );

typedef
VOID
(__stdcall *IP_DERESERVE_INDEX)(
    IN  ULONG   ulNumIndices,
    IN  ULONG   ulStartIndex
    );

typedef
NTSTATUS
(__stdcall *IP_CHANGE_INDEX)(
    IN  PVOID           pvContext,
    IN  ULONG           ulNewIndex,
    IN  PUNICODE_STRING pusNewName OPTIONAL
    );

//
// Exported IP interface used by the ARP modules
//
NTSTATUS
__stdcall
IPRegisterARP(
    IN  PNDIS_STRING            ARPName,
    IN  uint                    Version,        /* Suggested value of 0x50000 for NT 5.0 and memphis */
    IN  ARP_BIND                ARPBindHandler,
    OUT IP_ADD_INTERFACE *      IpAddInterfaceHandler,
    OUT IP_DEL_INTERFACE *      IpDeleteInterfaceHandler,
    OUT IP_BIND_COMPLETE *      IpBindCompleteHandler,
    OUT IP_ADD_LINK      *      IpAddLinkHandler,
    OUT IP_DELETE_LINK   *      IpDeleteLinkHandler,
    OUT IP_CHANGE_INDEX  *      IpChangeIndex,
    OUT IP_RESERVE_INDEX *      IpReserveIndex,
    OUT IP_DERESERVE_INDEX *    IpDereserveIndex,
    OUT HANDLE           *      ARPRegisterHandle
    );

NTSTATUS
__stdcall
IPDeregisterARP(
    IN HANDLE   ARPRegisterHandle
    );

//
// exported via Dll entrypoints.
//
extern IP_STATUS
IPAddInterface(
    PNDIS_STRING DeviceName,
    PNDIS_STRING IfName,     OPTIONAL
    PNDIS_STRING ConfigName,
    void         *PNP,
    void         *Context,
    LLIPRegRtn   RegRtn,
    LLIPBindInfo *BindInfo,
    UINT         RequestedIndex,
    ULONG        MediaType,
    UCHAR        AccessType,
    UCHAR        ConnectionType
    );


extern void IPDelInterface(void *Context , BOOLEAN DeleteIndex);

extern IP_STATUS IPAddLink(void *IpIfCtxt, IPAddr NextHop, void *ArpLinkCtxt, void **IpLnkCtxt, uint mtu);

extern IP_STATUS IPDeleteLink(void *IpIfCtxt, void *LnkCtxt);


//
// Registration IOCTL code definition -
//
// This IOCTL is issued to a lower layer driver to retrieve the address
// of its registration function. There is no input buffer. The output
// buffer will contain a LLIPIF_REGISTRATION_DATA structure. This
// buffer is pointed to by Irp->AssociatedIrp.SystemBuffer and should be
// filled in before completion.
//

//
// structure passed in the registration IOCTL.
//
typedef struct llipif_registration_data {
    LLIPRegRtn    RegistrationFunction;
} LLIPIF_REGISTRATION_DATA;



typedef IP_ADD_INTERFACE IPAddInterfacePtr;
typedef IP_DEL_INTERFACE IPDelInterfacePtr;

//* Structure used in IOCTL_IP_GET_PNP_ARP_POINTERS ioctl sent to \device\ip by ARP modules
//
typedef struct ip_get_arp_pointers {
    IPAddInterfacePtr   IPAddInterface ;    // Pointer to IP's add interface routine
    IPDelInterfacePtr   IPDelInterface ; // Pointer to IP's del interface routine
} IP_GET_PNP_ARP_POINTERS, *PIP_GET_PNP_ARP_POINTERS ;


#define FSCTL_LLIPIF_BASE     FILE_DEVICE_NETWORK

#define _LLIPIF_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_LLIPIF_BASE, function, method, access)


#define IOCTL_LLIPIF_REGISTER    \
            _LLIPIF_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)


#endif // LLIPIF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nbfhdrs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbfhdrs.h

Abstract:

    This module defines private structure definitions describing the layout
    of the NetBIOS Frames Protocol headers for the NT NBF transport
    provider.

Author:

    Stephen E. Jones (stevej) 25-Oct-1989

Revision History:

    David Beaver (dbeaver) 24-Sep-1990
    remove pc586 and PDI specific code; add NDIS support

--*/

#ifndef _NBFHDRS_
#define _NBFHDRS_

//
// Pack these headers, as they are sent fully packed on the network.
//

#ifdef PACKING

#ifdef __STDC__
#pragma Off(Align_members)
#else
#pragma pack(1)
#endif // def __STDC__

#endif // def PACKING

#define NETBIOS_SIGNATURE_1 0xef        // signature in NetBIOS frames.
#define NETBIOS_SIGNATURE_0 0xff        // 1st byte.
#define NETBIOS_SIGNATURE   0xefff

//
// NetBIOS Frames Protocol Command Codes.
//

#define NBF_CMD_ADD_GROUP_NAME_QUERY    0x00
#define NBF_CMD_ADD_NAME_QUERY          0x01
#define NBF_CMD_NAME_IN_CONFLICT        0x02
#define NBF_CMD_STATUS_QUERY            0x03
#define NBF_CMD_TERMINATE_TRACE         0x07
#define NBF_CMD_DATAGRAM                0x08
#define NBF_CMD_DATAGRAM_BROADCAST      0x09
#define NBF_CMD_NAME_QUERY              0x0a
#define NBF_CMD_ADD_NAME_RESPONSE       0x0d
#define NBF_CMD_NAME_RECOGNIZED         0x0e
#define NBF_CMD_STATUS_RESPONSE         0x0f
#define NBF_CMD_TERMINATE_TRACE2        0x13
#define NBF_CMD_DATA_ACK                0x14
#define NBF_CMD_DATA_FIRST_MIDDLE       0x15
#define NBF_CMD_DATA_ONLY_LAST          0x16
#define NBF_CMD_SESSION_CONFIRM         0x17
#define NBF_CMD_SESSION_END             0x18
#define NBF_CMD_SESSION_INITIALIZE      0x19
#define NBF_CMD_NO_RECEIVE              0x1a
#define NBF_CMD_RECEIVE_OUTSTANDING     0x1b
#define NBF_CMD_RECEIVE_CONTINUE        0x1c
#define NBF_CMD_SESSION_ALIVE           0x1f

//
// NBF Transport Layer Header.
//

typedef struct _NBF_HDR_GENERIC {
    USHORT Length;              // Length of this header in bytes.
    UCHAR Signature [2];        // always {0xef, 0xff} for NBF.
    UCHAR Command;              // command code, NBF_CMD_xxx.
    UCHAR Data1;                // optional parameter.
    USHORT Data2;               // optional parameter.
    USHORT TransmitCorrelator;  // transmit correlator parameter.
    USHORT ResponseCorrelator;  // response correlator parameter.
} NBF_HDR_GENERIC;
typedef NBF_HDR_GENERIC UNALIGNED *PNBF_HDR_GENERIC;

typedef struct _NBF_HDR_CONNECTION {
    USHORT Length;              // length of the header in bytes (14).
    USHORT Signature;           // always {0xef, 0xff} for NBF.
    UCHAR Command;              // command code, NBF_CMD_xxx.
    UCHAR Data1;                // optional parameter.
    UCHAR Data2Low, Data2High;  // Intel-formatted DW parameter.
    USHORT TransmitCorrelator;  // Intel-formatted DW param. (transmit correlator).
    USHORT ResponseCorrelator;  // Intel-formatted DW param. (response correlator).
    UCHAR DestinationSessionNumber; // connection identifier of packet receiver.
    UCHAR SourceSessionNumber;      // connection identifier of packet sender.
} NBF_HDR_CONNECTION;
typedef NBF_HDR_CONNECTION UNALIGNED *PNBF_HDR_CONNECTION;

typedef struct _NBF_HDR_CONNECTIONLESS {
    USHORT Length;              // length of the header in bytes (44).
    USHORT Signature;           // always {0xef, 0xff} for NBF.
    UCHAR Command;              // command code, NBF_CMD_xxx.
    UCHAR Data1;                // optional parameter.
    UCHAR Data2Low, Data2High;  // Intel-formatted DW parameter.
    USHORT TransmitCorrelator;  // Intel-formatted DW param. (transmit correlator).
    USHORT ResponseCorrelator;  // Intel-formatted DW param. (response correlator).
    UCHAR DestinationName [NETBIOS_NAME_LENGTH]; // name of packet receiver.
    UCHAR SourceName [NETBIOS_NAME_LENGTH];      // name of packet sender.
} NBF_HDR_CONNECTIONLESS;
typedef NBF_HDR_CONNECTIONLESS UNALIGNED *PNBF_HDR_CONNECTIONLESS;

//
// These macros are used to retrieve the transmit and response
// correlators from an NBF_HDR_CONNECTION(LESS). The first two
// are general, the second two are used when the correlators
// are known to be WORD aligned.
//

#define TRANSMIT_CORR_A(_Hdr)    ((_Hdr)->TransmitCorrelator)
#define RESPONSE_CORR_A(_Hdr)    ((_Hdr)->ResponseCorrelator)

#ifdef _IA64_

//
// BUGBUG This is a workaround for a bug in the IA64 compiler version
// 13.00.8837 (bug #utc_p7#15002: FE bug).  When it is fixed, remove
// this new version of the macros in favor of the original version,
// below.
//

__inline
USHORT UNALIGNED *
TempUShortCast(
    IN USHORT UNALIGNED *p
    )
{
    return p;
}

#define TRANSMIT_CORR(_Hdr)      (*TempUShortCast( &(_Hdr)->TransmitCorrelator ))
#define RESPONSE_CORR(_Hdr)      (*TempUShortCast( &(_Hdr)->ResponseCorrelator ))

#define HEADER_LENGTH(_Hdr)      (*TempUShortCast( &(_Hdr)->Length ))
#define HEADER_SIGNATURE(_Hdr)   (*TempUShortCast( &(_Hdr)->Signature ))

#else

#define TRANSMIT_CORR(_Hdr)      (*(USHORT UNALIGNED *)(&(_Hdr)->TransmitCorrelator))
#define RESPONSE_CORR(_Hdr)      (*(USHORT UNALIGNED *)(&(_Hdr)->ResponseCorrelator))

#define HEADER_LENGTH(_Hdr)      (*(USHORT UNALIGNED *)(&(_Hdr)->Length))
#define HEADER_SIGNATURE(_Hdr)   (*(USHORT UNALIGNED *)(&(_Hdr)->Signature))

#endif

#define HEADER_LENGTH_A(_Hdr)    ((_Hdr)->Length)
#define HEADER_SIGNATURE_A(_Hdr) ((_Hdr)->Signature)

typedef union _NBF_HDR {
    NBF_HDR_GENERIC         Generic;
    NBF_HDR_CONNECTION      ConnectionOrientedFrame;
    NBF_HDR_CONNECTIONLESS  ConnectionlessFrame;
} NBF_HDR;
typedef NBF_HDR UNALIGNED *PNBF_HDR;

//
// The following structures define I-frame, U-frame, and S-frame DLC headers.
//

#define DLC_SSAP_RESPONSE       0x0001  // if (ssap & DLC_SSAP_RESP), it's a response.
#define DLC_SSAP_GLOBAL         0x00ff  // the global SAP.
#define DLC_SSAP_NULL           0x0000  // the null SAP.
#define DLC_SSAP_MASK           0x00fe  // mask to wipe out the response bit.
#define DLC_DSAP_MASK           0x00fe  // mask to wipe out the group SAP bit.

#define DLC_CMD_RR      0x01            // command code for RR.
#define DLC_CMD_RNR     0x05            // command code for RNR.
#define DLC_CMD_REJ     0x09            // command code for REJ.

#define DLC_CMD_SABME   0x6f            // command code for SABME.
#define DLC_CMD_DISC    0x43            // command code for DISC.
#define DLC_CMD_UA      0x63            // command code for UA.
#define DLC_CMD_DM      0x0f            // command code for DM.
#define DLC_CMD_FRMR    0x87            // command code for FRMR.
#define DLC_CMD_UI      0x03            // command code for UI.
#define DLC_CMD_XID     0xaf            // command code for XID.
#define DLC_CMD_TEST    0xe3            // command code for TEST.

typedef struct _DLC_XID_INFORMATION {
    UCHAR FormatId;                     // format of this XID frame.
    UCHAR Info1;                        // first information byte.
    UCHAR Info2;                        // second information byte.
} DLC_XID_INFORMATION;
typedef DLC_XID_INFORMATION UNALIGNED *PDLC_XID_INFORMATION;

typedef struct _DLC_TEST_INFORMATION {
    UCHAR Buffer [10];                  // this buffer is actually arbitrarily large.
} DLC_TEST_INFORMATION;
typedef DLC_TEST_INFORMATION UNALIGNED *PDLC_TEST_INFORMATION;

typedef struct _DLC_FRMR_INFORMATION {
    UCHAR Command;              // format: mmmpmm11, m=modifiers, p=poll/final.
    UCHAR Ctrl;                 // control field of rejected frame.
    UCHAR Vs;                   // our next send when error was detected.
    UCHAR Vr;                   // our next receive when error was detected.
    UCHAR Reason;               // reason for sending FRMR: 000VZYXW.
} DLC_FRMR_INFORMATION;
typedef DLC_FRMR_INFORMATION UNALIGNED *PDLC_FRMR_INFORMATION;

typedef struct _DLC_U_FRAME {
    UCHAR Dsap;                         // Destination Service Access Point.
    UCHAR Ssap;                         // Source Service Access Point.
    UCHAR Command;                      // command code.
    union {                             // information field for FRMR, TEST, XID.
        DLC_XID_INFORMATION XidInfo;    // XID information.
        DLC_TEST_INFORMATION TestInfo;  // TEST information.
        DLC_FRMR_INFORMATION FrmrInfo;  // FRMR information.
        NBF_HDR_CONNECTIONLESS NbfHeader; // UI frame contains NetBIOS header.
    } Information;
} DLC_U_FRAME;
typedef DLC_U_FRAME UNALIGNED *PDLC_U_FRAME;

#define DLC_U_INDICATOR 0x03    // (cmd & DLC_U_IND) == DLC_U_IND --> U-frame.
#define DLC_U_PF        0x10    // (cmd & DLC_U_PF) -> poll/final set.

typedef struct _DLC_S_FRAME {
    UCHAR Dsap;                         // Destination Service Access Point.
    UCHAR Ssap;                         // Source Service Access Point.
    UCHAR Command;                      // RR, RNR, REJ command code.
    UCHAR RcvSeq;                       // receive seq #, bottom bit is poll/final.
} DLC_S_FRAME;
typedef DLC_S_FRAME UNALIGNED *PDLC_S_FRAME;

#define DLC_S_PF        0x01    // (rcvseq & DLC_S_PF) means poll/final set.

typedef struct _DLC_I_FRAME {
    UCHAR Dsap;                         // Destination Service Access Point.
    UCHAR Ssap;                         // Source Service Access Point.
    UCHAR SendSeq;                      // send sequence number, bottom bit 0.
    UCHAR RcvSeq;                       // rcv sequence number, bottom bit p/f.
} DLC_I_FRAME;
typedef DLC_I_FRAME UNALIGNED *PDLC_I_FRAME;

#define DLC_I_PF        0x01    // (rcvseq & DLC_I_PF) means poll/final set.
#define DLC_I_INDICATOR 0x01    // !(sndseq & DLC_I_INDICATOR) indicates I-frame.

typedef struct _DLC_FRAME {
    UCHAR Dsap;                         // Destination Service Access Point.
    UCHAR Ssap;                         // Source Service Access Point.
    UCHAR Byte1;                        // command byte.
} DLC_FRAME;
typedef DLC_FRAME UNALIGNED *PDLC_FRAME;


//
// This macro builds a DLC UI-frame header.
//

#define NbfBuildUIFrameHeader(_Header)                 \
{                                                   \
    PDLC_FRAME DlcHeader = (PDLC_FRAME)(_Header);   \
    DlcHeader->Dsap = DSAP_NETBIOS_OVER_LLC;        \
    DlcHeader->Ssap = DSAP_NETBIOS_OVER_LLC;        \
    DlcHeader->Byte1 = DLC_CMD_UI;                  \
}


//
// Resume previous structure packing method.
//

#ifdef PACKING

#ifdef __STDC__
#pragma Pop(Align_members)
#else
#pragma pack()
#endif // def __STDC__

#endif // def PACKING

#endif // def _NBFHDRS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ndisprv.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndisprv.h

Abstract:

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __NDISPRV_H
#define __NDISPRV_H

//
//  All mac options require the reserved bit to be set in
//  the miniports mac options.
//
#define NDIS_MAC_OPTION_NDISWAN     0x00000001

//
// if you change the structure below to handle new PnP Ioctls,
// make sure you change the code in NDIS that checks for the
// lenght of the input buffer against the information in this
// structure
//
typedef struct _NDIS_PNP_OPERATION
{
    UINT                Layer;
    UINT                Operation;
    union
    {
        PVOID           ReConfigBufferPtr;
        ULONG_PTR       ReConfigBufferOff;
    };
    UINT                ReConfigBufferSize;
    NDIS_VAR_DATA_DESC  LowerComponent;
    NDIS_VAR_DATA_DESC  UpperComponent;
    NDIS_VAR_DATA_DESC  BindList;
} NDIS_PNP_OPERATION, *PNDIS_PNP_OPERATION;

//
// Used by proxy and RCA
//
#define NDIS_PROTOCOL_TESTER        0x20000000
#define NDIS_PROTOCOL_PROXY         0x40000000
#define NDIS_PROTOCOL_BIND_ALL_CO   0x80000000

#define NDIS_OID_MASK               0xFF000000
#define NDIS_OID_PRIVATE            0x80000000
#define OID_GEN_ELAPSED_TIME        0x00FFFFFF

typedef struct _NDIS_STATS
{
    LARGE_INTEGER   StartTicks;
    ULONG64         DirectedPacketsOut;
    ULONG64         DirectedPacketsIn;
} NDIS_STATS, *PNDIS_STATS;


//
// the name of the Ndis BindUnbind CallBack object
//
#define NDIS_BIND_UNBIND_CALLBACK_NAME L"\\CallBack\\NdisBindUnbind"


#endif // __NDISPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\netwarn.h ===
//
// Disable warnings about "nonstandard extensions" that
// are legal and common in Windows header files.
//
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nic1394.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nic1394.h

Abstract:

    This module defines the structures, macros, and manifests available
    to IEE1394-aware network components.

Revision History:

    09/14/1998 JosephJ  Created.

--*/

#ifndef _NIC1394_H_
#define _NIC1394_H_

// 
// Define USER_MODE in your user-mode app before including this file.
//
#if USER_MODE
typedef USHORT NODE_ADDRESS;
#endif // USER_MODE


///////////////////////////////////////////////////////////////////////////////////
//                          ADDRESS FAMILY VERSION INFORMATION
///////////////////////////////////////////////////////////////////////////////////

//
// The current major and minor version, respectively, of the NIC1394 address family.
//
#define NIC1394_AF_CURRENT_MAJOR_VERSION    5
#define NIC1394_AF_CURRENT_MINOR_VERSION    0

///////////////////////////////////////////////////////////////////////////////////
//                          MEDIA PARAMETERS                                     // 
///////////////////////////////////////////////////////////////////////////////////

//
// 1394 FIFO Address, consisting of the 64-bit UniqueID and the
// 48-bit address offset.
//
typedef struct _NIC1394_FIFO_ADDRESS
{
    UINT64              UniqueID;
    ULONG               Off_Low;
    USHORT              Off_High;

} NIC1394_FIFO_ADDRESS, *PNIC1394_FIFO_ADDRESS;


//  enum to identify which of the two modes of transmission on a 1394 is to be used
//
//

typedef enum _NIC1394_ADDRESS_TYPE
{
    NIC1394AddressType_Channel,       // Indicates this is a channel address
    NIC1394AddressType_FIFO,          // Indicates this is a FIFO address
    NIC1394AddressType_MultiChannel,  // Indicates this is multiple-channel address
    NIC1394AddressType_Ethernet,      // Indicates this is the ethernet emulation VC

} NIC1394_ADDRESS_TYPE, *PNIC1394_ADDRESS_TYPE;



//
// General form of a 1394 destination, which can specify either a 1394 channel or
// a FIFO address. This structure forms part of the 1394 media-specific
// parameters.
//
typedef struct _NIC1394_DESTINATION
{
    union
    {
        UINT                    Channel;     // IEEE1394 channel number.
        NIC1394_FIFO_ADDRESS    FifoAddress; // IEEE1394 NodeID and address offset.
        ULARGE_INTEGER          ChannnelMap; // Identifies multiple channels.
    };


    NIC1394_ADDRESS_TYPE        AddressType; // Address- asynch or isoch  

} NIC1394_DESTINATION, *PNIC1394_DESTINATION;

//
// Special channels  values
//
#define NIC1394_ANY_CHANNEL         ((UINT)-1) // miniport should pick channel.
#define NIC1394_BROADCAST_CHANNEL   ((UINT)-2) // special broadcast channel.

//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains IEEE1394 media specific values in the
// structure NIC1394_MEDIA_PARAMETERS.
//
#define NIC1394_MEDIA_SPECIFIC      0x13940000


//
// NOTES:
// The CO_MEDIA_PARAMETERS.Flags field for FIFO vcs must specify either TRANSMIT_VC
// or RECEIVE_VC, not both. If RECEIVE_VC is specified for a FIFO vc, this vc is
// used to receive on a local FIFO. In this case, the  Destination.RecvFIFO field
// must be set to all-0s when creating the vc. On activation of the vc,
// this field of the updated media parameters will contain the local nodes unique ID
// and the allocated FIFO address.
// 
// Multi-channel VC MUST specify RECEIVE_VC and not TRANSMIT_VC.
// Only one multi-channel VC is supported per adapter.
// 
//
// Ethernet VC MUST specify BOTH RECEIVE_VC and TRANSMIT_VC.
// Only one Ethernet VC is supported per adapter.
//

//
// Notes on the Ethernet VC.
// Packets sent and received on this VC are ethernet-style (802.3) packets.
// The nic indicates packets it gets on it's connectionless SEND handler up
// on this VC. The nic indicates packets SENT on this VC up on it's connectionless
// receive handler.
//

// 
// 1394 Specific Media parameters - this is the Media specific structure for 1394
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _NIC1394_MEDIA_PARAMETERS
{
    //
    // Identifies destination type (channel or FIFO) and type-specific address.
    //
    NIC1394_DESTINATION     Destination;

    //
    // Bitmap encoding characteristics of the vc. One or  more NIC1394_VCFLAG_*
    // values.
    //
    ULONG                   Flags;          

    //
    // Maximum size, in bytes, of blocks to be sent on this vc. Must be set to 0
    // if this is a recv-only VCs. The miniport will choose a block size that is a
    // minimum of this value and the value dictated by the bus speed map.
    // Special value (ULONG -1) indicates "maximum possible block size."
    UINT                    MaxSendBlockSize;

    //
    // One of the SCODE_* constants defined in 1394.h. Indicates
    // the maximum speed to be used for blocks sent on this vc. Must be set to 0
    // if this is a recv-only VC. The miniport will choose a speed that is a minimum
    // of this value and the value dicated by the bus speed map.
    // Special value (ULONG -1) indicates "maximum possible speed."
    //
    // TODO: change to ... MaxSendSpeedCode;
    //
    UINT                    MaxSendSpeed;

    //
    // Size, in bytes, of the largest packet that will be sent or received on
    // this VC. The miniport may use this information to set up internal buffers
    // for link-layer fragmentation and reassembly. The miniport will
    // fail attempts to send packets and will discard received packets if the
    // size of these packets is larger than the MTU.
    //
    UINT                    MTU;
    //
    // Amount of bandwidth to reserve, in units of bytes per isochronous frame.
    // Applies only for isochronous transmission, and must be set to 0 for
    // asynchronous transmission (i.e., if the NIC1394_VCFLAG_ISOCHRONOUS bit is 0).
    //
    UINT                    Bandwidth;  

    //
    // One or more NIC1394_FRAMETYPE_* values. The miniport will attempt to send up
    // only pkts with these protocols. However it may send other pkts.
    // The client should be able to deal with this. Must be set to 0 if
    // no framing is used (i.e., if the NIC1394_VCFLAG_FRAMED bit is 0).
    //
    ULONG                   RecvFrameTypes;

} NIC1394_MEDIA_PARAMETERS, *PNIC1394_MEDIA_PARAMETERS;


//
// NIC1394_MEDIA_PARAMETERS.Flags bitfield values
//

//
// Indicates VC will be used for isochronous transmission.
//
#define NIC1394_VCFLAG_ISOCHRONOUS      (0x1 << 1)

//
// Indicates that the vc is used for framed data. If set, the miniport will
// implement link-level fragmentation and reassembly. If clear, the miniport
// will treat data sent and received on this vc as raw data.
//
#define NIC1394_VCFLAG_FRAMED           (0x1 << 2)

//
// Indicates the miniport should allocate the necessary bus resources.
// Currently this only applies for non-broadcast channels, in which case
// the bus resources consist of the network channel number and (for isochronous
// vc's) the bandwidth specified in Bandwidth field.
// This bit does not apply (and should be 0) when creating the broadcast channel
// and either transmit or receive FIFO vcs.
//
#define NIC1394_VCFLAG_ALLOCATE         (0x1 << 3)

//
// End of NIC1394_MEDIA_PARAMETERS.Flags bitfield values.
//

//
// NIC1394_MEDIA_PARAMETERS.FrameType bitfield values
//
#define NIC1394_FRAMETYPE_ARP       (0x1<<0) // Ethertype 0x806
#define NIC1394_FRAMETYPE_IPV4      (0x1<<1) // Ethertype 0x800
#define NIC1394_FRAMETYPE_IPV4MCAP  (0x1<<2) // Ethertype 0x8861



///////////////////////////////////////////////////////////////////////////////////
//                          INFORMATIONAL OIDs                                   // 
///////////////////////////////////////////////////////////////////////////////////

//
// the structure for returning basic information about the miniport
// returned in response to OID_NIC1394_LOCAL_NODE_INFO. Associated with
// the address family handle.
//
typedef struct _NIC1394_LOCAL_NODE_INFO
{
    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
    ULONG                   BusGeneration;      // 1394 Bus generation ID.
    NODE_ADDRESS            NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRecvBlockSize;   // Maximum size, in bytes, of blocks
                                                // that can be read.
    UINT                    MaxRecvSpeed;       // Max speed which can be accepted
                                                // -- minimum
                                                // of the max local link speed and
                                                // the max local PHY speed.
                                                // UNITS: SCODE_XXX_RATE

} NIC1394_LOCAL_NODE_INFO, *PNIC1394_LOCAL_NODE_INFO;


//
// The structure for returning basic information about the specified vc
// returned in response to OID_NIC1394_VC_INFO. Associated with
// a vc handle
//
typedef struct _NIC1394_VC_INFO
{
    //
    // Channel or (unique-ID,offset). In the case of a recv (local) FIFO vc,
    // this will be set to the local node's unique ID and address offset.
    //
    NIC1394_DESTINATION Destination;

} NIC1394_VC_INFO, *PNIC1394_VC_INFO;

//
// The structure for dynamically changing channel characteristics.
//
typedef struct  _NIC1394_CHANNEL_CHARACTERISTICS
{
    ULARGE_INTEGER  ChannelMap; // Must be zero unless specifying a Multi-channel VC.
    ULONG   Speed;      // Same units as NIC1394_MEDIA_PARAMETERS.MaxSendSpeed.
                        // Special value -1 means "no change in speed."

} NIC1394_CHANNEL_CHARACTERISTICS, *PNIC1394_CHANNEL_CHARACTERISTICS;



///////////////////////////////////////////////////////////////////////////////////
//                          INDICATIONS                                          // 
///////////////////////////////////////////////////////////////////////////////////
// Bus Reset
// Params: NIC1394_LOCAL_NODE_INFO

///////////////////////////////////////////////////////////////////////////////////
//                          PACKET FORMATS                                       // 
///////////////////////////////////////////////////////////////////////////////////


//
// GASP Header, which prefixes all ip/1394 pkts sent over channels.
// TODO: move this withing NIC1394, because it is not exposed to protocols.
//
typedef struct _NIC1394_GASP_HEADER
{
    USHORT  source_ID;
    USHORT  specifier_ID_hi;
    UCHAR   specifier_ID_lo;
    UCHAR   version[3];

}  NIC1394_GASP_HEADER;

//
// Unfragmented encapsulation header.
//
typedef struct _NIC1394_ENCAPSULATION_HEADER
{
    // Set to the 16-bit Node ID of the sending node, in machine-byte order.
    // Set to zero if the Node ID of the sender is not known.
    // 
    //
    USHORT NodeId;

    // The EtherType field is set to the byte-swapped version of one of the
    // constants defined immediately below. 
    //
    USHORT EtherType;

    // Ethertypes in machine byte order. These values need to be byteswapped
    // before they are sent on the wire.
    //
    #define NIC1394_ETHERTYPE_IP    0x800
    #define NIC1394_ETHERTYPE_ARP   0x806
    #define NIC1394_ETHERTYPE_MCAP  0x8861

} NIC1394_ENCAPSULATION_HEADER, *PNIC1394_ENCAPSULATION_HEADER;

//
// TODO: get rid of NIC1394_ENCAPSULATION_HEADER
//
typedef
NIC1394_ENCAPSULATION_HEADER
NIC1394_UNFRAGMENTED_HEADER, *PNIC1394_UNFRAGMENTED_HEADER;


//
//          FRAGMENTED PACKET FORMATS
//
//      TODO: move these to inside NIC1394, because they are only
//      used within NIC1394.
//

//
// Fragmented Encapsulation header: first fragment
//
typedef struct _NIC1394_FIRST_FRAGMENT_HEADER
{
    // Contains the 2-bit "lf" field and the 12-bit "buffer_size" field.
    // Use the macros immediately below to extract the above fields from
    // the lfbufsz. This field needs to be byteswapped before it is sent out
    // on the wire.
    //
    USHORT  lfbufsz;

    #define NIC1394_LF_FROM_LFBUFSZ(_lfbufsz) \
                            ((_lfbufz) >> 14)

    #define NIC1394_BUFFER_SIZE_FROM_LFBUFSZ(_lfbufsz) \
                            ((_lfbufz) & 0xfff)

    #define NIC1394_MAX_FRAGMENT_BUFFER_SIZE    0xfff

    //
    // specifies what the packet is - an IPV4, ARP, or MCAP packet
    //
    USHORT EtherType;


    // Opaque datagram label. There is no need to byteswap this field before it
    // is sent out on the wire.
    //
    USHORT dgl;

    // Must be set to 0
    //
    USHORT reserved;

}  NIC1394_FIRST_FRAGMENT_HEADER, *PNIC1394_FIRST_FRAGMENT_HEADER;

//
// Fragmented Encapsulation header: second and subsequent fragments
//
typedef struct _NIC1394_FRAGMENT_HEADER
{
#if OBSOLETE
    ULONG lf:2;                         // Bits 0-1
    ULONG rsv0:2;                       // Bits 2-3
    ULONG buffer_size:12;               // Bits 4-15

    ULONG rsv1:4;                       // Bits 16-19
    ULONG fragment_offset:12;           // Bits 20-31

    ULONG dgl:16;                       // Bits 0-15

    ULONG reserved:16;                  // Bits 16-32 
#endif // OBSOLETE

    // Contains the 2-bit "lf" field and the 12-bit "buffer_size" field.
    // The format is the same as NIC1394_FIRST_FRAGMENT_HEADER.lfbufsz.
    //
    USHORT  lfbufsz;

    // Opaque datagram label. There is no need to byteswap this field before it
    // is setn out on the wire.
    //
    USHORT dgl;

    // Fragment offset. Must be less than or equal to NIC1394_MAX_FRAGMENT_OFFSET.
    // This field needs to be byteswapped before it is sent out on the wire.
    //
    USHORT fragment_offset;

    #define NIC1394_MAX_FRAGMENT_OFFSET 0xfff

}  NIC1394_FRAGMENT_HEADER, *PNIC1394_FRAGMENT_HEADER;


// NIC1394_PACKET_STATS maintains information about either send or receive
// packet transmission.
//
typedef struct
{
    UINT    TotNdisPackets;     // Total number of NDIS packets sent/indicated
    UINT    NdisPacketsFailures;// Number of NDIS packets failed/discarded
    UINT    TotBusPackets;      // Total number of BUS-level reads/writes
    UINT    BusPacketFailures;  // Number of BUS-level failures(sends)/discards(recv)

} NIC1394_PACKET_STATS;

// Types of structres used in OID OID_1394_NICINFO
//
typedef enum
{
    NIC1394_NICINFO_OP_BUSINFO,
    NIC1394_NICINFO_OP_REMOTENODEINFO,
    NIC1394_NICINFO_OP_CHANNELINFO,
    NIC1394_NICINFO_OP_RESETSTATS,

} NIC1394_NICINFO_OP;

#define NIC1394_NICINFO_VERSION         2
#define NIC1394_MAX_NICINFO_NODES       64
#define NIC1394_MAX_NICINFO_CHANNELS    64

// 
// The buffer used in OID OID_1394_NICINFO has the following common header.
//
typedef struct
{
    UINT                Version;            //  Set to NIC1394_NICINFO_VERSION
    NIC1394_NICINFO_OP  Op;                 //  One of NIC1394_NICINFO_OP_*

} NIC1394_NICINFO_HEADER, *PNIC1394_NICINFO_HEADER;


// NIC1394_BUSINFO is the structure corresponding to  NIC1394_NICINFO_OP_BUSINFO.
// It provides a summary of bus-wide information.
//
typedef struct
{
    NIC1394_NICINFO_HEADER Hdr; // Hdr.Op == *OP_BUSINFO

    //
    //  General information
    //
    UINT                    NumBusResets;
    UINT                    SecondsSinceBusReset;
    UINT                    NumOutstandingIrps;

    UINT                    Flags;          // One or more NIC1394_BUSINFO_*

    #define NIC1394_BUSINFO_LOCAL_IS_IRM    0x1 // Local node is the IRM

    // Local node caps
    //
    NIC1394_LOCAL_NODE_INFO LocalNodeInfo;

    //
    // CHANNEL RELATED INFORMATION
    //
    struct
    {

        // The bus channel map register
        //
        UINT64  BusMap;     // LSB bit == channel 0
    
        //  Bitmap of locally active channels.
        //  More information about each of these channels may be queried
        //  using NIC1394_NICINFO_OP_CHANNELINFO.
        //
        UINT64  ActiveChannelMap;
    
        // BROADCAST CHANNEL
        //
        UINT                    Bcr;    // Broadcast channels register.
        NIC1394_PACKET_STATS    BcSendPktStats; // Send stats
        NIC1394_PACKET_STATS    BcRecvPktStats; // Recv stats
    
        // Aggregated Channel stats
        //
        NIC1394_PACKET_STATS SendPktStats;  // Send stats
        NIC1394_PACKET_STATS RecvPktStats;  // Recv stats

    } Channel;

    //
    // FIFO RELATED INFORMATION.
    //
    struct
    {
        // Address offset of the receive fifo.
        //
        ULONG               Recv_Off_Low;
        USHORT              Recv_Off_High;

        // Aggregated stats across all fifos
        //
        NIC1394_PACKET_STATS RecvPktStats;
        NIC1394_PACKET_STATS SendPktStats;

        //  Current number and min number of available (free) receive buffers.
        //
        UINT                 NumFreeRecvBuffers;
        UINT                 MinFreeRecvBuffers;

        //  Number of outstanding reassemblies (receive side)
        //
        UINT                 NumOutstandingReassemblies;
        UINT                 MaxOutstandingReassemblies;
        UINT                 NumAbortedReassemblies;
        
    } Fifo;

    struct
    {
        //
        // To display private information, place format strings in FormatA and
        // Format B. The display program will do the following:
        // if (FormatA[0]) printf(FormatA, A0, A1, A2, A3);
        // if (FormatB[0]) printf(FormatB, B0, B1, B2, B3);
        //

        #define NIC1394_MAX_PRIVATE_FORMAT_SIZE 80
        char FormatA[NIC1394_MAX_PRIVATE_FORMAT_SIZE+1];
        char FormatB[NIC1394_MAX_PRIVATE_FORMAT_SIZE+1];
        UINT A0;
        UINT A1;
        UINT A2;
        UINT A3;
        UINT B0;
        UINT B1;
        UINT B2;
        UINT B3;

    } Private;

    //
    // Information about remote nodes. More information about each of these nodes
    // may be queried using *OP_REMOTE_NODEINFO
    //
    UINT                    NumRemoteNodes;
    UINT64                  RemoteNodeUniqueIDS[NIC1394_MAX_NICINFO_NODES];
    
} NIC1394_BUSINFO, *PNIC1394_BUSINFO;


//
// NIC1394_REMOTENODEINFO is structure corresponding to 
// NIC1394_NICINFO_OP_REMOTENODEINFO.
// The structure contains basic information about a specific remote node.
//
typedef struct
{
    NIC1394_NICINFO_HEADER Hdr; // Hdr.Op == *OP_REMOTENODEINFO

    UINT64                  UniqueID;           // This node's 64-bit Unique ID.
                                                // THIS IS AN IN PARAM


    USHORT                  NodeAddress;        // Local nodeID for the current bus
                                                // generation.
    USHORT                  Reserved;           // Padding.
    UINT                    MaxRec;             // Remote node's MaxRec value.
    UINT                    EffectiveMaxBlockSize;// Max block size, in bytes,
                                                // used when writing to this node.
                                                // It is based on the minimum
                                                // of the max speed between devices
                                                // and the local and remote maxrecs.
    UINT                    MaxSpeedBetweenNodes;// Max speed which can be accepted
                                                // in units of SCODE_XXX_RATE.

    UINT                    Flags;  // One or more  NIC1394_REMOTEINFO* consts
    #define NIC1394_REMOTEINFO_ACTIVE       (0x1<<0)
    #define NIC1394_REMOTEINFO_LOADING      (0x1<<1)
    #define NIC1394_REMOTEINFO_UNLOADING    (0x1<<2)

    NIC1394_PACKET_STATS SendFifoPktStats;  // Fifo Sends to this node
    NIC1394_PACKET_STATS RecvFifoPktStats;  // Fifo Recvs from this node
    NIC1394_PACKET_STATS RecvChannelPktStats;// Channel receives from this node

} NIC1394_REMOTENODEINFO, *PNIC1394_REMOTENODEINFO;


// NIC1394_CHANNELINFO is structure corresponding to 
// NIC1394_NICINFO_OP_CHANNELINFO.
// The structure contains basic information about a specific channel.
//
typedef struct
{

    NIC1394_NICINFO_HEADER Hdr; // Hdr.Op == *OP_CHANNELINFO

    UINT    Channel;        // Channel number (IN PARAM)
    UINT    SendAge;        // Age in seconds since it's been activated for sends.
    UINT    RecvAge;        // Age in seconds since it's been activated for recvs.
    UINT    Flags;          // One or more NIC1394_CHANNELINFO_* defines below

    #define NIC1394_CHANNELINFO_RECEIVE_ENABLED 0x1 // Enabled for receive
    #define NIC1394_CHANNELINFO_SEND_ENABLED    0x2 // Enabled for send
    #define NIC1394_CHANNELINFO_OWNER           0x4 // This node is the owner


    NIC1394_PACKET_STATS SendPktStats;  // Send stats
    NIC1394_PACKET_STATS RecvPktStats;  // Recv stats

} NIC1394_CHANNELINFO, *PNIC1394_CHANNELINFO;

// NIC1394_RESETSTATS is structure corresponding to 
// NIC1394_NICINFO_OP_RESETSTATS.
// The structure doesn't contain anything useful -- this OP is used to
// reset NIC statistics.
//
typedef struct
{
    NIC1394_NICINFO_HEADER Hdr; // Hdr.Op == *OP_RESETSTATS

} NIC1394_RESETSTATS, *PNIC1394_RESETSTATS;


//
// NIC1394_NICINFO is a union of all the structures that are used with
// OID_1394_NICINFO.
//
typedef union
{
    NIC1394_NICINFO_HEADER  Hdr;
    NIC1394_BUSINFO         BusInfo;
    NIC1394_REMOTENODEINFO  RemoteNodeInfo;
    NIC1394_CHANNELINFO     ChannelInfo;
    NIC1394_RESETSTATS      ResetStats;
    
} NIC1394_NICINFO, *PNIC1394_NICINFO;


// Issues a 1394 bus reset. Used to test the BCM algorithm
#define OID_1394_ISSUE_BUS_RESET                    0xFF00C910

// UnUsed - could be used to change channel characteristics
#define OID_1394_CHANGE_CHANNEL_CHARACTERISTICS     0xFF00C911

// used to query statistics and other information from the nic
#define OID_1394_NICINFO                            0xFF00C912

// Used by arp1394 to ask the nic if it knows of any ip1394 nodes on the net
#define OID_1394_IP1394_CONNECT_STATUS              0xFF00C913

//Used by the bridge to state that the bridge has opened an adapter 
#define OID_1394_ENTER_BRIDGE_MODE                  0xFF00C914

// Used by the bridge to state that the bridge is closing an adapter 
#define OID_1394_EXIT_BRIDGE_MODE                   0xFF00C915

// Used by arp1394 to query the Euid, Source, Mac Map - used in the bridge
#define OID_1394_QUERY_EUID_NODE_MAP					0xFF00C916

typedef enum
{
    NIC1394_EVENT_BUS_RESET
    
} NIC1394_EVENT_CODE;



//
// This is a struct the miniport uses to indicate an event to the protocols (Arp1394)
// It is used to 
//   1. Tell the Arp module that the bus has been reset 
//          and informs it of the new local node address.
//
typedef struct _NIC1394_STATUS_BUFFER
{
    UINT Signature; // == NIC1394_MEDIA_SPECIFIC        

    NIC1394_EVENT_CODE Event;   


    union
    {
        struct 
        {
            NODE_ADDRESS LocalNode;
            
            UINT ulGeneration;
            
        }BusReset;

    };

} NIC1394_STATUS_BUFFER, *PNIC1394_STATUS_BUFFER;



#endif  //   _NIC1394_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nls.h ===
#pragma once

// Set this from your DLL_PROCESS_ATTACH if your linking to nls.lib
// from a DLL.  It defines the message source module to pull the .mc
// messages from.  EXEs do not need to do this as the default value of
// NULL will work as long as the .mc file is linked into the executable.
//
extern HMODULE NlsMsgSourcemModuleHandle;

// NlsPutMsg Handle parameter values
//
#define STDOUT 1
#define STDERR 2

#ifdef __cplusplus
extern "C" {
#endif

UINT 
NlsPutMsg (
    IN UINT Handle, 
    IN UINT MsgNumber, 
    IN ...);
    
VOID 
NlsPerror (
    IN UINT MsgNumber, 
    IN INT ErrorNumber);

UINT 
NlsSPrintf ( 
    IN UINT usMsgNum,
    OUT char* pszBuffer,
    IN DWORD cbSize,
    IN ...);
    
VOID 
ConvertArgvToOem (
    IN int argc, 
    IN char* argv[]);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ndpif.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    ndpif.h

Abstract:

    Shared header file between ndptsp.tsp and ndproxy.sys


Author:

    Tony Bell


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/03/99        Created

--*/

#ifndef _NDPIF__H
#define _NDPIF__H


#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4
#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4

//
//
// Stuff from intrfce.h (ndistapi)
// This belongs in a public (shared by ndptsp and ndproxy) header file
//
//
//

#define NDISTAPIERR_UNINITIALIZED   0x00001001
#define NDISTAPIERR_BADDEVICEID     0x00001002
#define NDISTAPIERR_DEVICEOFFLINE   0x00001003

#define UNSPECIFIED_FLOWSPEC_VALUE  0xFFFFFFFF


//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_NDISTAPI  0x00008fff



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define NDISTAPI_IOCTL_INDEX  0x8f0



//
// The NDISTAPI device driver IOCTLs
//

#define IOCTL_NDISTAPI_CONNECT           CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX,     \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_DISCONNECT        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 1, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_QUERY_INFO        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 2, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_SET_INFO          CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 3, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_GET_LINE_EVENTS      CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 4, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_SET_DEVICEID_BASE    CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 5, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_CREATE               CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 6, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

//
// Type definitions
//
typedef struct _NDISTAPI_REQUEST {
    //
    // Linkage used to thread up pended
    // requests on the Vc's request queue
    // Only used in ndproxy!
    //
    LIST_ENTRY  Linkage;

    //
    // Irp this request came in
    // Only used in ndproxy!
    //
    PVOID    Irp;

    //
    // Return value
    //
    ULONG   ulUniqueRequestId;

    //
    // Return value
    //
    ULONG   ulReturnValue;

    //
    // Operation idenfifier
    //
    ULONG   Oid;

    //
    // Target line device ID
    //
    ULONG   ulDeviceID;

    //
    // Total size of request data in buffer
    //
    ULONG   ulDataSize;

    //
    // Buffer for request data, must be pointer aligned.
    //

    union {
        UCHAR   Data[1];
        PVOID   Alignment;
    };

} NDISTAPI_REQUEST, *PNDISTAPI_REQUEST;

//
// Returns info to ndptsp in the LINE_OPEN OID
//
typedef struct _NDISTAPI_OPENDATA {

    //
    // GUID of the adapter that owns this line
    //
    OUT     GUID    Guid;

    //
    // Media type of the adapter that owns this line
    //
    OUT     NDIS_WAN_MEDIUM_SUBTYPE MediaType;

} NDISTAPI_OPENDATA, *PNDISTAPI_OPENDATA;

typedef struct _NDISTAPI_EVENT_DATA {
    //
    // Total size of the event data buffer
    //

    IN      ULONG   ulTotalSize;

    //
    // Size of the returned event data
    //

    OUT     ULONG   ulUsedSize;

    //
    // Event data buffer
    //

    OUT     UCHAR   Data[1];

} NDISTAPI_EVENT_DATA, *PNDISTAPI_EVENT_DATA;

//
// Info for a LINE_CREATE
//
typedef struct _NDISTAPI_CREATE_INFO {

    //
    // Given by NdisTapi in LINE_CREATE indication
    //
    IN  ULONG   TempID;

    //
    // The ID for this device
    //
    IN  ULONG   DeviceID;

} NDISTAPI_CREATE_INFO, *PNDISTAPI_CREATE_INFO;

//
//
// End of stuff form intrface.h (ndistapi)
//
//
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nlasvc.h ===
#pragma once

// Filename    : nlasvc.h
// Description : Structures necessary to connect to and communicate with the
//               Network Location Awareness (NLA) system service via LPC.
// Author      : Jeffrey C. Venable, Sr. (jeffv@microsoft.com)
// Revision    : 14 June 2000

//
// Type thunks for 32 bit clients on 64 bit machines.
//


#include <iptypes.h>


#if defined(USE_LPC6432)

#define NLA_HWND              ULONGLONG
#define NLA_PVOID             ULONGLONG
#define NLA_WPARAM            ULONGLONG
#define NLA_HANDLE            ULONGLONG
#define NLA_ULONG_PTR         ULONGLONG
#define NLA_HKEY              ULONGLONG
#define NLA_PIO_STATUS_BLOCK  ULONGLONG
#define NLA_PPS_APC_ROUTINE   ULONGLONG

#else

#define NLA_HWND              HWND
#define NLA_PVOID             PVOID
#define NLA_WPARAM            WPARAM
#define NLA_HANDLE            HANDLE
#define NLA_ULONG_PTR         ULONG_PTR
#define NLA_HKEY              HKEY
#define NLA_PIO_STATUS_BLOCK  PIO_STATUS_BLOCK
#define NLA_PPS_APC_ROUTINE   PPS_APC_ROUTINE

#endif // defined(USE_LPC6432)


typedef struct _LOCATION_802_1X {
    CHAR  adapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    WCHAR information[2048];
} LOCATION_802_1X, *PLOCATION_802_1X;

typedef struct _WSM_NOTIFY {
    ULONG serialNumber;
    WSACOMPLETIONTYPE Type;
    union {
        NLA_HANDLE      hThread;
        NLA_HANDLE      hEvent;
        NLA_HWND        hWnd;
    };
    union {
        NLA_ULONG_PTR   Key;
        UINT            uMsg;
        NLA_PVOID       ApcRoutine;
    };
    union {
        NLA_PPS_APC_ROUTINE ApcCompletion;
        NLA_HANDLE      hPort;
        NLA_WPARAM      context;
    };
    NLA_PIO_STATUS_BLOCK pIoStatusBlock;
    NLA_HKEY userNetworks;
    FILETIME lastModification;
    NLA_PVOID query;
} WSM_NOTIFY, *PWSM_NOTIFY;

typedef enum _WSM_LPC_REQUEST_TYPE {
    
    // Requests:
    REQUEST_DATA_MAPPING_HANDLE                   = 0x00000001,
    REQUEST_DATA_MAPPING_HANDLE_SLOW              = 0x00000002,
    REQUEST_DATA_MAPPING_HANDLE_SLOW_WITH_UPDATE  = 0x00000003,
    REQUEST_CHANGE_NOTIFICATION                   = 0x00000004,
    REQUEST_CHANGE_NOTIFICATION_SLOW              = 0x00000005,
    REQUEST_CANCEL_CHANGE_NOTIFICATION            = 0x00000006,

    // Notifies:
    DHCP_NOTIFY_CHANGE                            = 0x00000010,

    // Asynchronous information:
    LOCATION_802_1X_REGISTER                      = 0x00000020,
    LOCATION_802_1X_DELETE                        = 0x00000021,

} WSM_LPC_REQUEST_TYPE, *PWSM_LPC_REQUEST_TYPE, FAR * LPWSM_LPC_REQUEST_TYPE;

typedef struct _WSM_LPC_CONNECT {
    struct {
        USHORT major;
        USHORT minor;
    } version;
#if defined(_WIN64) || defined (USE_LPC6432)
    BOOLEAN client32;
#endif
} WSM_LPC_CONNECT, *PWSM_LPC_CONNECT;

typedef struct _WSM_LPC_REQUEST {
    WSM_LPC_REQUEST_TYPE type;
    union {
        WSM_NOTIFY notification;
    };
} WSM_LPC_REQUEST, *PWSM_LPC_REQUEST;

typedef struct _WSM_LPC_REPLY {
    union {
        NLA_HANDLE hNetworkHeader; // returned on connection reply
        NLA_HANDLE hNetworkData;   // returned on REQUEST_DATA_MAPPING_HANDLE
    };
    NTSTATUS status;           // always returned to indicate success/failure
} WSM_LPC_REPLY, *PWSM_LPC_REPLY;

typedef struct _WSM_LPC_DATA {
    ULONG signature;
    union {
        WSM_LPC_CONNECT connect;
        WSM_LPC_REQUEST request;
        WSM_LPC_REPLY reply;
    };
} WSM_LPC_DATA, * PWSM_LPC_DATA;

typedef struct _WSM_LPC_MESSAGE {
    PORT_MESSAGE portMsg;
    WSM_LPC_DATA data;
} WSM_LPC_MESSAGE, *PWSM_LPC_MESSAGE;

#define WSM_SIGNATURE          'bMsW'

#define WSM_VERSION_MAJOR      1
#define WSM_VERSION_MINOR      0
#define WSM_PORT_NAME          L"\\NLAPublicPort"
#define WSM_PRIVATE_PORT_NAME  L"\\NLAPrivatePort"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nsu.h ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Network Security Utilities
//
// Abstract:
//
//     Master include file
//
// Author:
//
//     pmay 2/5/02
//
// Environment:
//
//     User / Kernel
//
// Revision History:
//

#pragma once

#ifndef NSU_H
#define NSU_H

#define NSU_CLEANUP Cleanup

#ifndef NSU_BAIL_ON_ERROR
#define NSU_BAIL_ON_ERROR(err) if((err) != ERROR_SUCCESS) {goto NSU_CLEANUP;}
#endif

#ifndef NSU_BAIL_ON_NULL
#define NSU_BAIL_ON_NULL(ptr, err) if ((ptr) == NULL) {(err) = ERROR_NOT_ENOUGH_MEMORY; goto NSU_CLEANUP;}
#endif

#ifndef NSU_BAIL_OUT
#define NSU_BAIL_OUT {goto NSU_CLEANUP;}
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "NsuMem.h"

#include "NsuString.h"

#include "NsuList.h"

#endif // NSU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nsumem.h ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Header definitions for NSU memory utilities
//
// Abstract:
//
//     Contains function prototypes that provide memory allocation deallocation routines.
//
// Author:
//
//     kmurthy 2/5/02
//
// Environment:
//
//     User mode
//
// Revision History:
//

// Description:
// This predefined, "known" pointer is used to 
// designate that a pointer has already been freed.
#define FREED_POINTER  ((PVOID)"Already Freed!!")

#ifdef __cplusplus
extern "C" {
#endif

PVOID WINAPI NsuAlloc(SIZE_T dwBytes,DWORD dwFlags);
DWORD WINAPI NsuFree(PVOID *ppMem);
DWORD WINAPI NsuFree0(PVOID *ppMem);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nsulist.h ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     common utility
//
// Abstract:
//
//     NT list api wrapper.
//
//     The NT list API is a very efficient and robust list API because:
//
//        a) all operations are guarenteed to succeed in constant time without
//            any branch instructions
//
//        b) memory is used in an optimum way since LIST_ENTRY structures 
//            are embedded into the objects stored in the list.  This means 
//            that the heap does not get fragmented with list nodes.  It also
//            allows entries to be removed/transferred/moved without ever 
//            having to free or reallocate a list node.
//
//      One drawback to the NT list API is that it comes with a learning curve 
//      for most people.
//
//      This header defines a wrapper of the NT list API to:
//      
//          - Allow for easy instrumentation.  Modules that use this API can be
//             specially purposed to store state with the lists, nodes, etc.
//
//          - Clarify the NT list API by separating the concept of a list from
//             a node in a list.  Although both are LIST_ENTRY's in the NT list
//             API, there are subtle differences.  For example, the head
//             of a list is not embedded into any other structure the way the
//             entries in a list are.
//
// Author:
//
//     pmay 3-Apr-2002
//
// Environment:
//
//     Kernel/user mode
//
// Revision History:
//

#pragma once

#ifndef NSULIST_H
#define NSULIST_H

#include "Nsu.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef LIST_ENTRY NSU_LIST_ENTRY;
typedef PLIST_ENTRY PNSU_LIST_ENTRY;

typedef LIST_ENTRY NSU_LIST;
typedef PLIST_ENTRY PNSU_LIST;

typedef struct _NSU_LIST_ITERATOR
{
    PNSU_LIST pList;
    PNSU_LIST_ENTRY pCurrentEntry;
} NSU_LIST_ITERATOR, * PNSU_LIST_ITERATOR;

// Description:
//
//    API's to manipulate lists
//
VOID 
FORCEINLINE
NsuListInitialize(
    OUT PNSU_LIST pList)
{
    InitializeListHead(pList);
}

BOOL
FORCEINLINE
NsuListIsEmpty(
    IN PNSU_LIST pList)
{
    return IsListEmpty(pList);
}

PNSU_LIST_ENTRY
FORCEINLINE
NsuListGetFront(
    IN PNSU_LIST pList)
{
    return pList->Flink;
}

PNSU_LIST_ENTRY
FORCEINLINE
NsuListGetBack(
    IN PNSU_LIST pList)
{
    return pList->Blink;
}

VOID
FORCEINLINE
NsuListInsertFront(
    IN PNSU_LIST pList,
    PNSU_LIST_ENTRY pEntry)
{
    InsertHeadList(pList, pEntry);
}

VOID
FORCEINLINE
NsuListInsertBack(
    IN PNSU_LIST pList,
    PNSU_LIST_ENTRY pEntry)
{
    InsertTailList(pList, pEntry);
}


PNSU_LIST_ENTRY
FORCEINLINE
NsuListRemoveFront(
    IN PNSU_LIST pList)
{
    PNSU_LIST_ENTRY pEntry;
    
    if (IsListEmpty(pList))
    {
        return NULL;
    }

    pEntry = pList->Flink;

    RemoveEntryList(pEntry);
    InitializeListHead(pEntry);

    return pEntry;
}

PNSU_LIST_ENTRY
FORCEINLINE
NsuListRemoveBack(
    IN PNSU_LIST pList)
{
    PNSU_LIST_ENTRY pEntry;
    
    if (IsListEmpty(pList))
    {
        return NULL;
    }

    pEntry = pList->Blink;

    RemoveEntryList(pEntry);
    InitializeListHead(pEntry);

    return pEntry;
}

// Description:
//
//    API's to manipulate entries (nodes) in a list
//
#define NsuListEntryGetData(Address, Type, Field) \
    CONTAINING_RECORD(Address, Type, Field)

VOID 
FORCEINLINE
NsuListEntryInitialize(
    OUT PNSU_LIST_ENTRY pEntry)
{
    InitializeListHead(pEntry);
}

BOOL
FORCEINLINE
NsuListEntryIsMember(
    IN PNSU_LIST_ENTRY pEntry)
{
    return IsListEmpty(pEntry);
}

VOID 
FORCEINLINE
NsuListEntryRemove(
    IN PNSU_LIST_ENTRY pEntry)
{
    RemoveEntryList(pEntry);
    InitializeListHead(pEntry);
}

VOID
FORCEINLINE
NsuListEntryInsertBefore(
    IN PNSU_LIST_ENTRY pEntryInList,
    IN PNSU_LIST_ENTRY pEntryToInsert)
{
    InsertTailList(pEntryInList, pEntryToInsert);
}

VOID
FORCEINLINE
NsuListEntryInsertAfter(
    IN PNSU_LIST_ENTRY pEntryInList,
    IN PNSU_LIST_ENTRY pEntryToInsert)
{
    InsertHeadList(pEntryInList, pEntryToInsert);
}

// Description:
//
//    API's to iterate over lists
//
//    Sample for using the iterator (includes removing during iteration):
//
//      NSU_LIST List;
//      NSU_LIST_ITERATOR Iterator;
//      NSU_LIST_ENTRY* pEntry;
//
//      NsuListIteratorInitialize(&Iterator, &List, NULL);
//      while ( !NsuListIteratorAtEnd(&Iterator) )
//      {
//          pEntry = NsuListIteratorCurrent(&Iterator))
//          pData = NsuListEntryGetData(pEntry, Type, Field);
//
//          NsuListIteratorNext(&Iterator);  // advance before any removing
//          
//          if (NeedToRemove(pData))
//          {
//              NsuListEntryRemove(pEntry);
//          }
//      }
//
VOID
FORCEINLINE
NsuListIteratorInitialize(
    OUT PNSU_LIST_ITERATOR pIterator,
    IN PNSU_LIST pList,
    IN OPTIONAL PNSU_LIST_ENTRY pEntryInList)     // NULL = start at front
{
    pIterator->pList = pList;
	pIterator->pCurrentEntry = (pEntryInList) ? pEntryInList : pList->Flink;
}

BOOL
FORCEINLINE
NsuListIteratorAtEnd(
    IN PNSU_LIST_ITERATOR pIterator)
{
    return (pIterator->pList == pIterator->pCurrentEntry);
}

PNSU_LIST_ENTRY 
FORCEINLINE
NsuListIteratorCurrent(
    IN PNSU_LIST_ITERATOR pIterator)
{
    return pIterator->pCurrentEntry;
}

VOID
FORCEINLINE
NsuListIteratorReset(
    IN PNSU_LIST_ITERATOR pIterator)
{
    pIterator->pCurrentEntry = pIterator->pList->Flink;
}

VOID
FORCEINLINE
NsuListIteratorNext(
    IN PNSU_LIST_ITERATOR pIterator)
{
    pIterator->pCurrentEntry = pIterator->pCurrentEntry->Flink;
}

VOID
FORCEINLINE
NsuListIteratorPrev(
    IN PNSU_LIST_ITERATOR pIterator)
{
    pIterator->pCurrentEntry = pIterator->pCurrentEntry->Blink;
}


// This wrapper does not work correctly in all cases and needs to be fixed. For now just
// use the C versions of everything

/*
// Description:
//
//    C++ List api wrapper
//
#ifdef __cplusplus

class NsuListEntry
{
public:
    NsuListEntry() { NsuListEntryInitialize(&m_Entry); }
    ~NsuListEntry() { RtlZeroMemory(&m_Entry, sizeof(m_Entry)); }

    PNSU_LIST_ENTRY Get() { return &m_Entry; }
    VOID Set(PNSU_LIST_ENTRY pEntry) { m_Entry = *pEntry; }

    BOOL IsMember() { return NsuListEntryIsMember(Get()); }

    VOID Remove() { return NsuListEntryRemove(&m_Entry); }

    VOID InsertBefore(NsuListEntry* pSrc) { return NsuListEntryInsertBefore((PNSU_LIST_ENTRY)pSrc, &m_Entry); }
    VOID InsertAfter(NsuListEntry* pSrc) { return NsuListEntryInsertAfter((PNSU_LIST_ENTRY)pSrc, &m_Entry); }

private:
    NSU_LIST_ENTRY m_Entry;
};

class NsuList
{
public:
	NsuList() { NsuListInitialize(&m_Head); }

    PNSU_LIST Get() { return &m_Head; } 
    
	PNSU_LIST GetFront(NsuListEntry& lEntry) { return NsuListGetFront(&m_Head); }
	PNSU_LIST GetBack(NsuListEntry& lEntry) { return NsuListGetBack(&m_Head); }

    VOID RemoveFront(OUT OPTIONAL NsuListEntry* pEntry) { pEntry = (NsuListEntry*)NsuListRemoveFront(&m_Head); }
    VOID RemoveBack(OUT OPTIONAL NsuListEntry* pEntry) { pEntry = (NsuListEntry*)NsuListRemoveBack(&m_Head); }

	VOID InsertFront(NsuListEntry* pEntry) { NsuListInsertFront(&m_Head, (PNSU_LIST_ENTRY)pEntry); }
    VOID InsertBack(NsuListEntry* pEntry) { NsuListInsertBack(&m_Head, (PNSU_LIST_ENTRY)pEntry); } 
    
    VOID MoveToFront(NsuListEntry* pEntry); 
    VOID MoveToBack(NsuListEntry* pEntry);

private:
    NSU_LIST m_Head;
};

class NsuListIterator
{
public:
	NsuListIterator(NsuList* pList);

    PNSU_LIST_ITERATOR Get() { return &m_Iterator; } 

	VOID Reset() { return NsuListIteratorReset(&(NSU_LIST_ITERATOR)m_Iterator); }
	VOID Next() { NsuListIteratorNext(&(NSU_LIST_ITERATOR)m_Iterator); }
	VOID Prev() { NsuListIteratorPrev(&(NSU_LIST_ITERATOR)m_Iterator); }

	NsuListEntry* Current() { return (NsuListEntry*)NsuListIteratorCurrent(&(NSU_LIST_ITERATOR)m_Iterator); }
	BOOL AtEnd() { return NsuListIteratorAtEnd(&(NSU_LIST_ITERATOR)m_Iterator); }

private:
    NSU_LIST_ITERATOR m_Iterator;
};

inline NsuListIterator::NsuListIterator(NsuList* pList)
{
	NsuListIteratorInitialize(&(NSU_LIST_ITERATOR)m_Iterator, (PNSU_LIST)pList, 0);
}

#endif
*/


#ifdef __cplusplus
}
#endif

#endif // NSULIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nsustring.h ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Safe string function wrappers and implementation for Networking/IPsec
//     nsustring.h
//
// Abstract:
//
//     Wrappers for strsafe.h and safe string functions
//
// Author:
//
//     RaymondS     1 February-2002
//
// Environment:
//
//     User mode
//
// Revision History:
//

#pragma once

#ifndef __NSUSTRING_H__
#define __NSUSTRING_H_

#include "Nsu.h"

#ifdef __cplusplus
extern "C" {
#endif

// (strsafe.h written by Reiner Fink)

#ifdef UNICODE
#define NsuStringCopy               NsuStringCopyW
#define NsuStringDup                NsuStringDupW
#define NsuStringCat                NsuStringCatW
#define NsuStringSprint             NsuStringSprintW
#define NsuStringSprintFailSafe     NsuStringSprintFailSafeW
#define NsuStringVSprintFailSafe    NsuStringVSprintFailSafeW
#define NsuStringLen                NsuStringLenW
#define NsuStringFind				NsuStringFindW
#else
#define NsuStringCopy               NsuStringCopyA
#define NsuStringDup                NsuStringDupA
#define NsuStringCat                NsuStringCatA
#define NsuStringSprint             NsuStringSprintA
#define NsuStringSprintFailSafe     NsuStringSprintFailSafeA
#define NsuStringVSprintFailSafe    NsuStringVSprintFailSafeA
#define NsuStringLen                NsuStringLenA
#define NsuStringFind				NsuStringFindA
#endif

DWORD
WINAPI
NsuStringCopyW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
NsuStringCopyA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszSrc
    );

DWORD
WINAPI
NsuStringCopyAtoWAlloc(
    OUT LPWSTR* ppszDest,
    IN size_t  cchLimit,    
    IN LPCSTR  pszSrc
    );

DWORD
WINAPI
NsuStringCopyWtoAAlloc(
    OUT LPSTR* ppszDest,
    IN size_t cbLimit,        
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
NsuStringCopyWtoA(
    OUT LPSTR pszDest,
    IN size_t cbDest,
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
NsuStringCopyAtoW(
    OUT LPWSTR pszDest,
    IN size_t  cchDest,
    IN LPCSTR  pszSrc
    );
    
DWORD
WINAPI
NsuStringDupW(
    OUT LPWSTR* ppszDest,
    IN size_t cchLimit,
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
NsuStringDupA(
    OUT LPSTR* ppszDest,
    IN size_t cchLimit,
    IN LPCSTR pszSrc
    );

DWORD
WINAPI
NsuStringCatW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
NsuStringCatA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszSrc
    );

DWORD
WINAPI
NsuStringSprintW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    ...
    );


DWORD
WINAPI
NsuStringSprintA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    ...
    );

VOID
WINAPI
NsuStringSprintFailSafeW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    ...
    );

VOID
WINAPI
NsuStringSprintFailSafeA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    ...
    );

VOID
WINAPI
NsuStringVSprintFailSafeW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    IN va_list vaArguments
    );

VOID
WINAPI
NsuStringVSprintFailSafeA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    IN va_list vaArguments
    );
    
DWORD
WINAPI
NsuStringLenW(
    IN LPCWSTR pszStr,
    OUT size_t* pcchStrLen
    );

DWORD
WINAPI
NsuStringLenA(
    IN LPCSTR pszStr,
    OUT size_t* pcbStrLen
    );

DWORD
WINAPI
NsuStringFindW(
	IN LPCWSTR pszStrToSearch,
	IN LPCWSTR pszStrToFind,
	IN BOOL bIsCaseSensitive,
	OUT LPCWSTR* ppszStartOfMatch
	);

DWORD
WINAPI
NsuStringFindA(
	IN LPCSTR pszStrToSearch,
	IN LPCSTR pszStrToFind,
	IN BOOL bIsCaseSensitive,
	OUT LPCSTR* ppszStartOfMatch
	);

#ifdef __cplusplus
}
#endif

#endif /* #ifdef __NSUSTRING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\pnpuverp.h ===
#include <winver.h>
#include <ntverp.h>

#undef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

#define VER_PRODUCTVERSION_STRING   "7.02"
#define VER_PRODUCTVERSION          7,02,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0702)
#define VER_PRODUCTVERSION_DW       (0x07020000 | VER_PRODUCTBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\ntstapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntstapi.h

Abstract:

    This module declares the STREAMS APIs that are provided for use
    primarily by the NT tcp/ip socket library.

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    mikemas   01-02-92    Deleted poll definition. Mips complained because
                          of def in winsock.h

    jballard  07-14-94    Added STRMAPI types. This should fix problems
                          building outside of the MS build environment.


--*/

#ifndef _NTSTAPI_
#define _NTSTAPI_

#ifndef STRMAPI

#if (_MSC_VER >= 800)
#define STRMAPI      __stdcall
#else
#define STRMAPI
#endif

#endif


//
// s_close() is not provided.  Use the open and close primitives that are
// appropriate to your subsystem.
//

int
STRMAPI
getmsg(
    IN HANDLE fd,
    IN OUT struct strbuf *ctrlptr OPTIONAL,
    IN OUT struct strbuf *dataptr OPTIONAL,
    IN OUT int *flagsp
    );

int
STRMAPI
putmsg(
    IN HANDLE fd,
    IN struct strbuf *ctrlptr OPTIONAL,
    IN struct strbuf *dataptr OPTIONAL,
    IN int flags
    );

int
STRMAPI
s_ioctl(
    IN HANDLE fd,
    IN int cmd,
    IN OUT void *arg OPTIONAL
    );

HANDLE
STRMAPI
s_open(
    IN char *path,
    IN int oflag,
    IN int ignored
    );

#endif /* _NTSTAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\polguids.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  IPSEC Policy Storage Component
//  Contract Category: Directory Schema
//	Copyright (C) 1997 Cisco Systems, Inc. All rights reserved.
//
//  File:       polguids.h
//
//  Contents:   Global GUIDS for Policy Storage
//
//  Notes:
/////////////////////////////////////////////////////////////////////////////
#ifndef __POLICY_STORAGE_GUIDS_H__
#define __POLICY_STORAGE_GUIDS_H__

//////////////////////////////
//
// Globals
//
//////////////////////////////

// {6A1F5C6F-72B7-11d2-ACF0-0060B0ECCA17}
static const GUID GUID_POLSTORE_VERSION_INFO =
{ 0x6a1f5c6f, 0x72b7, 0x11d2, { 0xac, 0xf0, 0x0, 0x60, 0xb0, 0xec, 0xca, 0x17 } };


// {72385230-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_POLICY =
{ 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385231-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_ISAKMP =
{ 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385232-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NFA =
{ 0x72385232, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385233-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NEGPOL =
{ 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385236-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_POLICY =
{ 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385237-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_ISAKMP =
{ 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385238-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_POLICY =
{ 0x72385238, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385239-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_ISAKMP =
{ 0x72385239, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523a-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ME_TO_FROM_ANYONE_FILTER=
{ 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385235-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ICMP_FILTER =
{ 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523c-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_POLICY =
{ 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523d-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_ISAKMP =
{ 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523e-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NFA =
{ 0x7238523e, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523f-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NEGPOL =
{ 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

static const GUID GUID_BUILTIN_PERMIT_NEGPOL =
{ 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };





//////////////////////////////
//////////////////////////////
//		Negotiation Policy Types
//////////////////////////////
//////////////////////////////
// {62F49E10-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_STANDARD =
{ 0x62f49e10, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E11-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_BASE =
{ 0x62f49e11, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E12-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_EXTENDED =
{ 0x62f49e12, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E13-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_DEFAULT =
{ 0x62f49e13, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


//////////////////////////////
//////////////////////////////
//		Negotiation Policy Actions
//////////////////////////////
//////////////////////////////

// {3F91A819-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_BLOCK =
{ 0x3f91a819, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {3F91A81A-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU =
{ 0x3f91a81a, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD2-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NO_IPSEC =
{ 0x8a171dd2, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD3-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NORMAL_IPSEC =
{ 0x8a171dd3, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };




//////////////////////////////
//////////////////////////////
//		GUID identifying the default IKE settings to use
//		in case no policy is assigned.
//////////////////////////////
//////////////////////////////
// {72385234-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_DEFAULT_ISAKMP_POLICY=
{ 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

///////////////////////
// GUIDS reserved for future use... These are handy mostly because they
// are easily recognizable because of the trailing zeros.  This helps out in
// debugging and in manual manipulation of policies by GUID -- such as removing
// built-in policies from the DS using adsvw etc.
//////////////////////



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\poll.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  poll.h

Abstract:

  Contains #defines, types, and macros for poll

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

--*/

#ifndef SYS_POLL_INCLUDED
#define SYS_POLL_INCLUDED

/*
 * Structure of file descriptor/event pairs supplied in
 * the poll arrays.
 */
struct pollfd {
#ifndef _POSIX_SOURCE
        HANDLE fd;                      /* file handle to poll */
#else
        int   fd;                       /* file desc to poll */
#endif
        short events;                   /* events of interest on fd */
        short revents;                  /* events that occurred on fd */
};

/*
 * Testable select events
 */
#define POLLIN          01              /* fd is readable */
#define POLLPRI         02              /* priority info at fd */
#define POLLOUT         04              /* fd is writeable (won't block) */
#define POLLMSG         0100            /* M_SIG or M_PCSIG arrived */

/*
 * Non-testable poll events (may not be specified in events field,
 * but may be returned in revents field).
 */
#define POLLERR         010             /* fd has error condition */
#define POLLHUP         020             /* fd has been hung up on */
#define POLLNVAL        040             /* invalid pollfd entry */

/*
 * Number of pollfd entries to read in at a time in poll.
 * The larger the value the better the performance, up to the
 * maximum number of open files allowed.  Large numbers will
 * use excessive amounts of kernel stack space.
 */
#define NPOLLFILE       20


/*
 * Poll function prototype
 *
 */

int
poll(
    IN OUT struct pollfd *,
    IN unsigned int,
    IN int);


#endif  //SYS_POLL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\pxuser.h ===
//
//  Include file for users of ndproxy.
//
//
//  #include <ndistapi.h>
//


#ifndef _PXUSER__H
#define _PXUSER__H

//
//  Access TAPI Call Information on a VC via NdisCoRequest to the proxy:
//
#define OID_NDPROXY_TAPI_CALL_INFORMATION		0xFF110001

typedef struct _NDPROXY_TAPI_CALL_INFORMATION
{
	ULONG						Size;			// Length of this structure
	ULONG						ulBearerMode;
	ULONG						ulMediaMode;
	ULONG						ulMinRate;
	ULONG						ulMaxRate;

} NDPROXY_TAPI_CALL_INFORMATION, *PNDPROXY_TAPI_CALL_INFORMATION;


#endif // _PXUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\pxdebug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PXDebug.h

Abstract:

    Debug macros for Proxy
Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    rmachin     11-01-96       created -- after ArvindM's cmadebug.h

Notes:

--*/

#ifndef _PXDebug__H
#define _PXDebug__H

//
// Message verbosity: lower values indicate higher urgency
//
#define PXD_VERY_LOUD       10
#define PXD_LOUD             8
#define PXD_INFO             6
#define PXD_TAPI             5
#define PXD_WARNING          4
#define PXD_ERROR            2
#define PXD_FATAL            1

#define PXM_INIT            0x00000001
#define PXM_CM              0x00000002
#define PXM_CL              0x00000004
#define PXM_CO              0x00000008
#define PXM_UTILS           0x00000010
#define PXM_TAPI            0x00000020
#define PXM_ALL             0xFFFFFFFF

#if DBG

extern ULONG    PXDebugLevel;   // the value here defines what the user wants to see
                                // all messages with this urgency and lower are enabled
extern ULONG    PXDebugMask;

#define PXDEBUGP(_l, _m, Fmt)                           \
{                                                       \
    if ((_l <= PXDebugLevel) &&                         \
        (_m & PXDebugMask)) {                           \
        DbgPrint("NDProxy: ");                          \
        DbgPrint Fmt;                                   \
    }                                                   \
}


#define PxAssert(exp)                                                   \
{                                                                       \
    if (!(exp)) {                                                       \
        DbgPrint("NDPROXY: ASSERTION FAILED! %s\n", #exp);              \
        DbgPrint("NDPROXY: File: %s, Line: %d\n", __FILE__, __LINE__);  \
        DbgBreakPoint();                                                \
    }                                                                   \
}

//
// Memory Allocation/Freeing Auditing:
//

//
//Signature used for all pool allocs
//
#define PXD_MEMORY_SIGNATURE    (ULONG)'XPDN'

//
// The PXD_ALLOCATION structure stores all info about one CmaMemAlloc.
//
typedef struct _PXD_ALLOCATION {
    LIST_ENTRY              Linkage;
    ULONG                   Signature;
    ULONG                   FileNumber;
    ULONG                   LineNumber;
    ULONG                   Size;
    ULONG_PTR               Location;   // where the returned pointer was put
    UCHAR                   UserData;
} PXD_ALLOCATION, *PPXD_ALLOCATION;

PVOID
PxAuditAllocMem (
    PVOID   pPointer,
    ULONG   Size,
    ULONG   Tag,
    ULONG   FileNumber,
    ULONG   LineNumber
    );

VOID
PxAuditFreeMem(
    PVOID       Pointer
    );

#else  // end DBG

//
// No debug
//

#define PXDEBUGP(_l, _m, fmt)
#define PxAssert(exp)

#endif  // end !DBG

#endif // _PXDebug__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\nuiouser.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nuiouser.h

Abstract:

    Constants and types to access the NDISUIO driver.
    Users must also include ntddndis.h

Environment:

    User/Kernel mode.

Revision History:

    arvindm     4/12/2000    Created

--*/

#ifndef __NUIOUSER__H
#define __NUIOUSER__H


#define FSCTL_NDISUIO_BASE      FILE_DEVICE_NETWORK

#define _NDISUIO_CTL_CODE(_Function, _Method, _Access)  \
            CTL_CODE(FSCTL_NDISUIO_BASE, _Function, _Method, _Access)

#define IOCTL_NDISUIO_OPEN_DEVICE   \
            _NDISUIO_CTL_CODE(0x200, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISUIO_QUERY_OID_VALUE   \
            _NDISUIO_CTL_CODE(0x201, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISUIO_SET_OID_VALUE   \
            _NDISUIO_CTL_CODE(0x205, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISUIO_SET_ETHER_TYPE   \
            _NDISUIO_CTL_CODE(0x202, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISUIO_QUERY_BINDING   \
            _NDISUIO_CTL_CODE(0x203, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_NDISUIO_BIND_WAIT   \
            _NDISUIO_CTL_CODE(0x204, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

    
//
//  Structure to go with IOCTL_NDISUIO_QUERY_OID_VALUE.
//  The Data part is of variable length, determined by
//  the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISUIO_QUERY_OID
{
    NDIS_OID        Oid;
    UCHAR           Data[sizeof(ULONG)];

} NDISUIO_QUERY_OID, *PNDISUIO_QUERY_OID;

//
//  Structure to go with IOCTL_NDISUIO_SET_OID_VALUE.
//  The Data part is of variable length, determined
//  by the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISUIO_SET_OID
{
    NDIS_OID        Oid;
    UCHAR           Data[sizeof(ULONG)];

} NDISUIO_SET_OID, *PNDISUIO_SET_OID;


//
//  Structure to go with IOCTL_NDISUIO_QUERY_BINDING.
//  The input parameter is BindingIndex, which is the
//  index into the list of bindings active at the driver.
//  On successful completion, we get back a device name
//  and a device descriptor (friendly name).
//
typedef struct _NDISUIO_QUERY_BINDING
{
	ULONG			BindingIndex;		// 0-based binding number
	ULONG			DeviceNameOffset;	// from start of this struct
	ULONG			DeviceNameLength;	// in bytes
	ULONG			DeviceDescrOffset;	// from start of this struct
	ULONG			DeviceDescrLength;	// in bytes

} NDISUIO_QUERY_BINDING, *PNDISUIO_QUERY_BINDING;
 
#endif // __NUIOUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\rasfmsub.h ===
//****************************************************************************
//
//  Microsoft Remote Access Service
//
//  Copyright (C) Microsoft Corporation
//
//  Description: This file contains all structure and constant definitions for
//             the subauthentication package used by ARAP, MD5 and SFM
//
//****************************************************************************


#ifndef _RASSFMSUBAUTH_
#define _RASSFMSUBAUTH_

//
// Get id for our subauthentication package - MSV1_0_SUBAUTHENTICATION_DLL_RAS
//
#include <ntmsv1_0.h>

//
// Defines for those protocols that need subauthentication at the PDC
//
enum RAS_SUBAUTH_PROTO
{
    RAS_SUBAUTH_PROTO_ARAP = 1,
    RAS_SUBAUTH_PROTO_MD5CHAP = 2,
    RAS_SUBAUTH_PROTO_MD5CHAP_EX = 3,
    RAS_SUBAUTH_PROTO_