***********************************/
#ifndef __CAT_H__
#define __CAT_H__

#include <windows.h>
#include <mailmsg.h>
#include <aqueue.h>

#define CATCALLCONV

#define CATEXPDLLCPP extern "C"

/************************************************************
 * FUNCTION: CatInit
 * DESCRIPTION: Initialzies Categorizer.
 * PARAMETERS:
 *   pszConfig: Indicates where to find configuration defaults
 *              Config info found in key
 *              HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
 *              \PlatinumIMC\CatSources\szConfig
 *
 *   phCat:    Pointer to a handle.  Upon successfull initializtion,
 *             handle to use in subsequent Categorizer calls will be
 *             plcaed there.
 *
 *   pAQConfig: pointer to an AQConfigInfo structure containing
 *              per virtual server message cat parameters
 *
 *   pfn: Service routine for periodic callbakcs if any time consuming
 *        operations are performed
 *
 *   pServiceContext: Context for the pfn function.
 *
 *   pISMTPServer: ISMTPServer interface to use for triggering server
 *                 events for this virtual server
 *
 *   pIDomainInfo: pointer to an interface that contains domain info routines
 *
 *   dwVirtualServerInstance: Virtual Server ID
 *
 * Return value: S_OK if everything is initialized okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:26: Created
 *   // jstamerj 1998/06/25 12:25:34: Added AQConfig/IMSTPServer.
 *
 ************************************************************/
typedef void (*PCATSRVFN_CALLBACK)(PVOID);
CATEXPDLLCPP HRESULT CATCALLCONV CatInit(
    IN  AQConfigInfo *pAQConfig,
    IN  PCATSRVFN_CALLBACK pfn,
    IN  PVOID pvServiceContext,
    IN  ISMTPServer *pISMTPServer,
    IN  IAdvQueueDomainType *pIDomainInfo,
    IN  DWORD dwVirtualServerInstance,
    OUT HANDLE *phCat);

//+------------------------------------------------------------
//
// Function: CatChangeConfig
//
// Synopsis: Changes the configuration of a virtual categorizer
//
// Arguments:
//   hCat: handle of virtual categorizer
//   pAQConfig: AQConfigInfo pointer
//   pISMTPServer: ISMTPServer to use
//   pIDomainInfo: interface that contains domain information
//
//   Flags for dwMsgCatFlags in AQConfigInfo
#define MSGCATFLAG_RESOLVELOCAL             0x00000001
#define MSGCATFLAG_RESOLVEREMOTE            0x00000002
#define MSGCATFLAG_RESOLVESENDER            0x00000004
#define MSGCATFLAG_RESOLVERECIPIENTS        0x00000008
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: Invalid hCat or pAQConfig
//
// History:
// jstamerj 980521 15:47:42: Created.
//
//-------------------------------------------------------------
CATEXPDLLCPP HRESULT CATCALLCONV CatChangeConfig(
    IN HANDLE hCat,
    IN AQConfigInfo *pAQConfig,
    IN ISMTPServer *pISMTPServer,
    IN IAdvQueueDomainType *pIDomainInfo);



/************************************************************
 * FUNCTION: PFNCAT_COMPLETION (User supplied)
 * DESCRIPTION: Completion routine called to accept a categorized IMsg
 * PARAMETERS:
 *   hr:       S_OK unless message categorization was not finished.
 *             CAT_W_SOME_UNDELIVERABLE_MSGS if one or more
 *             recipient should not be delivered to...
 *   pContext: User's value passed into CatMsg
 *   pImsg:    IMsg interface of categorized object -- if message was
 *             bifurcated this parameter will be NULL
 *   rpgImsg:  NULL unless IMsg was bifurcated -- if message was
 *             bifurcated, this will be a NULL termianted array of
 *             ptrs to IMsg interfaces.
 * NOTE: Either pImsg or rgpImsg will always be NULL (but never both).
 *
 * Return Value: S_OK if everything is okay (Categorizer will assert
 *                                           check this value)
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
typedef HRESULT (CATCALLCONV *PFNCAT_COMPLETION)(/* IN  */ HRESULT hr,
                                                 /* IN  */ PVOID pContext,
                                                 /* IN  */ IUnknown *pImsg,
                                                 /* IN  */ IUnknown **rgpImsg);


/************************************************************
 * FUNCTION: CatMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface for message to categorize
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatMsg (/* IN  */ HANDLE hCat,
                                         /* IN  */ IUnknown *pImsg,
                                         /* IN  */ PFNCAT_COMPLETION pfn,
                                         /* IN  */ LPVOID pContext);

/************************************************************
 * FUNCTION: PFNCAT_DLCOMPLETION (User supplied)
 * DESCRIPTION: Completion routine called to accept a categorized message
 * PARAMETERS:
 *   hr:       S_OK unless message categorization was not finished.
 *   pContext: User's value passed into CatMsg
 *   pImsg:    IMsg interface of categorized object (with expanded recipients)
 *   fMatch:   TRUE if your user was found
 *
 * Return Value: S_OK if everything is okay (Categorizer will assert
 *                                           check this value)
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
typedef HRESULT (CATCALLCONV *PFNCAT_DLCOMPLETION)(
    /* IN  */ HRESULT hr,
    /* IN  */ PVOID pContext,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ BOOL fMatch);


/************************************************************
 * FUNCTION: CatDLMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface to categorize -- each DL should be a recip
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *   fMatchOnly: Stop resolving when a match is found?
 *   CAType:   The address type of pszAddress
 *   pszAddress: THe address you are looking for
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatDLMsg (
    /* IN  */ HANDLE hCat,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ PFNCAT_DLCOMPLETION pfn,
    /* IN  */ LPVOID pContext,
    /* IN  */ BOOL fMatchOnly = FALSE,
    /* IN  */ CAT_ADDRESS_TYPE CAType = CAT_UNKNOWNTYPE,
    /* IN  */ LPSTR pszAddress = NULL);


/************************************************************
 * FUNCTION: CatTerm
 * DESCRIPTION: Called when user wishes to terminate categorizer
 *              opertions with this handle
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatTerm(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatCancel
 * DESCRIPTION: Cancels pending searches for this hCat.  User's
 *              completion routine will be called with an error for
 *              each pending message.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:52:10: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatCancel(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatPrepareForShutdown
 * DESCRIPTION: Begin shutdown for this virtual categorizer (hCat).
 *              Stop accepting messages for categorization and cancel
 *              pending categorizations.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 1999/07/19 22:35:17: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatPrepareForShutdown(/* IN  */ HANDLE hCat);


/************************************************************
 * FUNCTION: CatVerifySMTPAddress
 * DESCRIPTION: Verifies a the address corresponds to a valid user or DL
 * PARAMETERS:
 *  hCat:       Categorizer handle received from CatInit
 *  szSMTPAddr  SMTP Address to lookup (ex: "user@domain")
 *
 * Return Values:
 *  S_OK            User exists
 *  CAT_I_DL        This is a distribution list
 *  CAT_I_FWD       This user has a forwarding address
 *  CAT_E_NORESULT  There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatVerifySMTPAddress(
  /* IN  */ HANDLE hCat,
  /* IN  */ LPTSTR szSMTPAddr);


/************************************************************
 * FUNCTION: CatGetForwaringSMTPAddress
 * DESCRIPTION: Retreive a user's forwarding address.
 * PARAMETERS:
 *  hCat:           Categorizer handle received from CatInit
 *  szSMTPAddr:     SMTP Address to lookup (ex: "user@domain")
 *  pdwcc:          Size of forwarding address buffer in Chars
 *                  (This is set to actuall size of forwarding address
 *                   string (including NULL terminator) on exit)
 *  szSMTPForward:  Buffer where retreived forwarding SMTP address
 *                  will be copied. (can be NULL if *pdwcc is zero)
 *
 * Return Values:
 *  S_OK            Success
 *  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
 *                  *pdwcc was not large enough to hold the forwarding
 *                  address string.
 * CAT_E_DL         This is a distribution list.
 * CAT_E_NOFWD      This user does not have a forwarding address.
 * CAT_E_NORESULT   There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatGetForwardingSMTPAddress(
  /* IN  */    HANDLE  hCat,
  /* IN  */    LPCTSTR szSMTPAddr,
  /* IN,OUT */ PDWORD  pdwcc,
  /* OUT */    LPTSTR  szSMTPForward);

//
// Com support functions for COM categorizer objects
//


//+------------------------------------------------------------
//
// Function: CatDllMain
//
// Synopsis: Handle what cat needs to do in DLLMain
//
// Arguments:
//  hInstance: instance of this DLL
//  dwReason: Why are you calling me?
//  lpReserved
//
// Returns: TRUE
//
// History:
// jstamerj 1998/12/12 23:06:08: Created.
//
//-------------------------------------------------------------
BOOL WINAPI CatDllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */);




//+------------------------------------------------------------
//
// Function: RegisterCatServer
//
// Synopsis: Register the categorizer com objects
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:07:20: Created.
//
//-------------------------------------------------------------
STDAPI RegisterCatServer();


//+------------------------------------------------------------
//
// Function: UnregisterCatServer
//
// Synopsis: Unregister the categorizer com objects
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:08:09: Created.
//
//-------------------------------------------------------------
STDAPI UnregisterCatServer();


//+------------------------------------------------------------
//
// Function: DllCanUnloadCatNow
//
// Synopsis: Return to COM wether it's okay or not to unload our dll
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, can unload
//  S_FALSE: Success, do not unload
//
// History:
// jstamerj 1998/12/12 15:09:02: Created.
//
//-------------------------------------------------------------
STDAPI DllCanUnloadCatNow();


//+------------------------------------------------------------
//
// Function: DllGetCatClassObject
//
// Synopsis: Return the class factory object (an interface to it)
//
// Arguments:
//  clsid: The CLSID of the object you want a class factory for
//  iid: the interface you want
//  ppv: out param to set to the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: don't support that interface
//  CLASS_E_CLASSNOTAVAILABLE: don't support that clsid
//
// History:
// jstamerj 1998/12/12 15:11:48: Created.
//
//-------------------------------------------------------------
STDAPI DllGetCatClassObject(
    const CLSID& clsid,
    const IID& iid,
    void **ppv);


//+------------------------------------------------------------
//
// Function: CatGetPerfCounters
//
// Synopsis: Retrieve the categorizer performance counter block
//
// Arguments:
//  hCat: Categorizer handle returned from CatInit
//  pCatPerfBlock: struct to fill in with counter values
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/02/26 14:53:21: Created.
//
//-------------------------------------------------------------
HRESULT CatGetPerfCounters(
    HANDLE hCat,
    PCATPERFBLOCK pCatPerfBlock);


//+------------------------------------------------------------
//
// Function: CatLogEvent
//
// Synopsis: Log an event to the event log
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for logging
//
// Returns:
//  S_OK: Success
//
// History:
// dbraun 2000/09/13 : Created.
//
//-------------------------------------------------------------
HRESULT CatLogEvent(
    ISMTPServer              *pISMTPServer,
    DWORD                    idMessage,
    WORD                     cSubstrings,
    LPCSTR                   *rgszSubstrings,
    DWORD                    errCode,
    LPCSTR                   szKey,
    DWORD                    dwOptions,
    WORD                     iDebugLevel,
    DWORD                    iMessageString = 0xffffffff);

HRESULT CatLogEvent(
    IN  ISMTPServerEx            *pISMTPServerEx,
    IN  DWORD                    idMessage,
    IN  WORD                     cSubStrings,
    IN  LPCSTR                   *rgpszSubStrings,
    IN  DWORD                    errCode,
    IN  LPCSTR                   pszKey,
    IN  DWORD                    dwOptions,
    IN  WORD                     wLogLevel,
    IN  DWORD                    iMessageString = 0xffffffff);

#endif // __CAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\hshroute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: hshroute.h
//
//  Description: Hash Routing functions.  In many cases, domains are
//      identified by domain *and* routing informtion.  This additional
//      information is identified by router GUID and a DWORD idenitfier.
//      This header provides macros to create unique domain-name-like strings
//      from the domain name and additional routing information.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/24/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __HSHROUTE_H__
#define __HSHROUTE_H__

#include <dbgtrace.h>

//The following is a list of 1 character "types" that can be used to identify
//the type of routing information hashed.  It is unlikely that this list will
//grow significantly (or even at all).
typedef enum
{
    //Be sure to update FIRST_ROUTE_HASH_TYPE if you change the first type
    ROUTE_HASH_MESSAGE_TYPE = 0,
    ROUTE_HASH_SCHEDULE_ID,
    ROUTE_HASH_NUM_TYPES,
} eRouteHashType;
#define FIRST_ROUTE_HASH_TYPE ROUTE_HASH_MESSAGE_TYPE

_declspec (selectany) CHAR g_rgHashTypeChars[ROUTE_HASH_NUM_TYPES+1] =
{
    'M', //ROUTE_HASH_MESSAGE_TYPE
    'S', //ROUTE_HASH_SCHEDULE_ID
    '\0' //End of list
};

//---[ dwConvertHexChar ]------------------------------------------------------
//
//
//  Description:
//      Converts Hex character into an int from 0 to 15.
//  Parameters:
//      chHex   Hex character to convert
//  Returns:
//      DWORD value between 0 and 15
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwConvertHexChar(CHAR chHex)
{
    DWORD dwValue = 0;
    if (('0' <= chHex) && ('9' >= chHex))
        dwValue = chHex-'0';
    else if (('a' <= chHex) && ('f' >= chHex))
        dwValue = 10 + chHex-'a';
    else if (('A' <= chHex) && ('F' >= chHex))
        dwValue = 10 + chHex-'A';
    else
        _ASSERT(0 && "Invalid hex character");

    _ASSERT(15 >= dwValue);
    return dwValue;
}


//Format is <type>.GUID.DWORD... each byte takes 2 chars to encode in HEX
//  eg - M.00112233445566778899AABBCCDDEEFF.00112233.foo.com

//Offsets are defined to be used in ptr arith or array offsets
#define ROUTE_HASH_CHARS_IN_DWORD   (2*sizeof(DWORD))
#define ROUTE_HASH_CHARS_IN_GUID    (2*sizeof(GUID))
#define ROUTE_HASH_TYPE_OFFSET      0
#define ROUTE_HASH_GUID_OFFSET      2
#define ROUTE_HASH_DWORD_OFFSET     (3 + ROUTE_HASH_CHARS_IN_GUID)
#define ROUTE_HASH_DOMAIN_OFFSET    (4 + ROUTE_HASH_CHARS_IN_GUID + ROUTE_HASH_CHARS_IN_DWORD)
#define ROUTE_HASH_PREFIX_SIZE      sizeof(CHAR)*ROUTE_HASH_DOMAIN_OFFSET

//---[ erhtGetRouteHashType ]---------------------------------------------------
//
//
//  Description:
//      For a given hashed domain, will return the assocaiated eRouteHashType
//  Parameters:
//      IN  szHashedDomain  Hashed domain
//  Returns:
//      eRouteHashType of hashed domain
//      ROUTE_HASH_NUM_TYPES (and asserts) if domain is not a valid route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline eRouteHashType erhtGetRouteHashType(LPSTR szHashedDomain)
{
    eRouteHashType erthRet = FIRST_ROUTE_HASH_TYPE;
    PCHAR pchRouteHashType = g_rgHashTypeChars;
    CHAR  chRouteHashType = szHashedDomain[ROUTE_HASH_TYPE_OFFSET];

    while (('\0' != *pchRouteHashType) &&
           (*pchRouteHashType != chRouteHashType))
    {
        pchRouteHashType++;
        erthRet = (eRouteHashType) (erthRet + 1);

        //we should not get to end of list
        _ASSERT(ROUTE_HASH_NUM_TYPES > erthRet);
    }

    return erthRet;
}

//---[ szGetDomainFromRouteHash ]----------------------------------------------
//
//
//  Description:
//      Returns the string of the unhashed domain from the hashed domain
//      string.  Do *NOT* attempt to free this string.
//  Parameters:
//      IN  szHashedDomain  Hashed domain
//  Returns:
//      Original... unhashed domain
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline LPSTR szGetDomainFromRouteHash(LPSTR szHashedDomain)
{
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DOMAIN_OFFSET-1]);
    return (szHashedDomain + ROUTE_HASH_DOMAIN_OFFSET);
}

//---[ guidGetGUIDFromRouteHash ]----------------------------------------------
//
//
//  Description:
//      Extracts the guid from the route hash
//  Parameters:
//      IN     szHashedDomain   Hashed domain
//      IN OUT pguid            Extracted GUID
//  Returns:
//      -
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline void GetGUIDFromRouteHash(LPSTR szHashedDomain, IN OUT GUID *pguid)
{
    DWORD *pdwGuid = (DWORD *) pguid;
    LPSTR szGUIDString = szHashedDomain+ROUTE_HASH_GUID_OFFSET;

    _ASSERT(sizeof(GUID)/sizeof(DWORD) == 4); //should be 4 DWORDs in GUID

    //Reverse operation of hash... convert to array of 4 DWORDs
    for (int i = 0; i < 4; i++)
    {
        pdwGuid[i] = 0;
        for (int j = 0;j < ROUTE_HASH_CHARS_IN_DWORD; j++)
        {
            pdwGuid[i] *= 16;
            pdwGuid[i] += dwConvertHexChar(*szGUIDString);
            szGUIDString++;
        }
    }
    _ASSERT('.' == *szGUIDString);
}

//---[ dwGetIDFromRouteHash ]--------------------------------------------------
//
//
//  Description:
//      Extracts DWORD ID from route hash
//  Parameters:
//      IN     szHashedDomain   Hashed domain
//  Returns:
//      DWORD ID encoded in route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwGetIDFromRouteHash(LPSTR szHashedDomain)
{
    _ASSERT(szHashedDomain);
    LPSTR szDWORDString = szHashedDomain+ROUTE_HASH_DWORD_OFFSET;
    DWORD dwID = 0;

    for (int i = 0; i < ROUTE_HASH_CHARS_IN_DWORD; i++)
    {
        dwID *= 16;
        dwID += dwConvertHexChar(*szDWORDString);
        szDWORDString++;
    }

    _ASSERT('.' == *szDWORDString);
    return dwID;
}

//---[ dwGetSizeForRouteHash ]--------------------------------------------------
//
//
//  Description:
//      Returns the required sizeof the hash buffer from the string
//      length of the domain
//  Parameters:
//      IN  cbDomainName    string length of domain name (in bytes)
//  Returns:
//      size (in bytes) of buffer required to create route hash
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline DWORD dwGetSizeForRouteHash(DWORD cbDomainName)
{
    //include prefix size and NULL char
    return (cbDomainName + sizeof(CHAR) + ROUTE_HASH_PREFIX_SIZE);
}

//---[ CreateRouteHash ]-------------------------------------------------------
//
//
//  Description:
//      Creates a route-hashed domain name from a given domain name and
//      routing information.
//  Parameters:
//      IN     cbDomainName     string length of domain name (in bytes)
//      IN     szDomainName     Name of domain to hash
//      IN     pguid            Ptr to GUID of router
//      IN     dwRouterID       ID Provided by router
//      IN OUT szHashedDomain   Buffer that is filled with route-hashed domain
//                              name
//      IN     cbHashedDomain   Size of output buffer
//  Returns:
//      -
//  History:
//      9/24/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
inline void CreateRouteHash(IN     DWORD cbDomainName,
                            IN     const LPSTR szDomainName,
                            IN     eRouteHashType erhtType,
                            IN     GUID *pguidRouter,
                            IN     DWORD dwRouterID,
                            IN OUT LPSTR szHashedDomain,
                            IN OUT DWORD cbHashedDomain)
{
    _ASSERT(ROUTE_HASH_NUM_TYPES > erhtType);
    _ASSERT(pguidRouter);
    _ASSERT(sizeof(GUID) == 16);
    DWORD *pdwGuids = (DWORD *) pguidRouter;

    _ASSERT(cbHashedDomain >= dwGetSizeForRouteHash(cbDomainName));

    _snprintf(szHashedDomain, cbHashedDomain, "%c.%08X%08X%08X%08X.%08X.%s",
            g_rgHashTypeChars[erhtType], pdwGuids[0], pdwGuids[1], pdwGuids[2],
            pdwGuids[3], dwRouterID, szDomainName);

    // ensure that the string is terminated
    szHashedDomain[cbHashedDomain-1] = 0;

    _ASSERT('.' == szHashedDomain[ROUTE_HASH_GUID_OFFSET-1]);
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DWORD_OFFSET-1]);
    _ASSERT('.' == szHashedDomain[ROUTE_HASH_DOMAIN_OFFSET-1]);
}


#endif //__HSHROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\retrsink.h ===
////////////////////////////////////////////////////////////////////////////////////////////////
// FILE: retrsink.h
// PURPOSE: Lib for handling retries of failed outbound connections
// HISTORY:
//  NimishK 05-14-98 Created
///////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __RETRSINK_H__
#define __RETRSINK_H__

#include <baseobj.h>

//function used for retry callback
typedef VOID (*RETRFN)(PVOID pvContext);
#define CALLBACK_DOMAIN "!callback"

////////////////////////////
//Temporary stuff, till we get this all into the event interface IDL file
typedef struct RetryData
{
   BOOL   fRetryDelay;
   DWORD   dwRetryDelay;
} RETRY_DATA, *PRETRY_DATA;

typedef struct RetryConfigData
{
    DWORD    dwRetryThreshold;
    DWORD    dwGlitchRetrySeconds;
    DWORD    dwFirstRetrySeconds;
    DWORD    dwSecondRetrySeconds;
    DWORD    dwThirdRetrySeconds;
    DWORD    dwFourthRetrySeconds;

} RETRYCONFIG, *PRETRYCONFIG;

enum SINK_STATUS {EVT_IGNORED, EVT_HANDLED, SKIP_ALL};
///////////////////////////

#define DOMAIN_ENTRY_RETRY 0x00000002
#define DOMAIN_ENTRY_SCHED 0x00000004
#define DOMAIN_ENTRY_FORCE_CONN 0x00000008
#define DOMAIN_ENTRY_ETRNTURN 0x00000040

//Forward declaration
class CRETRY_HASH_ENTRY;
class CRETRY_HASH_TABLE;
class CRETRY_Q;


////////////////////////////////////////////////////////////////////////////////////////////////
// class CSMTP_RETRY_HANDLER
//      This class provides the retry functionality that is needed when SMTP server fails to
//      send messages to the remote host.
//      It is considered the default retry handler - meaning in absence of any other entity 
//      taking care of retries, this handler will do it. For additional information look up
//      docs on the ServerEvent framework for AQUEUE.
//      Whenever SMTP acks a connection, this handler gets called. If the connection failed, the 
//      handler keeps track of the "NextHop" name that failed. It will disable the link corres-
//      ponding to the "NextHop" and reactivate it later based on the retry interval specified
//      the administrator. 
//      The main components are - a "NextHop" name hash table to keep track of links we know 
//      about, a queue with entries sorted by the retry time of a link and a dedicated thread 
//      that will be responsible for retrying entries based on the queue
//      This class will be initialized during the ConnectionManager initialization and deiniti-
//      alized during ConnectionManager Deinit.
//      It gets signalled whenever there is change in the config data ( retry interval )
//      
///////////////////////////////////////////////////////////////////////////////////////////////
class CSMTP_RETRY_HANDLER : 
    public IConnectionRetrySink, 
    public CBaseObject
{

   // CSMTP_RETRY_HANDLER
   public:
      CSMTP_RETRY_HANDLER()
      {
         m_RetryEvent = NULL;
         m_fHandlerShuttingDown = FALSE;
      }
      ~CSMTP_RETRY_HANDLER()
      {
         TraceFunctEnterEx((LPARAM)this, "~CSMTP_RETRY_HANDLER");

         TraceFunctLeaveEx((LPARAM)this);
      }
      
      //Init / denit called during ConnMan inits
      HRESULT HrInitialize(IN IConnectionRetryManager *pIConnectionRetryManager);
      HRESULT HrDeInitialize(void);
      
      //Config data change notifier - called by ConnMan whenver relevant
      //data in metabase changes
      void UpdateRetryData(PRETRYCONFIG pRetryConfig)
      { 
          m_dwRetryThreshold = pRetryConfig->dwRetryThreshold;
          m_dwGlitchRetrySeconds = pRetryConfig->dwGlitchRetrySeconds;
          m_dwFirstRetrySeconds =  pRetryConfig->dwFirstRetrySeconds;
          m_dwSecondRetrySeconds = pRetryConfig->dwSecondRetrySeconds;
          m_dwThirdRetrySeconds = pRetryConfig->dwThirdRetrySeconds;
          m_dwFourthRetrySeconds = pRetryConfig->dwFourthRetrySeconds;

          //Update all the queue entries with the new config data.
          //
          UpdateAllEntries();
      }

      //Wait for dedicated thread to exit during Deinit
      void WaitForQThread(void)
      {
         DWORD ThreadExit;
         ThreadExit = WaitForSingleObject(m_ThreadHandle,INFINITE);
      }

      //Wait for all ConnectionReleased threads to go away 
      //during deinit
      void WaitForShutdown(void)
      {
         DWORD ThreadExit;
         ThreadExit = WaitForSingleObject(m_ShutdownEvent,INFINITE);
      }

      //Set event to control the dedicated thread
      void SetQueueEvent(void)
      {
         _ASSERT(m_RetryEvent != NULL);

         SetEvent(m_RetryEvent);
      }

      //wrapper for calls to enable/disable a link using IConnectionRetryManager
      //Called by Dedicated thread or connection release thread
      BOOL ReleaseForRetry(IN char * szHashedDomainName);
      BOOL HoldForRetry(IN char * szHashedDomainName);

      CRETRY_HASH_TABLE* GetTablePtr(){return m_pRetryHash;}
      CRETRY_Q* GetQueuePtr(){return m_pRetryQueue;}
      
      HANDLE GetRetryEventHandle(void) const {return m_RetryEvent;}

      BOOL IsShuttingDown(void){ return m_fHandlerShuttingDown;}
      void SetShuttingDown(void){ m_fHandlerShuttingDown = TRUE;}

      //Called by the RetryThreadRoutine whenever it comes across a link entry that 
      // can be retried. Currently does not do much. Only Enables the link
      void ProcessEntry(CRETRY_HASH_ENTRY* pRHEntry);

      //The dedicated thread that keeps track of next link to be retried and wakes up and 
      //does that
      static DWORD WINAPI RetryThreadRoutine(void * ThisPtr);
        
      //Aqueue DLL wide ( cross instance ) init deinit
      static DWORD dwInstanceCount;

      //Will call back after the appropriate time has elapsed.
      HRESULT SetCallbackTime(IN RETRFN   pCallbackFn,
                              IN PVOID    pvContext,
                              IN DWORD    dwCallbackMinutes);

   public: //IConnectionRetrySink
      STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) {return E_NOTIMPL;};
      STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
      STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

      //Will be called by ConnectionManger every time a connection is released
      STDMETHOD(ConnectionReleased)( 
                           IN  DWORD cbDomainName,
                           IN  CHAR  szDomainName[],
                           IN  DWORD dwDomainInfoFlags,
                           IN  DWORD dwScheduleID,
                           IN  GUID  guidRouting,
                           IN  DWORD dwConnectionStatus,  
                           IN  DWORD cFailedMessages, 
                           IN  DWORD cTriedMessages,  
                           IN  DWORD cConsecutiveConnectionFailures,
                           OUT BOOL* pfAllowImmediateRetry,
                           OUT FILETIME *pftNextRetryTime);

   private :
      CRETRY_HASH_TABLE     *m_pRetryHash;
      CRETRY_Q              *m_pRetryQueue;
      DWORD                 m_dwRetryMilliSec;      // Retry interval based on config data
      IConnectionRetryManager *m_pIRetryManager;   // Interface to enable/disable link
      HANDLE                m_RetryEvent;           // Retry Release timeout event
      HANDLE                m_ShutdownEvent;      // Shutdown event
      HANDLE                m_ThreadHandle;         // Retry Thread handle
      BOOL                  m_fHandlerShuttingDown; // Shutdown flag
      BOOL                  m_fConfigDataUpdated;
      LONG                  m_ThreadsInRetry;      // Number of ConnectionManager threads
      
      DWORD                 m_dwRetryThreshold;
      DWORD                 m_dwGlitchRetrySeconds;
      DWORD                 m_dwFirstRetrySeconds;
      DWORD                 m_dwSecondRetrySeconds;
      DWORD                 m_dwThirdRetrySeconds;
      DWORD                 m_dwFourthRetrySeconds;



      //Calculates the time a link needs to be released for retry.
      //The time is based on the current time and the configured interval and
      //the history of connection failures for this particular host
      FILETIME CalculateRetryTime(DWORD cFailedConnections, FILETIME* InsertedTime);

      //Insert or remove domains from the retry handler ( hash table and the queue ) 
      //based on the Connection released call
      BOOL InsertDomain(char * szDomainName, 
                        IN  DWORD cbDomainName, //String length (in bytes) of domain name
                        IN  DWORD dwConnectionStatus,		//eConnectionStatus
                        IN  DWORD dwScheduleID,
                        IN  GUID  *pguidRouting,
                        IN  DWORD cConnectionFailureCount, 
                        IN  DWORD cTriedMessages, 	//# of untried messages in queue
						IN  DWORD cFailedMessages,		//# of failed message for *this* connection
                        OUT FILETIME *pftNextRetry  //next retry
						);
      BOOL RemoveDomain(char * szDomainName);
      BOOL UpdateAllEntries(void);


#ifdef DEBUG
    public :
      void DumpAll(void);
#endif


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\ptrwinst.h ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.h
//
//  Description:  Instramented share lock implementations.  Our current 
//      sharelock implementation is non-reentrant.  This wrapper can also
//      be used to check for possible deadlocks.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/10/99 - MikeSwa Created 
//      8/6/99 - MikeSwa created phatq version
//      11/6/99 - MikeSwa updated to use CShareLockNH
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __PTRWINST_H__
#define __PTRWINST_H__

#include "rwnew.h"
#include "listmacr.h"

#define SHARE_LOCK_INST_SIG         'kcoL'
#define SHARE_LOCK_INST_SIG_FREE    '!koL'


#define THREAD_ID_BLOCK_SIG         'klBT'
#define THREAD_ID_BLOCK_SIG_FREE    '!lBT'
#define THREAD_ID_BLOCK_UNUSED      0xFFFFFFFF 

//Flag values that describe the type of tracking to do
//These can be passed to the constructor to allow different levels of 
//tracking for different instances.
enum
{
    SHARE_LOCK_INST_TRACK_CONTENTION        = 0x00000001,
    SHARE_LOCK_INST_TRACK_SHARED_THREADS    = 0x00000002,
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS = 0x00000004,
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS = 0x00000008,
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST    = 0x00000010,
    SHARE_LOCK_INST_TRACK_NOTHING           = 0x80000000,
};

//Define some useful flag combinations

//This combination of flags has minimal perf impact, but does
//allow easier exclusive deadlock detection 
#define SHARE_LOCK_INST_TRACK_MINIMALS ( \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//This combination of flags uses all of the tracking functionality of
//this class.
#define SHARE_LOCK_INST_TRACK_ALL (\
    SHARE_LOCK_INST_TRACK_CONTENTION | \
    SHARE_LOCK_INST_TRACK_SHARED_THREADS | \
    SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS | \
    SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS | \
    SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST )

//A user can define their own defaults before including this file
//$$TODO - scale back the defaults for debug builds
#ifndef SHARE_LOCK_INST_TRACK_DEFAULTS
#ifdef DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_ALL
#else //not DEBUG
#define SHARE_LOCK_INST_TRACK_DEFAULTS SHARE_LOCK_INST_TRACK_MINIMALS
#endif //not DEBUG
#endif //SHARE_LOCK_INST_TRACK_DEFAULTS

#ifndef SHARE_LOCK_INST_DEFAULT_MAX_THREADS
#define SHARE_LOCK_INST_DEFAULT_MAX_THREADS 200
#endif //SHARE_LOCK_INST_DEFAULT_MAX_THREADS

//---[ CThreadIdBlock ]--------------------------------------------------------
//
//
//  Description: 
//      An structure that represents a thread and the required info to
//      hash it.
//  Hungarian: 
//      tblk, ptblk
//  
//-----------------------------------------------------------------------------
class CThreadIdBlock
{
  protected:
    DWORD            m_dwSignature;
    DWORD            m_dwThreadId;
    DWORD            m_cThreadRecursionCount;
    CThreadIdBlock  *m_ptblkNext;
  public:
    CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG;
        m_dwThreadId = THREAD_ID_BLOCK_UNUSED;
        m_cThreadRecursionCount = 0;
        m_ptblkNext = NULL;
    };
    ~CThreadIdBlock()
    {
        m_dwSignature = THREAD_ID_BLOCK_SIG_FREE;
        if (m_ptblkNext)
            delete m_ptblkNext;
        m_ptblkNext = NULL;
    };

    DWORD   cIncThreadCount(DWORD dwThreadId);
    DWORD   cDecThreadCount(DWORD dwThreadId);
    DWORD   cMatchesId(DWORD dwThreadId);
};

//---[ dwHashThreadId ]--------------------------------------------------------
//
//
//  Description: 
//      Given a thread ID (return by GetCurrentThreadId()) it returns a hashed
//      index.  This is designed to be used in conjuction with a array (of
//      size dwMax) of CThreadIdBlock's.  Each CThreadIdBlock will implement
//      linear chaining.  A hash lookup can be implemented by somehthing as
//      simple as:
//          rgtblk[dwhashThreadId(GetCurrentThreadId()), 
//                                sizeof(rgtblk)].cIncThreadCount();
//  Parameters:
//      dwThreadId      Thread Id to hash
//      dwMax           Max hash value (actual max value +1)
//  Returns:
//      Hashed thread Id
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline DWORD dwHashThreadId(DWORD dwThreadId, DWORD dwMax)
{
    //Typically IDs are between 0x100 and 0xFFF
    //Also, the handles are multiples of 4 (ie end in 0, 4, 8, or C)
    //For these conditions, this hash will give unique results for
    //dwMax of 1000. (0xFFF-0x100)/4 < 1000
    const   DWORD   dwMinExpectedThread = 0x100;
    DWORD   dwHash = dwThreadId;

    dwHash -= dwMinExpectedThread;
    dwHash >>= 2;
    dwHash %= dwMax;
    return dwHash;
};

typedef CShareLockNH  CShareLockInstBase;
//---[ CShareLockInst ]--------------------------------------------------------
//
//
//  Description: 
//      An intstramented version of CShareLockInstBase
//  Hungarian: 
//      sli, psli
//  
//-----------------------------------------------------------------------------
class CShareLockInst : public CShareLockInstBase
{
  protected:
    //Static lock-tracking variables
    static              LIST_ENTRY  s_liLocks;
    static volatile     DWORD       s_dwLock;
    static              DWORD       s_cLockSpins;
    static              DWORD       s_dwSignature;

    static inline void AcquireStaticSpinLock();
    static inline void ReleaseStaticSpinLock();
  protected:
    DWORD               m_dwSignature;

    //Flags describing types of tracking to be performed
    DWORD               m_dwFlags;

    //List entry for list of all locks  - used by a debugger extension
    LIST_ENTRY          m_liLocks;

    //The total number of attempts to enter this lock in a shared mode
    DWORD               m_cShareAttempts;

    //The total number of attempts to enter shared that blocked
    DWORD               m_cShareAttemptsBlocked;

    //The total number ot attempts to enter this lock exclusively
    DWORD               m_cExclusiveAttempts;

    //The total number ot attempts to enter this lock exclusively that blocked
    DWORD               m_cExclusiveAttemptsBlocked;

    //Constant string descrition passed in 
    LPCSTR              m_szDescription;

    //ID of the thread that holds this lock exclusively
    DWORD               m_dwExclusiveThread;

    //Array of thread IDs that hold this lock shared
    CThreadIdBlock     *m_rgtblkSharedThreadIDs;

    //Maximum number of shared threads that can be tracked
    DWORD               m_cMaxTrackedSharedThreadIDs;

    //The current number of shared threads
    DWORD               m_cCurrentSharedThreads;

    //The most theads that have ever held this lock shared
    DWORD               m_cMaxConcurrentSharedThreads;

    //Used internally, to see if the private functions need to be called
    inline BOOL    fTrackingEnabled();
    

    BOOL    fTrackContention() 
        {return (SHARE_LOCK_INST_TRACK_CONTENTION & m_dwFlags);};

    BOOL    fTrackSharedThreads()
        {return (m_cMaxTrackedSharedThreadIDs && 
                (SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags));};

    BOOL    fTrackExclusiveThreads() 
        {return (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags);};

    BOOL    fAssertSharedDeadlocks() 
        {return (fTrackSharedThreads() && 
                (SHARE_LOCK_INST_ASSERT_SHARED_DEADLOCKS & m_dwFlags));};

    BOOL    fTrackInGlobalList()
        {return (SHARE_LOCK_INST_TRACK_IN_GLOBAL_LIST & m_dwFlags);};

    //statisics helper functions
    void LogAcquireShareLock(BOOL fTry);
    void LogReleaseShareLock();

    void PrvShareLock();
    void PrvShareUnlock();
    BOOL PrvTryShareLock();
    void PrvExclusiveLock();
    void PrvExclusiveUnlock();
    BOOL PrvTryExclusiveLock();

    void PrvAssertIsLocked();
  public:
    CShareLockInst(
        LPCSTR szDescription = NULL,
        DWORD dwFlags = SHARE_LOCK_INST_TRACK_DEFAULTS, 
        DWORD cMaxTrackedSharedThreadIDs = SHARE_LOCK_INST_DEFAULT_MAX_THREADS);

    ~CShareLockInst();

    //wrappers for sharelock functions
    inline void ShareLock();
    inline void ShareUnlock();
    inline BOOL TryShareLock();
    inline void ExclusiveLock();
    inline void ExclusiveUnlock();
    inline BOOL TryExclusiveLock();

    inline void AssertIsLocked();

};

//---[ inline ShareLock wrapper functions ]------------------------------------
//
//
//  Description: 
//      These functions are all thin wrappers for the sharelock wrapper 
//      functions.  If there is any tracking enabled for this object, then 
//      the private (non-inline) functions are called.
//
//      The idea is that you should be able to have these sharelocks in your
//      code with minimal perf-impact when logging is turned off.
//  Parameters:
//      
//  Returns:
//
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::ShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareLock();
    else
        CShareLockInstBase::ShareLock();
};


void CShareLockInst::ShareUnlock()
{
    if (fTrackSharedThreads() || fAssertSharedDeadlocks())
        PrvShareUnlock();
    else
        CShareLockInstBase::ShareUnlock();
};

BOOL CShareLockInst::TryShareLock()
{
    if (fTrackContention() || fTrackSharedThreads() || fAssertSharedDeadlocks())
        return PrvTryShareLock();
    else
        return CShareLockInstBase::TryShareLock();
};

void CShareLockInst::ExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        PrvExclusiveLock();
    else
        CShareLockInstBase::ExclusiveLock();
};

void CShareLockInst::ExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
        PrvExclusiveUnlock();
    else
        CShareLockInstBase::ExclusiveUnlock();
};

BOOL CShareLockInst::TryExclusiveLock()
{
    if (fTrackContention() || fTrackExclusiveThreads())
        return PrvTryExclusiveLock();
    else
        return CShareLockInstBase::TryExclusiveLock();
};


//---[ AssertIsLocked ]--------------------------------------------------------
//
//
//  Description: 
//      In Debug code, will assert if this is not locked by the calling thread.
//      NOTE: This requires the following flags are specified at object
//      creation time:
//          SHARE_LOCK_INST_TRACK_SHARED_THREADS
//          SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::AssertIsLocked()
{
#ifdef DEBUG
    if ((SHARE_LOCK_INST_TRACK_SHARED_THREADS & m_dwFlags) &&
        (SHARE_LOCK_INST_TRACK_EXCLUSIVE_THREADS & m_dwFlags))
    {
        PrvAssertIsLocked();
    }
#endif //DEBUG
};

#endif //__PTRWINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\dsnsink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnsink.h
//
//  Description: Header file for CDefaultDSNSink - Default DSN Generation Sink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/30/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNSINK_H__
#define __DSNSINK_H__

#include <aqintrnl.h>
#include <baseobj.h>

#define DSN_SINK_SIG 'sNSD'
#define DSN_SINK_SIG_FREED 'NSD!'

class CDSNBuffer;

//Limit on the MIME boundary string set by RFC2046
#define MIME_BOUNDARY_RFC2046_LIMIT 70

//RFCs 2045-2048 suggests that we inlcude "=_" somewhere in the MIME Boundry
#define MIME_BOUNDARY_CONSTANT "9B095B5ADSN=_"
#define MIME_BOUNDARY_START_TIME_SIZE 16*sizeof(CHAR) //Size of string with file-time
#define MIME_BOUNDARY_SIZE MIME_BOUNDARY_START_TIME_SIZE + \
            sizeof(MIME_BOUNDARY_CONSTANT) + \
            24*sizeof(CHAR) //room for 8 char count and portion of host name

//needs room for "x.xxx.xxx", plus an optional comment
#define MAX_STATUS_COMMENT_SIZE 50
#define STATUS_STRING_SIZE      10+MAX_STATUS_COMMENT_SIZE

//
// The default implementation of the DSN Generation sink
//
class CDefaultDSNSink :
    public IDSNGenerationSink
{
  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    //
    // This class is allocated as a part of another object. Pass
    // AddRef/Release to the parent object
    //
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return m_pUnk->AddRef();
    }
    STDMETHOD_(ULONG, Release)(void)
    {
        return m_pUnk->Release();
    }
  public: //IDSNGenerationSink
    STDMETHOD(OnSyncSinkInit) (
        IN  DWORD                        dwVSID);

    STDMETHOD(OnSyncGetDSNRecipientIterator) (
        IN  ISMTPServer                 *pISMTPServer,
        IN  IMailMsgProperties          *pIMsg,
        IN  IMailMsgPropertyBag         *pDSNProperties,
        IN  DWORD                        dwStartDomain,
        IN  DWORD                        dwDSNActions,
        IN  IDSNRecipientIterator       *pRecipIterIN,
        OUT IDSNRecipientIterator     **ppRecipIterOUT);

    STDMETHOD(OnSyncGenerateDSN) (
        IN  ISMTPServer                 *pISMTPServer,
        IN  IDSNSubmission              *pIDSNSubmission,
        IN  IMailMsgProperties          *pIMsg,
        IN  IMailMsgPropertyBag         *pDSNProperties,
        IN  IDSNRecipientIterator       *pRecipIter);

    STDMETHOD(OnSyncPostGenerateDSN) (
        IN  ISMTPServer                 *pISMTPServer,
        IN  IMailMsgProperties          *pIMsgOrig,
        IN  DWORD                        dwDSNAction,
        IN  DWORD                        cRecipsDSNd,
        IN  IMailMsgProperties          *pIMsgDSN,
        IN  IMailMsgPropertyBag         *pDSNProperties)
    {
        return E_NOTIMPL;
    }

#define SIGNATURE_CDEFAULTDSNSINK           (DWORD)'NSDC'
#define SIGNATURE_CDEFAULTDSNSINK_INVALID   (DWORD)'NSDX'

    CDefaultDSNSink(IUnknown *pUnk);
    ~CDefaultDSNSink()
    {
        _ASSERT(m_dwSig == SIGNATURE_CDEFAULTDSNSINK);
        m_dwSig = SIGNATURE_CDEFAULTDSNSINK_INVALID;
    }
    HRESULT HrInitialize();

  private:
    HRESULT HrGenerateDSNInternal(
        ISMTPServer *pISMTPServer,
        IMailMsgProperties *pIMailMsgProperties,
        IDSNRecipientIterator *pIRecipIter,
        IDSNSubmission *pIDSNSubmission,
        DWORD dwDSNActions,
        DWORD dwRFC821Status,
        HRESULT hrStatus,
        LPSTR szDefaultDomain,
        DWORD cbDefaultDomain,
        LPSTR szReportingMTA,
        DWORD cbReportingMTA,
        LPSTR szReportingMTAType,
        DWORD cbReportingMTAType,
        LPSTR szDSNContext,
        DWORD cbDSNContext,
        DWORD dwPreferredLangId,
        DWORD dwDSNOptions,
        LPSTR szCopyNDRTo,
        DWORD cbCopyNDRTo,
        FILETIME *pftExpireTime,
        LPSTR szHRTopCustomText,
        LPWSTR wszHRTopCustomText,
        LPSTR szHRBottomCustomText,
        LPWSTR wszHRBottomCustomText,
        IMailMsgProperties **ppIMailMsgPropertiesDSN,
        DWORD *pdwDSNTypesGenerated,
        DWORD *pcRecipsDSNd,
        DWORD *pcIterationsLeft,
        DWORD dwDSNRetType,
        HRESULT hrContentFailure);

    //Used to mark all recipient flags, when there is no per recip processing
    //happening (like NDR of DSN).
    HRESULT HrMarkAllRecipFlags(
        IN  DWORD dwDSNActions,
        IN  IDSNRecipientIterator *pIRecipIter);

    VOID GetCurrentIterationsDSNAction(
        IN OUT DWORD *pdwActualDSNAction,
        IN OUT DWORD *pcIterationsLeft);

    //Writes global DSN P1 Properties to IMailMsgProperties and P2 headers to content
    HRESULT HrWriteDSNP1AndP2Headers(
        IN DWORD dwDSNAction,
        IN IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgProperties *pIMailMsgPropertiesDSN,
        IN CDSNBuffer *pdsnbuff,
        IN LPSTR szDefaultDomain,
        IN DWORD cbDefaultDomain,
        IN LPSTR szReportingMTA,
        IN DWORD cbReportingMTA,
        IN LPSTR szDSNContext,
        IN DWORD cbDSNContext,
        IN LPSTR szCopyNDRTo,
        IN HRESULT hrStatus,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary,
        IN DWORD dwDSNOptions,
        IN HRESULT hrContent);

    //Write human readable portion of DSN
    HRESULT HrWriteDSNHumanReadable(
        IN IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgRecipients *pIMailMsgRecipients,
        IN IDSNRecipientIterator *pIRecipIter,
        IN DWORD dwDSNActions,
        IN CDSNBuffer *pdsnbuff,
        IN DWORD dwPreferredLangId,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary,
        IN HRESULT hrStatus,
        IN LPSTR szHRTopCustomText,
        IN LPWSTR wszHRTopCustomText,
        IN LPSTR szHRBottomCustomText,
        IN LPWSTR wszHRBottomCustomText);

    //Write the per-msg portion of the DSN Report
    HRESULT HrWriteDSNReportPerMsgProperties(
        IN IMailMsgProperties *pIMailMsgProperties,
        IN CDSNBuffer *pdsnbuff,
        IN LPSTR szReportingMTA,
        IN DWORD cbReportingMTA,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary);

    //Write a per-recipient portion of the DSN Report
    HRESULT HrWriteDSNReportPreRecipientProperties(
        IN IMailMsgRecipients *pIMailMsgRecipients,
        IN CDSNBuffer *pdsnbuff,
        IN DWORD iRecip,
        IN LPSTR szExpireTime,
        IN DWORD cbExpireTime,
        IN DWORD dwDSNAction,
        IN DWORD dwRFC821Status,
        IN HRESULT hrStatus);

    //Logs events for DSN generation
    HRESULT HrLogDSNGenerationEvent(
        ISMTPServer *pISMTPServer,
        IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgRecipients *pIMailMsgRecipients,
        IN DWORD iRecip,
        IN DWORD dwDSNAction,
        IN DWORD dwRFC821Status,
        IN HRESULT hrStatus);

    //Writes last mime-headers, flush dsnbuffer, and copy original message
    HRESULT HrWriteDSNClosingAndOriginalMessage(
        IN IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgProperties *pIMailMsgPropertiesDSN,
        IN CDSNBuffer *pdsnbuff,
        IN PFIO_CONTEXT pDestFile,
        IN DWORD   dwDSNAction,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary,
        IN DWORD dwDSNRetType,
        IN DWORD dwOrigMsgSize);

    void GetCurrentMimeBoundary(
        IN LPSTR szReportingMTA,
        IN DWORD cbReportingMTA,
        IN OUT CHAR szMimeBoundary[MIME_BOUNDARY_SIZE],
        OUT DWORD *pcbMimeBoundary);

    //Writes the original full message to the third DSN part
    HRESULT HrWriteOriginalMessageFull(
        IN IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgProperties *pIMailMsgPropertiesDSN,
        IN CDSNBuffer *pdsnbuff,
        IN PFIO_CONTEXT pDestFile,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary,
        IN DWORD dwOrigMsgSize);

    //Write only some headers of the orignal message to the third DSN part
    HRESULT HrWriteOriginalMessagePartialHeaders(
        IN IMailMsgProperties *pIMailMsgProperties,
        IN IMailMsgProperties *pIMailMsgPropertiesDSN,
        IN CDSNBuffer *pdsnbuff,
        IN PFIO_CONTEXT pDestFile,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary);

    //Write MIME headers to finish message
    HRESULT HrWriteMimeClosing(
        IN CDSNBuffer *pdsnbuff,
        IN LPSTR szMimeBoundary,
        IN DWORD cbMimeBoundary,
        OUT DWORD *pcbDSNSize);

    //Gets the per-recipient DSN status code
    HRESULT HrGetStatusCode(
        IN IMailMsgRecipients *pIMailMsgRecipients,
        IN DWORD iRecip,
        IN DWORD dwDSNAction,
        IN DWORD dwStatus,
        IN HRESULT hrStatus,
        IN DWORD cbExtendedStatus,
        IN OUT LPSTR szExtendedStatus,
        IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    //Parse status code from RFC2034 extended status code string
    HRESULT HrGetStatusFromStatus(
        IN DWORD cbExtendedStatus,
        IN OUT LPSTR szExtendedStatus,
        IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    //Determine status based on supplied context information
    HRESULT HrGetStatusFromContext(
        IN HRESULT hrRecipient,
        IN DWORD   dwRecipFlags,
        IN DWORD   dwDSNAction,
        IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    HRESULT HrGetStatusFromRFC821Status(
        IN DWORD    dwRFC821Status,
        IN OUT CHAR szStatus[STATUS_STRING_SIZE]);

    //Writes a list of recipients being DSN'd... one per line
    HRESULT HrWriteHumanReadableListOfRecips(
        IN IMailMsgRecipients *pIMailMsgRecipients,
        IN IDSNRecipientIterator *pIRecipIter,
        IN DWORD dwDSNActionsNeeded,
        IN CDSNBuffer *pdsnbuff);

    //Get the recipient address and type... checks multple mailmsg props
    HRESULT HrGetRecipAddressAndType(
        IN     IMailMsgRecipients *pIMailMsgRecipients,
        IN     DWORD iRecip,
        IN     DWORD cbAddressBuffer,
        IN OUT LPSTR szAddressBuffer,
        IN     DWORD cbAddressType,
        IN OUT LPSTR szAddressType);

  private:
    DWORD       m_dwSig;
    IUnknown   *m_pUnk;
    DWORD       m_dwVSID;
    DWORD       m_cDSNsRequested;
    BOOL        m_fInit;
    CHAR        m_szPerInstanceMimeBoundary[MIME_BOUNDARY_START_TIME_SIZE + 1];
};

//---[ CDSNGenerator ]-------------------------------------------------------
//
//
//  Description:
//      Default DSN Generation sink...
//  Hungarian:
//      dsnsink, pdsnsink
//
//-----------------------------------------------------------------------------
class CDSNGenerator
{
  protected:
    DWORD       m_dwSignature;

  public:
    CDSNGenerator(IUnknown *pUnk);
    ~CDSNGenerator();
    HRESULT HrInitialize()
    {
        return m_CDefaultDSNSink.HrInitialize();
    }

  public:
    STDMETHOD(GenerateDSN)(
        IAQServerEvent *pIServerEvent,
        DWORD dwVSID,
        ISMTPServer *pISMTPServer,
        IMailMsgProperties *pIMailMsgProperties,
        DWORD dwStartDomain,
        DWORD dwDSNActions,
        DWORD dwRFC821Status,
        HRESULT hrStatus,
        LPSTR szDefaultDomain,
        LPSTR szReportingMTA,
        LPSTR szReportingMTAType,
        LPSTR szDSNContext,
        DWORD dwPreferredLangId,
        DWORD dwDSNOptions,
        LPSTR szCopyNDRTo,
        FILETIME *pftExpireTime,
        IDSNSubmission *pIAQDSNSubmission,
        DWORD dwMaxDSNSize);

    HRESULT HrTriggerGetDSNRecipientIterator(
        IAQServerEvent *pIServerEvent,
        DWORD dwVSID,
        ISMTPServer *pISMTPServer,
        IMailMsgProperties *pIMsg,
        IMailMsgPropertyBag *pIDSNProperties,
        DWORD dwStartDomain,
        DWORD dwDSNActions,
        IDSNRecipientIterator **ppIRecipIterator);

    HRESULT HrTriggerGenerateDSN(
        IAQServerEvent *pIServerEvent,
        DWORD dwVSID,
        ISMTPServer *pISMTPServer,
        IDSNSubmission *pIDSNSubmission,
        IMailMsgProperties *pIMsg,
        IMailMsgPropertyBag *pIDSNProperties,
        IDSNRecipientIterator *pIRecipIterator);

    HRESULT HrTriggerPostGenerateDSN(
        IAQServerEvent *pIServerEvent,
        DWORD dwVSID,
        ISMTPServer *pISMTPServer,
        IMailMsgProperties *pIMsgOrig,
        DWORD dwDSNAction,
        DWORD cRecipsDSNd,
        IMailMsgProperties *pIMsgDSN,
        IMailMsgPropertyBag *pIDSNProperties);

    static HRESULT HrStaticInit();
    static VOID StaticDeinit();

  private:
    HRESULT HrSetRetType(
        IN  DWORD dwMaxDSNSize,
        IN  IMailMsgProperties *pIMsg,
        IN  IMailMsgPropertyBag *pDSNProps);

  private:
    CDefaultDSNSink m_CDefaultDSNSink;
};

#endif //__DSNSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\fifoq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoq.h
//
//  Description:    
//      FifoQueue class definition.  Provides a high-speed memory 
//      efficient growable FIFO queue for COM-style objects that 
//      support addref and release.
//
//  Author:         mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _FIFOQ_H_
#define _FIFOQ_H_

#include <aqincs.h>
#include <rwnew.h>

#define FIFOQ_SIG   'euQF'
template<class PQDATA>
class CFifoQueuePage;

//---[ CFifoQueue ]------------------------------------------------------------
//
//
//    Hungarian: fq, pfq
//
//  Implements a FIFO Queue for COM objects (or any objects that supports 
//  addref and release).  Provides the ability to peek, requeue, and maintain a 
//  cursor into the queue in addition to the normal queue operations.
//
//-----------------------------------------------------------------------------
template<class PQDATA>
class CFifoQueue
{
public:
    typedef HRESULT (*MAPFNAPI)(PQDATA, PVOID, BOOL*, BOOL*); //function type for MapFn

    CFifoQueue();
    ~CFifoQueue();

    //static startup and shutdown operations
    //These are ref counted and can be called multiple times
    //Eventually we might decide to modify the size of the free list based
    //on the number of references.
    static  void       StaticInit();
    static  void       StaticDeinit();

    //Normal Queue operations
    HRESULT HrEnqueue(IN PQDATA pqdata);   //Data to enqueue
    HRESULT HrDequeue(OUT PQDATA *ppqdata); //Data dequeued
               

    //Insert at the front of the queue
    HRESULT HrRequeue(IN PQDATA pqdata); //Data to requeue
                
    
    //Return the data at the head of the queue without dequeuing
    HRESULT HrPeek(OUT PQDATA *ppqdata); //Data peeked
                
    
    //returns the number of entries in the queue
    DWORD   cGetCount() {return m_cQueueEntries;};  

    //Advances the secondary cursor until supplied function  returns FALSE
    //  The pFunc parameter must be a function with the following prototype:
    //
    //      HRESULT pvFunc(
    //                 IN  PQDATA pqdata,  //ptr to data on queue
    //                 IN  PVOID pvContext, //context passed to function
    //                 OUT BOOL *pfContinue, //TRUE if we should continue
    //                 OUT BOOL *pfDelete);  //TRUE if item should be deleted
    //   pFunc must NOT release pqdata.. if it is no longer valid, it should
    //   return TRUE in pfDelete, and the calling code will remove it from
    //   the queue and release it. 
    //   NOTE: the MAPFNAPI is CFifoQueue<PQDATA>::MAPFNAPI and is 
    //   specific to the type of template
    HRESULT HrMapFn(
                IN MAPFNAPI pFunc,          //ptr to function to map
                IN PVOID    pvContext,      //context to pass to function
                OUT DWORD *pcItems);        //number of items mapped
    
protected:
#ifdef DEBUG
    void           AssertQueueFn(BOOL fHaveLocks = FALSE);
#endif //DEBUG
    typedef        CFifoQueuePage<PQDATA>  FQPAGE;
    DWORD          m_dwSignature;
    DWORD          m_cQueueEntries;  //Count of entries in queue
    FQPAGE        *m_pfqpHead;       //First Queue Page
    FQPAGE        *m_pfqpTail;       //Tail Page of queue
    FQPAGE        *m_pfqpCursor;     //Page that the cursor is on
    PQDATA        *m_ppqdataHead;    //Next item to be grabbed
    PQDATA        *m_ppqdataTail;    //First free space available
    PQDATA        *m_ppqdataCursor;  //secondary queue cursor that is
                                              //between the head and the tail 
                                              //of the queue 
    CShareLockNH   m_slTail; //CS for updating tail ptr & page
    CShareLockNH   m_slHead; //CS for updating head ptr & page
    
    //Adjusts head  ptr for dequeue and peek
    HRESULT HrAdjustHead(); 

    //Static Methods and variables to manage a free list of queue pages
    volatile static  FQPAGE    *s_pfqpFree;      //Pointer to free page list
    static  DWORD               s_cFreePages;    //Count of pages on free list
    static  DWORD               s_cFifoQueueObj; //Count of queue objects
    static  DWORD               s_cStaticRefs;   //# of calls to HrStaticInit
    static  CRITICAL_SECTION    s_csAlloc;       //Protect against ABA in alloc

    static  HRESULT         HrAllocQueuePage(
                                OUT FQPAGE **ppfqp); //allocated page
    static  void            FreeQueuePage(FQPAGE *pfqp);
    static  void            FreeAllQueuePages(); //Free all pages at shutdown

#ifdef DEBUG
    //use when making changes to do basic tracking of memory leaks
    static  DWORD           s_cAllocated;       //Count of allocated queue pages
    static  DWORD           s_cDeleted;         //Count of deleted queue pages
    static  DWORD           s_cFreeAllocated;   //allocations from free list
    static  DWORD           s_cFreeDeleted;     //number of calls to add to free list
#endif //DEBUG

};

//Example HrMapFn Function that will clear the queue.
template <class PQDATA>
HRESULT HrClearQueueMapFn(IN PQDATA pqdata, OUT BOOL *pfContinue, OUT BOOL *pfDelete);


#endif // _FIFOQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\hashentr.h ===
////////////////////////////////////////////////////////////////////////////////////////////////
// FILE: hashentr.h
// PURPOSE: hash entry in the retry hash table
// HISTORY:
//  NimishK 05-14-98 Created
///////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __HASHENTR_H__
#define __HASHENTR_H__

#include <hshroute.h>

#define	MAX_RETRY_DOMAIN_NAME_LEN       (258 + ROUTE_HASH_PREFIX_SIZE)
#define RETRY_ENTRY_SIGNATURE_VALID		'reSV'
#define RETRY_ENTRY_SIGNATURE_FREE		'reSF'

typedef VOID (*CALLBACKFN)(PVOID pvContext);
#define INVALID_CALLBACK ((CALLBACKFN)(~0))

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_ENTRY:
//
// An entry in the retry hash table. We will also add the same entry into a queue
// ordered by retry time. A dedicated thread will walk the thread to retry domains
// if it is time.
// The hash key is the name of the domain
// Need to add CPool backed memory allocation
//
/////////////////////////////////////////////////////////////////////////////////

class CRETRY_HASH_ENTRY
{

    public:
    //One Cpool for all entries in all instances of the retry table
    static CPool       PoolForHashEntries;

    // override the mem functions to use CPool functions
    void *operator new (size_t cSize)
							    { return PoolForHashEntries.Alloc(); }
    void operator delete (void *pInstance)
							    { PoolForHashEntries.Free(pInstance); }

    protected:
        DWORD		m_Signature;
        LONG		m_RefCount;
        BOOL		m_InQ;
        BOOL		m_InTable;
        FILETIME	m_ftEntryInsertedTime;
        FILETIME	m_ftRetryTime;
        DWORD       m_cFailureCount;
        CALLBACKFN  m_pfnCallbackFn;
        PVOID       m_pvCallbackContext;
        char		m_szDomainName[MAX_RETRY_DOMAIN_NAME_LEN];

    public:
        LIST_ENTRY  m_QLEntry;  //List Entry for adding to RETRYQ
        LIST_ENTRY  m_HLEntry;  //List Entry for adding to BUCKET queue in HASH table

    CRETRY_HASH_ENTRY(char * szDomainName, DWORD cbDomainName,
                      DWORD dwScheduleID, GUID *pguidRouting,
                      FILETIME* InsertedTime)
    {
        m_Signature = RETRY_ENTRY_SIGNATURE_VALID;
        m_RefCount = 0;
        m_InQ = FALSE;
        m_InTable = FALSE;
        m_ftEntryInsertedTime = *InsertedTime;
        m_pvCallbackContext = NULL;
        m_pfnCallbackFn = NULL;

        //Hash schedule ID and router guid to domain name
        CreateRouteHash(cbDomainName, szDomainName, ROUTE_HASH_SCHEDULE_ID,
                        pguidRouting, dwScheduleID, m_szDomainName, sizeof(m_szDomainName));
#ifdef DEBUG
        m_hTranscriptHandle = INVALID_HANDLE_VALUE;
        m_szTranscriptFile[0] = '\0';
#endif

    }

    //Query list entries
    LIST_ENTRY & QueryHListEntry(void) {return ( m_HLEntry);}
    LIST_ENTRY & QueryQListEntry(void) {return ( m_QLEntry);}

    //Domain name used as HASH key
    void SetHashKey(char * SearchData) { lstrcpy(m_szDomainName,SearchData);}
    char * GetHashKey(void) { return m_szDomainName;}

    //Insert and RetryTimes
    void SetInsertTime(FILETIME* ftEntryInsertTime) { m_ftEntryInsertedTime = *ftEntryInsertTime;}
    void SetRetryReleaseTime(FILETIME* ftRetryTime) { m_ftRetryTime = *ftRetryTime;}
    FILETIME GetInsertTime(void){return m_ftEntryInsertedTime;}
    FILETIME GetRetryTime(void){return m_ftRetryTime;}
    DWORD GetFailureCount(void){return m_cFailureCount;}
    void  SetFailureCount(DWORD cFailureCount){m_cFailureCount = cFailureCount;}

    void SetInQ(void) { m_InQ = TRUE;}
    void ClearInQ(void) { m_InQ = FALSE;}
    BOOL GetInQ(void) { return m_InQ;}

    void SetInTable(void) { m_InTable = TRUE;}
    void ClearInTable(void) { m_InTable = FALSE;}
    BOOL GetInTable(void) { return m_InTable;}

    BOOL IsValid() { return(m_Signature == RETRY_ENTRY_SIGNATURE_VALID);}

    //Support for having non-domain based callback functions
    BOOL IsCallback() {return(NULL != m_pfnCallbackFn);};
    void ExecCallback()
    {
        _ASSERT(m_pfnCallbackFn);
        _ASSERT(INVALID_CALLBACK != m_pfnCallbackFn);
        //don't want to call twice, and don't want IsCallBack() to change
        m_pfnCallbackFn(m_pvCallbackContext);
        m_pfnCallbackFn = INVALID_CALLBACK;
    };
    void SetCallbackContext(CALLBACKFN pfnCallbackFn, PVOID pvCallbackContext)
    {
        _ASSERT(pfnCallbackFn);
        _ASSERT(INVALID_CALLBACK != pfnCallbackFn);
        m_pfnCallbackFn = pfnCallbackFn;
        m_pvCallbackContext = pvCallbackContext;
    };

    //Ref counting on the hash entry
    // Insertion into Hash table adds one and insertion into queue adds one
    LONG QueryRefCount(void){return m_RefCount;}
    LONG IncRefCount(void){return InterlockedIncrement(&m_RefCount);}
    void DecRefCount(void)
    {
        //
        if(InterlockedDecrement(&m_RefCount) == 0)
        {
            //we should not be in the retryQ if the ref
            //count is zero
            _ASSERT(m_InQ == FALSE);
            _ASSERT(m_InTable == FALSE);
            delete this;
        }
    }

    ~CRETRY_HASH_ENTRY()
    {
        m_Signature = RETRY_ENTRY_SIGNATURE_FREE;
        _ASSERT(m_InQ == FALSE);
        _ASSERT(m_InTable == FALSE);
#ifdef DEBUG
            //Close the transcript file
        if (INVALID_HANDLE_VALUE != m_hTranscriptHandle)
            _VERIFY(CloseHandle(m_hTranscriptHandle));
#endif
    }

#ifdef DEBUG
    public:
        HANDLE m_hTranscriptHandle;
        char   m_szTranscriptFile[MAX_PATH];
#endif


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\retrsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\main.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: main.cpp
//
//  Description: Main file for SMTP retry sink
//
//  Author: NimishK
//
//  History:
//      7/15/99 - MikeSwa Moved to Platinum
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"

//constants
//
#define MAX_RETRY_OBJECTS 15000

#define DEFAULT_GLITCH_FAILURE_THRESHOLD 3
#define DEFAULT_FIRST_TIER_RETRY_THRESHOLD  6

#define DEFAULT_GLITCH_FAILURE_RETRY_SECONDS (1 * 60)  // retry a glitch intwo minutes
#define DEFAULT_FIRST_TIER_RETRY_SECONDS  (15 * 60)    // retry a failure in 15 minutes
#define DEFAULT_SECOND_TIER_RETRY_SECONDS  (60 * 60)   // retry a failure in 60 minutes

// provide memory for static declared in RETRYHASH_ENTRY
//
CPool CRETRY_HASH_ENTRY::PoolForHashEntries(RETRY_ENTRY_SIGNATURE_VALID);
DWORD CSMTP_RETRY_HANDLER::dwInstanceCount = 0;

//Forward declarations
//
BOOL ShouldHoldForRetry(DWORD dwConnectionStatus,
                        DWORD cFailedMsgCount,
                        DWORD cTriedMsgCount);

//Debugging related
//
#define LOGGING_DIRECTORY "c:\\temp\\"
enum DEBUGTYPE
{
    INSERT,
    UPDATE
};
#ifdef DEBUG
void WriteDebugInfo(CRETRY_HASH_ENTRY* pRHEntry,
                    DWORD DebugType,
                    DWORD dwConnectionStatus,
                    DWORD cTriedMessages,
                    DWORD cFailedMessages);
#endif

//--------------------------------------------------------------------------------
// Logic :
//      In a normal state every hashentry is added to a retry hash and
//      a retry queue strcture.
//      An entry is considered deleted when removed from both structures.
//      The deletion could happen in two ways depending on the sequence in
//      which the entry is removed from the two structres.
//      For eg : when an entry is to be released from retry, we start by
//      dequeing it from RETRYQ and then remove it from hash table.
//      On the other hand when we get successful ConnectionReleased( ) for
//      a domain that we are holding fro retry, we remove it from the hash
//      table first based on the name.
//      The following is the logic for deletion that has least contention and
//      guards against race conditions.
//      Every hash entry has normally two ref counts - one for hash table and
//      the other for the retry queue.
//      If a thread gets into ProcessEntry(), that means it dequed a
//      hash entry from RETRYQ. Obviously no other thread is going to
//      succeed in dequeing this same entry.
//      Some other thread could possibily remove it from the table, but
//      will not succeed in dequeing it from RETRYQ.
//      The deletion logic is that only the thread succeeding in dequing
//      the hash entry from RETRYQ frees it up.
//      The conflicting thread that removed the entry from hashtable via a
//      call to RemoveDomain() will fail on deque and simply carry on.
//      The thread that succeeded in dequeing may fail to remove it from hash
//      table becasue somebody has already removed it, but still goes ahead
//      and frees up the hash entry
//--------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::HrInitialize
//
//
//------------------------------------------------------------------------------
//
HRESULT CSMTP_RETRY_HANDLER::HrInitialize(IN IConnectionRetryManager *pIConnectionRetryManager)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::HrInitialize");
    //Decide if we need to copy over data from earlier sink

    _ASSERT(pIConnectionRetryManager != NULL);

    if(!pIConnectionRetryManager)
    {
        ErrorTrace((LPARAM)this, "Bad Init params");
        return E_FAIL;
    }

    m_pIRetryManager = pIConnectionRetryManager;
    m_ThreadsInRetry = 0;



    if(InterlockedIncrement((LONG*)&CSMTP_RETRY_HANDLER::dwInstanceCount) == 1)
    {
        //First instance to come in reserves the memory for the retry entries
        if (!CRETRY_HASH_ENTRY::PoolForHashEntries.ReserveMemory( MAX_RETRY_OBJECTS,
                                                            sizeof(CRETRY_HASH_ENTRY)))
        {
            DWORD err = GetLastError();
            ErrorTrace((LPARAM)NULL,
                "ReserveMemory failed for CRETRY_HASH_ENTRY. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
	            err = ERROR_NOT_ENOUGH_MEMORY;
            TraceFunctLeaveEx((LPARAM)NULL);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //Initialize Hash Table
    m_pRetryHash = new CRETRY_HASH_TABLE();

    if(!m_pRetryHash || !m_pRetryHash->IsHashTableValid())
    {
        ErrorTrace((LPARAM)this, "Failed to initialize the hash table ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return E_FAIL;
    }

    //Create the retry queue
    m_pRetryQueue = CRETRY_Q::CreateQueue();
    if(!m_pRetryQueue)
    {
        ErrorTrace((LPARAM)this, "Failed to initialize the retry queue ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return E_FAIL;
    }

    //create the Retry queue event. Others will set this event
    //when something is placed at the top of the queue or when
    //Sink needs to shutdown
    //
    m_RetryEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_RetryEvent == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //create the Shutdown event. The last of the ConnectionReleased
    //threads will set this event when the Shutting down flag is set.
    //
    m_ShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_ShutdownEvent == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //create the thread that processes things out of the
    //the queue
    DWORD ThreadId;
    m_ThreadHandle = CreateThread (NULL,
                                   0,
                                   CSMTP_RETRY_HANDLER::RetryThreadRoutine,
                                   this,
                                   0,
                                   &ThreadId);
    if (m_ThreadHandle == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //Initialize RetryQ
    return S_OK;
    TraceFunctLeaveEx((LPARAM)this);
}

//-------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::HrDeInitialize
//
//
//--------------------------------------------------------------------------------
HRESULT CSMTP_RETRY_HANDLER::HrDeInitialize(void)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::HrDeInitialize");

    //Set the flag that the Handler is shutting down
    SetShuttingDown();
    //Release the Retry thread by setting the retry event
    SetQueueEvent();
    //Wait for the thread to exit
    //NK** - right now this is infinite wait - but that needs to
    //change and we will have to comeout and keep giving hints
    WaitForQThread();

    //At this point we just need to wait for all the threads that are in there
    //to go out and we can then shutdown
    //Obviously ConnectionManager has to to stop sending threads this way
    //NK** - right now this is infinite wait - but that needs to
    //change and we will have to comeout and keep giving hints
    if(m_ThreadsInRetry)
	    WaitForShutdown();

    //Close the shutdown Event handle
    if(m_ShutdownEvent != NULL)
	    CloseHandle(m_ShutdownEvent);

    //Close the Retry Event handle
    if(m_RetryEvent != NULL)
	    CloseHandle(m_RetryEvent);

    //Close the Retry Thread handle
    if(m_ThreadHandle != NULL)
	    CloseHandle(m_ThreadHandle);

    //Once all threads are gone
    //we can deinit the hash table and the queue
    m_pRetryQueue->DeInitialize();
    m_pRetryHash->DeInitialize();

    //Release the shedule manager
    m_pIRetryManager->Release();

    if(InterlockedDecrement((LONG*)&CSMTP_RETRY_HANDLER::dwInstanceCount) == 0)
    {
        //finally, release all our memory
	    CRETRY_HASH_ENTRY::PoolForHashEntries.ReleaseMemory();
    }

    TraceFunctLeaveEx((LPARAM)this);
    delete this;
    return S_OK;
}


//---[ CSMTP_RETRY_HANDLER::ConnectionReleased ]-------------------------------
//
//
//  Description:
//      Default sink for ConnectionReleased event
//  Parameters:
//      - see aqintrnl.idl for a description of parameters
//  Returns:
//      S_OK on success
//  History:
//      9/24/98 - MikeSwa updated from original ConnectionReleased
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTP_RETRY_HANDLER::ConnectionReleased(
                           IN  DWORD cbDomainName,
                           IN  CHAR  szDomainName[],
                           IN  DWORD dwDomainInfoFlags,
                           IN  DWORD dwScheduleID,
                           IN  GUID  guidRouting,
                           IN  DWORD dwConnectionStatus,
                           IN  DWORD cFailedMessages,
                           IN  DWORD cTriedMessages,
                           IN  DWORD cConsecutiveConnectionFailures,
                           OUT BOOL* pfAllowImmediateRetry,
                           OUT FILETIME *pftNextRetryTime)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::ConnectionReleased");

    HRESULT hr;
    DWORD dwError;
    GUID guid = GUID_NULL;
    LPSTR szRouteHashedDomain = NULL;

    //Keep a track of threads that are inside
    //This will be needed in shutdown
    InterlockedIncrement(&m_ThreadsInRetry);

    //By default, we will allow the domain to retry
    _ASSERT(pfAllowImmediateRetry);
    *pfAllowImmediateRetry = TRUE;

    _ASSERT(pftNextRetryTime);

    if(TRUE)
    {
        // Check what we want to do
        // **If we need to disable the connection - disable it
        // **Check if there are any outstanding connections
        // If no connections, calculate the retry time and add in the queue and return
        if(ShouldHoldForRetry(dwConnectionStatus,
                              cFailedMessages,
                              cTriedMessages))
        {
            //Do not hold TURN/ETRN domains for retry (except for "glitch" retry)
            if((!(dwDomainInfoFlags & (DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY))) ||
               (cConsecutiveConnectionFailures < m_dwRetryThreshold))
            {
                //Insert it - we could fail to insert it if an entry already exists
                //That is OK - we will return success
                if(!InsertDomain(szDomainName,
                                 cbDomainName,
                                 dwConnectionStatus,
                                 dwScheduleID,
                                 &guidRouting,
                                 cConsecutiveConnectionFailures,
                                 cTriedMessages,
                                 cFailedMessages, pftNextRetryTime ))
                {
                    dwError = GetLastError();
                    DebugTrace((LPARAM)this,
                        "Failed to insert %s entry into retry hash table : Err : %d ",
			            szDomainName, dwError);

                    if(dwError == ERROR_FILE_EXISTS )
                    {
	                    //We did not insert because the entry was already there
                        *pfAllowImmediateRetry = FALSE;
	                    hr = S_OK;
	                    goto Exit;
                    }
                    else
                    {
                        if(dwError == ERROR_NOT_ENOUGH_MEMORY )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _ASSERT(0);
                            hr = E_FAIL;
                        }
                        goto Exit;
                    }
                }
                //Normal retry domain
                *pfAllowImmediateRetry = FALSE;
                DebugTrace((LPARAM)this,
                    "Holding domain %s for retry",szDomainName);
            }
        }
        else
        {
            // Some connection succeeded for this domain.
            //If we have it marked for retry - it needs to be freed up
            //Looks like the incident which caused retry has cleared up.
            CHAR szHashedDomain[MAX_RETRY_DOMAIN_NAME_LEN];

            //Hash schedule ID and router guid to domain name
            CreateRouteHash(cbDomainName, szDomainName, ROUTE_HASH_SCHEDULE_ID,
                            &guidRouting, dwScheduleID, szHashedDomain, sizeof(szHashedDomain));

            RemoveDomain(szHashedDomain);
            hr = S_OK;
            goto Exit;
        }
    }
    hr = S_OK;

Exit :

    //Keep a track of threads that are inside
    //This will be needed in shutdown
    if(InterlockedDecrement(&m_ThreadsInRetry) == 0 && IsShuttingDown())
    {
        //we signal the shutdown event to indicate that
        //no more threads are in the system
        _ASSERT(m_ShutdownEvent != NULL);
        SetEvent(m_ShutdownEvent);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
// CSMTP_RETRY_HANDLER::InsertDomain
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL CSMTP_RETRY_HANDLER::InsertDomain(char * szDomainName,
                                       IN  DWORD cbDomainName,
                                       IN  DWORD dwConnectionStatus,		//eConnectionStatus
                                       IN  DWORD dwScheduleID,
                                       IN  GUID  *pguidRouting,
                                       IN  DWORD cConnectionFailureCount,
                                       IN  DWORD cTriedMessages, 	//# of untried messages in queue
									   IN  DWORD cFailedMessages,		//# of failed message for *this* connection
									   OUT FILETIME *pftNextRetry)
{
    DWORD dwError;
    FILETIME TimeNow;
    FILETIME RetryTime;
    CRETRY_HASH_ENTRY* pRHEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::InsertDomain");

    //Get the insertion time for the entry
    GetSystemTimeAsFileTime(&TimeNow);

    //Cpool based allocations for hash entries
    pRHEntry = new CRETRY_HASH_ENTRY (szDomainName, cbDomainName,
                                dwScheduleID, pguidRouting, &TimeNow);

    if(!pRHEntry)
    {
        //_ASSERT(0);
        dwError = GetLastError();
        DebugTrace((LPARAM)this,
                    "failed to Create a new hash entry : %s err: %d",
					szDomainName,
					dwError);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //Based on the current time and the number of connections failures calculate the
    //time of release for retry
    RetryTime = CalculateRetryTime(cConnectionFailureCount, &TimeNow);
    pRHEntry->SetRetryReleaseTime(&RetryTime);
    pRHEntry->SetFailureCount(cConnectionFailureCount);

    //The hash entry has been initialized
    //Insert it - we could fail to insert it if an entry already exists
    //That is OK - we will return success
    if(!m_pRetryHash->InsertIntoTable (pRHEntry))
    {
        //Free up the entry
        _ASSERT(pRHEntry);
        delete pRHEntry;
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }
    else
    {
        //Report next retry time
        if (pftNextRetry)
            memcpy(pftNextRetry, &RetryTime, sizeof(FILETIME));

        //Insert into the retry queue.
        BOOL fTopOfQueue = FALSE;
        //Lock the queue
        m_pRetryQueue->LockQ();
        m_pRetryQueue->InsertSortedIntoQueue(pRHEntry, &fTopOfQueue);

#ifdef DEBUG
        //Add ref count for logging before releasing the lock
        //Do rtacing afterwards so as to reduce lock time
        pRHEntry->IncRefCount();
#endif
        m_pRetryQueue->UnLockQ();
        //If the insertion was at the top of the queue
        //wake up the retry thread to evaluate the new
        //sleep time
        if(fTopOfQueue)
        {
	        SetEvent(m_RetryEvent);
        }

#ifdef DEBUG
        //Write out the insert and release time to a file
        //
        WriteDebugInfo(pRHEntry,
                       INSERT,
                       dwConnectionStatus,
                       cTriedMessages,
					   cFailedMessages);
        //Decrement the ref count obtained for the tracing
        pRHEntry->DecRefCount();
#endif

    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

//---------------------------------------------------------------------------------
// CSMTP_RETRY_HANDLER::RemoveDomain
//
//
//---------------------------------------------------------------------------------
//
BOOL CSMTP_RETRY_HANDLER::RemoveDomain(char * szDomainName)
{
    PRETRY_HASH_ENTRY pRHEntry;

    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::RemoveDomain");

    if(!m_pRetryHash->RemoveFromTable(szDomainName, &pRHEntry))
    {
        if(GetLastError() == ERROR_PATH_NOT_FOUND)
            return TRUE;
        else
        {
            _ASSERT(0);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }


    _ASSERT(pRHEntry != NULL);

    //Remove it from the queue
    m_pRetryQueue->LockQ();
    if(!m_pRetryQueue->RemoveFromQueue(pRHEntry))
    {
        m_pRetryQueue->UnLockQ();
        if(GetLastError() == ERROR_PATH_NOT_FOUND)
            return TRUE;
        else
        {
            _ASSERT(0);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }
    m_pRetryQueue->UnLockQ();

    //If successful in removing from the queue then we are not competing with
    //the Retry thread
    //decrement hash table ref count as well as the ref count for the queue
    pRHEntry->DecRefCount();
    pRHEntry->DecRefCount();

    //Release this entry by setting the right flags
    //This should always succeed
    DebugTrace((LPARAM)this,
            "Releasing domain %s because another connection succeeded", szDomainName);
    if(!ReleaseForRetry(szDomainName))
    {
        ErrorTrace((LPARAM)this, "Failed to release the entry");
        TraceFunctLeaveEx((LPARAM)this);
        //_ASSERT(0);
    }
    return TRUE;
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::CalculateRetryTime
//
// Logic to decide based on the number of failed connection how long to hld this
// domain for retry
//
//---------------------------------------------------------------------------------
FILETIME CSMTP_RETRY_HANDLER::CalculateRetryTime(DWORD cFailedConnections,
												 FILETIME* InsertedTime)
{
    FILETIME ftTemp;
    LONGLONG Temptime;
    DWORD dwRetryMilliSec = 0;

    //Does this look like a glitch
    //A glitch is defined as less than x consecutive failures
    if(cFailedConnections < m_dwRetryThreshold)
        dwRetryMilliSec = m_dwGlitchRetrySeconds * 1000;
    else
    {
        switch(cFailedConnections - m_dwRetryThreshold)
        {
        case 0: dwRetryMilliSec = m_dwFirstRetrySeconds  * 1000;
            break;

        case 1: dwRetryMilliSec = m_dwSecondRetrySeconds * 1000;
            break;

        case 2: dwRetryMilliSec = m_dwThirdRetrySeconds  * 1000;
            break;

        case 3: dwRetryMilliSec = m_dwFourthRetrySeconds  * 1000;
            break;

        default: dwRetryMilliSec = m_dwFourthRetrySeconds  * 1000;
            break;
        }
    }

    _ASSERT(dwRetryMilliSec);

    Temptime = INT64_FROM_FILETIME(*InsertedTime) + HnsFromMs((__int64)dwRetryMilliSec);
    // HnsFromMin(m_RetryMinutes)
    ftTemp = FILETIME_FROM_INT64(Temptime);

    return ftTemp;
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::ProcessEntry
//
// Description :
//      Process the hash entry removed from the queue because it is
//      time to release the corresponding domain.
//      We mark the domain active for retry and then take the hash
//      entry out of the hash table and delete the hash entry.
//
//---------------------------------------------------------------------------------

void CSMTP_RETRY_HANDLER::ProcessEntry(PRETRY_HASH_ENTRY pRHEntry)
{
    TraceFunctEnterEx((LPARAM)this, "CSMTP_RETRY_HANDLER::ProcessEntry");

    PRETRY_HASH_ENTRY pTempEntry;

    _ASSERT(pRHEntry != NULL);

    if (pRHEntry->IsCallback())
    {
        //call callback function
        pRHEntry->ExecCallback();
    }
    else
    {
        //Remove the entry from the hash table
        if(!m_pRetryHash->RemoveFromTable(pRHEntry->GetHashKey(), &pTempEntry))
        {
            _ASSERT(GetLastError() == ERROR_PATH_NOT_FOUND);
        }

        //Check to see if this is
        //Release this entry by setting the right flags
        //This shoudl alway suceed
        DebugTrace((LPARAM)this,
            "Releasing domain %s for retry", pRHEntry->GetHashKey());
        if(!ReleaseForRetry(pRHEntry->GetHashKey()))
        {
            ErrorTrace((LPARAM)this,
                "Failed to release the entry %s", pRHEntry->GetHashKey());
            // _ASSERT(0);
        }

        //Irrespective of fail or success while removing the hash entry,
        //we decrement the refcount for both the hash table
        pRHEntry->DecRefCount();
    }

    pRHEntry->DecRefCount();
    TraceFunctLeaveEx((LPARAM)this);
}

//---------------------------------------------------------------------------------
//
// CSMTP_RETRY_HANDLER::UpdateAllEntries
//
// Whenever the config data changes we update the release time for the queues
// based on it.
//
//
//---------------------------------------------------------------------------------
//
BOOL CSMTP_RETRY_HANDLER::UpdateAllEntries(void)
{
    CRETRY_HASH_ENTRY * pHashEntry = NULL;
    CRETRY_Q * pTempRetryQueue = NULL;
    FILETIME ftInsertTime, ftRetryTime;
    DWORD cConnectionFailureCount = 0;
    BOOL fTopOfQueue;
    BOOL fInserted = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::UpdateAllEntries");

    //Create the temporary retry queue
    pTempRetryQueue = CRETRY_Q::CreateQueue();
    if(!pTempRetryQueue)
    {
        ErrorTrace((LPARAM)this,
            "Failed to initialize the temp retry queue ");
        _ASSERT(0);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    m_pRetryQueue->LockQ();

    //Create a new queue and load everything into it
    while(1)
    {
        //Get the  top entry from first queue
        //Do not release the ref count on it - we need the entry to be around
        //so as to reinsert it at the right place in the updated queue
        pHashEntry = m_pRetryQueue->RemoveFromTop();

        //If we get hash entry
        if(pHashEntry)
        {
            if (!pHashEntry->IsCallback()) //don't update times of callbacks
            {
                ftInsertTime = pHashEntry->GetInsertTime();
                cConnectionFailureCount = pHashEntry->GetFailureCount();

                ftRetryTime = CalculateRetryTime(cConnectionFailureCount, &ftInsertTime);
                pHashEntry->SetRetryReleaseTime(&ftRetryTime);
#ifdef DEBUG
                WriteDebugInfo(pHashEntry,UPDATE,0,0,0);
#endif
            }

            //Insert the entry into the new queue using the new Release time
            //This will bump up the ref count.
            pTempRetryQueue->InsertSortedIntoQueue(pHashEntry, &fTopOfQueue);

            //Decrement the ref count to correspond to remove from Old queue now
            pHashEntry->DecRefCount();

            fInserted = TRUE;

        }
        else
            break;
    }

    //Update the old queue head with the Flink/Blink ptrs from the new queue
    if(fInserted)
    {
        m_pRetryQueue->StealQueueEntries(pTempRetryQueue);
    }

    pTempRetryQueue->DeInitialize();
    m_pRetryQueue->UnLockQ();
    SetEvent(m_RetryEvent);
    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

//--------------------------------------------------------------------------------------
//
//
//	Name :
//		CSMTP_RETRY_HANDLER::RetryThreadRoutine
//
//  Description:
//	   This function is the static member
//	   function that gets passed to CreateThread
//	   during the initialization. It is the main
//     thread that does the work of releasing the
//	   domain that are being held for retry.
//
//  Arguments:
//		A pointer to a RETRYQ
//
//  Returns:
//--------------------------------------------------------------------------------------
//
DWORD WINAPI CSMTP_RETRY_HANDLER::RetryThreadRoutine(void * ThisPtr)
{
    CSMTP_RETRY_HANDLER* RetryHandler =   (CSMTP_RETRY_HANDLER*)ThisPtr;
    CRETRY_Q* QueuePtr = (CRETRY_Q*) RetryHandler->GetQueuePtr();
    PRETRY_HASH_ENTRY pRHEntry;
    DWORD				dwDelay;    //Delay in seconds to sleep for
//  HANDLE WaitTable[2];
//  HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)QueuePtr, "CSMTP_RETRY_HANDLER::RetryThreadRoutine");


    //This thread will permanently loop on the retry queue.
    //If we find something at the top of the queue that can be retried, it gets
    //
    while(TRUE)
    {
        //if we are shutting down, break out of the loop
        if (RetryHandler->IsShuttingDown())
        {
            goto Out;
        }

        //if we find the top entry to be ready for a retry
        //we remove it from the queue and do the needful
        //
        if( QueuePtr->CanRETRYHeadEntry(&pRHEntry, &dwDelay))
        {
            //We got an entry to process
            //Processing should be simply enabling a link
            if(pRHEntry)
            {
                RetryHandler->ProcessEntry(pRHEntry);
            }
            else
            {
                DebugTrace((LPARAM)QueuePtr,
				            "Error getting a domain entry off the retry queue");
            }
        }
        else
        {
            DebugTrace((LPARAM)QueuePtr,"Sleeping for %d seconds", dwDelay);
            //Goto Sleep
            WaitForSingleObject(RetryHandler->m_RetryEvent,dwDelay);
        }
    } //end while

Out:

    DebugTrace((LPARAM)QueuePtr,"Queue thread exiting");
    TraceFunctLeaveEx((LPARAM)QueuePtr);
    return 1;
}

//--------------------------------------------------------------------------------------
//
// Logic to decide based on the failure condition if the connection needs to be
// disabled and added to retry queue
// If we fail we hold it for retry
// Otherwise if we tried more than one messages and every one of them failed we
// hold for retry
// In all other cases we keep the link active
//
//      2/5/99 - MikeSwa Modified to kick all non-success acks into retry
//--------------------------------------------------------------------------------------
BOOL ShouldHoldForRetry(DWORD dwConnectionStatus,
                        DWORD cFailedMsgCount,
                        DWORD cTriedMsgCount)
{

    //If connection failed or all messages on this connection failed TRUE
    if(dwConnectionStatus != CONNECTION_STATUS_OK)
    {
        return TRUE;
    }
    else if( cTriedMsgCount > 0 && !(cTriedMsgCount - cFailedMsgCount))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

//---[ CSMTP_RETRY_HANDLER::SetCallbackTime ]----------------------------------
//
//
//  Description:
//      Puts an entry in the retry queue to provide a callback at a specified
//      later time.
//  Parameters:
//      IN pCallbackFn             Pointer to retry function
//      IN pvContext            Context passed to retry function
//      IN dwCallbackMinutes    Minutes to wait before calling back
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if a hash entry cannot be allocated
//      E_INVALIDARG of pCallbackFn is NULL
//  History:
//      8/17/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CSMTP_RETRY_HANDLER::SetCallbackTime(
                        IN RETRFN    pCallbackFn,
                        IN PVOID     pvContext,
                        IN DWORD    dwCallbackMinutes)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTP_RETRY_HANDLER::SetCallbackTime");
    HRESULT hr = S_OK;
    CRETRY_HASH_ENTRY* pRHEntry = NULL;
    BOOL fTopOfQueue = FALSE;
    FILETIME TimeNow;
    FILETIME RetryTime;
    LONGLONG Temptime;
    GUID     guidFakeRoutingGUID = GUID_NULL;

    //$$REVIEW
    //This (and all other occurences of this in retrsink) is not really thread
    //safe... but since the code calling the retrsink *is* thread safe,
    //this is not too much of a problem. Still, this should get fixed for M3
    //though - MikeSwa 8/17/98
    InterlockedIncrement(&m_ThreadsInRetry);

    if (!pCallbackFn)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Get the insertion time for the entry
    GetSystemTimeAsFileTime(&TimeNow);

    pRHEntry = new CRETRY_HASH_ENTRY (CALLBACK_DOMAIN,
                                      sizeof(CALLBACK_DOMAIN),
                                      0,
                                      &guidFakeRoutingGUID,
                                      &TimeNow);
    if (!pRHEntry)
    {
        ErrorTrace((LPARAM) this, "ERROR: Unable to allocate retry hash entry");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //Calculate retry time
    Temptime = INT64_FROM_FILETIME(TimeNow) + HnsFromMs((__int64)dwCallbackMinutes*60*1000);
    RetryTime = FILETIME_FROM_INT64(Temptime);

    //set callback time
    pRHEntry->SetRetryReleaseTime(&RetryTime);
    pRHEntry->SetCallbackContext(pCallbackFn, pvContext);

    //Lock the queue
    m_pRetryQueue->LockQ();
    m_pRetryQueue->InsertSortedIntoQueue(pRHEntry, &fTopOfQueue);

#ifdef DEBUG

    //Add ref count for logging before releasing the lock
    //Do rtacing afterwards so as to reduce lock time
    pRHEntry->IncRefCount();

#endif //DEBUG

    m_pRetryQueue->UnLockQ();
    //If the insertion was at the top of the queue
    //wake up the retry thread to evaluate the new
    //sleep time
    if(fTopOfQueue)
    {
        SetEvent(m_RetryEvent);
    }

#ifdef DEBUG
    //Write out the insert and release time to a file
    WriteDebugInfo(pRHEntry, INSERT, 0xFFFFFFFF, 0,0);

    //Decrement the ref count obtained for the tracing
    pRHEntry->DecRefCount();

#endif //DEBUG

  Exit:
    InterlockedDecrement(&m_ThreadsInRetry);
    TraceFunctLeave();
    return hr;
}

//---[ ReleaseForRetry ]-------------------------------------------------------
//
//
//  Description:
//      Releases given domain for retry by setting link state flags
//  Parameters:
//      IN  szHashedDomainName      Route-hashed domain name to release
//  Returns:
//      TRUE on success
//      FALSE on failure
//  History:
//      9/25/98 - MikeSwa Created (adapted from inline function)
//
//-----------------------------------------------------------------------------
BOOL CSMTP_RETRY_HANDLER::ReleaseForRetry(IN char * szHashedDomainName)
{
    _ASSERT(szHashedDomainName);
    HRESULT hr = S_OK;
    DWORD dwScheduleID = dwGetIDFromRouteHash(szHashedDomainName);
    GUID  guidRouting = GUID_NULL;
    LPSTR szUnHashedDomain = szGetDomainFromRouteHash(szHashedDomainName);

    GetGUIDFromRouteHash(szHashedDomainName, &guidRouting);

    hr = m_pIRetryManager->RetryLink(lstrlen(szUnHashedDomain),
                szUnHashedDomain, dwScheduleID, guidRouting);

    return (SUCCEEDED(hr));
}


//--------------------------------------------------------------------------------------
//
// Debugging functions
//
//
//--------------------------------------------------------------------------------------
#ifdef DEBUG

void CSMTP_RETRY_HANDLER::DumpAll(void)
{
	m_pRetryQueue->PrintAllEntries();
}

void WriteDebugInfo(CRETRY_HASH_ENTRY* pRHEntry,
                    DWORD DebugType,
                    DWORD dwConnectionStatus,
                    DWORD cTriedMessages,
                    DWORD cFailedMessages)
{
    //open a transcript file and put the insert and release times in it
    //
    SYSTEMTIME stRetryTime, stInsertTime, stLocalInsertTime, stLocalRetryTime;
    char szScratch[MAX_PATH];
    char sztmp[20];
    DWORD cbWritten;
    TIME_ZONE_INFORMATION tz;

    FileTimeToSystemTime(&pRHEntry->GetRetryTime(), &stRetryTime);
    FileTimeToSystemTime(&pRHEntry->GetInsertTime(), &stInsertTime);

    GetTimeZoneInformation(&tz);
    SystemTimeToTzSpecificLocalTime(&tz, &stInsertTime, &stLocalInsertTime);
    SystemTimeToTzSpecificLocalTime(&tz, &stRetryTime, &stLocalRetryTime);

    if(DebugType == INSERT)
    {
        //Get rid of annoying routing information
        if (lstrcmp(pRHEntry->GetHashKey(), CALLBACK_DOMAIN))
        {
        	sprintf(pRHEntry->m_szTranscriptFile, "%s%.200s.%p.rtr",
        		LOGGING_DIRECTORY,
        		szGetDomainFromRouteHash(pRHEntry->GetHashKey()),
        		pRHEntry);
        }
        else
        {
            //callback function
            sprintf(pRHEntry->m_szTranscriptFile, "%s%.200s.rtr",
        		LOGGING_DIRECTORY,
        		pRHEntry->GetHashKey());

        }

        _ASSERT(strlen(pRHEntry->m_szTranscriptFile) < MAX_PATH);

        pRHEntry->m_hTranscriptHandle = INVALID_HANDLE_VALUE;
        pRHEntry->m_hTranscriptHandle = CreateFile(pRHEntry->m_szTranscriptFile,
                                                   GENERIC_READ | GENERIC_WRITE,
                                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                   NULL,
                                                   OPEN_ALWAYS,
                                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                   NULL);

        switch(dwConnectionStatus)
        {
        case 0: lstrcpy( sztmp, "OK");
            break;
        case 1: lstrcpy( sztmp, "FAILED");
            break;
        case 2: lstrcpy( sztmp, "DROPPED");
            break;
        default:lstrcpy( sztmp, "UNKNOWN");
            break;
        }

        sprintf(szScratch,"InsertTime:%d:%d:%d Retrytime:%d:%d:%d\nConnection status:%s Consecutive failures:%d\nMessages Tried:%d Failed:%d\n\n",
                                        stLocalInsertTime.wHour, stLocalInsertTime.
                                        wMinute,stLocalInsertTime.wSecond,
                                        stLocalRetryTime.wHour, stLocalRetryTime.wMinute,
                                        stLocalRetryTime.wSecond,
                                        sztmp,
                                        pRHEntry->GetFailureCount(),
                                        cTriedMessages,
                                        cFailedMessages);

        if( pRHEntry->m_hTranscriptHandle != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(pRHEntry->m_hTranscriptHandle,
                           0,
                           NULL,
                           FILE_END);
            ::WriteFile(pRHEntry->m_hTranscriptHandle,
                        szScratch,
                        strlen(szScratch),
                        &cbWritten,
                        NULL);
        }
    }
    else if (DebugType == UPDATE)
    {
        sprintf(szScratch,"Updated : InsertedTime:%d:%d:%d Retrytime:%d:%d:%d\n\n",
                            stLocalInsertTime.wHour, stLocalInsertTime.wMinute,
                            stLocalInsertTime.wSecond,
                            stLocalRetryTime.wHour, stLocalRetryTime.wMinute,
                            stLocalRetryTime.wSecond);

        if( pRHEntry->m_hTranscriptHandle != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(pRHEntry->m_hTranscriptHandle,
                           0,
                           NULL,
                           FILE_END);
            ::WriteFile(pRHEntry->m_hTranscriptHandle,
                        szScratch,
                        strlen(szScratch),
                        &cbWritten,
                        NULL);
        }
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retrinc.h ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <rwnew.h>
#include "listmacr.h"
#include "timemath.h"

// Tracing and Cpool specific
#include <dbgtrace.h>
#include <cpool.h>

#define INOUT 
#define IN
#define OUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

#include "retrinc.h"
#include "hashentr.h"
#include "rhash.h"
#include "retryq.h"
#include "aqueue.h"
#include "aqintrnl.h"
#include "retrsink.h"
#include "hshroute.h"
#include "aqmem.h"

#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retryq.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       queue.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    01-05-96   NimishK   Created
//
//----------------------------------------------------------------------------

#ifndef __QUEUE_H__
#define __QUEUE_H__

//
// A SORTED_QUEUE is a 

#define PRETRY_HASH_ENTRY CRETRY_HASH_ENTRY*

class CRETRY_HASH_ENTRY;

class CRETRY_Q 
{
	 private :

		LIST_ENTRY           		m_QHead;          	// List pointers
		CRITICAL_SECTION			m_CritSec;   		// Guard
		BOOL						m_fCritSecInit;     // Has init been called

	 public:

		CRETRY_Q () //initialize stuff that can't fail
		{
			TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::CRETRY_Q");
			m_fCritSecInit = FALSE;
			TraceFunctLeaveEx((LPARAM)this);
		}

		~CRETRY_Q ()
		{
			TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::~CRETRY_Q");
			TraceFunctLeaveEx((LPARAM)this);
		}

		HRESULT Initialize(void);
		HRESULT DeInitialize(void);
 		static CRETRY_Q * CreateQueue(void);

	public :
		//for controlling the retry queue
		void LockQ () {EnterCriticalSection (&m_CritSec);}
		void UnLockQ() {LeaveCriticalSection (&m_CritSec);}
        LIST_ENTRY* GetQHead(){return &m_QHead;}


		void PrintAllEntries(void);

		void InsertSortedIntoQueue(PRETRY_HASH_ENTRY pHashEntry, BOOL *fTopOfQueue);
		BOOL RemoveFromQueue(PRETRY_HASH_ENTRY pRHEntry);
        PRETRY_HASH_ENTRY RemoveFromTop(void);

		BOOL CanRETRYHeadEntry(PRETRY_HASH_ENTRY *ppRHEntry, DWORD* dwDelay);

		BOOL IsQueueEmpty(void) const {return IsListEmpty(&m_QHead);}

        //Used to steal entries with tmp queue
        void StealQueueEntries(CRETRY_Q *pRetryQueue);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\retryq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        retrq.cxx

   Abstract:
		Implements the Retry queue

   Author:

           Nimish Khanolkar    ( NimishK )    11-Dec-1995

   Project:

          CRETRY_Q sink

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "precomp.h"

//////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::InitializeQueue
//
//  Description:
//	   This function initializes the class
//
//////////////////////////////////////////////////////////////////////////////
//
HRESULT CRETRY_Q::Initialize(void)
{

	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::InitializeQueue");

	//Init the heaad of the queue
	InitializeListHead(&m_QHead);

	//Init or critical section.  This protects the queue and the hash table
	InitializeCriticalSection(&m_CritSec);
	m_fCritSecInit = TRUE;
  
	TraceFunctLeaveEx((LPARAM)this);
	return S_OK;
}
 
//////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::CreateQueue
//
//  Description:
//	   This is the static member function that creates the Queue
//
//
////////////////////////////////////////////////////////////////////////////////

CRETRY_Q * CRETRY_Q::CreateQueue()
{
	HRESULT hr;

    CRETRY_Q * pRQueue = NULL;
	
	pRQueue = new CRETRY_Q();

    if(!pRQueue)
    {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
    }

	//initialize the queue
	hr = pRQueue->Initialize();
	if(FAILED(hr))
	{
		delete pRQueue;
		pRQueue = NULL;
	}
	return pRQueue;
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::DeInitialize
//
// Very Basic.
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT CRETRY_Q::DeInitialize(void)
{
    PLIST_ENTRY  plEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    //Release all the objects in the queue
    //      10/1/98 - MikeSwa
    while(!IsListEmpty(&m_QHead))
    {
        plEntry = RemoveHeadList (&m_QHead);
        pHashEntry = CONTAINING_RECORD(plEntry, CRETRY_HASH_ENTRY, m_QLEntry);
        pHashEntry->ClearInQ();

        //Execute callback on shutdown, so caller can free memory
        if (pHashEntry->IsCallback())
            pHashEntry->ExecCallback();

        pHashEntry->DecRefCount();
    }

    if (m_fCritSecInit)
        DeleteCriticalSection(&m_CritSec);

	delete this;
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::InsertSortedIntoQueue
//
//  Description:
//	   It takes the list entry for the new RETRY_HASH_ENTRY 
//	   and adds it in the right order based on the Retry time 
//	   for that entry.
//     UnLocked operation. The caller has to have the lock
//
//  Arguments:
//
//   Returns:
//
///////////////////////////////////////////////////////////////////////

void CRETRY_Q::InsertSortedIntoQueue(PRETRY_HASH_ENTRY pHashEntry, 
									 BOOL *fTopOfQueue )
{
	PLIST_ENTRY  pCurrentListEntry;
	FILETIME	 CurrentRetryTime;
	FILETIME	 NewRetryTime;
	PRETRY_HASH_ENTRY pCurrentHashEntry;
	
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::InsertSortedEntry");

	*fTopOfQueue = FALSE;
	
	//Initialize
	pCurrentListEntry = &m_QHead;

	//Look at the next entry to see if we are not at the end of the queue
	while(pCurrentListEntry->Flink != &m_QHead)
	{
		//Get the object pointed by the next entry
		pCurrentHashEntry = CONTAINING_RECORD( pCurrentListEntry->Flink, 
											CRETRY_HASH_ENTRY, m_QLEntry);
		CurrentRetryTime = pCurrentHashEntry->GetRetryTime();
		NewRetryTime = pHashEntry->GetRetryTime();

		//If the new entry has more delay we continue finding a place for it
		if(CompareFileTime (&CurrentRetryTime, &NewRetryTime) == -1) 
		{
			pCurrentListEntry = pCurrentListEntry->Flink;
			continue;
		}
		else 
		{	//We found the place
			break;
		}
	}

	//insert before the next entry
	InsertHeadList(pCurrentListEntry, &pHashEntry->QueryQListEntry());
	//set inQ flag
	pHashEntry->SetInQ();
	pHashEntry->IncRefCount();
	if(m_QHead.Flink == &pHashEntry->QueryQListEntry())
		*fTopOfQueue = TRUE;

	TraceFunctLeaveEx((LPARAM)this);
	return;
}

/////////////////////////////////////////////////////////////////////////////////
//
//	Name :
//		CRETRY_Q::CanRETRYHeadEntry
//
//		We look at the entry at the top of the queue
//		If it is something that we can retry right now, we remove it from the 
//		queue and return it to the caller
//
///////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_Q::CanRETRYHeadEntry(PRETRY_HASH_ENTRY* ppRHEntry, 
													DWORD* pdwDelay)
{
	FILETIME        TimeNow;        //the time now
	FILETIME		RetryTime;      //time connection should be retried
		
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::CanPopHead");

	//get the current time
	GetSystemTimeAsFileTime(&TimeNow);

	//Lock the queue
	LockQ();

	_ASSERT(m_QHead.Flink);

	//Look at the next entry to see if we are not at the end of the queue
	if(m_QHead.Flink != &m_QHead)
	{
		//Get the object pointed by the next entry
		*ppRHEntry = CONTAINING_RECORD( m_QHead.Flink, CRETRY_HASH_ENTRY, m_QLEntry);
		RetryTime = (*ppRHEntry)->GetRetryTime();

		//If the Current time is less than the retry time
		// and the time difference is greater than 1 sec then go back to waiting
		//else remove the entry
		if( (CompareFileTime (&TimeNow, &RetryTime) == -1) && 
					(*pdwDelay = ((DWORD)SecFromFtSpan(TimeNow, RetryTime) * 1000)))
		{
			//We cannnot POP this entry as it is not yet release
			_ASSERT(*pdwDelay > 0);

			*ppRHEntry = NULL;
			//Unlock the queue
			UnLockQ();
			TraceFunctLeaveEx((LPARAM)this);
			return FALSE;
		} //end of while
		else
		{
			//We can pop this entry from our retry queue
			RemoveEntryList(m_QHead.Flink);
			(*ppRHEntry)->ClearInQ();
			*pdwDelay = 0;
			//Unlock the queue
			UnLockQ();
			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}
	else
	{
		//Unlock the queue
		UnLockQ();
		//There is no entry in the queue so go to sleep indefintely.
		*ppRHEntry = NULL;
		//get the delay to sleep
		*pdwDelay = INFINITE;
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
//    CRETRY_Q::RemoveFromQueue(PLISTENTRY	pEntry)
//
//		This function removes an entry into the queue
//    
//	Arguments:
//
//			none
//
/////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_Q::RemoveFromQueue(PRETRY_HASH_ENTRY pRHEntry)
{
	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::RemoveFromQueue");

    _ASSERT( pRHEntry != NULL);

	if(pRHEntry == NULL || &pRHEntry->QueryQListEntry() == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

    // Remove 
	if(pRHEntry->GetInQ())
	{
	    RemoveEntryList( &pRHEntry->QueryQListEntry());
		pRHEntry->ClearInQ();
		TraceFunctLeaveEx((LPARAM)this);
		return TRUE;
	}
	else
	{
		SetLastError(ERROR_PATH_NOT_FOUND);
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
//    CRETRY_Q::RemoveFromTop()
//
//		This function removes an entry into the queue
//    
//	Arguments:
//
//			none
//
/////////////////////////////////////////////////////////////////////////////////
//
PRETRY_HASH_ENTRY CRETRY_Q::RemoveFromTop(void)
{

    PLIST_ENTRY  plEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

     //get the first item off the queue
    if(!IsListEmpty(&m_QHead))
    {
        plEntry = RemoveHeadList (&m_QHead);
        pHashEntry = CONTAINING_RECORD(plEntry, CRETRY_HASH_ENTRY, m_QLEntry);
    }

    return pHashEntry;

}



/////////////////////////////////////////////////////////////////////////////////
// CRETRY_Q::PrintAllEntries
//
//		Walks the retry queue and Prints all the domains and the times
//
/////////////////////////////////////////////////////////////////////////////////
//
void CRETRY_Q::PrintAllEntries(void)
{
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	PLIST_ENTRY  pentryNext = NULL;
	CRETRY_HASH_ENTRY * pHashEntry = NULL;
	FILETIME ftTime;
	SYSTEMTIME stTime;
	char szRetryTime[20];
	char szInsertedTime[20];

	TraceFunctEnterEx((LPARAM)this, "CRETRY_Q::PrintAllEntries");

	LockQ();
	HeadOfList = &m_QHead;
	pEntry = m_QHead.Flink;
	for(; pEntry != HeadOfList; pEntry = pentryNext)
	{
		pentryNext = pEntry->Flink;
		pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_QLEntry);
		
		ftTime = pHashEntry->GetRetryTime();
		FileTimeToSystemTime(&ftTime, &stTime);
		sprintf(szRetryTime, "%d:%d:%d",stTime.wHour,stTime.wMinute, stTime.wSecond); 
		ftTime = pHashEntry->GetInsertTime();
		FileTimeToSystemTime(&ftTime, &stTime);
		sprintf(szInsertedTime, "%d:%d:%d",stTime.wHour,stTime.wMinute, stTime.wSecond); 

		DebugTrace((LPARAM)this,"Domain: %s RTime: %s, ITime: %s", 
					pHashEntry->GetHashKey(),szRetryTime, szInsertedTime);
	}
	UnLockQ();
	TraceFunctLeaveEx((LPARAM)this);
}

//---[ CRETRY_Q::StealQueueEntries ]-------------------------------------------
//
//
//  Description: 
//      Used to swap entries with tmp queue during config update.
//  Parameters:
//      pRetryQueue     Queue to swap entries with.
//  Returns:
//      -
//  History:
//      10/12/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CRETRY_Q::StealQueueEntries(CRETRY_Q *pRetryQueue)
{
    _ASSERT(IsListEmpty(&m_QHead));

    //Update our head
    if (!IsListEmpty(&(pRetryQueue->m_QHead)))
    {
        m_QHead.Flink = pRetryQueue->m_QHead.Flink;
        m_QHead.Flink->Blink = &m_QHead;
        m_QHead.Blink = pRetryQueue->m_QHead.Blink;
        m_QHead.Blink->Flink = &m_QHead;
    }

    //Now mark other queue as empty
    InitializeListHead(&(pRetryQueue->m_QHead));
}

/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\timemath.h ===
// timemath.h---written by Bill Griffin (Billgr)

#if !defined(_TIMEMATH_H_)
#define _TIMEMATH_H_

const __int64 hnsPerMillisecond  = 10000i64;
const __int64 hnsPerSecond       = 10000000i64;
const __int64 hnsPerMinute       = 600000000i64;
const __int64 hnsPerHour         = 36000000000i64;
const __int64 hnsPerDay          = 864000000000i64;

inline __int64 MsFromHns(__int64 hns)
    { return hns / hnsPerMillisecond; }
inline __int64 SecFromHns(__int64 hns)
    { return hns / hnsPerSecond; }
inline __int64 MinFromHns(__int64 hns)
    { return hns / hnsPerMinute; }
inline __int64 HrFromHns(__int64 hns)
    { return hns / hnsPerHour; }
inline __int64 DayFromHns(__int64 hns)
    { return hns / hnsPerDay; }

inline  __int64 HnsFromMs(__int64 ms)
    { return ms * hnsPerMillisecond; }
inline  __int64 HnsFromSec(__int64 sec)
    { return  sec * hnsPerSecond; }
inline  __int64 HnsFromMin(__int64 min)
    { return  min * hnsPerMinute; }
inline  __int64 HnsFromHr(__int64 hr)
    { return  hr * hnsPerHour; }
inline  __int64 HnsFromDay(__int64 day)
    { return day * hnsPerDay; }

inline __int64 HnsFromFt(FILETIME ft)
    { return *((__int64*)&ft); }
inline __int64 HnsFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HnsFromFt(ftEnd) - HnsFromFt(ftStart); }
inline __int64 SecFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return SecFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 MinFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return MinFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 HrFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return HrFromHns(HnsFromFtSpan(ftStart, ftEnd)); }
inline __int64 DayFromFtSpan(FILETIME ftStart, FILETIME ftEnd)
    { return DayFromHns(HnsFromFtSpan(ftStart, ftEnd)); }

//NimishK - some more good stuff related to the time math issues
#define I64_LI(cli) (*((__int64*)&cli))
#define LI_I64(i) (*((LARGE_INTEGER*)&i))
#define INT64_FROM_LARGE_INTEGER(cli) I64_LI(cli)
#define LARGE_INTEGER_FROM_INT64(i) LI_I64(i)

#define I64_FT(ft) (*((__int64*)&ft))
#define FT_I64(i) (*((FILETIME*)&i))
#define INT64_FROM_FILETIME(ft) I64_FT(ft)
#define FILETIME_FROM_INT64(i) FT_I64(i)

#endif // !defined(_TIMEMATH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\rhash.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       rhash.h

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

        Nimish Khanolkar   (NimishK)       May-98 

--*/

#ifndef _RHASH_H_
#define _RHASH_H_

#include <windows.h>
#include <limits.h>


#define RETRY_TABLE_SIGNATURE_VALID		'RtsV'
#define RETRY_TABLE_SIGNATURE_FREE		'RtsF'

class RETRYQ;


typedef struct HASH_BUCKET_ENTRY
{
    DWORD       m_NumEntries;
    LONG        m_RefNum;
    LIST_ENTRY  m_ListHead;
    CShareLockNH  m_Lock;

    HASH_BUCKET_ENTRY (void)
    {
        InitializeListHead(&m_ListHead);
        m_NumEntries = 0;
        m_RefNum = 0;
    }

}BUCKET_ENTRY, *PBUCKET_ENTRY;

#define BITS_IN_int     (sizeof(int) * CHAR_BIT)
#define THREE_QUARTERS  ((int) ((BITS_IN_int * 3) / 4))
#define ONE_EIGHTH      ((int) (BITS_IN_int / 8))
#define HIGH_BITS       (~((unsigned int)(~0) >> ONE_EIGHTH))
#define TABLE_SIZE      241

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE:
//
// A hash table to store all the domains that are in the Retry queue.
// The hash key is the name of the domain
//
/////////////////////////////////////////////////////////////////////////////////

class CRETRY_HASH_TABLE
{
    protected:
        DWORD   m_Signature;
        LONG    m_TotalEntries;
        HASH_BUCKET_ENTRY m_HashTable[TABLE_SIZE];
		RETRYQ*	m_pRetryQueue;

    public:

		CRETRY_HASH_TABLE();
        ~CRETRY_HASH_TABLE();
		HRESULT DeInitialize(void);
		void RemoveAllEntries(void);
		void RemoveThisEntry(CRETRY_HASH_ENTRY * pHashEntry, DWORD BucketNum);

        BOOL RemoveFromTable(const char * SearchData, CRETRY_HASH_ENTRY* *ppExistingEntry);
        BOOL InsertIntoTable (CRETRY_HASH_ENTRY * pHashEntry);
 
        BOOL IsTableEmpty(void) const {return (m_TotalEntries == 0);}
		BOOL IsHashTableValid(void){ return (m_Signature == RETRY_TABLE_SIGNATURE_VALID);} 

		RETRYQ*	GetQueuePtr(){return m_pRetryQueue;}

        //An adaptation of Peter Weinberger's (PJW) generic
        //hashing algorithm based on Allen Holub's version.
        //Code from Practical Algorithms for Programmers
        //by Andrew Binstock
        unsigned int HashFunction (const char * String)
        {
            unsigned int HashValue = 0;
            unsigned int i = 0;

            _ASSERT(String != NULL);

            for (HashValue = 0; String && *String; ++String)
            {
                HashValue = (HashValue << ONE_EIGHTH) + * String;
                if((i = HashValue & HIGH_BITS) != 0)
                {
                    HashValue = (HashValue ^ (i >> THREE_QUARTERS)) & ~ HIGH_BITS;
                }
            }

            HashValue %= TABLE_SIZE;
            return HashValue;
        }

	private:
		//Unused functions
#if 0		
		DWORD PrimaryCompareFunction(const char * SearchData, CRETRY_HASH_ENTRY * pExistingEntry)
		{
			DWORD Result = 0;
			Result = lstrcmpi(SearchData, pExistingEntry->GetHashKey());
			return Result;
		}
				
		CRETRY_HASH_ENTRY * FindHashData(const char * SearchData);

        LIST_ENTRY & GetBucketHead(DWORD BucketNum)
        {
            return m_HashTable[BucketNum].m_ListHead;
        }
#endif

	public:
		//debug function
		void PrintAllEntries(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\retrsink\rhash.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       rhash.cxx

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

  		Nimish Khanolkar     (NimishK)		

--*/
#include "precomp.h"

CRETRY_HASH_TABLE::CRETRY_HASH_TABLE()
{
    TraceFunctEnterEx((LPARAM)this, 
			    "CRETRY_HASH_TABLE::CRETRY_HASH_TABLE");
    m_TotalEntries = 0;
    m_Signature = RETRY_TABLE_SIGNATURE_VALID;
	    
    TraceFunctLeaveEx((LPARAM)this);
}

CRETRY_HASH_TABLE::~CRETRY_HASH_TABLE()
{
    TraceFunctEnterEx((LPARAM)this, 
			    "CRETRY_HASH_TABLE::~CRETRY_HASH_TABLE");

    m_Signature = RETRY_TABLE_SIGNATURE_FREE;

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::DeInitialize
//
// Very Basic.
// By this time there should be no threads adding anything to the hash table
// Frees up all the entries in the hash table
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT CRETRY_HASH_TABLE::DeInitialize(void)
{
    //Remove all the entries from the HashTable
    RemoveAllEntries();
    delete this;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveThisEntry
//
// Need to add code to remove entry from retry q as well
//
/////////////////////////////////////////////////////////////////////////////////
void CRETRY_HASH_TABLE::RemoveThisEntry(CRETRY_HASH_ENTRY * pHashEntry, 
                                        DWORD BucketNum)
{
    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveThisEntry");
    DebugTrace((LPARAM)this, "removing %s from hash table", 
                                                pHashEntry->GetHashKey());

    m_HashTable[BucketNum].m_Lock.ExclusiveLock();
    RemoveEntryList(&pHashEntry->QueryHListEntry());
    m_HashTable[BucketNum].m_Lock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveAllEntries
//
// To be clean : Need to add code to remove each entry from retry q as well
// But not really needed as I will not be leaking anything if I simply destroy the
// queue
//
/////////////////////////////////////////////////////////////////////////////////

void CRETRY_HASH_TABLE::RemoveAllEntries(void)
{
    DWORD LoopVar = 0;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY pEntry = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveAllEntries");

    for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
    {
        m_HashTable[LoopVar].m_Lock.ExclusiveLock();
        HeadOfList = &m_HashTable[LoopVar].m_ListHead;
        while (!IsListEmpty(HeadOfList))
        {
            //remove the entries from the list
            pEntry = RemoveHeadList (HeadOfList);
            pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_HLEntry);

            _ASSERT(pHashEntry->IsValid());

            DebugTrace((LPARAM)this, "removing %s from hash table. RefCnt = %d", 
			            pHashEntry->GetHashKey(),  pHashEntry->QueryRefCount());

            pHashEntry->ClearInTable();

            pHashEntry->DecRefCount();

            //decrement entry counts
            m_HashTable[LoopVar].m_NumEntries--;
            InterlockedIncrement(&(m_HashTable[LoopVar].m_RefNum));
            InterlockedDecrement(&m_TotalEntries);
        }
        m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
    }

    TraceFunctLeaveEx((LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::PrintAllEntries
//
// Should not use this one - not really useful.
// Instead Use RETRYQ::PrintAllQEntries()
//
/////////////////////////////////////////////////////////////////////////////////
//
void CRETRY_HASH_TABLE::PrintAllEntries(void)
{

    DWORD LoopVar = 0;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY  pEntry = NULL;
    PLIST_ENTRY  pentryNext = NULL;
    CRETRY_HASH_ENTRY * pHashEntry = NULL;

    for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
    {
        m_HashTable[LoopVar].m_Lock.ExclusiveLock();
        HeadOfList = &m_HashTable[LoopVar].m_ListHead;
        pEntry = m_HashTable[LoopVar].m_ListHead.Flink;
        for(; pEntry != HeadOfList; pEntry = pentryNext)
        {
            pentryNext = pEntry->Flink;
            pHashEntry = CONTAINING_RECORD(pEntry, CRETRY_HASH_ENTRY, m_HLEntry);
            printf("%s i n bucket %d\n", pHashEntry->GetHashKey(), LoopVar);
        }
        m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
    }

}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::InsertIntoTable
//
// We insert a new entry into the table 
// If we find an existing one for the same domain we remove it and add this new 
// one
// Adding an entry to the Hash Table also results in adding the entry to the retry 
// queue ordered on the RetryTime
//
/////////////////////////////////////////////////////////////////////////////////
//
BOOL CRETRY_HASH_TABLE::InsertIntoTable(CRETRY_HASH_ENTRY * pHashEntry)
{
    unsigned int HashValue = 0;
    char * NewData = NULL;
    char * ExistingData = NULL;
    PLIST_ENTRY	HeadOfList = NULL;
    PLIST_ENTRY ListEntry =NULL;
    CRETRY_HASH_ENTRY * pExistingEntry = NULL;
    int Result = 0;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::InsertIntoTable");

    _ASSERT(pHashEntry != NULL);

    if(pHashEntry == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //get the new key
    NewData = pHashEntry->GetHashKey();

    _ASSERT(NewData != NULL);

    if(NewData == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    CharLowerBuff((char *)NewData, lstrlen(NewData));

    //get the hash value for it
    HashValue = HashFunction (NewData);

    //lock the list exclusively
    m_HashTable[HashValue].m_Lock.ExclusiveLock();

    //insert the head of the list for this bucket
    //duplicates are dealt by removing the dup entry and
    //adding the new one
    HeadOfList = &m_HashTable[HashValue].m_ListHead;

    for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
	    ListEntry = ListEntry->Flink)
    {
        _ASSERT(ListEntry != NULL);
        pExistingEntry = CONTAINING_RECORD(ListEntry, CRETRY_HASH_ENTRY, m_HLEntry);
        
        if(pExistingEntry && pExistingEntry->IsValid())
        {
            //So we got a valid entry
            ExistingData = pExistingEntry->GetHashKey();
        }
        else
        {
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_INVALID_DATA);
            //We have a corrupt entry in the hash table
            DebugTrace((LPARAM)this, "hash table bucket %d has a currupt entry listEntry ", 
									            HashValue);
            _ASSERT(pExistingEntry->IsValid());
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        _ASSERT(ExistingData != NULL);

        Result = lstrcmpi(NewData, ExistingData);
        if(Result < 0)
        {
            break;
        }
        else if(Result == 0)
        {

            //So there is already a Hash Entry
            DebugTrace((LPARAM)this, "%s is already in hash table ", 
									            pHashEntry->GetHashKey());

            //If we already have an entry in there - we will live with it 
            //For the time being, we will taking the approach that if something 
            //makes us establish a new connection before the retry interval and
            //we fail the connection, then we simply ignore the failure and stick
            //with the original retry interval
            //eg at 2:00pm we inserted something for retry at 2:30pm
            //	 at 2:20pm something triggers this domain, but the connection fails
            //   Instead of updating the retry queue to now retry at 2:50 pm, 
            //	 we will instead retry at 2:30pm as orginally planned.

            //unlock this bucket
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_FILE_EXISTS);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
    }

    // Ok, insert the entry here here.

    //inc the ref count on the hash entry
    pHashEntry->IncRefCount();

    //We just added the entry the ref count cannot be anything but 1
    _ASSERT(pHashEntry->QueryRefCount() == 1);
    _ASSERT(ListEntry != NULL);

    //Insert into the hash bucket list before the exisitng entry
    InsertTailList(ListEntry, &pHashEntry->QueryHListEntry());
    pHashEntry->SetInTable();

    //update total entries in this bucket
    m_HashTable[HashValue].m_NumEntries++;

    DebugTrace((LPARAM)this, "inserted %s into hash table. RefCnt = %d", 
					    pHashEntry->GetHashKey(), pHashEntry->QueryRefCount());

    //update numentries in this bucket
    InterlockedIncrement(&m_TotalEntries);

    //unlock this bucket
    m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// CRETRY_HASH_TABLE::RemoveFromTable
//
// We insert a new entry into the table 
// If we find an existing one for the same domain we remove it and add this new 
// one
// Adding an entry to the Hash Table also results in adding the entry to the retry 
// queue ordered on the RetryTime
//
/////////////////////////////////////////////////////////////////////////////////

BOOL CRETRY_HASH_TABLE::RemoveFromTable(const char * SearchData, 
										PRETRY_HASH_ENTRY *ppExistingEntry)
{
    unsigned int HashValue;
    char * ExistingData = NULL;
    PLIST_ENTRY	HeadOfList;
    PLIST_ENTRY ListEntry;
    int Result = 0;

    TraceFunctEnterEx((LPARAM)this, "CRETRY_HASH_TABLE::RemoveFromTable");

    _ASSERT(SearchData != NULL);

    if(SearchData == NULL)
    {
        return FALSE;
    }

    CharLowerBuff((char *)SearchData, lstrlen(SearchData));

    //get the hash value
    HashValue = HashFunction (SearchData);

    m_HashTable[HashValue].m_Lock.ExclusiveLock();

    HeadOfList = &m_HashTable[HashValue].m_ListHead;

    for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
                                        ListEntry = ListEntry->Flink)
    {
        _ASSERT(ListEntry != NULL);
        *ppExistingEntry = CONTAINING_RECORD(ListEntry, CRETRY_HASH_ENTRY, m_HLEntry);
        //ExistingData = (*ppExistingEntry)->GetHashKey();

        if((*ppExistingEntry) && (*ppExistingEntry)->IsValid())
        {
            //So we got a valid entry
            ExistingData = (*ppExistingEntry)->GetHashKey();
        }
        else
        {
            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
            SetLastError(ERROR_INVALID_DATA);
            //We have a corrupt entry in the hash table
            DebugTrace((LPARAM)this, 
                "hash table bucket %d has a currupt entry listEntry ", 
	            HashValue);
            _ASSERT((*ppExistingEntry)->IsValid());
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        _ASSERT(ExistingData != NULL);

        Result = lstrcmpi(SearchData,ExistingData);
        if(Result == 0)
        {
            DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

            //found it
            //Remove it from this bucket list
            RemoveEntryList(ListEntry);
            (*ppExistingEntry)->ClearInTable();

            m_HashTable[HashValue].m_NumEntries--;

            InterlockedDecrement(&m_TotalEntries);

            m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
        else if ( Result < 0 )
            break;
    }

    //duplicates are not allowed
    SetLastError(ERROR_PATH_NOT_FOUND);
    *ppExistingEntry = NULL;
    m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\dnsdiag\dnsdiag.h ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Abstract:
//
//      Include file for DNS diagnostic tool.
//
//  Author:
//
//      gpulla
//
//-----------------------------------------------------------------------------

// IISRTL, ATQ APIs
#include <atq.h>
#include <irtlmisc.h>

// Winsock
#include <winsock2.h>

// DNS API
#include <dns.h>
#include <dnsapi.h>

// Metabase property definitions
#include <smtpinet.h>
#include <iiscnfg.h>

// Metabase COM access APIs
#define INITGUID
#include <iadmw.h>

// DSGetDC
#include <lm.h>
#include <lmapibuf.h>
#include <dsgetdc.h>

// ADSI headers
#include <activeds.h>

// ldap stuff
#include <winldap.h>

// SMTP specific stuff
#include <rwnew.h>

// These #defines are needed for cdns.h
#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2)

#include "cdns.h"

//
// Program return codes and descriptions
// 0 is always success and the other error codes indicate some failure.
//

// The name was resolved successfully to one or more IP addresses.
#define DNSDIAG_RESOLVED                  0

// The name could not be resolved due to some unspecified error.
#define DNSDIAG_FAILURE                   1

// The name does not exist - a "NOT FOUND" error was returned by a server
// authoritative for the domain in which the name is.
#define DNSDIAG_NON_EXISTENT              2

// The name could not be found in DNS.
#define DNSDIAG_NOT_FOUND                 3

// Loopback detected
#define DNSDIAG_LOOPBACK                  4

extern int g_nProgramStatus;

//
// Helper function to set the global program return status code to a more
// specific error than the generic DNSDIAG_FAILURE. Note that this is not
// thread-safe.
//
inline void SetProgramStatus(DWORD dwCode)
{
    if(g_nProgramStatus == DNSDIAG_FAILURE)
        g_nProgramStatus = dwCode;
}

extern DWORD g_cDnsObjects;

//
// handy function for DWORD -> stringized IP conversion.
// inet_ntoa is cumbersome to use directly since the DWORD needs to
// be either cast to an in_addr struct, or copied to an in_addr first
// This function casts the *address* of the DWORD to in_addr ptr, and
// then de-references the pointer to make the cast work, before passing
// it to inet_ntoa. The string returned by inet_ntoa is valid till
// another winsock call is made on the thread (see SDK documentation).
//

inline char *iptostring(DWORD dw)
{
    return inet_ntoa(
                        *( (in_addr *) &dw  )
                    );
}

void PrintIPArray(PIP_ARRAY pipArray, char *pszPrefix = "")
{
    for(DWORD i = 0; i < pipArray->cAddrCount; i++)
        printf("%s%s\n", pszPrefix, iptostring(pipArray->aipAddrs[i]));
}

//------------------------------------------------------------------------------
//  Description:
//      Utility function to print descriptions of errors that may occur while
//      reading from the metabase.
//
//  Arguments:
//      IN HRESULT hr - Metabase access error HRESULT
//
//  Returns:
//      String (static) indicating the error that occurred.
//------------------------------------------------------------------------------
inline const char *MDErrorToString(HRESULT hr)
{
    static const DWORD dwErrors[] =
    {
        ERROR_ACCESS_DENIED,
        ERROR_INSUFFICIENT_BUFFER,
        ERROR_INVALID_PARAMETER,
        ERROR_PATH_NOT_FOUND,
        MD_ERROR_DATA_NOT_FOUND
    };

    static const char *szErrors[] =
    {
        "ERROR_ACCESS_DENIED",
        "ERROR_INSUFFICIENT_BUFFER",
        "ERROR_INVALID_PARAMETER",
        "ERROR_PATH_NOT_FOUND",
        "MD_ERROR_DATA_NOT_FOUND"
    };

    static const char szUnknown[] = "Unknown Error";

    for(int i = 0; i < sizeof(dwErrors)/sizeof(DWORD); i++)
    {
        if(HRESULT_FROM_WIN32(dwErrors[i]) == hr)
            return szErrors[i];
    }

    return szUnknown;
}

inline const char *QueryType(DWORD dwDnsQueryType)
{
    DWORD i = 0;
    static const DWORD rgdwQueryTypes[] =
    {
        DNS_TYPE_MX,
        DNS_TYPE_A,
        DNS_TYPE_CNAME
    };

    static const char *rgszQueryTypes[] =
    {
        "MX",
        "A",
        "CNAME"
    };

    static const char szUnknown[] = "Unknown Type";

    for(i = 0; i < sizeof(rgdwQueryTypes)/sizeof(DWORD); i++)
    {
        if(rgdwQueryTypes[i] == dwDnsQueryType)
            return rgszQueryTypes[i];
    }
    return szUnknown;
}

inline void GetSmtpFlags(DWORD dwFlags, char *pszFlags, DWORD cchFlags)
{
    if(dwFlags == DNS_FLAGS_TCP_ONLY)
    {
        _snprintf(pszFlags, cchFlags, " TCP only");
        return;
    }

    if(dwFlags == DNS_FLAGS_UDP_ONLY)
    {
        _snprintf(pszFlags, cchFlags, " UDP only");
        return;
    }

    if(dwFlags == DNS_FLAGS_NONE)
    {
        _snprintf(pszFlags, cchFlags, " UDP default, TCP on truncation");
        return;
    }

    _snprintf(pszFlags, cchFlags, " Unknown flag");
}

inline void GetDnsFlags(DWORD dwFlags, char *pszFlags, DWORD cchFlags)
{
    DWORD i = 0;
    DWORD dwScratchFlags = dwFlags; // Copy of dwFlags: will be overwritten
    char *pszStartBuffer = pszFlags;
    int cchWritten = 0;
    BOOL fFlagsSet = FALSE;

    static const DWORD rgdwDnsFlags[] =
    {
        DNS_QUERY_STANDARD,
        DNS_QUERY_USE_TCP_ONLY,
        DNS_QUERY_NO_RECURSION,
        DNS_QUERY_BYPASS_CACHE,
        DNS_QUERY_CACHE_ONLY,
        DNS_QUERY_TREAT_AS_FQDN,
    };
        
    static const char *rgszDnsFlags[] =
    {
        "DNS_QUERY_STANDARD",
        "DNS_QUERY_USE_TCP_ONLY",
        "DNS_QUERY_NO_RECURSION",
        "DNS_QUERY_BYPASS_CACHE",
        "DNS_QUERY_CACHE_ONLY",
        "DNS_QUERY_TREAT_AS_FQDN"
    };

    for(i = 0; i < sizeof(rgdwDnsFlags)/sizeof(DWORD);i++)
    {
        if(rgdwDnsFlags[i] & dwScratchFlags)
        {
            fFlagsSet = TRUE;
            dwScratchFlags &= ~rgdwDnsFlags[i];
            cchWritten = _snprintf(pszFlags, cchFlags, " %s", rgszDnsFlags[i]);
            if(cchWritten < 0)
            {
                sprintf(pszStartBuffer, " %s", "Error");
                return;
            }
            pszFlags += cchWritten;
            cchFlags -= cchWritten;
        }
    }

    if(!fFlagsSet)
        sprintf(pszStartBuffer, " %s", "No flags");

    if(dwScratchFlags)
        sprintf(pszStartBuffer, " %x is %s", dwScratchFlags, "Unknown!");
}

void PrintRecordList(PDNS_RECORD pDnsRecordList, char *pszPrefix = "");

void PrintRecord(PDNS_RECORD pDnsRecord, char *pszPrefix = "");

class CSimpleDnsServerList : public CDnsServerList
{
public:

    //
    // It is meaningful to have this > 1 only if you have several async queries
    // pending at the same time. In the DNS tool only 1 async query is
    // outstanding at any given time.
    //

    DWORD ConnectsAllowedInProbation()
        {   return 1;   }
    
    //
    // SMTP actually has 3 retries before failing over, but that is because it
    // has dozens of queries going out per minute. If even a small percent of
    // those fail due to network errors, DNS servers will be quickly marked down.
    // This is not a factor here though.
    //

    DWORD ErrorsBeforeFailover()
        {   return 1;   }

    void LogServerDown(
        DWORD dwServerIp,
        BOOL fUdp,
        DWORD dwErr,
        DWORD cUpServers)
        {   return;     }

};

class CAsyncTestDns : public CAsyncMxDns
{
private:
    BOOL    m_fGlobalList;
    HANDLE  m_hCompletion;
public:

    //
    // Custom new/delete operators. They simply call into the global operators,
    // but additionally they track the number of DNS objects still "alive". This
    // is needed so that we know when we can shutdown ATQ/IISRTL. Terminating
    // ATQ/IISRTL before all DNS objects have been completely destructed can mean
    // leaked ATQ contexts and all sorts of AV's (and ASSERTS in debug). Note that
    // it is inadequate to signal termination in ~CAsyncTestDns, since the base
    // class destructor ~CAsyncDns is yet to be called at that point.
    //

    void *operator new(size_t size)
    {
        void *pvNew = ::new BYTE[sizeof(CAsyncTestDns)];

        InterlockedIncrement((PLONG)&g_cDnsObjects);
        return pvNew;
    }

    void operator delete(void *pv, size_t size)
    {
        ::delete ((CAsyncTestDns *)pv);
        InterlockedDecrement((PLONG)&g_cDnsObjects);
    }

    CAsyncTestDns(char *pszMyFQDN, BOOL fGlobalList, HANDLE hCompletion)
        : CAsyncMxDns(pszMyFQDN),
          m_fGlobalList(fGlobalList),
          m_hCompletion(hCompletion)
        {   }

    ~CAsyncTestDns();

    // virtual functions implemented by us
    BOOL RetryAsyncDnsQuery(BOOL fUdp);

    void HandleCompletedData(DNS_STATUS status);

    BOOL IsShuttingDown()
        {   return FALSE;   }

    BOOL IsAddressMine(DWORD dwIp);
};

class CDnsLogToFile : public CDnsLogger
{
public:
    // Definitions of virtual functions
    void DnsPrintfMsg(char *szFormat, ...);
    
    void DnsPrintfErr(char *szFormat, ...);

    void DnsPrintfDbg(char *szFormat, ...);
    
    void DnsLogAsyncQuery(
        char *pszQuestionName,
        WORD wQuestionType,
        DWORD dwFlags,
        BOOL fUdp,
        CDnsServerList *pDnsServerList);

    void DnsLogApiQuery(
        char *pszQuestionName,
        WORD wQuestionType,
        DWORD dwApiFlags,
        BOOL fGlobal,
        PIP_ARRAY pipServers);

    void DnsLogResponse(
        DWORD dwStatus,
        PDNS_RECORD pDnsRecordList,
        PBYTE pbMsg,
        DWORD wMessageLength);

    // Utility functions
    void DnsLogServerList(CDnsServerList *pDnsServerList);

    void DnsLogRecordList(PDNS_RECORD pDnsRecordList)
        {   PrintRecordList(pDnsRecordList); }

    void DnsPrintRecord(PDNS_RECORD pDnsRecord)
        {   PrintRecord(pDnsRecord); }

    void DnsPrintIPArray(PIP_ARRAY pipArray)
        {   PrintIPArray(pipArray); }

};

BOOL ParseCommandLine(
    int argc,
    char *argv[],
    char *pszHostName,
    DWORD cchHostName,
    CDnsLogToFile **ppDnsLogger,
    PIP_ARRAY pipArray,
    DWORD cMaxServers,
    BOOL *pfUdp,
    DWORD *pdwDnsFlags,
    BOOL *pfGlobalList,
    BOOL *pfTryAllServers);

HRESULT HrGetVsiConfig(
    LPSTR pszTargetHost,
    DWORD dwVsid,
    PDWORD pdwFlags,
    PIP_ARRAY pipDnsServers,
    DWORD cMaxServers,
    BOOL *pfUdp,
    BOOL *pfGlobalList,
    PIP_ARRAY pipServerBindings,
    DWORD cMaxServerBindings);

DWORD IsExchangeInstalled(BOOL *pfInstalled);

DWORD DsGetConfiguration(
    char *pszServer,
    DWORD dwVsid,
    PIP_ARRAY pipDnsServers,
    DWORD cMaxServers,
    PBOOL pfExternal);

DWORD DsFindExchangeServer(
    PLDAP pldap,
    LPSTR szBaseDN,
    LPSTR szHostDnsName,
    LPSTR *ppszServerDN,
    BOOL *pfFound);

PLDAP BindToDC();

BOOL GetServerBindings(
    WCHAR *pwszMultiSzBindings,
    PIP_ARRAY pipServerBindings,
    DWORD cMaxServerBindings);

void SetMsgColor();
void SetErrColor();
void SetNormalColor();

void msgprintf(char *szFormat, ...);
void errprintf(char *szFormat, ...);
void dbgprintf(char *szFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\isrpcexp.h ===
//
//  Dll initialization and termination
//

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

dllexp
BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

dllexp
CleanupServiceRpc(
               VOID
               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\dnsdiag\main.cpp ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Abstract:
//
//      Source file for DNS diagnostic tool. Links into dnslib.lib which has
//      the SMTP DNS resolution logic and calls into DNS resolution functions
//      while printing diagnostic messages.
//
//  Author:
//
//      gpulla
//
//-----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include "dnsdiag.h"

int g_nProgramStatus = DNSDIAG_FAILURE;
CDnsLogger *g_pDnsLogger = NULL;
HANDLE g_hCompletion = NULL;
BOOL g_fDebug = FALSE;
DWORD g_cDnsObjects = 0;
HANDLE g_hConsole = INVALID_HANDLE_VALUE;
DWORD g_rgBindings[32];
PIP_ARRAY g_pipBindings = (PIP_ARRAY)g_rgBindings;
DWORD g_cMaxBindings = sizeof(g_rgBindings)/sizeof(DWORD) - 1;

char g_szUsage[] =
    "Summary:\n"
    "\n"
    "This tool is used to troubleshoot problems with DNS resolution for SMTP. It\n"
    "simulates SMTPSVC's internal code-path and prints diagnostic messages that\n"
    "indicate how the resolution is proceeding. The tool must be run on the machine\n"
    "where the DNS problems are occurring.\n"
    "\n"
    "Program return codes:\n"
    "   These are set as the ERRORLEVEL for usage in batch files.\n"
    "\n"
    "   0 - The name was resolved successfully to one or more IP addresses.\n"
    "   1 - The name could not be resolved due to an unspecified error.\n"
    "   2 - The name does not exist. The error was returned by an authoritative DNS\n"
    "       server for the domain.\n"
    "   3 - The name could not be located in DNS. This is not an error from the\n" 
    "       authoritative DNS server.\n"
    "   4 - A loopback was detected.\n"
    "\n"
    "Usage:\n"
    "\n"
    "dnsdiag <hostname> [-d] [options]\n"
    "\n"
    "<hostname>\n"
    "    Hostname to query for. Note that this may not be the same as the display\n"
    "    -name of the queue (in ESM, if Exchange is installed). It should be the\n"
    "    fully-qualified domain name of the target for the queue seeing the DNS\n"
    "    errors\n"
    "\n"
    "-d\n"
    "   This is a special option to run in debug/verbose mode. There is a lot of\n"
    "   output, and the most important messages (the ones that normally appear when\n"
    "   this mode is not turned on) are highlighted in a different color.\n"
    "\n"
    "Options are:\n"
    "-v <VSID>\n"
    "   If running on an Exchange DMZ machine, you can specify the VSI# of the\n"
    "   VSI to simulate DNS for that SMTP VS. Then this tool will read the\n"
    "   external DNS serverlist for that VSI and query that serverlist for\n"
    "   <hostname> when <hostname> is an \"external\" host. If <hostname> is the\n"
    "   name of an Exchange computer, the query is generated against the default\n"
    "   DNS servers for the local computer.\n"
    "\n"
    "-s <serverlist>\n"
    "   DNS servers to use, if you want to specify a specific set of servers.\n"
    "\n"
    "   If this option is not specified, the default DNS servers on the local\n"
    "   computer are used as specified by -v.\n"
    "\n"
    "   This option is incompatible with -v.\n"
    "\n"
    "-p <protocol>\n"
    "   TCP, UDP or DEF. TCP generates a TCP only query. UDP generates a UDP only\n"
    "   query. DEF generates a default query that will initially query a server with\n"
    "   UDP, and then if that query results in a truncated reply, it will be retried\n"
    "   with TCP.\n"
    "\n"
    "   If this option is not specified the protocol configured in the metabase for\n"
    "   /smtpsvc/UseTcpDns is used.\n"
    "\n"
    "   This option is incompatible with the -v option.\n"
    "\n"
    "-a\n"
    "   All the DNS servers obtained (either through the registry, active directory,\n"
    "   or -s option) are tried in sequence and the results of querying each are\n"
    "   displayed.\n";


//-----------------------------------------------------------------------------
//  Description:
//      DNS diagnostic utility. See above for usage.
//-----------------------------------------------------------------------------
int __cdecl main(int argc, char *argv[])
{
    CAsyncTestDns *pAsyncTestDns = NULL;
    CSimpleDnsServerList *pDnsSimpleList = NULL;
    CDnsLogToFile *pDnsLogToFile = NULL;
    char szMyHostName[MAX_PATH + 1];
    char szHostName[MAX_PATH + 1];
    BOOL fAtqInitialized = FALSE;
    BOOL fIISRTLInitialized = FALSE;
    BOOL fWSAInitialized = FALSE;
    WORD wVersion = MAKEWORD(2, 2);
    WSADATA wsaData;
    BOOL fRet = TRUE;
    int nRet = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwDnsFlags = 0;
    BOOL fUdp = TRUE;
    BOOL fGlobalList = FALSE;
    BOOL fTryAllDnsServers = FALSE;    
    DWORD rgDnsServers[16];
    PIP_ARRAY pipArray = (PIP_ARRAY)rgDnsServers;
    DWORD cMaxServers = sizeof(rgDnsServers)/sizeof(DWORD) - 1;
    DWORD rgSingleServer[2];
    PIP_ARRAY pipSingleServer = (PIP_ARRAY)rgSingleServer;
    DWORD cNextServer = 0;
    PIP_ARRAY pipDnsArray = NULL;

    ZeroMemory(rgDnsServers, sizeof(rgDnsServers));
    ZeroMemory(rgSingleServer, sizeof(rgSingleServer));
    ZeroMemory(g_rgBindings, sizeof(g_rgBindings));

    if(1 == argc)
    {
        SetProgramStatus(DNSDIAG_RESOLVED);
        printf("%s", g_szUsage);
        goto Cleanup;
    }

    nRet = WSAStartup(wVersion, &wsaData);
    if(0 != nRet)
    {
        errprintf("Failed Winsock init, error - %d\n", WSAGetLastError());
        goto Cleanup;
    }

    fWSAInitialized = TRUE;

    if(0 != gethostname(szMyHostName, sizeof(szMyHostName)))
    {
        printf("Unable to get local machine name. Error - %d\n",
            WSAGetLastError());
        goto Cleanup;
    }

    g_hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    if(g_hConsole == INVALID_HANDLE_VALUE)
    {
        printf("Failed to GetStdHandle\n");
        goto Cleanup;
    }

    g_hCompletion = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(NULL == g_hCompletion)
        goto Cleanup;

    dbgprintf("Reading options and configuration.\n");
    fRet = ParseCommandLine(argc, argv, szHostName,
               sizeof(szHostName), &pDnsLogToFile, pipArray, cMaxServers,
               &fUdp, &dwDnsFlags, &fGlobalList, &fTryAllDnsServers);

    if(!fRet)
        goto Cleanup;
    
    g_pDnsLogger = (CDnsLogger *)pDnsLogToFile;

    fIISRTLInitialized = InitializeIISRTL();
    if(!fIISRTLInitialized)
    {
        errprintf("Failed IISRTL init, error - %d\n", GetLastError());
        errprintf("Make sure you are running this tool on a server with IIS "
            "installed\n");
        goto Cleanup;
    }

    fAtqInitialized = AtqInitialize(0);
    if(!fAtqInitialized)
    {
        errprintf("Failed ISATQ init, error - %d\n", GetLastError());
        errprintf("Make sure you are running this tool on a server with IIS "
            "installed\n");
        goto Cleanup;
    }

    cNextServer = 0;
    pipSingleServer->cAddrCount = 1;

    while(TRUE)
    {
        //
        // Set pipDnsArray to the DNS servers to be used. If the -a option is
        // specified, each DNS server will be tried individually. We will run
        // through this while loop and set pipDnsArray to single DNS server
        // in turn. If -a is not given, all servers are set on pipDnsServers.
        //

        if(fTryAllDnsServers)
        {
            if(cNextServer >= pipArray->cAddrCount)
                break;

            pipSingleServer->aipAddrs[0] = pipArray->aipAddrs[cNextServer];
            cNextServer++;
            pipDnsArray = pipSingleServer;
            msgprintf("\n\nQuerying DNS server: %s\n",
                iptostring(pipSingleServer->aipAddrs[0]));
        }
        else
        {
            pipDnsArray = pipArray;
        }

        //
        // Create the DNS serverlist object and set however many DNS servers we
        // want to query on the object
        //

        pDnsSimpleList = new CSimpleDnsServerList();
        if(!pDnsSimpleList)
        {
            errprintf("Out of memory creating DNS serverlist object.\n");
            goto Cleanup;
        }

        fRet = pDnsSimpleList->Update(pipDnsArray);
        if(!fRet)
        {
            errprintf("Unable to create DNS serverlist\n");
            goto Cleanup;
        }

        //
        // DNS querying object
        //

        pAsyncTestDns = new CAsyncTestDns(szMyHostName, fGlobalList, g_hCompletion);
        if(!pAsyncTestDns)
        {
            errprintf("Out of memory allocating DNS object.\n");
            goto Cleanup;
        }

        dwStatus = pAsyncTestDns->Dns_QueryLib(
                                        szHostName,
                                        DNS_TYPE_MX,
                                        dwDnsFlags,
                                        fUdp,
                                        pDnsSimpleList,
                                        fGlobalList);


        //
        // If the query failed we need to manually delete the object. If the
        // query succeeded, the completing ATQ threads will delete the object
        // after the results have been reported.
        //

        if(dwStatus != ERROR_SUCCESS)
        {
            errprintf("DNS query failed.\n");
            delete pAsyncTestDns;
            pAsyncTestDns = NULL;
        }

        //
        // This event is set in the destructor of pAsyncTestDns when the object
        // has finally finished the query (either successfully or with a failure).
        //

        WaitForSingleObject(g_hCompletion, INFINITE);
        ResetEvent(g_hCompletion);

        delete pDnsSimpleList;
        pDnsSimpleList = NULL;

        //
        // If -a was specified, we go on to the next iteration, and pick up the
        // next DNS server in line. Otherwise we just finish after a single
        // query.
        //

        if(!fTryAllDnsServers)
            break;
    }

Cleanup:
    if(pDnsSimpleList)
        delete pDnsSimpleList;

    while(g_cDnsObjects)
        Sleep(100);

    if(fAtqInitialized)
    {
        dbgprintf("Shutting down ATQ\n");
        AtqTerminate();
    }

    if(fIISRTLInitialized)
    {
        dbgprintf("Shutting down IISRTL\n");
        TerminateIISRTL();
    }

    if(fWSAInitialized)
        WSACleanup();

    if(g_hCompletion)
        CloseHandle(g_hCompletion);

    dbgprintf("Exit code: %d\n", g_nProgramStatus);
    exit(g_nProgramStatus);
    return g_nProgramStatus;
}

//-----------------------------------------------------------------------------
//  Description:
//      Parses the argc and argv and gets the various options. Also reads from
//      the metabase and DS to get the configuration as needed.
//
//  Arguments:
//      IN  int argc - Command line arg-count
//      IN  char *argv[] - Command line args
//      OUT char *pszHostName - Pass in buffer to get target host
//      IN  DWORD cchHostName - Length of above buffer in chars
//      OUT CDnsLogToFile **ppDnsLogger - Returns a logging object
//      OUT PIP_ARRAY pipArray - Pass in buffer to get DNS servers
//      IN  int cMaxServers - Number of DNS servers that can be returned above
//      OUT BOOL *pfUdp - Use TCP or UDP for the query
//      OUT DWORD *pdwDnsFlags - Metabase configured SMTP DNS flags
//      OUT BOOL *pfGlobalList - Are the servers global?
//      OUT BOOL *pfTryAllServers - The "-a" option
//
//  Returns:
//      TRUE arguments were successfully parsed, configuration was read without
//          problems, and initialization completed without errors.
//      FALSE there was an error. Abort. This function prints error messages
//          to stdout.
//-----------------------------------------------------------------------------
BOOL ParseCommandLine(
    int argc,
    char *argv[],
    char *pszHostName,
    DWORD cchHostName,
    CDnsLogToFile **ppDnsLogger,
    PIP_ARRAY pipArray,
    DWORD cMaxServers,
    BOOL *pfUdp,
    DWORD *pdwDnsFlags,
    BOOL *pfGlobalList,
    BOOL *pfTryAllServers)
{
    int i = 0;
    BOOL fRet = FALSE;
    HRESULT hr = E_FAIL;
    BOOL fOptionS = FALSE;
    BOOL fOptionV = FALSE;
    BOOL fOptionD = FALSE;
    BOOL fOptionA = FALSE;
    BOOL fOptionP = FALSE;
    DWORD dwVsid = 0;
    DWORD cServers = 0;
    DWORD dwIpAddress = INADDR_NONE;

    *pszHostName = '\0';

    *pfGlobalList = FALSE;
    *pfTryAllServers = FALSE;
    
    if(argc < 2)
    {
        errprintf("Must specify a hostname as first argument.\n");
        printf("%s", g_szUsage);
        return FALSE;
    }
    else if(argc == 2 && (!_stricmp(argv[1], "/?") || !_stricmp(argv[1], "-?")))
    {
        SetProgramStatus(DNSDIAG_RESOLVED);
        printf("%s", g_szUsage);
        return FALSE;
    }

    pszHostName[cchHostName - 1] = '\0';
    strncpy(pszHostName, argv[1], cchHostName);
    if(pszHostName[cchHostName - 1] != '\0')
    {
        errprintf("Hostname too long. Maximum that can be handled by this tool is "
            "%d characters\n", cchHostName);
        return FALSE;
    }

    i = 2;

    while(i < argc)
    {
        if(!g_fDebug && !_stricmp(argv[i], "-d"))
        {
            i++;
            g_fDebug = TRUE;
            printf("Running in debug/verbose mode.\n");
            continue;
        }

        if(!fOptionV && !_stricmp(argv[i], "-v"))
        {
            i++;
            if(i >= argc)
            {
                printf("Specify an SMTP VSI# for -v option.\n");
                goto Cleanup;
            }

            dwVsid = atoi(argv[i]);
            if(dwVsid <= 0)
            {
                printf("Illegal operand to -v. Should be a number > 0.\n");
                goto Cleanup;
            }

            fOptionV = TRUE;
            i++;
            continue;
        }

        if(!fOptionS && !_stricmp(argv[i], "-s"))
        {
            i++;
            if(i >= argc)
            {
                printf("No DNS servers specified for -s option.\n");
                goto Cleanup;
            }

            cServers = 0;
            while(*argv[i] != '-')
            {
                dwIpAddress = inet_addr(argv[i]);
                if(dwIpAddress == INADDR_NONE)
                {
                    printf("Non IP address \"%s\" in -s option.\n", argv[i]);
                    goto Cleanup;
                }

                if(cServers >= cMaxServers)
                {
                    printf("Too many servers in -s. Maximum that can be handled"
                        " by this tool is %d.\n", cMaxServers);
                    goto Cleanup;
                }

                pipArray->aipAddrs[cServers] = dwIpAddress;
                cServers++;
                i++;

                if(i >= argc)
                    break;
            }

            pipArray->cAddrCount = cServers;
            *pdwDnsFlags = 0;
            *pfGlobalList = FALSE;
            fOptionS = TRUE;
            continue;
        }

        if(!fOptionA && !_stricmp(argv[i], "-a"))
        {
            fOptionA = TRUE;
            *pfTryAllServers = TRUE;
            i++;
            continue;
        }

        if(!fOptionP && !_stricmp(argv[i], "-p"))
        {
            i++;

            if(i >= argc)
            {
                printf("Specify protocol for -p option. Either TCP, UDP or"
                    " DEF (for default). Default means that UDP will be tried"
                    " first followed by TCP if the reply was truncated.\n");
            }

            if(!_stricmp(argv[i], "tcp"))
            {
                *pfUdp = FALSE;
                *pdwDnsFlags = DNS_FLAGS_TCP_ONLY;
            }
            else if(!_stricmp(argv[i], "udp"))
            {
                *pfUdp = TRUE;
                *pdwDnsFlags = DNS_FLAGS_UDP_ONLY;
            }
            else if(!_stricmp(argv[i], "def"))
            {
                *pfUdp = TRUE;
                *pdwDnsFlags = DNS_FLAGS_NONE;
            }
            else
            {
                printf("Unrecognized protocol %s\n", argv[i]);
                goto Cleanup;
            }

            i++;
            fOptionP = TRUE;
            continue;
        }

        printf("Unrecognized option \"%s\".\n", argv[i]);
        printf("%s", g_szUsage);
        goto Cleanup;
    }

    if(fOptionV)
    {
        if(fOptionS)
        {
            printf("Options -s and -v are incompatible\n");
            goto Cleanup;
        }

        if(fOptionP)
        {
            printf("Options -p and -v are incompatible\n");
            goto Cleanup;
        }
    }

    *ppDnsLogger = new CDnsLogToFile();
    if(!*ppDnsLogger)
    {
        errprintf("Out of memory creating DNS logger.\n");
        goto Cleanup;
    }

    if(fOptionV)
    {
        hr = HrGetVsiConfig(pszHostName, dwVsid, pdwDnsFlags, pipArray,
                cMaxServers, pfGlobalList, pfUdp, g_pipBindings,
                g_cMaxBindings);

        if(FAILED(hr))
        {
            errprintf("Unable to get VSI configuration\n");
            goto Cleanup;
        }
    }

    if(pipArray->cAddrCount == 0)
    {
        errprintf("Either specify DNS servers using -s, or use -v.\n");
        goto Cleanup;
    }

    return TRUE;

Cleanup:
    if(*ppDnsLogger)
    {
        delete *ppDnsLogger;
        *ppDnsLogger = NULL;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//  Description:
//
//      This function reads from the metabase and the Active directory (if
//      Exchange is installed) to determine the DNS settings for the VSI that
//      is to be simulated. Additionally, if the VSI is configured as a DMZ
//      (i.e. with additional external DNS servers configured in the AD), we
//      determine if the target server is an Exchange computer by searching
//      for it in the directory.
//
//  Arguments:
//
//      IN LPSTR pszTargetServer - Name to resolve
//      IN DWORD dwVsid - VSI to simulate
//      OUT PDWORD pdwFlags - Flags to pass to Dns_QueryLib (from metabase)
//      OUT PIP_ARRAY pipDnsServers - Returns DNS servers to query
//      IN DWORD cMaxServers - Capacity of above buffer
//      OUT BOOL *pfGlobalList - TRUE if default DNS servers are to be used
//      OUT BOOL *pfUdp - Indicates protocol to connect with DNS
//
//  Returns:
//
//      S_OK - If the configuration was successfully read
//      ERROR HRESULT if something failed. Diagnostic error messages are
//          printed.
//-----------------------------------------------------------------------------
HRESULT HrGetVsiConfig(
    LPSTR pszTargetServer,
    DWORD dwVsid,
    PDWORD pdwFlags,
    PIP_ARRAY pipDnsServers,
    DWORD cMaxServers,
    BOOL *pfGlobalList,
    BOOL *pfUdp,
    PIP_ARRAY pipServerBindings,
    DWORD cMaxServerBindings)
{
    HRESULT hr = E_FAIL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fCoInitialized = FALSE;
    IMSAdminBase *pIMeta = NULL;
    METADATA_RECORD mdRecord;
    DWORD dwLength = 0;
    PBYTE pbMDData = (PBYTE) pdwFlags;
    PIP_ARRAY pipTempServers = NULL;
    BOOL fExternal = FALSE;
    WCHAR wszVirtualServer[256];
    WCHAR wszBindings[256];

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr))
    {
        errprintf("Unable to initialize COM. The error HRESULT is 0x%08x\n", hr);
        goto Cleanup;
    }

    fCoInitialized = TRUE;

    // Check metabase configuration for DNS
    hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
            IID_IMSAdminBase, (void **) &pIMeta);

    if(FAILED(hr))
    {
        errprintf("Failed to connect to IIS metabase. Make sure the IISADMIN"
            " service is installed and running and that you are running this"
            " tool with sufficient permissions. The failure HRESULT is"
            " 0x%08x\n", hr);
        goto Cleanup;
    }

    ZeroMemory(&mdRecord, sizeof(mdRecord));
    mdRecord.dwMDIdentifier = MD_SMTP_USE_TCP_DNS;
    mdRecord.dwMDAttributes = METADATA_INHERIT;
    mdRecord.dwMDUserType = IIS_MD_UT_FILE;
    mdRecord.dwMDDataType = DWORD_METADATA;
    mdRecord.dwMDDataLen = sizeof(DWORD);
    mdRecord.pbMDData = pbMDData;

    hr = pIMeta->GetData(METADATA_MASTER_ROOT_HANDLE, L"/LM/SMTPSVC",
            &mdRecord, &dwLength);

    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        *pdwFlags = DNS_FLAGS_NONE;
        dbgprintf("The DNS flags are not explicitly set in the metabase, assuming "
            "default flags - 0x%08x\n", DNS_FLAGS_NONE);
    }
    else if(FAILED(hr))
    {
        errprintf("Error reading key MD_SMTP_USE_TCP_DNS (%d) under /SMTPSVC in"
            " the metabase. The error HRESULT is 0x%08x - %s\n",
            MD_SMTP_USE_TCP_DNS, hr, MDErrorToString(hr));
        goto Cleanup;
    }
    else
    {
        dbgprintf("These DNS flags are configured in the metabase");

        if(*pdwFlags & DNS_FLAGS_UDP_ONLY)
            dbgprintf(" DNS_FLAGS_UDP_ONLY");
        else if(*pdwFlags & DNS_FLAGS_TCP_ONLY)
            dbgprintf(" DNS_FLAGS_TCP_ONLY");

        dbgprintf(" (0x%08x)\n", *pdwFlags);
    }

    mdRecord.dwMDIdentifier = MD_SERVER_BINDINGS;
    mdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdRecord.dwMDUserType = IIS_MD_UT_SERVER;
    mdRecord.dwMDDataType = MULTISZ_METADATA;
    mdRecord.dwMDDataLen = sizeof(wszBindings);
    mdRecord.pbMDData = (PBYTE) wszBindings;

    swprintf(wszVirtualServer, L"/LM/SMTPSVC/%d", dwVsid);
    hr = pIMeta->GetData(METADATA_MASTER_ROOT_HANDLE, wszVirtualServer,
        &mdRecord, &dwLength);

    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        errprintf("No VSI bindings in metabase. The key %S had no data.\n");
        goto Cleanup;
    }
    else if(FAILED(hr))
    {
        errprintf("Error reading /SMTPSVC/%d/ServerBindings from the metabase."
            " The error HRESULT is 0x%08x - %s\n", dwVsid, hr,
            MDErrorToString(hr));
        goto Cleanup;
    }
    else
    {
        if(!GetServerBindings(wszBindings, pipServerBindings,
                cMaxServerBindings))
        {
            goto Cleanup;
        }

        dbgprintf("These are the local IP addresses (server-bindings)\n");
        if(g_fDebug)
            PrintIPArray(pipServerBindings);
    }

    // UDP is used (for the intial query) iff exclusive TCP_ONLY is not set
    *pfUdp = ((*pdwFlags) != DNS_FLAGS_TCP_ONLY);
    
    dwErr = DsGetConfiguration(pszTargetServer, dwVsid, pipDnsServers,
                cMaxServers, &fExternal);

    if(dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    //
    // If external DNS servers were configured AND pszServer is an external
    // target, then then we have all the information we need. Otherwise we
    // need to supply the default DNS servers configured on this machine
    //

    if(pipDnsServers->cAddrCount > 0 && fExternal)
        goto Cleanup;

    *pfGlobalList = TRUE;
    DnsGetDnsServerList(&pipTempServers);
    if(NULL == pipTempServers)
    {
        errprintf("Unable to get configured DNS servers for this computer\n");
        goto Cleanup;
    }

    if(pipTempServers->cAddrCount <= cMaxServers)
    {
        CopyMemory(pipDnsServers, pipTempServers,
            (1 + pipTempServers->cAddrCount) * sizeof(DWORD));
    }
    else
    {
        errprintf("Too many DNS servers are configured on this computer for this"
            " tool to handle. The maximum number that can be handled by this"
            " tool is %d\n", cMaxServers);
        goto Cleanup;
    }

    dbgprintf("Using the default DNS servers configured for this computer.\n");
    if(g_fDebug)
        PrintIPArray(pipDnsServers);

Cleanup:
    if(pIMeta)
        pIMeta->Release();

    if(pipTempServers)
        DnsApiFree(pipTempServers);

    if(fCoInitialized)
        CoUninitialize();

    return hr;
}

BOOL GetServerBindings(
    WCHAR *pwszMultiSzBindings,
    PIP_ARRAY pipServerBindings,
    DWORD cMaxServerBindings)
{
    int lErr = 0;
    DWORD cbOutBuffer = 0;
    WCHAR *pwszBinding = pwszMultiSzBindings;
    WCHAR *pwchEnd = pwszBinding;
    char szBinding[256];
    int cchWritten = 0;
    SOCKET sock;
    SOCKADDR_IN *lpSockAddrIn = NULL;
    BYTE rgbBuffer[512];
    LPSOCKET_ADDRESS_LIST pIpBuffer = (LPSOCKET_ADDRESS_LIST)rgbBuffer;

    if(*pwszBinding == L':')
    {
        // Blank binding string
        dbgprintf("Encountered blank server binding string for VSI\n");

        sock = socket(AF_INET, SOCK_STREAM, 0);
        if(sock == INVALID_SOCKET)
        {
            errprintf("Unable to create socket for WSAIoctl. The Win32 error"
                " is %d\n", WSAGetLastError());
            return FALSE;
        }

        lErr = WSAIoctl(sock, SIO_ADDRESS_LIST_QUERY, NULL, 0,
            (PBYTE)(pIpBuffer), sizeof(rgbBuffer), &cbOutBuffer, NULL, NULL);

        closesocket(sock);
        if(lErr != 0)
        {
            errprintf("Unable to issue WSAIoctl to get local IP addresses."
                " The Win32 error is %d\n", WSAGetLastError());
            return FALSE;
        }

        if(pIpBuffer->iAddressCount > (int)cMaxServerBindings)
        {
            errprintf("%d IP addresses were returned for the local machine"
                " by WSAIoctl. The maximum number that can be accomodated"
                " by this tool is %d\n", pIpBuffer->iAddressCount,
                cMaxServerBindings);
            return FALSE;
        }

        for(pipServerBindings->cAddrCount = 0;
            (int)pipServerBindings->cAddrCount < pIpBuffer->iAddressCount;
            pipServerBindings->cAddrCount++)
        {
            lpSockAddrIn =
                (SOCKADDR_IN *)
                    (pIpBuffer->Address[pipServerBindings->cAddrCount].lpSockaddr);
            CopyMemory(
                (PVOID)&(pipServerBindings->aipAddrs[pipServerBindings->cAddrCount]),
                (PVOID)&(lpSockAddrIn->sin_addr),
                sizeof(DWORD));
        }
        return TRUE;
    }

    while(TRUE)
    {
        pwchEnd = wcschr(pwszBinding, L':');
        if(pwchEnd == NULL)
        {
            errprintf("Illegal format for server binding string. The server"
                " binding string should be in the format <ipaddress>:<port>."
                " Instead, the string is \"%S\"\n", pwszBinding);
            return FALSE;
        }

        *pwchEnd = L'\0';
        pwchEnd++;

        if(pipServerBindings->cAddrCount > cMaxServerBindings)
        {
            errprintf("Too many server bindings for VSI. Maximum that can be"
                " handled by this tool is %d.\n", cMaxServerBindings);
            return FALSE;
        }

        // Explicit IP in binding string
        cchWritten = wcstombs(szBinding, pwszBinding, sizeof(szBinding));
        if(cchWritten < 0)
        {
            errprintf("Failed to conversion of %S from widechar to ASCII\n",
                pwszBinding);
            return FALSE;
        }

        pipServerBindings->aipAddrs[pipServerBindings->cAddrCount] =
            inet_addr(szBinding);

        if(pipServerBindings->aipAddrs[pipServerBindings->cAddrCount] ==
            INADDR_NONE)
        {
            errprintf("Illegal format for binding\n");
            return FALSE;
        }

        pipServerBindings->cAddrCount++;

        // Skip to end of string
        while(*pwchEnd != L'\0')
            pwchEnd++;

        // 2 NULL terminations signal end of MULTI_SZ
        pwchEnd++;
        if(*pwchEnd == L'\0')
            return TRUE;

        pwszBinding = pwchEnd;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks the regkey which is created when Exchange is installed, and uses
//      it to determine if Exchange is installed.
//  Arguments:
//      OUT BOOL *pfBool - Set to TRUE if the regkey exists, FALSE otherwise.
//  Returns:
//      Win32 Error if something failed.
//-----------------------------------------------------------------------------
DWORD IsExchangeInstalled(BOOL *pfBool)
{
    LONG lResult = 0;
    HKEY hkExchange;
    const char szExchange[] =
        "Software\\Microsoft\\Exchange";

    lResult = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 szExchange,
                 0,
                 KEY_READ,
                 &hkExchange);

    if(lResult == ERROR_SUCCESS)
    {
        dbgprintf("Microsoft Exchange is installed on this machine.\n");
        RegCloseKey(hkExchange);
        *pfBool = TRUE;
        return ERROR_SUCCESS;
    }
    else if(lResult == ERROR_NOT_FOUND || lResult == ERROR_FILE_NOT_FOUND)
    {
        dbgprintf("Microsoft Exchange not installed on this machine\n");
        *pfBool = FALSE;
        return ERROR_SUCCESS;
    }

    errprintf("Error opening registry key HKLM\\%s, Win32 err - %d\n",
        szExchange, lResult);
    return lResult;
}

//-----------------------------------------------------------------------------
//  Description:
//      Connects to a domain controller and reads configuration options for the
//      VSI being simulated. In addition it checks if the target-server (which
//      is to be resolved) is an Exchange computer that is a member of the
//      Exchange Org or not.
//
//  Arguments:
//      IN char *pszTargetServer - Server to resolve
//      IN DWORD dwVsid - VSI to simulate
//      OUT PIP_ARRAY pipExternalDnsServers - External DNS servers on VSI if
//          any are returned in this caller allocated buffer.
//      IN DWORD cMaxServers - Capacity of above buffer.
//      OUT PBOOL pfExternal - Set to TRUE when there are external DNS servers
//          configured.
//
//  Returns:
//      ERROR_SUCCESS if configuration was read without problems.
//      Win32 error code if there was a problem. Error messages are written to
//          stdout for diagnostic purposes.
//-----------------------------------------------------------------------------
DWORD
DsGetConfiguration(
    char *pszTargetServer,
    DWORD dwVsid,
    PIP_ARRAY pipExternalDnsServers,
    DWORD cMaxServers,
    PBOOL pfExternal)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    BOOL fRet = FALSE;
    PLDAP pldap = NULL;
    PLDAPMessage pldapMsgContexts = NULL;
    PLDAPMessage pldapMsgSmtpVsi = NULL;
    PLDAPMessage pEntry = 0;
    char szLocalComputerName[256];
    DWORD cchLocalComputerName = sizeof(szLocalComputerName);

    // Context attributes to read at the base level - so we know where to base
    // the rest of our searches from
    char *rgszContextAttrs[] =
        { "configurationNamingContext", NULL };

    // Attributes we are interested in for the VSI object
    char *rgszSmtpVsiAttrs[] =
        { "msExchSmtpExternalDNSServers", NULL };

    // LDAP result ptrs to store the results of the search
    char **rgszConfigurationNamingContext = NULL;   
    char **rgszSmtpVsiExternalDNSServers = NULL;
    char *pszExchangeServerDN = NULL;
    char szSmtpVsiDN[256];

    char *pchSeparator = NULL;
    char *pszIPServer = NULL;
    char *pszStringEnd = NULL;

    int i = 0;
    int cValues = 0;
    int cch = 0;
    BOOL fInstalled = FALSE;
    BOOL fFound = FALSE;

    *pfExternal = FALSE;
    pipExternalDnsServers->cAddrCount = 0;

    dwErr = IsExchangeInstalled(&fInstalled);
    if(ERROR_SUCCESS != dwErr || !fInstalled)
        return dwErr;

    dbgprintf("Querying domain controller for configuration.\n");

    pldap = BindToDC();
    if(!pldap)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwErr = ldap_search_s(
                pldap,                           // ldap binding
                "",                              // base DN
                LDAP_SCOPE_BASE,                 // scope
                "(objectClass=*)",               // filter
                rgszContextAttrs,                // attributes we want to read
                FALSE,                           // FALSE means read value
                &pldapMsgContexts);              // return results here

    if(dwErr != LDAP_SUCCESS)
    {
        errprintf("Error encountered during LDAP search. LDAP err - %d.\n", dwErr);
        goto Cleanup;
    }

    pEntry = ldap_first_entry(pldap, pldapMsgContexts);
    if(pEntry == NULL)
    {
        dwErr = ERROR_INVALID_DATA;
        errprintf("Base object not found on domain controller!\n");
        goto Cleanup;
    }

    rgszConfigurationNamingContext = ldap_get_values(pldap, pEntry, rgszContextAttrs[0]);
    if(rgszConfigurationNamingContext == NULL)
    {
        dwErr = ERROR_INVALID_DATA;
        errprintf("configurationNamingContext attribute not set on base object of"
            " domain controller.\n");
        goto Cleanup;
    }
          
    if((cValues = ldap_count_values(rgszConfigurationNamingContext)) == 1)
    {
        dbgprintf("configurationNamingContext is \"%s\"\n", rgszConfigurationNamingContext[0]);
        dbgprintf("This will be used as the Base DN for all directory searches.\n");
    }
    else
    {
        dwErr = ERROR_INVALID_DATA;
        errprintf("Unexpected error reading configurationNamingContext. Expected"
            " a single string value, instead there were %d values set\n",
            cValues);
        goto Cleanup;
    }

    // See if the target server is an Exchange Server in the Org
    dbgprintf("Checking if the target server %s is an Exchange server\n",
        pszTargetServer);

    dwErr = DsFindExchangeServer(pldap, rgszConfigurationNamingContext[0],
                pszTargetServer, NULL, &fFound);

    //
    // If it is in the Org, nothing more to do - we just use the default DNS
    // servers configured for the box to do the resolution
    //

    if(dwErr == LDAP_SUCCESS && fFound)
    {
        msgprintf("%s is in the Exchange Org. Global DNS servers will be used.\n",
            pszTargetServer);

        *pfExternal = FALSE;
        goto Cleanup;
    }

    //
    // On the other hand, if the target is not an Exchange computer in the org,
    // we need to lookup the VSI object on the local computer and check if it
    // is configured with external DNS servers
    //

    *pfExternal = TRUE;
    msgprintf("%s is an external server (not in the Exchange Org).\n", pszTargetServer);

    cchLocalComputerName = sizeof(szLocalComputerName);
    fRet = GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified,
                szLocalComputerName, &cchLocalComputerName);

    if(!fRet)
    {
        dwErr = GetLastError();
        errprintf("Unable to retrieve local computer DNS name, Win32 err - %d.\n",
            dwErr);
        goto Cleanup;
    }

    dbgprintf("Checking on DC if the VSI being simulated is configured with"
        " external DNS servers.\n");

    // Find the Exchange Server container object for the local computer
    dwErr = DsFindExchangeServer(pldap, rgszConfigurationNamingContext[0],
                szLocalComputerName, &pszExchangeServerDN, &fFound);

    if(!fFound || !pszExchangeServerDN)
    {
        errprintf("This server \"%s\" was not found in the DS. Make sure you are"
            " running this tool on an Exchange server in the Organization\n");
        dwErr = ERROR_INVALID_DATA;
        goto Cleanup;
    }
 
    // Construct the DN of the VSI for the server we found. This is fixed relative
    // to the Exchange Server DN
    cch = _snprintf(szSmtpVsiDN, sizeof(szSmtpVsiDN),
        "CN=%d,CN=SMTP,CN=Protocols,%s", dwVsid, pszExchangeServerDN);

    if(cch < 0)
    {
        errprintf("Unable to construct SMTP virtual server's DN. The DN is too"
            " long for this tool to handle\n");
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dbgprintf("DN for the virtual server is \"%s\"\n", szSmtpVsiDN);

    // Get the DNS servers attribute for the VSI
    dwErr = ldap_search_s(
                pldap,                           // ldap binding
                szSmtpVsiDN,                     // base DN
                LDAP_SCOPE_SUBTREE,              // scope
                "(objectClass=*)",               // filter
                NULL, //rgszSmtpVsiAttrs,                // attributes we want to read
                FALSE,                           // FALSE means read value
                &pldapMsgSmtpVsi);               // return results here

    if(dwErr == LDAP_NO_SUCH_OBJECT)
    {
        errprintf("No object exists for SMTP virtual server #%d on GC for %s\n",
            dwVsid, szLocalComputerName);
        goto Cleanup;
    }

    if(dwErr != LDAP_SUCCESS)
    {
        errprintf("Search for SMTP virtual server object failed, LDAP err - %d\n",
            dwErr);
        goto Cleanup;
    }

    pEntry = ldap_first_entry(pldap, pldapMsgSmtpVsi);
    if(pEntry == NULL)
    {
        errprintf("SMTP virtual server #%d for server %s was not found in the DS\n",
            dwVsid, szLocalComputerName);
        dwErr = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    rgszSmtpVsiExternalDNSServers = ldap_get_values(pldap, pEntry,
        rgszSmtpVsiAttrs[0]);

    if(rgszSmtpVsiExternalDNSServers == NULL)
    {
        dbgprintf("The attribute msExchSmtpExternalDNSServers was not found on"
            " the SMTP virtual server being simulated.\n");

        msgprintf("No external DNS servers on VSI. Using global DNS servers.\n");

        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }
          
    // This is a string of comma separated IP addresses
    if((cValues != ldap_count_values(rgszSmtpVsiExternalDNSServers)) == 1)
    {
        errprintf("Unexpected error reading msExchSmtpExternalDNSServers,"
            " cValues - %d\n", cValues);
        dwErr = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    dbgprintf("msExchSmtpExternalDNSServers: %s\n", rgszSmtpVsiExternalDNSServers[0]);

    pszIPServer = rgszSmtpVsiExternalDNSServers[0];
    pszStringEnd = rgszSmtpVsiExternalDNSServers[0] +
        lstrlen(rgszSmtpVsiExternalDNSServers[0]);

    i = 0;
    pipExternalDnsServers->cAddrCount = 0;

    while(pszIPServer < pszStringEnd && *pszIPServer != '\0')
    {
        pchSeparator = strchr(pszIPServer, ',');

        if(pchSeparator != NULL) // last IP address
            *pchSeparator = '\0';

        if(i > (int)cMaxServers)
        {
            errprintf("Too many DNS servers configured in registry. The maximum"
                " that this tool can handle is %d\n", cMaxServers);
            dwErr = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        pipExternalDnsServers->aipAddrs[i] = inet_addr(pszIPServer);
        if(pipExternalDnsServers->aipAddrs[i] == INADDR_NONE)
        {
            errprintf("The attribute msExchSmtpExternalDNSServers is in an"
                " invalid format. Expected a comma separated list of IP"
                " addresses in dotted decimal notation.\n");
            goto Cleanup;
        }

        pipExternalDnsServers->cAddrCount++;
        if(pchSeparator == NULL) // last IP address
            break;

        // There was a comma, advance to just after it
        pszIPServer = pchSeparator + 1;
        i++;
    }

    
    if(pipExternalDnsServers->cAddrCount == 0)
    {
        errprintf("No IP addresses could be constructed from"
            " msExchSmtpExternalDNSServers\n");
    }
    else
    {
        msgprintf("Using external DNS servers:\n");

        SetMsgColor();
        PrintIPArray(pipExternalDnsServers);
        SetNormalColor();
    }

    dwErr = ERROR_SUCCESS;

Cleanup:
    if(pszExchangeServerDN)
        delete [] pszExchangeServerDN;

    if(rgszSmtpVsiExternalDNSServers)
        ldap_value_free(rgszSmtpVsiExternalDNSServers);

    if(pldapMsgSmtpVsi)
        ldap_msgfree(pldapMsgSmtpVsi);

    if(rgszConfigurationNamingContext)
        ldap_value_free(rgszConfigurationNamingContext);

    if(pldapMsgContexts)
        ldap_msgfree(pldapMsgContexts);

    if(pldap)
        ldap_unbind(pldap);

    return dwErr;
}

//-----------------------------------------------------------------------------
//  Description:
//      Locates a domain controller for the local machine and opens an LDAP
//      connection to it.
//  Arguments:
//      None.
//  Returns:
//      LDAP* which can be used for LDAP queries
//-----------------------------------------------------------------------------
PLDAP BindToDC()
{
    DWORD dwErr = LDAP_SUCCESS;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    char *pszDomainController = NULL;
    PLDAP pldap = NULL;

    dwErr = DsGetDcName(
        NULL,   // Computer name
        NULL,   // Domain name
        NULL,   // Domain GUID,
        NULL,   // Sitename
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_RETURN_DNS_NAME,
        &pdci);

    if(dwErr != ERROR_SUCCESS)
    {
        errprintf("Error getting domain controller FQDN, Win32 err - %d\n", dwErr);
        goto Cleanup;
    }

    pszDomainController = pdci->DomainControllerName;
    while(*pszDomainController == '\\')
        pszDomainController++;

    dbgprintf("The domain controller server which will be used for reading"
        " configuration data is %s\n", pszDomainController);

    dbgprintf("Connecting to %s over port %d\n", pszDomainController, LDAP_PORT);

    pldap = ldap_open(pszDomainController, LDAP_PORT);
    if(pldap == NULL)
    {
        dwErr = LdapGetLastError();
        errprintf("Unable to initialize an LDAP session to the domain controller"
            " server %s, LDAP err - %d\n", pszDomainController, dwErr);
        goto Cleanup;
    }

    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);
    if(dwErr != LDAP_SUCCESS)
    {
        errprintf("Unable to authenticate to the domain controller server %s. Make"
            " sure you are running this tool with appropriate credentials,"
            " LDAP err - %d\n", pszDomainController, dwErr);
        goto Cleanup;
    }

Cleanup:
    if(pdci)
        NetApiBufferFree((PVOID)pdci);

    return pldap;
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks if a given FQDN is the name of an Exchange server in the org.
//
//  Arguments:
//      IN PLDAP pldap - Open LDAP session to domain controller.
//      IN LPSTR szBaseDN - Base DN to search from
//      IN LPSTR szServerName - Servername to search for
//      OUT LPSTR *ppszServerDN - If a non-NULL char** is passed in, the DN
//          of the server (if found) is returned to this. The buffer must be
//          freed using delete [].
//      OUT BOOL *pfFound - Set to TRUE if the server is found.
//
//  Returns:
//      ERROR_SUCCESS if configuration was read without problems.
//      Win32 error code if there was a problem. Error messages are written to
//          stdout for diagnostic purposes.
//-----------------------------------------------------------------------------
DWORD DsFindExchangeServer(
    PLDAP pldap,
    LPSTR szBaseDN,
    LPSTR szServerName,
    LPSTR *ppszServerDN,
    BOOL *pfFound)
{
    int i = 0;
    int cch = 0;
    int cValues = 0;
    DWORD dwErr = LDAP_SUCCESS;
    PLDAPMessage pldapMsgExchangeServer = NULL;  
    PLDAPMessage pEntry = NULL;
    char *rgszExchangeServerAttrs[] = { "distinguishedName", "networkAddress", NULL };
    char **rgszExchangeServerDN = NULL;
    char **rgszExchangeServerNetworkName = NULL;
    char szExchangeServerFilter[256];
    char szSearchNetworkName[256];

    //
    // The Exchange Server object has a multivalued attribute, "networkAddress"
    // that enumerates all the various names by which the Exchange Server is
    // identified such as NetBIOS, DNS etc. We are only interested in the fully
    // qualified domain name. This is set on the attribute as the string
    // "ncacn_ip_tcp:" prefixed to the server's FQDN.
    //

    szExchangeServerFilter[sizeof(szExchangeServerFilter) - 1] = '\0';
    cch = _snprintf(
        szExchangeServerFilter,
        sizeof(szExchangeServerFilter) - 1,
        "(&(networkAddress=ncacn_ip_tcp:%s)(objectClass=msExchExchangeServer))",
        szServerName);

    if(cch < 0)
    {
        errprintf("The servername %s is too long for this tool to handle.\n",
            szServerName);
        dwErr = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    dbgprintf("Searching for an Exchange Server object for %s on the domain"
        " controller\n", szServerName);

    dwErr = ldap_search_s(
                pldap,
                szBaseDN,
                LDAP_SCOPE_SUBTREE,
                szExchangeServerFilter,
                rgszExchangeServerAttrs,
                FALSE,
                &pldapMsgExchangeServer);

    if(dwErr == LDAP_NO_SUCH_OBJECT)
    {
        dbgprintf("No Exchange Server object found for %s on domain controller,"
            " LDAP err - LDAP_NO_SUCH_OBJECT\n", szServerName);
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    if(dwErr != LDAP_SUCCESS)
    {
        errprintf("LDAP search failed, LDAP err %d\n", dwErr);
        goto Cleanup;
    }
    
    pEntry = ldap_first_entry(pldap, pldapMsgExchangeServer);
    if(pEntry == NULL)
    {
        dbgprintf("No Exchange Server object found for %s on domain controller,\n",
            szServerName);
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    dbgprintf("LDAP search returned some results, examining them.\n");

    // Loop through the Exchange server objects
    while(pEntry)
    {

        dbgprintf("Examining next object for attributes we are interested in.\n");

        // Get the Exchange server-DN
        rgszExchangeServerDN = ldap_get_values(
                                    pldap,
                                    pEntry,
                                    rgszExchangeServerAttrs[0]);

        if(rgszExchangeServerDN == NULL)
        {
            errprintf("Unexpected error reading the distinguishedName attribute"
                " on the Exchange Server  object. The attribute was not set"
                " on the object. This is a required attribute.\n");
            dwErr = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        else if((cValues = ldap_count_values(rgszExchangeServerDN)) != 1)
        {
            errprintf("Unexpected error reading the distinguishedName attribute"
                " on the Exchange Server object. The attribute is supposed to"
                " have a single string value, instead %d values were"
                " returned.\n", cValues);
            dwErr = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        else
        {
            dbgprintf("Successfully read the distinguishedName attribute on the"
                " Exchange Server object. The value of the attribute is %s\n",
                rgszExchangeServerDN[0]);
        }

        // Get the Exchange server network name
        rgszExchangeServerNetworkName = ldap_get_values(
                                            pldap,
                                            pEntry,
                                            rgszExchangeServerAttrs[1]);

        if(!rgszExchangeServerNetworkName)
        {
            errprintf("The networkName attribute was not set on the Exchange"
                " Server object. This is a required attribute. The DN of the"
                " problematic object is %s\n", rgszExchangeServerDN[0]);
            dwErr = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        // This is a multi-valued string attribute
        cch = _snprintf(szSearchNetworkName, sizeof(szSearchNetworkName),
            "ncacn_ip_tcp:%s", szServerName);

        if(cch < 0)
        {
            errprintf("Exchange server name too long for this tool to handle\n");
            dwErr = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        cValues = ldap_count_values(rgszExchangeServerNetworkName);
        dbgprintf("The search returned the following %d values for the"
            " networkName attribute for the Exchange Server object for %s\n",
            cValues, szServerName);

        dbgprintf("Attempting to match the TCP/IP networkName of the Exchange"
            " Server object returned from the domain controller against the FQDN"
            " we are searching for\n");

        for(i = 0; i < cValues; i++)
        {
            dbgprintf("%d> networkName: %s", i, rgszExchangeServerNetworkName[i]);
            if(!_stricmp(rgszExchangeServerNetworkName[i], szSearchNetworkName))
            {
                // This is an internal server
                dbgprintf("...match succeeded\n");
                dbgprintf("%s is an Exchange Server in the Org.\n",
                    szServerName);

                *pfFound = TRUE;

                if(ppszServerDN != NULL)
                {
                    *ppszServerDN =
                        new char[lstrlen(rgszExchangeServerDN[0]) + 1];
                    if(*ppszServerDN == NULL)
                    {
                        errprintf("Out of memory allocating space for Exchange"
                            " Server object DN\n");
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }

                    lstrcpy(*ppszServerDN, rgszExchangeServerDN[0]);
                }
                dwErr = ERROR_SUCCESS;
                goto Cleanup;
            }
            dbgprintf("...match failed\n");
        }

        dbgprintf("No networkName on this object matched the server we are "
            " searching for. Checking for more objects returned by search.\n");

        pEntry = ldap_next_entry(pldap, pEntry);
    }

    dbgprintf("Done examining all objects returned by search. No match found.\n");
    dwErr = ERROR_SUCCESS;

Cleanup:
    if(rgszExchangeServerNetworkName)
        ldap_value_free(rgszExchangeServerNetworkName);

    if(rgszExchangeServerDN)
        ldap_value_free(rgszExchangeServerDN);

    if(pldapMsgExchangeServer)
        ldap_msgfree(pldapMsgExchangeServer);

    return dwErr;
}

//-----------------------------------------------------------------------------
//  Description:
//      Destructor for async DNS class. It merely signals when the async
//      resolve has finished. Since this object is deleted by completing ATQ
//      threads on success, we need an explicit way of telling the caller
//      when the resolve has finished.
//-----------------------------------------------------------------------------
CAsyncTestDns::~CAsyncTestDns()
{
    if(m_hCompletion != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_hCompletion);
        if(m_fMxLoopBack)
            SetProgramStatus(DNSDIAG_LOOPBACK);
    }
}

//-----------------------------------------------------------------------------
//  Description:
//      Virtual method that is called by the async DNS base class when a query
//      needs to be retried. This function creates a new DNS object and spins
//      off a repeat of the previous async query. The difference is only that
//      the DNS serverlist has probably undergone some state changes with some
//      servers being marked down or fUdp is different from the original query.
//
//  Arguments:
//      IN BOOL fUdp - What protocol to use for the retry query
//
//  Returns:
//      TRUE on success
//      FALSE if something failed. Diagnostic messages are printed.
//-----------------------------------------------------------------------------
BOOL CAsyncTestDns::RetryAsyncDnsQuery(BOOL fUdp)
{
    DWORD dwStatus = ERROR_SUCCESS;
    CAsyncTestDns *pAsyncRetryDns = NULL;

    if(GetDnsList()->GetUpServerCount() == 0)
    {
        errprintf("No working DNS servers to retry query with.\n");
        return FALSE;
    }

    dbgprintf("There are %d DNS servers marked as working. Trying the next"
        " one\n", GetDnsList()->GetUpServerCount());

    pAsyncRetryDns = new CAsyncTestDns(m_FQDNToDrop, m_fGlobalList,
                            m_hCompletion);

    if(!pAsyncRetryDns)
    {
        errprintf("Unable to create new query. Out of memory.\n");
        return FALSE;
    }

    dwStatus = pAsyncRetryDns->Dns_QueryLib(
                                    m_HostName,
                                    DNS_TYPE_MX,
                                    m_dwFlags,
                                    fUdp,
                                    GetDnsList(),
                                    m_fGlobalList);

    if(dwStatus == ERROR_SUCCESS)
    {
        // New query object will flag completion event
        m_hCompletion = INVALID_HANDLE_VALUE;
        return TRUE;
    }

    errprintf("DNS query failed. The Win32 error is %d.\n", dwStatus);
    delete pAsyncRetryDns;
    return FALSE;
}

//-----------------------------------------------------------------------------
//  Description:
//      This is a virtual function declared in the base CAsyncMxDns object.
//      When the MX resolution is finished, this virtual function is invoked
//      so that the user can do custom app-specific processing. In the case
//      of SMTP this consists of spinning off an async connect to the IP
//      addresses reported in m_AuxList. In this diagnostic application
//      we merely display the results, and if results were not found (an
//      error status is passed in), then we print the error message.
//
//      In this app, we also set m_hCompletion to signal that the resolve
//      is done. The main thread waiting for us in WaitForQueryCompletion
//      will then exit.
//
//  Arguments:
//      IN DWORD status - DNS error code from resolve
//
//  Notes:
//      Results are available in m_AuxList
//-----------------------------------------------------------------------------
void CAsyncTestDns::HandleCompletedData(DNS_STATUS status)
{
    PLIST_ENTRY pListHead = NULL;
    PLIST_ENTRY pListTail = NULL;
    PLIST_ENTRY pListCurrent = NULL;
    LPSTR pszIpAddr = NULL;
    DWORD i = 0;
    PMXIPLIST_ENTRY pMxEntry = NULL;
    BOOL fFoundIpAddresses = FALSE;

    if(status == ERROR_NOT_FOUND)
    {
        SetProgramStatus(DNSDIAG_NON_EXISTENT);
        goto Exit;
    }
    else if(!m_AuxList || m_AuxList->NumRecords == 0 || m_AuxList->DnsArray[0] == NULL)
    {
        SetProgramStatus(DNSDIAG_NOT_FOUND);
        errprintf("The target server could not be resolved to IP addresses!\n");

        msgprintf("If the VSI/domain is configured with a fallback"
            " smarthost delivery will be attempted to that smarthost.\n");

        goto Exit;
    }

    msgprintf("\nTarget hostnames and IP addresses\n");
    msgprintf("---------------------------------\n");
    for(i = 0; i < m_AuxList->NumRecords && m_AuxList->DnsArray[i] != NULL; i++)
    {
        pListTail = &(m_AuxList->DnsArray[i]->IpListHead);
        pListHead = m_AuxList->DnsArray[i]->IpListHead.Flink;
        pListCurrent = pListHead;
        msgprintf("HostName: \"%s\"\n", m_AuxList->DnsArray[i]->DnsName);
        
        if(pListCurrent == pListTail)
            errprintf("\tNo IP addresses for this name!\n");

        while(pListCurrent != pListTail)
        {
            // Atleast 1 IP address was found
            fFoundIpAddresses = TRUE;

            pMxEntry = CONTAINING_RECORD(pListCurrent, MXIPLIST_ENTRY, ListEntry);
            pszIpAddr = iptostring(pMxEntry->IpAddress);
            if(pszIpAddr == NULL)
            {
                errprintf("\tUnexpected error. Failed to read IP address, going on to next.\n");
                pListCurrent = pListCurrent->Flink;
                continue;
            }

            msgprintf("\t%s\n", pszIpAddr);
            pListCurrent = pListCurrent->Flink;
        };
    }
    if(fFoundIpAddresses)
        SetProgramStatus(DNSDIAG_RESOLVED);
    else
        SetProgramStatus(DNSDIAG_NOT_FOUND);

Exit:
    return;
}

//-----------------------------------------------------------------------------
//  Description:
//      If the -v option is being used to simulate a VSI, this virtual function
//      checks if dwIp is one of the IP addresses in the VSI bindings for the
//      VS being simulated. g_pipBindings is initialized at startup of this
//      app from the metabase.
//  Arguments:
//      IN DWORD dwIp - IP address to check
//  Returns:
//      TRUE is dwIp is a local-binding
//      FALSE if not
//-----------------------------------------------------------------------------
BOOL CAsyncTestDns::IsAddressMine(DWORD dwIp)
{
    DWORD i = 0;

    if(g_pipBindings->cAddrCount == 0)
        return FALSE;

    for(i = 0; i < g_pipBindings->cAddrCount; i++)
    {
        if(g_pipBindings->aipAddrs[i] == dwIp)
            return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//  Description:
//      Various output functions. These print informational, debugging and error
//      messages in various colors depending on the current "mode" as set in
//      the global variable g_fDebug.
//
//      The CDnsLogToFile is instantiated is a global variable. The DNS library
//      checks to see if there is a non-NULL CDnsLogToFile* and if it is
//      present the messages are directed to this object.
//-----------------------------------------------------------------------------
void CDnsLogToFile::DnsPrintfMsg(char *szFormat, ...)
{
    va_list argptr;

    SetMsgColor();
    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
    SetNormalColor();
}

void CDnsLogToFile::DnsPrintfErr(char *szFormat, ...)
{
    va_list argptr;

    SetErrColor();
    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
    SetNormalColor();
}

void CDnsLogToFile::DnsPrintfDbg(char *szFormat, ...)
{
    va_list argptr;

    if(!g_fDebug)
        return;

    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
}

void CDnsLogToFile::DnsLogAsyncQuery(
    char *pszQuestionName,
    WORD wQuestionType,
    DWORD dwFlags,
    BOOL fUdp,
    CDnsServerList *pDnsServerList)
{
    char szFlags[32];

    GetSmtpFlags(dwFlags, szFlags, sizeof(szFlags));

    SetMsgColor();
    printf("Created Async Query:\n");
    printf("--------------------\n");
    printf("\tQNAME = %s\n", pszQuestionName);
    printf("\tType = %s (0x%x)\n", QueryType(wQuestionType), wQuestionType);
    printf("\tFlags = %s (0x%x)\n", szFlags, dwFlags);
    printf("\tProtocol = %s\n", fUdp ? "UDP" : "TCP");
    printf("\tDNS Servers: (DNS cache will not be used)\n");
    DnsLogServerList(pDnsServerList);
    printf("\n");
    SetNormalColor();
}

void CDnsLogToFile::DnsLogApiQuery(
    char *pszQuestionName,
    WORD wQuestionType,
    DWORD dwApiFlags,
    BOOL fGlobal,
    PIP_ARRAY pipServers)
{
    char szFlags[32];

    GetDnsFlags(dwApiFlags, szFlags, sizeof(szFlags));

    SetMsgColor();
    printf("Querying via DNSAPI:\n");
    printf("--------------------\n");
    printf("\tQNAME = %s\n", pszQuestionName);
    printf("\tType = %s (0x%x)\n", QueryType(wQuestionType), wQuestionType);
    printf("\tFlags = %s, (0x%x)\n", szFlags, dwApiFlags);
    printf("\tProtocol = Default UDP, TCP on truncation\n");
    printf("\tServers: ");
    if(fGlobal)
    {
        printf("(DNS cache will be used)\n");
    }
    else
    {
        printf("(DNS cache will not be used)\n");
    }
    if(pipServers)
        PrintIPArray(pipServers, "\t");
    else
        printf("\tDefault DNS servers on box.\n");

    printf("\n");
    if(fGlobal == FALSE)
        SetNormalColor();
}

void CDnsLogToFile::DnsLogResponse(
    DWORD dwStatus,
    PDNS_RECORD pDnsRecordList,
    PBYTE pbMsg,
    DWORD wLength)
{
    PDNS_RECORD pDnsRecord = pDnsRecordList;

    SetMsgColor();
    printf("Received DNS Response:\n");
    printf("----------------------\n");
    switch(dwStatus)
    {
    case ERROR_SUCCESS:
        printf("\tError: %d\n", dwStatus);
        printf("\tDescription: Success\n");
        break;

    case DNS_INFO_NO_RECORDS:
        printf("\tError: %d\n", dwStatus);
        printf("\tDescription: No records could be located for this name\n");
        break;

    case DNS_ERROR_RCODE_NAME_ERROR:
        printf("\tError: %d\n", dwStatus);
        printf("\tDescription: No records exist for this name.\n");
        break;

    default:
        printf("\tError: %d\n", dwStatus);
        printf("\tDescription: Not available.\n");
        break;
    }

    if(pDnsRecord)
    {
        printf("\tThese records were received:\n");
        PrintRecordList(pDnsRecord, "\t");
        printf("\n");
    }

    SetNormalColor();
}

void CDnsLogToFile::DnsLogServerList(CDnsServerList *pDnsServerList)
{
    LPSTR pszAddress = NULL;
    PIP_ARRAY pipArray = NULL;

    if(!pDnsServerList->CopyList(&pipArray))
    {
        printf("Error, out of memory printing serverlist\n");
        return;
    }

    for(DWORD i = 0; i < pDnsServerList->GetCount(); i++)
    {
        pszAddress = iptostring(pipArray->aipAddrs[i]);
        printf("\t%s\n", pszAddress);
    }

    delete pipArray;
}

void PrintRecordList(PDNS_RECORD pDnsRecordList, char *pszPrefix)
{
    PDNS_RECORD pDnsRecord = pDnsRecordList;

    while(pDnsRecord)
    {
        PrintRecord(pDnsRecord, pszPrefix);
        pDnsRecord = pDnsRecord->pNext;
    }
}

void PrintRecord(PDNS_RECORD pDnsRecord, char *pszPrefix)
{
    LPSTR pszAddress = NULL;

    switch(pDnsRecord->wType)
    {
    case DNS_TYPE_MX:
        printf(
            "%s%s    MX    %d    %s\n",
            pszPrefix,
            pDnsRecord->nameOwner,
            pDnsRecord->Data.MX.wPreference,
            pDnsRecord->Data.MX.nameExchange);
        break;

    case DNS_TYPE_CNAME:
        printf(
            "%s%s    CNAME    %s\n",
            pszPrefix,
            pDnsRecord->nameOwner,
            pDnsRecord->Data.CNAME.nameHost);
        break;

    case DNS_TYPE_A:
        pszAddress = iptostring(pDnsRecord->Data.A.ipAddress);
        printf(
            "%s%s    A    %s\n",
            pszPrefix,
            pDnsRecord->nameOwner,
            pszAddress);
        break;

    case DNS_TYPE_SOA:
        printf("%s%s   SOA      (SOA records are not used by us)\n",
            pszPrefix,
            pDnsRecord->nameOwner);
        break;

    default:
        printf("%s%s   (Record type = %d)    Unknown record type\n",
            pszPrefix,
            pDnsRecord->nameOwner,
            pDnsRecord->wType);
        break;
    }
}

void msgprintf(char *szFormat, ...)
{
    va_list argptr;

    SetMsgColor();
    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
    SetNormalColor();
}

void errprintf(char *szFormat, ...)
{
    va_list argptr;

    SetErrColor();
    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
    SetNormalColor();
}

void dbgprintf(char *szFormat, ...)
{
    va_list argptr;

    if(!g_fDebug)
        return;

    va_start(argptr, szFormat);
    vprintf(szFormat, argptr);
    va_end(argptr);
}

void SetMsgColor()
{
    if(g_fDebug)
    {
        SetConsoleTextAttribute(g_hConsole,
            FOREGROUND_GREEN | FOREGROUND_INTENSITY);
    }
}

void SetErrColor()
{
    if(g_fDebug)
    {
        SetConsoleTextAttribute(g_hConsole,
            FOREGROUND_RED | FOREGROUND_INTENSITY);
    }
}

void SetNormalColor()
{
    if(g_fDebug)
    {
        SetConsoleTextAttribute(g_hConsole,
            FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\envdef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       envdef.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    01-05-96   Rohanp   Created
//
//----------------------------------------------------------------------------

#ifndef __ENVDEF_H__
#define __ENVDEF_H__

#define MSG_TYPE_NDR				0x00000001	//Msg is an NDR
#define MSG_TYPE_DSL				0x00000002	//Msg has a DL
#define MSG_TYPE_NDE				0x00000004	//Msg is to be NDRed immediately
#define MSG_TYPE_NDP				0x00000008	//NDR sent to POSTMASTER
#define MSG_TYPE_RES				0x00000010	//Msg was already resolved through abook
#define MSG_TYPE_EMIME				0x00000020	//Msg is 8bit mime
#define MSG_TYPE_RQL				0x00000040	//Requeue this message to the sharing queue
#define MSG_TYPE_LRE				0x00000080	//Local recipients were in the retry queue
#define MSG_TYPE_RRE				0x00000100	//Remote recipients were in the retry queue
#define MSG_TYPE_NEW				0x00000200	//Brand new message
#define MSG_TYPE_SQL				0x00000400	//Reading from SQL
#define MSG_TYPE_PKUP				0x00000800	//Reading from Pickup directory
#define MSG_TYPE_ASYNC_RES_STARTED	0x00001000	//Async resolution started
#define MSG_TYPE_ASYNC_RES_STOPPED	0x00002000	//Async resolution stopped
#define MSG_TYPE_LTR_PRESENT		0x00004000	//An LTR is present before addr resolution

//current version of this header
#define CURRENT_HEADER_HIGH_VERSION 1
#define CURRENT_HEADER_LOW_VERSION 0
#define MAKESMTPVERSION(HighVersion, LowVersion) (((HighVersion) << 16) | (LowVersion))
#define ENV_SIGNATURE		((DWORD)'SENV')

#define IsPropertySet(Flags, Option) ((Flags & Option) == Option)
enum HEADER_OFFSET {HDR_VERSION, HDR_TYPE, HDR_LOFFSET, HDR_LSIZE,
				    HDR_ROFFSET, HDR_RSIZE, HDR_LEXP_TIME, 
					HDR_RETRY_OFFSET, HDR_RETRY_ELEMENTS, 
					HDR_ROUTE_SIZE, HDR_REXP_TIME};

/*	   
	   The envelope for each message resides in an NTFS
	   stream in that message file.  The envelope has
	   a header that looks like the following :

	struct ENVELOPE_HEADER
	{
	DWORD						Version;			// The current version of this structure
	DWORD						Signature;			// Signature (should be 'SENV'
	DWORD						HdrSize;			// Current size of this structure
	DWORD						BodyOffset;			// Offset of the body of the message from beginning
	DWORD						MsgFlags;			// 0 if normal message, 1 if NDR message
	DWORD                       LocalOffset;		// Local rcpt. list offset
    DWORD                       RemoteOffset;   	// Remote rcpt. list offset
    DWORD                       LocalSize;			// Size of local rcpt list in bytes
	DWORD						RemoteSize;			// Size of remote rcpt list in bytes
	DWORD						RouteStructSize;	// Size of AB structure, if present
	LONGLONG                    LocalExpireTime;	// Time to delete local portion of mail
    LONGLONG                    RemoteExpireTime;	// To delete remote portion of mail
	};

		Right after the envelope header is the address 
		that was in the "Mail From" line. This address 
		is stored like "Srohanp@microsoft.com\n".  The "S"
		stands for SENDER. In the code below, the first
		byte is always removed when reading the address.
		The '\n' is also replaced with a '\0';

		In this version the Remote recipient list, if any,
		comes right after the senders' address.  You can
		also find it by seeking RemoteOffset bytes from the
		beginning of the file.  Once RemoteOffset is reached,
		the code reads RemoteSize bytes of data.  This is the
		total size in bytes of the remote recipient list.
		Each recipient address is stored on a line by itself,
		with the first letter "R" as in the example below:

		Rrohanp@microsoft.com\n
		Rtoddch@microsoft.com\n
		etc.

		The local addresses have the same format. The first byte,
		'R' stands for recipient and is always removed when building
		the address.  The '\n' is also removed.
*/


typedef struct _ENVELOPE_HEADER_
{
	DWORD						Version;			// The current version of this structure
	DWORD						Signature;			// Signature (should be 'SENV'
	DWORD						HdrSize;			// Size of this header
	DWORD						BodyOffset;			// Offset of body into file
	DWORD						MsgFlags;			// Has flags noted above
	DWORD                       LocalOffset;		// Local rcpt. list offset
    DWORD                       RemoteOffset;   	// Remote rcpt. list offset
    DWORD                       LocalSize;			// Size of local rcpt list in bytes
	DWORD						RemoteSize;			// Size of remote rcpt list in bytes
	DWORD						RouteStructSize;	// Size of AB structure, if present
	DWORD						RetryOffset;		// offset of local recipients to retry
	DWORD						RetryElements;			// Size of retry list
    LONGLONG                    LocalExpireTime;	// Time to delete local portion of mail
    LONGLONG                    RemoteExpireTime;	// To delete remote portion of mail
} ENVELOPE_HEADER, *PENV_HEADER;

typedef struct _ENVELOPE_HEADER_EX_
{
	DWORD						ErrorCode;
	ABROUTING					AbInfo;			// Last address in DL we processed
}ENVELOPE_HEADER_EX, *PENV_HEADER_EX;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\ims.h ===
/*++

    Copyright    (c)    1994    Microsoft Corporation

    Module  Name :

        ims.h

    Abstract:

        Common header for Internet Mail System components.

    Author:

        Richard Kamicar    (rkamicar)    31-Dec-1995

    Project:

        IMS

    Revision History:

--*/

#ifndef _IMS_H_
#define _IMS_H_

#define I64_LI(cli) (*((__int64*)&cli))
#define LI_I64(i) (*((LARGE_INTEGER*)&i))
#define INT64_FROM_LARGE_INTEGER(cli) I64_LI(cli)
#define LARGE_INTEGER_FROM_INT64(i) LI_I64(i)

#define I64_FT(ft) (*((__int64*)&ft))
#define FT_I64(i) (*((FILETIME*)&i))
#define INT64_FROM_FILETIME(ft) I64_FT(ft)
#define FILETIME_FROM_INT64(i) FT_I64(i)

//
// These can be overridden by registry values.
//
#define IMS_MAX_ERRORS          10
#define IMS_MAX_USER_NAME_LEN   64
#define IMS_MAX_DOMAIN_NAME_LEN 256
#define IMS_MAX_PATH_LEN        64
#define IMS_MAX_MSG_SIZE        42 * 1024
#define IMS_MAX_FILE_NAME_LEN   40

#define IMS_ACCESS_LOCKFILE         TEXT("pop3lock.lck")
#define IMS_ACCESS_LOCKFILE_NAME    IMS_ACCESS_LOCKFILE

#define IMS_DOMAIN_KEY              TEXT("DomainName")
#define IMS_EXTENSION               TEXT("eml")
#define ENV_EXTENSION               TEXT("env")
static const int TABLE_SIZE = 241;

/*++
    This function canonicalizes the path, taking into account the current
    user's current directory value.

    Arguments:
        pszDest   string that will on return contain the complete
                    canonicalized path. This buffer will be of size
                    specified in *lpdwSize.

        lpdwSize  Contains the size of the buffer pszDest on entry.
                On return contains the number of bytes written
                into the buffer or number of bytes required.

        pszSearchPath  pointer to string containing the path to be converted.
                    IF NULL, use the current directory only

    Returns:

        Win32 Error Code - NO_ERROR on success

    MuraliK   24-Apr-1995   Created.

--*/
BOOL
ResolveVirtualRoot(
        OUT CHAR *      pszDest,
    IN  OUT LPDWORD     lpdwSize,
    IN  OUT CHAR *      pszSearchPath,
        OUT HANDLE *    phToken = NULL
    );

//Published hash algorithm used in the UNIX ELF
//format for object files
inline unsigned long ElfHash (const unsigned char * UserName)
{
    unsigned long HashValue = 0, g;

    while (*UserName)
    {
        HashValue = (HashValue << 4) + *UserName++;
        if( g = HashValue & 0xF0000000)
            HashValue ^= g >> 24;

        HashValue &= ~g;
    }

    return HashValue;

}

inline DWORD HashUser (const unsigned char * UserName)
{
    DWORD HashValue = ElfHash (UserName);
    HashValue %= TABLE_SIZE;

    return HashValue;
}

inline VOID
MakeInboxPath(
    LPTSTR  pszInboxPath,           // UNICODE | ASCII
    LPCTSTR pszMailRoot,            // UNICODE | ASCII
    LPCSTR  paszUserName            // ASCII
    )
{

    wsprintf(pszInboxPath, "%s\\%u\\%hs",
                            pszMailRoot,
                            HashUser((const unsigned char *)paszUserName),
                            paszUserName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\regsink.h ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module name :

        regsink.h

   Abstract:

        Libaray to support registration processes for SEO sinks.

   Author:

           Keith Lau    (KeithLau)    7/04/98

   Project:

           SMTP Server DLL

   Revision History:

--*/

#ifndef __REGSINK_H__
#define __REGSINK_H__

HRESULT RegisterSinkAndAllDependencies(
			DWORD				dwInstanceID,
			REFGUID				rguidSourceType,
			LPSTR				pszSourceTypeDisplayName,
			REFGUID				rguidEventType,
			LPSTR				pszEventTypeDisplayName,
			REFGUID				rguidSourceBaseGuid,
			LPSTR				pszBaseDisplayName,
			LPSTR				pszMetabaseRootPath,
			REFGUID				rguidBinding,
			LPSTR				pszSinkDisplayName,
			LPSTR				pszSinkProgID,
			LPSTR				pszRule,
			DWORD				dwPriority
			);

HRESULT UnregisterSinkGivenDependencies(
			DWORD				dwInstanceID,
			REFGUID				rguidSourceType,
			REFGUID				rguidEventType,
			REFGUID				rguidSourceBaseGuid,
			LPSTR				pszMetabaseRootPath,
			REFGUID				rguidBinding
			);

HRESULT FindEventSourceType(
			REFGUID				rguidSourceType,
			IEventSourceType	**ppSourceType
			);

HRESULT RegisterEventSourceType(
			REFGUID				rguidSourceType,
			LPSTR				pszDisplayName,
			IEventSourceType	**ppSourceType
			);

HRESULT RegisterEventType(
			IEventSourceType	*pSourceType,
			REFGUID				rguidEventType,
			LPSTR				pszDisplayName
			);

HRESULT FindEventSource(
			IEventSourceType		*pSourceType,
			REFGUID					rguidSourceBaseGuid,
			DWORD					dwInstanceID,
			IEventSource			**ppEventSource
			);

HRESULT RegisterEventSource(
			IEventSourceType		*pSourceType,
			REFGUID					rguidSourceBaseGuid,
			LPSTR					pszMetabaseRootPath,
			LPSTR					pszBaseDisplayName,
			DWORD					dwInstanceID,
			IEventSource			**ppEventSource
			);

HRESULT RegisterEventSink(
			IEventSource			*pEventSource,
			REFGUID					rguidBinding,
			REFGUID					rguidEventType,
			LPSTR					pszSinkProgID,
			LPSTR					pszDisplayName,
			LPSTR					pszRule,
			DWORD					dwPriority
			);

HRESULT UnregisterEventSink(
			IEventSource			*pEventSource,
			REFGUID					rguidBinding,
			REFGUID					rguidEventType
			);

HRESULT UnregisterEventSource(
			IEventSourceType	*pSourceType,
			REFGUID				rguidSourceBaseGuid,
			DWORD				dwInstanceID
			);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\seoext.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    seoext.h

Abstract:

    SMTP server extension header file. These definitions are available
    to SEO server extension writers.

Author:

    Microsoft Corporation	July, 1997

Revision History:

--*/

#ifndef _SEOEXT_H_
#define _SEOEXT_H_

// ====================================================================
// Return codes
//

#define SSE_STATUS_SUCCESS                  0
#define SSE_STATUS_RETRY                    1
#define SSE_STATUS_ABORT_DELIVERY           2
#define SSE_STATUS_BAD_MAIL					3

#define SSE_STATUS_INTERNAL_ERROR			0x1000
#define SSE_STATUS_EXCEPTION				0x1001

// The SMTP server fills in one of these before it calls 
// CallDeliveryExtension()
typedef struct _DELIVERY_EXTENSION_BLOCK
{
	HANDLE	hImpersonation;			// Token for user impersonation
	LPSTR	lpszMailboxPath;		// Recipient's mailbox path

} DELIVERY_EXTENSION_BLOCK, *LPDELIVERY_EXTENSION_BLOCK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\msg.h ===
// Msg.h : Declaration of the CMsg

#ifndef __MSG_H_
#define __MSG_H_

#include "imsg.h"
#include "props.h"


// This template is used for declaring objects on the stack.  It is just like
// CComObjectStack<>, except that it does not assert on Addref(), Release(), or
// QueryInterface().
template <class Base>
class CComObjectStackLoose : public Base
{
public:
	CComObjectStackLoose() { m_dwRef=1; };
	~CComObjectStackLoose() { FinalRelease(); };
	STDMETHOD_(ULONG, AddRef)() { return (InternalAddRef()); };
	STDMETHOD_(ULONG, Release)() {return (InternalRelease()); };
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{ return _InternalQueryInterface(iid,ppvObject); }
};


/////////////////////////////////////////////////////////////////////////////
// CMsg
class ATL_NO_VTABLE __declspec(uuid("2DF59670-3D15-11d1-AA51-00AA006BC80B")) CMsg : 
	public CComObjectRoot,
//	public CComCoClass<CMsg, &CLSID_Msg>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMsg, &IID_IMsg, &LIBID_IMSGLib>,
	public IMsgLog
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Init(CGenericPTable *pPTable, LPVOID pDefaultContext=NULL);
		static HRESULT CreateInstance(CGenericPTable *pPTable, LPVOID pDefaultContext, CMsg **ppCMsg);
		void SetLogging(LPVOID pvLogHandle, DWORD (*pLogInformation)(LPVOID,const INETLOG_INFORMATION *));

	DECLARE_NOT_AGGREGATABLE(CMsg);
	DECLARE_PROTECT_FINAL_CONSTRUCT();

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SMTP CMsg Class",
//								   L"SMTP.CMsg.1",
//								   L"SMTP.CMsg");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CMsg)
		COM_INTERFACE_ENTRY(IMsg)
		COM_INTERFACE_ENTRY(IMsgLog)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_IID(__uuidof(CMsg),CMsg)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISupportsErrorInfo
	public:
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	// IMsg
	public:
		STDMETHOD(SetInterfaceW)(LPCWSTR pszName, IUnknown *punkValue);
		STDMETHOD(SetInterfaceA)(LPCSTR pszName, IUnknown *punkValue);
//		STDMETHOD(GetInterfaceW)(LPCWSTR pszName, IUnknown **ppunkResult);
//		STDMETHOD(GetInterfaceA)(LPCSTR pszName, IUnknown **ppunkResult);
		STDMETHOD(GetInterfaceW)(LPCWSTR pszName, const GUID &guid, IUnknown **ppunkResult);
		STDMETHOD(GetInterfaceA)(LPCSTR pszName, const GUID &guid, IUnknown **ppunkResult);
		STDMETHOD(SetDwordW)(LPCWSTR pszName, DWORD dwValue);
		STDMETHOD(SetDwordA)(LPCSTR pszName, DWORD dwValue);
		STDMETHOD(GetDwordW)(LPCWSTR pszName, DWORD *pdwResult);
		STDMETHOD(GetDwordA)(LPCSTR pszName, DWORD *pdwResult);
		STDMETHOD(SetStringW)(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue);
		STDMETHOD(SetStringA)(LPCSTR pszName, DWORD chCount, LPCSTR pszValue);
		STDMETHOD(GetStringW)(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult);
		STDMETHOD(GetStringA)(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult);
		STDMETHOD(SetVariantW)(LPCWSTR pszName, VARIANT *pvarValue);
		STDMETHOD(SetVariantA)(LPCSTR pszName, VARIANT *pvarValue);
		STDMETHOD(GetVariantW)(LPCWSTR pszName, VARIANT *pvarResult);
		STDMETHOD(GetVariantA)(LPCSTR pszName, VARIANT *pvarResult);
		STDMETHOD(get_Value)(BSTR bstrValue, /*[out, retval]*/ VARIANT *pVal);
		STDMETHOD(put_Value)(BSTR bstrValue, /*[in]*/ VARIANT newVal);

		// This method is called by the source after all sink processing 
		// to commit all changes to the media. Only changed properties
		// are updated.
		BOOL CommitChanges() { return(m_PTable.CommitChanges() == S_OK?TRUE:FALSE); }

		// This method is called by the source to rollback
		BOOL Rollback() { return(m_PTable.Invalidate() == S_OK?TRUE:FALSE); }

	// IMsgLog
	public:
		STDMETHOD(WriteToLog)(LPCSTR pszClientHostName,
							  LPCSTR pszClientUserName,
							  LPCSTR pszServerAddress,
							  LPCSTR pszOperation,
							  LPCSTR pszTarget,
							  LPCSTR pszParameters,
							  LPCSTR pszVersion,
							  DWORD dwBytesSent,
							  DWORD dwBytesReceived,
							  DWORD dwProcessingTimeMS,
							  DWORD dwWin32Status,
							  DWORD dwProtocolStatus,
							  DWORD dwPort,
							  LPCSTR pszHTTPHeader);

	private:
		// We have an instance of CPropertyTable
		CPropertyTable m_PTable;			// Property table
		LPVOID m_pContext;			// Context pointer
		CComPtr<IUnknown> m_pUnkMarshaler;
		DWORD (*m_pLogInformation)(LPVOID,const INETLOG_INFORMATION *);
		LPVOID m_pvLogHandle;
};


class CMsgStack : public CComObjectStackLoose<CMsg> {
	public:
		CMsgStack(CGenericPTable *pPTable, LPVOID pDefaultContext=NULL) {
			Init(pPTable,pDefaultContext);
		};
};


#endif //__MSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\ptable.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	ptable.h

Abstract:

	This module contains the export of the property table

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PTABLE_H_
#define _PTABLE_H_

#include "props.h"

// Enumerated type for HP access of individual properties
typedef enum _MSG_PTABLE_ITEMS
{
	_PI_MSG_CLIENT_DOMAIN = 0,
	_PI_MSG_CLIENT_IP,
	_PI_MSG_MAIL_FROM,
	_PI_MSG_MSG_STATUS,
	_PI_MSG_MSG_STREAM,
	_PI_MSG_RCPT_TO,
	_PI_MSG_SERVER_IP,
	_PI_MSG_MAX_PI

} MSG_PTABLE_ITEMS;

typedef enum _DEL_PTABLE_ITEMS
{
	_PI_DEL_CLIENT_DOMAIN = 0,
	_PI_DEL_CLIENT_IP,
	_PI_DEL_CURRENT_RCPT,
	_PI_DEL_MAIL_FROM,
	_PI_DEL_MAILBOX_PATH,
	_PI_DEL_MSG_STATUS,
	_PI_DEL_MSG_STREAM,
	_PI_DEL_RCPT_TO,
	_PI_DEL_SECURITY_TOKEN,
	_PI_DEL_SERVER_IP,
	_PI_DEL_MAX_PI

} DEL_PTABLE_ITEMS;

extern char		*rgszMessagePropertyNames[_PI_MSG_MAX_PI];
extern char		*rgszDeliveryPropertyNames[_PI_DEL_MAX_PI];

//
// CGenericPTable and CGenericCache are all defined in props.h
//
class CPerMessageCache : public CGenericCache
{
  public:
	CPerMessageCache(LPVOID pvDefaultContext) : CGenericCache(pvDefaultContext)
	{
		m_rgpdMessagePropertyData[0].pContext = NULL;
		m_rgpdMessagePropertyData[0].pCacheData = (LPVOID)&m_psClientDomain;
		m_rgpdMessagePropertyData[1].pContext = NULL;
		m_rgpdMessagePropertyData[1].pCacheData = (LPVOID)&m_psClientIP;
		m_rgpdMessagePropertyData[2].pContext = NULL;
		m_rgpdMessagePropertyData[2].pCacheData = (LPVOID)&m_psMailFrom;
		m_rgpdMessagePropertyData[3].pContext = NULL;
		m_rgpdMessagePropertyData[3].pCacheData = (LPVOID)&m_pdMsgStatus;
		m_rgpdMessagePropertyData[4].pContext = NULL;
		m_rgpdMessagePropertyData[4].pCacheData = (LPVOID)&m_pdStream;
		m_rgpdMessagePropertyData[5].pContext = NULL;
		m_rgpdMessagePropertyData[5].pCacheData = (LPVOID)&m_psRcptTo;
		m_rgpdMessagePropertyData[6].pContext = NULL;
		m_rgpdMessagePropertyData[6].pCacheData = (LPVOID)&m_psServerIP;

		// Default context
		m_rgpdMessagePropertyData[7].pContext = pvDefaultContext;
		m_rgpdMessagePropertyData[7].pCacheData = pvDefaultContext;
	}
	~CPerMessageCache() {}

	LPPROPERTY_DATA GetCacheBlock() { return(m_rgpdMessagePropertyData); }

  private:
	CPropertyValueDWORD		m_pdStream;			// IStream to message file
	CPropertyValueDWORD		m_pdMsgStatus;		// Message status
	CPropertyValueString	m_psMailFrom;		// Mail from string
	CPropertyValueString	m_psRcptTo;			// Rcpt to (MULTISZ)
	CPropertyValueString	m_psClientDomain;	// Client domain per EHLO
	CPropertyValueString	m_psClientIP;		// Client IP address
	CPropertyValueString	m_psServerIP;		// Server IP address

	// The extra slot is for the default accessor
	PROPERTY_DATA	m_rgpdMessagePropertyData[_PI_MSG_MAX_PI + 1];
};

class CPerRecipientCache : public CGenericCache
{
  public:
	CPerRecipientCache(LPVOID pvDefaultContext) : CGenericCache(pvDefaultContext)
	{
		m_rgpdRecipientPropertyData[0].pContext = NULL;
		m_rgpdRecipientPropertyData[0].pCacheData = (LPVOID)&m_psClientDomain;
		m_rgpdRecipientPropertyData[1].pContext = NULL;
		m_rgpdRecipientPropertyData[1].pCacheData = (LPVOID)&m_psClientIP;
		m_rgpdRecipientPropertyData[2].pContext = NULL;
		m_rgpdRecipientPropertyData[2].pCacheData = (LPVOID)&m_psCurrentRcpt;
		m_rgpdRecipientPropertyData[3].pContext = NULL;
		m_rgpdRecipientPropertyData[3].pCacheData = (LPVOID)&m_psMailFrom;
		m_rgpdRecipientPropertyData[4].pContext = NULL;
		m_rgpdRecipientPropertyData[4].pCacheData = (LPVOID)&m_psMailboxPath;
		m_rgpdRecipientPropertyData[5].pContext = NULL;
		m_rgpdRecipientPropertyData[5].pCacheData = (LPVOID)&m_pdMsgStatus;
		m_rgpdRecipientPropertyData[6].pContext = NULL;
		m_rgpdRecipientPropertyData[6].pCacheData = (LPVOID)&m_pdStream;
		m_rgpdRecipientPropertyData[7].pContext = NULL;
		m_rgpdRecipientPropertyData[7].pCacheData = (LPVOID)&m_psRcptTo;
		m_rgpdRecipientPropertyData[8].pContext = NULL;
		m_rgpdRecipientPropertyData[8].pCacheData = (LPVOID)&m_pdSecurityToken;
		m_rgpdRecipientPropertyData[9].pContext = NULL;
		m_rgpdRecipientPropertyData[9].pCacheData = (LPVOID)&m_psServerIP;

		// Default context
		m_rgpdRecipientPropertyData[10].pContext = pvDefaultContext;
		m_rgpdRecipientPropertyData[10].pCacheData = pvDefaultContext;
	}
	~CPerRecipientCache() {}

	LPPROPERTY_DATA GetCacheBlock() { return(m_rgpdRecipientPropertyData); }

  private:
	CPropertyValueDWORD		m_pdStream;			// IStream to message file
	CPropertyValueDWORD		m_pdMsgStatus;		// Message status
	CPropertyValueDWORD		m_pdSecurityToken;	// hImpersonation
	CPropertyValueString	m_psMailFrom;		// Mail from string
	CPropertyValueString	m_psMailboxPath;	// Mailbox path
	CPropertyValueString	m_psRcptTo;			// Rcpt to (MULTISZ)
	CPropertyValueString	m_psClientDomain;	// Client domain per EHLO
	CPropertyValueString	m_psClientIP;		// Client IP address
	CPropertyValueString	m_psCurrentRcpt;	// Current recipient
	CPropertyValueString	m_psServerIP;		// Server IP address

	// The extra slot is for the default accessor
	PROPERTY_DATA	m_rgpdRecipientPropertyData[_PI_DEL_MAX_PI + 1];
};

class CMessagePTable : public CGenericPTable
{
  public:
	CMessagePTable(CGenericCache	*pCache);
	~CMessagePTable() {}

	LPPTABLE GetPTable() { return(&m_PTable); }

  private:
	PTABLE		m_PTable;
};

class CDeliveryPTable : public CGenericPTable
{
  public:
	CDeliveryPTable(CGenericCache	*pCache);
	~CDeliveryPTable() {}

	LPPTABLE GetPTable() { return(&m_PTable); }

  private:
	PTABLE		m_PTable;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\route.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

       route.h

   Abstract:

       This file defines functions and types required for
       routing interface library.


   Revision History:

   --*/

#ifndef _ROUTE_H_
#define _ROUTE_H_

#define ROUTING_DLL_NAME                        "abookdb.dll"
#define ROUTING_FUN_INIT                        "AbInitialize"
#define ROUTING_FUN_TERM                        "AbTerminate"
#define ROUTING_FUN_GETMAILROOT                 "AbGetUserMailRoot"
#define ROUTING_FUN_RESOLVEADDRESS              "AbResolveAddress"
#define ROUTING_FUN_GET_RESOLVE_ADDRESS         "AbGetResolveAddress"
#define ROUTING_FUN_END_RESOLVE_ADDRESS         "AbEndResolveAddress"
#define ROUTING_FUN_GETNEXTENUM                 "AbGetNextEnumResult"
#define ROUTING_FUN_ENDENUMRESULT               "AbEndEnumResult"
#define ROUTING_FUN_SETDOMAIN_MAPPING           "AbSetDomainMapping"
#define ROUTING_FUN_GET_ROUTING_DIRECTORY       "AbGetRoutingDirectory"
#define ROUTING_FUN_SET_SOURCES                 "AbSetSources"
#define ROUTING_FUN_VALIDATE_SOURCE             "AbValidateSource"
#define ROUTING_FUN_VALIDATE_NUM_SOURCES        "AbValidateNumSources"

#define ROUTING_FUN_SET_LOCAL_DOMAINS           "AbSetLocalDomains"

#define ROUTING_FUN_CREATE_USER                 "AbCreateUser"
#define ROUTING_FUN_DELETE_USER                 "AbDeleteUser"
#define ROUTING_FUN_SET_FORWARD                 "AbSetForward"
#define ROUTING_FUN_SET_MAILROOT                "AbSetMailRoot"
#define ROUTING_FUN_SET_MAILBOX_SIZE            "AbSetMailboxSize"
#define ROUTING_FUN_SET_MAILBOX_MESSAGE_SIZE    "AbSetMailboxMessageSize"
#define ROUTING_FUN_GET_USER_PROPS              "AbGetUserProps"

#define ROUTING_FUN_CREATE_DL                   "AbCreateDL"
#define ROUTING_FUN_DELETE_DL                   "AbDeleteDL"
#define ROUTING_FUN_CREATE_DL_MEMBER            "AbCreateDLMember"
#define ROUTING_FUN_DELETE_DL_MEMBER            "AbDeleteDLMember"

#define ROUTING_FUN_ENUM_NAME_LIST              "AbEnumNameList"
#define ROUTING_FUN_ENUM_NAME_LIST_FROM_DL      "AbEnumNameListFromDL"
#define ROUTING_FUN_GET_NEXT_EMAIL              "AbGetNextEmail"
#define ROUTING_FUN_END_ENUM_RESULT             "AbEndEnumResult"

#define ROUTING_FUN_GETERRORSTRING              "AbGetErrorString"
#define ROUTING_FUN_ADD_LOCAL_DOMAIN            "AbAddLocalDomain"
#define ROUTING_FUN_ADD_ALIAS_DOMAIN            "AbAddAliasDomain"
#define ROUTING_FUN_DELETE_LOCAL_DOMAIN         "AbDeleteLocalDomain"
#define ROUTING_FUN_DELETE_ALL_LOCAL_DOMAINS    "AbDeleteAllLocalDomains"
#define ROUTING_FUN_ABCANCEL                    "AbCancel"

#define ROUTING_FUN_MAKE_BACKUP                 "AbMakeBackup"
#define ROUTING_FUN_GET_TYPE                    "AbGetType"


#if defined(TDC)
#define ROUTING_FUN_FREE_MEMORY                 "AbFreeMemory"
#define ROUTING_FUN_GET_DL_PROPS                "AbGetDLProps"
#define ROUTING_FUN_GET_NEXT_ENUM_RESULT        "AbGetNextEnumResult"
#endif

#define RtxFlag(i)                      ((0x1) << (i))
#define IsRtxFlagSet(rtxflag, rtxmask)  (((rtxflag) & (rtxmask)) != 0)

#define cbEmailNameMax                  (316)
#define cbVRootMax                      (250)
#define cbDomainMax                     (250)
#define cbSourceMax                     (512)

#define rtxnameUser                     RtxFlag(0)
#define rtxnameDistListNormal           RtxFlag(1)
#define rtxnameDistListExtended         RtxFlag(2)
#define rtxnameDistListSite             RtxFlag(3)
#define rtxnameDistListDomain           RtxFlag(4)
#define rtxnameDistListAll              ( \
                                        rtxnameDistListNormal | \
                                        rtxnameDistListExtended | \
                                        rtxnameDistListSite | \
                                        rtxnameDistListDomain \
                                        )

#define rtxnameAll                      ( \
                                        rtxnameUser | \
                                        rtxnameDistListAll \
                                        )

#define ROUTING_INIT_MAIL_ROOT                  (RtxFlag(1))
#define ROUTING_INIT_USER_CONFIG                (RtxFlag(2))
#define ROUTING_INIT_DL_CONFIG                  (RtxFlag(3))
#define ROUTING_INIT_RESOLVE                    (RtxFlag(4))
#define ROUTING_INIT_SOURCES                    (RtxFlag(5))
#define ROUTING_INIT_DOMAIN                     (RtxFlag(6))
#define ROUTING_INIT_PERF                       (RtxFlag(7))
#define ROUTING_INIT_ENUM                       (RtxFlag(8))
#define ROUTING_INIT_LIST                       (RtxFlag(9))
#define ROUTING_INIT_UTIL                       (RtxFlag(10))
#define ROUTING_INIT_BACKUP                     (RtxFlag(11))


#define ROUTING_INIT_ALL                        ( \
                                                ROUTING_INIT_MAIL_ROOT | \
                                                ROUTING_INIT_USER_CONFIG | \
                                                ROUTING_INIT_DL_CONFIG | \
                                                ROUTING_INIT_RESOLVE | \
                                                ROUTING_INIT_SOURCES | \
                                                ROUTING_INIT_DOMAIN | \
                                                ROUTING_INIT_PERF | \
                                                ROUTING_INIT_ENUM | \
                                                ROUTING_INIT_LIST | \
                                                ROUTING_INIT_UTIL  \
                                                )

enum RTTYPE {rttypeNone, rttypeSQL, rttypeFF, rttypeLDAP};

typedef HANDLE HRTXENUM, *PHRTXENUM;

typedef struct _RTX_DOMAIN_ENTRY
{
    LIST_ENTRY  m_list;
    char        m_szDomain[cbDomainMax];
} RTX_DOMAIN_ENTRY, *PRTX_DOMAIN_ENTRY;

typedef struct _RTX_USER_PROPS
{
    CHAR    szEmail[cbEmailNameMax];
    CHAR    szForward[cbEmailNameMax];
    BOOL    fLocal;
    DWORD   cbMailBoxSize;
    DWORD   cbMailboxMessageSize;
    CHAR    szVRoot[cbVRootMax];
} RTX_USER_PROPS, *LPRTX_USER_PROPS;

/*
typedef struct _RTX_DIST_LIST_PROPS
{
    CHAR    szEmail[cbEmailNameMax];
    DWORD   dwToken;
} RTX_DIST_LIST_PROPS, *LPRTX_DIST_LIST_PROPS;
*/

class CRtx
{
private:
    HINSTANCE                       m_hDll;
    HANDLE                          m_hContext;
    RTTYPE                          m_rttype;

    struct __ROUTINGVTBL__ {
        LPFNAB_INIT                     pfnInit;
        LPFNAB_TERM                     pfnTerm;
        LPFNAB_GET_MAILROOT             pfnGetMailRoot;
        LPFNAB_CREATE_USER              pfnCreateUser;
        LPFNAB_DELETE_USER              pfnDeleteUser;
        LPFNAB_SET_FORWARD              pfnSetForward;
        LPFNAB_SET_MAILROOT             pfnSetVRoot;
        LPFNAB_SET_MAILBOX_SIZE         pfnSetMailboxSize;
        LPFNAB_SET_MAILBOX_MESSAGE_SIZE pfnSetMailboxMessageSize;
        LPFNAB_CREATE_DL                pfnCreateDL;
        LPFNAB_DELETE_DL                pfnDeleteDL;
        LPFNAB_CREATE_DL_MEMBER         pfnCreateDLMember;
        LPFNAB_DELETE_DL_MEMBER         pfnDeleteDLMember;
        LPFNAB_GET_ROUTING_DIRECTORY    pfnGetRoutingDirectory;
        LPFNAB_SET_SOURCES              pfnSetSources;
        LPFNAB_GET_USER_PROPS           pfnGetUserProps;
#if defined(TDC)
        LPFNAB_GET_DL_PROPS             pfnGetDLProps;
#endif
        LPFNAB_ADD_LOCAL_DOMAIN         pfnAddLocalDomain;
        LPFNAB_ADD_ALIAS_DOMAIN         pfnAddAliasDomain;
        LPFNAB_DELETE_LOCAL_DOMAIN      pfnDeleteLocalDomain;
        LPFNAB_DELETE_ALL_LOCAL_DOMAINS pfnDeleteAllLocalDomains;
#if defined(TDC)
        LPFNAB_GET_NEXT_ENUM_RESULT     pfnGetNextEnumResult;
#endif
        LPFNAB_END_ENUM_RESULT          pfnEndEnumResult;
        LPFNAB_ENUM_NAME_LIST           pfnEnumNameList;
        LPFNAB_ENUM_NAME_LIST_FROM_DL   pfnEnumNameListFromDL;
        LPFNAB_GET_NEXT_EMAIL           pfnGetNextEmail;
        LPFNAB_RES_ADDR                 pfnResolveAddress;
        LPFNAB_GET_RES_ADDR             pfnGetResolveAddress;
        LPFNAB_END_RES_ADDR             pfnEndResolveAddress;
#if defined(TDC)
        LPFNAB_FREE_MEMORY              pfnFreeMemory;
#endif
        LPFNAB_GET_ERROR_STRING         pfnGetErrorString;
        LPFNAB_CANCEL                   pfnCancel;
        LPFNAB_MAKE_BACKUP              pfnMakeBackup;
        LPFNAB_GET_TYPE                 pfnGetType;
        LPFNAB_VALIDATE_SOURCE          pfnValidateSource;
        LPFNAB_VALIDATE_NUM_SOURCES     pfnValidateNumSources;
    } m_routingvtbl;


public:
    CRtx() : m_hDll(NULL), m_hContext(NULL), m_rttype(rttypeNone)
    {
        FillMemory(&m_routingvtbl, sizeof(m_routingvtbl), 0xFF);
    }

    ~CRtx() {};

    BOOL            Initialize(LPSTR szDll, LPSTR szDisplayName, LPFNLOGTRANX pfnlogtranx, DWORD dwFlags, PLIST_ENTRY pleDbConfig);
    void            Terminate();
    RTTYPE          GetRtType() { return m_rttype; }
    BOOL            AddOptionalEntryPoints(DWORD dwFlags);

    BOOL            GetMailRoot(LPSTR szUser, LPSTR szMoniker, DWORD *pcbMoniker);

    BOOL            CreateUser(LPSTR szEmail, LPSTR szForward, BOOL fLocalUser, LPSTR szVRoot, DWORD cbMailboxMax, DWORD cbMailboxMessageMax);
    BOOL            DeleteUser(LPSTR szEmail);
    BOOL            GetUserProps(LPSTR szEmail, RTX_USER_PROPS *pUserProps);
    BOOL            SetForward(LPSTR szEmail, LPSTR szForward);
    BOOL            SetMailboxSize(LPSTR szEmail, DWORD cbMailboxMax);
    BOOL            SetMailboxMessageSize(LPSTR szEmail, DWORD cbMailboxMessageMax);
    BOOL            SetVRoot(LPSTR szEmail, LPSTR szVRoot);

    BOOL            CreateDistList(LPSTR szEmail, DWORD dwType);
    BOOL            DeleteDistList(LPSTR szEmail);
    BOOL            CreateDistListMember(LPSTR szEmail, LPSTR szMember);
    BOOL            DeleteDistListMember(LPSTR szEmail, LPSTR szMember);

    BOOL            GetRoutingDirectory(LPSTR szDll, PLIST_ENTRY pleSources, LPSTR szDirectory);
    BOOL            SetSources(PLIST_ENTRY pHead);
    BOOL            ValidateSource(LPSTR szSource);
    BOOL            ValidateNumSources(DWORD dwNumSources);

    BOOL            AddLocalDomain(LPSTR szName);
    BOOL            AddAliasDomain(LPSTR szName, LPSTR szAlias);
    BOOL            DeleteLocalDomain(LPSTR szName);
    BOOL            DeleteAllLocalDomains();

    BOOL            EnumNameList(LPSTR szEmail, BOOL fForward, DWORD crowsReq, DWORD dwFlags, PHRTXENUM phrtxenum);
    BOOL            EnumNameListFromDL(LPSTR szEmailDL, LPSTR szEmail, BOOL fForward, DWORD crowsReq, DWORD dwFlags, PHRTXENUM phrtxenum);
    BOOL            GetNextEmail(HRTXENUM hrtxenum, DWORD *pdwType, LPSTR szEmail);
#if defined(TDC)
    BOOL            GetNextEnumResult(HRTXENUM hrtxenum, LPVOID pvBuf, LPDWORD pcbBuf);
#endif
    BOOL            EndEnumResult(HRTXENUM hrtxenum);

    DWORD           EnumRowsReturned(HRTXENUM hrtxenum);

    BOOL            FreeHrtxenum(HRTXENUM hrtxtenum);

#if defined(TDC)
    BOOL            FreeMemory(PABROUTING pabrouting);
#endif
    BOOL            GetErrorString(DWORD dwErr, LPSTR lpBuf, DWORD cbBufSize);

    BOOL            ResolveAddress(PLIST_ENTRY HeadOfList, PABADDRSTAT pabAddrStat, PABROUTING pabrouting, PABRESOLVE pabresolve);
    BOOL            GetResolveAddress(PABRESOLVE pabresolve, PABROUTING pabrouting);
    BOOL            EndResolveAddress(PABRESOLVE pabresolve);
    BOOL            Cancel(void);

    BOOL            MakeBackup(LPSTR szDirectory);

#if defined(TDC)
    LPFNAB_FREE_MEMORY PfnFreeMemory() { return m_routingvtbl.pfnFreeMemory; }
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\props.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	props.h

Abstract:

	This module contains the definition of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PROPS_H_
#define _PROPS_H_

// Define a generic accessor function to access properties
typedef HRESULT (*GET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData,
											LPVOID	pvBuffer, 
											LPDWORD	pdwBufferLen);

typedef HRESULT (*SET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pCacheData, 
											LPVOID	pvBuffer, 
											DWORD	dwBufferLen,
											DWORD	ptPropertyType);

typedef HRESULT (*COMMIT_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData);

typedef HRESULT (*INVALIDATE_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pCacheData,
											DWORD	ptPropertyType);

// Define the property item structure. We can hash this if
// we want in the future
typedef struct _PROPERTY_ITEM
{
	LPSTR							pszName;
	DWORD							ptBaseType;
	DWORD							fAccess;
	DWORD							dwIndex;
	GET_ACCESSOR_FUNCTION			pfnGetAccessor;
	SET_ACCESSOR_FUNCTION			pfnSetAccessor;
	COMMIT_ACCESSOR_FUNCTION		pfnCommitAccessor;
	INVALIDATE_ACCESSOR_FUNCTION	pfnInvalidateAccessor;

} PROPERTY_ITEM, *LPPROPERTY_ITEM;

typedef struct _PROPERTY_DATA
{
	LPVOID							pContext;
	LPVOID							pCacheData;

} PROPERTY_DATA, *LPPROPERTY_DATA;

// Define a property context
typedef struct _PROP_CTXT
{
	LPPROPERTY_ITEM	pItem;
	BOOL			fIsWideStr;
	LPSTR			pszDefaultPropertyName;

} PROP_CTXT, *LPPROP_CTXT;

// Define a generic structure to define a set of properties
typedef struct _PTABLE
{
	LPPROPERTY_ITEM		pProperties;	// Actual property table
	LPPROPERTY_DATA		pPropertyData;	// Prop data
	DWORD				dwProperties;	// Count
	BOOL				fIsSorted;		// Sorted prop table?

} PTABLE, *LPPTABLE;

// =================================================================
// Generic cache class
//
class CGenericCache
{
  public:
	CGenericCache(LPVOID pvDefaultContext) {}
	~CGenericCache() {}
	virtual LPPROPERTY_DATA GetCacheBlock() = 0;
};

// =================================================================
// Generic property table
//
class CGenericPTable
{
  public:
	CGenericPTable(CGenericCache	*pCache) {}
	~CGenericPTable() {}
	virtual LPPTABLE GetPTable() = 0;
};

// =================================================================
// Definition of an in-house string structure
//
typedef struct _STRING_ATTR
{
	LPSTR	pszValue;
	DWORD	dwMaxLen;

} STRING_ATTR, *LPSTRING_ATTR;

// Enumerated types representing type of access on property
typedef enum _PROPERTY_ACCESS
{
	PA_READ = 1,
	PA_WRITE = 2,
	PA_READ_WRITE = 3

} _PROPERTY_ACCESS;

// Enumerated types representing property types
typedef enum _PROPERTY_TYPES
{
	PT_NONE = 0,
	PT_STRING,
	PT_DWORD,
	PT_INTERFACE,
	PT_DEFAULT,
	PT_MAXPT

} PROPERTY_TYPES;


// =================================================================
// Definition of an in-house string class, this is used for caching
//
class CPropertyValueString
{
  public:
	CPropertyValueString()
	{ 
		m_pszValue = NULL; 
		m_dwLength = 0;
		m_dwMaxLen = 0; 
		m_fChanged = FALSE;
	}
	~CPropertyValueString()	
	{ 
		if (m_pszValue) 
			LocalFree(m_pszValue); 
		m_pszValue = NULL; 
	}

	// Overload the assignment to abstract the implementation
	const CPropertyValueString& operator=(LPSTR szValue);

	// Users can call copy if they desire to
	BOOL Copy(LPSTR pszSrc, DWORD dwLength /* Optional */);

	void Invalidate()
	{
		if (m_pszValue) 
			LocalFree(m_pszValue); 
		m_pszValue = NULL; 
		m_fChanged = FALSE;
	}

	// We make these directly accessible
	LPSTR	m_pszValue;
	DWORD	m_dwLength;
	DWORD	m_dwMaxLen;
	BOOL	m_fChanged;
};

// =================================================================
// Definition of an in-house DWORD class, this is used for caching
//
class CPropertyValueDWORD
{
  public:
	CPropertyValueDWORD()
	{ 
		m_dwValue = 0; 
		m_fInit = FALSE;
		m_fChanged = TRUE;
		m_punkScratch = NULL;
	}

	~CPropertyValueDWORD()
	{ 
		if (m_fInit && m_punkScratch)
			m_punkScratch->Release();
		m_punkScratch = NULL;
	}

	// Overload the assignment to abstract the implementation
	const CPropertyValueDWORD& operator=(DWORD dwValue)
	{
		m_dwValue = dwValue;
		m_fInit = TRUE;
		m_fChanged = TRUE;
		return(*this);
	}

	void Invalidate()
	{
		if (m_fInit && m_punkScratch)
			m_punkScratch->Release();
		m_punkScratch = NULL;
		m_fInit = FALSE;
		m_fChanged = FALSE;
	}

	// We make these directly accessible
	DWORD	m_dwValue;
	BOOL	m_fInit;
	BOOL	m_fChanged;
	IUnknown *m_punkScratch;	// HACK: for interfaces only
};

// Size of default scratch buffer
#define DEFAULT_SCRATCH_BUFFER_SIZE		1024

// =================================================================
// class for searching properties
//
class CPropertyTable
{
  public:

	CPropertyTable()	
	{
		// Set up the default scratch pad
		m_szBuffer = m_rgcBuffer;
		m_cBuffer = DEFAULT_SCRATCH_BUFFER_SIZE;
	}

	BOOL Init(LPPROPERTY_ITEM	pProperties,
					LPPROPERTY_DATA	pData,
					DWORD			dwcProperties,
					LPVOID			pvDefaultContext,
					BOOL			fIsSorted = FALSE)
	{
		m_pProperties = pProperties;
		m_pData = pData;
		m_dwProperties = dwcProperties;
		m_fIsSorted = fIsSorted;

		// Set up default context for properties
		for (DWORD i = 0; i < dwcProperties; i++)
			m_pData[i].pContext = pvDefaultContext;

		return(TRUE);
	}

	~CPropertyTable()
	{
		// Wipe out members
		m_pProperties = NULL;
		m_dwProperties = 0;

		// Free the scratch buffer, if not equal to default
		if (m_szBuffer != m_rgcBuffer)
		{
			LocalFree((HLOCAL)m_szBuffer);
		}
	}

	// Method to get the property type given the property name
	HRESULT GetPropertyType(LPCSTR	szPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);

	HRESULT GetPropertyType(LPCWSTR	wszPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);

	// Method to retrieve the associated property item
	HRESULT GetProperty(LPPROP_CTXT	pPropertyContext,
						LPVOID		pvBuffer,
						LPDWORD		pdwBufferLen);

	// Method to set the associated property item
	HRESULT SetProperty(LPCSTR	szPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);

	HRESULT SetProperty(LPCWSTR	wszPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);

	// Method to commit all changes. This must be called or
	// all the changes will be lost
	HRESULT CommitChanges();

	// Method to rollback changes to the initial state or the
	// state after the last commit, whichever is more recent
	HRESULT Invalidate();

  private:
  
	// Method to obtain a scratch buffer of the desired size,
	// will allocate new one if insufficient. Size in bytes.
	LPVOID GetScratchBuffer(DWORD dwSizeDesired);

	// Method to search the property table and return the associated
	// property item, if found
	LPPROPERTY_ITEM SearchForProperty(LPCSTR szPropertyName);

	// Pointer to property table and count of items
	LPPROPERTY_ITEM		m_pProperties;
	LPPROPERTY_DATA		m_pData;
	DWORD				m_dwProperties;

	// TRUE if the table of properties is sorted, will use
	// binary search if so. Otherwise, a linear scan is performed
	BOOL				m_fIsSorted;

	// Default scratch buffer, used for wide string to LPSTR
	// conversion
	CHAR				m_rgcBuffer[DEFAULT_SCRATCH_BUFFER_SIZE];

	// Pointer to current scratch buffer, will be freed by 
	// destructor if not equal to m_rgcBuffer
	LPSTR				m_szBuffer;
	DWORD				m_cBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\pbagstm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	pbagstm.h

Abstract:

	This module contains the definition of the property bag stream

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/09/97	created

--*/

#ifndef _PBAGSTM_H_
#define _PBAGSTM_H_

#include "cpool.h"

#define MAX_PROPERTY_NAME_LENGTH		256

typedef struct _TABLE_ENTRY
{
	DWORD		dwOffset;
	DWORD		dwSize;
	DWORD		dwNameSize;
	DWORD		dwMaxSize;
	DWORD		dwKey;	
	WORD		fFlags;
	WORD		wIndex;

} TABLE_ENTRY, *LPTABLE_ENTRY;

typedef struct _STREAM_HEADER
{
	DWORD				dwSignature;
	WORD				wVersionHigh;
	WORD				wVersionLow;
	DWORD				dwHeaderSize;
	DWORD				dwProperties;
	DWORD				dwDirectorySize;
	DWORD				dwEndOfData;

} STREAM_HEADER, *LPSTREAM_HEADER;

#define _CACHE_SIZE				64

typedef enum _PROPERTY_BAG_CREATORS
{
	PBC_NONE = 0,
	PBC_BUILDQ,
	PBC_DIRNOT,
	PBC_ENV,
	PBC_LOCALQ,
	PBC_MAILQ,
	PBC_REMOTEQ,
	PBC_RRETRYQ,
	PBC_SMTPCLI

} PROPERTY_BAG_CREATORS;

typedef enum _PROPERTY_FLAG_OPERATIONS
{
	PFO_NONE = 0,
	PFO_OR,
	PFO_ANDNOT

} PROPERTY_FLAG_OPERATIONS;

/////////////////////////////////////////////////////////////////////////////
// CPropertyBagStream
//

class CPropertyBagStream
{
  public:
	CPropertyBagStream(DWORD dwContext = 0);
	~CPropertyBagStream();

	static CPool		Pool;

	// override the mem functions to use CPool functions
	void *operator new (size_t cSize)
					   { return Pool.Alloc(); }
	void operator delete (void *pInstance)
					   { Pool.Free(pInstance); }

	// Reference count methods ...
	ULONG AddRef();
	ULONG Release(BOOL fDeleteIfZeroRef = FALSE);

	HRESULT SetStreamFileName(LPSTR	szStreamFileName);
	LPSTR GetStreamFileName() { return(m_szStreamName); }

	// Mechanisms for locking and unlocking the property bag
	HRESULT Lock();
	HRESULT Unlock();

	// Force opens the stream file if it is not already opened.
	// This is useful in checking if a stream file exists.
	HRESULT OpenStreamFile();

	// Access to properties as a whole
	HRESULT GetProperty(LPSTR	pszName, 
						LPVOID	pvBuffer,
						LPDWORD	pdwBufferLen);

	HRESULT SetProperty(LPSTR	pszName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen);

	// Access to properties, providing specific access to 
	// portions of the property data relative to the start
	// of the property data
	HRESULT GetPropertyAt(LPSTR	pszName, 
						DWORD	dwOffsetFromStart,
						LPVOID	pvBuffer,
						LPDWORD	pdwBufferLen);

	HRESULT SetPropertyAt(LPSTR	pszName,
						DWORD	dwOffsetFromStart,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen);

	// Ad-hoc function to allow access to a specific DWORD of
	// a property, treating the DWORD as a set of flags. The 
	// dwOperation argument specifies what kind of binary operation
	// we would like to have performed on the original value.
	// If the property does not originally exist, this function
	// will fail.
	HRESULT UpdatePropertyFlagsAt(LPSTR	pszName, 
						DWORD	dwOffsetFromStart,
						DWORD	dwFlags,
						DWORD	dwOperation);

#ifdef USE_PROPERTY_ITEM_ISTREAM
	// Returns an IStream interface to the desired property
	// for random access
	HRESULT GetIStreamToProperty(LPSTR		pszName,
								 IStream	**ppIStream);
#endif

	BOOL DeleteStream();

  private:

	BOOL ReleaseStream();

	HRESULT Seek(DWORD	dwOffset, DWORD	dwMethod);

	HRESULT LoadIntoCache(DWORD	dwStartIndex);

	LPTABLE_ENTRY FindFromCache(DWORD	dwKey,
								LPDWORD	pdwStartIndex);	

	HRESULT FindFrom(LPSTR	pszName,
							DWORD	dwKey,
							DWORD	dwStartIndex,
							BOOL	fForward,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry);

	HRESULT FindFromEx(LPSTR	pszName,
							DWORD	dwKey,
							DWORD	dwStartIndex,
							BOOL	fForward,
							DWORD	dwOffsetFromStart,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry);

	HRESULT GetRecordData(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordName(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordValue(LPTABLE_ENTRY	pEntry, 
							LPVOID		pvBuffer);

	HRESULT GetRecordValueAt(LPTABLE_ENTRY	pEntry, 
							DWORD		dwOffsetFromStart,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen);

	HRESULT UpdateEntry(LPTABLE_ENTRY	pEntry);

	HRESULT UpdateHeader();
	HRESULT UpdateHeaderUsingHandle(HANDLE hStream);

	HRESULT FindProperty(LPSTR	pszName,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry = NULL);

	HRESULT FindPropertyEx(LPSTR	pszName,
							DWORD	dwOffsetFromStart,
							LPVOID	pvBuffer,
							LPDWORD	pdwBufferLen,
							LPTABLE_ENTRY	*ppEntry = NULL);

	HRESULT SetRecordData(LPTABLE_ENTRY	pEntry,
							LPSTR		pszName,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen);

	HRESULT SetRecordDataAt(LPTABLE_ENTRY	pEntry,
							LPSTR		pszName,
							DWORD		dwOffsetFromStart,
							LPVOID		pvBuffer,
							DWORD		dwBufferLen,
							BOOL		fNewRecord = FALSE);

	HRESULT RelocateRecordData(LPTABLE_ENTRY	pEntry);

	HRESULT DetermineIfCacheValid(BOOL *pfCacheInvalid);

	DWORD CreateKey(LPSTR	pszName)
	{
		CHAR cKey[9];
		DWORD dwLen = 0;

		// Convert to lower case ...
		while (*pszName && (dwLen < 8))
			if ((*pszName >= 'A') && (*pszName <= 'Z'))
				cKey[dwLen++] = *pszName++ - 'A' + 'a';
			else
				cKey[dwLen++] = *pszName++;
		cKey[dwLen] = '\0';
		dwLen = lstrlen(cKey);

		// Create the key
		if (dwLen < 4)
			return((DWORD)cKey[dwLen - 1]);
		else if (dwLen < 8)
			return(*(DWORD *)cKey);
		else
			return(~*(DWORD *)cKey ^ *(DWORD *)(cKey + 4));
	}

	DWORD GetTotalHeaderSize()
	{	
		return(sizeof(STREAM_HEADER) + 
				(m_Header.dwDirectorySize * sizeof(TABLE_ENTRY)));
	}

	// Current context
	DWORD				m_dwContext;

	// Base file name
	CHAR				m_szStreamName[MAX_PATH + 1];

	// Handle to stream
	HANDLE				m_hStream;

	// Stream header
	STREAM_HEADER		m_Header;

	// Directory caching
	TABLE_ENTRY			m_Cache[_CACHE_SIZE];
	DWORD				m_dwCacheStart;	
	DWORD				m_dwCachedItems;

	// Reference counting
	LONG				m_lRef;

	// This is a signature placed at the end to catch memory overwrite
	DWORD				m_dwSignature;

};


/////////////////////////////////////////////////////////////////////////////
// CPropertyItemStream
//

//
// Not everyone wants to use the property IStream, so we don't expose
// it if it's not wanted
//
#ifdef USE_PROPERTY_ITEM_ISTREAM

class CPropertyItemStream : public IStream
{
	public:

		CPropertyItemStream(LPSTR				pszName, 
							CPropertyBagStream	*pBag)
		{
			m_cRef = 0;

			m_pParentBag = pBeg;
			m_szName = pszName;
			m_libOffset.QuadPart = (DWORDLONG)0;
		}

		~CPropertyItemStream()
		{
			Cleanup();
		}

		// IUnknown 
		STDMETHODIMP QueryInterface(REFIID, void**);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);

		void Cleanup() {}
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		CPropertyBagStream	*m_pParentBag;

		LPSTR				m_szName;
		ULARGE_INTEGER		m_libOffset;

		long				m_cRef;
};

#endif // USE_PROPERTY_ISTREAM

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\smtpdata.h ===
//#---------------------------------------------------------------
//  File:       smtpdata.h
//
//  Synopsis:   Extensible object definitions for the SMTP
//              Server's counter objects & counters.
//
//  Copyright (C) 1995 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on msn sources by rkamicar, keithmo
//              dhowell - added Instance Support for K2
//----------------------------------------------------------------

#ifndef _SMTPDATA_H_
#define _SMTPDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any unsigned __int64s that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _SMTP_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    unsigned __int64    DummyEntryForAlignmentPurposesOnly;

} SMTP_COUNTER_BLOCK;


#define         INSTANCE_NAME_SIZE      20

typedef WCHAR   SMTP_INSTANCE_NAME[INSTANCE_NAME_SIZE];

typedef struct _SMTP_INSTANCE_DEFINITION
{   
    PERF_INSTANCE_DEFINITION    PerfInstanceDef;
    SMTP_INSTANCE_NAME          InstanceName;
} SMTP_INSTANCE_DEFINITION;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define SMTP_BYTES_SENT_TTL_OFFSET                  sizeof(SMTP_COUNTER_BLOCK)
#define SMTP_BYTES_SENT_PER_SEC_OFFSET              (SMTP_BYTES_SENT_TTL_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_TTL_OFFSET                  (SMTP_BYTES_SENT_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_PER_SEC_OFFSET              (SMTP_BYTES_RCVD_TTL_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_TTL_OFFSET                       (SMTP_BYTES_RCVD_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_TTL_PER_SEC_OFFSET               (SMTP_BYTES_TTL_OFFSET + sizeof(unsigned __int64))

#define SMTP_BYTES_SENT_MSG_OFFSET                  (SMTP_BYTES_TTL_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET          (SMTP_BYTES_SENT_MSG_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_MSG_OFFSET                  (SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET          (SMTP_BYTES_RCVD_MSG_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_MSG_OFFSET                       (SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_BYTES_MSG_PER_SEC_OFFSET               (SMTP_BYTES_MSG_OFFSET + sizeof(unsigned __int64))

#define SMTP_MSG_RCVD_TTL_OFFSET                    (SMTP_BYTES_MSG_PER_SEC_OFFSET + sizeof(unsigned __int64))
#define SMTP_MSG_RCVD_PER_SEC_OFFSET                (SMTP_MSG_RCVD_TTL_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET          (SMTP_MSG_RCVD_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET     (SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET      (SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET (SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET      (SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET (SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET           (SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET          (SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET + sizeof(DWORD))
#define SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET           (SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET + sizeof(DWORD))


#define SMTP_MSG_DLVR_TTL_OFFSET                    (SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_DLVR_PER_SEC_OFFSET                (SMTP_MSG_DLVR_TTL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_DLVR_RETRIES_TTL_OFFSET            (SMTP_MSG_DLVR_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET        (SMTP_MSG_DLVR_RETRIES_TTL_OFFSET + sizeof(DWORD))      
#define SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET   (SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET + sizeof(DWORD))
#define SMTP_MSG_FWD_TTL_OFFSET                     (SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET + sizeof(DWORD))
#define SMTP_MSG_FWD_PER_SEC_OFFSET                 (SMTP_MSG_FWD_TTL_OFFSET + sizeof(DWORD))
#define SMTP_NDR_GENERATED_OFFSET                   (SMTP_MSG_FWD_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_LOCALQ_LENGTH_OFFSET                   (SMTP_NDR_GENERATED_OFFSET + sizeof(DWORD))
#define SMTP_RETRYQ_LENGTH_OFFSET                   (SMTP_LOCALQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_NUM_MAILFILE_HANDLES_OFFSET            (SMTP_RETRYQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_NUM_QUEUEFILE_HANDLES_OFFSET           (SMTP_NUM_MAILFILE_HANDLES_OFFSET + sizeof(DWORD))              
#define SMTP_CATQ_LENGTH_OFFSET                     (SMTP_NUM_QUEUEFILE_HANDLES_OFFSET + sizeof(DWORD))

#define SMTP_MSG_SENT_TTL_OFFSET                    (SMTP_CATQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_MSG_SENT_PER_SEC_OFFSET                (SMTP_MSG_SENT_TTL_OFFSET + sizeof(DWORD))
#define SMTP_MSG_SEND_RETRIES_TTL_OFFSET            (SMTP_MSG_SENT_PER_SEC_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET        (SMTP_MSG_SEND_RETRIES_TTL_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET   (SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET + sizeof(DWORD))
#define SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET          (SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET + sizeof(DWORD))
#define SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET     (SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET + sizeof(DWORD))
#define SMTP_REMOTEQ_LENGTH_OFFSET                  (SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET + sizeof(DWORD))

#define SMTP_DNS_QUERIES_TTL_OFFSET                 (SMTP_REMOTEQ_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_DNS_QUERIES_PER_SEC_OFFSET             (SMTP_DNS_QUERIES_TTL_OFFSET + sizeof(DWORD))
#define SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET       (SMTP_DNS_QUERIES_PER_SEC_OFFSET + sizeof(DWORD))

#define SMTP_CONN_IN_TTL_OFFSET                     (SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET + sizeof(DWORD))
#define SMTP_CONN_IN_CURR_OFFSET                    (SMTP_CONN_IN_TTL_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_TTL_OFFSET                    (SMTP_CONN_IN_CURR_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_CURR_OFFSET                   (SMTP_CONN_OUT_TTL_OFFSET + sizeof(DWORD))
#define SMTP_CONN_OUT_REFUSED_OFFSET                (SMTP_CONN_OUT_CURR_OFFSET + sizeof(DWORD))

#define SMTP_ERR_TTL_OFFSET                         (SMTP_CONN_OUT_REFUSED_OFFSET + sizeof(DWORD))
#define SMTP_ERR_PER_SEC_OFFSET                     (SMTP_ERR_TTL_OFFSET + sizeof(DWORD))

/*** HIT A COMPILER LIMIT ON OPEN BRACKETS, HAD TO REMOVE SOME BRAKETS ***/

#define SMTP_DIR_DROPS_OFFSET                       SMTP_ERR_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_DIR_DROPS_PER_SEC_OFFSET               SMTP_DIR_DROPS_OFFSET + sizeof(DWORD)
#define SMTP_RT_LOOKUPS_OFFSET                      SMTP_DIR_DROPS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_RT_LOOKUPS_PER_SEC_OFFSET              SMTP_RT_LOOKUPS_OFFSET + sizeof(DWORD)
#define SMTP_ETRN_MSGS_OFFSET                       SMTP_RT_LOOKUPS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_ETRN_MSGS_PER_SEC_OFFSET               SMTP_ETRN_MSGS_OFFSET + sizeof(DWORD)

#define SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET       SMTP_ETRN_MSGS_PER_SEC_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET  SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET     SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET + sizeof(DWORD)             
#define SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET     SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_EVENT_OFFSET               SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET + sizeof(DWORD)
#define SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET          SMTP_MSG_BADMAIL_EVENT_OFFSET + sizeof(DWORD)
#define SMTP_MSG_PENDING_ROUTING_OFFSET             SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET + sizeof(DWORD)
#define SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET    SMTP_MSG_PENDING_ROUTING_OFFSET + sizeof(DWORD)
#define SMTP_SUBMITTED_MESSAGES_OFFSET              SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET + sizeof(DWORD)
#define SMTP_DSN_FAILURES_OFFSET                    SMTP_SUBMITTED_MESSAGES_OFFSET + sizeof(DWORD)
#define SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET           SMTP_DSN_FAILURES_OFFSET + sizeof(DWORD)

#define SMTP_CATSUBMISSIONS_OFFSET                  SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET + sizeof(DWORD)
#define SMTP_CATCOMPLETIONS_OFFSET                  SMTP_CATSUBMISSIONS_OFFSET + sizeof(DWORD)
#define SMTP_CURRENTCATEGORIZATIONS_OFFSET          SMTP_CATCOMPLETIONS_OFFSET + sizeof(DWORD)
#define SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET        SMTP_CURRENTCATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_HARDFAILURECATEGORIZATIONS_OFFSET      SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET     SMTP_HARDFAILURECATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYOUTOFMEMORY_OFFSET                SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET + sizeof(DWORD)
#define SMTP_RETRYDSLOGON_OFFSET                    SMTP_RETRYOUTOFMEMORY_OFFSET + sizeof(DWORD)
#define SMTP_RETRYDSCONNECTION_OFFSET               SMTP_RETRYDSLOGON_OFFSET + sizeof(DWORD)
#define SMTP_RETRYGENERIC_OFFSET                    SMTP_RETRYDSCONNECTION_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET     SMTP_RETRYGENERIC_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESCREATED_OFFSET                 SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET + sizeof(DWORD)
#define SMTP_MESSAGESABORTED_OFFSET                 SMTP_MESSAGESCREATED_OFFSET + sizeof(DWORD)
#define SMTP_PRECATRECIPIENTS_OFFSET                SMTP_MESSAGESABORTED_OFFSET + sizeof(DWORD)
#define SMTP_POSTCATRECIPIENTS_OFFSET               SMTP_PRECATRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_NDRDRECIPIENTS_OFFSET                  SMTP_POSTCATRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_UNRESOLVEDRECIPIENTS_OFFSET            SMTP_NDRDRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_AMBIGUOUSRECIPIENTS_OFFSET             SMTP_UNRESOLVEDRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_ILLEGALRECIPIENTS_OFFSET               SMTP_AMBIGUOUSRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_LOOPRECIPIENTS_OFFSET                  SMTP_ILLEGALRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_GENERICFAILURERECIPIENTS_OFFSET        SMTP_LOOPRECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_RECIPSINMEMORY_OFFSET                  SMTP_GENERICFAILURERECIPIENTS_OFFSET + sizeof(DWORD)
#define SMTP_UNRESOLVEDSENDERS_OFFSET               SMTP_RECIPSINMEMORY_OFFSET + sizeof(DWORD)
#define SMTP_AMBIGUOUSSENDERS_OFFSET                SMTP_UNRESOLVEDSENDERS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPS_OFFSET                  SMTP_AMBIGUOUSSENDERS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET        SMTP_ADDRESSLOOKUPS_OFFSET + sizeof(DWORD)
#define SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET          SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET + sizeof(DWORD)
#define SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET      SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET + sizeof(DWORD)
#define SMTP_CONNECTIONS_OFFSET                     SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET + sizeof(DWORD)
#define SMTP_CONNECTFAILURES_OFFSET                 SMTP_CONNECTIONS_OFFSET + sizeof(DWORD)
#define SMTP_OPENCONNECTIONS_OFFSET                 SMTP_CONNECTFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_BINDS_OFFSET                           SMTP_OPENCONNECTIONS_OFFSET + sizeof(DWORD)
#define SMTP_BINDFAILURES_OFFSET                    SMTP_BINDS_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHES_OFFSET                        SMTP_BINDFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHES_OFFSET                   SMTP_SEARCHES_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHFAILURES_OFFSET                  SMTP_PAGEDSEARCHES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHFAILURES_OFFSET             SMTP_SEARCHFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHESCOMPLETED_OFFSET               SMTP_PAGEDSEARCHFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHESCOMPLETED_OFFSET          SMTP_SEARCHESCOMPLETED_OFFSET + sizeof(DWORD)
#define SMTP_SEARCHCOMPLETIONFAILURES_OFFSET        SMTP_PAGEDSEARCHESCOMPLETED_OFFSET + sizeof(DWORD)
#define SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET   SMTP_SEARCHCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_GENERALCOMPLETIONFAILURES_OFFSET       SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_ABANDONEDSEARCHES_OFFSET               SMTP_GENERALCOMPLETIONFAILURES_OFFSET + sizeof(DWORD)
#define SMTP_PENDINGSEARCHES_OFFSET                 SMTP_ABANDONEDSEARCHES_OFFSET + sizeof(DWORD)
// This needs to be here to pad out the number of bytes returned to 
// be divisible by 8.  If you add new counters please check eventvwr to 
// make sure that you don't have warnings from Perflib saying that your
// counters aren't properly padded.  If you do get these warnings then
// comment out this item
#define SMTP_PADDING_OFFSET                         SMTP_PENDINGSEARCHES_OFFSET + sizeof(DWORD)

#define SIZE_OF_SMTP_PERFORMANCE_DATA               SMTP_PADDING_OFFSET + sizeof(DWORD)


//
//  The counter structure returned.
//

typedef struct _SMTP_DATA_DEFINITION
{
    PERF_OBJECT_TYPE        SmtpObjectType;
    PERF_COUNTER_DEFINITION SmtpBytesSentTtl;
    PERF_COUNTER_DEFINITION SmtpBytesSentPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdTtl;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesTtl;
    PERF_COUNTER_DEFINITION SmtpBytesTtlPerSec;

    PERF_COUNTER_DEFINITION SmtpBytesSentMsg;
    PERF_COUNTER_DEFINITION SmtpBytesSentMsgPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdMsg;
    PERF_COUNTER_DEFINITION SmtpBytesRcvdMsgPerSec;
    PERF_COUNTER_DEFINITION SmtpBytesMsg;
    PERF_COUNTER_DEFINITION SmtpBytesMsgPerSec;

    PERF_COUNTER_DEFINITION SmtpMsgRcvdTtl;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdPerSec;
    PERF_COUNTER_DEFINITION SmtpAvgRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpPctLclRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBasePctLclRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpPctRmtRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpBasePctRmtRcptsPerMsgRcvd;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedSize;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedCAddr;
    PERF_COUNTER_DEFINITION SmtpMsgRcvdRefusedMail;

    PERF_COUNTER_DEFINITION SmtpMsgDlvrTtl;
    PERF_COUNTER_DEFINITION SmtpMsgDlvrPerSec;
    PERF_COUNTER_DEFINITION SmtpMsgDlvrRetriesTtl;
    PERF_COUNTER_DEFINITION SmtpAvgRetriesPerMsgDlvr;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRetriesPerMsgDlvr;
    PERF_COUNTER_DEFINITION SmtpMsgFwdTtl;
    PERF_COUNTER_DEFINITION SmtpMsgFwdPerSec;
    PERF_COUNTER_DEFINITION SmtpNdrGenerated;
    PERF_COUNTER_DEFINITION SmtpLocalQLength;
    PERF_COUNTER_DEFINITION SmtpRetryQLength;
    PERF_COUNTER_DEFINITION SmtpNumMailFileHandles;
    PERF_COUNTER_DEFINITION SmtpNumQueueFileHandles;
    PERF_COUNTER_DEFINITION SmtpCatQLength;

    PERF_COUNTER_DEFINITION SmtpMsgSentTtl;
    PERF_COUNTER_DEFINITION SmtpMsgSentPerSec;
    PERF_COUNTER_DEFINITION SmtpMsgSendRetriesTtl;
    PERF_COUNTER_DEFINITION SmtpAvgRetriesPerMsgSend;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRetriesPerMsgSend;
    PERF_COUNTER_DEFINITION SmtpAvgRcptsPerMsgSent;
    PERF_COUNTER_DEFINITION SmtpBaseAvgRcptsPerMsgSent;
    PERF_COUNTER_DEFINITION SmtpRemoteQLength;

    PERF_COUNTER_DEFINITION SmtpDnsQueriesTtl;
    PERF_COUNTER_DEFINITION SmtpDnsQueriesPerSec;
    PERF_COUNTER_DEFINITION SmtpRemoteRetryQueueLength;

    PERF_COUNTER_DEFINITION SmtpConnInTtl;
    PERF_COUNTER_DEFINITION SmtpConnInCurr;
    PERF_COUNTER_DEFINITION SmtpConnOutTtl;
    PERF_COUNTER_DEFINITION SmtpConnOutCurr;
    PERF_COUNTER_DEFINITION SmtpConnOutRefused;

    PERF_COUNTER_DEFINITION SmtpErrTtl;
    PERF_COUNTER_DEFINITION SmtpErrPerSec;
        
    PERF_COUNTER_DEFINITION SmtpDirectoryDropsTtl;
    PERF_COUNTER_DEFINITION SmtpDirectoryDropsPerSec;
    PERF_COUNTER_DEFINITION SmtpRoutingTblLookupsTtl;
    PERF_COUNTER_DEFINITION SmtpRoutingTblLookupsPerSec;
    PERF_COUNTER_DEFINITION SmtpETRNMsgsTtl;
    PERF_COUNTER_DEFINITION SmtpETRNMsgsPerSec;

    PERF_COUNTER_DEFINITION MsgsBadmailNoRecipients;
    PERF_COUNTER_DEFINITION MsgsBadmailHopCountExceeded;
    PERF_COUNTER_DEFINITION MsgsBadmailFailureGeneral;
    PERF_COUNTER_DEFINITION MsgsBadmailBadPickupFile;
    PERF_COUNTER_DEFINITION MsgsBadmailEvent;
    PERF_COUNTER_DEFINITION MsgsBadmailNdrOfDsn;
    PERF_COUNTER_DEFINITION MsgsPendingRouting;
    PERF_COUNTER_DEFINITION MsgsPendingUnreachableLink;
    PERF_COUNTER_DEFINITION SubmittedMessages;
    PERF_COUNTER_DEFINITION DSNFailures;
    PERF_COUNTER_DEFINITION MsgsInLocalDelivery;

    PERF_COUNTER_DEFINITION CatSubmissions;
    PERF_COUNTER_DEFINITION CatSubmissionsPerSec;
    PERF_COUNTER_DEFINITION CatCompletions;
    PERF_COUNTER_DEFINITION CatCompletionsPerSec;
    PERF_COUNTER_DEFINITION CatCurrentCategorizations;
    PERF_COUNTER_DEFINITION CatSucceededCategorizations;
    PERF_COUNTER_DEFINITION CatHardFailures;
    PERF_COUNTER_DEFINITION CatRetryFailures;
    PERF_COUNTER_DEFINITION CatOutOfMemoryFailures;
    PERF_COUNTER_DEFINITION CatDsLogonFailures;
    PERF_COUNTER_DEFINITION CatDsConnectionFailures;
    PERF_COUNTER_DEFINITION CatGenericRetryFailures;
    PERF_COUNTER_DEFINITION CatMsgsOut;
    PERF_COUNTER_DEFINITION CatMsgsCreated;
    PERF_COUNTER_DEFINITION CatMsgsAborted;
    PERF_COUNTER_DEFINITION CatRecipsPreCat;
    PERF_COUNTER_DEFINITION CatRecipsPostCat;
    PERF_COUNTER_DEFINITION CatRecipsNDRd;
    PERF_COUNTER_DEFINITION CatRecipsUnresolved;
    PERF_COUNTER_DEFINITION CatRecipsAmbiguous;
    PERF_COUNTER_DEFINITION CatRecipsIllegal;
    PERF_COUNTER_DEFINITION CatRecipsLoop;
    PERF_COUNTER_DEFINITION CatRecipsGenericFailure;
    PERF_COUNTER_DEFINITION CatRecipsInMemory;
    PERF_COUNTER_DEFINITION CatSendersUnresolved;
    PERF_COUNTER_DEFINITION CatSendersAmbiguous;
    PERF_COUNTER_DEFINITION CatAddressLookups;
    PERF_COUNTER_DEFINITION CatAddressLookupsPerSec;
    PERF_COUNTER_DEFINITION CatAddressCompletions;
    PERF_COUNTER_DEFINITION CatAddressCompletionsPerSec;
    PERF_COUNTER_DEFINITION CatAddressLookupsNotFound;
    PERF_COUNTER_DEFINITION CatMailMsgDuplicateCollisions;
    PERF_COUNTER_DEFINITION CatLDAPConnections;
    PERF_COUNTER_DEFINITION CatLDAPConnectionFailures;
    PERF_COUNTER_DEFINITION CatLDAPOpenConnections;
    PERF_COUNTER_DEFINITION CatLDAPBinds;
    PERF_COUNTER_DEFINITION CatLDAPBindFailures;
    PERF_COUNTER_DEFINITION CatLDAPSearches;
    PERF_COUNTER_DEFINITION CatLDAPSearchesPerSec;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearches;
    PERF_COUNTER_DEFINITION CatLDAPSearchFailures;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchFailures;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompleted;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompletedPerSec;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchesCompleted;
    PERF_COUNTER_DEFINITION CatLDAPSearchesCompeltedFailure;
    PERF_COUNTER_DEFINITION CatLDAPPagedSearchesCompletedFailure;
    PERF_COUNTER_DEFINITION CatLDAPGeneralCompletionFailure;
    PERF_COUNTER_DEFINITION CatLDAPAbandonedSearches;
    PERF_COUNTER_DEFINITION CatLDAPPendingSearches;

} SMTP_DATA_DEFINITION;


extern  SMTP_DATA_DEFINITION        SmtpDataDefinition;
extern  SMTP_INSTANCE_DEFINITION    SmtpInstanceDefinition;

#define NUMBER_OF_SMTP_COUNTERS ((sizeof(SMTP_DATA_DEFINITION) -        \
                                sizeof(PERF_OBJECT_TYPE)) /     \
                                sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _SMTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\smtps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    smtps.h

    This file contains constants & type definitions shared between the
    SMTP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _SMTPS_H_
#define _SMTPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif

//
//  Service name.
//

#define SMTP_SERVICE_NAME               TEXT("SMTPSVC")
#define SMTP_SERVICE_NAME_A             "SMTPSVC"
#define SMTP_SERVICE_NAME_W             L"SMTPSVC"

#define IPPORT_SMTP                     25
#define IPPORT_SMTP_SECURE              465

//
//  Name of the log file, used for logging file accesses.
//

#define SMTP_LOG_FILE                  TEXT("SMTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define SMTP_PARAMETERS_KEY_A   "System\\CurrentControlSet\\Services\\SMTPSvc\\Parameters"
#define SMTP_PARAMETERS_KEY_W   L"System\\CurrentControlSet\\Services\\SMTPSvc\\Parameters"
#define SMTP_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters")


//
//  Performance key.
//

#define SMTP_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Performance")

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//
#define SMTP_ANONYMOUS_SECRET         TEXT("SMTP_ANONYMOUS_DATA")
#define SMTP_ANONYMOUS_SECRET_A       "SMTP_ANONYMOUS_DATA"
#define SMTP_ANONYMOUS_SECRET_W       L"SMTP_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//
#define SMTP_ROOT_SECRET_W            L"SMTP_ROOT_DATA"

#define DEFAULT_AUTHENTICATION	MD_AUTH_BASIC|MD_AUTH_NT
#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _SMTPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\smtptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _SMTPTYPE_
#define _SMTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Common Gibraltar Service types.
//
#include <gibtype.h>

//
//  Simple types.
//

#ifdef __cplusplus
}
#endif

#endif _SMTPTYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\stream.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.h

Abstract:

	This module contains the definition for the Server
	Extension Object Stream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29/97	created

--*/


// stream.h : Declaration of the CSEOStream

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE __declspec(uuid("2DF59671-3D15-11d1-AA51-00AA006BC80B")) CSEOStream : 
	public CComObjectRoot,
	public IStream
//	, public CComCoClass<CSEOStream, &CLSID_CSEOStream>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Cleanup();
		HRESULT Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Open();
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);
		static HRESULT CreateInstance(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream, IStream **ppStream);
		static HRESULT CreateInstance(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream, IStream **ppStream);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CSEOStream);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SMTP IStream Class",
//								   L"SMTP.IStream.1",
//								   L"SMTP.IStream");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOStream)
		COM_INTERFACE_ENTRY(IStream)
		COM_INTERFACE_ENTRY_IID(__uuidof(CSEOStream),CSEOStream)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		HANDLE m_hFile;
		LPSTR m_pszFile;
		ULARGE_INTEGER m_libOffset;
		HANDLE m_hEvent;
		CSEOStream *m_pSubStream;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\catparams.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catparams.cpp
//
// Contents: Categorizer server event parameter classes
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/06/23 13:13:58: Created.
//
//-------------------------------------------------------------
#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>
#include "dbgtrace.h"

#include "imd.h"
#include "mb.hxx"

#include <smtpevents.h>

#include <stdio.h>

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL


#include "seo.h"
#include "seolib.h"
#include "smtpdisp.h"
#include "seodisp.h"
#include "seodisp.h"
#include <smtpevent.h>

//
// CMailTransportCatRegisterParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->Register(
        m_pContext->pICatParams);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    if(FAILED(hrRes) && (hrRes != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hrRes;
    }

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    if(FAILED(hr) && (hr != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hr;
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBeginParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BeginMessageCategorization(
        m_pContext->pICatMailMsgs);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatEndParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->EndMessageCategorization(
        m_pContext->pICatMailMsgs,
        m_pContext->hrStatus);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatBuildQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQuery(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault");
    HRESULT hr;

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hr = (m_pContext->pfnDefault)(S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBuildQueriesParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQueries(
        m_pContext->pICatParams,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->pICatQueries);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatSendQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SendQuery(
        m_Context.pICatParams,
        m_Context.pICatQueries,
        m_Context.pICatAsyncContext,
        (LPVOID)&m_Context);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    pSink->Release();

    //
    // SendQuery return values:
    //   MAILTRANSPORT_S_PEDING: Will call (or already called)
    //   ICategorizerAsyncContext.CompleteQuery with the result of
    //   this lookup
    //   S_OK: Will not call CompleteQuery, please continue
    //   S_FALSE: Will not call CompleteQuery, please stop calling sinks
    //   Everything else: Will not call CompleteQuery.
    //

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);


    hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
//
// CMailTransportCatSortQueryResultParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SortQueryResult(
        m_pContext->pICatParams,
        m_pContext->hrResolutionStatus,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->dwcResults,
        m_pContext->rgpICatItemAttributes);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatProcessItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->ProcessItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatExpandItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;
    BOOL fAlreadyAsync;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    DebugTrace((LPARAM)this, "Calling expanditem event on this sink");

    hrRes = pSink->ExpandItem(
        m_Context.pICatParams,
        m_Context.pICatItem,
        m_pINotify,
        (PVOID)this);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hrRes != MAILTRANSPORT_S_PENDING) {

        m_fAsyncCompletion = fAlreadyAsync;
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }
    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault()
{
    HRESULT hr;
    BOOL fAlreadyAsync;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);
    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hr != MAILTRANSPORT_S_PENDING)
        m_fAsyncCompletion = fAlreadyAsync;

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//   Or return value from supplied completion routine
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // The way ExpandItem works is the following:
    //  If any sinks return MAILTRANSPORT_S_PENDING (including the default), 
    //  then TriggerServerEvent returns MAILTRANSPORT_S_PENDING, and
    //  the supplied completion routine will be called. 
    //  Otherwise, TriggerServerEvent returns S_OK and no completion
    //  routine is called
    //
    if(m_fAsyncCompletion)

        hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);
        
    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//
// CMailTransportCatCompleteItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->CompleteItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seomgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: seomgr.h
//
// Contents: A class to manage the SEO dispatcher for a particular
//           SMTP virtual server 
//
// Classes:
//  CSMTPSeoMgr
//
// Functions:
//
// History:
// jstamerj 1999/06/25 19:11:03: Created.
//
//-------------------------------------------------------------
#include <windows.h>

interface IEventRouter;
interface IServerDispatcher;

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(*rg))

//
// Class to manage the SEO configuration of one SMTP virtual server
//
class CSMTPSeoMgr
{
  public:
    CSMTPSeoMgr();
    ~CSMTPSeoMgr();

    HRESULT HrInit(
        DWORD dwVSID);
    VOID Deinit();

    HRESULT HrTriggerServerEvent(
        DWORD dwEventType,
        PVOID pvContext);

    IEventRouter *GetRouter()
    {
        return m_pIEventRouter;
    }

  private:
    #define SIGNATURE_CSMTPSEOMGR           (DWORD)'MSSC'
    #define SIGNATURE_CSMTPSEOMGR_INVALID   (DWORD)'MSSX'

    DWORD m_dwSignature;
    IEventRouter *m_pIEventRouter;
    IServerDispatcher *m_pICatDispatcher;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\smtpapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpapi.h

Abstract:

    This file contains information about the MSN SMTP server counters

Author:

    Johnson Apacible (johnsona)         10-Sept-1995
    Rohan Phillips (Rohanp)             11-Dec-1995

--*/


#ifndef _SMTPAPI_
#define _SMTPAPI_

#ifdef __cplusplus
extern "C" {
#endif

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

#include "smtpext.h"
#include "perfcat.h"

//
// Config Structures and API's

#pragma warning( disable:4200 )          // nonstandard ext. - zero sized array
                                         // (MIDL requires zero entries)

#define NAME_TYPE_USER                  (BitFlag(0))
#define NAME_TYPE_LIST_NORMAL           (BitFlag(1))
#define NAME_TYPE_LIST_DOMAIN           (BitFlag(2))
#define NAME_TYPE_LIST_SITE             (BitFlag(3))

#define NAME_TYPE_ALL                   ( \
                                        NAME_TYPE_USER | \
                                        NAME_TYPE_LIST_NORMAL | \
                                        NAME_TYPE_LIST_DOMAIN | \
                                        NAME_TYPE_LIST_SITE \
                                        )

typedef struct _SMTP_NAME_ENTRY
{
    DWORD       dwType;
    LPWSTR      lpszName;
} SMTP_NAME_ENTRY, *LPSMTP_NAME_ENTRY;


typedef struct _SMTP_NAME_LIST
{
    DWORD       cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_NAME_ENTRY aNameEntry[];
} SMTP_NAME_LIST, *LPSMTP_NAME_LIST;


typedef struct _SMTP_CONN_USER_ENTRY
{
    DWORD       dwUserId;
    LPWSTR      lpszName;
    LPWSTR      lpszHost;
    DWORD       dwConnectTime;
} SMTP_CONN_USER_ENTRY, *LPSMTP_CONN_USER_ENTRY;

typedef struct _SMTP_CONN_USER_LIST
{
    DWORD           cEntries;
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONN_USER_ENTRY    aConnUserEntry[];
} SMTP_CONN_USER_LIST, *LPSMTP_CONN_USER_LIST;

typedef struct _SMTP_CONFIG_DOMAIN_ENTRY
{
    LPWSTR          lpszDomain;
} SMTP_CONFIG_DOMAIN_ENTRY, *LPSMTP_CONFIG_DOMAIN_ENTRY;

typedef struct _SMTP_CONFIG_DOMAIN_LIST
{
    DWORD           cEntries;                   // Count of supported domains
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONFIG_DOMAIN_ENTRY    aDomainEntry[]; // Supported domains
} SMTP_CONFIG_DOMAIN_LIST, *LPSMTP_CONFIG_DOMAIN_LIST;


typedef struct _SMTP_CONFIG_ROUTING_ENTRY
{
    LPWSTR          lpszSource;
} SMTP_CONFIG_ROUTING_ENTRY, *LPSMTP_CONFIG_ROUTING_ENTRY;


typedef struct _SMTP_CONFIG_ROUTING_LIST
{
    DWORD           cEntries;               // Count of supported data sources
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_CONFIG_ROUTING_ENTRY   aRoutingEntry[];
} SMTP_CONFIG_ROUTING_LIST, *LPSMTP_CONFIG_ROUTING_LIST;


// 0 - Perfmon stats

typedef struct _SMTP_STATISTICS_0
{

    // total bytes sent/received, including protocol msgs

    unsigned __int64    BytesSentTotal;
    unsigned __int64    BytesRcvdTotal;
    unsigned __int64    BytesSentMsg;
    unsigned __int64    BytesRcvdMsg;

    //incoming counters
    DWORD               NumMsgRecvd;
    DWORD               NumRcptsRecvd;
    DWORD               NumRcptsRecvdLocal;
    DWORD               NumRcptsRecvdRemote;
    DWORD               MsgsRefusedDueToSize;
    DWORD               MsgsRefusedDueToNoCAddrObjects;
    DWORD               MsgsRefusedDueToNoMailObjects;

    //MTA counters
    DWORD               NumMsgsDelivered;
    DWORD               NumDeliveryRetries;
    DWORD               NumMsgsForwarded;
    DWORD               NumNDRGenerated;
    DWORD               LocalQueueLength;
    DWORD               RetryQueueLength;
    DWORD               NumMailFileHandles;
    DWORD               NumQueueFileHandles;
    DWORD               CatQueueLength;

    //outgoing counters
    DWORD               NumMsgsSent;
    DWORD               NumRcptsSent;
    DWORD               NumSendRetries;
    DWORD               RemoteQueueLength;

    //DNS query counters
    DWORD               NumDnsQueries;
    DWORD               RemoteRetryQueueLength;

    //connection counters
    DWORD               NumConnInOpen;
    DWORD               NumConnInClose;
    DWORD               NumConnOutOpen;
    DWORD               NumConnOutClose;
    DWORD               NumConnOutRefused;

    // other counters
    DWORD               NumProtocolErrs;
    DWORD               DirectoryDrops;
    DWORD               RoutingTableLookups;
    DWORD               ETRNMessages;

    DWORD               MsgsBadmailNoRecipients;
    DWORD               MsgsBadmailHopCountExceeded;
    DWORD               MsgsBadmailFailureGeneral;
    DWORD               MsgsBadmailBadPickupFile;
    DWORD               MsgsBadmailEvent;
    DWORD               MsgsBadmailNdrOfDsn;
    DWORD               MsgsPendingRouting;
    DWORD               MsgsPendingUnreachableLink;
    DWORD               SubmittedMessages;
    DWORD               DSNFailures;
    DWORD               MsgsInLocalDelivery;

    CATPERFBLOCK        CatPerfBlock;

    DWORD               TimeOfLastClear;        // statistics last cleared

} SMTP_STATISTICS_0, *LPSMTP_STATISTICS_0;



typedef struct _SMTP_STATISTICS_BLOCK
{
    DWORD               dwInstance;
    SMTP_STATISTICS_0   Stats_0;
} SMTP_STATISTICS_BLOCK, *PSMTP_STATISTICS_BLOCK;


typedef struct _SMTP_STATISTICS_BLOCK_ARRAY
{
    DWORD           cEntries;                   // Count of instances of statistics
#if defined(MIDL_PASS)
    [size_is(cEntries)]
#endif
    SMTP_STATISTICS_BLOCK       aStatsBlock[];
} SMTP_STATISTICS_BLOCK_ARRAY, *PSMTP_STATISTICS_BLOCK_ARRAY;



#pragma warning(default:4200)

//
// Cut by keithlau on 7/8/96
//
// #define FC_SMTP_INFO_LOOP_BACK               ((FIELD_CONTROL)BitFlag(0))
// #define FC_SMTP_INFO_BACK_LOG                ((FIELD_CONTROL)BitFlag(1))
// #define FC_SMTP_INFO_MAX_OBJECTS             ((FIELD_CONTROL)BitFlag(6))
// #define FC_SMTP_INFO_DOMAIN                  ((FIELD_CONTROL)BitFlag(12))
// #define FC_SMTP_INFO_DELIVERY                ((FIELD_CONTROL)BitFlag(17))
// #define FC_SMTP_INFO_BAD_MAIL                ((FIELD_CONTROL)BitFlag(19))
// #define FC_SMTP_INFO_MAIL_QUEUE_DIR          ((FIELD_CONTROL)BitFlag(20))
// #define FC_SMTP_INFO_FILELINKS               ((FIELD_CONTROL)BitFlag(21))
// #define FC_SMTP_INFO_BATCHMSGS               ((FIELD_CONTROL)BitFlag(22))
// #define FC_SMTP_INFO_ROUTING_DLL             ((FIELD_CONTROL)BitFlag(23))
// #define FC_SMTP_INFO_MAIL_PICKUP_DIR         ((FIELD_CONTROL)BitFlag(25))

#define FC_SMTP_INFO_REVERSE_LOOKUP         ((FIELD_CONTROL)BitFlag(0))
#define FC_SMTP_INFO_MAX_HOP_COUNT          ((FIELD_CONTROL)BitFlag(1))
#define FC_SMTP_INFO_MAX_ERRORS             ((FIELD_CONTROL)BitFlag(2))
#define FC_SMTP_INFO_MAX_SIZE               ((FIELD_CONTROL)BitFlag(3))
#define FC_SMTP_INFO_REMOTE_TIMEOUT         ((FIELD_CONTROL)BitFlag(4))
#define FC_SMTP_INFO_MAX_OUTBOUND_CONN      ((FIELD_CONTROL)BitFlag(5))
#define FC_SMTP_INFO_MAX_RECIPS             ((FIELD_CONTROL)BitFlag(6))
#define FC_SMTP_INFO_RETRY                  ((FIELD_CONTROL)BitFlag(7))
#define FC_SMTP_INFO_PIPELINE               ((FIELD_CONTROL)BitFlag(8))
#define FC_SMTP_INFO_OBSOLETE_ROUTING       ((FIELD_CONTROL)BitFlag(9))
#define FC_SMTP_INFO_SEND_TO_ADMIN          ((FIELD_CONTROL)BitFlag(10))
#define FC_SMTP_INFO_SMART_HOST             ((FIELD_CONTROL)BitFlag(11))
#define FC_SMTP_INFO_AUTHORIZATION          ((FIELD_CONTROL)BitFlag(12))
#define FC_SMTP_INFO_COMMON_PARAMS          ((FIELD_CONTROL)BitFlag(13))
#define FC_SMTP_INFO_DEFAULT_DOMAIN         ((FIELD_CONTROL)BitFlag(14))
#define FC_SMTP_INFO_ROUTING                ((FIELD_CONTROL)BitFlag(15))

//
// Added by keithlau on 7/8/96
//
#define FC_SMTP_INFO_BAD_MAIL_DIR           ((FIELD_CONTROL)BitFlag(15))
#define FC_SMTP_INFO_MASQUERADE             ((FIELD_CONTROL)BitFlag(16))
#define FC_SMTP_INFO_REMOTE_PORT            ((FIELD_CONTROL)BitFlag(17))
#define FC_SMTP_INFO_LOCAL_DOMAINS          ((FIELD_CONTROL)BitFlag(18))
#define FC_SMTP_INFO_DOMAIN_ROUTING         ((FIELD_CONTROL)BitFlag(19))
#define FC_SMTP_INFO_ADMIN_EMAIL_NAME       ((FIELD_CONTROL)BitFlag(20))
#define FC_SMTP_INFO_ALWAYS_USE_SSL         ((FIELD_CONTROL)BitFlag(21))
#define FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN ((FIELD_CONTROL)BitFlag(22))
#define FC_SMTP_INFO_SASL_LOGON_DOMAIN      ((FIELD_CONTROL)BitFlag(23))
#define FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS ((FIELD_CONTROL)BitFlag(24))
#define FC_SMTP_INFO_DEFAULT_DROP_DIR       ((FIELD_CONTROL)BitFlag(25))
#define FC_SMTP_INFO_FQDN                   ((FIELD_CONTROL)BitFlag(26))
#define FC_SMTP_INFO_ETRN_SUBDOMAINS        ((FIELD_CONTROL)BitFlag(27))
#define FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS ((FIELD_CONTROL)BitFlag(29))
#define FC_SMTP_CLEARTEXT_AUTH_PROVIDER     ((FIELD_CONTROL)BitFlag(30))

//
// Added by mlans on 7/24/96
//
#define FC_SMTP_INFO_SSL_PERM               ((FIELD_CONTROL)BitFlag(28))

#define FC_SMTP_ROUTING_TYPE_FILTER         ((FIELD_CONTROL)(BitFlag(30) | BitFlag(31)))
#define FC_SMTP_ROUTING_TYPE_SQL            ((FIELD_CONTROL)(0)))
#define FC_SMTP_ROUTING_TYPE_FF             ((FIELD_CONTROL)BitFlag(30))
#define FC_SMTP_ROUTING_TYPE_LDAP           ((FIELD_CONTROL)BitFlag(31))


#define FC_SMTP_INFO_ALL                    ( \
                                            FC_SMTP_INFO_REVERSE_LOOKUP | \
                                            FC_SMTP_INFO_MAX_HOP_COUNT | \
                                            FC_SMTP_INFO_MAX_ERRORS | \
                                            FC_SMTP_INFO_MAX_SIZE | \
                                            FC_SMTP_INFO_REMOTE_TIMEOUT | \
                                            FC_SMTP_INFO_MAX_OUTBOUND_CONN | \
                                            FC_SMTP_INFO_MAX_RECIPS | \
                                            FC_SMTP_INFO_RETRY | \
                                            FC_SMTP_INFO_PIPELINE | \
                                            FC_SMTP_INFO_ROUTING | \
                                            FC_SMTP_INFO_OBSOLETE_ROUTING | \
                                            FC_SMTP_INFO_SEND_TO_ADMIN | \
                                            FC_SMTP_INFO_SMART_HOST | \
                                            FC_SMTP_INFO_COMMON_PARAMS | \
                                            FC_SMTP_INFO_DEFAULT_DOMAIN | \
                                            FC_SMTP_INFO_BAD_MAIL_DIR  | \
                                            FC_SMTP_INFO_MASQUERADE | \
                                            FC_SMTP_INFO_LOCAL_DOMAINS | \
                                            FC_SMTP_INFO_REMOTE_PORT | \
                                            FC_SMTP_INFO_DOMAIN_ROUTING |\
                                            FC_SMTP_INFO_ADMIN_EMAIL_NAME |\
                                            FC_SMTP_INFO_ALWAYS_USE_SSL |\
                                            FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN |\
                                            FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS |\
                                            FC_SMTP_INFO_DEFAULT_DROP_DIR |\
                                            FC_SMTP_INFO_FQDN |\
                                            FC_SMTP_INFO_ETRN_SUBDOMAINS |\
                                            FC_SMTP_INFO_SSL_PERM |\
                                            FC_SMTP_INFO_AUTHORIZATION |\
                                            FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS |\
                                            FC_SMTP_INFO_SASL_LOGON_DOMAIN |\
                                            FC_SMTP_CLEARTEXT_AUTH_PROVIDER \
                                            )

//
// Cut out from FC_SMTP_INFO_ALL by keithlau on 7/8/96
//
/*
 *
                                            FC_SMTP_INFO_LOOP_BACK | \
                                            FC_SMTP_INFO_BACK_LOG | \
                                            FC_SMTP_INFO_MAX_OBJECTS | \
                                            FC_SMTP_INFO_DELIVERY | \
                                            FC_SMTP_INFO_BAD_MAIL | \
                                            FC_SMTP_INFO_DOMAIN | \
                                            FC_SMTP_INFO_MAIL_QUEUE_DIR | \
                                            FC_SMTP_INFO_FILELINKS | \
                                            FC_SMTP_INFO_BATCHMSGS | \
                                            FC_SMTP_INFO_ROUTING_DLL | \
                                            FC_SMTP_INFO_MAIL_PICKUP_DIR \
 *
 */

typedef struct _SMTP_CONFIG_INFO
{
    FIELD_CONTROL FieldControl;

    //
    // Removed by keithlau on 7/8/96
    //
    // DWORD            dwCheckLoopBack;            // Make sure we're not sending to ourself
    // DWORD            dwLocalBackLog;             //
    // DWORD            dwRemoteBackLog;            //
    // DWORD            dwMaxAddressObjects;        // Max CPool Addresses
    // DWORD            dwMaxMailObjects;           // Max CPool Msgs
    // DWORD            dwShouldDelete;             // Should delete messages when delivered
    // DWORD            dwShouldDeliver;            // Should deliver messages when accepted
    // DWORD            dwUseFileLinks;             // 0 = use NTFS file links, 1 = use CopyFile
    // DWORD            dwBatchMsgs;                // 0 = Don't batch msgs, 1 = batch msgs
    // DWORD            dwMaxBatchLimit;            // if dwBatchMsgs == 1, batch this many in a row
    // DWORD            dwSaveBadMail;              // Save bad mail locally - independent of sending to admin
    // DWORD            dwEnableMailPickUp;         // 1 = Pickup from a Dir, 0 = No pickup from a Dir
    // LPWSTR           lpszDeleteDir;              // Dir to move delivered msg to if dwShouldDelete == FALSE
    // LPWSTR           lpszRoutingDll;             // Mail routing DLL
    // LPWSTR           lpszMailQueueDir;           // Local directory to use for the mail queue
    // LPWSTR           lpszMailPickupDir;          // Local Directory for mail pickup
    // LPSMTP_CONFIG_DOMAIN_LIST    DomainList;     // Domain config info - default domain and supported domains

    DWORD           dwReverseLookup;            // Do DNS Reverse lookup?
    DWORD           dwMaxHopCount;              // Max msg hops before NDR
    DWORD           dwMaxRemoteTimeOut;         // Outbound inactivity timeout
    DWORD           dwMaxErrors;                // Max protocol errors before drop conn
    DWORD           dwMaxMsgSizeAccepted;       // Largest msg we'll accept
    DWORD           dwMaxMsgSizeBeforeClose;    // Largest msg we'll wait for before abrupt close
    DWORD           dwMaxRcpts;                 // Max recips per message
    DWORD           dwShouldRetry;              // Should retry delivery
    DWORD           dwMaxRetryAttempts;         // Max # of retry attempts
    DWORD           dwMaxRetryMinutes;          // Minutes between retries
    DWORD           dwNameResolution;           // 0 = DNS, 1 = GetHostByName
    DWORD           dwShouldPipelineOut;        // Pipeline outbound mail?
    DWORD           dwShouldPipelineIn;         // Advertise inbound pipeline support?
    DWORD           dwSmartHostType;            // 0 = Never, 1 = On failed connection, 1 = Always
    DWORD           dwSendNDRCopyToAdmin;       // Send copy of all NDR's to AdminEmail?
    DWORD           dwSendBadMailToAdmin;       // Send bad msgs to AdminEmail?
    DWORD           dwMaxOutboundConnections;   // Maximum outbound connections allowed

    LPWSTR          lpszSmartHostName;          // Smart host server
    LPWSTR          lpszConnectResp;            // Connection response
    LPWSTR          lpszBadMailDir;             // Dir to save bad mail
    LPWSTR          lpszDefaultDomain;          // Default domain

    LPSMTP_CONFIG_ROUTING_LIST  RoutingList;    // Mail routing source information

} SMTP_CONFIG_INFO, *LPSMTP_CONFIG_INFO;

NET_API_STATUS
NET_API_FUNCTION
SmtpGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    DWORD           dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  LPSMTP_CONFIG_INFO      pConfig,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetConnectedUserList(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONN_USER_LIST   *ppConnUserList,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDisconnectUser(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  DWORD                   dwUserId,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpRenameDomain(
    IN  LPWSTR                  wszServerName,
    IN  LPWSTR                  wszOldDomainName,
    IN  LPWSTR                  wszNewDomainName,
    IN  DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetLocalDomains(
    IN  LPWSTR                      wszServerName,
    OUT LPSMTP_CONFIG_DOMAIN_LIST   *ppDomainList,
    IN DWORD                        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpAddLocalDomain(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszLocalDomain,
    IN DWORD        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDelLocalDomain(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszLocalDomain,
    IN DWORD        dwInstance

    );


//
// User config
//

#define FC_SMTP_USER_PROPS_FORWARD          ((FIELD_CONTROL)BitFlag(0))
#define FC_SMTP_USER_PROPS_MAILBOX_SIZE     ((FIELD_CONTROL)BitFlag(1))
#define FC_SMTP_USER_PROPS_VROOT            ((FIELD_CONTROL)BitFlag(2))
#define FC_SMTP_USER_PROPS_LOCAL            ((FIELD_CONTROL)BitFlag(3))
#define FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE ((FIELD_CONTROL)BitFlag(4))

#define FC_SMTP_USER_PROPS_ALL              ( \
                                            FC_SMTP_USER_PROPS_FORWARD | \
                                            FC_SMTP_USER_PROPS_MAILBOX_SIZE | \
                                            FC_SMTP_USER_PROPS_VROOT | \
                                            FC_SMTP_USER_PROPS_LOCAL |\
                                            FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE \
                                            )
#if defined(MIDL_PASS)
#define MIDL(x) x
#else
#define MIDL(x)
#endif

typedef struct _SMTP_USER_PROPS
{
    FIELD_CONTROL   fc;

    LPWSTR          wszForward;
    DWORD           dwMailboxMax;
    LPWSTR          wszVRoot;
    DWORD           dwLocal;
    DWORD           dwMailboxMessageMax;
} SMTP_USER_PROPS, *LPSMTP_USER_PROPS;


NET_API_STATUS
NET_API_FUNCTION
SmtpCreateUser(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszForwardEmail,
    IN DWORD    dwLocal,
    IN DWORD    dwMailboxSize,
    IN DWORD    dwMailboxMessageSize,
    IN LPWSTR   wszVRoot,
    IN DWORD    dwInstance

    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteUser(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    OUT LPSMTP_USER_PROPS *ppUserProps,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN LPSMTP_USER_PROPS pUserProps,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance

    );

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwRowsReq,
    IN  BOOL                    fForward,
    OUT LPSMTP_NAME_LIST        *ppNameList,
    IN DWORD                    dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameListFromList(
    IN  LPWSTR              wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN DWORD            dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpGetVRootSize(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszVRoot,
    IN  LPDWORD     pdwBytes,
    IN DWORD        dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpBackupRoutingTable(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszPath,
    IN DWORD        dwInstance
    );

// ===================================================
// SMTP SDK RPCs
//

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProfileInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPWSTR                  wszEmail,
    IN OUT  LPSSE_USER_PROFILE_INFO lpProfileInfo,
    IN      DWORD                   dwInstance
    );

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProfileInformation(
    IN      LPWSTR                  pszServer OPTIONAL,
    IN      LPWSTR                  wszEmail,
    IN      LPSSE_USER_PROFILE_INFO lpProfileInfo,
    IN      DWORD                   dwInstance
    );



//
// Get Server Statistics
//

NET_API_STATUS
NET_API_FUNCTION
SmtpQueryStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

//
// Clear server statistics
//

NET_API_STATUS
NET_API_FUNCTION
SmtpClearStatistics(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD            dwInstance
    );

//
// Used to free buffers returned by APIs
//

VOID
SmtpFreeBuffer(
    LPVOID Buffer
    );

//
// AQ Admin APIs
//
#include <aqadmtyp.h>

NET_API_STATUS
NET_API_FUNCTION
SmtpAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues);

NET_API_STATUS
NET_API_FUNCTION
SmtpAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs);

#ifdef __cplusplus
}
#endif

#endif _SMTPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\inc\smtpext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpext.h

Abstract:

    SMTP server extension header file. These definitions are available
    to server extension writers.

Author:

    Microsoft Corporation	June, 1996

Revision History:

--*/

#ifndef _SMTPEXT_H_
#define _SMTPEXT_H_


// ====================================================================
// Include files
// 


// ====================================================================
// Version Information
// 

#define SSE_VERSION_MAJOR	1 // Major version
#define SSE_VERSION_MINOR	0 // Minor version
#define SSE_VERSION			MAKELONG( SSE_VERSION_MINOR, SSE_VERSION_MAJOR )


// ====================================================================
// Generic defines
// 

#define SSE_MAX_EXT_DLL_NAME_LEN			256 // Max length of Ext. DLL name
#define SSE_MAX_STRING_LEN_ANY				512 // Max length of any string


// ====================================================================
// Return codes
//

#define SSE_STATUS_SUCCESS                  0
#define SSE_STATUS_RETRY                    1
#define SSE_STATUS_ABORT_DELIVERY           2
#define SSE_STATUS_BAD_MAIL					3


// ====================================================================
// Server support fucntions request codes
//

#define SSE_REQ_GET_USER_PROFILE_INFO			1
#define SSE_REQ_SET_USER_PROFILE_INFO			2


// ====================================================================
// Server extension version data structure
//

typedef struct _SSE_VERSION_INFO
{
    DWORD       dwServerVersion;                // Server version
    DWORD       dwExtensionVersion;             // Extension version
    CHAR        lpszExtensionDesc[SSE_MAX_EXT_DLL_NAME_LEN];    // Description

} SSE_VERSION_INFO;


// ====================================================================
// SMTP Extension Control Block data structure
//

typedef LPVOID	LPSSECTXT;

typedef struct _SSE_EXTENSION_CONTROL_BLOCK
{
	DWORD		cbSize;					// Size of this struct
	DWORD		dwVersion;				// Version of this spec
    LPSSECTXT	lpContext;				// Server context (DO NOT MODIFY)

	LPSTR		lpszSender;				// Name of sender of message
	LPSTR		lpszCurrentRecipient;	// Current recipient being processed

	DWORD		cbTotalBytes;			// Total size of message in bytes
	DWORD		cbAvailable;			// Available number of bytes
	LPBYTE		lpbData;				// Pointer to message data

	LPVOID		lpvReserved;			// Reserved, must be NULL

	// Server callbacks

	BOOL (WINAPI * GetServerVariable)	( LPSSECTXT	lpContext,
										  LPSTR		lpszVeriableName,
										  LPVOID	lpvBuffer,
										  LPDWORD	lpdwSize );

	BOOL (WINAPI * ServerSupportFunction)	( LPSSECTXT	lpContext,
											  DWORD		dwSSERequest,
											  LPVOID	lpvBuffer,
											  LPDWORD	lpdwSize,
											  LPDWORD	lpdwDataType );

} SSE_EXTENSION_CONTROL_BLOCK, *LPSSE_EXTENSION_CONTROL_BLOCK;


// ====================================================================
// Data structures for server support functions
//

typedef struct _SSE_USER_PROFILE_INFO
{
	LPTSTR		lpszExtensionDllName;	// Name of calling DLL
	LPTSTR		lpszKey;				// Key to look for
	LPTSTR		lpszValue;				// Value to set/get
	DWORD		dwSize;					// Buffer size on a get

} SSE_USER_PROFILE_INFO, *LPSSE_USER_PROFILE_INFO;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\wildmat.cpp ===
//---[ wildmat.cpp ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

//
// This stuff is isolated out to simplify unit-testing ...
//

#include "windows.h"
#include "abtype.h"
#include "dbgtrace.h"

static void pStringLower(LPSTR szString, LPSTR szLowerString)
{
	while (*szString)
		*szLowerString++ = (CHAR)tolower(*szString++);
	*szLowerString = '\0';
}

// This stuff is from address.hxx
#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2) // 2 for @ and \0

//
// This is a quick and dirty function to do wildcard matching for email
// names. The match is case-insensitive, and the pattern can be expressed as:
//
// <email pattern>[@<domain pattern>]
//
// The email pattern is expressed as follows:
//
// <email pattern> := { * | [*]<email name>[*] }
//
// Which becomes one of the below:
// *		- Any email name
// foo		- Exact match for "foo"
// *foo		- Any email name ending with "foo", including "foo"
// foo*		- Any email name beginning with "foo", including "foo"
// *foo*	- Any email name that contains the string "foo", including "foo"
//
// If a domain is not specified, the pattern matches against any domain. Both the
// email pattern and the domain pattern (if specified) must be matched for the
// rule to fire. Domain patterns are expressed as:
//
// <domain pattern> := [*][<domain name>]
//
// Which are:
// *		- Any domain
// bar.com	- Exact match for "bar.com"
// *bar.com	- Any domain ending with "bar.com", including "bar.com"
//
// szEmail must be a string to the email alias (clean without comments, etc.)
// szEmailDomain must be a string to the email domain. NULL means no domain
// is specified. The domain must be clean without comments, etc.
//
//
typedef enum _WILDMAT_MODES
{
	WMOD_INVALID = 0,
	WMOD_WILDCARD_LEFT,		// Wildcard on the left
	WMOD_WILDCARD_RIGHT,	// Wildcard on the right
	WMOD_WILDCARD_BOTH,		// Wildcard on both sides
	WMOD_WILDCARD_MAX

} WILDMAT_MODES;

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail)
{
	LPSTR		pszPatternDomain;
	BOOL		fEmailWildMat = FALSE;
	BOOL		fDomainWildMat = FALSE;
	DWORD		wmEmailWildMatMode = WMOD_INVALID;
	DWORD		dwEmailLen = 0, dwDomainLen = 0;
	DWORD		dwEmailStemLen = 0, dwDomainStemLen = 0;
	DWORD		i;
	HRESULT		hrRes = S_OK;
	CHAR		szDomainMat[MAX_INTERNET_NAME + 1];

	TraceFunctEnterEx((LPARAM)NULL, "MatchEmailOrDomainName");

	// This validates that it is a good email name
	lstrcpyn(szDomainMat, szPattern, MAX_INTERNET_NAME + 1);
	szPattern = szDomainMat;
	pszPatternDomain = strchr(szDomainMat, '@');

	// See if we have an email wildcard at the left
	if (*szPattern == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a left wildcard");
		fEmailWildMat = TRUE;
		szPattern++;
		wmEmailWildMatMode = WMOD_WILDCARD_LEFT;
	}

	// Get the domain pointer
	if (szEmailDomain)
	{
		dwEmailLen = (DWORD)(szEmailDomain - szEmail);
		*szEmailDomain++ = '\0';
		dwDomainLen = lstrlen(szEmailDomain);
	}
	else
		dwEmailLen = lstrlen(szEmail);

	// Validate that the lengths of szEmail and szEmailDomain will not
	// overflow our buffers
	if (dwEmailLen > MAX_INTERNET_NAME ||
	    dwDomainLen > MAX_INTERNET_NAME)
	{
	    hrRes = E_INVALIDARG;
	    goto Cleanup;
	}

	if (pszPatternDomain)
	{
		dwEmailStemLen = (DWORD)(pszPatternDomain - szPattern);
		*pszPatternDomain++ = '\0';
		dwDomainStemLen = lstrlen(pszPatternDomain);
		if (*pszPatternDomain == '*')
		{
			fDomainWildMat = TRUE;
			dwDomainStemLen--;
			pszPatternDomain++;
		}
	}
	else
		dwEmailStemLen = lstrlen(szPattern);

	// See if we have an email wildcard at the right
	if (dwEmailStemLen &&
		*(szPattern + dwEmailStemLen - 1) == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a right wildcard");

		szPattern[--dwEmailStemLen] = '\0';
		if (!fEmailWildMat)
		{
			// It has no left wildcard, so it is a right-only wildcard
			fEmailWildMat = TRUE;
			wmEmailWildMatMode = WMOD_WILDCARD_RIGHT;
		}
		else
			wmEmailWildMatMode = WMOD_WILDCARD_BOTH;
	}

	// Make sure there are no more wildcards embedded
	for (i = 0; i < dwEmailStemLen; i++)
		if (szPattern[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}
	for (i = 0; i < dwDomainStemLen; i++)
		if (pszPatternDomain[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}

	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szEmail, szEmailDomain?szEmailDomain:"none");
	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szPattern, pszPatternDomain?pszPatternDomain:"none");

	// OK, now eliminate by length
	if (dwEmailLen < dwEmailStemLen)
	{
		DebugTrace((LPARAM)NULL, "Email too short to match");
		hrRes = S_FALSE;
		goto Cleanup;
	}
	else
	{
		if (fEmailWildMat)
		{
			CHAR	szPatternLower[MAX_INTERNET_NAME + 1];
			CHAR	szEmailLower[MAX_INTERNET_NAME + 1];

			_ASSERT(wmEmailWildMatMode != WMOD_INVALID);
			_ASSERT(wmEmailWildMatMode < WMOD_WILDCARD_MAX);

			// Do the right thing based on the wildcard mode
			switch (wmEmailWildMatMode)
			{
			case WMOD_WILDCARD_LEFT:
				if (lstrcmpi(szPattern, szEmail + (dwEmailLen - dwEmailStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_RIGHT:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) != szEmail)
				{
					DebugTrace((LPARAM)NULL, "Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_BOTH:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) == NULL)
				{
					DebugTrace((LPARAM)NULL, "Left and Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;
			}
		}
		else
		{
			if ((dwEmailLen != dwEmailStemLen) ||
				(lstrcmpi(szPattern, szEmail)))
			{
				DebugTrace((LPARAM)NULL, "Exact email match failed");
				hrRes = S_FALSE;
				goto Cleanup;
			}
		}
	}

	// We are matching the domain pattern
	if (pszPatternDomain)
	{
		if (!szEmailDomain)
		{
			DebugTrace((LPARAM)NULL, "No email domain");
			hrRes = S_FALSE;
			goto Cleanup;
		}

		if (dwDomainLen < dwDomainStemLen)
		{
			DebugTrace((LPARAM)NULL, "Domain too short to match");
			hrRes = S_FALSE;
			goto Cleanup;
		}
		else
		{
			if (fDomainWildMat)
			{
				if (lstrcmpi(pszPatternDomain,
							szEmailDomain + (dwDomainLen - dwDomainStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left domain wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
			else
			{
				if ((dwDomainLen != dwDomainStemLen) ||
					(lstrcmpi(pszPatternDomain, szEmailDomain)))
				{
					DebugTrace((LPARAM)NULL, "Exact domain match failed");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
		}
	}
	else
		hrRes = S_OK;

Cleanup:

	TraceFunctLeaveEx((LPARAM)NULL);
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for 
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail);

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\newwild.cpp ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seodisp.cpp ===
//#define INCL_INETSRV_INCS
//#include "smtpinc.h"

#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>
#include <cpool.h>
#include <address.hxx>
#include <mailmsgprops.h>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>
#include "dbgtrace.h"

#include "imd.h"
#include "mb.hxx"

#include <stdio.h>

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#include "filehc.h"
#include "seo.h"
#include "seolib.h"

#include "smtpdisp_i.c"
#include "mailmsgi.h"
#include <smtpevent.h>
#include "cdo.h"
#include "cdo_i.c"
#include "cdoconstimsg.h"
#include "seomgr.h"

#define MAX_RULE_LENGTH 4096
//
// Message object
//
#define MAILMSG_PROGID          L"Exchange.MailMsg"

#define INITGUID
#include "initguid.h"
#include "smtpguid.h"
#include "wildmat.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "evntwrap.h"

// {0xCD000080,0x8B95,0x11D1,{0x82,0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D}}
DEFINE_GUID(IID_IConstructIMessageFromIMailMsg, 0xCD000080,0x8B95,0x11D1,0x82,
0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D);

extern VOID
ServerEventCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
);

#define SKIPSINK_CALL_NO_MORE_SINKS 0xffffffff

class CStoreCreateOptions : public CEventCreateOptionsBase
{
  public:

    CStoreCreateOptions(    SMTP_ALLOC_PARAMS * pContext)
    {
        _ASSERT (pContext != NULL);

        m_Context = pContext;
    }

  private:

    HRESULT STDMETHODCALLTYPE Init(REFIID iidDesired, IUnknown **ppUnkObject, IEventBinding *, IUnknown *)
    {
        ISMTPStoreDriver *pSink = NULL;
        IUnknown * ThisUnknown = NULL;
        IUnknown * NewUnknown = NULL;
        HRESULT hrRes = S_OK;

        TraceFunctEnterEx((LPARAM)this, "Calling create options");

        ThisUnknown = *ppUnkObject;

        hrRes = ThisUnknown->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
        if (hrRes == E_NOINTERFACE) {
            return (E_NOTIMPL);
        }
        if (FAILED(hrRes))
            return(hrRes);

        DebugTrace((LPARAM)this, "Calling startup events on sinks ...");
        hrRes = pSink->Init(m_Context->m_InstanceId,
                            NULL,
                            (IUnknown *) m_Context->m_EventSmtpServer,
                            m_Context->m_dwStartupType,
                            &NewUnknown);
        pSink->Release();
        if (FAILED(hrRes) && (hrRes != E_NOTIMPL)) {
            return (hrRes);
        }
        if(NewUnknown)
            {
                hrRes = NewUnknown->QueryInterface(iidDesired, (void **)ppUnkObject);
                NewUnknown->Release();
                if (!SUCCEEDED(hrRes)) {
                    return (hrRes);
                }
                ThisUnknown->Release();
            }


        return (E_NOTIMPL);
    };

  public:
    SMTP_ALLOC_PARAMS *     m_Context;

};


CStoreDispatcher::CStoreAllocParams::CStoreAllocParams()
{
    m_hContent = NULL;
}

CStoreDispatcher::CStoreAllocParams::~CStoreAllocParams()
{
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CreateCParams
//
// Synopsis: Based on dwEventType, create the appropriate Params object
//
// Arguments:
//   dwEventType - specifies SMTP event
//   pContext - context to pass into Init function
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  or error from InitParamData
//
// History:
// jstamerj 980610 18:30:20: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CreateCParams(
    DWORD               dwEventType,
    LPVOID              pContext,
    IMailTransportNotify *pINotify,
    REFIID              rGuidEventType,
    CStoreBaseParams    **ppCParams)
{
    _ASSERT(ppCParams);
    HRESULT hr;

    switch(dwEventType) {
     case SMTP_STOREDRV_STARTUP_EVENT:
        if (!SUCCEEDED(GetData(NULL,NULL))) {
            hr = SetData(((SMTP_ALLOC_PARAMS *) pContext)->m_EventSmtpServer,
                         ((SMTP_ALLOC_PARAMS *) pContext)->m_InstanceId);
            _ASSERT(SUCCEEDED(hr));
        }
        // fall through
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
         *ppCParams = new CStoreParams();
         break;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         *ppCParams = new CMailTransportSubmissionParams();
         break;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPreCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
         *ppCParams = new CMailTransportCatRegisterParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
         *ppCParams = new CMailTransportCatBeginParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
         *ppCParams = new CMailTransportCatEndParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
         *ppCParams = new CMailTransportCatBuildQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
         *ppCParams = new CMailTransportCatBuildQueriesParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
         *ppCParams = new CMailTransportCatSendQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
         *ppCParams = new CMailTransportCatSortQueryResultParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
         *ppCParams = new CMailTransportCatProcessItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
         *ppCParams = new CMailTransportCatExpandItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         *ppCParams = new CMailTransportCatCompleteItemParams();
         break;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPostCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         *ppCParams = new CMailTransportRouterParams();
         break;

     case SMTP_MSGTRACKLOG_EVENT:
         *ppCParams = new CMsgTrackLogParams();
         break;

     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         *ppCParams = new CDnsResolverRecordParams();
         break;

     case SMTP_MAXMSGSIZE_EVENT:
         *ppCParams = new CSmtpMaxMsgSizeParams();
         break;

     case SMTP_LOG_EVENT:
     	 *ppCParams = new CSmtpLogParams();
     	 break;

     case SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT:
         *ppCParams = new CSmtpGetAuxDomainInfoFlagsParams();
         break;

     default:
         _ASSERT(0 && "Unknown server event");
         *ppCParams = NULL;
         break;
    }

    if(*ppCParams == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = (*ppCParams)->InitParamData(
        pContext,
        dwEventType,
        pINotify,
        this,
        rGuidEventType);

    if(FAILED(hr)) {
        (*ppCParams)->Release();
        *ppCParams = NULL;
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CStoreBaseParams
//
// Synopsis: Sets member data to pre-initialized values
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:01: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::CStoreBaseParams() :
    m_rguidEventType(CATID_SMTP_STORE_DRIVER)
{
    m_dwSignature = SIGNATURE_VALID_CSTOREPARAMS;

    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;

    m_pINotify = NULL;
    m_pIUnknownSink = NULL;
    m_pDispatcher = NULL;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams
//
// Synopsis: Release the IMailTransportNotify reference if held
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:51: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams()
{
    if(m_pINotify)
        m_pINotify->Release();

    _ASSERT(m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS);
    m_dwSignature = SIGNATURE_INVALID_CSTOREPARAMS;
}


//+------------------------------------------------------------
//
// Function: InitParamData
//
// Synopsis: Initializes object.  This includes calling Init() which
//           is implemented in dervied objects.
//
// Arguments:
//  pContext: Context passed in - specific for server event
//  dwEventType: Specifies which server event we are for
//  pINotify: IMailTransportNotify interface for async completion
//  rguidEventType: guid for event type binding
//
// Returns:
//  S_OK: Success
//  Error from Init()
//
// History:
// jstamerj 980615 19:16:55: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::InitParamData(
    PVOID pContext,
    DWORD dwEventType,
    IMailTransportNotify *pINotify,
    CStoreDispatcher *pDispatcher,
    REFIID rguidEventType)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreBaseParams::InitParamData");
    HRESULT hr;

    m_dwEventType = dwEventType;
    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;
    m_pINotify = pINotify;
    m_pINotify->AddRef();
    m_rguidEventType = rguidEventType;
    m_pDispatcher = pDispatcher;

    hr = Init(pContext);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Init() failed, hr = %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CallObject
//
// Synopsis: Called by the dispatcher when time to call a sink.  This
// implements some default functionality -- create the sink with a
// null CCreateOptions
//
// Arguments:
//   IEventManager
//   CBinding
//
// Returns:
//  S_OK: Success
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/06/23 13:53:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule
//
// Synopsis: Determines if a mailmsg string rule passes or fails given
//           the mailmsg and the CBinding object
//
// Arguments:
//  pBinding: CBinding object for this sink
//  pMsgProps: IMailMsgProperteries of the message to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//
// History:
// jstamerj 1999/01/11 17:04:01: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule(
    CBinding *pBinding,
    IMailMsgProperties *pIMsgProps)
{
    HRESULT hr;
    BOOL    fDomainLoaded = FALSE;
    BOOL    fSenderLoaded = FALSE;
    CHAR    szDomain[MAX_INTERNET_NAME + 2];
    CHAR    szSender[MAX_INTERNET_NAME + 2];
    LPSTR   szRule;
    CStoreBinding *pStoreBinding = (CStoreBinding *)pBinding;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule");

    _ASSERT(pStoreBinding);
    _ASSERT(pIMsgProps);

    // Get the cached rule from the binding
    szRule = pStoreBinding->GetRuleString();
    DebugTrace((LPARAM)this, "Rule string: %s", (szRule)?szRule:"NULL (No rule)");

    // If the rule is NULL, we will don't have a rule
    // string and we will return a match
    if (!szRule)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return(S_OK);
    }

    // try each comma delimited rule in the header patterns list
    char *pszHeader = (char *) _alloca(lstrlen(szRule)+1);
    if (!pszHeader) {
        return (E_OUTOFMEMORY);
    }
    lstrcpy(pszHeader,szRule);
    while (pszHeader != NULL && *pszHeader != 0)
    {
        // find the next semicolon in the string and turn it into a 0
        // if it exists
        char *pszSemiColon = strchr(pszHeader, ';');
        if (pszSemiColon != NULL)
            *pszSemiColon = 0;

        // set pszContents to point to the text which must be matched
        // in the header.  if pszContents == NULL then just having
        // the header exist is good enough.
        char *pszPatterns = strchr(pszHeader, '=');
        if (pszPatterns != NULL)
        {
            *pszPatterns = 0;
            (pszPatterns++);
        }

        // we now have the header that we are looking for in
        // pszHeader and the list of patterns that we are interested
        // in pszPatterns.  Make the lookup into the header
        // data structure
        hr = S_FALSE;

        DebugTrace((LPARAM)this, "Processing Header <%s> with pattern <%s>",
                        pszHeader, pszPatterns);
        if (!lstrcmpi(pszHeader, "EHLO")) {

            // Process a client domain rule ...
            if (!fDomainLoaded) {
                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_HELO_DOMAIN,
                    sizeof(szDomain),
                    szDomain);

                if (hr == S_OK) {

                    fDomainLoaded = TRUE;
                }
            }
            if (fDomainLoaded) {
                hr = MatchEmailOrDomainName(szDomain, pszPatterns, FALSE);
            }
        } else if (!lstrcmpi(pszHeader, "MAIL FROM")) {

            // Process a sender name rule ...
            if (!fSenderLoaded) {

                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_SENDER_ADDRESS_SMTP,
                    sizeof(szSender),
                    szSender);

                if (hr == S_OK)
                {
                    fSenderLoaded = TRUE;
                }
            }
            if (fSenderLoaded) {
                hr = MatchEmailOrDomainName(szSender, pszPatterns, TRUE);
            }
        }
        else if (!lstrcmpi(pszHeader, "RCPT TO"))
        {
            hr = CheckMailMsgRecipientsRule(
                pIMsgProps,
                pszPatterns);
        }

        // We don't want to destroy the rule string so we restore all the
        // semicolons and equal signs
        if (pszSemiColon)
            *pszSemiColon = ';';
        if (pszPatterns)
            *(pszPatterns - 1) = '=';

        // Exit immediately if we found a match!
        if (hr == S_OK)
            goto Cleanup;

        // the next pattern is the one past the end of the semicolon
        pszHeader = (pszSemiColon == NULL) ? NULL : pszSemiColon + 1;
    }

Cleanup:
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule
//
// Synopsis: Determines if a mailmsg pattern string matches mailmsg
//           recipients or not
//
// Arguments:
//  pIMsg: An interface to a mailmsg object
//  pszPatterns: The sink rule to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//  error from mailmsg
//
// History:
// jstamerj 1999/01/12 15:25:55: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule(
    IUnknown *pIMsg,
    LPSTR pszPattern)
{
    HRESULT hr;
    DWORD dwNumRecips;
    IMailMsgRecipients *pIRecips = NULL;
    BOOL fMatch = FALSE;
    DWORD dwCount;
    CHAR szRecip [MAX_INTERNET_NAME + 2];

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule");

    hr = pIMsg->QueryInterface(
        IID_IMailMsgRecipients,
        (LPVOID *)&pIRecips);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRecips->Count(&dwNumRecips);
    if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Checking rule \"%s\" for %d recipients",
               pszPattern, pIMsg);

    for(dwCount = 0;
        (fMatch == FALSE) && (dwCount < dwNumRecips);
        dwCount++) {

        hr = pIRecips->GetStringA(
            dwCount,
            IMMPID_RP_ADDRESS_SMTP,
            sizeof(szRecip),
            szRecip);

        if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
            goto CLEANUP;

        if(hr != MAILMSG_E_PROPNOTFOUND) {
            hr = MatchEmailOrDomainName(szRecip,pszPattern,TRUE);
            if(hr == S_OK)
                fMatch = TRUE;
            else if(FAILED(hr))
                goto CLEANUP;
        }
    }
    hr = (fMatch) ? S_OK : S_FALSE;

 CLEANUP:
    if(pIRecips)
        pIRecips->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseparams::MatchEmailOrDomainName
//
// Synopsis: Given an email/domain name and a pattern, determine if
// the pattern matches or not
//
// Arguments:
//  szEmail: The email address or domain name
//  szPattern: The pattern to check
//  fIsEmail: TRUE if szEmail is an email address, FALSE if szEmail is
//  a domain
//
// Returns:
//  S_OK: Success, match
//  S_FALSE: Success, no match
//  E_INVALIDARG
//
// History:
// jstamerj 1999/01/12 15:25:36: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName(
    LPSTR szEmail,
    LPSTR szPattern,
    BOOL fIsEmail)
{
    CAddr       *pEmailAddress = NULL;
    LPSTR       szEmailDomain = NULL;
    HRESULT     hrRes;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName");

    DebugTrace((LPARAM)NULL, "Matching <%s> against <%s>", szEmail, szPattern);

    if (!szEmail || !szPattern)
        return(E_INVALIDARG);

    // This validates that it is a good email name
    pEmailAddress = CAddr::CreateAddress(szEmail, fIsEmail?FROMADDR:CLEANDOMAIN);
    if (!pEmailAddress)
        return(E_INVALIDARG);

    szEmail = pEmailAddress->GetAddress();
    szEmailDomain = pEmailAddress->GetDomainOffset();

    hrRes = ::MatchEmailOrDomainName(szEmail, szEmailDomain, szPattern, fIsEmail);

    // Free the CAddr objects ...
    if (pEmailAddress)
        delete pEmailAddress;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}



CStoreDispatcher::CStoreBinding::CStoreBinding()
{
    m_szRule = NULL;
}

CStoreDispatcher::CStoreBinding::~CStoreBinding()
{
    if(m_szRule)
        delete [] m_szRule;
}

//
// initialize a new binding.  we cache information from the binding database
// here
// jstamerj 1999/01/12 16:25:59: Copied MCIS2 code to get the rule string
//
HRESULT CStoreDispatcher::CStoreBinding::Init(IEventBinding *piBinding)
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr))
        return hr;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr))
        return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr))
        return hr;

    // Process the rule string, the result code is not important
    // since it will NULL our the string
    if (hr == S_OK)
        hr = GetAnsiStringFromVariant(vRule, &m_szRule);

    return hr;
}

HRESULT CStoreDispatcher::CStoreBinding::GetAnsiStringFromVariant(
    CComVariant &vString, LPSTR *ppszString)
{
    HRESULT hr = S_OK;

    _ASSERT(ppszString);

    if (!ppszString)
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));

    // Default to NULL
    *ppszString = NULL;

    if (vString.vt == VT_BSTR)
        {
            DWORD dwLength = lstrlenW(vString.bstrVal) + 1;

            // Convert to an ANSI string and store it as a member
            *ppszString = new char[dwLength];
            if (!*ppszString)
                return HRESULT_FROM_WIN32(GetLastError());

            // copy the rule into an ascii string
            if (WideCharToMultiByte(CP_ACP, 0, vString.bstrVal,
                                    -1, (*ppszString), dwLength, NULL, NULL) <= 0)
                {
                    delete [] (*ppszString);
                    *ppszString = NULL;
                    return HRESULT_FROM_WIN32(GetLastError());
                }
        }
    else
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return(hr);
}

#if 1
//
// create and call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(IEventManager *pManager, CBinding& bBinding)
{
    CStoreCreateOptions opt (m_pContext);
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}
#endif

//
// call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    HRESULT hrTmp = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CServerParams::CallObject");

    // We do this for different types of SMTP events
    switch (m_dwEventType)
        {
         case SMTP_STOREDRV_STARTUP_EVENT:
             break;
         case SMTP_STOREDRV_ALLOC_EVENT:
         {
             IMailMsgStoreDriver *pSink = NULL;
             IMailMsgProperties *   pMsg = (IMailMsgProperties *)m_pContext->IMsgPtr;
             IMailMsgBind         *pBindInterface = NULL;
             IMailMsgPropertyStream  *pStream = NULL;
             PATQ_CONTEXT           pAtqFileContext = NULL;

             DebugTrace((LPARAM)this, "Calling bind on sinks ...");

             /*IID_ISMTPStoreDriver*/
             hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             // Allocate a new message
             hrRes = pSink->AllocMessage(pMsg, NULL, &pStream, &m_pContext->hContent, NULL);
             if(!FAILED(hrRes))
             {
                     pBindInterface = (IMailMsgBind *)m_pContext->BindInterfacePtr;

#if 0
                     hrRes = pBindInterface->BindToStore(pStream, pSink, m_pContext->hContent,
                                                         m_pContext->pAtqClientContext, ServerEventCompletion,
                                                         INFINITE,
                                                         &m_pContext->pAtqContext,
                                                         AtqAddAsyncHandle,
                                                         AtqFreeContext);
#endif
                     hrRes = pBindInterface->BindToStore(pStream,
                                                         pSink,
                                                         m_pContext->hContent);
                     if (pStream)
                     {
                         pStream->Release();
                         pStream = NULL;
                     }

                     m_pContext->hr = hrRes;
                     if(FAILED(hrRes))
                     {
                            ErrorTrace((LPARAM)this, "pBindAtqInterface->BindToStore failed with %x", hrRes);

                            // Close the content handle
                            HRESULT myRes = pSink->CloseContentFile(
                                        pMsg,
                                        m_pContext->hContent);
                            if (FAILED(myRes))
                            {
                                FatalTrace((LPARAM)this, "Unable to close content file (%08x)", myRes);
                                _ASSERT(FALSE);
                            }

                            m_pContext->hContent = NULL;

                            hrTmp = pSink->Delete(pMsg, NULL);
                            _ASSERT(SUCCEEDED(hrTmp));

                     }
                     else
                     {
                            //Skip all sinks - temporary
                            hrRes = S_FALSE;
                     }

             }
             else
             {
                DebugTrace((LPARAM)this, "pSink->AllocMessage failed with %x", hrRes);
                m_pContext->hr = hrRes;
             }

             pSink->Release();
         }
         break;
         case SMTP_STOREDRV_DELIVERY_EVENT:
         {
             ISMTPStoreDriver *pSink;
             IMailMsgNotify *pNotify;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             // if the caller has async notify support then pass in our
             // notification class.  
             if (m_pContext->m_pNotify) {
                // the sink might return async, so we need to keep local
                // copies of our context data
                hrRes = this->CopyContext();
                if (FAILED(hrRes))
                    return hrRes;

                hrRes = this->QueryInterface(IID_IMailMsgNotify, 
                                             (LPVOID *) &pNotify);
                if (FAILED(hrRes))
                    return hrRes;
             } else {
                pNotify = NULL;
             }

             //
             // Remember the sink so we can release this sink later if it
             // returns pending
             //
             _ASSERT(m_pIUnknownSink == NULL);
             m_pIUnknownSink = (IUnknown*)pSink;
             m_pIUnknownSink->AddRef();

             DebugTrace((LPARAM)this, "Calling local delivery sink sink ...");
             hrRes = pSink->LocalDelivery(
                (IMailMsgProperties *) m_pContext->IMsgPtr, 
                m_pContext->m_RecipientCount, 
                m_pContext->pdwRecipIndexes, 
                (IMailMsgNotify *) pNotify);
             pSink->Release();
             if(hrRes != MAILTRANSPORT_S_PENDING) {
                 //
                 // We completed synchronously, so release the sink
                 //
                 m_pIUnknownSink->Release();
                 m_pIUnknownSink = NULL;
             }
             // if LocalDelivery was going to do an async return then it
             // should have AddRef'd pNotify
             if (pNotify) pNotify->Release();

             //
             // jstamerj 1998/08/04 17:31:07:
             //   If the store driver sink returns this specific error
             //   code, we want to stop calling sinks and return from
             //   TriggerLocalDelivery
             //
             if(hrRes == STOREDRV_E_RETRY) {

                 DebugTrace((LPARAM)this, "Sink returned STOREDRV_E_RETRY on LocalDelivery");
                 m_pContext->hr = hrRes;
                 hrRes = S_FALSE;
             }

         }
         break;
         case SMTP_MAIL_DROP_EVENT:
             // ISMTPStoreDriver *pSink;

             // hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             // if (FAILED(hrRes))
             // return(hrRes);

             // DebugTrace((LPARAM)this, "Calling mail drop sink ...");
             // hrRes = pSink->DirectoryDrop((IMailMsgProperties *) m_pContext->IMsgPtr, m_pContext->m_RecipientCount, m_pContext->pdwRecipIndexes, m_pContext->m_DropDirectory, NULL);
             // pSink->Release();
             //}
             break;
         case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling prepare to shutdown on sinks ...");
             hrRes = pSink->PrepareForShutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;
         case SMTP_STOREDRV_SHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling shutdown on sinks ...");
             hrRes = pSink->Shutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         case SMTP_STOREDRV_ENUMMESS_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling Enumerate on sinks ...");
             hrRes = pSink->EnumerateAndSubmitMessages(NULL);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         default:
             DebugTrace((LPARAM)this, "Invalid sink interface");
             hrRes = E_NOINTERFACE;
        }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreParams::CallDefault
//
// Synopsis: CStoreDispatcher::Dispatcher will call this routine when
//           the default sink priority has been reached.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980611 14:19:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreParams::CallDefault()
{
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CStoreDriver::CStoreParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreParams::CallCompletion(HRESULT hrStatus) {
    // call the caller's completion method if there is one
    IMailMsgNotify *pNotify = (IMailMsgNotify *) (m_pContext->m_pNotify);
    if (pNotify) {
        pNotify->Notify(m_pContext->hr);
        pNotify->Release();
    }

    // do the normal call completion work
    CStoreBaseParams::CallCompletion(hrStatus);

    return S_OK;
}


//
// call the child object
//
HRESULT CStoreDispatcher::CStoreAllocParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

#if 0
    IMailMsgStoreDriver   *pStoreDriver = NULL;
    IMailMsgProperties    *pMsg         = NULL;
    IMailMsgPropertyStream  *pStream    = NULL;
    IMailMsgBindATQ       *pBindInterface = NULL;
    CLSID                 clsidMailMsg;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreAllocParams::CallObject");

    hrRes = CLSIDFromProgID(MAILMSG_PROGID, &clsidMailMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    // Create a new MailMsg
    hrRes = CoCreateInstance(
        clsidMailMsg,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMailMsgProperties,
        (LPVOID *)&pMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pStoreDriver);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    // Allocate a new message
    hrRes = pStoreDriver->AllocMessage(
        pMsg,
        NULL,
        &pStream,
        &m_hContent,
        NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "pDriver->AllocMessage failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pMsg->QueryInterface(IID_IMailMsgBindATQ, (void **)&pBindInterface);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pBindInterface->SetATQInfo (NULL, NULL, NULL, INFINITE, NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
goto Exit;
    }


Exit:

    if(pStoreDriver)
    {
        pStoreDriver->Release();
    }

    if(pMsg)
    {
        pMsg->Release();
    }

    if(pBindInterface)
    {
        pBindInterface->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
#endif

    return(hrRes);
}

#if 0
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(REFIID  iidEvent,
                                                    DWORD   dwEventType,
                                                    LPVOID  pvContext)
{
    HRESULT hr = S_OK;

    // create the params object, and pass it into the dispatcher
    CStoreParams ServerParams;
    ServerParams.Init(dwEventType, pvContext);
    hr = Dispatcher(iidEvent, &ServerParams);

    return hr;
}
#endif


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::OnEvent
//
// Synopsis: Prepares for server event
//
// Arguments:
//   iidEvent: guid for event
//   dwEventType: specifies the event
//   pvContext: context for the params object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 13:27:55: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(
    REFIID  iidEvent,
    DWORD   dwEventType,
    LPVOID  pvContext)
{
    HRESULT hr;

    IMailTransportNotify *pINotify = NULL;
    //
    // Call into ATL internals to get the interface we need to pass out
    //
    hr = _InternalQueryInterface(
        IID_IMailTransportNotify,
        (LPVOID *)&pINotify);

    if(FAILED(hr))
        return hr;

    //
    // create the CParams object on the heap -- the object will be
    // needed after this call may be out of here (when a sink returns
    // MAILTRANSPORT_S_PENDING and there are more sinks to call)
    //
    CStoreBaseParams *pCParams;

    hr = CreateCParams(
        dwEventType,
        pvContext,
        pINotify,
        iidEvent,
        &pCParams);

    //
    // The params object should addref pINotify
    //
    pINotify->Release();

    if(FAILED(hr))
        return hr;

    //
    // Start calling sinks
    //
    hr = Dispatcher(iidEvent, pCParams);
    return hr;
}


//+------------------------------------------------------------
//
// Function: GuidForEvent
//
// Synopsis: Given dwEventType, return the appropriate GUID for the
//           event binding
//
// Arguments:
//   dwEventType: type of SMTP event
//
// Returns:
//   REFIID of GUID for the event
//
// History:
// jstamerj 980610 18:24:24: Created.
//
//-------------------------------------------------------------
REFIID GuidForEvent(DWORD dwEventType)
{
    switch(dwEventType) {
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_STARTUP_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
     default:
         return CATID_SMTP_STORE_DRIVER;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         return CATID_SMTP_TRANSPORT_SUBMISSION;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_PRECATEGORIZE;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         return CATID_SMTP_TRANSPORT_CATEGORIZE;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_POSTCATEGORIZE;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         return CATID_SMTP_TRANSPORT_ROUTER;
     case SMTP_MSGTRACKLOG_EVENT:
         return CATID_SMTP_MSGTRACKLOG;
     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         return CATID_SMTP_DNSRESOLVERRECORDSINK;
     case SMTP_MAXMSGSIZE_EVENT:
         return CATID_SMTP_MAXMSGSIZE;
     case SMTP_LOG_EVENT:
         return CATID_SMTP_LOG;
     case SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT:
        return CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS;
    }
}

//
// this function performs instance level server events registration
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // see if this source is registered with the list of sources for the
    // SMTP source type
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
    if (FAILED(hr))
        return hr;
    //
    // if the source guid doesn't exist then we need to register a new
    // source for the SMTP source type and add directory drop as a binding
    //
    if (hr == S_FALSE)
    {
        // register the SMTPSvc source
        hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
        if (FAILED(hr))
            return hr;

        char szSourceDisplayName[50];
        _snprintf(szSourceDisplayName, 50, "smtpsvc %lu", dwInstanceID);
        CComBSTR bstrSourceDisplayName = szSourceDisplayName;
        hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
        if (FAILED(hr))
            return hr;

        // create the event database for this source
        CComPtr<IEventDatabaseManager> pDatabaseManager;
        hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL,
                              IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
        if (hr != S_OK)
            return hr;

        CComBSTR bstrEventPath;
        CComBSTR bstrService = "smtpsvc";
        hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
        if (FAILED(hr))
            return hr;

        CComPtr<IUnknown> pDatabaseMoniker;
        hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        // save everything we've done so far
        hr = pEventSource->Save();
        if (FAILED(hr))
            return hr;

        hr = pSourceType->Save();
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr = S_OK;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // remove this source from the list of registered sources
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
    if (FAILED(hr))
        return hr;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Dispatcher
//
// Synopsis: Override the default functionality in seolib.cpp to
//           provide some extra features (default functionality
//
// Arguments:
//   rguidEventType: Guid specifying a server event
//   pParams: CStoreBaseParams -- contains async info
//
// Returns:
//  S_OK: Success, at least one sink called
//  S_FALSE: No sinks were called
//  otherwise error from CallObject
//
// History:
// jstamerj 980603 19:23:06: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Dispatcher(
    REFIID rguidEventType,
    CStoreBaseParams *pParams)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Dispatcher");
    _ASSERT(pParams);

    //
    // This code based on %STAXPT%\src\core\seo\lib\seolib.cpp
    //
    HRESULT hrRes = S_OK;
    CETData *petdData;
    BOOL bObjectCalled = (pParams->m_dwIdx_SinkSkip > 0);

    //
    // AddRef pParams here, release at the end of the function
    // This way, if a sink returns MAILTRANSPORT_S_PENDING and does
    // async completion before this function exits, we wont AV
    // accessing pParams
    //
    pParams->AddRef();

    petdData = m_Data.Find(rguidEventType);
    if (pParams->m_dwIdx_SinkSkip != SKIPSINK_CALL_NO_MORE_SINKS) {
        if(petdData) {
            for(DWORD dwIdx = pParams->m_dwIdx_SinkSkip;
                dwIdx < petdData->Count();
                dwIdx++) {
                if(!petdData->Index(dwIdx)->m_bIsValid) {
                    continue;
                }
                if(bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
                    continue;
                }
                if(pParams->Abort() == S_OK) {
                    break;
                }
                //
                // Call default processing method if the priority of the sink
                // we're looking at is less than default priority
                //
                if((pParams->m_fDefaultProcessingCalled == FALSE) &&
                   (petdData->Index(dwIdx)->m_dwPriority >
                    SMTP_TRANSPORT_DEFAULT_PRIORITY)) {

                    // This is needed so we don't call the default
                    // processing again if the default processing returns
                    // MAILTRANSPORT_S_PENDING (and we reenter Dispatcher)
                    pParams->m_fDefaultProcessingCalled = TRUE;

                    //
                    // Set the correct index in our async structure -- our
                    // current index.
                    //
                    pParams->m_dwIdx_SinkSkip = dwIdx;
                    hrRes = pParams->CallDefault();

                    if((hrRes == MAILTRANSPORT_S_PENDING) ||
                       (hrRes == S_FALSE)) {
                        break;
                    }
                }

                //
                // Now proceed with calling a real sink
                //
                hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
                if(hrRes == S_OK) {
                    if(pParams->Abort() == S_OK) {
                        break;
                    }
                    //
                    // jstamerj 980603 19:37:17: Set the correct index in our
                    // async structure -- this index plus one to skip the
                    // sink we are about to call
                    //
                    pParams->m_dwIdx_SinkSkip = dwIdx+1;
                    hrRes = pParams->CallObject(
                        m_piEventManager,
                        *petdData->Index(dwIdx));

                    if(!SUCCEEDED(hrRes)) {
                        continue;
                    }
                    bObjectCalled = TRUE;
                    if((hrRes == MAILTRANSPORT_S_PENDING) ||
                       (hrRes == S_FALSE) ||
                       (petdData->Index(dwIdx)->m_bExclusive)) {
                        break;
                    }
                }
            }
        }

        //
        // It is possible we haven't called our default processing sink
        // yet.  Check for this case here.  Make sure that a sink above in
        // the loop isn't indicating async completion or skip (PENDING or
        // S_FALSE)
        //
        if((pParams->m_fDefaultProcessingCalled == FALSE) &&
           (hrRes != MAILTRANSPORT_S_PENDING) &&
           (hrRes != S_FALSE)) {

            // Make sure we don't call default again on async completion...
            pParams->m_fDefaultProcessingCalled = TRUE;

            //
            // Set the index in our async structure so we don't reenter
            // the above loop on async completion
            //
            pParams->m_dwIdx_SinkSkip = (petdData ? petdData->Count() : 0);

            hrRes = pParams->CallDefault();
        }
    } else {
        // bObjectCalled should always be set if SKIPSINK_CALL_NO_MORE_SINKS
        // was set
        _ASSERT(bObjectCalled);
    }

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // It is time to call the completion processing
        //
        hrRes = pParams->CallCompletion(bObjectCalled ? S_OK : S_FALSE);
        if(FAILED(hrRes)) {
            goto CLEANUP;
        }
        hrRes = (bObjectCalled) ? S_OK : S_FALSE;
    }
 CLEANUP:
    pParams->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Notify
//
// Synopsis: Handles async completions of sinks
//
// Arguments: pvContext - context passed into sink
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG:
//
// History:
// jstamerj 980608 15:50:57: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Notify(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Notify");

    _ASSERT(pvContext);
    if((pvContext == NULL) ||
       IsBadReadPtr(
           pvContext,
           sizeof(CStoreBaseParams))) {
        ErrorTrace((LPARAM)this, "Sink called Notify with bogus pvContext");
        return E_INVALIDARG;
    }

    CStoreBaseParams *pParams = (CStoreBaseParams *)pvContext;

    if(FAILED(pParams->CheckSignature())) {
        ErrorTrace((LPARAM)this, "Sink called Notify with invalid pvContext");
        return E_INVALIDARG;
    }
    //
    // Release the sink that called us
    // m_pIUnknownSink could be NULL if default processing returned pending
    //
    if(pParams->m_pIUnknownSink) {
        pParams->m_pIUnknownSink->Release();
        pParams->m_pIUnknownSink = NULL;
    }

    if (hrStatus == S_FALSE) {
        // prevent the dispatcher from calling any more sinks.
        pParams->m_dwIdx_SinkSkip = SKIPSINK_CALL_NO_MORE_SINKS;
    }
    Dispatcher(pParams->m_rguidEventType, pParams);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::Notify
//
// Synopsis: Handles async completions of sinks using mailmsg notify
//
// Arguments: hrStatus - hresult from async operation
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG:
//
// History:
// jstamerj 980608 15:50:57: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::CStoreParams::Notify(
    HRESULT hrStatus)
{
    TraceFunctEnter("CStoreDispatcher::CStoreBaseParams::Notify");

    //
    // Release the sink that called us
    // m_pIUnknownSink could be NULL if default processing returned pending
    //
    if(m_pIUnknownSink) {
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    // this guy can either be STOREDRV_E_RETRY or S_OK.  If he was ever
    // set to STOREDRV_E_RETRY then we shouldn't be getting back to this
    // point in the code because we never would have called another sink
    _ASSERT(m_pContext->hr == S_OK);

    if (hrStatus == STOREDRV_E_RETRY) {
        DebugTrace((LPARAM)this, "Sink returned STOREDRV_E_RETRY on LocalDelivery");
        m_pContext->hr = hrStatus;
        hrStatus = S_FALSE;
    } 

    if (hrStatus == S_FALSE) {
        // prevent the dispatcher from calling any more sinks.
        m_dwIdx_SinkSkip = SKIPSINK_CALL_NO_MORE_SINKS;
    }

    m_pDispatcher->Dispatcher(m_rguidEventType, this);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//
// CMailTransportSubmissionParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    IMailTransportSubmission *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportSubmission,
                                       (PVOID *)&pSink);

    if(hrRes == E_NOINTERFACE) {
        //
        // See if we can get the interfaces we need for a CDO sink
        //
        hrRes = CallCDOSink(punkObject);
        //
        // Success or failure, return here
        //
        TraceFunctLeaveEx((LPARAM)this);
        return hrRes;
    } else if(FAILED(hrRes)) {
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessageSubmission(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink
//
// Synopsis: Call the CDO Sink
//
// Arguments:
//  pSink: IUnknown of the sink
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 10:31:47: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink(
    IUnknown *pSink)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink");
    _ASSERT(pSink);

    HRESULT hr;
    ISMTPOnArrival *pCDOSink = NULL;
    IConstructIMessageFromIMailMsg *pIConstruct = NULL;
    CdoEventStatus eStatus = cdoRunNextSink;

    hr = pSink->QueryInterface(IID_ISMTPOnArrival,
                               (PVOID *)&pCDOSink);
    if(FAILED(hr))
        goto CLEANUP;

    if(m_pCDOMessage == NULL) {
        //
        // Yay.  Create a CDO message
        //
        hr = CoCreateInstance(
            CLSID_Message,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMessage,
            (LPVOID *)&m_pCDOMessage);
        if(FAILED(hr))
            goto CLEANUP;

        //
        // Fill in properties based on MailMsg
        //
        hr = m_pCDOMessage->QueryInterface(
            IID_IConstructIMessageFromIMailMsg,
            (LPVOID *)&pIConstruct);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }

        hr = pIConstruct->Construct(
            cdoSMTPOnArrival,
            m_Context.pIMailMsgProperties);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }
    }

    //
    // Call the sink
    //
    hr = pCDOSink->OnArrival(
        m_pCDOMessage,
        &eStatus);

 CLEANUP:
    //
    // Release interfaces
    //
    if(pIConstruct)
        pIConstruct->Release();
    if(pCDOSink)
        pCDOSink->Release();

    DebugTrace((LPARAM)this, "CallCDOSink returning hr %08lx eStatus %d", hr, eStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return FAILED(hr) ? hr :
        ((eStatus == cdoSkipRemainingSinks) ? S_FALSE : S_OK);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportSubmissionParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:55:29: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportSubmissionParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPreCategorizeParams:
//


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);

    IMailTransportOnPreCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPreCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling precategorize event on this sink");

    hrRes = pSink->OnSyncMessagePreCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPreCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:59:59: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPostCategorizeParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);

    IMailTransportOnPostCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPostCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessagePostCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPostCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 17:01:40: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CRouterCreateOptions::Init
//
// Synopsis: This is called right after we CoCreate any routing sink
// -- so call routing's initialize function (RegisterRouterReset)
//
// Arguments:
//  iidDesired: not used
//  ppUnkObject: IUnknown of newly created sink object
//  IEventBinding: not used
//  IUnknown: not used
//
// Returns:
//  E_NOTIMPL: Success, please do the regular Init thing
//  otherwise error from QI or sink function
//
// History:
// jstamerj 1998/07/10 18:09:04: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::CRouterCreateOptions::Init(
    REFIID iidDesired,
    IUnknown **ppUnkObject,
    IEventBinding *,
    IUnknown *)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CRouterCreateOptions::Init");

    IMailTransportSetRouterReset *pSink = NULL;
    HRESULT hr;

    hr = (*ppUnkObject)->QueryInterface(
        IID_IMailTransportSetRouterReset,
        (PVOID *)&pSink);
    if(hr == E_NOINTERFACE) {
        //
        // It's okay; this sink just doesn't care about hooking
        // the router reset interface
        //
        DebugTrace((LPARAM)this, "Router sink doesn't support IMailTransportSetRouterReset");
        TraceFunctLeaveEx((LPARAM)this);
        return E_NOTIMPL;

    } else if(FAILED(hr)) {
        ErrorTrace((LPARAM)this,
                   "QI for IMailTransportSetRouterReset failed with hr %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    DebugTrace((LPARAM)this, "Calling RegisterRouterReset event onSink");
    hr = pSink->RegisterResetInterface(
        m_pContext->dwVirtualServerID,
        m_pContext->pIRouterReset);

    pSink->Release();

    if(FAILED(hr) && (hr != E_NOTIMPL)) {
        //
        // A real failure occured
        //
        ErrorTrace((LPARAM)this, "RegisterResetInterface failed with hr %08lx", hr);
        return hr;
    }
    //
    // Return E_NOTIMPL so the real work of Init will be done
    //
    return E_NOTIMPL;
}

//
// CMailTransportRoutingParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams::CallObject
//
// Synopsis: Creates (if necessary) and calls the sink object
//
// Arguments:
//  pManager: IEventManager passed in from dispatcher
//  bBinding: CBinding for this event
//
// Returns:
//  S_OK: Success
//  E_POINTER: bad pManager
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/07/10 18:15:09: Created.
//
//-------------------------------------------------------------
//
// create and call the child object
//
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    CRouterCreateOptions opt (m_pContext);
    CComPtr<IUnknown> pUnkSink;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRotuerParams::CallObject");

    if (pManager == NULL) {
        ErrorTrace((LPARAM)this, "Invalid (NULL) pManager");
        TraceFunctLeaveEx((LPARAM)this);
        return (E_POINTER);
    }

    hr = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (FAILED(hr)) {
        ErrorTrace((LPARAM)this, "CreateSink returned error hr %08lx",
                   hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }
    hr = CallObject(bBinding,pUnkSink);
    DebugTrace((LPARAM)this, "CallObject child returned error %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRoutingParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  Error from QI or return code from sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportRoutingEngine *pSink;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    //
    // If they pass in a pIMailMsgProperties of NULL it means that they
    // just want to create a router object, but not actually do the
    // get message router call.
    //
    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    hrRes = punkObject->QueryInterface(IID_IMailTransportRoutingEngine,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on this sink");

    hrRes = pSink->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &(pIMessageRouterNew));

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // We are done with pSink so release it
    //
    pSink->Release();

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one and save the new one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    DebugTrace((LPARAM)this, "Sink GetMessageRouter returned hr %08lx", hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallDefault()
{
    HRESULT hrRes;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallDefault");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    //
    // Call the default IMailTransportRoutingEngine (CatMsgQueue)
    // just like any other sink except SEO didn't CoCreate it for us
    //

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on default sink");

    hrRes = m_pContext->pIRoutingEngineDefault->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &pIMessageRouterNew);

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    TraceFunctLeaveEx((LPARAM)this);

    DebugTrace((LPARAM)this, "Default processing returned hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    IMsgTrackLog *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_IMsgTrackLog, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncLogMsgTrackInfo(
                    m_pContext->pIServer,
                    m_pContext->pIMailMsgProperties,
                    m_pContext->pMsgTrackInfo );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    HRESULT hr = S_OK;
    IDnsInfoSink *pAdvancedSink = NULL;
    IDnsResolverRecordSink *pSink = NULL;

    hr = punkObject->QueryInterface(IID_IDnsInfoSink, (void **)&pAdvancedSink);
    if(hr == S_OK)
    {
        //
        // Use the advanced interface. This extends the functionality
        // of OnSyncGetDnsResolverRecord by adding the option for the
        // sink to return ppDnsServerInfo.
        //

        hr = pAdvancedSink->OnSyncGetDnsInfo(
                                m_pContext->pszHostName,
                                m_pContext->pszFQDN,
                                m_pContext->dwVirtualServerId,
                                m_pContext->ppDnsServerInfo,
                                m_pContext->ppIDnsResolverRecord);


        pAdvancedSink->Release();

        return hr;
    }

    //
    // If the QI for the IDnsSinkInfo failed, this sink does not support
    // the newer interface. We need to call the older interface.
    //

    hr = punkObject->QueryInterface(IID_IDnsResolverRecordSink, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncGetResolverRecord( m_pContext->pszHostName,
                                         m_pContext->pszFQDN,
                                         m_pContext->dwVirtualServerId,
                                         m_pContext->ppIDnsResolverRecord );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpMaxMsgSize *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpMaxMsgSize, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncMaxMsgSize( m_pContext->pIUnknown, m_pContext->pIMailMsg, m_pContext->pfShouldImposeLimit );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpLogParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpLog *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpLog, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncLog(m_pContext->pSmtpEventLogInfo );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpLogParams::CallDefault()
{
    HRESULT hrRes = S_OK;
    SMTP_LOG_EVENT_INFO     *pLogEventInfo;
    CEventLogWrapper        *pEventLog;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CSmtpLogParams::CallDefault");

    _ASSERT(m_dwEventType == SMTP_LOG_EVENT);

    if ((m_pContext->pSmtpEventLogInfo == NULL) ||
        (m_pContext->pDefaultEventLogHandler == NULL))
    {
        DebugTrace((LPARAM) this, "Skipping LogEvent call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    // Params are m_pContext->pSmtpEventLogInfo
    pLogEventInfo = m_pContext->pSmtpEventLogInfo;

    // filter out events that the user isn't interested in
    if (m_pContext->iSelectedDebugLevel < pLogEventInfo->iDebugLevel) {
        return S_OK;
    }

    // Handler is m_pContext->pDefaultEventLogHandler
    pEventLog = (CEventLogWrapper*)m_pContext->pDefaultEventLogHandler;

    // Call into default logging handler
    pEventLog->LogEvent(
                    pLogEventInfo->idMessage,
//                    pLogEventInfo->idCategory,	// Not used by default handler
                    pLogEventInfo->cSubstrings,
                    pLogEventInfo->rgszSubstrings,
                    pLogEventInfo->wType,
                    pLogEventInfo->errCode,
                    pLogEventInfo->iDebugLevel,
                    pLogEventInfo->szKey,
                    pLogEventInfo->dwOptions,
                    pLogEventInfo->iMessageString,
                    pLogEventInfo->hModule);

    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpGetAuxDomainInfoFlagsParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpGetAuxDomainInfoFlags *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpGetAuxDomainInfoFlags, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnGetAuxDomainInfoFlags(m_pContext->pIServer,
                                        m_pContext->pszDomainName,
                                        m_pContext->pdwDomainInfoFlags );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpGetAuxDomainInfoFlagsParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------
//
// Function: CStoreDriver::Setprevious
//
// Synopsis: Method of IEventDispatcherChain - gets calle dy the
//           dispatcher, when binding changes happen.
//
// Arguments:
//   pUnkPrevious: [in] Pointer to the previous dispatcher
//   ppUnkPreload: [out] Receives an object which implements
//                 IEnumGUID, in order to tell the router
//                 which event types to pre-load.
//
// Returns:
//   S_OK: Success
//
// History:
//      dondu   06/22/98    Created
//
//-------------------------------------------------------------

const GUID* g_apStoreDispEventTypes[] = {&CATID_SMTP_STORE_DRIVER,&GUID_NULL};

HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload) {
    HRESULT hrRes;

    if (ppUnkPreload) {
        *ppUnkPreload = NULL;
    }
    if (!ppUnkPreload) {
        return (E_POINTER);
    }
    _ASSERT(pUnkPrevious);
    if (pUnkPrevious) {
        CComQIPtr<CStoreDispatcherData,&__uuidof(CStoreDispatcherData)> pData;
        LPVOID pvServer;
        DWORD dwServerInstance;

        pData = pUnkPrevious;
        _ASSERT(pData);
        if (pData) {
            hrRes = pData->GetData(&pvServer,&dwServerInstance);

            if (SUCCEEDED(hrRes)) {
                hrRes = SetData(pvServer,dwServerInstance);
                _ASSERT(SUCCEEDED(hrRes));
            }
        }
    }
    hrRes = CEDEnumGUID::CreateNew(ppUnkPreload,g_apStoreDispEventTypes);
    return (hrRes);
};


HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetContext(REFGUID guidEventType,
                                                       IEventRouter *piRouter,
                                                       IEventBindings *pBindings) {
    HRESULT hrRes;

    hrRes = CEventBaseDispatcher::SetContext(guidEventType,piRouter,pBindings);
    if (SUCCEEDED(hrRes) && (guidEventType == CATID_SMTP_STORE_DRIVER)) {
        HRESULT hrResTmp;
        LPVOID pvServer;
        DWORD dwServerInstance;
        SMTP_ALLOC_PARAMS AllocParams;

        hrResTmp = GetData(&pvServer,&dwServerInstance);
        if (SUCCEEDED(hrResTmp)) {
            ZeroMemory(&AllocParams, sizeof(AllocParams));
            AllocParams.m_EventSmtpServer = (LPVOID *) pvServer;
            AllocParams.m_InstanceId = dwServerInstance;
            AllocParams.m_dwStartupType = SMTP_INIT_BINDING_CHANGE;

            hrResTmp = OnEvent(CATID_SMTP_STORE_DRIVER,SMTP_STOREDRV_STARTUP_EVENT,&AllocParams);
            _ASSERT(SUCCEEDED(hrResTmp));
        }
    }
    return (hrRes);
}


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::CSMTPSeoMgr
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:24:18: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::CSMTPSeoMgr");

    m_dwSignature = SIGNATURE_CSMTPSEOMGR;
    m_pIEventRouter = NULL;
    m_pICatDispatcher = NULL;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::~CSMTPSeoMgr
//
// Synopsis: Deinitialize if necessary
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:26:09: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::~CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::~CSMTPSeoMgr");

    Deinit();

    _ASSERT(m_dwSignature == SIGNATURE_CSMTPSEOMGR);
    m_dwSignature = SIGNATURE_CSMTPSEOMGR_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::~CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrInit
//
// Synopsis: Initialize
//
// Arguments:
//  dwVSID: The virtual server ID
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:27:30: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrInit(
    DWORD dwVSID)
{
    HRESULT hr = S_OK;
    CStoreDispatcherClassFactory cf;
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrInit");

    _ASSERT(m_pIEventRouter == NULL);

    hr = SEOGetRouter(
        GUID_SMTP_SOURCE_TYPE,
        (REFGUID) CStringGUID(GUID_SMTPSVC_SOURCE, dwVSID),
        &m_pIEventRouter);

    if(FAILED(hr) || (hr == S_FALSE)) {
        //
        // Map S_FALSE to file not found -- this happens when the
        // source type is not registered
        //
        if(hr == S_FALSE)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        ErrorTrace((LPARAM)this, "SEOGetRouter failed hr %08lx", hr);
        m_pIEventRouter = NULL;
        goto CLEANUP;
    }
    //
    // Grab the dispatcher for the categorizer
    //
    _ASSERT(m_pICatDispatcher == NULL);

    hr = m_pIEventRouter->GetDispatcherByClassFactory(
        CLSID_CStoreDispatcher,
        &cf,
        CATID_SMTP_TRANSPORT_CATEGORIZE,
        IID_IServerDispatcher,
        (IUnknown **) &m_pICatDispatcher);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
        m_pICatDispatcher = NULL;
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr))
        Deinit();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrInit



//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::Deinit
//
// Synopsis: Deinitialize member variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:41:20: Created.
//
//-------------------------------------------------------------
VOID CSMTPSeoMgr::Deinit()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::Deinit");

    if(m_pICatDispatcher) {
        m_pICatDispatcher->Release();
        m_pICatDispatcher = NULL;
    }

    if(m_pIEventRouter) {
        m_pIEventRouter->Release();
        m_pIEventRouter = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::Deinit


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrTriggerServerEvent
//
// Synopsis: Trigger a server event
//
// Arguments:
//  dwEventType: event type to trigger
//  pvContext: structure specific to event type (see smtpseo.h)
//
// Returns:
//  S_OK: Success, called one or more sinks
//  S_FALSE: Success, no sinks called
//  MAILTRANSPORT_S_PENDING: Proccessing events async
//  E_OUTOFMEMORY
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:43:00: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrTriggerServerEvent(
    DWORD dwEventType,
    PVOID pvContext)
{
    HRESULT hr = S_OK;
    CComPtr<IServerDispatcher> pEventDispatcher;
    CStoreDispatcherClassFactory cf;
    REFIID iidBindingPoint = GuidForEvent(dwEventType);
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrTriggerServerEvent");

    if(m_pIEventRouter == NULL)
        return E_POINTER;

    if(iidBindingPoint == CATID_SMTP_TRANSPORT_CATEGORIZE) {
        //
        // Use the cached Categorizer dispatcher
        //
        pEventDispatcher = m_pICatDispatcher;

    } else {
        //
        // Get the latest dispatcher with all changes
        //
        hr = m_pIEventRouter->GetDispatcherByClassFactory(
            CLSID_CStoreDispatcher,
            &cf,
            iidBindingPoint,
            IID_IServerDispatcher,
            (IUnknown **) &pEventDispatcher);

        if (FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
            goto CLEANUP;
        }
    }

    hr = pEventDispatcher->OnEvent(
        iidBindingPoint,
        dwEventType,
        pvContext);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrTriggerServerEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\seodisp.h ===
#ifndef __SEODISP_H__
#define __SEODISP_H__

#include <smtpevents.h>
#include "smtpseo.h"
#include <smtpevent.h>
#include "smtpguid.h"
#include <comcat.h>
#include "seolib2.h"
#include "cdo.h"
#include <baseobj.h>

class __declspec(uuid("B226CEB5-0BBF-11d2-A011-00C04FA37348")) CStoreDispatcherData : public IUnknown {
	public:
		CStoreDispatcherData() {
			m_pvServer = NULL;
			m_dwServerInstance = 0;
		};
		HRESULT STDMETHODCALLTYPE GetData(LPVOID *ppvServer, DWORD *pdwServerInstance) {
			if (ppvServer) {
				*ppvServer = NULL;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = 0;
			}
			if (!m_pvServer) {
				return (E_FAIL);
			}
			if (ppvServer) {
				*ppvServer = m_pvServer;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = m_dwServerInstance;
			}
			return (S_OK);
		};
		HRESULT STDMETHODCALLTYPE SetData(LPVOID pvServer, DWORD dwServerInstance) {
			m_pvServer = pvServer;
			m_dwServerInstance = dwServerInstance;
			return (S_OK);
		};
	private:
		LPVOID m_pvServer;
		DWORD m_dwServerInstance;
};


class CStoreDispatcher :
        public CEventBaseDispatcher,
        public CComObjectRootEx<CComMultiThreadModelNoCS>,
        public IServerDispatcher,
        public IMailTransportNotify,
        public IClassFactory,
		public IEventDispatcherChain,
		public CStoreDispatcherData
{
    public:
        DECLARE_PROTECT_FINAL_CONSTRUCT();

        DECLARE_GET_CONTROLLING_UNKNOWN();

        DECLARE_NOT_AGGREGATABLE(CStoreDispatcher);

        BEGIN_COM_MAP(CStoreDispatcher)
            COM_INTERFACE_ENTRY(IEventDispatcher)
            COM_INTERFACE_ENTRY(IServerDispatcher)
            COM_INTERFACE_ENTRY(IMailTransportNotify)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
			COM_INTERFACE_ENTRY(IClassFactory)
			COM_INTERFACE_ENTRY(IEventDispatcherChain)
			COM_INTERFACE_ENTRY_IID(__uuidof(CStoreDispatcherData),CStoreDispatcherData)
        END_COM_MAP()

        // this code gets called during initialization
        HRESULT FinalConstruct()
        {
            // we need to do this to signal that we are free threaded
            return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p));
        }

        // this has the global destructor code in it
        void FinalRelease() {}

        virtual HRESULT AllocBinding(REFGUID rguidEventType,
                                     IEventBinding *piBinding,
                                     CBinding **ppNewBinding)
        {
            if (ppNewBinding)
                *ppNewBinding = NULL;

            if (!piBinding || !ppNewBinding)
                return E_POINTER;

            *ppNewBinding = new CStoreBinding;
            if (*ppNewBinding == NULL)
                return E_OUTOFMEMORY;

            return S_OK;
        }

    //
    // Local binding class
    //
    class CStoreBinding : public CEventBaseDispatcher::CBinding
    {
      public:
        CStoreBinding();
        ~CStoreBinding();
        virtual HRESULT Init(IEventBinding *piBinding);

        LPSTR   GetRuleString() { return(m_szRule); }

      private:
        HRESULT GetAnsiStringFromVariant(CComVariant &vString, LPSTR *ppszString);

      public:
        LPSTR       m_szRule;
    };
    //
    // Parameter abstract base class
    //
#define SIGNATURE_VALID_CSTOREPARAMS (DWORD)'CSPa'
#define SIGNATURE_INVALID_CSTOREPARAMS (DWORD)'aPSC'
    class CStoreBaseParams :
        public CEventBaseDispatcher::CParams,
        public CBaseObject
    {
      public:
        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject) = 0;
        virtual HRESULT CallDefault() = 0;
        virtual HRESULT CallCompletion(HRESULT hrStatus)
        {
            //
            // Free this Params object (Referenced in CStoreDispatcher::OnEvent)
            //
            CBaseObject::Release();
            return S_OK;
        }

        virtual HRESULT Init(PVOID pContext) = 0;

        HRESULT CheckMailMsgRule(
            CBinding *pBinding,
            IMailMsgProperties *pIMsgProps);

        HRESULT CheckMailMsgRecipientsRule(
            IUnknown *pIMsg,
            LPSTR pszPatterns);

        HRESULT CheckSignature()
        {
            return (m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS) ? S_OK : E_FAIL;
        }

        HRESULT MatchEmailOrDomainName(
            LPSTR szEmail,
            LPSTR szPattern,
            BOOL  fIsEmail);

      public:
        CStoreBaseParams();
        ~CStoreBaseParams();
        HRESULT InitParamData(
            LPVOID pContext,
            DWORD  dwEventType,
            IMailTransportNotify *pINotify,
            CStoreDispatcher *pDispatcher,
            REFIID rguidEventType);


      public:
        DWORD m_dwSignature;

        // This indicates which event type we are raising so that
        // the proper sink can be QI'd
        DWORD m_dwEventType;

      public:
        // Data needed for async sink operation:

        // How many sinks to skip on the next async sink completion
        DWORD m_dwIdx_SinkSkip;

        // Indicates wether or not default processing has been called
        BOOL  m_fDefaultProcessingCalled;

        // The IMailTransportNotify interface to pass to async capable sinks
        IMailTransportNotify *m_pINotify;

        // Our event type guid -- pass to dispatcher function
        GUID m_rguidEventType;

        // A pointer to the sink currently in asynchronous operation.
        // Must be NULL when no sinks are in async operation.
        IUnknown *m_pIUnknownSink;

        // store dispatcher that owns us
        CStoreDispatcher *m_pDispatcher;

    };

    //
    // Parameter class
    //
    class CStoreParams : 
        public CStoreBaseParams,
        public IMailMsgNotify
    {
        public:

        CStoreParams()
        {
            m_pContext = NULL;
            m_fCopiedContext = FALSE;
        }

        ~CStoreParams() {
            // clean up from CopyContext
            if (m_fCopiedContext) {
                _ASSERT(m_pContext == &m_context);
                if (m_context.m_RecipientCount) {
                    delete[] m_context.pdwRecipIndexes;
                }
                if (m_context.IMsgPtr) {
                    ((IMailMsgProperties *) m_context.IMsgPtr)->Release();
                }
                if (m_context.m_EventSmtpServer) {
                    ((ISMTPServer *) m_context.m_EventSmtpServer)->Release();
                }
            }
        }

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        virtual HRESULT CallCompletion(HRESULT hrStatus);

        // this needs to be done when we expect to use m_pContext in async
        // operations (such as local delivery)
        HRESULT CopyContext() {
            TraceFunctEnter("CStoreParams::CopyContext");

            // copying twice will screw things up
            if (m_fCopiedContext) {
                    TraceFunctLeave();
                        return S_OK;
            }

            _ASSERT(&m_context != m_pContext);

            memcpy(&m_context, m_pContext, sizeof(SMTP_ALLOC_PARAMS));

            if (m_context.m_RecipientCount) {
                // this is the only operation that can fail, so we do
                // it first.
                m_context.pdwRecipIndexes = 
                    new DWORD[m_context.m_RecipientCount];
                if (m_context.pdwRecipIndexes == NULL) {
                    ErrorTrace((LPARAM) this, "out of mem copying context");
                    TraceFunctLeave();
                    return E_OUTOFMEMORY;
                }
                memcpy(m_context.pdwRecipIndexes, 
                       m_pContext->pdwRecipIndexes, 
                       sizeof(DWORD) * m_context.m_RecipientCount);
            }

            // we need to hold onto these pointers
            if (m_context.IMsgPtr) {
                ((IMailMsgProperties *) m_context.IMsgPtr)->AddRef();
            }

            if (m_context.m_EventSmtpServer) {
                ((ISMTPServer *) m_context.m_EventSmtpServer)->AddRef();
            }

            m_fCopiedContext = TRUE;
            m_pContext = &m_context;

            TraceFunctLeave();
            return S_OK;
        }

        HRESULT Init(PVOID pContext)
        {
            m_pContext = (SMTP_ALLOC_PARAMS* )pContext;
            // AddRef our notification interface.  This is released in
            // CallCompletion.
            IMailMsgNotify *pNotify = (IMailMsgNotify *) m_pContext->m_pNotify;
            if (pNotify) {
                pNotify->AddRef();
            }
            return S_OK;
        }

        // IUnknown
        HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
        {
            if ( iid == IID_IUnknown ) {
                *ppv = static_cast<IMailMsgNotify*>(this);
            } else if ( iid == IID_IMailMsgNotify ) {
                *ppv = static_cast<IMailMsgNotify*>(this);
            } else {
                *ppv = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppv)->AddRef();
            return S_OK;
        }
        STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
        STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};

        // IMailMsgNotify
        HRESULT STDMETHODCALLTYPE Notify(HRESULT hrStatus);

      public:
        SMTP_ALLOC_PARAMS * m_pContext;
        SMTP_ALLOC_PARAMS m_context;
        BOOL m_fCopiedContext;
    };

    //
    // Parameter class - OnPreCategorize
    //
    class CMailTransportPreCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_PRECATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_PRECATEGORIZE m_Context;
    };

    //
    // Parameter class - OnPostCategorize
    //
    class CMailTransportPostCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_POSTCATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_POSTCATEGORIZE m_Context;
    };

    // ------------------------------------------------------------
    // Categorizer Parameter classes
    // ------------------------------------------------------------
    class CMailTransportCatRegisterParams : public CStoreBaseParams
    {
      public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATREGISTER) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATREGISTER m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBeginParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBEGIN) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBEGIN m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatEndParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATEND) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATEND m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERY) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERY m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueriesParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERIES) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERIES m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSendQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATSENDQUERY));
            //
            // Setup async params (so ICatAsyncContext can call back into dispatcher)
            //
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        EVENTPARAMS_CATSENDQUERY m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSortQueryResultParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATSORTQUERYRESULT) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATSORTQUERYRESULT m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatProcessItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATPROCESSITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATPROCESSITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatExpandItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            m_fAsyncCompletion = FALSE;
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATEXPANDITEM));
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        BOOL m_fAsyncCompletion;
        EVENTPARAMS_CATEXPANDITEM m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatCompleteItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATCOMPLETEITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATCOMPLETEITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportSubmissionParams : public CStoreBaseParams
    {
        public:
        CMailTransportSubmissionParams()
        {
            m_pCDOMessage = NULL;
        }
        ~CMailTransportSubmissionParams()
        {
            if(m_pCDOMessage)
                m_pCDOMessage->Release();
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_SUBMISSION));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        HRESULT CallCDOSink(IUnknown *pSink);

        EVENTPARAMS_SUBMISSION m_Context;
        IMessage *m_pCDOMessage;
    };

    //
    // Create options class - Routing
    //

    class CRouterCreateOptions : public CEventCreateOptionsBase
    {
      public:

        CRouterCreateOptions(PEVENTPARAMS_ROUTER pContext)
        {
            _ASSERT (pContext != NULL);

            m_pContext = pContext;
        }

      private:
        HRESULT STDMETHODCALLTYPE Init(
            REFIID iidDesired,
            IUnknown **ppUnkObject,
            IEventBinding *,
            IUnknown *);

        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class - Routing
    //
    class CMailTransportRouterParams : public CStoreBaseParams
    {
      public:

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_ROUTER) pContext;
            //
            // Make sure caller initialized pIMessageRouter to NULL
            //
            _ASSERT(m_pContext->pIMessageRouter == NULL);

            return S_OK;
        }

      private:
        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class
    //
    class CStoreAllocParams : public CEventBaseDispatcher::CParams
    {
    public:

        CStoreAllocParams();
        ~CStoreAllocParams();

        virtual HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);

    public:

        PFIO_CONTEXT  m_hContent;

    };

    //
    // Parameter class for msgTrackLog
    //
    class CMsgTrackLogParams : public CStoreBaseParams
    {
      public:
        CMsgTrackLogParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MSGTRACKLOG) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MSGTRACKLOG m_pContext;
    };

    //
    // Parameter class for mx records
    //
    class CDnsResolverRecordParams : public CStoreBaseParams
    {
      public:
        CDnsResolverRecordParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_DNSRESOLVERRECORD) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_DNSRESOLVERRECORD m_pContext;
    };

    //
    // Parameter class for max msg size exceeded event
    //
    class CSmtpMaxMsgSizeParams : public CStoreBaseParams
    {
      public:
        CSmtpMaxMsgSizeParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MAXMSGSIZE) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MAXMSGSIZE m_pContext;
    };

    //
    // Parameter class for log event
    //
    class CSmtpLogParams : public CStoreBaseParams
    {
      public:
        CSmtpLogParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_LOG) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_LOG m_pContext;
    };

    //
    // Parameter class for Get Aux Domain Info Flags event
    //
    class CSmtpGetAuxDomainInfoFlagsParams : public CStoreBaseParams
    {
      public:
        CSmtpGetAuxDomainInfoFlagsParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS m_pContext;
    };

    HRESULT CreateCParams(
            DWORD               dwEventType,
            LPVOID              pContext,
            IMailTransportNotify *pINotify,
            REFIID              rGuidEventType,
            CStoreBaseParams    **ppCParams);

    HRESULT STDMETHODCALLTYPE OnEvent(
        REFIID  iidEvent,
        DWORD   dwEventType,
        LPVOID  pvContext);

    HRESULT STDMETHODCALLTYPE Dispatcher(
        REFIID rguidEventType,
        CStoreBaseParams *pParams);

    HRESULT STDMETHODCALLTYPE Notify(
        HRESULT hrStatus,
        PVOID pvContext);

    // IClassFactory methods
    public:
	    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
	    {
	        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	    }
	    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
	    {
	        _ASSERT(FALSE);
	        return E_NOTIMPL;
	    }

	// IEventDispatcherChain methods
	public:
		HRESULT STDMETHODCALLTYPE SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload);

	// IEventDispatcher methods
	public:
		HRESULT STDMETHODCALLTYPE SetContext(REFGUID guidEventType,
											 IEventRouter *piRouter,
											 IEventBindings *pBindings);

    private:
        CComPtr<IUnknown> m_pUnkMarshaler;
};

class CStoreDispatcherClassFactory : public IClassFactory
{
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void * * ppvObj)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
    unsigned long  STDMETHODCALLTYPE AddRef () { _ASSERT(FALSE); return 0; }
    unsigned long  STDMETHODCALLTYPE Release () { _ASSERT(FALSE); return 0; }

    // *** IClassFactory methods ***
    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
    {
        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
    }
    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
};


// helper functions
//
// jstamerj 980603 10:45:21: TriggerServerEvent with async callback
// support for completion
//

HRESULT TriggerServerEvent(IEventRouter             *pRouter,
                            DWORD                   dwEventType,
                            PVOID                   pvContext);


//
// register a new SEO instance.  if the instance is already registered
// this function will detect it and won't register it again.  it should
// be called for each instance at service startup and when each instance
// is created.
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID);
//
// unregister an SEO instance.  this should be called when an SEO
// instance is being deleted.
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\seo\mseodisp\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\wstgado.h $(O)\wstgado_i.c : $(STAXINC)\export\wstgado.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\wstgado_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\wstgado_i.c \
    -header $@ \
    -tlb $(O)\wstagado.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpsvc.h $(O)\smtpsvc_s.c : ..\..\smtpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\smtpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: smtpmsg.mc 
    copy /a smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\account.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       account.cxx
//
//  Contents:   Code to read and set the passwords for services. Adopted from
//              the code used by the service control manager to do the same.
//
//  Classes:
//
//  Functions:  SCMgrGetPassword
//              ScGetPassword
//              ScOpenPolicy
//              ScFormSecretName
//              MapNTStatus
//
//  History:    January 16, 1998    Milans Created
//
//-----------------------------------------------------------------------------

#include "smtpinc.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"
#include "account.h"

DWORD ScGetPassword(
    LPSTR szServiceName,
    LPSTR *pszPassword);

DWORD ScOpenPolicy(
    ACCESS_MASK DesiredAccess,
    LSA_HANDLE *PolicyHandle);

DWORD
ScFormSecretName(
    LPSTR szServiceName,
    LPWSTR *pwszSecretName);

DWORD
MapNTStatus(
    NTSTATUS ntstatus);

//+----------------------------------------------------------------------------
//
//  Function:   SCMgrGetPassword
//
//  Synopsis:   Reads the password configured for a given service.
//
//  Arguments:  [szServiceName] -- Name of service.
//              [cbPassword] -- Size in bytes of pszPassword buffer.
//              [pszPassword] -- The buffer in which to return the password.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning password.
//              [ERROR_MORE_DATA] -- Password too big for passed in buffer.
//              [ERROR_INVALID_SREVICE_ACCOUNT] -- Unable to find password for
//                  specified service.
//              [ERROR_ACCESS_DENIED] -- Priviledge violation reading password
//
//-----------------------------------------------------------------------------

DWORD SCMgrGetPassword(
    LPSTR szServiceName,
    DWORD cbPassword,
    LPSTR pszPassword)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPSTR pszAllocatedPassword;

    pszAllocatedPassword = NULL;

    dwErr = ScGetPassword(szServiceName, &pszAllocatedPassword);

    if (dwErr == ERROR_SUCCESS) {

        if (strlen(pszAllocatedPassword) < cbPassword)
            strcpy(pszPassword, pszAllocatedPassword);
        else
            dwErr = ERROR_MORE_DATA;

        delete [] pszAllocatedPassword;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ScGetPassword
//
//  Synopsis:   Retrieves the configured password for a given service
//
//  Arguments:  [szServiceName] -- Name of service for which the configured
//                  password is to be retrieved.
//              [pszPassword] -- On successful return, a string is allocated
//                  using new and the password returned in it. Caller should
//                  free using delete.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning password.
//              [ERROR_INVALID_SERVICE_ACCOUNT] -- Service name not found.
//              [ERROR_ACCESS_DENIED] -- No access to password registry
//
//-----------------------------------------------------------------------------

DWORD ScGetPassword(
    LPSTR szServiceName,
    LPSTR *pszPassword)
{
    DWORD dwErr;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    LPWSTR LsaSecretName;
    UNICODE_STRING SecretNameString;
    PUNICODE_STRING NewPasswordString;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_CREATE_SECRET,
            &PolicyHandle
            ) != NO_ERROR) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Form the secret name under which the service password is stored
    //
    if ((dwErr = ScFormSecretName(
                      szServiceName,
                      &LsaSecretName
                      )) != ERROR_SUCCESS) {
        (void) LsaClose(PolicyHandle);
        return dwErr;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaRetrievePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   &NewPasswordString
                   );

    if (NT_SUCCESS(ntstatus)) {

        *pszPassword = new CHAR[ NewPasswordString->Length + 1 ];

        if (*pszPassword != NULL) {

            wcstombs(
                *pszPassword,
                NewPasswordString->Buffer,
                NewPasswordString->Length/sizeof(WCHAR));

            (*pszPassword)[NewPasswordString->Length/sizeof(WCHAR)] = 0;

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = E_OUTOFMEMORY;

        }

    } else {

        dwErr = MapNTStatus( ntstatus );
    }

    delete [] LsaSecretName;

    (void) LsaClose(PolicyHandle);

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   ScOpenPolicy
//
//  Synopsis:   Opens the local security policy by calling LsaOpenPolicy.
//
//  Arguments:  [DesiredAccess] -- Desired access to Policy.
//              [PolicyHandle] -- The policy handle is returned here.
//
//  Returns:    [ERROR_SUCCESS] -- Successful return.
//              [ERROR_ACCESS_DENIED] -- No access to lsa policy.
//
//-----------------------------------------------------------------------------

DWORD ScOpenPolicy(
    ACCESS_MASK DesiredAccess,
    LSA_HANDLE *PolicyHandle)
{
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   DesiredAccess,
                   PolicyHandle
                   );

    return( MapNTStatus( ntstatus ) );

}

//+----------------------------------------------------------------------------
//
//  Function:   ScFormSecretName
//
//  Synopsis:   Forms the secret name used to store the password for the
//              service.
//
//  Arguments:  [szServiceName] -- The service name for which the
//                  corresponding secret name is required.
//              [pwszSecretName] -- On successful return, a newly allocated
//                  buffer, containing the UNICODE secret name, is returned
//                  here. Caller should free using delete.
//
//  Returns:    [ERROR_SUCCESS] -- If successful
//              [E_OUTOFMEMORY] -- If unable to allocate space for
//                  pwszSecretName.
//
//-----------------------------------------------------------------------------

#define SC_SECRET_PREFIX "_SC_"
#define SC_SECRET_PREFIX_W L"_SC_"

DWORD
ScFormSecretName(
    LPSTR szServiceName,
    LPWSTR *pwszSecretName)
{
    DWORD cLen, cServiceNameLen;

    cServiceNameLen = strlen(szServiceName);

    cLen = sizeof( SC_SECRET_PREFIX ) + cServiceNameLen + 1;

    *pwszSecretName = new WCHAR[ cLen ];

    if (*pwszSecretName != NULL) {

        wcscpy( *pwszSecretName, SC_SECRET_PREFIX_W );

        mbstowcs(
            &(*pwszSecretName)[sizeof(SC_SECRET_PREFIX) - 1],
            szServiceName,
            cServiceNameLen + 1);

        return( ERROR_SUCCESS );

    } else {

        return( E_OUTOFMEMORY );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   MapNTStatus
//
//  Synopsis:   Simple function to map some registry related NT statuses to
//              Win32 errors.
//
//  Arguments:  [ntstatus] -- The NT Status to map
//
//  Returns:    Win32 error corresponding to ntstatus
//
//-----------------------------------------------------------------------------

DWORD
MapNTStatus(
    NTSTATUS ntstatus)
{
    DWORD dwErr;

    switch (ntstatus) {
    case STATUS_SUCCESS:
        dwErr = ERROR_SUCCESS;
        break;

    case STATUS_ACCESS_DENIED:
        dwErr = ERROR_ACCESS_DENIED;
        break;

    default:
        dwErr = ERROR_INVALID_SERVICE_ACCOUNT;
        break;

    }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\asyncmx.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include <asynccon.hxx>
#include <dnsreci.h>
#include "asyncmx.hxx"

#include "smtpout.hxx"

extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);

CPool  CAsyncMx::Pool(ASYNCMX_SIGNATURE);

CAsyncMx::CAsyncMx(PMXPARAMS Parameters)
:CAsyncConnection(Parameters->PortNum, Parameters->TimeOut, Parameters->HostName, Parameters->CallBack)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::CAsyncMx");

    m_Signature = ASYNCMX_SIGNATURE;
    NumMxRecords = Parameters->pDnsRec->NumRecords;
    m_DomainOptions = 0;
    m_NextMxRecord = Parameters->pDnsRec->StartRecord;
    m_CurrentMxRec = 0;
    m_fTriedOnFailHost = FALSE;
    m_fLoopback = FALSE;
    pSmtpConnection = Parameters->pISMTPConnection;
    pServiceInstance = Parameters->pInstance;
    m_pDnsRec = Parameters->pDnsRec;
    m_pNextIpAddress = NULL;
    m_pDNS_RESOLVER_RECORD = Parameters->pDNS_RESOLVER_RECORD;
    m_fInitCalled = FALSE;
    m_pszSSLVerificationName = NULL;

    pServiceInstance->InsertAsyncObject(this);

    DebugTrace((LPARAM) this, "Constructing MX object with %d records", NumMxRecords);
    DebugTrace((LPARAM) this, "Got DNS_RESOLVER_RECORD = 0x%08x", m_pDNS_RESOLVER_RECORD);

    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      Initializes heap allocated members of CAsyncMx, ~CAsyncMx cleans up.
//  Arguments:
//      pszSSLVerificationName - For outbound session, name against which
//          server SSL certificate is matched (if config option to match the
//          name is set in SMTP).
//  Returns:
//      FALSE on failure (caller should then delete CAsyncMx), else TRUE
//-----------------------------------------------------------------------------
BOOL CAsyncMx::Init (LPSTR pszSSLVerificationName)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CAsyncMx::Init");

    m_fInitCalled = TRUE;
    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen (pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName)
            goto Exit;

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }

    fRet = TRUE;
Exit:
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

CAsyncMx::~CAsyncMx()
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::~CAsyncMx");
    
    _ASSERT (m_fInitCalled && "Init not called for CAsyncMx object");

    if(m_pDNS_RESOLVER_RECORD != NULL)
    {
        DebugTrace((LPARAM) this, "Deleting embedded DNS_RESOLVER_RECORD in async MX obj");
        delete m_pDNS_RESOLVER_RECORD;
        m_pDNS_RESOLVER_RECORD = NULL;
    }
    DBG_CODE(else DebugTrace((LPARAM)this, "No DNS_RESOLVER_RECORD object in async MX obj"));

    if(m_pDnsRec != NULL)
    {
        DeleteDnsRec (m_pDnsRec);
        m_pDnsRec = NULL;
    }

    if(m_pszSSLVerificationName != NULL)
    {
        delete [] m_pszSSLVerificationName;
        m_pszSSLVerificationName = NULL;
    }

    pServiceInstance->RemoveAsyncObject(this);

    m_Signature = ASYNCMX_SIGNATURE_FREE;
    TraceFunctLeaveEx((LPARAM) this);
}


BOOL CAsyncMx::CheckIpAddress(DWORD IpAddress, DWORD PortNum)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::CheckIpAddress");

    fRet = pServiceInstance->IsAddressMine (IpAddress, PortNum);

    m_fLoopback = fRet;

    return !fRet;
    TraceFunctLeaveEx((LPARAM) this);
}

BOOL CAsyncMx::IsMoreIpAddresses(void)
{
    BOOL fMore = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::IsMoreIpAddresses");

    if(m_pDnsRec && m_pNextIpAddress && m_pDnsRec->DnsArray[m_CurrentMxRec])
    {
        if(m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead)
        {
            fMore = TRUE;
        }
        else
        {
            m_pNextIpAddress = NULL;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fMore;
}

void CAsyncMx::IncNextIpToTry (void) 
{
    if(m_pNextIpAddress)
    {
        m_pNextIpAddress = m_pNextIpAddress->Flink;
    }
}

DWORD CAsyncMx::GetNextIpAddress(void)
{
    PMXIPLIST_ENTRY pContext = NULL;
    DWORD IpAddress = INADDR_NONE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::GetNextIpAddress");

	if(m_pDnsRec && m_pNextIpAddress && m_pDnsRec->DnsArray[m_CurrentMxRec])
	{
		//m_pNextIpAddress = m_pNextIpAddress->Flink;

        //if m_pNextIpAddress == &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead
        //this means we have tried every IP address in the list, and there is no more.
        //else we get the next IP address and try to connect to it.
        if(m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead)
        {
            pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );
            IpAddress = pContext->IpAddress;
        }
        else
        {
            m_pNextIpAddress = NULL;
        }
    }
    else
    {
            m_pNextIpAddress = NULL;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return IpAddress;
}

BOOL CAsyncMx::ConnectToNextMxHost(void)
{
    BOOL fReturn = FALSE;
    LIST_ENTRY * pEntry = NULL;
    PMXIPLIST_ENTRY pContext = NULL;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::ConnectToNextMxHost");

    SetLastError(NO_ERROR);

    DebugTrace((LPARAM)this, "m_NextMxRecord is %d", m_NextMxRecord);
    DebugTrace((LPARAM)this, "NumMxRecords is %d", NumMxRecords);

    //If there are more MX records to connect to, then try and connect
    //to the next one.
    
    if((m_NextMxRecord < NumMxRecords) &&  (m_pDnsRec->DnsArray[m_NextMxRecord] != NULL))
    {
        m_CurrentMxRec = m_NextMxRecord;

        SetNewHost(m_pDnsRec->DnsArray[m_NextMxRecord]->DnsName);

        DebugTrace((LPARAM)this, "m_NextMxRecord for %s is %d", GetHostName(), m_NextMxRecord);

        //if the first entry is non NULL, then see if this
        //entry has an Ip Address. If it has an ip address,
        //save the link to the next ip address incase this
        //one fails to connect. Also, bump the next MX record
        //to try counter.
        if(!IsListEmpty(&m_pDnsRec->DnsArray[m_NextMxRecord]->IpListHead))
        {
            m_pNextIpAddress = m_pDnsRec->DnsArray[m_NextMxRecord]->IpListHead.Flink;
            pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );

            m_NextMxRecord++;
            SetErrorCode(NO_ERROR);

#define BYTE_VAL(dw, ByteNo) ( ((dw) >> (8 * (ByteNo))) & 0xFF)

            DebugTrace((LPARAM) this, "ConnectToNextMxHost trying IP address %d.%d.%d.%d", 
                BYTE_VAL(pContext->IpAddress, 0),
                BYTE_VAL(pContext->IpAddress, 1),
                BYTE_VAL(pContext->IpAddress, 2),
                BYTE_VAL(pContext->IpAddress, 3));

            fReturn = ConnectToHost(pContext->IpAddress);
        }
        else
        {
            //the list is empty.
            DebugTrace((LPARAM) this, "No more MX hosts in ConnectToNextMxHost");

            m_NextMxRecord++;
            m_pDnsRec->StartRecord++;   
            SetErrorCode(WSAHOST_NOT_FOUND);
        }
    }
    else
    {
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

BOOL CAsyncMx::MakeFirstAsyncConnect(void)
{
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::MakeFirstAsyncConnect");

    fReturn = ConnectToNextMxHost();

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}


BOOL CAsyncMx::OnConnect(BOOL fConnected)
{
    LIST_ENTRY  * pEntryNext = NULL;
    PMXIPLIST_ENTRY pContext = NULL;
    BOOL fReturn = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMx::OnConnect");

    //remove this IP address from the list, so we do not connect
    //to it again if the connection drops when we perform all our
    //outbound processing
    if(m_pNextIpAddress &&
        (m_pNextIpAddress != &m_pDnsRec->DnsArray[m_CurrentMxRec]->IpListHead))
    {
        //save the next entry in the list
        pEntryNext = m_pNextIpAddress->Flink;   

        //get the current entry, remove it, then delete it
        pContext = CONTAINING_RECORD( m_pNextIpAddress, MXIPLIST_ENTRY, ListEntry );
        RemoveEntryList( &(pContext->ListEntry));
        delete pContext;

        //set the current entry equal to the saved entry
        m_pNextIpAddress = pEntryNext;
    }
    else
    {
        fReturn = FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

void CAsyncMx::AckMessage(void)
{
    MessageAck MsgAck;

    if(m_pDnsRec != NULL)
    {
        if(m_pDnsRec->pMailMsgObj)
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;
            MsgAck.pvMsgContext = (DWORD *) m_pDnsRec->pAdvQContext;
            MsgAck.pIMailMsgProperties = (IMailMsgProperties *) m_pDnsRec->pMailMsgObj;
            pSmtpConnection->AckMessage(&MsgAck);
            MsgAck.pIMailMsgProperties->Release();
            m_pDnsRec->pMailMsgObj = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\aqstore.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>

#include <nsepname.hxx>

extern DWORD g_UseMapiDriver ;

HINSTANCE g_hStoredll = NULL;
HINSTANCE g_hAqdll = NULL;
BOOL StoreDriverInitialized = FALSE;

AQ_INITIALIZE_EX_FUNCTION g_pfnInitializeAQ = NULL;
AQ_DEINITIALIZE_EX_FUNCTION g_pfnDeinitializeAQ = NULL;


static void STDAPICALLTYPE DeInitialize(DWORD InstanceId)
{
	return;
}


void UnLoadQueueDriver(void)
{
        if(g_hAqdll != NULL)
        {
                FreeLibrary(g_hAqdll);
                g_hAqdll = NULL;
        }
}


BOOL LoadAdvancedQueueing(char *szAQDll)
{
    TraceFunctEnterEx((LPARAM) NULL, "LoadAdvancedQueueing");

    DWORD dwErr = ERROR_SUCCESS;

    g_hAqdll = LoadLibraryEx(szAQDll, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (g_hAqdll != NULL) {

        g_pfnInitializeAQ =
            (AQ_INITIALIZE_EX_FUNCTION)
                GetProcAddress(g_hAqdll, AQ_INITIALIZE_FUNCTION_NAME_EX);

        if (g_pfnInitializeAQ != NULL) {

            g_pfnDeinitializeAQ =
                (AQ_DEINITIALIZE_EX_FUNCTION)
                    GetProcAddress(g_hAqdll, AQ_DEINITIALIZE_FUNCTION_NAME_EX);

        }

        if (g_pfnInitializeAQ == NULL || g_pfnDeinitializeAQ == NULL) {
            dwErr = GetLastError();

            DebugTrace((LPARAM) NULL, "Error getting address of %s - %d",
                g_pfnInitializeAQ ? AQ_DEINITIALIZE_FUNCTION_NAME_EX :
                    AQ_INITIALIZE_FUNCTION_NAME_EX, dwErr);
        }

    } else {

        dwErr = GetLastError();

        DebugTrace((LPARAM) NULL, "Error loading %s - %d", szAQDll, dwErr);

    }


    TraceFunctLeaveEx((LPARAM) NULL);
	return (dwErr == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\admin.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    This module contains code for doing admin rpcs

Author:

    Todd Christensen (ToddCh)     28-Apr-1996

Revision History:

    Rohan Phillips (Rohanp) - enabled virtual server support 4-Feb-1997

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpsvc.h"
#include "smtpcli.hxx"
#include "admin.hxx"

// Address validation lib (KeithLau 7/28/96)
#include "address.hxx"
#include "findiis.hxx"
#include <stdio.h>
#include <malloc.h>

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return(TRUE);
    return(FALSE);
}

//
// Quick and dirty range check using inlines
//
static inline BOOL pValidateRange(DWORD dwValue, DWORD dwLower, DWORD dwUpper)
{
    // Inclusive
    if ((dwValue >= dwLower) && (dwValue <= dwUpper))
        return(TRUE);

    SetLastError(ERROR_INVALID_PARAMETER);
    return(FALSE);
}

NET_API_STATUS
NET_API_FUNCTION
SmtprGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pszServer - unused
       ppConfig - Receives pointer to admin information

   Note:

--*/
{
    SMTP_CONFIG_INFO * pConfig;
    PSMTP_SERVER_INSTANCE pInstance;
    DWORD            err = NO_ERROR;

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (IsBadWritePtr((LPVOID)ppConfig, sizeof(LPSMTP_CONFIG_INFO)))
        return(ERROR_INVALID_PARAMETER);

    // In case we exit on an error...
    *ppConfig = NULL;

    if ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION ))
        return err;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if (!ConvertSmtpConfigToRpc(&pConfig, pInstance))
    {
        err = GetLastError();
        goto exit;
    }

    if (!ConvertSmtpRoutingListToRpc(&(pConfig->RoutingList), pInstance))
    {
        FreeRpcSmtpConfig(pConfig);
        err = GetLastError();
        goto exit;
    }

    *ppConfig = pConfig;

exit:

    pInstance->Dereference();
    return err;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  SMTP_CONFIG_INFO *      pConfig,
    IN  DWORD                   dwInstance
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pszServer - unused
       pConfig - Admin information to set

   Note:

--*/
{
    PSMTP_SERVER_INSTANCE pInstance;

    if (IsBadReadPtr((LPVOID)pConfig, sizeof(SMTP_CONFIG_INFO)))
        return(ERROR_INVALID_PARAMETER);

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    DWORD err;

    if ( err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION ))
        return err;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance != NULL)
    {
        // raid 129712 - we treat this case the same as before.
        if ( !(pInstance->WriteRegParams(pConfig)) ||
         !(pInstance->ReadRegParams(pConfig->FieldControl, TRUE)))
        {
            pInstance->Dereference();
            return GetLastError();
        }

        pInstance->Dereference();
        return NO_ERROR;
    }

    return ERROR_INVALID_DATA;
}



//+---------------------------------------------------------------
//
//  Function:   ConvertSmtpConfigToRpc
//
//  Synopsis:   Moves config values into the RPC structure
//
//  Arguments:  LPSMTP_CONFIG_INFO *: structure to be filled with
//                  configuration data.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL ConvertSmtpConfigToRpc(LPSMTP_CONFIG_INFO *ppConfig, PSMTP_SERVER_INSTANCE pInstance)
{
    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}


void FreeRpcSmtpConfig(LPSMTP_CONFIG_INFO pConfig)
{
    if (pConfig)
    {
        if (pConfig->lpszSmartHostName)
            FreeRpcString(pConfig->lpszSmartHostName);
        if (pConfig->lpszConnectResp)
            FreeRpcString(pConfig->lpszConnectResp);
        if (pConfig->lpszBadMailDir)
            FreeRpcString(pConfig->lpszBadMailDir);

        if (pConfig->RoutingList)
            FreeRpcSmtpRoutingList(pConfig->RoutingList);

        MIDL_user_free(pConfig);
    }
}


BOOL ConvertSmtpRoutingListToRpc(LPSMTP_CONFIG_ROUTING_LIST *ppRoutingList, PSMTP_SERVER_INSTANCE pInstance)
{
#if 0
    LPSMTP_CONFIG_ROUTING_LIST  pRoutingList;
    DWORD                       dwErr;
    DWORD                       iSource;
    DWORD                       cSources = 0;
    DWORD                       cbAlloc;
    PLIST_ENTRY                 pEntry;
    PLIST_ENTRY                 pHead;

    cSources = pInstance->GetRoutingSourceCount();

    cbAlloc = sizeof(SMTP_CONFIG_ROUTING_LIST) + cSources * sizeof(SMTP_CONFIG_ROUTING_ENTRY);
    pRoutingList = (LPSMTP_CONFIG_ROUTING_LIST) MIDL_user_allocate(cbAlloc);
    if (!pRoutingList)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    ZeroMemory(pRoutingList, cbAlloc);

    pRoutingList->cEntries = cSources;
    pHead = pInstance->GetRoutingSourceList();

    for (pEntry = pHead->Flink, iSource = 0 ; pEntry != pHead ; pEntry = pEntry->Flink, iSource++)
    {
        if (!ConvertStringToRpc(&(pRoutingList->aRoutingEntry[iSource].lpszSource),
                CONTAINING_RECORD(pEntry, ABSOURCE, list)->szConfig))
        {
            dwErr = GetLastError();
            for (iSource = 0 ; iSource < cSources ; iSource++)
            {
                if (pRoutingList->aRoutingEntry[iSource].lpszSource)
                    FreeRpcString(pRoutingList->aRoutingEntry[iSource].lpszSource);
            }

            MIDL_user_free(pRoutingList);
            SetLastError(dwErr);
            return FALSE;
        }
    }

    *ppRoutingList = pRoutingList;
#endif

    return FALSE;
}



void FreeRpcSmtpRoutingList(LPSMTP_CONFIG_ROUTING_LIST pRoutingList)
{
    DWORD       iSource;

    if (pRoutingList)
    {
        for (iSource = 0 ; iSource < pRoutingList->cEntries ; iSource++)
        {
            if (pRoutingList->aRoutingEntry[iSource].lpszSource)
                FreeRpcString(pRoutingList->aRoutingEntry[iSource].lpszSource);
        }

        MIDL_user_free(pRoutingList);
    }
}



NET_API_STATUS
NET_API_FUNCTION
SmtprGetConnectedUserList(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONN_USER_LIST   *ppConnUserList,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Retrieves the connected user list

   Arguments:

       pszServer - unused
       ppConnUserList - Receives pointer to admin information

   Note:

--*/
{
    SMTP_CONN_USER_LIST     *pConnUserList;
    SMTP_CONN_USER_ENTRY    *pConnEntry;
    DWORD                   dwErr;
    PLIST_ENTRY             pleHead;
    PLIST_ENTRY             pleT;
    SMTP_CONNECTION         *pConn;
    DWORD                   iEntry;
    DWORD                   NumUsers = 0;
    PSMTP_SERVER_INSTANCE pInstance;

    // In case we exit on an error...
    *ppConnUserList = NULL;

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (IsBadWritePtr((LPVOID)ppConnUserList, sizeof(LPSMTP_CONN_USER_LIST)))
        return(ERROR_INVALID_PARAMETER);

    if (dwErr = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION))
        return dwErr;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance->LockConfig();

    //loop through the list to get the count of all connected users.
    //These are users whose sockets are not equal to INVALID_SOCKET
    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);
        if(pConn->QueryClientSocket() != INVALID_SOCKET)
        {
            NumUsers++;
        }
    }

    pConnUserList = (SMTP_CONN_USER_LIST *)MIDL_user_allocate(sizeof(SMTP_CONN_USER_LIST) +
        sizeof(SMTP_CONN_USER_ENTRY) * NumUsers);
    if (!pConnUserList)
    {
        pInstance->UnLockConfig();
        pInstance->Dereference();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pConnUserList->cEntries = NumUsers;
    pConnEntry = pConnUserList->aConnUserEntry;
    ZeroMemory(pConnEntry, sizeof(SMTP_CONN_USER_ENTRY) * pConnUserList->cEntries);

    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);

        //disregard anyone whose socket is invalid
        if(pConn->QueryClientSocket() == INVALID_SOCKET)
            continue;

        pConnEntry->dwUserId = pConn->QueryClientId();
        pConnEntry->dwConnectTime = pConn->QuerySessionTime();
        if (pConn->QueryClientUserName())
        {
            if (!ConvertStringToRpc(&(pConnEntry->lpszName), pConn->QueryClientUserName()))
            {
                pInstance->UnLockConfig();

                pConnEntry = pConnUserList->aConnUserEntry;
                for (iEntry = 0 ; iEntry < pConnUserList->cEntries ; iEntry++, pConnEntry++)
                {
                    if (pConnEntry->lpszName)
                        FreeRpcString(pConnEntry->lpszName);
                    if (pConnEntry->lpszHost)
                        FreeRpcString(pConnEntry->lpszHost);
                }
                MIDL_user_free(pConnUserList);

                pInstance->Dereference();
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if (pConn->QueryClientHostName())
        {
            if (!ConvertStringToRpc(&(pConnEntry->lpszHost), pConn->QueryClientHostName()))
            {
                pInstance->UnLockConfig();

                pConnEntry = pConnUserList->aConnUserEntry;
                for (iEntry = 0 ; iEntry < pConnUserList->cEntries ; iEntry++, pConnEntry++)
                {
                    if (pConnEntry->lpszName)
                        FreeRpcString(pConnEntry->lpszName);
                    if (pConnEntry->lpszHost)
                        FreeRpcString(pConnEntry->lpszHost);
                }
                MIDL_user_free(pConnUserList);
                pInstance->Dereference();
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        pConnEntry++;
    }

    pInstance->UnLockConfig();
    *ppConnUserList = pConnUserList;

    pInstance->Dereference();
    return NO_ERROR;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprDisconnectUser(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  DWORD                   dwUserId,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Disconnects the specified user

   Arguments:

       pszServer - unused
       dwUserId - user to disconnect

   Note:

--*/
{
    DWORD                   dwErr;
    PLIST_ENTRY             pleHead;
    PLIST_ENTRY             pleT;
    SMTP_CONNECTION         *pConn;
    PSMTP_SERVER_INSTANCE pInstance;


    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (dwErr = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION))
        return dwErr;

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance->LockConfig();

    pleHead = pInstance->GetConnectionList();
    for (pleT = pleHead->Flink ; pleT != pleHead ; pleT = pleT->Flink)
    {
        pConn = CONTAINING_RECORD(pleT, SMTP_CONNECTION, m_listEntry);
        if (pConn->QueryClientId() == dwUserId)
        {
            pConn->DisconnectClient();
            pInstance->UnLockConfig();
            pInstance->Dereference();

            return NO_ERROR;
        }
    }

    pInstance->UnLockConfig();
    pInstance->Dereference();
    return ERROR_NO_SUCH_USER;
}



/*++

    Description:
        Adds a user

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateUser(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszForwardEmail,
    IN  DWORD                   dwLocal,
    IN  DWORD                   dwMailboxSize,
    IN  DWORD                   dwMailboxMessageSize,
    IN  LPWSTR                  wszVRoot,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szForward = NULL;
    LPSTR   szVRoot = NULL;
    HANDLE  hToken;
    DWORD   cbRoot;
    char    szRoot[MAX_PATH + 1];
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateUser");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (wszForwardEmail &&
        !pValidateStringPtr(wszForwardEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (wszVRoot &&
        !pValidateStringPtr(wszVRoot, AB_MAX_VROOT))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Forward: %ls", wszForwardEmail ? wszForwardEmail : L"<NULL>");
    if (wszForwardEmail)
    {
        szForward = ConvertUnicodeToAnsi(wszForwardEmail, NULL, 0);
        if (!szForward)
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszForwardEmail, dwErr);
            TCP_FREE(szEmail);
            pInstance->Dereference();
            TraceFunctLeave();
            return dwErr;
        }
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail)) // Note: ANSI version
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (wszForwardEmail)
        if (!CAddr::ValidateEmailName(szForward)) // Note: ANSI version
        {
            ErrorTrace(NULL, "Invalid parameter: wszForwardEmail (%ls)\n",
                       (wszForwardEmail)?wszForwardEmail:L"NULL");
            if (szForward)
                TCP_FREE(szForward);
            TCP_FREE(szEmail);
            pInstance->Dereference();
            TraceFunctLeave();
            return(ERROR_INVALID_PARAMETER);
        }
    if (!pValidateRange(dwLocal, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: dwLocal (%u)\n",
                   dwLocal);
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    // VRoot is checked downstream

    DebugTrace(NULL, "Create mailbox: %s", dwLocal ? "TRUE" : "FALSE");
    if (dwLocal)
    {
        DebugTrace(NULL, "VRoot: %ls", wszVRoot ? wszVRoot : L"<NULL>");
        if (wszVRoot)
        {
            szVRoot = ConvertUnicodeToAnsi(wszVRoot, NULL, 0);
            if (!szVRoot)
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %u", wszVRoot, dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }

            DWORD dwAccessMask = 0;

            // Parameter checking for valid vroot
            cbRoot = sizeof(szRoot);
            if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
                szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                &hToken, NULL))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to resolve virtual root(%ls): %u", wszVRoot, dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                TCP_FREE(szVRoot);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }
        }
        else
        {
            szVRoot = (LPSTR)TCP_ALLOC(MAX_PATH);
            if (!szVRoot)
            {
                ErrorTrace(NULL, "Allocation failed");
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if (!pInstance->FindBestVRoot(szVRoot))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to FindBestVRoot: %u", dwErr);
                if (szForward)
                    TCP_FREE(szForward);
                TCP_FREE(szEmail);
                pInstance->Dereference();
                TraceFunctLeave();
                return dwErr;
            }

        }
    }

/*
    if (!pInstance->PRtx()->CreateUser(szEmail, szForward, dwLocal, szVRoot, dwMailboxSize, dwMailboxMessageSize))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to create user %s: %u", szEmail, dwErr);
        if (szVRoot)
            TCP_FREE(szVRoot);
        if (szForward)
            TCP_FREE(szForward);
        TCP_FREE(szEmail);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }
*/
    if (szVRoot)
        TCP_FREE(szVRoot);
    if (szForward)
        TCP_FREE(szForward);
    TCP_FREE(szEmail);

    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Deletes a user

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteUser(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwInstance
    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprDeleteUser");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

/*
    if (!pInstance->PRtx()->DeleteUser(szEmail))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete user %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }
*/

    TCP_FREE(szEmail);
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Gets user properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprGetUserProps(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    OUT LPSMTP_USER_PROPS       *ppUserProps,
    IN  DWORD                   dwInstance

    )
{
#if 0
    LPSTR               szEmail;
    DWORD               dwErr;
    LPSMTP_USER_PROPS   pUserProps;
    RTX_USER_PROPS      rtxuserprops;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetUserProps");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppUserProps, sizeof(LPSMTP_USER_PROPS)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    if (!pInstance->PRtx()->GetUserProps(szEmail, &rtxuserprops))
    {
        ErrorTrace(NULL, "GetUserProps call failed: %u", GetLastError());
        TCP_FREE(szEmail);
        pInstance->Dereference();
        return GetLastError();
    }
    TCP_FREE(szEmail);

    pUserProps = (LPSMTP_USER_PROPS) MIDL_user_allocate(sizeof(SMTP_USER_PROPS));

    if (!ConvertStringToRpc(&(pUserProps->wszForward), rtxuserprops.szForward))
    {
        ErrorTrace(NULL, "Unable to convert forward to rpc string: %u", GetLastError());
        MIDL_user_free(pUserProps);
        pInstance->Dereference();

        return GetLastError();
    }

    if (!ConvertStringToRpc(&(pUserProps->wszVRoot), rtxuserprops.szVRoot))
    {
        ErrorTrace(NULL, "Unable to convert vroot to rpc string: %u", GetLastError());
        FreeRpcString(pUserProps->wszForward);
        MIDL_user_free(pUserProps);
        pInstance->Dereference();

        return GetLastError();
    }

    pUserProps->dwMailboxMax = rtxuserprops.cbMailBoxSize;
    pUserProps->dwMailboxMessageMax = rtxuserprops.cbMailboxMessageSize;
    pUserProps->dwLocal = rtxuserprops.fLocal;
    pUserProps->fc = FC_SMTP_USER_PROPS_ALL;

    *ppUserProps = pUserProps;

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
#endif 

	return ERROR_INVALID_PARAMETER;
}



/*++

    Description:
        Sets a users properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprSetUserProps(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPSMTP_USER_PROPS       pUserProps,
    IN  DWORD                   dwInstance

    )
{
#if 0

    DWORD   dwErr;
    DWORD   dwErrKeep = NO_ERROR;
    LPSTR   szEmail = NULL;
    LPSTR   szForward = NULL;
    LPSTR   szVRoot = NULL;
    HANDLE  hToken;
    DWORD   cbRoot;
    char    szRoot[MAX_PATH + 1];
    BOOL    fSet;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprSetUserProps");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadReadPtr((LPVOID)pUserProps, sizeof(SMTP_USER_PROPS)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    if (!pUserProps->fc)
    {
        // Nothing to do...
        pInstance->Dereference();
        return NO_ERROR;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter checking
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pUserProps)
    {
        ErrorTrace(NULL, "Invalid parameter: pUserProps (NULL)\n");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    // More checking downstream ...

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_FORWARD))
    {
        fSet = TRUE;

        if (pUserProps->wszForward)
        {
            szForward = ConvertUnicodeToAnsi(pUserProps->wszForward, NULL, 0);
            if (!szForward)
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", pUserProps->wszForward, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
                fSet = FALSE;
            }
        }
        else
        {
            szForward = NULL;
        }

        // Parameter check for forward
        if (szForward &&
            !CAddr::ValidateEmailName(szForward))
        {
            ErrorTrace(NULL, "Invalid parameter: pconfig->pUserProps->wszForward (%s)\n",
                       (pUserProps->wszForward)?pUserProps->wszForward:L"NULL");
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = ERROR_INVALID_PARAMETER;
            fSet = FALSE;
        }

        if (fSet)
        {
            if (!pInstance->PRtx()->SetForward(szEmail, szForward))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to set forward for %s: %d", szEmail, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
            }
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_MAILBOX_SIZE))
    {
        if (!pInstance->PRtx()->SetMailboxSize(szEmail, pUserProps->dwMailboxMax))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to set mailbox size for %s: %d", szEmail, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_MAILBOX_MESSAGE_SIZE))
    {
        if (!pInstance->PRtx()->SetMailboxMessageSize(szEmail, pUserProps->dwMailboxMessageMax))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to set mailbox size for %s: %d", szEmail, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
        }
    }

    if (IsFieldSet(pUserProps->fc, FC_SMTP_USER_PROPS_VROOT))
    {
        fSet = TRUE;
        szVRoot = ConvertUnicodeToAnsi(pUserProps->wszVRoot, NULL, 0);
        if (!szVRoot)
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", pUserProps->wszVRoot, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
            fSet = FALSE;
        }

        DWORD dwAccessMask = 0;

        // Parameter checking for VRoot
        cbRoot = sizeof(szRoot);
        if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
                szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                &hToken, NULL))
        {
            dwErr = GetLastError();
            ErrorTrace(NULL, "Unable to resolve virtual root(%ls): %u", pUserProps->wszVRoot, dwErr);
            if (dwErrKeep == NO_ERROR)
                dwErrKeep = dwErr;
            fSet = FALSE;
        }

        if (fSet)
        {
            if (!pInstance->PRtx()->SetVRoot(szEmail, szVRoot))
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "Unable to set vroot for %s: %d", szEmail, dwErr);
                if (dwErrKeep == NO_ERROR)
                    dwErrKeep = dwErr;
            }
        }
    }

    if (szVRoot)
        TCP_FREE(szVRoot);
    if (szForward)
        TCP_FREE(szForward);
    TCP_FREE(szEmail);

    pInstance->Dereference();

    TraceFunctLeave();
    return dwErrKeep;

#endif
	return ERROR_INVALID_PARAMETER;
}



/*++

    Description:
        Creates a DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateDistList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwInstance

    )
{
#if 0
    DWORD   dwErr;
    LPSTR   szEmail;
    DWORD   dwRtxType;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateDistList");

    if(g_IsShuttingDown)
    {
        TraceFunctLeave();
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (dwType == NAME_TYPE_LIST_NORMAL)
        dwRtxType = rtxnameDistListNormal;
    else if (dwType == NAME_TYPE_LIST_SITE)
        dwRtxType = rtxnameDistListSite;
    else if (dwType == NAME_TYPE_LIST_DOMAIN)
        dwRtxType = rtxnameDistListDomain;
    else
    {
        ErrorTrace(NULL, "TYPE is not NAME_TYPE_LIST_NORMAL or NAME_TYPE_LIST_SITE");
        pInstance->Dereference();
        TraceFunctLeave();
        return ERROR_INVALID_PARAMETER;
    }


    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    if (!pInstance->PRtx()->CreateDistList(szEmail, dwRtxType))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to create list %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmail);
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;
#endif

	return ERROR_INVALID_PARAMETER;
}


/*++

    Description:
        Deletes a DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteDistList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    PSMTP_SERVER_INSTANCE pInstance;

    TraceFunctEnter("SmtprDeleteDistList");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->DeleteDistList(szEmail))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete list %s: %d", szEmail, dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Adds a member to the DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprCreateDistListMember(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszEmailMember,
    IN  DWORD                   dwInstance
    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szMember;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprCreateDistListMember");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmailMember, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();

        TraceFunctLeave();
        return dwErr;
    }

    szMember = ConvertUnicodeToAnsi(wszEmailMember, NULL, 0);
    if (!szMember)
    {
        dwErr = GetLastError();
	TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmailMember, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!CAddr::ValidateEmailName(szMember))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailMember (%ls)\n",
                   (wszEmailMember)?wszEmailMember:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->CreateDistListMember(szEmail, szMember))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to add member %s to %s: %d", szMember, szEmail, dwErr);
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szMember);
    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}


/*++

    Description:
        Deletes a member from the DL

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprDeleteDistListMember(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  LPWSTR                  wszEmailMember,
    IN  DWORD                   dwInstance

    )
{
    DWORD   dwErr;
    LPSTR   szEmail;
    LPSTR   szMember;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprDeleteDistListMember");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmailMember, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    szMember = ConvertUnicodeToAnsi(wszEmailMember, NULL, 0);
    if (!szMember)
    {
        dwErr = GetLastError();
	TCP_FREE(szEmail);
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmailMember, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter check
    if (!CAddr::ValidateEmailName(szEmail))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!CAddr::ValidateEmailName(szMember))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailMember (%ls)\n",
                   (wszEmailMember)?wszEmailMember:L"NULL");
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
#if 0
    if (!pInstance->PRtx()->DeleteDistListMember(szEmail, szMember))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to delete member %s from %s: %d", szMember, szEmail, dwErr);
        TCP_FREE(szMember);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }
#endif

    TCP_FREE(szMember);
    TCP_FREE(szEmail);

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;
}



/*++

    Description:
        Sets DL properties

   Note:

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtprGetNameList(
    IN  LPWSTR                  wszServer,
    IN  LPWSTR                  wszEmail,
    IN  DWORD                   dwType,
    IN  DWORD                   dwRowsReq,
    IN  BOOL                    fForward,
    OUT LPSMTP_NAME_LIST        *ppNameList,
    IN  DWORD                   dwInstance

    )
{
#if 0

    DWORD               dwErr;
    HRTXENUM            hrtxenum;
    LPSTR               szEmail;
    DWORD               crowsReturned;
    DWORD               cbAlloc;
    DWORD               irows;
    LPSMTP_NAME_LIST    pNameList;
    DWORD               dwFlags;
    DWORD               cbNameEntry;
    char                szName[cbEmailNameMax];
    PSMTP_SERVER_INSTANCE pInstance;

    TraceFunctEnter("SmtprGetNameList");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppNameList, sizeof(LPSMTP_NAME_LIST)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    // Up front parameter check
    if (!pValidateRange(dwType, 1,15))
    {
        ErrorTrace(NULL, "Invalid parameter: dwType (%u)\n",
                   dwType);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(dwRowsReq, 1, 100))
    {
        ErrorTrace(NULL, "Invalid parameter: dwRowsReq (%u)\n",
                   dwRowsReq);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(fForward, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: fForward (%u)\n",
                   fForward);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!ppNameList)
    {
        ErrorTrace(NULL, "Invalid parameter: ppNameList (NULL)\n");
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }


    // More checks downstream

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d", wszEmail, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    // Parameter change
    if (szEmail[0] != 0 &&
            szEmail[0] != '@' &&
                !CAddr::ValidateEmailName(szEmail, TRUE))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwFlags = 0;
    if (dwType & NAME_TYPE_USER)
        dwFlags |= rtxnameUser;
    if (dwType & NAME_TYPE_LIST_NORMAL)
        dwFlags |= rtxnameDistListNormal;
    if (dwType & NAME_TYPE_LIST_SITE)
        dwFlags |= rtxnameDistListSite;
    if (dwType & NAME_TYPE_LIST_DOMAIN)
        dwFlags |= rtxnameDistListDomain;

    if (!pInstance->PRtx()->EnumNameList(szEmail, fForward, dwRowsReq, dwFlags, &hrtxenum))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to enum name list: %d", dwErr);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmail);

    crowsReturned = pInstance->PRtx()->EnumRowsReturned(hrtxenum);
    cbAlloc = sizeof(SMTP_NAME_LIST) + crowsReturned * sizeof(SMTP_NAME_ENTRY);

    pNameList = (LPSMTP_NAME_LIST)MIDL_user_allocate(cbAlloc);
    ZeroMemory(pNameList, cbAlloc);
    pNameList->cEntries = crowsReturned;

    for (irows = 0 ; irows < crowsReturned ; irows++)
    {
        cbNameEntry = cbEmailNameMax;
        if (!pInstance->PRtx()->GetNextEmail(hrtxenum, &(dwFlags),
                szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "GetNext failed on row %u: %u", irows, dwErr);
            pInstance->Dereference();
            return dwErr;
        }

        if (dwFlags & rtxnameUser)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_USER;
        if (dwFlags & rtxnameDistListNormal)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_NORMAL;
        if (dwFlags & rtxnameDistListSite)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_SITE;
        if (dwFlags & rtxnameDistListDomain)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_DOMAIN;

        if (!ConvertStringToRpc(&(pNameList->aNameEntry[irows].lpszName), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", szName, dwErr);
            pInstance->Dereference();
            return dwErr;
        }
    }

    _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
    _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));

    *ppNameList = pNameList;
    pInstance->Dereference();

    TraceFunctLeave();
    return NO_ERROR;

#endif

	return ERROR_INVALID_PARAMETER;
}



NET_API_STATUS
NET_API_FUNCTION
SmtprGetNameListFromList(
    IN  SMTP_HANDLE         wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN  DWORD                   dwInstance

    )
/*++

   Description

       Performs a search within a list

   Arguments:

       wszServer - unused
       wszEmailList - Email list to search from
       wszEmail - Email name to search for
       dwType - Type of the Email name supplied
       dwRowsRequested - Number of rows requested
       fForward -
       ppNameList - pointer to pointer to name list to return

   Note:

       This RPC is added by Keith Lau (keithlau) on 7/5/96

--*/
{

#if 0
    DWORD               dwErr;
    HRTXENUM            hrtxenum;
    LPSTR               szEmail;
    LPSTR               szEmailList;
    DWORD               crowsReturned;
    DWORD               cbAlloc;
    DWORD               irows;
    LPSMTP_NAME_LIST    pNameList;
    DWORD               dwFlags;
    DWORD               cbNameEntry;
    char                szName[cbEmailNameMax];
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetNameListFromList");


    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszEmailList, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (!pValidateStringPtr(wszEmail, (AB_MAX_LOGIN + AB_MAX_FULL_EMAIL_WO_NULL + 2)))
        return(ERROR_INVALID_PARAMETER);
    if (IsBadWritePtr((LPVOID)ppNameList, sizeof(LPSMTP_NAME_LIST)))
        return(ERROR_INVALID_PARAMETER);

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    if (!pValidateRange(dwType, 1, 15))
    {
        ErrorTrace(NULL, "Invalid parameter: dwType (%u)\n",
                   dwType);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(dwRowsRequested, 1, 100))
    {
        ErrorTrace(NULL, "Invalid parameter: dwRowsRequested (%u)\n",
                   dwRowsRequested);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!pValidateRange(fForward, 0, 1))
    {
        ErrorTrace(NULL, "Invalid parameter: fForward (%u)\n",
                   fForward);
        pInstance->Dereference();

        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (!ppNameList)
    {
        ErrorTrace(NULL, "Invalid parameter: ppNameList (NULL)\n");
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    DebugTrace(NULL, "Email list name: %ls", wszEmailList);
    szEmailList = ConvertUnicodeToAnsi(wszEmailList, NULL, 0);
    if (!szEmailList)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszEmailList, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (!CAddr::ValidateEmailName(szEmailList))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmailList (%ls)\n",
                   (wszEmailList)?wszEmailList:L"NULL");
        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(NULL, "Email name: %ls", wszEmail);
    szEmail = ConvertUnicodeToAnsi(wszEmail, NULL, 0);
    if (!szEmail)
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszEmail, dwErr);

        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (szEmail[0] != 0 &&
            szEmail[0] != '@' &&
                !CAddr::ValidateEmailName(szEmail, TRUE))
    {
        ErrorTrace(NULL, "Invalid parameter: wszEmail (%ls)\n",
                   (wszEmail)?wszEmail:L"NULL");
        TCP_FREE(szEmail);
        TCP_FREE(szEmailList);
        pInstance->Dereference();
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    dwFlags = 0;
    if (dwType & NAME_TYPE_USER)
        dwFlags |= rtxnameUser;
    if (dwType & NAME_TYPE_LIST_NORMAL)
        dwFlags |= rtxnameDistListNormal;
    if (dwType & NAME_TYPE_LIST_SITE)
        dwFlags |= rtxnameDistListSite;
    if (dwType & NAME_TYPE_LIST_DOMAIN)
        dwFlags |= rtxnameDistListDomain;

    if (!pInstance->PRtx()->EnumNameListFromDL(szEmailList,
                                    szEmail,
                                    fForward,
                                    dwRowsRequested,
                                    dwFlags,
                                    &hrtxenum))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to enum name list: %d", dwErr);
        TCP_FREE(szEmailList);
        TCP_FREE(szEmail);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szEmailList);
    TCP_FREE(szEmail);

    crowsReturned = pInstance->PRtx()->EnumRowsReturned(hrtxenum);
    cbAlloc = sizeof(SMTP_NAME_LIST) + crowsReturned * sizeof(SMTP_NAME_ENTRY);

    pNameList = (LPSMTP_NAME_LIST)MIDL_user_allocate(cbAlloc);
    ZeroMemory(pNameList, cbAlloc);
    pNameList->cEntries = crowsReturned;

    for (irows = 0 ; irows < crowsReturned ; irows++)
    {
        cbNameEntry = cbEmailNameMax;
        if (!pInstance->PRtx()->GetNextEmail(hrtxenum, &(dwFlags), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "GetNext failed on row %u: %u", irows, dwErr);
            pInstance->Dereference();
            return dwErr;
        }

        if (dwFlags & rtxnameUser)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_USER;
        if (dwFlags & rtxnameDistListNormal)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_NORMAL;
        if (dwFlags & rtxnameDistListSite)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_SITE;
        if (dwFlags & rtxnameDistListDomain)
            pNameList->aNameEntry[irows].dwType = NAME_TYPE_LIST_DOMAIN;

        if (!ConvertStringToRpc(&(pNameList->aNameEntry[irows].lpszName), szName))
        {
            dwErr = GetLastError();
            _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
            _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));
            for (irows = 0 ; irows < crowsReturned ; irows++)
            {
                if (pNameList->aNameEntry[irows].lpszName)
                    FreeRpcString(pNameList->aNameEntry[irows].lpszName);
            }

            MIDL_user_free(pNameList);
            ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", szName, dwErr);
            pInstance->Dereference();
            return dwErr;
        }
    }

    _VERIFY(pInstance->PRtx()->EndEnumResult(hrtxenum));
    _VERIFY(pInstance->PRtx()->FreeHrtxenum(hrtxenum));

    *ppNameList = pNameList;

    pInstance->Dereference();
    TraceFunctLeave();
    return NO_ERROR;

#endif

	return ERROR_INVALID_PARAMETER;
}

NET_API_STATUS
NET_API_FUNCTION
SmtprGetVRootSize(
    IN  SMTP_HANDLE     wszServerName,
    IN  LPWSTR          wszVRoot,
    OUT LPDWORD         pdwBytes,
    IN  DWORD           dwInstance

    )
/*++

   Description

       Obtains the size of the specified VRoot

   Arguments:

       wszServer - unused
       wszVRoot - VRoot whose size to return
       pdwBytes - Pointer to a DWORD to contain the VRoot size on return

   Return Value:

       This call returns NO_ERROR on success. ERROR_INVALID_NAME is returned
       if ResolveVirtualRoot returns an invalid directory name. A Win32
       error code is returned for other error conditions.

   Note:

       This RPC is added by Keith Lau (keithlau) on 7/5/96

--*/
{
    HANDLE          hToken;
    DWORD           cbRoot;
    LPSTR           szVRoot;
    char            szRoot[MAX_PATH + 1];
    DWORD           dwErr;
    ULARGE_INTEGER  uliBytesAvail;
    ULARGE_INTEGER  uliBytesTotal;
    ULARGE_INTEGER  uliBytesFree;
    DWORD dwAccessMask = 0;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprGetVRootSize");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszVRoot, AB_MAX_VROOT))
    {
        ErrorTrace(NULL, "Invalid parameter: wszVRoot\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    if (IsBadWritePtr((LPVOID)pdwBytes, sizeof(DWORD)))
    {
        ErrorTrace(NULL, "Invalid parameter: pdwBytes\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    // Default the size to 0 bytes free
    *pdwBytes = 0;
    dwErr = NO_ERROR;

    // Access check
    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    // Resolve the Virtual Root, need Unicode - ANSI conversion
    cbRoot = sizeof(szRoot);
    DebugTrace(NULL, "VRoot name: %ls", wszVRoot);
    if (!(szVRoot = ConvertUnicodeToAnsi(wszVRoot, NULL, 0)))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszVRoot, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if(!pInstance->QueryVrootTable()->LookupVirtualRoot(
        szVRoot, szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
        &hToken, NULL))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "ResolveVirtualRoot failed for %s, %u", wszVRoot, dwErr);
        TCP_FREE(szVRoot);
    }
    else
    {
        // Free it right away lest we forget
        TCP_FREE(szVRoot);

        DebugTrace(NULL, "Getting free disk ratio on %s", szRoot);
        if (hToken == 0 || ImpersonateLoggedOnUser(hToken))
        {
            if (GetDiskFreeSpaceEx(szRoot,
                                   &uliBytesAvail,
                                   &uliBytesTotal,
                                   &uliBytesFree))
            {
                // Make sure we are not overflowing 4Gig, which is easy
                _ASSERT(uliBytesAvail.HighPart == 0);
                *pdwBytes = uliBytesAvail.LowPart;
            }
            else
            {
                dwErr = GetLastError();
                ErrorTrace(NULL, "GetDiskFreeSpaceEx failed on %s: %u", szRoot, dwErr);
            }

            if (hToken != 0)
                _VERIFY(RevertToSelf());
        }
        else
        {
            ErrorTrace(NULL, "Impersonation failed");
            dwErr = GetLastError();
        }
    }

    pInstance->Dereference();
    TraceFunctLeave();
    return dwErr;
}




NET_API_STATUS
NET_API_FUNCTION
SmtprBackupRoutingTable(
    IN  SMTP_HANDLE     wszServerName,
    IN  LPWSTR          wszPath,
    IN  DWORD           dwInstance

    )
/*++

   Description

       Tells routing table to backup itself to the given path

   Arguments:

       wszServer - unused
       wszVRoot - Path to put backup file

   Return Value:

       This call returns NO_ERROR on success. Routing table error
       if routing table cannot create the backup

--*/
{

#if 0
    DWORD           dwErr;
    LPSTR           szBackupDir = NULL;
    PSMTP_SERVER_INSTANCE pInstance;


    TraceFunctEnter("SmtprBackupRoutingTable");

    if(g_IsShuttingDown)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    if (!pValidateStringPtr(wszPath, MAX_PATH))
    {
        ErrorTrace(NULL, "Invalid parameter: wszPath\n");
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }

    pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
    if(pInstance == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = NO_ERROR;

    // Access check
    dwErr = TsApiAccessCheck(TCP_QUERY_ADMIN_INFORMATION);
    if (dwErr != NO_ERROR)
    {
        ErrorTrace(NULL, "Access check failed: %u", dwErr);
        pInstance->Dereference();
        return dwErr;
    }

    if (pInstance->PRtx()->GetRtType() != rttypeFF)
    {
        ErrorTrace(NULL, "Backup for non-FF routing table isn't allowed!");
        pInstance->Dereference();
        return ERROR_NOT_SUPPORTED;
    }

    if (!(szBackupDir = ConvertUnicodeToAnsi(wszPath, NULL, 0)))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to ConvertUnicodeToAnsi(%ls): %d",
                         wszPath, dwErr);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    if (!pInstance->PRtx()->MakeBackup(szBackupDir))
    {
        dwErr = GetLastError();
        ErrorTrace(NULL, "Unable to complete backup to %s: %d", szBackupDir, dwErr);
        TCP_FREE(szBackupDir);
        pInstance->Dereference();
        TraceFunctLeave();
        return dwErr;
    }

    TCP_FREE(szBackupDir);

    pInstance->Dereference();
    TraceFunctLeave();
    return dwErr;
#endif

	return ERROR_INVALID_PARAMETER;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\cleanback.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cleanback.h
//
// Contents: Implements Cleanup callback interface
//
// Classes: CCleanBack
//
// Description: The intention is this object will be used as a part of
//              other objects (member variable or inheritence).
//              Therefore, the IUnknown passed in is NOT referenced.
//
// History:
// jstamerj 1999/09/27 17:58:50: Created.
//
//-------------------------------------------------------------
#include "mailmsg.h"
#include "spinlock.h"

class CCleanBack :
    public IMailMsgRegisterCleanupCallback
{
  public:
    CCleanBack(IUnknown *pUnknown)
    {
        m_pListHead = NULL;
        m_pIUnknown = pUnknown;
        InitializeSpinLock(&m_spinlock);
    }
    ~CCleanBack()
    {
        CallCallBacks();
    }
    VOID CallCallBacks()
    {
        //
        // Call all registered callbacks while destroying the list
        //
        CCallBack *pCallback;

        while(m_pListHead) {
            //
            // Dequeue from head of list
            //
            AcquireSpinLock(&m_spinlock);

            pCallback = m_pListHead;
            if(pCallback)
                m_pListHead = pCallback->GetNext();

            ReleaseSpinLock(&m_spinlock);
            //
            // Make the call
            //
            if(pCallback) {
                pCallback->Call(m_pIUnknown);
                delete pCallback;
            }
        }
    }        

    STDMETHOD (RegisterCleanupCallback) (
        IMailMsgCleanupCallback *pICallBack,
        PVOID                    pvContext)
    {
        CCallBack *pCCallBack;

        if(pICallBack == NULL)
            return E_POINTER;

        pCCallBack = new CCallBack(
            pICallBack,
            pvContext);

        if(pCCallBack == NULL)
            return E_OUTOFMEMORY;

        //
        // Insert object into list
        //
        AcquireSpinLock(&m_spinlock);
        pCCallBack->SetNext(m_pListHead);
        m_pListHead = pCCallBack;
        ReleaseSpinLock(&m_spinlock);

        return S_OK;
    }

    
    class CCallBack {

      public:
        CCallBack(IMailMsgCleanupCallback *pICallBack, PVOID pvContext)
        {
            m_pICallBack = pICallBack;
            m_pICallBack->AddRef();
            m_pvContext = pvContext;
            m_pNext = NULL;
        }
        ~CCallBack()
        {
            m_pICallBack->Release();
        }
        VOID Call(IUnknown *pIUnknown)
        {
            m_pICallBack->CleanupCallback(
                pIUnknown,
                m_pvContext);
        }
        VOID SetNext(CCallBack *pCCallBack)
        {
            m_pNext = pCCallBack;
        }
        CCallBack * GetNext()
        {
            return m_pNext;
        }

      private:
        IMailMsgCleanupCallback *m_pICallBack;
        PVOID m_pvContext;
        CCallBack *m_pNext;
    };
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        PVOID *ppv)
    {
        return m_pIUnknown->QueryInterface(
            iid,
            ppv);
    }
    STDMETHOD_ (ULONG, AddRef) ()
    {
        return m_pIUnknown->AddRef();
    }
    STDMETHOD_ (ULONG, Release) ()
    {
        return m_pIUnknown->Release();
    }

  private:
    SPIN_LOCK m_spinlock;
    CCallBack *m_pListHead;
    IUnknown *m_pIUnknown;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\cbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cbuffer.h
//
//  Contents:   CHAR buffer definitions
//
//  History:    02-16-93    SethuR -- Implemented
//              07-28-94    AlokS  -- Added more methods
//              12-09-97    MilanS -- Ported to Exchange
//              01-18-99    MikeSwa -- Fixed Cat()
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __CBUFFER_H__
#define __CBUFFER_H__

//+---------------------------------------------------------------------
//
// Class:   CCHARBuffer
//
// Purpose: A CHAR buffer
//
// History:
//
// Notes:   Very often we encounter the case in string manipulation wherein
//          the length of the string is less than some value most of the time
//          (99%). However, in order to reliably with the very rare case we
//          are forced to either allocate the string on the heap or alternatively
//          go through some bizarre code that avoids the heap allocation in the
//          common case. This class is an abstraction of a WCHAR buffer and its
//          implementation is an attempt at hiding the detail from all clients.
//
//          As it is designed it is an ideal candidate for a temporary buffer
//          for string manipulation.
//
//----------------------------------------------------------------------

#define MAX_CHAR_BUFFER_SIZE 260 // long enough to cover all path names

class CCHARBuffer
{
public:

    inline CCHARBuffer(ULONG cwBuffer = 0);
    inline ~CCHARBuffer();

    inline DWORD    Size();
    inline PCHAR   ReAlloc(DWORD cwBuffer = MAX_CHAR_BUFFER_SIZE);
    inline void     Set(PWCHAR pwszFrom);
    inline void     Set(PCHAR  pszFrom);
    inline BOOL     Cat(PCHAR pszPlus);

    inline      operator PCHAR ();
    inline      operator PCHAR () const;

    inline void operator  =(PWCHAR pwszFrom)
    {
        Set(pwszFrom);
    };

    inline void operator  =(PCHAR  pszFrom)
    {
        Set(pszFrom);
    };

private:

    DWORD   _cBuffer;
    PCHAR   pchBuffer;    // buffer ptr;
    CHAR   _achBuffer[MAX_CHAR_BUFFER_SIZE];
};

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::CCHARBuffer, inline public
//
//  Synopsis:   Constructor
//
//  Arguments:  [cBuffer]   -- desired buffer length.
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::CCHARBuffer(ULONG cBuffer) :
                     pchBuffer(NULL),
                     _cBuffer(cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::~CCHARBuffer, inline public
//
//  Synopsis:   Destructor
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::~CCHARBuffer()
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Size, inline public
//
//  Synopsis:   Retrieve the size of the buffer
//
//  Returns:    the size of the buffer as a DWORD
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline DWORD CCHARBuffer::Size()
{
    return _cBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::ReAlloc, inline public
//
//  Synopsis:   Reallocates the buffer to accomdate the newly specified size
//
//  Arguments:  [cBuffer] -- the desired buffer size
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline PCHAR CCHARBuffer::ReAlloc(DWORD cBuffer)
{
    if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
    {
        delete pchBuffer;
    }

    if ((_cBuffer = cBuffer) > MAX_CHAR_BUFFER_SIZE)
    {
        pchBuffer = new CHAR[_cBuffer];
    }
    else if (_cBuffer > 0)
    {
        pchBuffer = _achBuffer;
    }
    else if (_cBuffer == 0)
    {
        pchBuffer = NULL;
    }

    return pchBuffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::operator PCHAR (), inline public
//
//  Synopsis:   casting operator to accomdate syntactic sugaring
//
//  Returns:    the ptr to the buffer (PCHAR)
//
//  History:    02-17-93  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline CCHARBuffer::operator PCHAR ()
{
    return (PCHAR)pchBuffer;
}

inline CCHARBuffer::operator PCHAR () const
{
    return (PCHAR)pchBuffer;
}
//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pwszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PWCHAR pwszFrom)
{
    if (pwszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pwszFrom)
    {
        DWORD len = wcslen(pwszFrom)+1;
        if (len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        wcstombs(pchBuffer, pwszFrom, len);
    }
    else
    {
        *pchBuffer='\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Set, inline public
//
//  Synopsis:   Copies the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszFrom] -- Pointer to the string
//
//  Returns:    -none-
//
//  History:    07-28-94  AlokS Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline VOID CCHARBuffer::Set(PCHAR pszFrom)
{
    if (pszFrom==NULL)
    {
        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        _cBuffer=0;
        pchBuffer = NULL;
    }
    else if (*pszFrom)
    {
        DWORD len = strlen(pszFrom)+1;
        if ( len > _cBuffer)
        {
            (void)ReAlloc (len);
        }
        // Now copy
        memcpy(pchBuffer, pszFrom, len);
    }
    else
    {
        *pchBuffer=L'\0';
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCHARBuffer::Cat, inline public
//
//  Synopsis:   Concatnates the string to internal buffer. Reallocates
//              in internal buffer, if necessary
//
//  Arguments:  [pszPlus] -- Pointer to the string
//
//  Returns:    TRUE on success
//              FALSE if memory allocation failed
//
//  History:    07-28-94  AlokS Created
//              01-18-99  Mikeswa Fixed AV in checkin allocated ptr
//
//  Notes:
//
//----------------------------------------------------------------------------

inline BOOL CCHARBuffer::Cat(PCHAR pszFrom)
{
    DWORD  len1 = strlen(pchBuffer),
           len2 = strlen(pszFrom),
           len3 = len1+len2 + 1;

    if ( len3 > MAX_CHAR_BUFFER_SIZE)
    {
        PCHAR ptr = new CHAR [len3];

        //Avoid AV'ing
        if (!ptr)
            return FALSE;

        memcpy(ptr, pchBuffer, len1);

        if (_cBuffer > MAX_CHAR_BUFFER_SIZE)
        {
            delete pchBuffer;
        }
        pchBuffer = ptr;
    }
    memcpy( ((LPWSTR)(pchBuffer)+len1), pszFrom, (len2+1) * sizeof(CHAR));
    _cBuffer = len3;
    return TRUE;
}
#endif // __CBUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\base64.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name:
      base64.cxx

   Abstract:
      This module supports functions for file caching for servers

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Oct-1995

   Environment:

       Win32 Apps

   Project:

       Internet Services Common  DLL

   Functions Exported:



   Revision History:
     Obtained from old inetsvcs.dll

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <iis64.h>

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
	int nbytesin = 0;
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

	/*NimishK ** : If it aint divisible by 4 it aint base 64 */
	if(!fBase64)
	{
		nbytesin = lstrlen(bufcoded);
		if(nbytesin % 4)
			return FALSE;
	}

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}
/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\conn.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        conn.cxx

   Abstract:

        This module defines the functions for base class of connections
        for Internet Services  ( class CLIENT_CONNECTION)

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

           Gibraltar Services Common Code

   Functions Exported:

          CLIENT_CONNECTION::Initialize()
          CLIENT_CONNECTION::Cleanup()
          CLIENT_CONNECTION::~CLIENT_CONNECTION()
          BOOL CLIENT_CONNECTION::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)
          VOID CLIENT_CONNECTION::DisconnectClient( IN DWORD ErrorReponse)

          BOOL CLIENT_CONNECTION::StartupSession( VOID)
          BOOL CLIENT_CONNECTION::ReceiveRequest(
                                               OUT LPBOOL pfFullRequestRecd)

          BOOL CLIENT_CONNECTION::ReadFile( OUT LPVOID pvBuffer,
                                            IN  DWORD  dwSize)
          BOOL CLIENT_CONNECTION::WriteFile( IN LPVOID pvBuffer,
                                             IN DWORD  dwSize)
          BOOL CLIENT_CONNECTION::TransmitFile( IN HANDLE hFile,
                                                IN DWORD cbToSend)
          BOOL CLIENT_CONNECTION::PostCompletionStatus( IN DWORD dwBytes )

   Revision History:
   Revision History:
           Richard Kamicar   ( rkamicar )  31-Dec-1995
                Moved to common directory, filled in more

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "conn.hxx"



/************************************************************
 *    Functions
 ************************************************************/



/*++

   ICLIENT_CONNECTION::Initialize()

      Constructor for ICLIENT_CONNECTION object.
      Initializes the fields of the client connection.

   Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

   Note:
      TO keep the number of connected users <= Max connections specified.
      Make sure to add this object to global list of connections,
       after creating it.
      If there is a failure to add to global list, delete this object.

--*/

CLIENT_CONNECTION::Initialize(
    IN SOCKET              sClient,
    IN const SOCKADDR_IN * psockAddrRemote,
    IN const SOCKADDR_IN * psockAddrLocal  /* Default  = NULL */,
    IN PATQ_CONTEXT        pAtqContext     /* Default  = NULL */,
    IN PVOID               pvInitialRequest/* Default  = NULL */,
    IN DWORD               cbInitialData   /* Default  = 0    */
    )
{
    DWORD dwError = NO_ERROR;


    m_sClient        = ( sClient);
    m_pAtqContext    = pAtqContext;
    m_cbReceived = 0;
    m_pvInitial    = pvInitialRequest;
    m_cbInitial    = cbInitialData;
    m_Destroy = FALSE;

    _ASSERT( psockAddrRemote != NULL);

    m_saClient = *psockAddrRemote;

    //  Obtain the socket addresses for the socket
    m_pchRemoteHostName[0] =
    m_pchLocalHostName[0] =
    m_pchLocalPortName[0] = '\0';

    // InetNtoa() wants just 16 byte buffer.
    _ASSERT( 16 <= MAX_HOST_NAME_LEN);
    dwError = InetNtoa( psockAddrRemote->sin_addr, m_pchRemoteHostName);

    _ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer

    if ( psockAddrLocal != NULL)
    {
      dwError = InetNtoa( psockAddrLocal->sin_addr, m_pchLocalHostName);
      _itoa( ntohs(psockAddrLocal->sin_port), m_pchLocalPortName, 10);
    } else
    {
        SOCKADDR_IN  sockAddr;
        int cbAddr = sizeof( sockAddr);

        if ( getsockname( sClient,
                         (struct sockaddr *) &sockAddr,
                         &cbAddr ))
        {

            dwError = InetNtoa( sockAddr.sin_addr, m_pchLocalHostName );
            _itoa( ntohs(sockAddr.sin_port), m_pchLocalPortName, 10);

        }
    }

   // DBG_ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer

#if 0
    DBG_CODE(
             if ( dwError != NO_ERROR) {

                 DBGPRINTF( ( DBG_CONTEXT,
                             "Obtaining Local Host Name Failed. Error = %u\n",
                             dwError)
                           );
                 SetLastError( dwError);
             }
             );

    DEBUG_IF( CLIENT, {

     DBGPRINTF( ( DBG_CONTEXT,
                    " Constructed ICLIENT_CONNECTION object ( %08x)."
                    " Socket (%d), Host (%s).\n",
                    this,
                    sClient,
                    QueryClientHostName()
                    ));
    });

#endif

    return ( TRUE);

}


/*++
     ICLIENT_CONNECTION::Cleanup()

       Destructor function for client connection object.
       Checks and frees the AtqContext.

    Note:
       If enlisted in the global list of connections,
        ensure that this object is freed from that list before deletion.

--*/
VOID CLIENT_CONNECTION::Cleanup( VOID)
{
  PATQ_CONTEXT pAtqContext;

  if(m_DoCleanup)
  {
    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       AtqFreeContext( pAtqContext, TRUE );
    }
  }

} // ICLIENT_CONNECTION::Cleanup()


/*++

    Description:

        Checks to see if we have received the complete request from the client.
        ( A complete request is a line of text terminated by <cr><lf> )
        if a CRLF is found, it returns a pointer into the buffer were the CR
        starts, else it returns NULL.  If this routine finds a CR without a
        LF it will return NULL

    Arguments:

        InputBuffer       pointer to character buffer containing received data.

        cbRecvd         count of bytes of data received

    Returns:

       a pointer to the CR if CRLF is found
       NULL if CRLF is not found.

--*/
//  VIRTUAL
char * CLIENT_CONNECTION::IsLineComplete(IN OUT const char * InputBuffer, IN  DWORD cbRecvd)
{
    register DWORD Loop = 0;

    _ASSERT(InputBuffer != NULL);

    //we need at least 2 bytes to find a
    //CRLF pair
    if( ((int) cbRecvd) < 2)
     return NULL;

    //we are going to start at the 2nd byte
    //looking for the LF, then look backwards
    //for the CR
    Loop = 1;

    while (Loop < cbRecvd)
    {
        if(InputBuffer[Loop] == LF)
        {
            if(InputBuffer[Loop - 1] == CR)
                return (char *) &InputBuffer[Loop - 1];
            else
            {
                //skip 2 bytes since we saw a LF
                //without a CR.
                Loop += 2;
            }
        }
        else if(InputBuffer[Loop] == CR)
        {
            //we saw a CR, so increment out
            //loop variable by one so that
            //we can catch the LF on the next
            //go around
            Loop += 1;
        }
        else
        {
            //This character is neither a CR
            //or a LF, so we can increment by
            //2
            Loop += 2;
        }
    }

    //didn't find a CRLF pair
    return NULL;
}

/*++

    Description:

        VIRTUAL Method that MUST be defined by the derived class

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       fIOCompletion      TRUE if this was an IO completion


    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::ProcessClient( IN DWORD cbWritten, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    return ( TRUE);
} // CLIENT_CONNECTION::ProcessClient()


/*++

    Reads contents using ATQ into the given buffer.
     ( thin wrapper for ATQ call and managing references)

    Arguments:

      pvBuffer      pointer to buffer where to read in the contents

      cbSize        size of the buffer

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    if(INVALID_SOCKET == m_sClient)
        return FALSE;

    ZeroMemory(&m_Overlapped, sizeof(OVERLAPPED));

    return  AtqReadFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        &m_Overlapped) ;
}


/*++

    Writes contents from given buffer using ATQ.
     ( thin wrapper for ATQ call and managing references)

    Arguments:

      pvBuffer      pointer to buffer containing contents for write

      cbSize        size of the buffer

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::WriteFile( IN LPVOID pBuffer, IN DWORD cbSize )
{
    BOOL    fReturn = TRUE;
    int     BytesAlreadySent = 0;
    DWORD   BytesSent;
    DWORD   dwError = NO_ERROR;
    DWORD   cTimesBlocked = 0;
    DWORD   dwSleepTime = 1000;

    _ASSERT(pBuffer != NULL);

    for (BytesSent = 0; BytesSent < cbSize; BytesSent += BytesAlreadySent)
    {
        BytesAlreadySent = send(m_sClient,
                                (const char FAR *) pBuffer + BytesSent,
                                (int) (cbSize - BytesSent),
                                0);
        if (BytesAlreadySent == SOCKET_ERROR)
        {
            //The above send will fail with WSAEWOULDBLOCK when
            //the TCP buffer is full...  this can easily happen for blob
            //protocol sinks.  The correct thing to do is rely on memory 
            //instead of TCP buffers to store pending sends, but the 
            //low impact work-around is to sleep after we would block
            dwError = GetLastError();
            if ((WSAEWOULDBLOCK == dwError) && (cTimesBlocked < 500))
            {
                SetLastError(NO_ERROR);
                cTimesBlocked++;
                BytesAlreadySent = 0;
                Sleep(dwSleepTime);
                dwSleepTime += dwSleepTime;
                continue;
            }
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}

BOOL CLIENT_CONNECTION::WriteSocket( IN SOCKET Sock, IN LPVOID pBuffer, IN DWORD cbSize )
{
    BOOL    fReturn = TRUE;
    int     BytesAlreadySent = 0;
    DWORD   BytesSent;

    _ASSERT(pBuffer != NULL);

    for (BytesSent = 0; BytesSent < cbSize; BytesSent += BytesAlreadySent)
    {
        BytesAlreadySent = send(Sock,
                                (const char FAR *) pBuffer + BytesSent,
                                (int) (cbSize - BytesSent),
                                0);
        if (BytesAlreadySent == SOCKET_ERROR)
        {
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}



/*++

    Writes contents from given buffer using ATQ.
     (thin wrapper for ATQ call and managing references)

    Arguments:

      Pov      pointer to OVERLAPPED structure describing the write

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::WriteFile(
    IN  LPVOID      lpvBuffer,
    IN  DWORD       cbSize,
    IN  OVERLAPPED  *lpo)
{
    BOOL  fReturn = TRUE;

    _ASSERT(lpo != NULL);
    _ASSERT(lpvBuffer != NULL);
    _ASSERT(cbSize != 0);

    fReturn = AtqWriteFile(m_pAtqContext, lpvBuffer, cbSize, lpo);
    return fReturn;
}


/*++

    Transmits contents of the file ( of specified size)
     using the ATQ and client socket.
     ( thin wrapper for ATQ call and managing references)

    Arguments:

      hFile         handle for file to be transmitted

      liSize        large integer containing the size of file

      lpTransmitBuffers
        buffers containing the head and tail buffers that
            need to be transmitted along with the file.

    Returns:

      TRUE on success and FALSE on a failure.

--*/

BOOL CLIENT_CONNECTION::TransmitFile(
    IN  HANDLE                  hFile,
    IN  LARGE_INTEGER           &liSize,
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers
    )
{
    _ASSERT(hFile != INVALID_HANDLE_VALUE);
    _ASSERT(liSize.QuadPart > 0);

    return  AtqTransmitFile(
                        m_pAtqContext,              // Atq context
                        hFile,                      // file data comes from
                        (DWORD) liSize.LowPart,                     // Bytes To Send
                        lpTransmitBuffers,          // header/tail buffers
                        0                           // Flags
                        );
}


//+------------------------------------------------------------
//
// Function: CLIENT_CONNECTION::PostCompletionStatus
//
// Synopsis: Wrapper around atq for posting completion status
//
// Arguments:
//  dwBytes: The number of bytes to indicate in the completion status
//
// Returns:
//  TRUE: Success
//  FALSE: Failure
//
// History:
// jstamerj 1998/11/03 20:16:17: Created.
//
//-------------------------------------------------------------
BOOL CLIENT_CONNECTION::PostCompletionStatus(
    IN  DWORD   dwBytes)
{
    return AtqPostCompletionStatus(
        m_pAtqContext,
        dwBytes);
}


/*++

    Starts up a session for new client.
    Adds the client socket to the ATQ completion port and gets an ATQ context.
    Then prepares  receive buffer and starts off a receive request from client.
      ( Also moves the client connection to CcsGettingRequest state)

    Parameters:
      pvInitial   pointer to void buffer containing the initial data
      cbWritten   count of bytes in the buffer

    Returns:

        TRUE on success and FALSE if there is any error.
--*/

//  VIRTUAL
BOOL CLIENT_CONNECTION::StartSession( void)
{
  return TRUE;
}


/*++

    Receive full Request from the client.
    If the entire request is received,
     *pfFullRequestRecvd will be set to TRUE and
     the request will be parsed.

    Arguments:

        cbWritten              count of bytes written in last IO operation.
        pfFullRequestRecvd     pointer to boolean, which on successful return
                                indicates if the full request was received.

    Returns:

        TRUE on success and
        FALSE if there is any error ( to abort this connection).

--*/

BOOL CLIENT_CONNECTION::ReceiveRequest(IN DWORD cbWritten, OUT LPBOOL pfFullRequestRecvd)
{
   return ( TRUE);
}

/*++

   Description:

       Initiates a disconnect operation for current connection.
       If already shutdown, this function returns doing nothing.
       Optionally if there is any error message to be sent, they may be sent

   Arguments:

      dwErrorCode
         error code for server errors if any ( Win 32 error code)
        If dwErrorCode != NO_ERROR, then there is a system level error code.
         by the REQUEST object. But the disconnection occurs immediately; Hence
         the REQUEST object should send synchronous error messages.

   Returns:
       None

--*/
VOID CLIENT_CONNECTION::DisconnectClient(IN DWORD dwErrorCode)
{
   SOCKET  hSocket;

   hSocket = (SOCKET)InterlockedExchangePointer( (PVOID *)&m_sClient, (PVOID) INVALID_SOCKET );
   if ( hSocket != INVALID_SOCKET )
   {
       if ( QueryAtqContext() != NULL )
       {
            AtqCloseSocket(QueryAtqContext() , (dwErrorCode == NO_ERROR));
       }
       else
       {
            ShutAndCloseSocket( m_sClient );
       }
   }
}



/*++

   Description:

       returns the client user name
       VIRTUAL function so apps can override its return value

   Arguments:

       void

   Returns:
       returns ptr to user name

--*/
LPCTSTR CLIENT_CONNECTION::QueryClientUserName( VOID )
{
    return   m_pchLocalHostName;
}



//
// Private Functions
//


# if DBG

//  VIRTUAL
VOID CLIENT_CONNECTION::Print( VOID) const
{


    return;

} // ICLIENT_CONNECTION::Print()


# endif // DBG


/*++

    Description:

       Performs a hard close on the socket using shutdown before close.

    Arguments:

       sock    socket to be closed

    Returns:

      0  if no errors  or
      socket specific error code

--*/

INT ShutAndCloseSocket( IN SOCKET sock)
{

    INT  serr = 0;

    //
    // Shut the socket. ( Assumes this to be a TCP socket.)
    //  Prevent future sends from occuring. hence 2nd param is "1"
    //

    if( sock != INVALID_SOCKET )
    {
      if ( shutdown( sock, 1) == SOCKET_ERROR)
        serr = WSAGetLastError();

      closesocket( sock);
    }

    return ( serr);

} // ShutAndCloseSocket()



/*++
    This function canonicalizes the path, taking into account the current
    user's current directory value.

    Arguments:
        pszDest   string that will on return contain the complete
                    canonicalized path. This buffer will be of size
                    specified in *lpdwSize.

        lpdwSize  Contains the size of the buffer pszDest on entry.
                On return contains the number of bytes written
                into the buffer or number of bytes required.

        pszSearchPath  pointer to string containing the path to be converted.
                    IF NULL, use the current directory only

    Returns:

        Win32 Error Code - NO_ERROR on success

    MuraliK   24-Apr-1995   Created.

--*/
BOOL
ResolveVirtualRoot(
        OUT CHAR *      pszDest,
    IN  OUT LPDWORD     lpdwSize,
    IN  OUT CHAR *      pszSearchPath,
        OUT HANDLE *    phToken /* = NULL */
    )
{
    TraceFunctEnter("ResolveVirtualRoot");

    _ASSERT(pszDest != NULL);
    _ASSERT(lpdwSize != NULL);
    _ASSERT(pszSearchPath != NULL);
    //
    // Now we have the complete symbolic path to the target file.
    //  Translate it into the absolute path
    //

#if 0
    if (!TsLookupVirtualRoot(g_pTsvcInfo->GetTsvcCache(),   // TSvcCache
                                pszSearchPath,              // pszRoot
                                pszDest,                    // pszDirectory
                                lpdwSize,                   // lpcbSize
                                NULL,                       // lpdwAccessMask
                                NULL,                       // pcchDirRoot
                                NULL,                       // pcchVroot
                                phToken,                    // phImpersonationToken
                                NULL,                       // pszAddress
                                NULL                        // lpdwFileSystem
                                ))
    {
        ErrorTrace(NULL, "TsLookupVirtualRoot failed looking for %s: %d", pszSearchPath, GetLastError());
        TraceFunctLeave();
        return FALSE;
    }
#endif

    TraceFunctLeave();
    return TRUE;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\buildq.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        buildq.cxx

   Abstract:
        Builds the initial queue during service startup

   Author:

           KeithLau     10/9/96

   Project:

          SMTP Server DLL

   Functions Exported:

   Revision History:

            dhowell     26/5/97  Added MCIS to K2 upgrade... rewrite envelope if required logic.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "buildq.hxx"
#include "headers.hxx"
//#include "pkuprtyq.hxx"
#include "timeconv.h"

#define MAX_INITIAL_THREADS         8


/************************************************************
 *    Threadprocs
 ************************************************************/

//
// Threadproc which builds up the initial queue of messages
//
DWORD BuildInitialQueueProc(void *lpThis);

//
// Threadproc which delivers the queued messages
// 
VOID ProcessInitialQueueObjects(PVOID       pvContext, 
                                DWORD       cbWritten, 
                                DWORD       dwCompletionStatus, 
                                OVERLAPPED  *lpo);

/************************************************************
 *    Globals
 ************************************************************/

/************************************************************
 *    Implementation of SMTP_BUILDQ class
 ************************************************************/

/*++

    Name:

    SMTP_BUILDQ::SMTP_BUILDQ

    Constructs a new SMTP_BUILDQ object

--*/
SMTP_BUILDQ::SMTP_BUILDQ(SMTP_SERVER_INSTANCE * pInst)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::SMTP_BUILDQ");

    m_hAtq = INVALID_HANDLE_VALUE;
    m_pAtqContext = NULL;
    m_cPendingIoCount = 0;
    m_cActiveThreads = 0;
    m_Entries = 0;
    m_Signature = SMTP_BUILDQ_SIGNATURE_VALID;
    m_pInstance = pInst;

    InitializeListHead(&m_InitalQListHead);
    InitializeCriticalSection (&m_CritSec);

    TraceFunctLeaveEx((LPARAM)this);
}

SMTP_BUILDQ::~SMTP_BUILDQ(void)
{
    PATQ_CONTEXT pAtqContext = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::~SMTP_BUILDQ");

    _ASSERT(GetThreadCount() == 0);

    // Release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer((PVOID *)&m_pAtqContext, (PVOID)NULL);
    if (pAtqContext != NULL) 
    {
        pAtqContext->hAsyncIO = NULL;
        AtqFreeContext( pAtqContext, TRUE );
    }

    // Close the directory handle if for some reason it is
    // not already closed
    if (m_hAtq != INVALID_HANDLE_VALUE)
    {
        _VERIFY(CloseHandle(m_hAtq));
        m_hAtq = INVALID_HANDLE_VALUE;
    }

    // Invalidate the signature. since this connection is trashed.
    m_Signature = SMTP_BUILDQ_SIGNATURE_FREE;

    DeleteCriticalSection (&m_CritSec);

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_BUILDQ::InitializeObject(ATQ_COMPLETION pfnCompletion)
{
    //PATQ_CONT pContext;
    BOOL        fReturn = FALSE;
    HANDLE      hStop;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::InitializeObject");

    // Open the queue directory, this is just to keep AtqAddAsyncHandle happy
    m_hAtq = CreateFile(QuerySmtpInstance()->GetMailQueueDir(), 
                        FILE_LIST_DIRECTORY,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
                        NULL);
    if(m_hAtq == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM)this, 
                    "CreateFile on %s failed with error %d ",
                    QuerySmtpInstance()->GetMailQueueDir(), 
                    GetLastError());
        goto ExitFunc;
    }

    // Create an event to fire when we stop
    hStop = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(hStop == NULL)
    {
        ErrorTrace((LPARAM)this, 
                    "CreateEvent() for hStop failed with error %d ", 
                    GetLastError());
        goto ExitFunc;
    }

    QuerySmtpInstance()->SetBuildQStopHandle(hStop);

    // Add it to our Gibraltar interface
    if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this, pfnCompletion,
                            INFINITE, m_hAtq))
     {
        ErrorTrace((LPARAM)this, 
                    "AtqAddAsyncHandle failed with error %d ", 
                    GetLastError());
        goto ExitFunc;
     }

    // Hack to get around ATQ assert
    //pContext = (PATQ_CONT)m_pAtqContext;
    //pContext->lSyncTimeout = AtqProcessingIo;

    // Indicate success
    fReturn = TRUE;

ExitFunc:
    if (!fReturn)
    {
        if (m_hAtq != INVALID_HANDLE_VALUE)
        {
            _VERIFY(CloseHandle(m_hAtq));
            m_hAtq = INVALID_HANDLE_VALUE;
        }

        QuerySmtpInstance()->CloseBuildQStopHandle();
    }
    TraceFunctLeaveEx((LPARAM)this);
    return(fReturn);
}

void SMTP_BUILDQ::CloseAtqHandleAndFlushQueue (void)
{
    HANDLE          hAtq = INVALID_HANDLE_VALUE;
    PQUEUE_ENTRY    pQEntry;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::CloseAtqHandle");

    // We close the Atq (directory) handle.
    hAtq = (HANDLE)InterlockedExchangePointer((PVOID *)&m_hAtq, 
                                        (PVOID)INVALID_HANDLE_VALUE);
    if (hAtq != INVALID_HANDLE_VALUE)
        _VERIFY(CloseHandle(hAtq));

    QuerySmtpInstance()->SetStopHint(2);
    WaitForSingleObject(QuerySmtpInstance()->QueryBuildQStopHandle(), INFINITE);
    QuerySmtpInstance()->CloseBuildQStopHandle();
        
    // Flush the queue, since we are all shuttin gdown
    LockQ();
    while(!IsListEmpty(&m_InitalQListHead))
    {
        QuerySmtpInstance()->StopHint();
        pQEntry = PopQEntry();
        delete pQEntry;
    }
    UnLockQ();

    QuerySmtpInstance()->SetStopHint(2);

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_BUILDQ::InsertIntoInitialQueue(IN OUT PERSIST_QUEUE_ENTRY * pEntry)
{
    return(TRUE);
}

PQUEUE_ENTRY SMTP_BUILDQ::PopQEntry(void)
{
    return NULL;
}


BOOL SMTP_BUILDQ::PostCompletionStatus(DWORD BytesTransferred)
{
    BOOL fRet;

    TraceFunctEnterEx((LPARAM)this, "PostCompletionStatus");

    _ASSERT(QueryAtqContext() != NULL);

    // Ask for more threads only if we are less than the preset
    // maximum number of threads
    IncPendingIoCount();

    if(!(fRet = AtqPostCompletionStatus(QueryAtqContext(), 
                                        BytesTransferred)))
    {
        DecPendingIoCount();
        ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
    }

    TraceFunctLeaveEx((LPARAM) this);
    return(fRet);
}

/*++

    Name :
        DWORD BuildInitialQueueProc

    Description:
        Wrapper for the SMTP_BUILDQ::BuildInitialQueue workhorse
        funciton.

    Arguments:
        lpThis - points to the SMTP_BUILDQ object

    Returns:
        NO_ERROR

--*/
DWORD BuildInitialQueueProc(void *lpThis)
{
    SMTP_BUILDQ *pBuildQ = (SMTP_BUILDQ *)lpThis;

    _ASSERT(pBuildQ);
    _ASSERT(pBuildQ->IsValid());

    // Call the main workhorse function
    pBuildQ->BuildInitialQueue();

    return(NO_ERROR);
}

/*++

    Name :
        SMTP_BUILDQ::BuildInitialQueue

    Description:
       This function reads all the mail files
       that were not sent, for what ever reason,
       opens the NTFS stream that holds the envelope,
       and builds up the internal send queue. The
       envelope for each message resides in an NTFS
       stream in that message file.  The envelope has
       a header that looks like the following :

        struct ENVELOPE_HEADER
        {
            DWORD                       Version;
            DWORD                       Dummy1;         // To be used later
            DWORD                       Dummy2;         // To be used later
            DWORD                       LocalOffset;    // Local rcpt. list offset
            DWORD                       RemoteOffset;   // Remote rcpt. list offset
            DWORD                       LocalSize;      // Size of local rcpt list
            DWORD                       RemoteSize;     // Size of remote rcpt list 
        };

        Right after the envelope header is the address 
        that was in the "Mail From" line. This address 
        is stored like "Srohanp@microsoft.com\n".  The "S"
        stands for SENDER. In the code below, the first
        byte is always removed when reading the address.
        The '\n' is also replaced with a '\0';

        In this version the Local recipient list, if any,
        comes right after the senders' address.  You can
        also find it by seeking LocalOffset bytes from the
        beginning of the file.  Once LocalOffset is reached,
        the code reads LocalSize bytes of data.  This is the
        total size in bytes of the local recipient list.
        Each recipient address is stored on a line by itself,
        with the first letter "R" as in the example below:

        Rrohanp@microsoft.com\n
        Rtoddch@microsoft.com\n
        etc.

        The remote addresses have the same format. The first byte,
        'R' stands for recipient and is always removed when building
        the address.  The '\n' is also removed.

    Arguments:
        A pointer to a PERSIST_QUEUE

    Returns:

--*/

DWORD SMTP_BUILDQ::BuildInitialQueue(void)
{

    SMTP_SERVER_INSTANCE * pInst;

    pInst = QuerySmtpInstance();

    SetEvent(QuerySmtpInstance()->GetBuildQStopHandle());

    // Log an event saying that the server is ready to accept connections,
    // only if we are not shutting down.
    if (!pInst->IsShuttingDown())
    {
        char IntBuffer [20];

        pInst->SetAcceptConnBool();

        _itoa(pInst->QueryInstanceId(), IntBuffer, 10);
        SmtpLogEventEx(SMTP_EVENT_ACCEPTING_CONNECTIONS, IntBuffer, 0);
    }

    return(NO_ERROR);
}


BOOL SMTP_BUILDQ::ProcessMailQIO(DWORD InputBufferLen,
                                    DWORD dwCompletionStatus,
                                    OVERLAPPED * lpo)
{
    return(TRUE);
}


/*++

    Name :
        SMTP_BUILDQ::ProcessQueueObject

    Description:

       Main function for this class. Processes the objects in the
       initial queue

    Arguments:

       cbWritten          count of bytes written
       dwCompletionStatus Error Code for last IO operation
       lpo                Overlapped stucture

    Returns:

       FALSE when processing is incomplete.
       TRUE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_BUILDQ::ProcessQueueObject(IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fRet;

    TraceFunctEnterEx((LPARAM)this, "SMTP_BUILDQ::ProcessQueueObject" );

    //
    // Increment the number of threads processing this client
    //
    IncThreadCount();

    if(!QuerySmtpInstance()->IsShuttingDown())
    {
        // We want to make sure we are called from the Gibraltar
        // context since that should be the only case ...
        if (lpo == &(QueryAtqContext()->Overlapped))
        {
            DebugTrace((LPARAM)this,"About to process queue object");
            fRet = ProcessMailQIO (InputBufferLen, dwCompletionStatus, lpo);
        }
        else
        {
            // We are not called with the correct context, we can't
            // do much about it; so we skip in in retail and break
            // in debug.
            FatalTrace((LPARAM)this,"Bad overlapped context");
            _ASSERT(0);
        }
    }

    //
    // Decrement the number of threads processing this client
    //
    DecThreadCount();

    // If our pending IO count ever hits zero, we know we have handled 
    // all initial mail messages. If this is the case, we will return 
    // FALSE, and the calling function will then fire the Stop event.
    if (DecPendingIoCount() == 0)
    {
        DebugTrace((LPARAM)this, 
                    "SMTP_BUILDQ::ProcessQueueObject() shutting down - Pending IOs: %d", 
                    m_cPendingIoCount);
        DebugTrace((LPARAM)this, 
                    "SMTP_BUILDQ::ProcessQueueObject() shutting down - ActiveThreads: %d", 
                    m_cActiveThreads);
        _ASSERT(m_cActiveThreads == 0);
        fRet = TRUE;
    }
    else
    {
        DebugTrace((LPARAM)this,
                    "SMTP_BUILDQ::ProcessClient() - Pending IOs: %d",
                    m_cPendingIoCount);
        DebugTrace((LPARAM)this,
                    "SMTP_BUILDQ::ProcessClient() - ActiveThreads: %d",
                    m_cActiveThreads);
        fRet = FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fRet);
}

/*++
    Name :
        ProcessInitialQueueObjects

    Description:

        Handles a completed I/O for delivering queued mail objects

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID ProcessInitialQueueObjects(PVOID       pvContext, 
                                DWORD       cbWritten, 
                                DWORD       dwCompletionStatus, 
                                OVERLAPPED  *lpo)
{
    BOOL        fCompleted;
    SMTP_BUILDQ *pBuildQ = (SMTP_BUILDQ *)pvContext;

    TraceFunctEnterEx((LPARAM)pBuildQ, "ProcessInitialQueueObjects");

    _ASSERT(pBuildQ);
    _ASSERT(pBuildQ->IsValid());

    // Call the in-context function to process the object
    fCompleted = 
        pBuildQ->ProcessQueueObject(cbWritten, dwCompletionStatus, lpo);
    if (fCompleted)
    {
        // If fCompleted is TRUE, we know that we either finished
        // delivering the entire initial queue, or that we are already
        // signalled to shut down, and the last pending IO has just
        // been serviced. We fire the Stop event to allow CloseAtqHandle 
        // to proceed through the wait.
        _VERIFY(SetEvent(pBuildQ->QuerySmtpInstance()->GetBuildQStopHandle()));
    }

    TraceFunctLeaveEx((LPARAM)pBuildQ);
}

BOOL     SMTP_BUILDQ::MakeAllAddrsLocal (HANDLE hFile,  char * szBuffer, ENVELOPE_HEADER * pMyHeader)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the connection accept routine called by the connection
    thread.


    FILE HISTORY:
        Johnl       08-Aug-1994 Lifted from FTP server

*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <rdns.hxx>
#include "smtpcli.hxx"



//
//  Private prototypes.
//

VOID
SmtpCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	);

SOCKERR CloseSocket( SOCKET sock );

BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    );

//
//  Private functions.
//

/*++
  This function dereferences User data and kills the UserData object if the
    reference count hits 0. Before killing the user data, it also removes
    the connection from the list of active connections.

--*/
VOID DereferenceUserDataAndKill(IN OUT CLIENT_CONNECTION * pUserData)
{
        pUserData->DisconnectClient();
		((SMTP_CONNECTION*)pUserData)->QuerySmtpInstance()->RemoveConnection(pUserData);
		delete pUserData;
    
} // DereferenceUserDataAndKill()

void HandleErrorCondition(SOCKET sock, SMTP_SERVER_INSTANCE *pInstance, DWORD dwError, PSOCKADDR_IN pSockAddr)
{
	char ErrorBuf[4 *MAX_PATH];
	const CHAR * apszSubStrings[2];
	CHAR pchAddr1[50] = "";
	CHAR pchAddr2[50] = "";
	DWORD SendSize;

	_ASSERT(pSockAddr != NULL);
	_ASSERT(pInstance != NULL);
	_ASSERT(sock != INVALID_SOCKET);

	SendSize = wsprintf (ErrorBuf, "%d-%s %s\r\n", 
							SMTP_RESP_SRV_UNAVAIL, 
							pInstance->GetConnectResponse(),							
							SMTP_SRV_UNAVAIL_MSG);
		
	CLIENT_CONNECTION::WriteSocket(sock, ErrorBuf, SendSize );

	if(dwError == ERROR_REMOTE_SESSION_LIMIT_EXCEEDED)
	{
		_itoa(pInstance->QueryInstanceId(), pchAddr1, 10);
		InetNtoa(pSockAddr->sin_addr, pchAddr2 );

		apszSubStrings[0] = pchAddr1;
		apszSubStrings[1] = pchAddr2;

		SmtpLogEvent(SMTP_MAX_CONNECTION_REACHED,
                     2,
                     apszSubStrings,
                     NO_ERROR );
	}
}

BOOL VerifyClient(SMTP_CONNECTION * pNewClient, PSOCKADDR_IN psockAddrRemote)
{
	AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
	BOOL			fRet = TRUE;
	struct hostent* pH = NULL;

	pNewClient->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockAddrRemote );
	if ( pNewClient->BindInstanceAccessCheck() ) 
	{
		acIpAccess = pNewClient->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck);
		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) 
		{
			fRet = FALSE;
		}
		else if (fNeedDnsCheck) 
		{
			pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)psockAddrRemote)->sin_addr),
                          4, PF_INET );
			if(pH != NULL)
			{
				acIpAccess = pNewClient->QueryAccessCheck()->CheckName(pH->h_name);
			}
			else
			{
				acIpAccess = AC_IN_DENY_LIST;
			}
		}

		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				(acIpAccess == AC_NOT_IN_GRANT_LIST)) 
		{
			fRet = FALSE;
		}

		pNewClient->UnbindInstanceAccessCheck();
	}


	if(!fRet)
	{
		SetLastError(ERROR_ACCESS_DENIED);
	}

	return fRet;
}

BOOL
ProcessNewClient(
    IN SOCKET       sNew,
    IN PVOID        EndpointObject,
    IN SMTP_SERVER_INSTANCE *pInstance,
	IN BOOL         fMaxConnExceeded,
    IN PSOCKADDR_IN psockAddrRemote,
    IN PSOCKADDR_IN psockAddrLocal = NULL,
    IN PATQ_CONTEXT patqContext    = NULL,
    IN PVOID        pvBuff         = NULL,
    IN DWORD        cbWritten      = 0,
    OUT LPBOOL      pfAtqToBeFreed = NULL
    )
{
	SMTP_CONNECTION * pNewClient = NULL;
    DWORD           err     = NO_ERROR;
    BOOL            fReturn  = FALSE;
    BOOL            fMaxExceeded = FALSE;
    DBG_CODE( CHAR  pchAddr[32];);
    BOOL            fSockToBeFreed = TRUE;
    BOOL            fDereferenceInstance = FALSE;
    BOOL            fSupressErrorResponse = FALSE;
    CLIENT_CONN_PARAMS clientParams;

	TraceFunctEnterEx((LPARAM) NULL, "ProcessNewClient");

    DBG_CODE( InetNtoa( psockAddrRemote->sin_addr, pchAddr));

    if ( pfAtqToBeFreed != NULL) 
	{
        *pfAtqToBeFreed = TRUE;
    }

	clientParams.sClient = sNew;
    clientParams.pAtqContext = patqContext;
    clientParams.pAddrLocal = (PSOCKADDR) psockAddrLocal;
    clientParams.pAddrRemote = (PSOCKADDR)psockAddrRemote;
    clientParams.pvInitialBuff = pvBuff;
    clientParams.cbInitialBuff = cbWritten ;
    clientParams.pEndpoint = (PIIS_ENDPOINT)EndpointObject;

	if( pInstance && (pInstance->IsShuttingDown() || (pInstance->QueryServerState( ) != MD_SERVER_STATE_STARTED)))
	{
		DBGPRINTF((DBG_CONTEXT," Service instance is shutting down\n"));
	}
	else if ( !fMaxConnExceeded)
	{

	//	DBGPRINTF((DBG_CONTEXT,"Getting a connection object\n"));

        pNewClient = (SMTP_CONNECTION *) pInstance->CreateNewConnection( &clientParams);

		if(pNewClient)
		{
			if(!VerifyClient(pNewClient, psockAddrRemote))
			{
				//
				// Depending on metabase configuration, either require clients
				// whose IPs are blocked to authenticate, or drop the connection.
				//
				if(pInstance->GetDeniedIpAction() == SMTPDENIEDIP_REQAUTH)
					pNewClient->RequireAuth();
				else
				{
					_ASSERT(pInstance->GetDeniedIpAction() == SMTPDENIEDIP_DROPCONN);
					DereferenceUserDataAndKill(pNewClient);
					pNewClient = NULL;
					fSockToBeFreed = FALSE;
					fDereferenceInstance = FALSE;
					SetLastError(ERROR_ACCESS_DENIED);

					//
					//  We have closed the socket... don't write to it!!!
					//
					fSupressErrorResponse = TRUE;
				}
			}
		}
	}
	else
	{
		err = ERROR_REMOTE_SESSION_LIMIT_EXCEEDED;
		SetLastError(err);
	}

    if( pNewClient != NULL)
	{

		//DBGPRINTF((DBG_CONTEXT,"New connection object is non-null\n"));

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the USER_DATA object is created
        //    with the socket and atq context.
        //  From now on USER_DATA will take care of freeing
        // ATQ context & socket
        //

        fSockToBeFreed = FALSE;

         //
         // At this point we have the context for the AcceptExed socket.
         //  Set the context in the AtqContext if need be.
          //

         if ( patqContext != NULL) 
		 {
			 	//DBGPRINTF((DBG_CONTEXT,"AtqContext is not NULL\n"));


                //
                // Associate client connection object with this control socket
                //  handle for future completions.
                //

                AtqContextSetInfo(patqContext,
                                  ATQ_INFO_COMPLETION_CONTEXT,
                                  (UINT_PTR) pNewClient);
          }
		 else 
		 {
			 //DBGPRINTF((DBG_CONTEXT,"AtqContext is  NULL\n"));

			 if(!pNewClient->AddToAtqHandles((HANDLE) sNew,EndpointObject, pInstance->QueryConnectionTimeout(),
				SmtpCompletion))
			{
				err = GetLastError();
				DBGPRINTF((DBG_CONTEXT,"AddToAtqHandles() failed- err= %d\n", err));
				DebugTrace((LPARAM) NULL, "pNewClient->AddToAtqHandles failed- err = %d", err);

				DereferenceUserDataAndKill(pNewClient);
				fDereferenceInstance = FALSE;
				fSockToBeFreed = FALSE;
				pNewClient = NULL;
			}
		 }
    }
	else
	{
		err = GetLastError();

		if(err != ERROR_ACCESS_DENIED)
			fDereferenceInstance = TRUE;
	}

	if ( (pNewClient == NULL) || (err != NO_ERROR) ) 
	{

	//	DBGPRINTF((DBG_CONTEXT,"New connection object is NULL\n"));

        //
        // Failed to allocate new connection
        // Reasons:
        //   1) Max connections might have been exceeded.
        //   2) Not enough memory is available.
        //
        //  handle the failures and notify client.
        //

		if (!fSupressErrorResponse)
			HandleErrorCondition(sNew, pInstance, err, psockAddrRemote);

	}
	else
	{

		//DBGPRINTF((DBG_CONTEXT,"Calling StartSession()\n"));

		if(!pNewClient->StartSession())
		{
			err = GetLastError();
			DBGPRINTF((DBG_CONTEXT,"StartSession() failed - err= %d\n", err));
            DebugTrace((LPARAM) NULL, "pNewClient->StartSession() failed- err = %d", err);

			DereferenceUserDataAndKill(pNewClient);
			pNewClient = NULL;
			fSockToBeFreed = FALSE;
			fDereferenceInstance = FALSE;
		}
		else
		{
			fReturn = TRUE;
		}
	}


    if ( fSockToBeFreed ) 
	{
        if ( patqContext != NULL) 
		{
			// ensure that socket is shut down.
             DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE));
         } 
		else 
		{

            CloseSocket( sNew);
         }
    }


    if ( pfAtqToBeFreed != NULL) 
	{

        *pfAtqToBeFreed = fSockToBeFreed;
    }

	if (pInstance && fDereferenceInstance ) 
	{
		pInstance->DecrementCurrentConnections();
		pInstance->Dereference();
	}

	TraceFunctLeaveEx((LPARAM) NULL);
    return (fReturn);

} // ProcessNewClient()

/*******************************************************************

    NAME:       SmtpOnConnect

    SYNOPSIS:   Handles the incoming connection indication from the
                connection thread


    ENTRY:      sNew - New client socket

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        Johnl       02-Aug-1994 Reworked from FTP server

********************************************************************/

VOID SmtpOnConnect( IN SOCKET        sNew,
                  IN SOCKADDR_IN * psockaddr,       //Should be SOCKADDR *
                  IN PVOID         pEndpointContext,
                  IN PVOID         pEndpointObject )
{

    PIIS_ENDPOINT      pEndpoint    = (PIIS_ENDPOINT)pEndpointContext;
    INT                cbAddr       = sizeof( sockaddr );
    SOCKADDR_IN           sockaddr;
	SMTP_SERVER_INSTANCE *pInstance;
	BOOL fProcessed;
	BOOL fMaxConnExceeded;

    DBG_ASSERT( sNew != INVALID_SOCKET );
	DBG_ASSERT( psockaddr != NULL );

	if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) 
	{

		DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

		goto error_exit;

	}

	if ( getsockname( sNew, (PSOCKADDR) &sockaddr, &cbAddr ) != 0 )
    {
        goto error_exit;
    }

	//
	// Find Instance
	//
	pInstance = (SMTP_SERVER_INSTANCE *)
     ((PIIS_ENDPOINT)pEndpointContext)->FindAndReferenceInstance(
                             (LPCSTR)NULL,
                             sockaddr.sin_addr.s_addr,
							 &fMaxConnExceeded);

	if ( pInstance == NULL ) 
	{

		//
		//  Site is not permitted to access this server.
		//  Dont establish this connection. We should send a message.
		//

		goto error_exit;
	}

	fProcessed = ProcessNewClient( sNew,
                               pEndpointObject,
                               pInstance,
							   fMaxConnExceeded,
                               psockaddr);

	if ( fProcessed) 
	{
		//StatCheckAndSetMaxConnections();
	}

	return;

error_exit:

    CloseSocket( sNew );

	return;

} // SmtpOnConnect



VOID
SmtpOnConnectEx(
    VOID *        patqContext,
    DWORD         cbWritten,
    DWORD         err,
    OVERLAPPED *  lpo
    )
{
    BOOL       fAllowConnection    = FALSE;
    PVOID      pvBuff = NULL;
    PSOCKADDR_IN psockAddrLocal = NULL;
    PSOCKADDR_IN psockAddrRemote = NULL;
    SOCKET     sNew;
    PIIS_ENDPOINT pEndpoint;
    PSMTP_SERVER_INSTANCE pInstance;
	BOOL fProcessed = FALSE;
	BOOL  fAtqContextToBeFreed = TRUE;
	BOOL fMaxConnExceeded;

    if ( err || !lpo || g_IsShuttingDown)
    {
		if(g_IsShuttingDown)
		{
			DBGPRINTF(( DBG_CONTEXT,
                   "[SmtpOnConnectEx] Completion failed because of shutdown %d, Atq context %lx\n",
                    err,
                    patqContext ));

		}
		else
		{
			DBGPRINTF(( DBG_CONTEXT,
                   "[SmtpOnConnectEx] Completion failed with error %d, Atq context %lx\n",
                    err,
                    patqContext ));
		}

		goto exit;
    }


    //
    // Get AcceptEx parameters
    //

    AtqGetAcceptExAddrs( (PATQ_CONTEXT) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         (PSOCKADDR *) &psockAddrLocal,
                         (PSOCKADDR *) &psockAddrRemote );


	if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) 
	{

		DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

		goto exit ;
	}

	//
	// Find Instance
	//

	pInstance = (SMTP_SERVER_INSTANCE *)
     ((PIIS_ENDPOINT)pEndpoint)->FindAndReferenceInstance(
                             (LPCSTR)NULL,
                             psockAddrLocal->sin_addr.s_addr,
							 &fMaxConnExceeded
                             );

	if(pInstance == NULL)
	{
		//
		//  Site is not permitted to access this server.
		//  Dont establish this connection. We should send a message.
		//

	//	DBGPRINTF((DBG_CONTEXT,
		//	"Unable to find instance [err %d]\n",GetLastError()));
		goto exit;
	}


    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       (UINT_PTR) pInstance->QueryConnectionTimeout());


	fProcessed = ProcessNewClient( sNew,
                               pEndpoint,
                               pInstance,
							   fMaxConnExceeded,
                               psockAddrRemote,
                               psockAddrLocal,
                               (PATQ_CONTEXT ) patqContext,
                               pvBuff,
                               cbWritten,
                               &fAtqContextToBeFreed);


exit:

    if ( !fProcessed && fAtqContextToBeFreed ) 
	{

	//	DBGPRINTF((DBG_CONTEXT,
		//	"ProcessNewClient returned false\n"));

        //
        // We failed to process this connection. Free up resources properly
        //

        DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT )patqContext, FALSE));
        AtqFreeContext( (PATQ_CONTEXT ) patqContext, TRUE );
    }

    return;

} // SmtpOnConnectEx



#if 0
BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    )
{
    STR strResponse;

    if ( !strResponse.Resize( 512 ) ||
         !HTTP_REQ_BASE::BuildExtendedStatus( &strResponse,
                                              HT_FORBIDDEN,
                                              NO_ERROR,
                                              ids ))
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SendError] Failed to build status (error %d)\n",
                   GetLastError()));

        return FALSE;
    }

    //
    //  Do a synchronous send
    //

    send( socket,
          strResponse.QueryStr(),
          strResponse.QueryCB(),
          0 );

    return TRUE ;
} // SendError
#endif

/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR CloseSocket( SOCKET sock )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

#if 0
    shutdown( sock, 1 );    // Davidtr sez not needed
#endif

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    if( serr == 0 )
     {
         // DBGPRINTF(( DBG_CONTEXT,
                      // "closed socket %d\n",
                      //  sock ));
      }
     else
      {
          DBGPRINTF(( DBG_CONTEXT,
                       "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
      }

    return serr;

}   // CloseSocket

/*++

	Description:

		Handles a completed IO.

	Arguments:

		pvContext:			the context pointer specified in the initial IO
		cbWritten:			the number of bytes sent
		dwCompletionStatus:	the status of the completion (usually NO_ERROR)
		lpo:				the overlapped structure associated with the IO

	Returns:

		nothing.

--*/
VOID
SmtpCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	)
{
	BOOL WasProcessed;
	SMTP_CONNECTION *pCC = (SMTP_CONNECTION *) pvContext;

	_ASSERT(pCC);
	_ASSERT(pCC->IsValid());
	_ASSERT(pCC->QuerySmtpInstance() != NULL);

	//
	// if we could not process a command, or we were
	// told to destroy this object, close the connection.
	//
	WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
}

/*++

	Description:

		Handles a completed IO.

	Arguments:

		pvContext:			the context pointer specified in the initial IO
		cbWritten:			the number of bytes sent
		dwCompletionStatus:	the status of the completion (usually NO_ERROR)
		lpo:				the overlapped structure associated with the IO

	Returns:

		nothing.

--*/
VOID
SmtpCompletionFIO(
	PFIO_CONTEXT		pFIOContext,
	FH_OVERLAPPED		*pOverlapped,
	DWORD				cbWritten,
	DWORD				dwCompletionStatus)
{
	BOOL WasProcessed;
	SMTP_CONNECTION *pCC = (SMTP_CONNECTION *) (((SERVEREVENT_OVERLAPPED *) pOverlapped)->ThisPtr);

	_ASSERT(pCC);
	_ASSERT(pCC->IsValid());
	_ASSERT(pCC->QuerySmtpInstance() != NULL);

	//
	// if we could not process a command, or we were
	// told to destroy this object, close the connection.
	//
	WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, (OVERLAPPED *) pOverlapped);
}

#if 0
VOID
ServerEventCompletion(
	PVOID        pvContext,
	DWORD        cbWritten,
	DWORD        dwCompletionStatus,
	OVERLAPPED * lpo
	)
{
	SERVEREVENT_OVERLAPPED * Ov = (SERVEREVENT_OVERLAPPED *) lpo;

	_ASSERT(pvContext);

	Ov->Overlapped.pfnCompletion(Ov->ThisPtr, cbWritten, dwCompletionStatus, lpo);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\cpropbag.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cpropbag.cpp

Abstract:

	This module contains the definition of the 
	generic property bag class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	06/30/98	created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "cpropbag.h"

// =================================================================
// Default instance info
//

PROPERTY_TABLE_INSTANCE	CMailMsgPropertyBag::s_DefaultInstanceInfo =
{
	GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE,
	GLOBAL_PROPERTY_ITEM_BITS,
	GLOBAL_PROPERTY_ITEM_SIZE,
	0,
	INVALID_FLAT_ADDRESS
};

DWORD CMailMsgLoggingPropertyBag::LoggingHelper(
			LPVOID pvLogHandle, 
			const INETLOG_INFORMATION *pLogInformation
			)
{
	if (!pvLogHandle) {
		_ASSERT(pvLogHandle);
		return (ERROR_INVALID_PARAMETER);
	}
	return (((LOGGING *) pvLogHandle)->LogInformation(pLogInformation));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\cpropbag.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpropbag.h

Abstract:

    This module contains the definition of the 
    generic property bag class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    06/30/98    created

--*/

#ifndef _CPROPBAG_H_
#define _CPROPBAG_H_


#include "filehc.h"
#include "mailmsg.h"
#include "cmmtypes.h"
#include "cleanback.h"

//
//Logging facilities
//
#include "inetcom.h"
#include "logtype.h"


/***************************************************************************/
// Definitions
//

#define GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID     ((DWORD)'PTGv')


/***************************************************************************/
// CMailMsgPropertyBag
//

//
// Disable warning about using the this pointer in the constructor
// (CCleanBack only saves the pointer, so this is safe)
//
#pragma warning( disable: 4355 )

class CMailMsgPropertyBag : 
    public IMailMsgPropertyBag,
    public CCleanBack
{
  public:

    CMailMsgPropertyBag() :
        CCleanBack((IUnknown *)(IMailMsgPropertyBag *)this),
        m_bmBlockManager(NULL),
        m_ptProperties(
            PTT_PROPERTY_TABLE,
            GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
            &m_bmBlockManager,
            &m_InstanceInfo,
            CompareProperty,
            NULL,
            NULL
        )
    {
        m_lRefCount = 1;

        // Copy the default instance into our instance
        MoveMemory(
                &m_InstanceInfo, 
                &s_DefaultInstanceInfo, 
                sizeof(PROPERTY_TABLE_INSTANCE));
    }

    ~CMailMsgPropertyBag()
    {
        //
        // Call all registered callbacks BEFORE destroying member
        // variables (so that properties will still be accessible) 
        //
        CallCallBacks();
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
            if (riid == IID_IUnknown)
                *ppvObj = (IUnknown *)(IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgPropertyBag)
                *ppvObj = (IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgRegisterCleanupCallback)
                *ppvObj = (IMailMsgRegisterCleanupCallback *)this;
            else
                return(E_NOINTERFACE);
            AddRef();
            return(S_OK);
    }

    unsigned long STDMETHODCALLTYPE AddRef() 
    {
        return(InterlockedIncrement(&m_lRefCount));
    }

    unsigned long STDMETHODCALLTYPE Release() 
    {
        LONG    lTemp = InterlockedDecrement(&m_lRefCount);
        if (!lTemp)
        {
            // Extra releases are bad!
            _ASSERT(lTemp);
        }
        return(lTemp);
    }

    HRESULT STDMETHODCALLTYPE PutProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        piItem.idProp = dwPropID;
        return(m_ptProperties.PutProperty(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pbValue));
    }

    HRESULT STDMETHODCALLTYPE GetProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                DWORD   *pcbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        return(m_ptProperties.GetPropertyItemAndValue(
                                (LPVOID)&dwPropID,
                                (LPPROPERTY_ITEM)&piItem,
                                cbLength,
                                pcbLength,
                                pbValue));
    }

    HRESULT STDMETHODCALLTYPE PutStringA(
                DWORD   dwPropID,
                LPCSTR  pszValue
                ) 
    {
        return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringA(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPSTR   pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutStringW(
                DWORD   dwPropID,
                LPCWSTR pszValue
                )
    {
        return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringW(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPWSTR  pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutDWORD(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetDWORD(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutBool(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        dwValue = dwValue ? 1 : 0;
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetBool(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        HRESULT hrRes;
        DWORD dwLength;

        hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
        if (pdwValue)
            *pdwValue = *pdwValue ? 1 : 0;
        return (hrRes);
    }

  private:

    // The specific compare function for this type of property table
    static HRESULT CompareProperty(
                LPVOID          pvPropKey,
                LPPROPERTY_ITEM pItem
                );

  private:

    // Usage count
    LONG                            m_lRefCount;

    // Property table instance
    PROPERTY_TABLE_INSTANCE         m_InstanceInfo;
    static PROPERTY_TABLE_INSTANCE  s_DefaultInstanceInfo;

    // IMailMsgProperties is an instance of CPropertyTable
    CPropertyTable                  m_ptProperties;

    // An instance of the block memory manager 
    CBlockManager                   m_bmBlockManager;

};

//
// Restore original warning settings
//
#pragma warning ( default: 4355 )

/***************************************************************************/
// CMailMsgLoggingPropertyBag
//

class __declspec(uuid("58f9a2d2-21ca-11d2-aa6b-00c04fa35b82")) CMailMsgLoggingPropertyBag : 
    public CMailMsgPropertyBag,
    public IMailMsgLoggingPropertyBag
{
  public:

    CMailMsgLoggingPropertyBag()
    {
        m_lRefCount = 1;
        m_pvLogHandle       = NULL;
    }

    HRESULT STDMETHODCALLTYPE PutProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                LPBYTE  pbValue
                )
    {
        HRESULT                 hrRes = S_OK;

        m_rwLock.ExclusiveLock();
        hrRes = CMailMsgPropertyBag::PutProperty(
                        dwPropID,
                        cbLength,
                        pbValue);
        m_rwLock.ExclusiveUnlock();
        return(hrRes);
    }

    HRESULT STDMETHODCALLTYPE GetProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                DWORD   *pcbLength,
                LPBYTE  pbValue
                )
    {
        HRESULT                 hrRes = S_OK;

        m_rwLock.ExclusiveLock();
        hrRes = CMailMsgPropertyBag::GetProperty(
                                dwPropID,
                                cbLength,
                                pcbLength,
                                pbValue);
        m_rwLock.ExclusiveUnlock();
        return(hrRes);
    }

    HRESULT STDMETHODCALLTYPE PutStringA(
                DWORD   dwPropID,
                LPCSTR  pszValue
                ) 
    {
        return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringA(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPSTR   pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutStringW(
                DWORD   dwPropID,
                LPCWSTR pszValue
                )
    {
        return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringW(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPWSTR  pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutDWORD(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetDWORD(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutBool(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        dwValue = dwValue ? 1 : 0;
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetBool(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        HRESULT hrRes;
        DWORD dwLength;

        hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
        if (pdwValue)
            *pdwValue = *pdwValue ? 1 : 0;
        return (hrRes);
    }

    HRESULT SetLogging(
                LPVOID  pvLogHandle
                )
    {
        if (!pvLogHandle)
            return(E_POINTER);
        m_pvLogHandle = pvLogHandle;
        return(S_OK);
    }

    static void SetInetLogInfoField(
                LPCSTR  pszInput, 
                LPSTR   *ppszOutput, 
                DWORD   *pdwOutput
                )
    {
        if (pszInput) 
        {
            *ppszOutput = (LPSTR) pszInput;
            if (pdwOutput) 
                *pdwOutput = lstrlen(pszInput);
        }
    }

    unsigned long STDMETHODCALLTYPE AddRef() 
    {
        return(InterlockedIncrement(&m_lRefCount));
    }

    unsigned long STDMETHODCALLTYPE Release() 
    {
        LONG    lTemp = InterlockedDecrement(&m_lRefCount);
        if (!lTemp)
        {
            // Extra releases are bad!
            _ASSERT(lTemp);
        }
        return(lTemp);
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
            if (riid == IID_IUnknown)
                *ppvObj = (IUnknown *)(IMailMsgLoggingPropertyBag *)this;
            else if (riid == IID_IMailMsgLoggingPropertyBag)
                *ppvObj = (IMailMsgLoggingPropertyBag *)this;
            else if (riid == __uuidof(CMailMsgLoggingPropertyBag))
                *ppvObj = (CMailMsgLoggingPropertyBag *)this;
            else if (riid == IID_IMailMsgPropertyBag)
                *ppvObj = (IMailMsgPropertyBag *)
                          ((IMailMsgLoggingPropertyBag *)this);
            else if (riid == IID_IMailMsgRegisterCleanupCallback)
                *ppvObj = (IMailMsgRegisterCleanupCallback *)this;
            else
                return(E_NOINTERFACE);
            AddRef();
            return(S_OK);
    }

    static DWORD LoggingHelper(
                LPVOID pvLogHandle, 
                const INETLOG_INFORMATION *pLogInformation
                );

    HRESULT STDMETHODCALLTYPE WriteToLog(
                LPCSTR pszClientHostName,
                LPCSTR pszClientUserName,
                LPCSTR pszServerAddress,
                LPCSTR pszOperation,
                LPCSTR pszTarget,
                LPCSTR pszParameters,
                LPCSTR pszVersion,
                DWORD dwBytesSent,
                DWORD dwBytesReceived,
                DWORD dwProcessingTimeMS,
                DWORD dwWin32Status,
                DWORD dwProtocolStatus,
                DWORD dwPort,
                LPCSTR pszHTTPHeader
                ) 
    {
        INETLOG_INFORMATION info;
        DWORD dwRes;

        memset(&info,0,sizeof(info));
        SetInetLogInfoField(pszClientHostName,&info.pszClientHostName,&info.cbClientHostName);
        SetInetLogInfoField(pszClientUserName,&info.pszClientUserName,NULL);
        SetInetLogInfoField(pszServerAddress,&info.pszServerAddress,NULL);
        SetInetLogInfoField(pszOperation,&info.pszOperation,&info.cbOperation);
        SetInetLogInfoField(pszTarget,&info.pszTarget,&info.cbTarget);
        SetInetLogInfoField(pszParameters,&info.pszParameters,NULL);
        SetInetLogInfoField(pszVersion,&info.pszVersion,NULL);
        info.dwBytesSent = dwBytesSent;
        info.dwBytesRecvd = dwBytesReceived;
        info.msTimeForProcessing = dwProcessingTimeMS;
        info.dwWin32Status = dwWin32Status;
        info.dwProtocolStatus = dwProtocolStatus;
        info.dwPort = dwPort;
        SetInetLogInfoField(pszHTTPHeader,&info.pszHTTPHeader,&info.cbHTTPHeaderSize);
        dwRes = LoggingHelper(m_pvLogHandle,&info);
        return(S_OK);
    }


  private:

    // Usage count
    LONG                m_lRefCount;
    LPVOID              m_pvLogHandle;
    CShareLockNH        m_rwLock;

};



// =================================================================
// Compare function
//

inline HRESULT CMailMsgPropertyBag::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}                       



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\dirnot.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "dirnot.hxx"
#include "headers.hxx"
#include "timeconv.h"
#include "smtpcli.hxx"

//
// ProgID for IMsg - this needs to be published in an SDK
//

#define TIMEOUT_INTERVAL 30
#define DIRNOT_IP_ADDRESS "127.0.0.1"

#define IMSG_PROGID L"Exchange.IMsg"
#define MAILMSG_PROGID   L"Exchange.MailMsg"


extern void GenerateMessageId (char * Buffer, DWORD BuffLen);
extern DWORD GetIncreasingMsgId();
extern BOOL FindNextUnquotedOccurrence(char *lpszString,DWORD dwStringLength, char cSearch,char **ppszLocation);

static char * Daynames[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

//Event used make write files blocking
HANDLE              g_hFileWriteEvent;

//
// provide memory for static declared in SMTP_DIRNOT
//
CPool   CIoBuffer::Pool( DIRNOT_BUFFER_SIGNATURE );
CPool   CBuffer::Pool( DIRNOT_IO_BUFFER_SIGNATURE );

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

//+---------------------------------------------------------------
//
//  Function:   CBuffer
//
//  Synopsis:   constructor
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CBuffer::CBuffer( BOOL bEncrypted ) :
    m_dwSignature( DIRNOT_BUFFER_SIGNATURE ),
    m_bEncrypted( bEncrypted )
{
    TraceFunctEnterEx( (LPARAM)this, "CBuffer::CBuffer" );

    //
    // allocate the IO Buffer for this CBuffer
    // allocator needs to call GetData to ensure m_pIoBuffer is not NULL
    //

    ZeroMemory (&m_Overlapped, sizeof(m_Overlapped));
    m_pIoBuffer = new CIoBuffer;

    m_Overlapped.pBuffer = this;
    m_cCount = 0;  
}

//+---------------------------------------------------------------
//
//  Function:   CBuffer::~CBuffer
//
//  Synopsis:   frees associated IO buffer
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CBuffer::~CBuffer( void )
{
    TraceFunctEnterEx( (LPARAM)this, "CBuffer::~CBuffer" );

    //
    // delete the IO Buffer for this CBuffer
    //
    if ( m_pIoBuffer != NULL )
    {
        delete    m_pIoBuffer;
        m_pIoBuffer = NULL;
    }
    
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name:

    SMTP_DIRNOT::SMTP_DIRNOT

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

--*/
SMTP_DIRNOT::SMTP_DIRNOT(SMTP_SERVER_INSTANCE * pInstance)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::SMTP_DIRNOT" );

    _ASSERT(pInstance != NULL);

    m_hDir = INVALID_HANDLE_VALUE;
    m_pAtqContext = NULL;
    m_cPendingIoCount = 0;
    m_cDirChangeIoCount = 0;
    m_cActiveThreads = 0;
    m_pInstance = pInstance;
    //m_pRetryQ = NULL;
    m_Signature = SMTP_DIRNOT_SIGNATURE_VALID;
    InitializeCriticalSection (&m_CritFindLock);

    g_hFileWriteEvent = INVALID_HANDLE_VALUE;

    m_FindThreads = 0;
    m_FindFirstHandle = INVALID_HANDLE_VALUE;
    m_bDelayedFind = FALSE;

    TraceFunctLeaveEx((LPARAM)this);

}

SMTP_DIRNOT::~SMTP_DIRNOT (void)
{
    PATQ_CONTEXT pAtqContext = NULL;
    HANDLE  hTemp = INVALID_HANDLE_VALUE;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::~SMTP_DIRNOT" );

    _ASSERT(GetThreadCount() == 0);

    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, (PVOID) NULL);
    if ( pAtqContext != NULL ) 
    {
       pAtqContext->hAsyncIO = NULL;
       AtqFreeContext( pAtqContext, TRUE );
    } 

    // Invalidate the signature. since this connection is trashed.
    m_Signature = SMTP_DIRNOT_SIGNATURE_FREE;

    hTemp = (HANDLE)InterlockedExchangePointer( (PVOID *)&g_hFileWriteEvent, (PVOID) INVALID_HANDLE_VALUE);
    if ( hTemp != INVALID_HANDLE_VALUE ) 
    {
       CloseHandle(hTemp);
    } 

    DeleteCriticalSection (&m_CritFindLock);

    TraceFunctLeaveEx((LPARAM)this);
}

void SMTP_DIRNOT::SetPickupRetryQueueEvent(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::SetPickupRetryQueueEvent");

    //if(m_pRetryQ)
    //{
    //    m_pRetryQ->SetQueueEvent();
    //}
    
    TraceFunctLeaveEx((LPARAM)this);
}

BOOL SMTP_DIRNOT::InitializeObject (char *DirPickupName,  ATQ_COMPLETION  pfnCompletion)
{
    DWORD    error = 0;
    //PATQ_CONT pContext;
    HANDLE    StopHandle;
    DWORD    i;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::InitializeObject" );

    _ASSERT(m_pInstance != NULL);

    //open the directory
    m_hDir = CreateFile (DirPickupName, FILE_LIST_DIRECTORY,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
                        NULL);
    if(m_hDir == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateFile on %s failed with error %d ", DirPickupName, GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    g_hFileWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(g_hFileWriteEvent == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed for FileWriteEvent with error %d ", GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    StopHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(StopHandle == NULL)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed with error %d ", GetLastError());
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;        
    }

    //add it to our Gibraltar interface
    if(!AtqAddAsyncHandle( &m_pAtqContext, NULL, this, pfnCompletion,
                            INFINITE, m_hDir))
     {
        error = GetLastError();
        ErrorTrace((LPARAM) this, "AtqAddAsyncHandle on %s failed with error %d ", DirPickupName, GetLastError());
        CloseHandle (m_hDir);
        CloseHandle (StopHandle);
        m_hDir = INVALID_HANDLE_VALUE;
        StopHandle = NULL;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
     }

    QuerySmtpInstance()->SetDirnotStopHandle(StopHandle);

    //
    // pend a set of outstanding directory change notifications, at all times, we want
    // at least one notification outstanding, so pend 3 or 4
    //

    for (i = 0; i < OUTSTANDING_NOTIFICATIONS; i++)
    {
        if(!PendDirChangeNotification ())
        {
            ErrorTrace((LPARAM) this, "PendDirChangeNotification on failed with error %d ", GetLastError());
            ErrorTrace((LPARAM) this, "Setting stop handle because PendDirChangeNotification () failed");
            SetEvent(StopHandle);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

void SMTP_DIRNOT::CloseDirHandle (void)
{
    HANDLE        hDir = NULL;
    int i = 0;
    int Count = 0;
    int AfterSleepCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount = 0;

    TraceFunctEnterEx( (LPARAM)this, "SMTP_DIRNOT::CloseDirHandle" );

    _ASSERT(m_pInstance != NULL);

	hDir = (HANDLE) InterlockedExchangePointer((PVOID *) &m_hDir, NULL);
    if(hDir != NULL)
    {
        CloseHandle (hDir);
    }

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //

    dwTickCount = GetTickCount();
    for( i = 0; i < 240;  i++ ) 
    {
        dwAllocCount = (DWORD) QuerySmtpInstance()->GetCBufferAllocCount ();

        if ( dwAllocCount == 0) 
        {
            DebugTrace((LPARAM)this, "All pickup CBuffers are gone!");
            break;
        }

        Sleep( 1000 );

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc && 
                (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING))
        {
            DebugTrace((LPARAM)this, "Updating stop hint in pickup, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                             SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u;", 
                dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount)
        {
            DebugTrace((LPARAM)this, "Pickup CBuffers are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }


    DebugTrace((LPARAM)this, "Waiting for QuerySmtpInstance()->GetDirnotStopHandle()!");

    WaitForSingleObject(QuerySmtpInstance()->GetDirnotStopHandle(), INFINITE);

    DebugTrace((LPARAM)this, "End waiting for QuerySmtpInstance()->GetDirnotStopHandle()!");

    QuerySmtpInstance()->SetStopHint(2);

    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_DIRNOT::CreateSmtpDirNotification

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNOUT
       class.  This class cannot be allocated on the stack.

    Arguments:


    Returns:

       A pointer to an SMTP_DIRNOT class or NULL
--*/
SMTP_DIRNOT * SMTP_DIRNOT::CreateSmtpDirNotification (char * DirPickupName, 
                                                      ATQ_COMPLETION  pfnCompletion,
                                                      SMTP_SERVER_INSTANCE * pInstance)
{
    SMTP_DIRNOT * pSmtpDirNotObj;

    TraceFunctEnterEx((LPARAM) 0, "SMTP_CONNOUT::CreateSmtpConnection");

    pSmtpDirNotObj = new SMTP_DIRNOT (pInstance);
    if(pSmtpDirNotObj == NULL)
    {
        ErrorTrace(0, "new SMTP_DIRNOT () failed");
        TraceFunctLeaveEx((LPARAM)NULL);
        return NULL;
    }

    if(!pSmtpDirNotObj->InitializeObject(pSmtpDirNotObj->QuerySmtpInstance()->GetMailPickupDir(), SMTP_DIRNOT::ReadDirectoryCompletion))
    {
        TraceFunctLeaveEx((LPARAM)NULL);
        return NULL;
    }

    TraceFunctLeaveEx((LPARAM)NULL);
    return pSmtpDirNotObj;
}


BOOL SMTP_DIRNOT::DoFindFirstFile(BOOL    bIISThread)
{
    //
    // re-entrent FindFirst... the first thread does the FindFirst, all other threads up to
    // MAXFIND_THREADS do the FindNext.
    //

    char                    Buffer [MAX_PATH + 1];
    HANDLE                    hFindFile = INVALID_HANDLE_VALUE;
    DWORD                    BytesRead  = 0;
    DWORD                    NumFiles = 0;
    WIN32_FIND_DATA            find;
    BOOL                    bClosed;
    PSMTP_IIS_SERVICE        pService;

    TraceFunctEnterEx((LPARAM)this, "DoFindFirstFile");

    _ASSERT(m_pInstance != NULL);

    if (!QuerySmtpInstance()->GetAcceptConnBool())
    {
        return TRUE;
    }


    pService = (PSMTP_IIS_SERVICE) g_pInetSvc;
    //
    // ensure only one thread gets in here at a time.  we can only have one thread either setting
    // the find first at a time.
    //

    LockFind();

    hFindFile = GetFindFirstHandle();
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        //make up the file spec we want to find
        lstrcpy(Buffer, QuerySmtpInstance()->GetMailPickupDir());
        lstrcat(Buffer, "*.*");

        hFindFile = FindFirstFile(Buffer, &find);
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            // should not fail as we look for *.* and the directory root should be there.
            // setting the flag will make sure that next drop posts a findfirst.
            SetDelayedFindNotification(TRUE);

            ErrorTrace((LPARAM) this, "FindFirst failed for %s. Error %d", Buffer, GetLastError());

            UnLockFind();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
        else
        {

            IncFindThreads();    // there should be not find threads running at this point.
            //
            // We have no IIS threads available for the single findfirst... we must create a thread.
            // hopefull this will happen seldom.

            SetFindFirstHandle(hFindFile);
            
            SetDelayedFindNotification(FALSE);
        }
    }
    else
    {
        SetDelayedFindNotification(TRUE);
        
        if (!IncFindThreads())
        {
            UnLockFind();
        
            DebugTrace((LPARAM)this, "Have hit the max num Find Threads.");
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }

        if (!FindNextFile(hFindFile, &find))
        {
            if (GetLastError() != ERROR_NO_MORE_FILES)
            {
                SetDelayedFindNotification(TRUE);
                ErrorTrace((LPARAM) this,"FindNextFile() failed with error %d", GetLastError());
            }
        
            CloseFindHandle();  // will DecFindThreads.

            //
            // In the case below, it is possible that some files were missed by FindFirst.  
            // Create an ATQ thread for a final findfirst iteration to make sure.
            //
            if ((GetNumFindThreads() == 0) && GetDelayedFindNotification())
            {
                IncPendingIoCount();
                // AtqContext with buffer size of zero to get a FindFirst Going.
                if(!AtqPostCompletionStatus(QueryAtqContext(), 0))
                {
                    DecPendingIoCount();
                    ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
                }
            }

            UnLockFind();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }
    }

    UnLockFind();


    bClosed = FALSE;
    do
    {
        //format the name of the stream and then open the file.
        BytesRead = wsprintf(Buffer, "%s%s",QuerySmtpInstance()->GetMailPickupDir(), find.cFileName);
        if (!(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            HRESULT hr = S_OK;
            IMailMsgProperties *pIMsg = NULL;

            hr = CoCreateInstance(CLSID_MsgImp, NULL, CLSCTX_INPROC_SERVER,
                                            IID_IMailMsgProperties, (LPVOID *)&pIMsg);

            // Next, check if we are over the inbound cutoff limit. If so, we will release the message
            // and not proceed.
            if (SUCCEEDED(hr))
            {
                DWORD    dwCreationFlags;
                hr = pIMsg->GetDWORD(
                            IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                            &dwCreationFlags);
                if (FAILED(hr) || 
                    (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                {
                    // If we fail to get this property of if the inbound cutoff
                    // exceeded flag is set, discard the message and return failure
                    if (SUCCEEDED(hr))
                    {
                        DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                        hr = E_OUTOFMEMORY;
                    }
                    pIMsg->Release();
                    pIMsg = NULL;
                }
            }

            DebugTrace((LPARAM)this,"Found file %s", find.cFileName);

            if ((pIMsg == NULL) || FAILED(hr))
            {
                // We are out of resources, there is absolutely nothing
                // we can do: can't NDR, can't retry ...
                ErrorTrace((LPARAM) this, "new  MAILQ_ENTRY failed for file: %s",
                            find.cFileName);

                // 
                // Will want to run a findfirst when things free up a little.  Flag the post-processing findfirst.
                //
                SetDelayedFindNotification(TRUE);
                IncPendingIoCount ();
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, TIMEOUT_INTERVAL);    //retry after a while
                ErrorTrace((LPARAM)this, "Failed to create message will retry later.");
                break;
            }
            else
            {
                // We are in faith that upon delivery, the allocated
                // MailQEntry structure will be freed
                NumFiles++;
                pIMsg->PutStringA(IMMPID_MP_PICKUP_FILE_NAME, find.cFileName);

                if(!ProcessFile(pIMsg))
                {
                    // will be mail left in pickup.  queue a findfirst to take care of it.
                    SetDelayedFindNotification(TRUE);
                }
            }
        }

    
        LockFind();
        if (!FindNextFile(hFindFile, &find))
        {
            if (GetLastError() != ERROR_NO_MORE_FILES)
            {
                SetDelayedFindNotification(TRUE);
                ErrorTrace((LPARAM) this,"FindNextFile() failed with error %d", GetLastError());
            }

            CloseFindHandle();

            //
            // In the case below, it is possible that some files were missed by FindFirst.  
            // Create an ATQ thread for a final findfirst iteration to make sure.
            //
            if ((GetNumFindThreads() == 0) && GetDelayedFindNotification())
            {
                IncPendingIoCount();
                // AtqContext with buffer size of zero to get a FindFirst Going.
                if(!AtqPostCompletionStatus(QueryAtqContext(), 0))
                {
                    DecPendingIoCount();
                    ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
                }
            }

            UnLockFind();
            bClosed = TRUE;
            break;
        }
        UnLockFind();

    } 
    while ((!QuerySmtpInstance()->IsShuttingDown())
            && (QuerySmtpInstance()->QueryServerState( ) != MD_SERVER_STATE_STOPPED)
            && (QuerySmtpInstance()->QueryServerState( ) != MD_SERVER_STATE_INVALID)); 

        
    if (!bClosed)    // termination by the while condition above.
    {
        LockFind();
        CloseFindHandle();    
                
        UnLockFind();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}



DWORD WINAPI SMTP_DIRNOT::CreateNonIISFindThread(void * ClassPtr)
{
    //
    // Called by a CreateThread when we have run out of IIS threads.
    //

    SMTP_DIRNOT * ThisPtr = (SMTP_DIRNOT *) ClassPtr;

    TraceFunctEnterEx((LPARAM) ThisPtr,"CreateNonIISFindThread");

    _ASSERT(ThisPtr != NULL);

    _ASSERT(ThisPtr->QuerySmtpInstance() != NULL);


    //
    // Build the initial list - THE FLAG bIISThread IS SET TO FALSE.  
    // We IncCBufferAllocCount and DecCBufferAllocCount to make sure that we clean up properly in CloseDirHandle.
    // We don't want to destroy the Dirnot Object before this thread finishes.
    //

    ThisPtr->QuerySmtpInstance()->IncCBufferObjs();

    ThisPtr->DoFindFirstFile(FALSE);

    ThisPtr->QuerySmtpInstance()->DecCBufferObjs();

    TraceFunctLeaveEx((LPARAM)ThisPtr);
    return TRUE;
}



DWORD WINAPI SMTP_DIRNOT::PickupInitialFiles(void * ClassPtr)
{
    SMTP_DIRNOT * ThisPtr = (SMTP_DIRNOT *) ClassPtr;

    TraceFunctEnterEx((LPARAM) ThisPtr,"PickupInitialFiles");

    _ASSERT(ThisPtr != NULL);

    _ASSERT(ThisPtr->QuerySmtpInstance() != NULL);

    // Just quit if we are suhtting down already
    if (ThisPtr->QuerySmtpInstance()->IsShuttingDown())
        return TRUE;

    // Build the initial list
    ThisPtr->DoFindFirstFile();

    TraceFunctLeaveEx((LPARAM)ThisPtr);
    return TRUE;
}



#define PRIVATE_OPTIMAL_BUFFER_SIZE        4096
#define PRIVATE_LINE_BUFFER_SIZE        1024

#define IS_SPACE_OR_TAB(ch)                (((ch) == ' ') || ((ch) == '\t'))
#define IS_WHITESPACE_OR_CRLF(ch)        (((ch) == ' ') || ((ch) == '\t') || ((ch) == '\n') || ((ch) == '\r'))

static void pReplaceCrLfWithSpaces(CHAR *szIn, CHAR *szOut)
{
    while (*szIn)
    {
        if ((*szIn == '\r') || (*szIn == '\n'))
            *szOut++ = ' ';
        else
            *szOut++ = *szIn;
        szIn++;
    }
    *szOut = '\0';
}

BOOL SMTP_DIRNOT::CreateToList (char *AddrsList, IMailMsgRecipientsAdd *pIMsgRecips, IMailMsgProperties *pIMsgProps)
{
    char *p = NULL;                    //points to the ',' or '\0'
    char * StartOfAddress = NULL;    //start of recipient address
    char * EndOfAddress = NULL;        // end of recipient address
    char * ThisAddress = NULL;
    CAddr * NewAddress = NULL;        //new CAddr to add to our list
    char szAddress[MAX_INTERNET_NAME + 1], *pszAddress = szAddress;
    DWORD    dwPropId = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwNewRecipIndex = 0;
    HRESULT hr = S_OK;
    BOOL fNotFound = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::CreateToList");

    _ASSERT(m_pInstance != NULL);

    //start at the top of the list
    p = AddrsList;

    //get rid of leading white space, newlines, and commas
    while ((*p == ',') || IS_WHITESPACE_OR_CRLF(*p))
        p++;

    while((p != NULL) && (*p != '\0'))
    {
        char LastChar;

        StartOfAddress = p;

        // Find the ending delimiter of the address
        //while((*p != '\0') && (*p != ','))
        //    p++;

        // The first unquoted comma indicates the end of the address
        if(!FindNextUnquotedOccurrence(p,strlen(p),',',&EndOfAddress))
        {
                SetLastError(ERROR_INVALID_DATA);
                NewAddress = NULL;
                ErrorTrace((LPARAM) this, "Failed to parse out the address");
                return FALSE;
        }
        else if(!EndOfAddress)
            EndOfAddress = p + strlen(p);

        p = EndOfAddress;

        _ASSERT(EndOfAddress != NULL);
        
        // We don't like trailing spaces either, so walk backwards
        // to get rid of them
        //EndOfAddress = p;
        while (EndOfAddress > StartOfAddress)
        {
            EndOfAddress--;
            if (!IS_WHITESPACE_OR_CRLF(*EndOfAddress))
            {
                EndOfAddress++;
                break;
            }
        }

        // Save the character we are about to overrite
        LastChar = *EndOfAddress;

        // NULL terminate the address
        *EndOfAddress = '\0';

        if(lstrlen(StartOfAddress) > (MAX_INTERNET_NAME + 1))
        {
                SetLastError(ERROR_INVALID_DATA);
                NewAddress = NULL;
                ErrorTrace((LPARAM) this, "Address too long : %d bytes",lstrlen(StartOfAddress));
                return FALSE;
        }

        pReplaceCrLfWithSpaces(StartOfAddress, szAddress);

        DebugTrace((LPARAM) this, "found address [%s]", szAddress);

        //
        // Run it through the addr821 library
        //
        NewAddress = CAddr::CreateAddress(szAddress);
        BOOL fValidAddress = FALSE;
        if(NewAddress)
        {
            if(!NewAddress->IsDomainOffset())
            {
                CAddr * TempAddress = NULL;
                TempAddress = QuerySmtpInstance()->AppendLocalDomain (NewAddress);
                if (TempAddress)
                {
                    delete NewAddress;
                    NewAddress = TempAddress;
                    TempAddress = NULL;
                } else if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                    ErrorTrace((LPARAM) this, "CAddr::CreateAddress (StartOfAddress) failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

            }

            DebugTrace((LPARAM) this, "CreateAddress returned %s", NewAddress->GetAddress());

            ThisAddress = NewAddress->GetAddress();
            DWORD dwLen = strlen(ThisAddress);
            if(Validate821Address(
                ThisAddress,
                dwLen)) {
                
                LPSTR pszDomain;
                if(Get821AddressDomain(
                    ThisAddress,
                    dwLen,
                    &pszDomain) && pszDomain) 
                {
                    DWORD dwDomain = strlen(pszDomain);
                    if (Validate821Domain(pszDomain, dwDomain)) {
                        // everything is valid
                        fValidAddress = TRUE;
                    }
                } else {
                    ErrorTrace((LPARAM)0, "Detected legal address without a domain: %s", 
                               ThisAddress);
                }
            } else {
                ErrorTrace((LPARAM)0, "Detected ILLEGAL address: %s",
                           ThisAddress);
            }
        } else {
            if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
                ErrorTrace((LPARAM) this, "CAddr::CreateAddress (StartOfAddress) failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            ThisAddress = szAddress;
            fValidAddress = FALSE;
        }


        hr = pIMsgRecips->AddPrimary(1, (LPCTSTR *) &ThisAddress, &dwPropId, &dwNewRecipIndex, NULL, 0);
        if (FAILED(hr)) {
            SetLastError(hr);
            return FALSE;
        }

        if (NewAddress) delete NewAddress;

        if (!fValidAddress) {
            // AQ will look for this special domain and won't add it to the
            // DMT.  This stops us from putting corrupted domains into the
            // DMT
            hr = pIMsgRecips->PutStringA(dwNewRecipIndex, 
                                         IMMPID_RP_DOMAIN, 
                                         "==NDR==");
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutString(RP_DOMAIN) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // set the recipient to NDR
            hr = pIMsgRecips->PutDWORD(dwNewRecipIndex,
                                       IMMPID_RP_RECIPIENT_FLAGS,
                                       (RP_ERROR_CONTEXT_CAT | RP_UNRESOLVED));
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutDWORD(RP_FLAGS) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // tell AQ why it is NDRing
            hr = pIMsgRecips->PutDWORD(dwNewRecipIndex,
                                       IMMPID_RP_ERROR_CODE,
                                       CAT_E_ILLEGAL_ADDRESS);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "PutDWORD(RP_ERROR) failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }

            // tell AQ that some recips are NDRing
            hr = pIMsgProps->PutDWORD(IMMPID_MP_HR_CAT_STATUS,
                                      CAT_W_SOME_UNDELIVERABLE_MSGS);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) 0, "SetMailMsgCatStatus failed 0x%x", hr);
                SetLastError(hr);
                return FALSE;
            }
        }

        // Go find the start of the next address
        *EndOfAddress = LastChar;
        if(*p == ',')
        {
            p++;
            while(IS_WHITESPACE_OR_CRLF(*p))
                p++;
        }
    }

    TraceFunctLeave();
    return (TRUE);
}

static HANDLE pOpenPickupFile(LPSTR    szFileName)
{
    DWORD    dwError;
    HANDLE    hFile;

    TraceFunctEnterEx((LPARAM)NULL, "pOpenPickupFile");

    // Open the file
    hFile = CreateFile(szFileName, 
                        GENERIC_READ | GENERIC_WRITE,   
                        FILE_SHARE_DELETE,
                        NULL,                              
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
                        NULL );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        ErrorTrace((LPARAM)NULL, 
                    "Error: Can't open source file %s (err=%d)...skipping it",
                    szFileName, dwError);
    }
    TraceFunctLeaveEx((LPARAM)NULL);
    return(hFile);
}

static inline BOOL pFetchFileBuffer(    HANDLE    hFile,
                                        CHAR    *lpBuffer,
                                        LPDWORD    lpdwSize)
{
    BOOL fRet = TRUE;
    DWORD Error = 0;

    fRet = ReadFile(hFile, lpBuffer, *lpdwSize, lpdwSize, NULL);

    if(!fRet)
    {
        Error = GetLastError();
        if(Error == 998)
        {
            _ASSERT(FALSE);
        }
    }

    return fRet;
}

static CHAR *pGetLineBuffer(CHAR    *lpOldBuffer,
                            DWORD    *lpdwLength)
{
    DWORD dwLength = *lpdwLength;
    CHAR  *lpBuffer;

    if (lpOldBuffer)
    {
        // We have an old buffer, we double the size of the old buffer
        _ASSERT(lpdwLength);
        dwLength <<= 1;
    }
    else
        dwLength = PRIVATE_LINE_BUFFER_SIZE;

    // Allocate the new buffer
    lpBuffer = (CHAR *)HeapAlloc(GetProcessHeap(), 0, dwLength);
    if (!lpBuffer)
        return(NULL);

    if (lpOldBuffer)
    {
        // Copy the info over and free the old buffer
        CopyMemory((LPVOID)lpBuffer, (LPVOID)lpOldBuffer, *lpdwLength);
        _VERIFY( HeapFree(GetProcessHeap(), 0, lpOldBuffer) );
    }

    *lpdwLength = dwLength;
    return(lpBuffer);
}

static BOOL pFreeLineBuffer(CHAR    *lpBuffer)
{
    return( HeapFree(GetProcessHeap(), 0, lpBuffer) );
}

static CHAR *pGetValueFromHeader(CHAR *szHeader)
{
    while (*szHeader && (*szHeader++ != ':'))
        ;
    while (*szHeader)
    {
        if (!IS_SPACE_OR_TAB(*szHeader))
            return(szHeader);
        else
            szHeader++;
    }
    return(NULL);
}

static CHAR *pReadNextLineFromBuffer(   HANDLE   hFile,
                                        CHAR    *lpBuffer,
                                        LPDWORD  lpdwSize,
                                        CHAR    *lpStart,
                                        LPSTR   *ppszLine,
                                        DWORD   *lpdwMaxLineLen,
                                        LPSTR   *ppOriginalBuffer,
                                        DWORD   *lpdwOriginalBufferLen)
{
	DWORD	dwLineLen = 0;
	DWORD	dwMaxLineLen = *lpdwMaxLineLen;
	BOOL	fThisIsCR = FALSE;
	BOOL	fLastIsCR = FALSE;
	BOOL	fThisIsLF = FALSE;
	BOOL	fLastIsLF = FALSE;
	CHAR	*lpEnd;
	CHAR	*lpszLine = *ppszLine;
	CHAR	ch;
	BOOL	bEndOfFile;

	TraceFunctEnter("pReadNextLineFromBuffer");

	_ASSERT(hFile != INVALID_HANDLE_VALUE);
	_ASSERT(!IsBadWritePtr(lpdwSize, sizeof(DWORD)));
	_ASSERT(!IsBadWritePtr(lpBuffer, *lpdwSize));
	_ASSERT(!IsBadWritePtr(*ppszLine, *lpdwMaxLineLen));

	// raid 181922/88855 - replace recusive loop with while loop.
	do {
		dwLineLen = 0;
		dwMaxLineLen = *lpdwMaxLineLen;
		fThisIsCR = FALSE;
		fLastIsCR = FALSE;
		fThisIsLF = FALSE;
		fLastIsLF = FALSE;
	
		bEndOfFile = FALSE;

		// Now, make sure the supplied start pointer is within 
		// buffer supplied (We allow it to be one byte past the
		// end of the buffer, but we will never dereference it).
		if ((lpStart < lpBuffer) || (lpStart > (lpBuffer + *lpdwSize)))
		{
			_ASSERT(0);
			return(NULL);
		}

		// Now, keep copying until we hit one of the following scenarios:
		// i)  We hit CRLF
		// ii) We hit the end of the buffer, which we reload more data
		//     or if it is the end of the mail, we postpend a CRLF.
		lpEnd = lpBuffer + *lpdwSize;
		do
		{
			// See if this is past the buffer
			if (lpStart == lpEnd)
			{
				DWORD	dwNewLength;

				dwNewLength = *lpdwSize;
				if (!pFetchFileBuffer(hFile, lpBuffer, &dwNewLength))
				{
					return(NULL);
				}

				// Done!
				if (!dwNewLength)
				{
					bEndOfFile = TRUE;
					break;
				}

				// Get the new buffer length
				*lpdwSize = dwNewLength;

				// Reset the start and end pointers
				lpStart = lpBuffer;
				lpEnd = lpBuffer + *lpdwSize;
			}

			ch = *lpszLine++ = *lpStart++;

			// Too long?
			if (++dwLineLen >= dwMaxLineLen)
			{
				CHAR *lpTemp;
				DWORD dwUsedPortion = (DWORD)(lpszLine - *ppOriginalBuffer);

				// Yep, get a bigger buffer, all the existing stuff is copied over
				DebugTrace((LPARAM)*ppOriginalBuffer, "Growing buffer at %u bytes", *lpdwOriginalBufferLen);
				lpTemp = pGetLineBuffer(*ppOriginalBuffer, lpdwOriginalBufferLen);
				if (!lpTemp)
				{
					DebugTrace((LPARAM)NULL, "Failed to obtain buffer (%u)", GetLastError());
					TraceFunctLeave();
					return(NULL);
				}

				// Got it, adjust all associated pointers and lengths
				DebugTrace((LPARAM)lpTemp, "Obtained buffer at %u bytes", *lpdwOriginalBufferLen);

				// New beginning of line buffer
				*ppOriginalBuffer = lpTemp;

				// New beginning of line
				*ppszLine = lpTemp;

				// New pointer to next character
				lpszLine = lpTemp + dwUsedPortion;

				// New maximum length for current string before re-growing
				dwMaxLineLen = *lpdwOriginalBufferLen - dwUsedPortion;

			}

			fLastIsCR = fThisIsCR;
			if (ch == '\r')
				fThisIsCR = TRUE;
			else
				fThisIsCR = FALSE;

			fLastIsLF = fThisIsLF;
			if (ch == '\n')
				fThisIsLF = TRUE;
			else
				fThisIsLF = FALSE;

			// If we have CRLF or LFCR we leave
			if ((fLastIsCR && fThisIsLF) || (fLastIsLF && fThisIsCR))
				break;

		} while (1);

		*lpszLine = '\0';

		// Calculate remaining buffer size
		*lpdwMaxLineLen = dwMaxLineLen - dwLineLen;

		// raid 178234 - If we have CRLF or LFCR and no more continue line we leave 
		if (((fLastIsCR && fThisIsLF) || (fLastIsLF && fThisIsCR)) && !IS_SPACE_OR_TAB(*lpStart))
		{
		    // raid 166777 - Make sure we do leave if we find a line.
			break;
		}


	} while (!bEndOfFile && (IS_SPACE_OR_TAB(*lpStart) || (lpStart == lpEnd)));
	
	// We always return the start of line to be the start of our buffer
	// Note that the buffer could have changed during recursion due to growth
	*ppszLine = *ppOriginalBuffer;

	TraceFunctLeave();
	return(lpStart);  
}



BOOL inline WriteToSpooledFile(PFIO_CONTEXT hDstFile, CHAR *lpszLine, DWORD &DestOffset)
{
    DWORD dwBytesToWrite;
    DWORD  dwBytesWritten;
    BOOL fResult = FALSE;
    FH_OVERLAPPED ov;
    DWORD err = NO_ERROR;
    HANDLE HackedHandle = NULL;
    BOOL fRet = FALSE;

    ZeroMemory(&ov, sizeof(ov));

    ov.Offset = DestOffset;

    dwBytesToWrite = lstrlen(lpszLine);
    if (!dwBytesToWrite)
    {
        fRet = TRUE; //This is not really a failure
        goto Exit;
    }

    //HackedHandle = ((DWORD)g_hFileWriteEvent | 1);
    HackedHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(HackedHandle == NULL)
    {
        return FALSE;
    }
    
    ov.hEvent = (HANDLE) ((ULONG_PTR) HackedHandle | 1);

    //ov.hEvent = (HANDLE)HackedHandle;

    fResult = FIOWriteFile(hDstFile, lpszLine, dwBytesToWrite, &ov);

    if (!fResult) err = GetLastError();
    
    if((err == ERROR_IO_PENDING) || (((DWORD)STATUS_PENDING == ov.Internal) && ( err == NO_ERROR )))
    {

        //      12/16/98 - MikeSwa Modified 
        // OK... this is the theory... we are getting random AV, from what
        // looks like async completion to I/O.  It looks like
        // GetOverlappedResult cannot be called to wait for a hacked handle,
        // and it will not use the first argument unless the event in the
        // overlapped structure is NULL.  The solution is to call WaitForSingleObject
        // if we detect that the IO is still pending
        WaitForSingleObject(HackedHandle, INFINITE);
        _ASSERT((DWORD)STATUS_PENDING != ov.Internal);
    }
    else if (NO_ERROR != err)
    {
        SetLastError (err); //preserve the last error
        if(err == 998)
        {
            _ASSERT(FALSE);
        }

        goto Exit;
    }


    DestOffset += dwBytesToWrite;

    fRet = TRUE;

Exit:

    if(HackedHandle)
    {
        CloseHandle(HackedHandle);
    }

    //TraceFunctLeaveEx((LPARAM)NULL);
    return fRet;
}

BOOL CopyRestOfMessage(HANDLE hSrcFile, PFIO_CONTEXT hDstFile, DWORD &DestOffset)
{
    CHAR    acBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    DWORD    dwBytesRead;
    DWORD    dwBytesWritten;
    DWORD    dwTotalBytes = 0;
    DWORD    err = NO_ERROR;
    BOOL    fResult = FALSE;
    BOOL    fRet = FALSE;
    HANDLE  HackedHandle;
    FH_OVERLAPPED ov;

    CHAR    acCrLfDotCrLf[5] = { '\r', '\n', '.', '\r', '\n' };
    CHAR    acLastBytes[5] = { '\0', '\0', '\0', '\0', '\0' };

    // Copies from the current file pointer to the end of hSrcFile 
    // and appends to the current file pointer of hDstFile.
    _ASSERT(hSrcFile != INVALID_HANDLE_VALUE);
    _ASSERT(hDstFile != NULL);

    ZeroMemory(&ov, sizeof(ov));
    
    HackedHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(HackedHandle == NULL)
    {
        return FALSE;
    }
    
    ov.hEvent = (HANDLE) ((ULONG_PTR) HackedHandle | 1);

    do 
    {
        if (!ReadFile(hSrcFile, acBuffer, 
                        PRIVATE_OPTIMAL_BUFFER_SIZE,
                        &dwBytesRead,
                        NULL))
        {
            err = GetLastError();
            if(err == 998)
            {
                _ASSERT(FALSE);
            }

            goto Exit;
        }

        if (dwBytesRead)
        {
            ov.Offset = DestOffset;

            //
            // Save the last two bytes ever read/written. the buffer after
            // writing could be modified due to dot-stripping.
            //
            
            if (dwBytesRead > 4)
            {
                CopyMemory(acLastBytes, &acBuffer[dwBytesRead-5], 5);
            }
            else
            {
                MoveMemory(acLastBytes, &acLastBytes[dwBytesRead], 5-dwBytesRead);
                CopyMemory(&acLastBytes[5-dwBytesRead], acBuffer, dwBytesRead);
            }


            fResult = FIOWriteFile(hDstFile, acBuffer, dwBytesRead, &ov);

            if (!fResult) err = GetLastError();

            if((err == ERROR_IO_PENDING) || (((DWORD)STATUS_PENDING == ov.Internal) && ( err == NO_ERROR )))
            {

                //      12/16/98 - MikeSwa Modified 
                // OK... this is the theory... we are getting random AV, from what
                // looks like async completion to I/O.  It looks like
                // GetOverlappedResult cannot be called to wait for a hacked handle,
                // and it will not use the first argument unless the event in the
                // overlapped structure is NULL.  The solution is to call 
                // WaitForSingleObject and pass in the un-munged handle (only if 
                // we know that IO is still pending).
                WaitForSingleObject(HackedHandle, INFINITE);
                _ASSERT((DWORD)STATUS_PENDING != ov.Internal);
            }
            else if (NO_ERROR != err)
            {
                SetLastError (err); //preserve the last error
                if(err == 998)
                {
                    _ASSERT(FALSE);
                }

                goto Exit;
            }

            //
            // this is because Fcache keeps track of the offset were we need
            // to write. So we update dwBytesWritten to what we actually read.
            //
            dwBytesWritten = dwBytesRead;
        }
        else
        {
            dwBytesWritten = 0;
        }

        if (dwBytesWritten)
        {
            dwTotalBytes += dwBytesWritten;
            DestOffset += dwBytesWritten;
        }

    } while (dwBytesRead);

    // Now, see if the file ends with a CRLF, if not, add it
    if ((dwTotalBytes > 1) && memcmp(&acLastBytes[3], &acCrLfDotCrLf[3], 2))
    {
        // Add the trailing CRLF        
        if (!WriteToSpooledFile(hDstFile, "\r\n", DestOffset)) 
        {
            goto Exit;
        }

        dwTotalBytes+=2;

    }

    //If file ends with CRLF.CRLF, remove the trailing .CRLF
    //NimishK ** : this was decided per the bug 63394
    if ((dwTotalBytes > 4) && !memcmp(acLastBytes, acCrLfDotCrLf, 5))
    {
        DWORD dwFileSizeHigh = 0;
        DWORD dwFileSizeLow = GetFileSizeFromContext( hDstFile, &dwFileSizeHigh );

        DWORD Offset = SetFilePointer(hDstFile->m_hFile, dwFileSizeLow, NULL, FILE_BEGIN);

        // Remove the trailing CRLF only as the <DOT> would have been removed by
        // dot-stripping by file handle cache.
        if ((SetFilePointer(hDstFile->m_hFile, -2, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile->m_hFile))
        {
            _ASSERT(0 && "SetFilePointerFailed");
            goto Exit;
        }
    }

    fRet = TRUE;


Exit:

    if(HackedHandle)
    {
        CloseHandle(HackedHandle);
    }

    return fRet;
}



BOOL SMTP_DIRNOT::ProcessFile(IMailMsgProperties *pIMsg)
{
    LONGLONG                 LastAccessTime = (LONGLONG) 0;
    CHAR*                    acCrLf = "\r\n";
    DWORD                    AbOffset = 0;
    DWORD                    DestWriteOffset = 0;
    DWORD                    HeaderFlags = 0;
    DWORD                    dwPickupFileSize = 0;
    BOOL                     fIsStartOfFile = TRUE;
    BOOL                     fIsXSenderRead = FALSE;
    BOOL                     fAreXRcptsRead = FALSE;
    BOOL                     fIsSenderSeen = FALSE;
    BOOL                     fInvalidAddresses = FALSE;
    BOOL                     fDateExists = FALSE;
    BOOL                     fMessageIdExists = FALSE;
    BOOL                     fXOriginalArrivalTime = FALSE;
    BOOL                     fFromSeen = FALSE;
    BOOL                     fRcptSeen = FALSE;
    BOOL                     fSeenRFC822FromAddress = FALSE;
    BOOL                     fSeenRFC822ToAddress = FALSE;
    BOOL                     fSeenRFC822CcAddress = FALSE;
    BOOL                     fSeenRFC822BccAddress = FALSE;
    BOOL                     fSeenRFC822Subject = FALSE;
    BOOL                     fSeenRFC822SenderAddress = FALSE;
    BOOL                     fSeenXPriority = FALSE;
    BOOL                     fSeenContentType = FALSE;
    BOOL                     fSetContentType = FALSE;
    HANDLE                   hSource = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT             hDest = NULL;
    SYSTEMTIME               SysTime;
    DWORD                    dwLineBufferSize = 0;
    DWORD                    dwMaxLineSize = 0;
    CHAR*                    szLineBuffer = NULL;
    CHAR*                    szLine = NULL;
    CHAR*                    szValue = NULL;
    CHAR                     szScratch[512];
    CHAR                     szMsgId[512];
    CHAR                     acReadBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    CHAR                     szPickupFilePath[MAX_PATH + 1];
    CHAR                     szDateBuf [cMaxArpaDate];
    DWORD                    dwBufferSize = 0;
    CHAR                     FileName[MAX_PATH + 1];
    CHAR*                    lpStart = NULL;
    CHAR*                    lpXMarker = NULL;
    DWORD                    dwBytesToRewind = 0;
    LONG                     lOffset = 0;
    CAddr*                   Sender = NULL;
    PSMTP_IIS_SERVICE        pService = NULL;
    IMailMsgRecipientsAdd*   pIMsgRecips = NULL;
    IMailMsgRecipients*      pIMsgOrigRecips = NULL;
    IMailMsgBind*            pBindInterface = NULL;
    HRESULT                  hr = S_OK;
    DWORD                    dwTotalRecips = 0;
    SMTP_ALLOC_PARAMS        AllocParams;
    BOOL                     fResult = FALSE;
    BOOL                     DeleteIMsg = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::ProcessFile" );

    _ASSERT(m_pInstance != NULL);
    _ASSERT(pIMsg);
    if (!pIMsg)
    {
        ErrorTrace((LPARAM)this, "Internal error: pIMsg is NULL.");
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    // Compose the pickup path
    hr = pIMsg->GetStringA(IMMPID_MP_PICKUP_FILE_NAME, sizeof(FileName), FileName);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "MailQEntry->GetFileName() is NULL.");
        goto RetryPickup;
    }

    hr = pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&pBindInterface);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "IMsg->QueryInterface(IID_IMailMsgBindATQ) failed.");
        goto RetryPickup;
    }

    //Get recipient list
    hr = pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &pIMsgOrigRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "IMsg->QueryInterface(IID_IMailMsgRecipients) failed.");
        goto RetryPickup;
    }

    hr = pIMsgOrigRecips->AllocNewList(&pIMsgRecips);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "pIMsgOrigRecips->AllocNewList");
        goto RetryPickup;
    }

    _snprintf(szPickupFilePath, sizeof(szPickupFilePath)-1, "%s%s", QuerySmtpInstance()->GetMailPickupDir(), FileName);
    szPickupFilePath[sizeof(szPickupFilePath)-1]='\0';

    // Open the pickup file, if this failsas a sharing violation,
    // we would like to retry it ...
    hSource = pOpenPickupFile(szPickupFilePath);
    if (hSource == INVALID_HANDLE_VALUE)
    {   //
        // this is probably caused by the file still being written, wait a small amount of time
        // we manage our IO compl. threads to ensure that there are enough, so this shouldn't be
        // a big problem.  It avoids the retry queue.
        //

        WaitForSingleObject(QuerySmtpInstance()->GetQStopEvent(), g_PickupWait);
        
        hSource = pOpenPickupFile(szPickupFilePath);
        if (hSource == INVALID_HANDLE_VALUE)
        {
        
            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                //delete MailQEntry;
                ErrorTrace((LPARAM)this, "File %s is deleted from pickup dir", szPickupFilePath);
                goto RetryPickup;
            }

        // Schedule pickup mail for retry ...
        goto RetryPickup;
        }
    }

    AllocParams.BindInterfacePtr = (PVOID) pBindInterface;
    AllocParams.IMsgPtr = (PVOID)pIMsg;
    AllocParams.hContent = NULL;
    AllocParams.pAtqClientContext = QuerySmtpInstance();
    AllocParams.m_pNotify = NULL;
    fResult = QuerySmtpInstance()->AllocNewMessage (&AllocParams);

    //Get the context and the atq context
    hDest = AllocParams.hContent;

    if((!fResult) || (hDest == NULL))
    {
        goto RetryPickup;
    }

    // Get the handle of the spooled file
    _ASSERT(hDest != NULL);

    //
    // Winse:13699 and X5:174038
    // Remove Dot stuffing based on the metabase key.
    // Default behavior is that pickup directory messages are dot stuffed.
    // If the metabase key DisablePickupDotStuff is set then the pickup directory
    // messages should not be dot stuffed.
    //
    
    if( !SetDotStuffingOnWrites( hDest, !m_pInstance->DisablePickupDotStuff(), TRUE ) )
    {
        ErrorTrace((LPARAM)this, "SetDotStuffingonWrites failed" );
        goto RetryPickup;
    }
    
    // Spit a Received: line to the spooled file
    GetArpaDate(szDateBuf);
    GetLocalTime(&SysTime);

    // Allocate the needed line buffer
    szLineBuffer = pGetLineBuffer(NULL, &dwLineBufferSize);
    if (!szLineBuffer)
    {
        // Schedule pickup mail for retry ...
        ErrorTrace((LPARAM)this, "Unable to allocate line buffer (%u)", GetLastError());
        goto RetryPickup;
    }

    DebugTrace((LPARAM)this, "Allocated line buffer at %p, %u bytes", szLineBuffer, dwLineBufferSize);

    // Set up the line pointers
    szLine = szLineBuffer;
    dwMaxLineSize = dwLineBufferSize;

    // Prefetch a buffer-full of text
    dwBufferSize = PRIVATE_OPTIMAL_BUFFER_SIZE;
    if (!pFetchFileBuffer(hSource, acReadBuffer, &dwBufferSize))
    {
        // Schedule pickup mail for retry ...
        ErrorTrace((LPARAM)this, "Retrying because cannot fetch file buffer (%u)",GetLastError());
        goto RetryPickup;
    }

    m_pInstance->LockGenCrit();
    wsprintf( szScratch,
              "Received: from mail pickup service by %s with Microsoft SMTPSVC;\r\n\t %s, %s\r\n",
              QuerySmtpInstance()->GetFQDomainName(),
              Daynames[SysTime.wDayOfWeek],
              szDateBuf);
    m_pInstance->UnLockGenCrit();    

    //We will copy out to the temp out buffer
    //NK** : This is a safe assumption that this will not result in IO
#if 0
    if ((SetFilePointer(hDest, 0, NULL, FILE_BEGIN) == 0xffffffff) ||
        !WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
#else
    if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
#endif
        goto RetryPickup;

    lpStart = acReadBuffer;
    while (1)
    {
        HeaderFlags = 0;

        // The X marker is used to mark the start of the 
        // non-X-headers if X-headers are used
        if (fIsStartOfFile)
            lpXMarker = lpStart;

        // This function will read a complete header line,
        // into a single NULL-terminated string.
        // Raid 181922 - The function no longer unfolds the line.
        if (!(lpStart = pReadNextLineFromBuffer( hSource, 
                                                 acReadBuffer, 
                                                 &dwBufferSize, 
                                                 lpStart, 
                                                 &szLine,
                                                 &dwMaxLineSize,
                                                 &szLineBuffer,
                                                 &dwLineBufferSize)))
        {
            // We failed a file operation, we will retry later
            goto RetryPickup;
        }

        // See if we are still in the header portion of the body
        if (!IsHeader(szLine))
            break;

        // Get the set of headers that we know about.
        ChompHeader(szLine, HeaderFlags);
        szValue = pGetValueFromHeader(szLine);
        if(!szValue)
        {
            continue;
        }


        // Strip away the CRLF at the end of the value string
        lOffset = lstrlen(szValue);
        if (lOffset >= 2)
        {
            if (((szValue[lOffset-2] == '\r') && (szValue[lOffset-1] == '\n')) ||
                ((szValue[lOffset-2] == '\n') && (szValue[lOffset-1] == '\r')))

                
                szValue[lOffset-2] = '\0';
        }

        hr = GetAndPersistRFC822Headers( szLine,
                                         szValue,
                                         pIMsg,
                                         fSeenRFC822FromAddress,
                                         fSeenRFC822ToAddress,
                                         fSeenRFC822BccAddress,
                                         fSeenRFC822CcAddress,
                                         fSeenRFC822Subject,
                                         fSeenRFC822SenderAddress,
                                         fSeenXPriority,
                                         fSeenContentType,
                                         fSetContentType );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot getAndPersistRFC822 headers(%x)", hr);
            goto RetryPickup;
        }
            

        // Check for leading X-Sender and X-Receiver header lines ...
        if (fIsStartOfFile)
        {
            if (HeaderFlags & H_X_SENDER)
            {
                // NOTE: if we have more than one sender, 
                // we always use the first one encountered

                // Yes, we found an X-header
                fIsXSenderRead = TRUE;
            }
            else if (HeaderFlags & H_X_RECEIVER)
            {
                // We don't check for sender here, since if we don't
                // have one, we will barf downstream

                // Yes, we found an X-header
                fAreXRcptsRead = TRUE;
            }
            else
            {
                // We are done with our X-headers, now we have
                // normal headers!
                fIsStartOfFile = FALSE;
            }
        }

        if (HeaderFlags & H_FROM)
        {
            fFromSeen = TRUE;
        }

        if (HeaderFlags & H_RCPT)
        {
            fRcptSeen = TRUE;
        }


        // Handle senders and recipients
        if (!fIsSenderSeen && ((HeaderFlags & H_X_SENDER) || (HeaderFlags & H_FROM)))
        {
            // Selectively do so
            if (fIsStartOfFile || !fIsXSenderRead)
            {
                char    *Address = NULL;
                DWORD    cbText = 0;
                DWORD   dwlen = strlen(szValue);
                _ASSERT(dwlen < 512 );

                Sender = CAddr::CreateAddress (szValue, FROMADDR);
                if (Sender)
                {
                    Address = Sender->GetAddress();
                    if(!Sender->IsDomainOffset() && !ISNULLADDRESS(Address))
                    {
                        CAddr * TempAddress = NULL;
                        TempAddress = QuerySmtpInstance()->AppendLocalDomain (Sender);
                        delete Sender;
                        if (TempAddress)
                        {
                            Sender = TempAddress;
                            Address = Sender->GetAddress();
                            TempAddress = NULL;
                        }
                        else
                        {
                            ErrorTrace((LPARAM) this,"Retrying because cannot to append local domain (%u)",GetLastError());
                            goto RetryPickup;
                        }
                    }

                    // Set the size of the FromName so that we can
                    // read it out of the queue file if we need it.
                    //cbText = lstrlen(Address) + 1;
                    //MailQEntry->SetFromNameSize (cbText);
                    //MailQEntry->SetSenderToStream(Address);
                    hr = pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, Address);
                    fIsSenderSeen = TRUE;
                }
                else
                {
                    // Undo the flag
                    if (fIsXSenderRead)
                        fIsXSenderRead = FALSE;

                    // If the sender is not invalid, it is likely to be a
                    // resource constraint, so we go and retry it
                    if (GetLastError() != ERROR_INVALID_DATA)
                    {
                        ErrorTrace((LPARAM)this, "Retrying because cannot allocate sender (%u)", GetLastError());
                        goto RetryPickup;
                    }
                }
            }
        }
        else if ((HeaderFlags & H_X_RECEIVER) || (HeaderFlags & H_RCPT))
        {
            // Selectively do so
            if (fIsStartOfFile || !fAreXRcptsRead)
            {
                DebugTrace((LPARAM)szLine, "To: line read <%s>", szValue);

                if (!CreateToList(szValue, pIMsgRecips, pIMsg))
                {
                    // If we're out of memory, we retry.
                    // If it is an invalid address, we remember the fact and
                    // remember to throw a copy into badmail
                    if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
                    {
                        ErrorTrace((LPARAM)this, "Retrying because cannot allocate recipient (%u)", GetLastError());
                        goto RetryPickup;
                    }
                    else
                        fInvalidAddresses = TRUE;
                }

                if (fIsStartOfFile)
                {
                    // X-headers!
                    lpXMarker = lpStart;
                }
            }
        }
        else if (HeaderFlags & H_MID)
        {
            // Message-ID already exists
            fMessageIdExists = TRUE;
            hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID , szValue );
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of IMMPID_MP_RFC822_MSG_ID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
            
        }
        else if (HeaderFlags & H_DATE)
        {
            // Date line already exists
            fDateExists = TRUE;
        }
        //      10/15/98 - MikeSwa Added supersedes functionality
        else if (HeaderFlags & H_X_MSGGUID)
        {
            hr = pIMsg->PutStringA(IMMPID_MP_MSG_GUID, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of MSG_GUID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
        else if (HeaderFlags & H_X_SUPERSEDES_MSGGUID)
        {
            hr = pIMsg->PutStringA(IMMPID_MP_SUPERSEDES_MSG_GUID, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of SUPERSEDES_MSG_GUID failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
        else if( HeaderFlags & H_X_ORIGINAL_ARRIVAL_TIME )
        {
            fXOriginalArrivalTime = TRUE;
            hr = pIMsg->PutStringA(IMMPID_MP_ORIGINAL_ARRIVAL_TIME, szValue);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "PutStringA of ORIGINAL_ARRIVAL_TIME failed - hr 0x%08X", hr);
                goto RetryPickup;
            }
        }
            

        // If this is an ordinary header, we will dump this to 
        // the spooled file
        if (!fIsStartOfFile)
        {
            // Non-x-header; dump the line!
            lstrcat(szLine, acCrLf);
            if (!WriteToSpooledFile(hDest, szLine, DestWriteOffset))
            {
                ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
                goto RetryPickup;
            }
        }
    }

    hr = pIMsg->PutStringA(IMMPID_MP_HELO_DOMAIN, m_pInstance->GetDefaultDomain());
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString(helo domain) failed (%x)", hr);
        goto RetryPickup;

    }

    hr = pIMsg->PutStringA(IMMPID_MP_CONNECTION_IP_ADDRESS, DIRNOT_IP_ADDRESS);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString(IP address) failed (%x)", hr);
        goto RetryPickup;

    }

    hr = SetAvailableMailMsgProperties( pIMsg );
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->PutString( for all available props) failed (%x)", hr);
        goto RetryPickup;

    }
    
    wsprintf( szScratch,
              "%s, %s",
              Daynames[SysTime.wDayOfWeek],
              szDateBuf);

    

    hr = pIMsg->PutStringA(IMMPID_MP_ARRIVAL_TIME, szScratch);
    if( FAILED( hr ) )
    {
        ErrorTrace((LPARAM)this,"Retrying because cannot putString IMPPID_MP_ARRIVAL_TIME (%x)", hr);
        goto RetryPickup;
    }


    // Now, before we go on and waste time on copying the rest of the message, etc.
    // we want to make sure we saw the sender and at least one valid recipient.
    // If not, we will just move the message to bad mail and be done with it.

    hr = pIMsgRecips->Count(&dwTotalRecips);
    if (!fIsSenderSeen || FAILED(hr) || (dwTotalRecips == 0))
    {
        // If no recipients but sender is seen, we must not leak the sender
        // object
        if (fIsSenderSeen)
        {
            delete Sender;
            Sender = NULL;
        }

        _VERIFY( pFreeLineBuffer(szLineBuffer) );
        szLineBuffer = NULL;
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }

        if(FAILED(hr))
        {
            goto RetryPickup;
        }
        else
        {
            // No choice but move to bad mail directory
            if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir()) )
            {
                if (!DeleteFile(szPickupFilePath))
                {
                    DWORD dwError = GetLastError();
                    ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
                }
            }
            goto RetryPickup;
        }
    }

    hr = pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, dwTotalRecips );
    if( FAILED( hr ) )
    {
        ErrorTrace((LPARAM)this,"Retrying because cannot putDWORD IMPPID_MP_NUM_RECIPIENTS (%x)", hr);
        goto RetryPickup;
    }
        



    // if we did not read a From Line, create a From: line from the xSender.
    // if we did not read a To, CC, BCC line, create a To: line from the xReceiver.
    if (!fFromSeen)
    {
        char    *Address = NULL;
        char    szUserName[MAX_INTERNET_NAME + 9];  // for the "From: %s\r\n" below

        Address = Sender->GetAddress();
        
        if (!Address)
        {
            _VERIFY( pFreeLineBuffer(szLineBuffer) );
            szLineBuffer = NULL;
            if (hSource != INVALID_HANDLE_VALUE)
            {
                _VERIFY( CloseHandle(hSource) );
                hSource = INVALID_HANDLE_VALUE;
            }

            // No choice but move to bad mail directory
            if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir()) )
            {
                if (!DeleteFile(szPickupFilePath))
                {
                    DWORD dwError = GetLastError();
                    ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
                }
            }
            goto RetryPickup;
        }

        wsprintf(szUserName, "From: %s\r\n", Address);
        
        if (!WriteToSpooledFile(hDest, szUserName, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this,"Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }


    if (!fRcptSeen)
    {
        //
        // fix for bug: 78275
        // add an emty Bcc line:
        //
        static char *    endRcpt = "Bcc:\r\n";

        if (!WriteToSpooledFile(hDest, endRcpt, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }    
    }


    if (fIsSenderSeen)
    {                    
        delete Sender;
    }




    // We still have to dump the current line to the spool
    // file, then we copy the rest over.
    // Since we use buffered read, the current file position
    // really doesn't mean much. So we calculate how many bytes
    // we have to rewind
    dwBytesToRewind = dwBufferSize - (DWORD)(lpStart - acReadBuffer);

    // Negative, since we are going backwards
    _ASSERT(dwBytesToRewind <= PRIVATE_OPTIMAL_BUFFER_SIZE);
    lOffset = -(long)dwBytesToRewind;
    if (SetFilePointer(hSource, lOffset, NULL, FILE_CURRENT) 
            == 0xffffffff) 
    {
        ErrorTrace((LPARAM)this, 
                        "Retrying because cannot move file pointer (%u)", 
                        GetLastError());
        goto RetryPickup;
    }

    // See if we have to add a Date: or Message-ID: line
    if (!fMessageIdExists)
    {
        char    MessageId[MAX_PATH];

        MessageId[0] = '\0';

        GenerateMessageId (MessageId, sizeof(MessageId));
        
        m_pInstance->LockGenCrit();
        wsprintf( szMsgId, "<%s%8.8x@%s>", MessageId, GetIncreasingMsgId(),QuerySmtpInstance()->GetFQDomainName());
        m_pInstance->UnLockGenCrit();
        
        wsprintf(szScratch, "Message-ID: %s\r\n",szMsgId );
                

        hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, szMsgId );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because Put string of IMMPID_MP_RFC822 failed (%x)", hr );
            goto RetryPickup;
        }
            

        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    //
    // see if we have to add Original Arrival time
    //
    
    if (!fXOriginalArrivalTime )
    {
        char    szOriginalArrivalTime[64];

        szOriginalArrivalTime[0] = '\0';

        GetSysAndFileTimeAsString( szOriginalArrivalTime );
        
        wsprintf(szScratch, "X-OriginalArrivalTime: %s\r\n",szOriginalArrivalTime );
                

        hr = pIMsg->PutStringA( IMMPID_MP_ORIGINAL_ARRIVAL_TIME, szOriginalArrivalTime );
        if( FAILED( hr ) )
        {
            ErrorTrace((LPARAM)this, "Retrying because Put string of IMMPID_MP_ORIGINAL_ARRIVAL_TIME failed (%x)", hr );
            goto RetryPickup;
        }
            

        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    //
    // see if we have to add the date
    //
    
    if (!fDateExists)
    {
        lstrcpy(szScratch, "Date: ");
        lstrcat(szScratch, szDateBuf);
        lstrcat(szScratch, acCrLf);
        if (!WriteToSpooledFile(hDest, szScratch, DestWriteOffset))
        {
            ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
            goto RetryPickup;
        }
    }

    // Write out the currently buffered line, then copy the 
    // pickup file to the spooler
    if (!WriteToSpooledFile(hDest, szLine, DestWriteOffset) ||
        !CopyRestOfMessage(hSource, hDest, DestWriteOffset))
    {
        ErrorTrace((LPARAM)this, "Retrying because cannot write to file (%u)", GetLastError());
        goto RetryPickup;
    }

    // We will no longer read headers at this point, so we free our
    // line buffer here ...
    DebugTrace((LPARAM)this, "Freeing line buffer at %p, %u bytes", szLineBuffer, dwLineBufferSize);
    _VERIFY( pFreeLineBuffer(szLineBuffer) );
    szLineBuffer = NULL;

    // Get the size of the spooled file before we close it
    DWORD dwFileSizeHigh;
    dwPickupFileSize = GetFileSizeFromContext(hDest, &dwFileSizeHigh);
    _ASSERT(dwFileSizeHigh == 0); // why??
    
    if (dwPickupFileSize == 0xffffffff)
    {
        dwPickupFileSize = 0;
    }

    pIMsg->PutDWORD( IMMPID_MP_MSG_SIZE_HINT, dwPickupFileSize );
    

    // Now, we see if there are any invalid addresses; if so, we will 
    // throw a copy og the original message into the badmail directory
    if (fInvalidAddresses)
    {
        // Close the pickup file
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }

        // Move it to badmail instead of deleting it
        DebugTrace((LPARAM)this, "Saving a copy in badmail due to bad recipients");
    
        // No choice but move to bad mail directory
        if( !QuerySmtpInstance()->MoveToBadMail( pIMsg, FALSE, FileName, QuerySmtpInstance()->GetMailPickupDir() ) )
        {
            if (!DeleteFile(szPickupFilePath))
            {
                DWORD dwError = GetLastError();
                ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
            }
        }
            
    }
    else
    {
        // Delete the file
        if (!DeleteFile(szPickupFilePath))
        {
            DWORD dwError = GetLastError();
            ErrorTrace((LPARAM)this, "Error deleting file %s (%u)", szPickupFilePath, dwError);
        }
        // Close the pickup file
        if (hSource != INVALID_HANDLE_VALUE)
        {
            _VERIFY( CloseHandle(hSource) );
            hSource = INVALID_HANDLE_VALUE;
        }
    }

    //
    // put the file into the local queue. 
    //

    pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

    hr = pIMsgOrigRecips->WriteList(pIMsgRecips);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsgOrigRecips->WriteList failed (%x)", hr);
        goto RetryPickup;
    }

    
    //
    // we scan for dots & strip them away while storing, so set these two properties
    // so we can get the dot stuffed context while sending it out.
    //
    
    pIMsg->PutDWORD( IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF, TRUE );
    pIMsg->PutDWORD( IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, TRUE );

    CompleteDotStuffingOnWrites( hDest, TRUE );

    hr = pIMsg->Commit(NULL);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Retrying because pIMsg->Commit(NULL) failed (%u)", 
                        hr);
        goto RetryPickup;
    } 

    pIMsgRecips->Release();
    pIMsgOrigRecips->Release();
    pIMsgRecips = NULL;
    pIMsgOrigRecips = NULL;

    if(m_pInstance->InsertIntoQueue(pIMsg))
    {
        DeleteIMsg = FALSE;
        
        // Up the msgs received and avg bytes per message counters
        ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (dwPickupFileSize));
        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsForwarded);
    }

RetryPickup:

    IMailMsgQueueMgmt * pMgmt = NULL;

    if(pBindInterface)
    {
        pBindInterface->Release();
    }

    if(pIMsgRecips)
    {
        pIMsgRecips->Release();
        pIMsgRecips = NULL;
    }

    if(pIMsgOrigRecips)
    {
        pIMsgOrigRecips->Release();
        pIMsgOrigRecips = NULL;
    }

    if(DeleteIMsg)
    {
        hr = pIMsg->QueryInterface(IID_IMailMsgQueueMgmt, (void **)&pMgmt);
        if(!FAILED(hr))
        {
            pMgmt->Delete(NULL);
            pMgmt->Release();
        }
    }

    if(pIMsg)
    {
        pIMsg->Release();
        pIMsg = NULL;
    }

    // Retry message
    if (szLineBuffer)
    {
        _VERIFY( pFreeLineBuffer(szLineBuffer) );
        szLineBuffer = NULL;
    }

    if (hSource != INVALID_HANDLE_VALUE)
    {
        _VERIFY( CloseHandle( hSource ) );
        hSource = INVALID_HANDLE_VALUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_DIRNOT::GetAndPersistRFC822Headers(
    char* InputLine,
    char* pszValueBuf,
    IMailMsgProperties* pIMsg,
    BOOL & fSeenRFC822FromAddress,
    BOOL & fSeenRFC822ToAddress,
    BOOL & fSeenRFC822BccAddress,
    BOOL & fSeenRFC822CcAddress,
    BOOL & fSeenRFC822Subject,
    BOOL & fSeenRFC822SenderAddress,
    BOOL & fSeenXPriority,
    BOOL & fSeenContentType,
    BOOL & fSetContentType
    )
{
    HRESULT hr = S_OK;
    
    //
    // get the Subject:  & persist it
    //
    
    if( !fSeenRFC822Subject &&
        ( !strncasecmp( InputLine, "Subject:", strlen("Subject:") ) ||
          !strncasecmp( InputLine, "Subject :", strlen("Subject :") ) ) )
    {
        fSeenRFC822Subject = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_SUBJECT, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the To: address & persist it
    //
    
    if( !fSeenRFC822ToAddress &&
        ( !strncasecmp( InputLine, "To:", strlen("To:") ) ||
          !strncasecmp( InputLine, "To :", strlen("To :") ) ) )
    {
        fSeenRFC822ToAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_TO_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the Cc: address & persist it
    //
    
    if( !fSeenRFC822CcAddress &&
        ( !strncasecmp( InputLine, "Cc:", strlen("Cc:") ) ||
          !strncasecmp( InputLine, "Cc :", strlen("Cc :") ) ) )
    {
        fSeenRFC822CcAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_CC_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the Bcc: address & persist it
    //
    
    if( !fSeenRFC822BccAddress &&
        ( !strncasecmp( InputLine, "Bcc:", strlen("Bcc:") ) ||
          !strncasecmp( InputLine, "Bcc :", strlen("Bcc :") ) ) )
    {
        fSeenRFC822BccAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_BCC_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the From: address & persist it
    //
    
    if( !fSeenRFC822FromAddress &&
        ( !strncasecmp( InputLine, "From:", strlen("From:") ) ||
          !strncasecmp( InputLine, "From :", strlen("From :") ) ) )
    {
        fSeenRFC822FromAddress = TRUE;
        
        if( pszValueBuf )
        {
            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, pszValueBuf ) ) )
            {
                return( hr );
            }

        }

        char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
        char *pszDomainOffset;
        DWORD cAddr;
        if (CAddr::ExtractCleanEmailName(szSmtpFromAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
            if (FAILED(hr = pIMsg->PutStringA(IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress))) {
                return hr;
            }
        }
    }

    if( !fSeenRFC822SenderAddress &&
        ( !strncasecmp( InputLine, "Sender:", strlen("Sender:") ) ||
          !strncasecmp( InputLine, "Sender :", strlen("Sender :") ) ) )
    {
        fSeenRFC822SenderAddress = TRUE;
        
        if( pszValueBuf )
        {
            char szSmtpSenderAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpSenderAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS, szSmtpSenderAddress))) {
                    return hr;
                }
            }            
        }
    
    }

    //
    // get the X-Priority & persist it
    //
    
    if( !fSeenXPriority &&
        ( !strncasecmp( InputLine, "X-Priority:", strlen("X-Priority:") ) ||
          !strncasecmp( InputLine, "X-Priority :", strlen("X-Priority :") ) ) )
    {
        fSeenXPriority = TRUE;
        
        if( pszValueBuf )
        {
            DWORD dwPri = (DWORD)atoi( pszValueBuf );
            if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_X_PRIORITY, dwPri ) ) )
            {
                return( hr );
            }
        }
    
    }

    //
    // get the content type & persist it
    //
    
    if( !fSeenContentType &&
        ( !strncasecmp( InputLine, "Content-Type:", strlen("Content-Type:") ) ||
          !strncasecmp( InputLine, "Content-Type :", strlen("Content-Type :") ) ) )
    {
        fSeenContentType = TRUE;
        fSetContentType = TRUE;
        DWORD dwContentType = 0;

        if( pszValueBuf )
        {
            if( !strncasecmp( pszValueBuf, "multipart/signed", strlen("multipart/signed") ) )
            {
                dwContentType = 1;
            }
            else if( !strncasecmp( pszValueBuf, "application/x-pkcs7-mime", strlen("application/x-pkcs7-mime") ) ||
                     !strncasecmp( pszValueBuf, "application/pkcs7-mime", strlen("application/pkcs7-mime") ) )
            {
                dwContentType = 2;
            }

            if( FAILED( hr = pIMsg->PutStringA( IMMPID_MP_CONTENT_TYPE, pszValueBuf ) ) )
            {
                return( hr );
            }
        }

        if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, dwContentType ) ) )
        {
            return( hr );
        }
    }

    if( !fSetContentType )
    {
        fSetContentType =   TRUE;
        
        if( FAILED( hr = pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, 0 ) ) )
        {
            return( hr );
        }
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_DIRNOT::SetAvailableMailMsgProperties( IMailMsgProperties *pIMsg )
{
    
    //set IPaddress that is already available
    HRESULT hr = S_OK;
    
    hr = pIMsg->PutStringA(IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS, DIRNOT_IP_ADDRESS);
    if(FAILED(hr))
    {
        return( hr );
    }
    
    hr = pIMsg->PutStringA(IMMPID_MP_SERVER_NAME, g_ComputerName);
    if(FAILED(hr))
    {
        return( hr );
    }
    
    hr = pIMsg->PutStringA(IMMPID_MP_SERVER_VERSION, g_VersionString);
    if(FAILED(hr))
    {
        return( hr );
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
void SMTP_DIRNOT::CreateLocalDeliveryThread (void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_DIRNOT::CreateLocalDeliveryThread");
    //
    // Add a delivery thread with the ATQPorts Overlapped structure. For the dir notifications, 
    // our overlapped structure is used... this is how we tell the difference in Process Client.
    //
    IncPendingIoCount();
    if(!AtqPostCompletionStatus(QueryAtqContext(), 50))
    {
        DecPendingIoCount();
        ErrorTrace((LPARAM) this,"AtqPostCompletionStatus() failed with error %d", GetLastError());
    }
    
    TraceFunctLeaveEx((LPARAM)this);
}



//////////////////////////////////////////////////////////////////////////////
BOOL SMTP_DIRNOT::PendDirChangeNotification (void)
{
    CBuffer * pBuffer = NULL;
    DWORD nBytes = 0;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::PendDirChangeNotification" );

    _ASSERT(m_pInstance != NULL);
    _ASSERT(m_hDir != INVALID_HANDLE_VALUE);

    //get a new buffer
    pBuffer = new CBuffer();
    if(pBuffer == NULL)
    {
        ErrorTrace((LPARAM) this, "pBuffer = new CBuffer()failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if(pBuffer->GetData() == NULL)
    {
        ErrorTrace((LPARAM) this, "pBuffer = new CBuffer()->GetData failed . err: %u", ERROR_NOT_ENOUGH_MEMORY);
        delete pBuffer;
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    QuerySmtpInstance()->IncCBufferObjs ();

    IncPendingIoCount();
    IncDirChangeIoCount();

    if(!AtqReadDirChanges(QueryAtqContext(),pBuffer->GetData(),QuerySmtpInstance()->GetDirBufferSize(),
                            FALSE,FILE_NOTIFY_CHANGE_FILE_NAME,
                            (OVERLAPPED *) &pBuffer->m_Overlapped.SeoOverlapped.Overlapped))
    {
        Error = GetLastError();
        ErrorTrace((LPARAM) this, "ReadDirectoryChangesW failed . err: %u", Error);
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
    
        //decrement over all I/O count
        DecPendingIoCount();
        DecDirChangeIoCount();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;

    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_DIRNOT::ProcessDirNotification( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    CHAR FileName[MAX_PATH + 1];
    PFILE_NOTIFY_INFORMATION Info = NULL;
    DWORD FileNameLength = 0;
    DWORD ServerState;
    CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "SMTP_DIRNOT::ProcessDirNotification" );

    _ASSERT(m_pInstance != NULL);

    //
    // pend a new notification to replace the one we are currently using... there will still be
    // a couple outstanding unless we are shutting down.
    //

    if (!PendDirChangeNotification())
        ErrorTrace((LPARAM)this, "PendDirChangeNotification() failed");

    if (!QuerySmtpInstance()->GetAcceptConnBool())
    {
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }


    if(dwCompletionStatus != NO_ERROR)
    {
        ErrorTrace((LPARAM) this, "SMTP_DIRNOT::ProcessDirNotification received error %d", dwCompletionStatus);
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    ServerState = QuerySmtpInstance()->QueryServerState( );

    //if we are not running, just delete
    if( (ServerState == MD_SERVER_STATE_STOPPED ) || (ServerState == MD_SERVER_STATE_INVALID))
    {
        delete pBuffer;
        QuerySmtpInstance()->DecCBufferObjs ();
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }


    if(InputBufferLen)
    {
        Info = (PFILE_NOTIFY_INFORMATION) pBuffer->GetData();
        while (1)
        {
            //we only care about files added to this
            //directory
            //if(Info->Action == FILE_ACTION_MODIFIED)
            if(Info->Action == FILE_ACTION_ADDED)
            {
                IMailMsgProperties *pIMsg = NULL;

                //convert the name to ascii
                FileNameLength = WideCharToMultiByte(CP_ACP, 0, &Info->FileName[0], Info->FileNameLength,
                                                    FileName, sizeof(FileName), NULL, NULL);
                FileName[FileNameLength/2] = '\0';
                DebugTrace((LPARAM) this, "File %s was detected", FileName);

                hr = CoCreateInstance(CLSID_MsgImp, NULL, CLSCTX_INPROC_SERVER,
                                                IID_IMailMsgProperties, (LPVOID *)&pIMsg);

                // Next, check if we are over the inbound cutoff limit. If so, we will release the message
                // and not proceed.
                if (SUCCEEDED(hr))
                {
                    DWORD    dwCreationFlags;
                    hr = pIMsg->GetDWORD(
                                IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                                &dwCreationFlags);
                    if (FAILED(hr) || 
                        (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                    {
                        // If we fail to get this property of if the inbound cutoff
                        // exceeded flag is set, discard the message and return failure
                        if (SUCCEEDED(hr))
                        {
                            DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                            hr = E_OUTOFMEMORY;
                        }
                        pIMsg->Release();
                        pIMsg = NULL;
                    }
                }

                if( (pIMsg == NULL) || FAILED(hr))
                {
                    // We are out of resources, there is absolutely nothing
                    // we can do: can't NDR, can't retry ...
                    // Just go on with the next mail ...
                    ErrorTrace((LPARAM) this, "new  MAILQ_ENTRY failed for file: %s",
                                FileName);

                    // will be mail left in pickup.  queue a findfirst to take care of it.
                    SetDelayedFindNotification(TRUE);
                    IncPendingIoCount ();
                    AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, TIMEOUT_INTERVAL);    //retry after a while
                    ErrorTrace((LPARAM)this, "Failed to create message will retry later.");
                    goto Exit;
                }
                else
                {
                    pIMsg->PutStringA(IMMPID_MP_PICKUP_FILE_NAME, FileName);
                    if(!ProcessFile(pIMsg))
                    {
                        // will be mail left in pickup.  queue a findfirst to take care of it.
                        SetDelayedFindNotification(TRUE);
                    }
                }
            }

            if(Info->NextEntryOffset == 0)
            {
                DebugTrace((LPARAM) this, "No more entries in this notification");
                break;
            }

            //get the next entry in the list to process
            Info = (PFILE_NOTIFY_INFORMATION)( (PCHAR)Info + Info->NextEntryOffset);
        }

        if (GetDelayedFindNotification())
        {
            DebugTrace((LPARAM) this, "Doing FindFirstFile because max mail objects was hit in notification");
            DoFindFirstFile();
        }

    }
    else
    {
        DebugTrace((LPARAM) this, "Doing FindFirstFile because InputBufferLen == 0");
        DoFindFirstFile();
    }

Exit:
    if(pBuffer)
    {
        delete pBuffer;
        pBuffer = NULL;
        QuerySmtpInstance()->DecCBufferObjs ();
    }


    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}


/*++

    Name :
        SMTP_DIRNOT::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                  Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_DIRNOT::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    PFILE_NOTIFY_INFORMATION Info = NULL;
    DWORD FileNameLength = 0;
    BOOL fRet;
    PSMTP_IIS_SERVICE        pService;


    TraceFunctEnterEx((LPARAM) this, "SMTP_DIRNOT::ProcessClient" );

    _ASSERT(m_pInstance != NULL);

    //
    // increment the number of threads processing this client
    //
    IncThreadCount();

    if(!QuerySmtpInstance()->IsShuttingDown())
    {

        //
        //    dhowell - if a gilbraltar thread, and size > 0 then it is a delivery thread we have created
        // the SMTP_CONNECTION code will ensure that only the correct number run.
        //

        if (lpo == &(QueryAtqContext()->Overlapped) || dwCompletionStatus == ERROR_SEM_TIMEOUT)
        {
            if(InputBufferLen == 0) 
            {
                DebugTrace( (LPARAM)this,"FindFirst called internally.");

                //reset timeout to infinity in anticipation of having memory; DoFindFirstFile
                //will set it to TIMEOUT_INTERVAL if it runs out of memory
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_TIMEOUT, INFINITE);

                DoFindFirstFile();

                //since this was a timeout completion, the atq context has been "disabled" from
                //further IO processing. Restart the timeout processing.
                AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_RESUME_IO, 1);
            }
        }
        //
        // A legit notification . 
        //
        else
        {
            DecDirChangeIoCount();
            DebugTrace( (LPARAM)this,"ReadDirectoryChange Notification");
            fRet = ProcessDirNotification(InputBufferLen, dwCompletionStatus, lpo);
        }
    }
    else
    {
        if (lpo != &(QueryAtqContext()->Overlapped))
        {
            //just cleanup up shop if we are shutting down.
            CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;
            delete pBuffer;
            pBuffer = NULL;
            QuerySmtpInstance()->DecCBufferObjs ();
            DecDirChangeIoCount();
        }

        //
        // only applies to shutdown case
        // these will not be decremented via SMTP_CONNECTION::ProcessMailQIO so we have to do it here.
        //
        if ((lpo == &(QueryAtqContext()->Overlapped)) && InputBufferLen)
        {
            pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

            QuerySmtpInstance()->DecRoutingThreads();
            pService->DecSystemRoutingThreads();
        }
    }

    //
    // decrement the number of threads processing this client
    //
    DecThreadCount();

    if ( DecPendingIoCount() == 0 )
    {
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() shutting down - Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() shutting down - ActiveThreads: %d",m_cActiveThreads);
        _ASSERT( m_cActiveThreads == 0 );
        fRet = FALSE;
    }
    else
    {
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() - Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_DIRNOT::ProcessClient() - ActiveThreads: %d",m_cActiveThreads);
        fRet = TRUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++
    Name :
        ReadDirectoryCompletion

    Description:

        Handles a completed I/O for ReadDirectoryChanges

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID SMTP_DIRNOT::ReadDirectoryCompletion(PVOID pvContext, DWORD cbWritten, 
                        DWORD dwCompletionStatus, OVERLAPPED * lpo)
{
    BOOL WasProcessed;
    SMTP_DIRNOT *pCC = (SMTP_DIRNOT *) pvContext;

    TraceFunctEnterEx((LPARAM) pCC, "SMTP_DIRNOT::ReadDirectoryCompletion");

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    if (dwCompletionStatus != NO_ERROR && dwCompletionStatus != ERROR_SEM_TIMEOUT)
        ErrorTrace((LPARAM)pCC, "Error in Atq operation: %d\r\n", dwCompletionStatus);

    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
    if(!WasProcessed)
    {
        SetEvent(pCC->QuerySmtpInstance()->GetDirnotStopHandle());
    }

    TraceFunctLeaveEx((LPARAM) pCC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\findiis.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceId
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceId(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	PSMTP_SERVER_INSTANCE pSmtpInstance = (PSMTP_SERVER_INSTANCE)pInstance ;
	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext) ;
	PSMTP_SERVER_INSTANCE* ppSmtpInstance = (PSMTP_SERVER_INSTANCE*)pvContext1 ;

	//
	//	Check this instance for its id - if it matches the id we are looking for
	//	return FALSE to discontinue the iteration.
	//
	if( dwInstanceId == pSmtpInstance->QueryInstanceId() )
	{
		// found it
		if(!pSmtpInstance->IsShuttingDown())
		{
			//reference it first
			pSmtpInstance->Reference();

			*ppSmtpInstance = pSmtpInstance ;
			return FALSE ;
		}
		else
		{
			//lie and say we did not find the instance
			//if we are shutting down
			*ppSmtpInstance = NULL;
			return FALSE;
		}
	}

	// did not find it - continue iteration
	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   FindIISInstance
//
//  Synopsis:  Returns an instance pointer for the given ID
//
//  Arguments:  pointer to an SMTP server calss and instance ID
//
//  Returns: pointer to an SMTP instance class
//
//  History:
//
//----------------------------------------------------------------
PSMTP_SERVER_INSTANCE
FindIISInstance(
    PSMTP_IIS_SERVICE pService,
	DWORD	dwInstanceId
    )

{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	PSMTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter("FindIISInstance");

	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceId;
	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)dwInstanceId,
									(PVOID)&pInstance,
									pfnInstanceEnum
									) ) {

		ErrorTrace(0,"Error enumerating instances");
	}

	//if we found an instance, but it's not running, or the service is
	//not running, then dereference the instance and leave
	if(pInstance && ( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)
		|| (pService->QueryCurrentServiceState() != SERVICE_RUNNING)))


	{
			pInstance->Dereference();
			pInstance = NULL;
	}

	TraceFunctLeave();

	return pInstance ;
}


BOOL CountInstances(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{

	if(pInstance)
	{
		(*(DWORD*)pvContext)++;
	}

	return TRUE;
}

BOOL GetInstancePerfData(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{

	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext) ;
	PSMTP_STATISTICS_BLOCK			pStatsBlock;
	PSMTP_INSTANCE_LIST_ENTRY	pInstanceInfo = NULL;

	pStatsBlock =  *(PSMTP_STATISTICS_BLOCK *) pvContext1;

	if(pInstance->QueryInstanceId() <= (DWORD)((DWORD_PTR)pvContext))
	{
		pStatsBlock->dwInstance = pInstance->QueryInstanceId();

		pInstanceInfo = ((SMTP_SERVER_INSTANCE *)pInstance)->GetSmtpInstanceInfo();

		if(pInstanceInfo)
		{
			pInstanceInfo->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		}
		//((SMTP_SERVER_INSTANCE *)pInstance)->GetSmtpInstanceInfo()->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		(*(PSMTP_STATISTICS_BLOCK *) pvContext1)++;
		return TRUE;
	}

	return FALSE;

}

PSMTP_STATISTICS_BLOCK_ARRAY GetServerPerfCounters(PSMTP_IIS_SERVICE pService)
{
	DWORD							NumInstances = 0;
	DWORD							dwAlloc = 0;
	PSMTP_INSTANCE_LIST_ENTRY		pSmtpInfo = NULL;
	PSMTP_STATISTICS_BLOCK_ARRAY	pSmtpStatsBlockArray = NULL;
	PSMTP_STATISTICS_BLOCK			pStatsBlock = NULL;

	TraceFunctEnter("GetServerPerfCounters");

	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;

	//Get the count of the number of instances first
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CountInstances;

	if( !pService->EnumServiceInstances(
									(PVOID)&NumInstances,
									(PVOID)NULL,
									pfnInstanceEnum
									) )
	{

		ErrorTrace(0,"Error counting instances");
	}

	if (NumInstances == 0)
	{
		TraceFunctLeave();
		return NULL;
	}

	//allocate memory to return to caller
	dwAlloc = sizeof(SMTP_STATISTICS_BLOCK_ARRAY) + NumInstances * sizeof(SMTP_STATISTICS_BLOCK);
	pSmtpStatsBlockArray = (PSMTP_STATISTICS_BLOCK_ARRAY)MIDL_user_allocate(dwAlloc);
	if (!pSmtpStatsBlockArray)
	{
		TraceFunctLeave();
		return NULL;
	}

	ZeroMemory(pSmtpStatsBlockArray, dwAlloc);

	//fill in memory structure
	pSmtpStatsBlockArray->cEntries = NumInstances;
	pStatsBlock = pSmtpStatsBlockArray->aStatsBlock;
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&GetInstancePerfData;

	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)NumInstances,
									(PVOID)&pStatsBlock,
									pfnInstanceEnum
									) )
	{

		ErrorTrace(0,"Error counting instances");
	}


	TraceFunctLeave();
	return pSmtpStatsBlockArray;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\dropdir.cxx ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "dropdir.hxx"

DWORD   g_dwDropFileCounter = 0;
CPool  CDropDir::m_Pool(DROPDIR_SIG);

//////////////////////////////////////////////////////////////////////////////
VOID
DropDirWriteCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    )
{
    DECL_TRACE((LPARAM) 0xC0DEC0DE, "DropDirWriteCompletion");
    BOOL WasProcessed = TRUE;
    CDropDir *pCC = (CDropDir *) pvContext;

    _ASSERT(pCC);

    pCC->SetHr( pCC->OnIoWriteCompletion(cbWritten, dwCompletionStatus, lpo) );

    SAFE_RELEASE( pCC );
}

//////////////////////////////////////////////////////////////////////////////
VOID
DropDirReadCompletion(
    PFIO_CONTEXT   pContext,
    PFH_OVERLAPPED lpo,
    DWORD          cbRead,
    DWORD          dwCompletionStatus
    )
{
    DECL_TRACE((LPARAM) 0xC0DEC0DE, "DropDirReadCompletion");
    BOOL WasProcessed = TRUE;
    DROPDIR_READ_OVERLAPPED *p = (DROPDIR_READ_OVERLAPPED *) lpo;
    CDropDir *pCC = (CDropDir*) p->ThisPtr;

    _ASSERT(pCC);

    pCC->SetHr( pCC->OnIoReadCompletion(cbRead, dwCompletionStatus, (LPOVERLAPPED)lpo) );

    SAFE_RELEASE( pCC );
}

//////////////////////////////////////////////////////////////////////////////
CDropDir::CDropDir()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CDropDir");

    m_dwSig = DROPDIR_SIG;
    m_cRef = 1;
    m_NumRcpts = 0;
    m_hDrop   = INVALID_HANDLE_VALUE;
    m_hMail   = NULL;
    m_AdvContext = NULL;
    m_rgRcptIndexList = NULL;
    m_pIMsg = NULL;
    m_pBindInterface = NULL;
    m_pAtqContext = NULL;
    CopyMemory( m_acCrLfDotCrLf, "\r\n.\r\n", 5 );
    ZeroMemory( m_acLastBytes, 5 );
    m_pIMsgRecips = NULL;
    m_hr = S_OK;
    m_cbWriteOffset = 0;
    m_cbReadOffset = 0;
    m_cbMsgWritten = 0;
    m_idxRecips = 0;
    ZeroMemory( &m_WriteOverlapped, sizeof( m_WriteOverlapped ) );
    ZeroMemory( &m_ReadOverlapped, sizeof( m_ReadOverlapped ) );
    m_szDropDir[0] = '\0';
    m_pISMTPConnection = NULL;
    m_ReadState = DROPDIR_READ_NULL;
    m_WriteState = DROPDIR_WRITE_NULL;
    m_pParentInst = NULL;
}

//////////////////////////////////////////////////////////////////////////////

CDropDir::~CDropDir()
{
    DECL_TRACE((LPARAM) this, "CDropDir::~CDropDir");

    SAFE_RELEASE( m_pIMsgRecips );

    if(m_pBindInterface)
    {
        m_pBindInterface->ReleaseContext();
        SAFE_RELEASE(m_pBindInterface);
    }

    m_MsgAck.pIMailMsgProperties = m_pIMsg;
    m_MsgAck.pvMsgContext = (DWORD *) m_AdvContext;

    if(SUCCEEDED(m_hr))
    {
        m_MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
    }
    else
    {
        m_MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;
    }

    m_MsgAck.dwStatusCode = 0;
    m_pISMTPConnection->AckMessage(&m_MsgAck);
    SAFE_RELEASE(m_pIMsg);

    if(SUCCEEDED(m_hr))
    {
        BUMP_COUNTER( m_pParentInst, DirectoryDrops);
    }

    if(SUCCEEDED(m_hr))
    {
        m_pISMTPConnection->AckConnection(CONNECTION_STATUS_OK);
    }
    else
    {
        SetLastError( 0x0000FFFF & m_hr );
        m_pISMTPConnection->AckConnection(CONNECTION_STATUS_FAILED);
    }

    PATQ_CONTEXT pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       if(m_hDrop != INVALID_HANDLE_VALUE)
           AtqCloseFileHandle( pAtqContext );
       AtqFreeContext( pAtqContext, TRUE );
    }

    // If we failed to completely write the message, delete the drop file
    if (FAILED(m_hr))
    {
        DeleteFile(m_szDropFile);
    }

    //
    // Now get the next message on this connection and
    // copy it to drop directory.
    //

    if (m_szDropDir[0])
        AsyncCopyMailToDropDir( m_pISMTPConnection, m_szDropDir, m_pParentInst );

    SAFE_RELEASE( m_pISMTPConnection );

    m_dwSig = DROPDIR_SIG_FREE;
}


//---[ CDropDir::CopyMailToDropDir ]-------------------------------------------
//
//
//  Description:
//
//      Entry point to the Async writing to the mail file. When this is called
//      it sets up a series of alternating reads and writes (read from the queue
//      and write to the mail file). The (rough description of the) algorithm is
//      as follows:
//
//          WriteHeaders()
//          Post Async Read from MailFile
//          return
//
//          Read Completion function()
//          Post Async Write of Data to DropDir
//          return
//
//          Write Completion function()
//          Post Async Read from MailFile
//          return
//
//      Called by
//          AsyncCopyMailToDropDir()
//
//  Parameters:
//
//  Returns:
//
//  History:
//      Created by PGOPI
//      3/25/99 - MikeSwa modified for checkin
//
//-----------------------------------------------------------------------------
HRESULT CDropDir::CopyMailToDropDir(
    ISMTPConnection      *pISMTPConnection,
    const char           *DropDirectory,
    IMailMsgProperties   *pIMsg,
    PVOID                 AdvContext,
    DWORD                 NumRcpts,
    DWORD                *rgRcptIndexList,
    SMTP_SERVER_INSTANCE *pParentInst)
{
    DECL_TRACE((LPARAM) this, "CDropDir::CopyMailToDropDir");
    HRESULT hr = S_OK;

    m_pISMTPConnection = pISMTPConnection;
    SAFE_ADDREF( m_pISMTPConnection );
    m_pIMsg = pIMsg;
    SAFE_ADDREF( m_pIMsg );
    m_pParentInst = pParentInst;
    m_AdvContext = AdvContext;
    m_NumRcpts = NumRcpts;
    m_rgRcptIndexList = rgRcptIndexList;

    if (!DropDirectory)
    {
        hr = E_INVALIDARG;
        goto error_exit;
    }

    //Copy drop directory now... so we have a copy in the destructor
    //even if this message cannot be dropped
    lstrcpy(m_szDropDir, DropDirectory);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);

    if(FAILED(hr))
    {
        ErrorTrace( (LPARAM)this, "m_pIMsg->QueryInterface for IID_IMailMsgBind return hr = 0x%x", hr );
        goto error_exit;
    }

    hr = m_pBindInterface->GetBinding(&m_hMail, NULL);

    if(FAILED(hr))
    {
        ErrorTrace( (LPARAM)this, "GetBinding return hr = 0x%x", hr );
        goto error_exit;
    }

    hr = m_pIMsg->QueryInterface( IID_IMailMsgRecipients, (PVOID *) &m_pIMsgRecips);

    if( FAILED( hr ) )
    {
        ErrorTrace( (LPARAM)this, "QueryInterface for IID_IMailMsgRecipients failed hr = 0x%x", hr );
        goto error_exit;
    }

    if( CheckIfAllRcptsHandled() )
    {
        goto exit;
    }


    DebugTrace((LPARAM)this, "Dropping file to: %s", DropDirectory);

    m_hDrop = CreateDropFile(DropDirectory);

    if (m_hDrop == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        ErrorTrace( (LPARAM)this, "Unable to create drop directory (%s) : 0x%x", DropDirectory, hr);
        goto error_exit;
    }

    if (!AtqAddAsyncHandle( &m_pAtqContext,
                            NULL,
                            (LPVOID) this,
                            DropDirWriteCompletion,
                            INFINITE,
                            m_hDrop))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        ErrorTrace((LPARAM)this, "Error 0x%x while adding async handle to ATQ", hr);
        goto error_exit;
    }

    // Output the x-headers

    if (FAILED( hr = CreateXHeaders() ) )
    {
        ErrorTrace( (LPARAM)this, " Error while creating x-headers hr = 0x%x", hr);
        goto error_exit;
    }

exit:
    return( hr );

error_exit:
    // If we failed here we must make sure we bubble up the failure so
    // it will be seen in the destructor - if we succeeded it is dangerous
    // to set this since we could overwrite a failure code written in the
    // async path resulting from CreateXHeaders (so we don't do that!)
    SetHr(hr);
    goto exit;

}

//////////////////////////////////////////////////////////////////////////////
HANDLE CDropDir::CreateDropFile(const char * DropDir)
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    DWORD           dwStrLen;
    FILETIME        ftTime;
    DWORD           Error = 0;

    DECL_TRACE((LPARAM)this, "CDropDir::CreateDropFile");

    dwStrLen = lstrlen(DropDir);
    lstrcpy(m_szDropFile, DropDir);

    do
    {
        GetSystemTimeAsFileTime(&ftTime);
        wsprintf(&m_szDropFile[dwStrLen],
                "%08x%08x%08x%s",
                ftTime.dwLowDateTime,
                ftTime.dwHighDateTime,
                InterlockedIncrement((PLONG)&g_dwDropFileCounter),
                ".eml");

        FileHandle = CreateFile(m_szDropFile,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED,
                                NULL);
        if (FileHandle != INVALID_HANDLE_VALUE)
                break;

        if((Error = GetLastError()) !=  ERROR_FILE_EXISTS)
        {
                FileHandle = INVALID_HANDLE_VALUE;
                ErrorTrace( (LPARAM)this, "CreateFile returns err = %u", Error );
                break;
        }

    } while( (FileHandle == INVALID_HANDLE_VALUE) && !m_pParentInst->IsShuttingDown());

    return (FileHandle);
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize
            )
{
    DECL_TRACE((LPARAM) this, "CDropDir::ReadFile");
    HRESULT hr = S_OK;

    _ASSERT(pBuffer != NULL);

    m_ReadOverlapped.Overlapped.Offset = LODWORD( m_cbReadOffset );
    m_ReadOverlapped.Overlapped.OffsetHigh = HIDWORD( m_cbReadOffset );
    m_ReadOverlapped.Overlapped.pfnCompletion = DropDirReadCompletion;
    m_ReadOverlapped.ThisPtr = (PVOID)this;

    AddRef();

    BOOL fRet = FIOReadFile( m_hMail,
                             pBuffer,            // Buffer
                             cbSize,             // BytesToRead
                             (PFH_OVERLAPPED)&m_ReadOverlapped) ;

    if(!fRet)
    {
        DWORD err = GetLastError();
        if( err != ERROR_IO_PENDING )
        {
            hr = HRESULT_FROM_WIN32( err );

            ErrorTrace( (LPARAM)this, "FIOReadFile return hr = 0x%x", hr );
        }

    }

    if( FAILED( hr ) )
    {
        Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize
            )
{
    DECL_TRACE((LPARAM) this, "CDropDir::WriteFile");
    CDropDir *p = this;
    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);
    HRESULT hr = S_OK;

    m_WriteOverlapped.Offset = LODWORD( m_cbWriteOffset );
    m_WriteOverlapped.OffsetHigh = HIDWORD( m_cbWriteOffset );

    AddRef();

    BOOL fRet = AtqWriteFile( m_pAtqContext,      // Atq context
                              pBuffer,            // Buffer
                              cbSize,             // BytesToRead
                              (OVERLAPPED *) &m_WriteOverlapped) ;

    if(!fRet)
    {
        DWORD err = GetLastError();
        if( err != ERROR_IO_PENDING )
        {
            hr = HRESULT_FROM_WIN32( err );

            ErrorTrace( (LPARAM)this, "AtqWriteFile return hr = 0x%x", hr );
        }

    }

    if( FAILED( hr ) )
    {
        Release();
    }
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnIoWriteCompletion( DWORD cbSize, DWORD dwErr, OVERLAPPED *lpo )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnIoWriteCompletion");

    HRESULT hr = S_OK;

    if( dwErr != NO_ERROR )
    {
        ErrorTrace( (LPARAM)this, "OnIoWriteCompletion got err = %u", dwErr );
        return( HRESULT_FROM_WIN32( dwErr ) );
    }

    m_cbWriteOffset += cbSize;

    switch( m_ReadState )
    {
        case DROPDIR_READ_X_SENDER:
            _ASSERT(!"Invalid State READ_X_SENDER");
            hr = E_INVALIDARG;
            break;
        case DROPDIR_READ_X_RECEIVER:
            hr = CreateXRecvHeaders();
            break;
        case DROPDIR_READ_DATA:
            hr = OnCopyMessageWrite( cbSize);
            break;
        default:
            _ASSERT(!"INVALID read STATE");
            hr = E_INVALIDARG;
            ErrorTrace( (LPARAM)this, "Invalid ReadState" );
            break;
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnIoReadCompletion( DWORD cbSize, DWORD dwErr, OVERLAPPED *lpo )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnIoReadCompletion");
    HRESULT hr = S_OK;

    if( ( dwErr != NO_ERROR ) && ( dwErr != ERROR_HANDLE_EOF ) )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        ErrorTrace( (LPARAM)this, "OnIOReadCompletion got hr = 0x%x", hr );
    }
    else
    {
        m_cbReadOffset += cbSize;
        hr = OnCopyMessageRead( cbSize, dwErr );
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CreateXHeaders()
{

    DECL_TRACE(((LPARAM) this), "CDropDir::CreateXHeaders");
    HRESULT hr = S_OK;

    DebugTrace( (LPARAM)this, "Setting m_ReadState = DROPDIR_READ_X_SENDER" );

    m_ReadState = DROPDIR_READ_X_SENDER;

    strcpy( m_szBuffer, X_SENDER_HEADER );

    hr = m_pIMsg->GetStringA( IMMPID_MP_SENDER_ADDRESS_SMTP, MAX_INTERNET_NAME, &m_szBuffer[ sizeof(X_SENDER_HEADER) - 1] );

    if(SUCCEEDED(hr))
    {
        strcat( m_szBuffer, X_HEADER_EOLN);

        //
        // this WriteFile will complete async, so set the next read state.
        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.

        m_ReadState = DROPDIR_READ_X_RECEIVER;

        DebugTrace( (LPARAM)this, "Setting m_ReadState = DROPDIR_READ_X_RECEIVER" );
        //

        if( FAILED( hr = WriteFile( m_szBuffer, strlen( m_szBuffer ) ) ) )
        {
            ErrorTrace((LPARAM)this, "Error %d writing x-sender line %s", hr, m_szBuffer);

            return( hr );
        }
    }
    else
    {


        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        ErrorTrace((LPARAM)this, "Could not get Sender Address returning hr = 0x%x", hr);

        return( hr );
    }

    return( hr );


}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CreateXRecvHeaders()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CreateXRecvHeaders");
    HRESULT hr = S_OK;
    DWORD dwRecipientFlags = 0;
    BOOL fPendingWrite = FALSE;

    strcpy( m_szBuffer, X_RECEIVER_HEADER );

    while( m_idxRecips < m_NumRcpts )
    {
        hr = m_pIMsgRecips->GetDWORD( m_rgRcptIndexList[m_idxRecips], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);

        if( SUCCEEDED( hr ) )
        {
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                hr = m_pIMsgRecips->GetStringA( m_rgRcptIndexList[m_idxRecips],
                                                IMMPID_RP_ADDRESS_SMTP,
                                                MAX_INTERNET_NAME,
                                                &m_szBuffer[ sizeof(X_RECEIVER_HEADER) - 1 ]);
                if (SUCCEEDED(hr))
                {
                    strcat(m_szBuffer, X_HEADER_EOLN);



                    // Make Sure that no class member variables are acessed after calling
                    // WriteFile or ReadFile as they complete async & there is no critical
                    // section protecting access.To do this trace through all paths
                    // thru which ReadFile and WriteFile are called and make sure no member
                    // variables are accessed.

                    m_idxRecips++;

                    if(FAILED( hr = WriteFile(m_szBuffer, strlen(m_szBuffer) ) ) )

                    {
                        ErrorTrace( (LPARAM)this, "WriteFile return hr = 0x%x", hr );
                        return( hr );
                    }
                    fPendingWrite = TRUE;
                    break;
                }
                else
                {
                    ErrorTrace( (LPARAM)this, "GetStringA for IMMPID_RP_ADDRESS_SMTP returns hr = 0x%x", hr );
                    return( hr );
                }
            }
            else
            {
                m_idxRecips++;
            }
        }
        else
        {
            ErrorTrace( (LPARAM)this, "GetDWORD for IMMPID_RP_RECIPIENT_FLAGS returns hr = 0x%x", hr );
            return( hr );
        }
    }

    if( !fPendingWrite )
    {
        m_ReadState = DROPDIR_READ_DATA;
        m_WriteState = DROPDIR_WRITE_DATA;
        DebugTrace( (LPARAM)this, "Setting m_WriteState & m_ReadState to WRITE_DATA & READ_DATA respectively" );
        return( CopyMessage() );
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::CopyMessage()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CopyMessage");

    // Make Sure that no class member variables are acessed after calling
    // WriteFile or ReadFile as they complete async & there is no critical
    // section protecting access.To do this trace through all paths
    // thru which ReadFile and WriteFile are called and make sure no member
    // variables are accessed.

    HRESULT hr = ReadFile( m_szBuffer, sizeof( m_szBuffer ) );

    if( hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ) )
    {
        m_WriteState = DROPDIR_WRITE_CRLF;

        DebugTrace( (LPARAM)this, "ReadFile returns err = ERROR_HANDLE_EOF, Setting m_WriteState = DROPDIR_WRITE_CRLF" );

        return( DoLastFileOp() );
    }

    return( hr );


}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnCopyMessageRead( DWORD dwBytesRead, DWORD dwErr )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnCopyMessageRead");
    HRESULT hr = S_OK;

    if (dwBytesRead )
    {
        if (dwBytesRead > 4)
        {
            CopyMemory(m_acLastBytes, &m_szBuffer[dwBytesRead-5], 5);
        }
        else
        {
            MoveMemory(m_acLastBytes, &m_acLastBytes[dwBytesRead], 5-dwBytesRead);
            CopyMemory(&m_acLastBytes[5-dwBytesRead], m_szBuffer, dwBytesRead);
        }

        //
        // the write file will complete async & then we'll do the
        // last fileop.
        //

        if( dwErr == ERROR_HANDLE_EOF )
        {
            DebugTrace( (LPARAM)this, " Interesting case err = ERROR_HANDLE_EOF, Setting m_WriteState = DROPDIR_WRITE_CRLF" );

            m_WriteState = DROPDIR_WRITE_CRLF;
        }

        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.

        if ( FAILED( hr = WriteFile(m_szBuffer, dwBytesRead ) ) )
        {
            ErrorTrace( (LPARAM)this, "WriteFile return hr = 0x%x", hr );
            return( hr );
        }

    }
    else
    {
        m_WriteState = DROPDIR_WRITE_CRLF;

        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_CRLF" );

        return( DoLastFileOp() );

    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::OnCopyMessageWrite( DWORD cbWritten )
{
    DECL_TRACE((LPARAM) this, "CDropDir::OnCopyMessageWrite");
    HRESULT hr = S_OK;

    m_cbMsgWritten += cbWritten;

    switch( m_WriteState )
    {
        case DROPDIR_WRITE_DATA:
            return( CopyMessage() );
            break;
        case DROPDIR_WRITE_CRLF:
            return( DoLastFileOp() );
            break;
        case DROPDIR_WRITE_SETPOS:
            return( AdjustFilePos() );
            break;
        default:
            _ASSERT(!"Invalid WriteState");
            ErrorTrace( (LPARAM)this, "Invalid WriteState" );
            hr = E_INVALIDARG;
            break;
    }

    return( hr );

}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::DoLastFileOp()
{
    DECL_TRACE((LPARAM) this, "CDropDir::DoLastFileOp");
    HRESULT hr = S_OK;
    DebugTrace( (LPARAM)this, "DoLastFileOp called" );

    // Now, see if the file ends with a CRLF, if not, add it
    if ((m_cbMsgWritten > 1) && memcmp(&m_acLastBytes[3], &m_acCrLfDotCrLf[3], 2))
    {
        //
        // the write will complete async. set next write state
        //

        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_SETPOS" );

        m_WriteState = DROPDIR_WRITE_SETPOS;

        // Make Sure that no class member variables are acessed after calling
        // WriteFile or ReadFile as they complete async & there is no critical
        // section protecting access.To do this trace through all paths
        // thru which ReadFile and WriteFile are called and make sure no member
        // variables are accessed.

        // Add the trailing CRLF
        if(FAILED( hr = WriteFile(m_acCrLfDotCrLf, 2 ) ) )
        {
            ErrorTrace( (LPARAM)this, "WriteFile returns hr = 0x%x", hr );
            return(hr);
        }

    }
    else
    {
        DebugTrace( (LPARAM)this, "Setting m_WriteState = DROPDIR_WRITE_SETPOS" );

        m_WriteState = DROPDIR_WRITE_SETPOS;

        return( AdjustFilePos() );
    }


    return( hr );
}

///////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::AdjustFilePos()
{
    DECL_TRACE((LPARAM) this, "CDropDir::AdjustFilePos");
    HRESULT hr = S_OK;

    DebugTrace( (LPARAM)this, "AdjustFilePos called" );

    //If file ends with CRLF.CRLF, remove the trailing .CRLF
    //Do not modify the file otherwise

    DWORD dwLo = LODWORD( m_cbWriteOffset );
    DWORD dwHi = HIDWORD( m_cbWriteOffset );

    if ((m_cbMsgWritten > 4) && !memcmp(m_acLastBytes, m_acCrLfDotCrLf, 5))
    {
        DebugTrace( (LPARAM)this, "Removing the trailing CRLF-DOT-CRLF" );

        // Remove the trailing .CRLF
        if ((SetFilePointer(m_hDrop, dwLo-3, (LONG*)&dwHi, FILE_BEGIN) == 0xffffffff) ||
            !SetEndOfFile(m_hDrop))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            ErrorTrace( (LPARAM)this, "SetFilePointer or SetEndofFile return hr = 0x%x", hr );
            return( hr );
        }
    }

    //We need to flush the context before ACK'ing the message
    if (!FlushFileBuffers(m_hDrop))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        ErrorTrace( (LPARAM)this, "FlushFileBuffers failed with hr = 0x%x", hr );
        return( hr );
    }

    hr = SetAllRcptsHandled();
    if( FAILED( hr ) )
    {
        ErrorTrace( (LPARAM)this, "SetAllRcptsHandledreturn hr = 0x%x", hr );
        return( hr );
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CDropDir::CheckIfAllRcptsHandled()
{
    DECL_TRACE((LPARAM) this, "CDropDir::CheckIfAllRcptsHandled");
    BOOL fRet = TRUE;

    for( DWORD i = 0; i < m_NumRcpts; i++ )
    {
        if ( m_rgRcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            HRESULT hr = m_pIMsgRecips->GetDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                fRet = FALSE;
                break;
            }

            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                fRet = FALSE;
                break;
            }

        }
    }

    return( fRet );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CDropDir::SetAllRcptsHandled()
{
    DECL_TRACE((LPARAM) this, "CDropDir::SetAllRcptsHandled");
    HRESULT hr = S_OK;

    for( DWORD i = 0; i < m_NumRcpts; i++ )
    {
        if (m_rgRcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            hr = m_pIMsgRecips->GetDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                break;
            }

            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                dwRecipientFlags |= RP_DELIVERED;


                hr = m_pIMsgRecips->PutDWORD(m_rgRcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr))
                {
                    break;
                }
            }

        }
    }
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _SMTPDATA_
#define _SMTPDATA_

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

#define DOMAIN_ROUTE_HT_SIGNATURE_VALID     'DRHV'
#define DOMAIN_ROUTE_HT_SIGNATURE_FREE      'DRHF'

#define LOCAL_DOMAIN_HT_SIGNATURE_VALID     'LDHV'
#define LOCAL_DOMAIN_HT SIGNATURE_FREE      'LDHF'

#define DEDICATED_CLIENT_REQUEST_THREADS    3
#define SYSTEM_ROUTING_THREADS_PER_PROC     12
#define CHECK_QUEUE_COUNT                   50
#define ADD_THREAD_BACKLOG                  100

#define SMTP_BASE_PRODUCT   (0)

#define SMTP_UNRECOG_COMMAND_CODE   500
#define SMTP_SYNTAX_ERROR_CODE      501
#define SMTP_NOT_IMPLEMENTED_CODE   502
#define SMTP_BAD_SEQUENCE_CODE      503
#define SMTP_PARAM_NOT_IMPLEMENTED_CODE 504

#define SMTP_SYS_STATUS_CODE        211
#define SMTP_SERVICE_CLOSE_CODE     221
#define SMTP_SERVICE_READY_CODE     220
#define SMTP_OK_CODE                250
#define SMTP_USER_NOT_LOCAL_CODE    251
#define SMTP_MBOX_BUSY_CODE         450
#define SMTP_MBOX_NOTFOUND_CODE     550
#define SMTP_ERROR_PROCESSING_CODE  451
#define SMTP_USERNOTLOCAL_CODE      551
#define SMTP_INSUFF_STORAGE_CODE    452
#define SMTP_ACTION_ABORTED_CODE    552
#define SMTP_ACTION_NOT_TAKEN_CODE  553
#define SMTP_START_MAIL_CODE        354
#define SMTP_TRANSACT_FAILED_CODE   554

#define SMTP_SERVICE_UNAVAILABLE_CODE 421
#define SMTP_COMPLETE_FAILURE_DWORD 5

enum RCPTYPE{LOCAL_NAME, REMOTE_NAME, ALIAS_NAME};

#define NORMAL_RCPT (char)'R'
#define ERROR_RCPT  (char)'E'
//
// use the current command for transaction logging
//
#define USE_CURRENT         0xFFFFFFFF

static const char * LOCAL_TRANSCRIPT    = "ltr";
static const char * REMOTE_TRANSCRIPT   = "rtr";
static const char * ALIAS_EXT           = "dl";

#define ISNULLADDRESS(Address) ((Address[0] == '<') && (Address[1] == '>'))

typedef char RCPT_TYPE;

extern SMTP_STATISTICS_0 g_pSmtpStat;
extern LPSMTP_SERVER_STATISTICS  g_pSmtpStats;
extern TIME_ZONE_INFORMATION   tzInfo;

extern CHAR  g_ComputerName[];
extern CHAR  g_VersionString[];
extern DWORD g_ComputerNameLength;
extern DWORD g_LoopBackAddr;
extern DWORD g_ProductType;
extern DWORD g_NumProcessors;
extern DWORD g_PickupWait;
extern LONG g_MaxFindThreads;
extern PLATFORM_TYPE g_SmtpPlatformType;
extern CEventLogWrapper g_EventLog;

extern "C"
{
extern BOOL g_IsShuttingDown;
}

#define INITIALIZE_INBOUNDPOOL  0x00000001
#define INITIALIZE_OUTBOUNDPOOL 0x00000002
#define INITIALIZE_ADDRESSPOOL  0x00000004
#define INITIALIZE_MAILOBJPOOL  0x00000008
#define INITIALIZE_CBUFFERPOOL  0x00000010
#define INITIALIZE_CIOBUFFPOOL  0x00000020
#define INITIALIZE_SSLCONTEXT   0x00000040
#define INITIALIZE_ETRNENTRYPOOL 0x00000080
#define INITIALIZE_CSECURITY    0x00000100
#define INITIALIZE_CPROPERTYBAGPOOL 0x00000200
#define INITIALIZE_CASYNCMX     0x00000400
#define INITIALIZE_CASYNCDNS    0x00000800
#define INITIALIZE_CBLOCKMGR    0x00001000
#define INITIALIZE_FILEHC       0x00002000
#define INITIALIZE_CDROPDIR     0x00004000

extern  DWORD g_SmtpInitializeStatus;

//Domain validation flags
#define SMTP_NOVALIDATE_EHLO    0x00000001
#define SMTP_NOVALIDATE_MAIL    0x00000002
#define SMTP_NOVALIDATE_RCPT    0x00000004
#define SMTP_NOVALIDATE_PKUP    0x00000008
#define SMTP_NOVALIDATE_ETRN    0x00000010


#define BUMP_COUNTER(InstObj, counter) \
                        InterlockedIncrement((LPLONG) &(InstObj->QueryStatsObj()->QueryStatsMember()->counter))

#define DROP_COUNTER(InstObj, counter) \
                        InterlockedDecrement((LPLONG) &(InstObj->QueryStatsObj()->QueryStatsMember()->counter))

#define ADD_COUNTER(InstObj, counter, value)    \
        INTERLOCKED_ADD_CHEAP(&(InstObj->QueryStatsObj()->QueryStatsMember()->counter), value)

#define ADD_BIGCOUNTER(InstObj, counter, value) \
        INTERLOCKED_BIGADD_CHEAP(&(InstObj->QueryStatsObj()->QueryStatsMember()->counter), value)

/***********************************************************
 *    Type Definitions
 ************************************************************/
const DWORD MAX_RESPONSE_LEN = 300;
const DWORD RESPONSE_BUFF_SIZE = MAX_RESPONSE_LEN + MAX_PATH;
const DWORD cMaxRoutingSources = 32;
const DWORD cbMaxRoutingSource = 512;
const DWORD smarthostNone = 0;
const DWORD smarthostAfterFail = 1;
const DWORD smarthostAlways = 2;
// Removed by KeithLau on 7/18/96
// const DWORD cMaxValidDomains = 32;

const DWORD MAX_MAIL_FROM_AUTH_LEN = 500;
const DWORD MAX_MAIL_FROM_ENVID_LEN = 100;
const DWORD MAX_RCPT_TO_ORCPT_LEN = 500;

#define SMTP_WRITE_BUFFER_SIZE ( 64 * 1024 ) //64K buffers

enum SMTP_MSG_FILE_TYPE {SYSTEM_MSG_FILE, LOCAL_MSG_FILE, ABOOK_MSG_FILE};

enum SMTPCMDSEX {
    #undef SmtpDef
    #define SmtpDef(a)  CMD_EX_##a,
    #include "smtpdef.h"
    CMD_EX_UNKNOWN
};

enum SMTPLOGS {
    #undef SmtpDef
    #define SmtpDef(a)  LOG_FLAG_##a = (1<<CMD_EX_##a),
    #include "smtpdef.h"
    LOG_FLAG_UNKNOWN = (1<<CMD_EX_UNKNOWN)
};

#define DEFAULT_CMD_LOG_FLAGS           LOG_FLAG_HELO | \
                                        LOG_FLAG_EHLO | \
                                        LOG_FLAG_MAIL | \
                                        LOG_FLAG_RCPT | \
                                        LOG_FLAG_DATA | \
                                        LOG_FLAG_QUIT | \
                    LOG_FLAG_ETRN | \
                    LOG_FLAG_VRFY | \
                    LOG_FLAG_STARTTLS |\
                    LOG_FLAG_AUTH |\
                    LOG_FLAG_TURN |\
                    LOG_FLAG_BDAT |\
                                        LOG_FLAG_UNKNOWN

/*++

        Returns a UniqueFilename for an e-mail message.
        The caller should loop through this call and a call to
        CreateFile with the CREATE_NEW flag. If the Create fails due
        to YYY, then the caller should loop again.

    Arguments:

        psz - a buffer
        pdw - IN the size of the buffer,
              OUT: the size of the buffer needed (error == ERROR_MORE_DATA)
                   or the size of the filename.

    Returns:

        TRUE on SUCCESS
        FALSE if buffer isn't big enough.

--*/
BOOL    GetUniqueFilename(
    IN OUT  LPTSTR  psz,
    IN OUT  LPDWORD pdw
    );

BOOL CreateLayerDirectory( char * str );

#define RESOLUTION_UNCACHEDDNS          0x00000001
#define RESOLUTION_GETHOSTBYNAME        0x00000002
#define RESOULTION_DNS_GETHOSTBYNAME    0x00000003


#endif // _SMTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\iissmtp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iissmtp.cxx

   Abstract:

        This module defines the SMTP_IIS_SERVICE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996
        Rohan Phillips      (Rohanp)        Feb-04-1997 - modified for smtp


--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <smtpinet.h>
#include "aqstore.hxx"


//
// External reference to SEO helpers
//
extern HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID);

BOOL
SMTP_IIS_SERVICE::AddInstanceInfo(
                     IN DWORD dwInstance,
                     IN BOOL fMigrateRoots
                     )
{
    HRESULT hr;
    PSMTP_SERVER_INSTANCE pInstance;
    MB      mb( (IMDCOM*) QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::AddInstanceInfo");

    //
    // Register the instance for server events
    //
    DebugTrace((LPARAM)this, "Registering SEO for instance %u", dwInstance);
    hr = RegisterPlatSEOInstance(dwInstance);
    if (FAILED(hr))
    {
        char szInst[10];

        ErrorTrace((LPARAM)this, "Instance %d: RegisterSEOInstance returned %08x",
                    dwInstance, hr);
        _itoa((int)dwInstance, szInst, 10);
        SmtpLogEventEx(SEO_REGISTER_INSTANCE_FAILED,
                        szInst,
                        hr);
    }

    //
    // Create the new instance
    //

    pInstance = new SMTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_SMTP,
                                QueryRegParamKey(),
                                SMTP_ANONYMOUS_SECRET_W,
                                SMTP_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if(pInstance == NULL)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if (m_fCreatingInstance)
    {
        //We just received the notification for the creation of the metabase
        //object for a VS... none of the config information is there.  We do 
        //not want to attempt starting, becuase we will log that we cannot 
        //find out config info in the event log!

        DebugTrace((LPARAM)this,"Instnace not started on metabase creation");
        SetLastError( ERROR_SERVICE_DISABLED );
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE ;
    }

    return AddInstanceInfoHelper( pInstance );

} // SMTP_IIS_SERVICE::AddInstanceInfo

DWORD
SMTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    ((SMTP_SERVER_INSTANCE *)pInstance)->DisconnectAllConnections();
    return NO_ERROR;

}   // SMTP_IIS_SERVICE::DisconnectUsersByInstance


DWORD
SMTP_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(SMTP_CONFIG_INFO);
    }

    return 0;

} // SMTP_IIS_SERVICE::GetServerConfigInfoSize


VOID
SMTP_IIS_SERVICE::StartHintFunction()
{

    if (QueryCurrentServiceState() == SERVICE_START_PENDING )
    {
        UpdateServiceStatus(SERVICE_START_PENDING, NO_ERROR, m_dwStartHint,SERVICE_START_WAIT_HINT);
        m_dwStartHint++;
    }
}


SMTP_IIS_SERVICE::SMTP_IIS_SERVICE(
        IN  LPCSTR                           pszServiceName,
        IN  LPCSTR                           pszModuleName,
        IN  LPCSTR                           pszRegParamKey,
        IN  DWORD                            dwServiceId,
        IN  ULONGLONG                        SvcLocId,
        IN  BOOL                             MultipleInstanceSupport,
        IN  DWORD                            cbAcceptExRecvBuffer,
        IN  ATQ_CONNECT_CALLBACK             pfnConnect,
        IN  ATQ_COMPLETION                   pfnConnectEx,
        IN  ATQ_COMPLETION                   pfnIoCompletion
        ) : IIS_SERVICE( pszServiceName,
                         pszModuleName,
                         pszRegParamKey,
                         dwServiceId,
                         SvcLocId,
                         MultipleInstanceSupport,
                         cbAcceptExRecvBuffer,
                         pfnConnect,
                         pfnConnectEx,
                         pfnIoCompletion
                         )
{

    MB          mb( (IMDCOM*) QueryMDObject() );
    DWORD       MaxPoolThreadValue = 0;


    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::SMTP_IIS_SERVICE");

    m_OldMaxPoolThreadValue = 0;
    m_cMaxSystemRoutingThreads = 0;
    m_cCurrentSystemRoutingThreads = 0;
    m_fHaveResetPrincipalNames = FALSE;

    //
    // configure the number of SMTP routing threads and IIS pool threads.
    //

    m_dwStartHint = 2;
    m_OldMaxPoolThreadValue = 0;

    MaxPoolThreadValue = (DWORD)AtqGetInfo(AtqMaxPoolThreads);

    if(MaxPoolThreadValue < 15)
        m_OldMaxPoolThreadValue = (DWORD)AtqSetInfo(AtqMaxPoolThreads, 15);

    m_fCreatingInstance = FALSE;

    InitializeListHead(&m_InstanceInfoList);
    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_IIS_SERVICE::SMTP_IIS_SERVICE

BOOL
SMTP_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{

    LPSMTP_STATISTICS_0   pStatDest = (LPSMTP_STATISTICS_0) pDestination;
    LPSMTP_STATISTICS_0   pStatSrc  = (LPSMTP_STATISTICS_0) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }

    pStatDest->BytesSentTotal       += pStatSrc->BytesSentTotal;
    pStatDest->BytesRcvdTotal       += pStatSrc->BytesRcvdTotal;

    pStatDest->BytesSentMsg         += pStatSrc->BytesSentMsg;
    pStatDest->BytesRcvdMsg         += pStatSrc->BytesRcvdMsg;
    pStatDest->NumMsgRecvd          += pStatSrc->NumMsgRecvd;
    pStatDest->NumRcptsRecvd        += pStatSrc->NumRcptsRecvd;
    pStatDest->NumRcptsRecvdLocal   += pStatSrc->NumRcptsRecvdLocal;
    pStatDest->NumRcptsRecvdRemote  += pStatSrc->NumRcptsRecvdRemote;
    pStatDest->MsgsRefusedDueToSize += pStatSrc->MsgsRefusedDueToSize;

    pStatDest->MsgsRefusedDueToNoCAddrObjects   += pStatSrc->MsgsRefusedDueToNoCAddrObjects;
    pStatDest->MsgsRefusedDueToNoMailObjects    += pStatSrc->MsgsRefusedDueToNoMailObjects;
    pStatDest->NumMsgsDelivered                 += pStatSrc->NumMsgsDelivered;
    pStatDest->NumDeliveryRetries               += pStatSrc->NumDeliveryRetries;
    pStatDest->NumMsgsForwarded                 += pStatSrc->NumMsgsForwarded;
    pStatDest->NumNDRGenerated                  += pStatSrc->NumNDRGenerated;
    pStatDest->LocalQueueLength                 += pStatSrc->LocalQueueLength;
    pStatDest->RetryQueueLength                 += pStatSrc->RetryQueueLength;
    pStatDest->NumMailFileHandles               += pStatSrc->NumMailFileHandles;
    pStatDest->NumQueueFileHandles              += pStatSrc->NumQueueFileHandles;
    pStatDest->CatQueueLength                   += pStatSrc->CatQueueLength;

    pStatDest->NumMsgsSent                += pStatSrc->NumMsgsSent;
    pStatDest->NumRcptsSent               += pStatSrc->NumRcptsSent;
    pStatDest->NumSendRetries             += pStatSrc->NumSendRetries;
    pStatDest->RemoteQueueLength          += pStatSrc->RemoteQueueLength;

    pStatDest->NumDnsQueries                += pStatSrc->NumDnsQueries;
    pStatDest->RemoteRetryQueueLength       += pStatSrc->RemoteRetryQueueLength;

    pStatDest->NumConnInOpen                += pStatSrc->NumConnInOpen;
    pStatDest->NumConnInClose               += pStatSrc->NumConnInClose;
    pStatDest->NumConnOutOpen               += pStatSrc->NumConnOutOpen;
    pStatDest->NumConnOutClose              += pStatSrc->NumConnOutClose;
    pStatDest->NumConnOutRefused            += pStatSrc->NumConnOutRefused;

    pStatDest->NumProtocolErrs              += pStatSrc->NumProtocolErrs;
    pStatDest->DirectoryDrops               += pStatSrc->DirectoryDrops;
    pStatDest->RoutingTableLookups          += pStatSrc->RoutingTableLookups;
    pStatDest->ETRNMessages                 += pStatSrc->ETRNMessages;
    pStatDest->TimeOfLastClear              += pStatSrc->TimeOfLastClear;

    pStatDest->MsgsBadmailNoRecipients      += pStatSrc->MsgsBadmailNoRecipients;
    pStatDest->MsgsBadmailHopCountExceeded  += pStatSrc->MsgsBadmailHopCountExceeded;
    pStatDest->MsgsBadmailFailureGeneral    += pStatSrc->MsgsBadmailFailureGeneral;
    pStatDest->MsgsBadmailBadPickupFile     += pStatSrc->MsgsBadmailBadPickupFile;
    pStatDest->MsgsBadmailEvent             += pStatSrc->MsgsBadmailEvent;
    pStatDest->MsgsBadmailNdrOfDsn          += pStatSrc->MsgsBadmailNdrOfDsn;
    pStatDest->MsgsPendingRouting           += pStatSrc->MsgsPendingRouting;
    pStatDest->MsgsPendingUnreachableLink   += pStatSrc->MsgsPendingUnreachableLink;
    pStatDest->SubmittedMessages            += pStatSrc->SubmittedMessages;
    pStatDest->DSNFailures                  += pStatSrc->DSNFailures;
    pStatDest->MsgsInLocalDelivery          += pStatSrc->MsgsInLocalDelivery;

    return TRUE;
}

SMTP_IIS_SERVICE::~SMTP_IIS_SERVICE()
{
    if(m_OldMaxPoolThreadValue != 0)
        AtqSetInfo(AtqMaxPoolThreads, m_OldMaxPoolThreadValue);
}


VOID
SMTP_IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fSslModified = FALSE;
    LPSTR   szIdString = NULL;
    BOOL    fSetCreatingInstance = FALSE;

    AcquireServiceLock();

    if (!m_fCreatingInstance)
    {
        //Check if this is a creation event.... if we are just creating the 
        //class key in smtpsvc/<instance>, then this is the notify we get 
        //when admin is creating an instance.  We should bail early so we 
        //do not attempt to create an instance and log bogus errors in 
        //the event log. If m_fCreatingInstance is set to TRUE... we will
        //not try to start the instance (by calling AddInstanceInfoHelper)

        //Parse the string and see if the last thing is the instance ID.. .we
        //expect it to be in the form of:
        //      /LM/{service_name}/{instance_id}/
        if (pcoChangeList->pszMDPath)
        {
            szIdString = (LPSTR)pcoChangeList->pszMDPath + 
                     sizeof(SMTP_MD_ROOT_PATH) - 2*sizeof(CHAR);
        }

        //We are now at the '/' before the instance id
        if (szIdString && (szIdString[0] == '/') && (szIdString[1] != '\0'))
        {
            //We have a possible winner... check for <n>/\0
            do {szIdString++;} while (*szIdString && isdigit((UCHAR)*szIdString));

            //If the last 2 characters are '/' and '\0'... we need to look further
            if ((szIdString[0] == '/') && (szIdString[1] == '\0'))
            {
                //Since all of this work is to avoid trying to start when
                //admin creates a new virtual server, we would be well advised
                //to only bail early in the exact case of admin adding a virtual
                //server instance.  They always create the key type first, so
                //we will check for it
                if ((MD_CHANGE_TYPE_ADD_OBJECT & pcoChangeList->dwMDChangeType) &&
                    (1 == pcoChangeList->dwMDNumDataIDs) &&
                    (MD_KEY_TYPE == pcoChangeList->pdwMDDataIDs[0]))
                {
                    //This is the notify that causes IIS to try and make us start
                    //before we have any config information.  If we call,
                    //IIS_SERVICE::MDChangeNotify it will turn around and start
                    //our instance.  .
                    m_fCreatingInstance = TRUE;
                
                    //This thread needs to unset it.  While the instance is created
                    //we will get other notifies (on this thread) when IIS sets 
                    //the service state.
                    fSetCreatingInstance = TRUE;
                }
            }
        }
    }
        

    IIS_SERVICE::MDChangeNotify( pcoChangeList );

    //The above call is were m_fCreatingInstance is used...reset it if we set it
    if (fSetCreatingInstance)
        m_fCreatingInstance = FALSE; 

    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case MD_SSL_PUBLIC_KEY:
        case MD_SSL_PRIVATE_KEY:
        case MD_SSL_KEY_PASSWORD:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    if ( !fSslModified && g_pSslKeysNotify )
    {
        if ( strlen( (LPSTR)pcoChangeList->pszMDPath ) >= sizeof("/LM/SMTPSVC/SSLKeys" )-1 &&
             !_memicmp( pcoChangeList->pszMDPath,
                        "/LM/SMTPSVC/SSLKeys",
                        sizeof("/LM/SMTPSVC/SSLKeys" )-1 ) )
        {
            fSslModified = TRUE;
        }
    }

    if ( fSslModified && g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
    }

    ReleaseServiceLock();
}

/*++

    Name:

        APIERR SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()

    Description:

        This method reads from the metabase to see if an advanced queueing dll
        has been set and loads it if so. If no dll is set then the default is
        loaded.

    Returns:

        NO_ERROR on success
        Whatever error occurred on failure

--*/

APIERR SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()
{
    char szValueName[MAX_PATH + 1];
    char szAQDll[MAX_PATH + 1];
    STR TempString;
    DWORD fRet;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()");

    lstrcpy(szValueName, g_pInetSvc->QueryMDPath());

    if ( !mb.Open( szValueName, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) 
    {
        return ERROR_SERVICE_DISABLED;
    }

    TempString.Reset();
    szAQDll[0] = '\0';
    if (fRet = mb.GetStr("", MD_AQUEUE_DLL, IIS_MD_UT_FILE, &TempString, METADATA_INHERIT, "")) 
    {
        lstrcpyn(szAQDll, TempString.QueryStr(), MAX_PATH);
        DebugTrace((LPARAM)this, "Loading extended advanced queueing DLL %s", szAQDll);
    } 
    
    if (!fRet || (szAQDll[0] == '\0'))
    {
        lstrcpyn(szAQDll, AQ_DLL_NAME, MAX_PATH);
        DebugTrace((LPARAM)this, "No extended advanced queueing DLL set, loading %s\n", szAQDll);
    }

    if(!LoadAdvancedQueueing(szAQDll))
    {
        HRESULT err = GetLastError();
        ErrorTrace((LPARAM)this, "LoadAdvancedQueueing failed, %u", err);
        SmtpLogEvent(SMTP_EVENT_FAILED_TO_LOAD_AQUEUE, 0, (const CHAR **)NULL, 0);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);

        mb.Close();
        TraceFunctLeaveEx((LPARAM)this);
        return err;
    }

    mb.Close();
    TraceFunctLeaveEx((LPARAM)this);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\globals.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        globals.cxx

   Abstract:

        This module contains global variable definitions shared by the
        various SMTP Service components.

   Author:
        KeithMo     07-Mar-1993 Created.

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include "dropdir.hxx"


#include "mailmsg_i.c"
#include "mailmsgi_i.c"
#include "aqueue_i.c"

#include "aqstore.hxx"

#include <dnsapi.h>
//
//  Version string for this server
//

#define MSSMTP_VERSION_STR_IIS        "Microsoft-IIS/K2"
#define MSSMTP_VERSION_STR_W95        "Microsoft-PWS-95/K2"
#define MSSMTP_VERSION_STR_NTW        "Microsoft-PWS/K2"

//
// Set to the largest of the three
//

#define MSSMTP_VERSION_STR_MAX        MSSMTP_VERSION_STR_W95

//
// Creates the version string
//

#define MAKE_VERSION_STRING( _s )   ("Server: " ##_s "\r\n")

//
//  MIME version we say we support
//

#define SMTP_MIME_VERSION_STR       "MIME-version: 1.0"

#define SMTP_TEMP_DIR_NAME          " "

//
// Server type string
//

CHAR g_szServerType[ sizeof(MSSMTP_VERSION_STR_MAX)];
DWORD g_cbServerType = 0;
CHAR szServerVersion[sizeof(MAKE_VERSION_STRING(MSSMTP_VERSION_STR_MAX))];
DWORD cbServerVersionString = 0;

DWORD g_ProductType = 5;
PLATFORM_TYPE g_SmtpPlatformType = PtNtServer;

//computer name
CHAR g_ComputerName[MAX_PATH + 1];
DWORD g_ComputerNameLength;

// number of procs on system for thread mgmt.
DWORD g_NumProcessors = 1;

CHAR g_VersionString[128];
CHAR g_Password[MAX_PATH + 1];
CHAR g_UserName[MAX_PATH + 1];
CHAR g_DomainName[MAX_PATH + 1];

static char g_BoundaryChars [] = "0123456789abcdefghijklmnopqrstuvwxyz"
                                "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

//Max Objects

DWORD g_cMaxAddressObjects;
DWORD g_cMaxPropertyBagObjects;
DWORD g_cMaxMailObjects;
DWORD g_cMaxEtrnObjects;
DWORD g_cMaxRoutingThreads;

// externs for cmmprops.lib and blockmgr.lib to control debug code
DWORD g_fValidateSignatures = 0;
DWORD g_fForceCrashOnError = 0;
DWORD g_fFillPropertyPages = 0;

DWORD g_cMaxConnectionObjs = 2000;
BOOL  g_CalledSrand;
DWORD g_dwIncMsgId;

// X5 189659 instrumentation
DWORD g_fCrashOnInvalidSMTPConn = 0;

//These buffers are associated with every incoming connection - so we
//will need to have atleast those any plus a few more for use in Dir pickup
//and large SSL buffers
DWORD g_cMaxDirBuffers = 2500;
//This buffer is now used primarily as WRITEBUFFER for every connection
//We have decided to go with 32K buffer
//NK** : Make this metabse readable
DWORD g_cMaxDirChangeIoSize = SMTP_WRITE_BUFFER_SIZE;


//loopback address
DWORD g_LoopBackAddr;

unsigned char GlobalIpBuffer[10000];
CShareLockNH  g_GlobalLock;
SOCKET g_IpListSocket = INVALID_SOCKET;
WSAOVERLAPPED WsaOverLapped;

HANDLE  g_ShutdownHandle = NULL;
HANDLE  g_TcpNotifyHandle = NULL;
HANDLE  g_FreeLibThreadHandle = NULL;
CTcpRegIpList  g_TcpRegIpList;

//
// Notification object used to watch for changes in CAPI stores
//
STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

//
//  Miscellaneous data.
//

LARGE_INTEGER    AllocationGranularity;         // Page allocation granularity.
HANDLE           g_hSysAccToken = NULL;
TCHAR          * g_pszSmtpTempDirName;            // Name of temporary directory.

DWORD           g_PickupWait;
DWORD           g_FreeLibInterval = 1;   //Interval in min to wait before calling CoFreeUnusedLib
DWORD           g_UseMapiDriver = 0;
LONG            g_MaxFindThreads;

//
// Platform type
//

PLATFORM_TYPE SmtpPlatformType = PtNtServer;
BOOL g_fIsWindows95 = FALSE;

//
// Statistics.
// used to write statistics counter values to when instance is unknown
//

LPSMTP_SERVER_STATISTICS  g_pSmtpStats;

//
// SEO Handle
//
IUnknown    *g_punkSEOHandle;

//
// Externals for SEO
//
extern HRESULT SEOGetServiceHandle(IUnknown **);


//
// Generate the string storage space
//

#if 0
# include "strconst.h"
# define CStrM( FriendlyName, ActualString)   \
   const char  PSZ_ ## FriendlyName[] = ActualString;

ConstantStringsForThisModule()

# undef CStrM

#endif

DWORD SmtpDebug;
extern "C" {
BOOL g_IsShuttingDown = FALSE;
}

DWORD g_SmtpInitializeStatus = 0;
TIME_ZONE_INFORMATION   tzInfo;

#define MAX_CONNECTION_OBJECTS  5000;

BOOL GetMachineIpAddresses(void);
DWORD TcpRegNotifyThread( LPDWORD lpdw );
DWORD FreeLibThread( LPDWORD lpdw );

//
// eventlog object
//
CEventLogWrapper g_EventLog;

//
// Header Date time cache
//

//PCACHED_DATETIME_FORMATS    g_pDateTimeCache = NULL;

static TCHAR    szParamPath[] = TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters");
static WCHAR    szParamPathW[] = L"System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters";
static TCHAR    szMaxAddrObjects[] = TEXT("MaxAddressObjects");
static WCHAR    szMaxAddrObjectsW[] = L"MaxAddressObjects";
static TCHAR    szMaxPropertyBagObjects[] = TEXT("MaxPropertyBagObjects");
static WCHAR    szMaxPropertyBagObjectsW[] = L"MaxPropertyBagObjects";
static TCHAR    szMaxMailObjects[] = TEXT("MaxMailObjects");
static WCHAR    szMaxMailObjectsW[] = L"MaxMailObjects";
static TCHAR    szMaxEtrnObjects[] = TEXT("MaxEtrnObjects");
static WCHAR    szMaxEtrnObjectsW[] = L"MaxEtrnObjects";
static TCHAR    szDirBuffers[] = TEXT("MaxDirectoryBuffers");
static WCHAR    szDirBuffersW[] = L"MaxDirectoryBuffers";
static TCHAR    szDirBuffersSize[] = TEXT("DirectoryBuffSize");
static WCHAR    szDirBuffersSizeW[] = L"DirectoryBufferSize";
static TCHAR    szDirPendingIos[] = TEXT("NumDirPendingIos");
static WCHAR    szDirPendingIosW[] = L"NumDirPendingIos";
static TCHAR    szRoutingThreads[] = TEXT("RoutingThreads");
static WCHAR    szRoutingThreadsW[] = L"RoutingThreads";
static TCHAR    szProductType[] = TEXT("ProductType");
static WCHAR    szProductTypeW[] = L"ProductType";
static TCHAR    szResolverSockets[] = TEXT("NumDnsResolverSockets");
static WCHAR    szResolverSocketsW[] = L"NumDnsResolverSockets";
static TCHAR    szDnsSocketTimeout[] = TEXT("msDnsSocketTimeout");
static WCHAR    szDnsSocketTimeoutW[] = L"msDnsSocketTimeout";
static TCHAR    szPickupWait[] = TEXT("PickupWait");
static WCHAR    szPickupWaitW[] = L"PickupWait";
static TCHAR    szMaxFindThreads[] = TEXT("MaxFindThreads");
static WCHAR    szMaxFindThreadsW[] = L"MaxFindThreads";
static TCHAR    szFreeLibInterval[] = TEXT("FreeLibInterval");
static WCHAR    szFreeLibIntervalW[] = L"FreeLibInterval";
static TCHAR    szUseMapiDrv[] = TEXT("UseMapiDriver");
static WCHAR    szUseMapiDrvW[] = L"UseMapiDriver";
static TCHAR    szDnsErrorsBeforeFailover[] = TEXT("DnsErrorsBeforeFailover");
static WCHAR    szDnsErrorsBeforeFailoverW[] = L"DnsErrorsBeforeFailover";
static TCHAR    szDnsConnectsInProbation[] = TEXT("DnsConnectsInProbation");
static WCHAR    szDnsConnectsInProbationW[] = L"DnsConnectsInProbation";
//
// resolver globals
//

DWORD   g_ResolverSockets = 10;
DWORD   g_DnsSocketTimeout = 60000;
DWORD   g_DnsErrorsBeforeFailover = 3;
DWORD   g_DnsConnectsInProbation = 2;



typedef struct  tagVERTAG {
    LPSTR   pszTag;
} VERTAG, *PVERTAG, FAR *LPVERTAG;



VERTAG  Tags[] = {
  //  { "FileDescription" },
//  { "OriginalFilename" },
  //  { "ProductName" },
    { "ProductVersion" },
//  { "LegalCopyright" },
//  { "LegalCopyright" },
};

#define NUM_TAGS    (sizeof( Tags ) / sizeof( VERTAG ))

BOOL GetRegistryDwordParameter(
            LPCSTR  pcszParameterName,
            DWORD   *pdwValue
            )
{
    HKEY    hKey = NULL;
    DWORD   dwRes;
    DWORD   dwType;
    DWORD   dwLength;
    DWORD   dwValue;
    BOOL    fRes = FALSE;

    // Open the registry key
    dwRes = (DWORD)RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                _T("Software\\Microsoft\\Exchange\\SmtpSvc"),
                0,
                KEY_ALL_ACCESS,
                &hKey);
    if (dwRes == ERROR_SUCCESS)
    {
        // Adjust the buffer size for character type ...
        dwLength = sizeof(DWORD);
        dwRes = (DWORD)RegQueryValueEx(
                    hKey,
                    pcszParameterName,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwLength);
        if ((dwRes == ERROR_SUCCESS) && dwType == REG_DWORD)
        {
            *pdwValue = dwValue;
            fRes = TRUE;
        }

        _VERIFY(RegCloseKey(hKey) == NO_ERROR);
    }

    return(fRes);
}

//DWORD ConfigIMCService(void);

DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   )
{
    static char sz[256], szFormat[256], sz2[256];
    int     i;
    UINT    uBytes;
    LPVOID  lpMem;
    DWORD   dw = 0, dwSize;
    HANDLE  hMem;
    LPVOID  lpsz;
    LPDWORD lpLang;
    DWORD   dwLang2;
    BOOL    bRC, bFileFound = FALSE;

    LPSTR   lpstrOrig = lpstrOut ;


    //CharUpper( lpszTitle );

    if ( dwSize = GetFileVersionInfoSize( lpszFile, &dw ) ) {
        if ( hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_ZEROINIT, (UINT)dwSize ) ) {
            lpMem = GlobalLock(hMem);
            if (GetFileVersionInfo( lpszFile, 0, dwSize, lpMem ) &&
                VerQueryValue(  lpMem, "\\VarFileInfo\\Translation",
                                (LPVOID FAR *)&lpLang, &uBytes ) )
            {
                dwLang2 = MAKELONG( HIWORD(lpLang[0]), LOWORD(lpLang[0]) );

                for( i=0; i<NUM_TAGS; i++ ) {

                    lpsz = 0 ;
                    //
                    // need to do the reverse because most winnt files are wrong
                    //
                    wsprintf( sz, "\\StringFileInfo\\%08lx\\%s", lpLang[0], Tags[i].pszTag );
                    wsprintf( sz2, "\\StringFileInfo\\%08lx\\%s", dwLang2, Tags[i].pszTag );
                    bRC =   VerQueryValue( lpMem, sz, &lpsz, &uBytes ) ||
                            VerQueryValue( lpMem, sz2, &lpsz, &uBytes ) ;

                    if( lpsz != 0 )
                    {

                        if( uBytes+1 < cbOut )
                        {
                            uBytes = min( (UINT)lstrlen( (char*)lpsz ), uBytes ) ;
                            CopyMemory( lpstrOut, lpsz, uBytes ) ;
                            lpstrOut[uBytes++] = ' ' ;
                            lpstrOut += uBytes ;
                            cbOut -= uBytes ;
                        }
                        else
                        {
                            GlobalUnlock( hMem );
                            GlobalFree( hMem );
                            return  (DWORD)(lpstrOut - lpstrOrig) ;
                        }
                    }

                }
                // version info from fixed struct
                bRC = VerQueryValue(lpMem,
                                    "\\",
                                    &lpsz,
                                    &uBytes );

                #define lpvs    ((VS_FIXEDFILEINFO FAR *)lpsz)
                static  char    szVersion[] = "Version: %d.%d.%d.%d" ;

                if ( (cbOut > (sizeof( szVersion )*2)) && lpsz ) {

                    CopyMemory( szFormat, szVersion, sizeof( szVersion ) ) ;
                    //LoadString( hInst, IDS_VERSION, szFormat, sizeof(szFormat) );

                    DWORD   cbPrint = wsprintf( lpstrOut, szFormat, HIWORD(lpvs->dwFileVersionMS),
                                LOWORD(lpvs->dwFileVersionMS),
                                HIWORD(lpvs->dwFileVersionLS),
                                LOWORD(lpvs->dwFileVersionLS) );
                    lpstrOut += cbPrint ;

                }
                bFileFound = TRUE;
            }   else    {

            }

            GlobalUnlock( hMem );
            GlobalFree( hMem );
        }       else    {

        }
    }   else    {

    }
    DWORD   dw2 = GetLastError() ;

    return  (DWORD)(lpstrOut - lpstrOrig) ;
}


BOOL InitServerVersionString( VOID )
{
    BOOL fRet = TRUE ;
    DWORD szSize;
    char szServerPath[MAX_PATH + 1];
    char * szOffset;

    CopyMemory(szServerPath, "c:\\", sizeof( "c:\\" ) ) ;

    g_VersionString [0] = '\0';

    HMODULE hModule = GetModuleHandle( "smtpsvc.dll" ) ;
    if( hModule != 0 )
    {

        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath ) ) )
        {
            lstrcpy( szServerPath, "c:\\") ;
        }
        else
        {
            szSize = SetVersionStrings(szServerPath, "", g_VersionString, 128 );
            szOffset = strstr(g_VersionString, "Version");
            if(szOffset)
            {
                //Move interesting part of string (including the
                //terminating NULL) to front of g_VersionString.
                MoveMemory(g_VersionString, szOffset, 
                    szSize+1 - (szOffset - g_VersionString));
            }

        }
    }


    return TRUE ;
}

BOOL GetGlobalRegistrySettings(void)
{
    BOOL        fRet = TRUE;
    HKEY        hkeySmtp = NULL;
    HKEY        hkeySub = NULL;
    DWORD       dwErr;
    DWORD       dwDisp;

    DWORD       dwMaxFindThreads;

    TraceFunctEnterEx((LPARAM)NULL, "GetGlobalRegistrySettings");

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szParamPath, NULL, NULL,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeySmtp, &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        SmtpLogEventEx(SMTP_EVENT_CANNOT_OPEN_SVC_REGKEY, (const char *)SMTP_PARAMETERS_KEY, dwErr);
        TraceFunctLeave();
        SetLastError(dwErr);
        return FALSE;
    }

    g_cMaxAddressObjects = ReadRegistryDword(hkeySmtp, szMaxAddrObjects, 100000);
    StateTrace((LPARAM)NULL, "g_cMaxAddressObjects = %u", g_cMaxAddressObjects);

    //NK ** We atleast need as many buffers as many connections we accept
    //so I have now tied it to that value
    //g_cMaxDirBuffers = ReadRegistryDword(hkeySmtp, szDirBuffers, 5000);
    //g_cMaxDirChangeIoSize = ReadRegistryDword(hkeySmtp, szDirBuffersSize, MAX_WRITE_FILE_BLOCK);

    g_ResolverSockets = ReadRegistryDword(hkeySmtp, szResolverSockets, 10);
    g_DnsSocketTimeout = ReadRegistryDword(hkeySmtp, szDnsSocketTimeout, 60000);
    g_DnsErrorsBeforeFailover = ReadRegistryDword(hkeySmtp, szDnsErrorsBeforeFailover, 3);
    g_DnsConnectsInProbation = ReadRegistryDword(hkeySmtp, szDnsConnectsInProbation, 2);

    g_PickupWait = ReadRegistryDword(hkeySmtp, szPickupWait, 200);
    // don't let them make this wait more than 5 secs.  that is too much.
    if (g_PickupWait > 5000)
    {
        g_PickupWait = 5000;
    }

    //In seems like after the call to unload, the dlls get physically unloaded
    //11 min after that. So I am setting the interval by default to 11.
    g_FreeLibInterval = ReadRegistryDword(hkeySmtp,szFreeLibInterval, 11);
    // don't let them make this wait more than 60 min.  that is too much.
    if (g_FreeLibInterval > 60)
    {
        g_FreeLibInterval = 60;
    }

    dwMaxFindThreads = ReadRegistryDword(hkeySmtp, szMaxFindThreads, 3);
    // don't want this to be bigger than the routing threads, but we want at least one.
    if (dwMaxFindThreads > 3)
    {
        dwMaxFindThreads = 3;
    }
    else if (dwMaxFindThreads <= 0)
    {
        dwMaxFindThreads = 1;
    }

    g_MaxFindThreads = dwMaxFindThreads;

    RegCloseKey(hkeySmtp);
    TraceFunctLeaveEx((LPARAM)NULL);
    return fRet;
}

void IpAddressListCallBack (DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED LpOverlapped,
                            DWORD dwFlags)
{
    DWORD wsError = 0;
    DWORD bytesReturned = 0;

    GetMachineIpAddresses();

    wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL,
                    0, &bytesReturned, &WsaOverLapped, IpAddressListCallBack);

}

BOOL GetMachineIpAddresses(void)
{
    DWORD   bytesReturned = 0;
    DWORD   wsError = 0;
    BOOL fRet = FALSE;

    g_GlobalLock.ExclusiveLock();

    ZeroMemory((void *)GlobalIpBuffer, sizeof(GlobalIpBuffer));

     if(g_IpListSocket != INVALID_SOCKET)
     {
        wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_QUERY, NULL, 0, (LPVOID) GlobalIpBuffer,
                    sizeof(GlobalIpBuffer), &bytesReturned, NULL, NULL);

        if(wsError == 0)
        {
            fRet = TRUE;
        }
     }

    g_GlobalLock.ExclusiveUnlock();
    return fRet;
}

BOOL IsIpInGlobalList(DWORD IpAddress)
{
    INT AddressCount = 0;
    SOCKET_ADDRESS_LIST * ptr = NULL;
    sockaddr_in * Current = NULL;
    char Scratch[100];

    TraceFunctEnterEx((LPARAM)NULL, "IsIpInGlobalList");

    g_GlobalLock.ShareLock();

    Scratch[0] = '\0';

    ptr = (SOCKET_ADDRESS_LIST *)GlobalIpBuffer;

    for (AddressCount = 0; AddressCount < ptr->iAddressCount;AddressCount++)
    {
            Current = (sockaddr_in *) ptr->Address[AddressCount].lpSockaddr;
            if(Current)
            {
                DebugTrace((LPARAM)NULL," Address - %s", inet_ntoa( Current->sin_addr));

                if(Current->sin_addr.s_addr == IpAddress)
                {
                    InetNtoa(*(struct in_addr *) &Current->sin_addr.s_addr, Scratch);

                    ErrorTrace((LPARAM) NULL, "IpAddress %s is one of mine - Failing connection", Scratch);
                    g_GlobalLock.ShareUnlock();
                    TraceFunctLeaveEx((LPARAM)NULL);
                    return TRUE;
                }
            }
    }

    g_GlobalLock.ShareUnlock();

    InetNtoa(*(struct in_addr *) &IpAddress, Scratch);

    DebugTrace((LPARAM) NULL, "IpAddress %s is not one of mine ", Scratch);

    TraceFunctLeaveEx((LPARAM)NULL);
    return FALSE;
}

void VerifyFQDNWithGlobalIp(DWORD InstanceId, char * szFQDomainName)
{
    INT AddressCount = 0;
    SOCKET_ADDRESS_LIST * ptr = NULL;
    sockaddr_in * Current = NULL;
    char Scratch[100];
    Scratch[0] = '\0';
    CONST CHAR *apszMsgs[2];
    CHAR achInstance[20];
    CHAR achIPAddr[20];
    PHOSTENT pH = NULL;

    //Get the current instnace id
    wsprintf( achInstance,
              "%lu",
              InstanceId );
    apszMsgs[1] = achInstance;


    g_GlobalLock.ShareLock();
    ptr = (SOCKET_ADDRESS_LIST *)GlobalIpBuffer;
    for (AddressCount = 0; AddressCount < ptr->iAddressCount;AddressCount++)
    {
        Current = (sockaddr_in *) ptr->Address[AddressCount].lpSockaddr;
        if(Current)
        {
            ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
            //For each IP address find the host name
            pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)Current)->sin_addr), 4, PF_INET );
            if(pH == NULL)
            {
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN, 0, (const CHAR **)NULL, 0 );
            }
            else if(_strnicmp(pH->h_name,szFQDomainName,strlen(szFQDomainName)))
            {
                wsprintf( achIPAddr,"%s",inet_ntoa( Current->sin_addr));
                apszMsgs[0] = achIPAddr;
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
            }
        }
    }
    g_GlobalLock.ShareUnlock();
}


//
//  Public functions.
//

APIERR
InitializeGlobals(
            VOID
            )

/*++

Routine Description:

    Initializes global shared variables.  Some values are
        initialized with constants, others are read from the
        configuration registry.

Arguments:

    None.

Return Value:

    Win32

--*/
{
    DWORD  err;
    DWORD MaxConnections;
    SYSTEM_INFO     systemInfo;
    HRESULT hr = S_OK;
    DWORD   wsError = 0;
    DWORD   bytesReturned = 0;
    DWORD   dwThreadId = 0;

    TraceFunctEnter( "InitializeGlobals" );

    g_CalledSrand = FALSE;
    g_dwIncMsgId = 0;

    g_ShutdownHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    if(g_ShutdownHandle == NULL)
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot allocate shutdown handle. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_TcpNotifyHandle =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)TcpRegNotifyThread,
                            NULL,
                            0,
                            &dwThreadId );

    if (g_TcpNotifyHandle == NULL )
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot create notify thread. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    hr = g_EventLog.Initialize("smtpsvc");
    if (FAILED(hr)) {
        // do nothing
    }

    g_IpListSocket = socket (AF_INET, SOCK_STREAM, 0);
    if(g_IpListSocket != INVALID_SOCKET)
    {
        GetMachineIpAddresses();
        wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL,
                    0, &bytesReturned, &WsaOverLapped, IpAddressListCallBack);

        if(wsError == 0)
        {
            //fRet = TRUE;
        }

    }

    //
    // read the global registry settings
    //

    g_SmtpPlatformType =  IISGetPlatformType();

    if(!GetGlobalRegistrySettings())
    {
        FatalTrace(NULL, "Could not read global reg settings!");
        TraceFunctLeave();
        return ERROR_SERVICE_DISABLED;
    }

    //thread to periodically call free ununsed libraries
    //so dll's can be unloaded
    g_FreeLibThreadHandle =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)FreeLibThread,
                            NULL,
                            0,
                            &dwThreadId );

    if (g_FreeLibThreadHandle == NULL )
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot create Free Library thread. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    //
    // do global SEO initialization
    //
    hr = SEOGetServiceHandle(&g_punkSEOHandle);
    if (FAILED(hr))
    {
        ErrorTrace(0, "SEOGetServiceHandle returned %x", hr);

        // we're in trouble here.  we'll try and continue on, but server events
        // probably won't work right
        g_punkSEOHandle = NULL;
        //SmtpLogEventSimple(SEO_INIT_FAILED, hr);
    }

    //
    // Initialize the server version string based on the platform type
    //
    InitServerVersionString();

    SmtpPlatformType =  IISGetPlatformType();

    switch ( SmtpPlatformType )
    {

    case PtNtWorkstation:
        lstrcpy(szServerVersion,MAKE_VERSION_STRING(MSSMTP_VERSION_STR_NTW));
        lstrcpy(g_szServerType, MSSMTP_VERSION_STR_NTW);
        break;

    default:

        //
        // Either server or unhandled platform type!
        //

        DBG_ASSERT(InetIsNtServer(SmtpPlatformType));
        lstrcpy(szServerVersion,MAKE_VERSION_STRING(MSSMTP_VERSION_STR_IIS));
        lstrcpy(g_szServerType, MSSMTP_VERSION_STR_IIS);
    }

    g_cbServerType = lstrlen( g_szServerType);
    cbServerVersionString = lstrlen(szServerVersion);

    //store the computer name
    g_ComputerNameLength = MAX_PATH;
    if (!GetComputerName(g_ComputerName, &g_ComputerNameLength))
    {
        err = GetLastError();
        ErrorTrace((LPARAM)NULL, "GetComputerName() failed with err %d", err);
        TraceFunctLeave();
        return err;
    }


    // number of processors on the system.
    GetSystemInfo( &systemInfo );
    g_NumProcessors = systemInfo.dwNumberOfProcessors;

    g_LoopBackAddr = inet_addr ("127.0.0.1");
    g_pSmtpStats = NULL;

    //find out what the max connection paramater is
    MaxConnections = MAX_CONNECTION_OBJECTS;

    DebugTrace(NULL, "g_cMaxConnectionObjs = %d", g_cMaxConnectionObjs);

    //allocate some SMTP_CONNECTION objects from CPOOL
    if (!SMTP_CONNECTION::Pool.ReserveMemory( g_cMaxConnectionObjs, sizeof(SMTP_CONNECTION) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for SMTP_CONNECTION. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }


    g_SmtpInitializeStatus |= INITIALIZE_INBOUNDPOOL;

    //allocate some SMTP_CONNECTION objects from CPOOL
    if (!SMTP_CONNOUT::Pool.ReserveMemory(MaxConnections, sizeof(SMTP_CONNOUT) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for SMTP_CONNOUT. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_OUTBOUNDPOOL;

    //allocate some CAddr objects from CPOOL
    if (!CAddr::Pool.ReserveMemory(1000, sizeof(CAddr) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for CAddr. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_ADDRESSPOOL;


    if (!CAsyncMx::Pool.ReserveMemory(3000, sizeof(CAsyncMx)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CASYNCMX;

    if (!CAsyncSmtpDns::Pool.ReserveMemory(4000, sizeof(CAsyncSmtpDns)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CASYNCDNS;

    //
    // Initialize the file handle cache
    //
    if (!InitializeCache()) {
            err = GetLastError();
            ErrorTrace(0, "InitializeCache failed err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_FILEHC;


    if (!CBuffer::Pool.ReserveMemory(g_cMaxDirBuffers, sizeof(CBuffer)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CBUFFERPOOL;

    if (!CIoBuffer::Pool.ReserveMemory(g_cMaxDirBuffers, g_cMaxDirChangeIoSize))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CIOBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
        }

    g_SmtpInitializeStatus |= INITIALIZE_CIOBUFFPOOL;

    if (!CBlockMemoryAccess::m_Pool.ReserveMemory(2000, sizeof(BLOCK_HEAP_NODE)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBlockMemoryAccess. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }
    g_SmtpInitializeStatus |= INITIALIZE_CBLOCKMGR;

    if (!CDropDir::m_Pool.ReserveMemory(1000, sizeof(CDropDir)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CDropDir. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }
    g_SmtpInitializeStatus |= INITIALIZE_CDROPDIR;

    //
    // Create the CAPI store notification object
    //
    g_pCAPIStoreChangeNotifier = new STORE_CHANGE_NOTIFIER();

    if ( g_pCAPIStoreChangeNotifier == NULL )
    {
            err = GetLastError();
            ErrorTrace(0, "Failed to create CAPIStoreChange notifier err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }


    if (!CEncryptCtx::Initialize(
            "SmtpSvc",
            (struct IMDCOM*) g_pInetSvc->QueryMDObject(),
            (PVOID) (&g_SmtpSMC)))
    {
        err = GetLastError();
        ErrorTrace(0, "Initializing SSL Context failed. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_SSLCONTEXT;

    if (!CSecurityCtx::Initialize(FALSE, FALSE))
    {
        err = GetLastError();
        ErrorTrace(NULL, "CSecurityCtx::Initialize failed, %u", err);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CSECURITY;

    GetTimeZoneInformation(&tzInfo);

    // Enable/disable 189659 instrumentation
    GetRegistryDwordParameter(
        _T("CrashOnInvalidSMTPConn"),
        &g_fCrashOnInvalidSMTPConn);

    TraceFunctLeave();
    return NO_ERROR;

error_exit:

    err = GetLastError();
    if(err == NO_ERROR)
    {
        SetLastError(ERROR_PATH_NOT_FOUND);
        err = ERROR_PATH_NOT_FOUND;
    }

    TraceFunctLeave();
    return err;

}   // InitializeGlobals


VOID
TerminateGlobals(
            VOID
            )

/*++

Routine Description:

    Terminates global shared variables.

Arguments:

    None.

Return Value:

    None.

--*/
{

  if(g_ShutdownHandle)
  {
    SetEvent(g_ShutdownHandle);
  }

  if(g_SmtpInitializeStatus & INITIALIZE_INBOUNDPOOL)
  {
    //finally, release all our memory
    SMTP_CONNECTION::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_OUTBOUNDPOOL)
  {
    SMTP_CONNOUT::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_ADDRESSPOOL)
  {
    CAddr::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CBUFFERPOOL)
  {
    //finally, release all our memory
    CBuffer::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CIOBUFFPOOL)
  {
    //finally, release all our memory
    CIoBuffer::Pool.ReleaseMemory();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_CDROPDIR)
  {
      CDropDir::m_Pool.ReleaseMemory();
  }
  
  if ( g_pCAPIStoreChangeNotifier )
  {
      delete g_pCAPIStoreChangeNotifier;
      g_pCAPIStoreChangeNotifier = NULL;
  }

  if (g_SmtpInitializeStatus & INITIALIZE_SSLCONTEXT) {
      CEncryptCtx::Terminate();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_CSECURITY)
        CSecurityCtx::Terminate();

  if(g_SmtpInitializeStatus & INITIALIZE_CASYNCMX)
  {
    //finally, release all our memory
    CAsyncMx::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CASYNCDNS)
  {
    //finally, release all our memory
    CAsyncSmtpDns::Pool.ReleaseMemory();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_FILEHC) {
    TerminateCache();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CBLOCKMGR)
  {
    //finally, release all our memory
    CBlockMemoryAccess::m_Pool.ReleaseMemory();
  }

    if( g_pSmtpStats != NULL )
    {
        delete g_pSmtpStats;
        g_pSmtpStats = NULL;
    }

    if(g_IpListSocket != INVALID_SOCKET)
    {
        closesocket (g_IpListSocket);
        g_IpListSocket = INVALID_SOCKET;
    }

    UnLoadQueueDriver();

    //
    // do global SEO cleanup
    //
    if (g_punkSEOHandle != NULL)
    {
        g_punkSEOHandle->Release();
        g_punkSEOHandle = NULL;
    }

    if(g_TcpNotifyHandle != NULL)
    {
        WaitForSingleObject(g_TcpNotifyHandle, INFINITE);
        CloseHandle(g_TcpNotifyHandle);
        g_TcpNotifyHandle = NULL;
    }

    if(g_FreeLibThreadHandle != NULL)
    {
        WaitForSingleObject(g_FreeLibThreadHandle, INFINITE);
        CloseHandle(g_FreeLibThreadHandle);
        g_FreeLibThreadHandle = NULL;
    }


    if(g_ShutdownHandle != NULL)
    {
        CloseHandle(g_ShutdownHandle);
        g_ShutdownHandle = NULL;
    }

}   // TerminateGlobals

//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( char * str )
{
    BOOL fReturn = TRUE;
    char Tmp [MAX_PATH + 1];

    do
    {
        INT index=0;
        INT iLength = lstrlen(str) + 1;

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            GetCurrentDirectory( MAX_PATH+1, szCurrentDir );

            lstrcpyn(Tmp, str, ( index + 1 ));

            if ( !SetCurrentDirectory( Tmp))
            {
                if (( fReturn = CreateDirectory( Tmp, NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}

void GenerateMessageId (char * Buffer, DWORD BuffLen)
{
    //Temporary stuff
    DWORD MsgIdLen = 20;
    if(BuffLen < MsgIdLen)
        MsgIdLen = BuffLen;

    if( !g_CalledSrand )
    {
        srand( GetTickCount() );
        g_CalledSrand = TRUE;
    }
    
    lstrcpyn (Buffer, g_ComputerName, (MsgIdLen - 1));

    DWORD Loop = lstrlen(Buffer);
    while (Loop < (MsgIdLen - 1) )
    {
        Buffer[Loop] = g_BoundaryChars[rand() % (sizeof(g_BoundaryChars) - 1)];
        Loop++;
    }
    Buffer [Loop] = '\0';
}

DWORD GetIncreasingMsgId()
{
    return( InterlockedIncrement( (LONG*)&g_dwIncMsgId ) );
}

DWORD FreeLibThread( LPDWORD lpdw )
{
    DWORD   dw = 0;
    DWORD   dwWaitMillisec = g_FreeLibInterval * 1000 * 60;

    TraceFunctEnterEx((LPARAM) NULL, "FreeLibThread");

    for ( ;; )
    {
        dw = WaitForSingleObject(g_ShutdownHandle,
                                    dwWaitMillisec );

        switch( dw )
        {
        //
        // normal shutdown signalled
        //
        case WAIT_OBJECT_0:

            ErrorTrace((LPARAM) NULL, "Exiting FreeLibThread for hShutdownEvent");
            return  0;

        //
        // Timeout occured
        //
        case WAIT_TIMEOUT:
            CoFreeUnusedLibraries();
            break;

        default:
            ErrorTrace((LPARAM) NULL, "Exiting FreeLibThread for default reasons");
            return  1;
        }
    }

    return  2;
}


#define NUM_REG_THREAD_OBJECTS  2

DWORD TcpRegNotifyThread( LPDWORD lpdw )
{
    HANDLE  Handles[NUM_REG_THREAD_OBJECTS];
    PIP_ARRAY       aipServers =NULL;
    PLIST_ENTRY     pEntry = NULL;
    CTcpRegIpList   * pIpEntry = NULL;
    CTcpRegIpList   *IpList = NULL;
    HKEY       hKey = NULL;
    DWORD   dw = 0;

    TraceFunctEnterEx((LPARAM) NULL, "TcpRegNotifyThread");

    Handles[0] = g_ShutdownHandle;

    Handles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( Handles[1] == NULL )
    {
        return  1;
    }


    DnsGetDnsServerList( (PIP_ARRAY *) &aipServers );
    if (aipServers != NULL)
    {
        g_TcpRegIpList.Update(aipServers);
        DnsApiFree(aipServers);
    }

    if ( RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        "System\\CurrentControlSet\\Services\\Tcpip",
                        0,
                        KEY_READ,
                        &hKey ) != ERROR_SUCCESS )
    {
        ErrorTrace((LPARAM) NULL, "RegNotifyThread RegOpenKeyEx failed %d", GetLastError());
        CloseHandle( Handles[1] );
        return  1;
    }

    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue(hKey,
                                    TRUE,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    Handles[1],
                                    TRUE ) != ERROR_SUCCESS )
        {
            ErrorTrace((LPARAM) NULL, "RegNotifyThread RegNotifyChangeKeyValue failed %d", GetLastError());
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }

        dw = WaitForMultipleObjects(NUM_REG_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
            //
            // normal signalled event
            //
            case WAIT_OBJECT_0:
    
                //close all the handles
                RegCloseKey( hKey );
                CloseHandle( Handles[1] );
                Handles[1] = NULL;
                hKey = NULL;
    
                g_TcpRegIpList.Update(NULL);
                ErrorTrace((LPARAM) NULL, "Exiting TcpRegNotifyThread for hShutdownEvent");
                return  0;
    
            //
            // signalled that our registry keys have changed
            //
            case WAIT_OBJECT_0+1:
                DnsGetDnsServerList( &aipServers );
                g_TcpRegIpList.Update(aipServers);

                if(aipServers)
                    DnsApiFree(aipServers);

                break;
            default:
                RegCloseKey( hKey );
                CloseHandle( Handles[1] );
                return  1;
        }
    }

    RegCloseKey( hKey );
    CloseHandle( Handles[1] );

    return  2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\headers.cxx ===
/*
 * Copyright (c) 1983, 1995 Eric P. Allman
 * Copyright (c) 1988, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by the University of
 *    California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "smtpinc.h"
#include <listmacr.h>
#include "headers.hxx"

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

struct hdrinfo
{
    char    *hi_field;    /* the name of the field */
    unsigned int    hi_flags;    /* status bits, see below */
};

struct hdrinfo    HdrInfo[] =
{
        /* originator fields, most to least significant  */
    "resent-sender",      H_FROM|H_RESENT,
    "resent-from",        H_FROM|H_RESENT,
    "resent-reply-to",    H_FROM|H_RESENT,
    "sender",             H_FROM,
    "from",               H_FROM,
    "reply-to",           H_FROM,
    "full-name",          0,
    "return-receipt-to",  H_FROM|H_RECEIPTTO,
    "errors-to",          H_FROM|H_ERRORSTO,

        /* destination fields */
    "to",                 H_RCPT,
    "resent-to",          H_RCPT|H_RESENT,
    "cc",                 H_RCPT,
    "resent-cc",          H_RCPT|H_RESENT,
    "bcc",                H_RCPT,
    "resent-bcc",         H_RCPT|H_RESENT,
    "apparently-to",      H_RCPT,

        /* message identification and control */
    "message-id",         H_MID,
    "resent-message-id",  H_RESENT,

        /* date fields */
    "date",               H_DATE,
    "resent-date",        H_RESENT,

        /* trace fields */
    "received",           0,
    "x400-received",      0,
    "via",                0,
    "mail-from",          H_TRACE,

        /* miscellaneous fields */
    "comments",           0,
    "return-path",        H_RETURNPATH,
    "subject",            H_SUBJECT,

        /* X-Headers */
    "x-sender",           H_X_SENDER,
    "x-receiver",         H_X_RECEIVER,


    // 10/15/98 - MikeSwa Added supersedes headers
    "x-msgguid",          H_X_MSGGUID,
    "x-supersedesmsgguid",H_X_SUPERSEDES_MSGGUID,

    // 12/18/98 -- pgopi. Added X-originalArrivalTime header
    "x-originalarrivaltime" , H_X_ORIGINAL_ARRIVAL_TIME,
    
    NULL,                 0,
};


#define xalloc(size) HeapAlloc(GetProcessHeap(), 0, size)
/*
**  CHOMPHEADER -- process and save a header line.
**
**    Called by collect and by readcf to deal with header lines.
**
**    Parameters:
**        line -- header as a text line.
**        def -- if set, this is a default value.
**        hdrp -- a pointer to the place to save the header.
**        e -- the envelope including this header.
**
**    Returns:
**        flags for this header.
**
**    Side Effects:
**        The header is saved on the header list.
**        Contents of 'line' are destroyed.
*/
BOOL ChompHeader(char * line, DWORD& HeaderFlags, char ** ppszValueBuf)
{
    register char *p = line;
    HEADERVAL *h = NULL;
    char *fname = NULL;
    char *fvalue = NULL;
    char *oldfvalue = NULL;
    struct hdrinfo *hi = NULL;
    DWORD fNameSize;


    /* find canonical name */
    fname = p;

    while (isascii((UCHAR)*p) && isgraph((UCHAR)*p) && *p != ':')
             p++;

    fvalue = p;

    while (isascii((UCHAR)*p) && isspace((UCHAR)*p))
           p++;

    //See if we had anything atall
    if(p == line)
    {
        //We had a seperator CRLF
        HeaderFlags |= H_EOH;
        return (FALSE);
    }

    if (*p++ != ':' || fname == fvalue)
    {
        //syserr("553 header syntax error, line \"%s\"", line);
        return (FALSE);
    }

    fvalue = p;

    if(ppszValueBuf)
        *ppszValueBuf = fvalue;

    fNameSize = (DWORD)((p - line) - 1);

    /* see if it is a known type */
    for (hi = HdrInfo; hi->hi_field != NULL; hi++)
     {
         if (strncasecmp(hi->hi_field, fname, fNameSize) == 0)
          {
              HeaderFlags |= hi->hi_flags; //set our flag
              break;
          }
      }

    return (TRUE);
}


#if 0
/*
**  ADDHEADER -- add a header entry to the end of the queue.
**
**    This bypasses the special checking of chompheader.
**
**    Parameters:
**        field -- the name of the header field.
**        value -- the value of the field.
**        hp -- an indirect pointer to the header structure list.
**
**    Returns:
**        none.
**
**    Side Effects:
**        adds the field on the list of headers for this envelope.
*/

void
addheader(field, value, hdrlist)
    char *field;
    char *value;
    HDR **hdrlist;
{
    register HDR *h;
    register struct hdrinfo *hi;
    HDR **hp;

    /* find info struct */
    for (hi = HdrInfo; hi->hi_field != NULL; hi++)
    {
        if (strcasecmp(field, hi->hi_field) == 0)
            break;
    }

    /* find current place in list -- keep back pointer? */
    for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
    {
        if (strcasecmp(field, h->h_field) == 0)
            break;
    }

    /* allocate space for new header */
    h = (HDR *) xalloc(sizeof *h);
    h->h_field = field;
    h->h_value = newstr(value);
    h->h_link = *hp;
    h->h_flags = hi->hi_flags | H_DEFAULT;
    clrbitmap(h->h_mflags);
    *hp = h;
}
/*
**  HVALUE -- return value of a header.
**
**    Only "real" fields (i.e., ones that have not been supplied
**    as a default) are used.
**
**    Parameters:
**        field -- the field name.
**        header -- the header list.
**
**    Returns:
**        pointer to the value part.
**        NULL if not found.
**
**    Side Effects:
**        none.
*/

char * hvalue(char * field, HDR * header)
{
    register HDR *h;

    for (h = header; h != NULL; h = h->h_link)
    {
        if (!bitset(H_DEFAULT, h->h_flags) &&
            strcasecmp(h->h_field, field) == 0)
            return (h->h_value);
    }
    return (NULL);
}
#endif

/*
**  ISHEADER -- predicate telling if argument is a header.
**
**    A line is a header if it has a single word followed by
**    optional white space followed by a colon.
**
**    Header fields beginning with two dashes, although technically
**    permitted by RFC822, are automatically rejected in order
**    to make MIME work out.  Without this we could have a technically
**    legal header such as ``--"foo:bar"'' that would also be a legal
**    MIME separator.
**
**    Parameters:
**        h -- string to check for possible headerness.
**
**    Returns:
**        TRUE if h is a header.
**        FALSE otherwise.
**
**    Side Effects:
**        none.
*/

BOOL IsHeader(char *h)
{
    register char *s = h;

    if (s[0] == '-' && s[1] == '-')
        return FALSE;

    while (*s > ' ' && *s != ':' && *s != '\0')
        s++;

    if (h == s)
        return FALSE;

    /* following technically violates RFC822 */
    while (isascii((UCHAR)*s) && isspace((UCHAR)*s))
        s++;

    return (*s == ':');
}

#if 0
/*
**  EATHEADER -- run through the stored header and extract info.
**
**    Parameters:
**        e -- the envelope to process.
**        full -- if set, do full processing (e.g., compute
**            message priority).  This should not be set
**            when reading a queue file because some info
**            needed to compute the priority is wrong.
**
**    Returns:
**        none.
**
**    Side Effects:
**        Sets a bunch of global variables from information
**            in the collected header.
**        Aborts the message if the hop count is exceeded.
*/

void
eatheader(e, full)
    register ENVELOPE *e;
    bool full;
{
    register HDR *h;
    register char *p;
    int hopcnt = 0;
    char *msgid;
    char buf[MAXLINE];

    /*
    **  Set up macros for possible expansion in headers.
    */

    define('f', e->e_sender, e);
    define('g', e->e_sender, e);
    if (e->e_origrcpt != NULL && *e->e_origrcpt != '\0')
        define('u', e->e_origrcpt, e);
    else
        define('u', NULL, e);

    /* full name of from person */
    p = hvalue("full-name", e->e_header);
    if (p != NULL)
        define('x', p, e);

    if (tTd(32, 1))
        printf("----- collected header -----\n");
    msgid = NULL;
    for (h = e->e_header; h != NULL; h = h->h_link)
    {
        if (tTd(32, 1))
            printf("%s: ", h->h_field);
        if (h->h_value == NULL)
        {
            if (tTd(32, 1))
                printf("<NULL>\n");
            continue;
        }

        /* do early binding */
        if (bitset(H_DEFAULT, h->h_flags))
        {
            if (tTd(32, 1))
            {
                printf("(");
                xputs(h->h_value);
                printf(") ");
            }
            expand(h->h_value, buf, sizeof buf, e);
            if (buf[0] != '\0')
            {
                if (bitset(H_FROM, h->h_flags))
                {
                    extern char *crackaddr();

                    expand(crackaddr(buf), buf, sizeof buf, e);
                }
                h->h_value = newstr(buf);
                h->h_flags &= ~H_DEFAULT;
            }
        }

        if (tTd(32, 1))
        {
            xputs(h->h_value);
            printf("\n");
        }

        /* count the number of times it has been processed */
        if (bitset(H_TRACE, h->h_flags))
            hopcnt++;

        /* send to this person if we so desire */
        if (GrabTo && bitset(H_RCPT, h->h_flags) &&
            !bitset(H_DEFAULT, h->h_flags) &&
            (!bitset(EF_RESENT, e->e_flags) || bitset(H_RESENT, h->h_flags)))
        {
            int saveflags = e->e_flags;

            (void) sendtolist(h->h_value, NULLADDR,
                      &e->e_sendqueue, 0, e);

            /* delete fatal errors generated by this address */
            if (!GrabTo && !bitset(EF_FATALERRS, saveflags))
                e->e_flags &= ~EF_FATALERRS;
        }

        /* save the message-id for logging */
        p = "resent-message-id";
        if (!bitset(EF_RESENT, e->e_flags))
            p += 7;
        if (strcasecmp(h->h_field, p) == 0)
        {
            msgid = h->h_value;
            while (isascii((UCHAR)*msgid) && isspace((UCHAR)*msgid))
                msgid++;
        }

        /* see if this is a return-receipt header */
        if (bitset(H_RECEIPTTO, h->h_flags))
            e->e_receiptto = h->h_value;
    }
    if (tTd(32, 1))
        printf("----------------------------\n");

    /* if we are just verifying (that is, sendmail -t -bv), drop out now */
    if (OpMode == MD_VERIFY)
        return;

    /* store hop count */
    if (hopcnt > e->e_hopcount)
        e->e_hopcount = hopcnt;

    /* message priority */
    p = hvalue("precedence", e->e_header);
    if (p != NULL)
        e->e_class = priencode(p);
    if (e->e_class < 0)
        e->e_timeoutclass = TOC_NONURGENT;
    else if (e->e_class > 0)
        e->e_timeoutclass = TOC_URGENT;
    if (full)
    {
        e->e_msgpriority = e->e_msgsize
                 - e->e_class * WkClassFact
                 + e->e_nrcpts * WkRecipFact;
    }

    /* message timeout priority */
    p = hvalue("priority", e->e_header);
    if (p != NULL)
    {
        /* (this should be in the configuration file) */
        if (strcasecmp(p, "urgent"))
            e->e_timeoutclass = TOC_URGENT;
        else if (strcasecmp(p, "normal"))
            e->e_timeoutclass = TOC_NORMAL;
        else if (strcasecmp(p, "non-urgent"))
            e->e_timeoutclass = TOC_NONURGENT;
    }

    /* date message originated */
    p = hvalue("posted-date", e->e_header);
    if (p == NULL)
        p = hvalue("date", e->e_header);
    if (p != NULL)
        define('a', p, e);

    /* check to see if this is a MIME message */
    if ((e->e_bodytype != NULL &&
         strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
        hvalue("MIME-Version", e->e_header) != NULL)
    {
        e->e_flags |= EF_IS_MIME;
        if (HasEightBits)
            e->e_bodytype = "8BITMIME";
    }
    else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
    {
        /* this may be an RFC 1049 message */
        p = strpbrk(p, ";/");
        if (p == NULL || *p == ';')
        {
            /* yep, it is */
            e->e_flags |= EF_DONT_MIME;
        }
    }

    /*
    **  From person in antiquated ARPANET mode
    **    required by UK Grey Book e-mail gateways (sigh)
    */

    if (OpMode == MD_ARPAFTP)
    {
        register struct hdrinfo *hi;

        for (hi = HdrInfo; hi->hi_field != NULL; hi++)
        {
            if (bitset(H_FROM, hi->hi_flags) &&
                (!bitset(H_RESENT, hi->hi_flags) ||
                 bitset(EF_RESENT, e->e_flags)) &&
                (p = hvalue(hi->hi_field, e->e_header)) != NULL)
                break;
        }
        if (hi->hi_field != NULL)
        {
            if (tTd(32, 2))
                printf("eatheader: setsender(*%s == %s)\n",
                    hi->hi_field, p);
            setsender(p, e, NULL, TRUE);
        }
    }

    /*
    **  Log collection information.
    */

# ifdef LOG
    if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
        logsender(e, msgid);
# endif /* LOG */
    e->e_flags &= ~EF_LOGSENDER;
}
/*
**  LOGSENDER -- log sender information
**
**    Parameters:
**        e -- the envelope to log
**        msgid -- the message id
**
**    Returns:
**        none
*/

void
logsender(e, msgid)
    register ENVELOPE *e;
    char *msgid;
{
# ifdef LOG
    char *name;
    register char *sbp;
    register char *p;
    int l;
    char hbuf[MAXNAME + 1];
    char sbuf[MAXLINE + 1];
    char mbuf[MAXNAME + 1];

    /* don't allow newlines in the message-id */
    if (msgid != NULL)
    {
        l = strlen(msgid);
        if (l > sizeof mbuf - 1)
            l = sizeof mbuf - 1;
        bcopy(msgid, mbuf, l);
        mbuf[l] = '\0';
        p = mbuf;
        while ((p = strchr(p, '\n')) != NULL)
            *p++ = ' ';
    }

    if (bitset(EF_RESPONSE, e->e_flags))
        name = "[RESPONSE]";
    else if ((name = macvalue('_', e)) != NULL)
        ;
    else if (RealHostName == NULL)
        name = "localhost";
    else if (RealHostName[0] == '[')
        name = RealHostName;
    else
    {
        name = hbuf;
        (void) sprintf(hbuf, "%.80s", RealHostName);
        if (RealHostAddr.sa.sa_family != 0)
        {
            p = &hbuf[strlen(hbuf)];
            (void) sprintf(p, " (%s)",
                anynet_ntoa(&RealHostAddr));
        }
    }

    /* some versions of syslog only take 5 printf args */
#  if (SYSLOG_BUFSIZE) >= 256
    sbp = sbuf;
    sprintf(sbp, "from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d",
        e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
        e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
    sbp += strlen(sbp);
    if (msgid != NULL)
    {
        sprintf(sbp, ", msgid=%.100s", mbuf);
        sbp += strlen(sbp);
    }
    if (e->e_bodytype != NULL)
    {
        (void) sprintf(sbp, ", bodytype=%.20s", e->e_bodytype);
        sbp += strlen(sbp);
    }
    p = macvalue('r', e);
    if (p != NULL)
        (void) sprintf(sbp, ", proto=%.20s", p);
    syslog(LOG_INFO, "%s: %s, relay=%s",
        e->e_id, sbuf, name);

#  else            /* short syslog buffer */

    syslog(LOG_INFO, "%s: from=%s",
        e->e_id, e->e_from.q_paddr == NULL ? "<NONE>" :
                shortenstring(e->e_from.q_paddr, 83));
    syslog(LOG_INFO, "%s: size=%ld, class=%ld, pri=%ld, nrcpts=%d",
        e->e_id, e->e_msgsize, e->e_class,
        e->e_msgpriority, e->e_nrcpts);
    if (msgid != NULL)
        syslog(LOG_INFO, "%s: msgid=%s", e->e_id, mbuf);
    sbp = sbuf;
    sprintf(sbp, "%s:", e->e_id);
    sbp += strlen(sbp);
    if (e->e_bodytype != NULL)
    {
        sprintf(sbp, " bodytype=%s,", e->e_bodytype);
        sbp += strlen(sbp);
    }
    p = macvalue('r', e);
    if (p != NULL)
    {
        sprintf(sbp, " proto=%s,", p);
        sbp += strlen(sbp);
    }
    syslog(LOG_INFO, "%s relay=%s", sbuf, name);
#  endif
# endif
}
/*
**  PRIENCODE -- encode external priority names into internal values.
**
**    Parameters:
**        p -- priority in ascii.
**
**    Returns:
**        priority as a numeric level.
**
**    Side Effects:
**        none.
*/

int
priencode(p)
    char *p;
{
    register int i;

    for (i = 0; i < NumPriorities; i++)
    {
        if (!strcasecmp(p, Priorities[i].pri_name))
            return (Priorities[i].pri_val);
    }

    /* unknown priority */
    return (0);
}
/*
**  CRACKADDR -- parse an address and turn it into a macro
**
**    This doesn't actually parse the address -- it just extracts
**    it and replaces it with "$g".  The parse is totally ad hoc
**    and isn't even guaranteed to leave something syntactically
**    identical to what it started with.  However, it does leave
**    something semantically identical.
**
**    This algorithm has been cleaned up to handle a wider range
**    of cases -- notably quoted and backslash escaped strings.
**    This modification makes it substantially better at preserving
**    the original syntax.
**
**    Parameters:
**        addr -- the address to be cracked.
**
**    Returns:
**        a pointer to the new version.
**
**    Side Effects:
**        none.
**
**    Warning:
**        The return value is saved in local storage and should
**        be copied if it is to be reused.
*/

char *
crackaddr(addr)
    register char *addr;
{
    register char *p;
    register char c;
    int cmtlev;
    int realcmtlev;
    int anglelev, realanglelev;
    int copylev;
    bool qmode;
    bool realqmode;
    bool skipping;
    bool putgmac = FALSE;
    bool quoteit = FALSE;
    bool gotangle = FALSE;
    bool gotcolon = FALSE;
    register char *bp;
    char *buflim;
    char *bufhead;
    char *addrhead;
    static char buf[MAXNAME + 1];

    if (tTd(33, 1))
        printf("crackaddr(%s)\n", addr);

    /* strip leading spaces */
    while (*addr != '\0' && isascii((UCHAR)*addr) && isspace((UCHAR)*addr))
        addr++;

    /*
    **  Start by assuming we have no angle brackets.  This will be
    **  adjusted later if we find them.
    */

    bp = bufhead = buf;
    buflim = &buf[sizeof buf - 5];
    p = addrhead = addr;
    copylev = anglelev = realanglelev = cmtlev = realcmtlev = 0;
    qmode = realqmode = FALSE;

    while ((c = *p++) != '\0')
    {
        /*
        **  If the buffer is overful, go into a special "skipping"
        **  mode that tries to keep legal syntax but doesn't actually
        **  output things.
        */

        skipping = bp >= buflim;

        if (copylev > 0 && !skipping)
            *bp++ = c;

        /* check for backslash escapes */
        if (c == '\\')
        {
            /* arrange to quote the address */
            if (cmtlev <= 0 && !qmode)
                quoteit = TRUE;

            if ((c = *p++) == '\0')
            {
                /* too far */
                p--;
                goto putg;
            }
            if (copylev > 0 && !skipping)
                *bp++ = c;
            goto putg;
        }

        /* check for quoted strings */
        if (c == '"' && cmtlev <= 0)
        {
            qmode = !qmode;
            if (copylev > 0 && !skipping)
                realqmode = !realqmode;
            continue;
        }
        if (qmode)
            goto putg;

        /* check for comments */
        if (c == '(')
        {
            cmtlev++;

            /* allow space for closing paren */
            if (!skipping)
            {
                buflim--;
                realcmtlev++;
                if (copylev++ <= 0)
                {
                    *bp++ = ' ';
                    *bp++ = c;
                }
            }
        }
        if (cmtlev > 0)
        {
            if (c == ')')
            {
                cmtlev--;
                copylev--;
                if (!skipping)
                {
                    realcmtlev--;
                    buflim++;
                }
            }
            continue;
        }
        else if (c == ')')
        {
            /* syntax error: unmatched ) */
            if (copylev > 0 && !skipping)
                bp--;
        }

        /* check for group: list; syntax */
        if (c == ':' && anglelev <= 0 && !gotcolon && !ColonOkInAddr)
        {
            register char *q;

            if (*p == ':')
            {
                /* special case -- :: syntax */
                if (cmtlev <= 0 && !qmode)
                    quoteit = TRUE;
                if (copylev > 0 && !skipping)
                {
                    *bp++ = c;
                    *bp++ = c;
                }
                p++;
                goto putg;
            }

            gotcolon = TRUE;

            bp = bufhead;
            if (quoteit)
            {
                *bp++ = '"';

                /* back up over the ':' and any spaces */
                --p;
                while (isascii((UCHAR)*--p) && isspace((UCHAR)*p))
                    continue;
                p++;
            }
            for (q = addrhead; q < p; )
            {
                c = *q++;
                if (bp < buflim)
                {
                    if (quoteit && c == '"')
                        *bp++ = '\\';
                    *bp++ = c;
                }
            }
            if (quoteit)
            {
                if (bp == &bufhead[1])
                    bp--;
                else
                    *bp++ = '"';
                while ((c = *p++) != ':')
                {
                    if (bp < buflim)
                        *bp++ = c;
                }
                *bp++ = c;
            }

            /* any trailing white space is part of group: */
            while (isascii((UCHAR)*p) && isspace((UCHAR)*p) && bp < buflim)
                *bp++ = *p++;
            copylev = 0;
            putgmac = quoteit = FALSE;
            bufhead = bp;
            addrhead = p;
            continue;
        }

        if (c == ';' && copylev <= 0 && !ColonOkInAddr)
        {
            if (bp < buflim)
                *bp++ = c;
        }

        /* check for characters that may have to be quoted */
        if (strchr(MustQuoteChars, c) != NULL)
        {
            /*
            **  If these occur as the phrase part of a <>
            **  construct, but are not inside of () or already
            **  quoted, they will have to be quoted.  Note that
            **  now (but don't actually do the quoting).
            */

            if (cmtlev <= 0 && !qmode)
                quoteit = TRUE;
        }

        /* check for angle brackets */
        if (c == '<')
        {
            register char *q;

            /* assume first of two angles is bogus */
            if (gotangle)
                quoteit = TRUE;
            gotangle = TRUE;

            /* oops -- have to change our mind */
            anglelev = 1;
            if (!skipping)
                realanglelev = 1;

            bp = bufhead;
            if (quoteit)
            {
                *bp++ = '"';

                /* back up over the '<' and any spaces */
                --p;
                while (isascii((UCHAR)*--p) && isspace((UCHAR)*p))
                    continue;
                p++;
            }
            for (q = addrhead; q < p; )
            {
                c = *q++;
                if (bp < buflim)
                {
                    if (quoteit && c == '"')
                        *bp++ = '\\';
                    *bp++ = c;
                }
            }
            if (quoteit)
            {
                if (bp == &buf[1])
                    bp--;
                else
                    *bp++ = '"';
                while ((c = *p++) != '<')
                {
                    if (bp < buflim)
                        *bp++ = c;
                }
                *bp++ = c;
            }
            copylev = 0;
            putgmac = quoteit = FALSE;
            continue;
        }

        if (c == '>')
        {
            if (anglelev > 0)
            {
                anglelev--;
                if (!skipping)
                {
                    realanglelev--;
                    buflim++;
                }
            }
            else if (!skipping)
            {
                /* syntax error: unmatched > */
                if (copylev > 0)
                    bp--;
                quoteit = TRUE;
                continue;
            }
            if (copylev++ <= 0)
                *bp++ = c;
            continue;
        }

        /* must be a real address character */
    putg:
        if (copylev <= 0 && !putgmac)
        {
            *bp++ = MACROEXPAND;
            *bp++ = 'g';
            putgmac = TRUE;
        }
    }

    /* repair any syntactic damage */
    if (realqmode)
        *bp++ = '"';
    while (realcmtlev-- > 0)
        *bp++ = ')';
    while (realanglelev-- > 0)
        *bp++ = '>';
    *bp++ = '\0';

    if (tTd(33, 1))
        printf("crackaddr=>`%s'\n", buf);

    return (buf);
}
/*
**  PUTHEADER -- put the header part of a message from the in-core copy
**
**    Parameters:
**        mci -- the connection information.
**        h -- the header to put.
**        e -- envelope to use.
**
**    Returns:
**        none.
**
**    Side Effects:
**        none.
*/

/*
 * Macro for fast max (not available in e.g. DG/UX, 386/ix).
 */
#ifndef MAX
# define MAX(a,b) (((a)>(b))?(a):(b))
#endif

void
putheader(mci, h, e)
    register MCI *mci;
    register HDR *h;
    register ENVELOPE *e;
{
    char buf[MAX(MAXLINE,BUFSIZ)];
    char obuf[MAXLINE];

    if (tTd(34, 1))
        printf("--- putheader, mailer = %s ---\n",
            mci->mci_mailer->m_name);

    mci->mci_flags |= MCIF_INHEADER;
    for (; h != NULL; h = h->h_link)
    {
        register char *p = h->h_value;
        extern bool bitintersect();

        if (tTd(34, 11))
        {
            printf("  %s: ", h->h_field);
            xputs(p);
        }

        /* suppress Content-Transfer-Encoding: if we are MIMEing */
        if (bitset(H_CTE, h->h_flags) &&
            bitset(MCIF_CVT8TO7|MCIF_INMIME, mci->mci_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (content-transfer-encoding))\n");
            continue;
        }

        if (bitset(MCIF_INMIME, mci->mci_flags))
            goto vanilla;

        if (bitset(H_CHECK|H_ACHECK, h->h_flags) &&
            !bitintersect(h->h_mflags, mci->mci_mailer->m_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped)\n");
            continue;
        }

        /* handle Resent-... headers specially */
        if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (resent))\n");
            continue;
        }

        /* suppress return receipts if requested */
        if (bitset(H_RECEIPTTO, h->h_flags) &&
            bitset(EF_NORECEIPT, e->e_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (receipt))\n");
            continue;
        }

        /* macro expand value if generated internally */
        if (bitset(H_DEFAULT, h->h_flags))
        {
            expand(p, buf, sizeof buf, e);
            p = buf;
            if (p == NULL || *p == '\0')
            {
                if (tTd(34, 11))
                    printf(" (skipped -- null value)\n");
                continue;
            }
        }

        if (tTd(34, 11))
            printf("\n");

        if (bitset(H_STRIPVAL, h->h_flags))
        {
            /* empty field */
            (void) sprintf(obuf, "%s:", h->h_field);
            putline(obuf, mci);
        }
        else if (bitset(H_FROM|H_RCPT, h->h_flags))
        {
            /* address field */
            bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);

            if (bitset(H_FROM, h->h_flags))
                oldstyle = FALSE;
            commaize(h, p, oldstyle, mci, e);
        }
        else
        {
            /* vanilla header line */
            register char *nlp;

vanilla:
            (void) sprintf(obuf, "%s: ", h->h_field);
            while ((nlp = strchr(p, '\n')) != NULL)
            {
                *nlp = '\0';
                (void) strcat(obuf, p);
                *nlp = '\n';
                putline(obuf, mci);
                p = ++nlp;
                obuf[0] = '\0';
            }
            (void) strcat(obuf, p);
            putline(obuf, mci);
        }
    }

    /*
    **  If we are converting this to a MIME message, add the
    **  MIME headers.
    */

#if MIME8TO7
    if (bitset(MM_MIME8BIT, MimeMode) &&
        bitset(EF_HAS8BIT, e->e_flags) &&
        !bitset(EF_DONT_MIME, e->e_flags) &&
        !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
        !bitset(MCIF_CVT8TO7, mci->mci_flags))
    {
        if (hvalue("MIME-Version", e->e_header) == NULL)
            putline("MIME-Version: 1.0", mci);
        if (hvalue("Content-Type", e->e_header) == NULL)
        {
            sprintf(obuf, "Content-Type: text/plain; charset=%s",
                defcharset(e));
            putline(obuf, mci);
        }
        if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
            putline("Content-Transfer-Encoding: 8bit", mci);
    }
#endif
}
/*
**  COMMAIZE -- output a header field, making a comma-translated list.
**
**    Parameters:
**        h -- the header field to output.
**        p -- the value to put in it.
**        oldstyle -- TRUE if this is an old style header.
**        mci -- the connection information.
**        e -- the envelope containing the message.
**
**    Returns:
**        none.
**
**    Side Effects:
**        outputs "p" to file "fp".
*/

void
commaize(h, p, oldstyle, mci, e)
    register HDR *h;
    register char *p;
    bool oldstyle;
    register MCI *mci;
    register ENVELOPE *e;
{
    register char *obp;
    int opos;
    int omax;
    bool firstone = TRUE;
    char obuf[MAXLINE + 3];

    /*
    **  Output the address list translated by the
    **  mailer and with commas.
    */

    if (tTd(14, 2))
        printf("commaize(%s: %s)\n", h->h_field, p);

    obp = obuf;
    (void) sprintf(obp, "%s: ", h->h_field);
    opos = strlen(h->h_field) + 2;
    obp += opos;
    omax = mci->mci_mailer->m_linelimit - 2;
    if (omax < 0 || omax > 78)
        omax = 78;

    /*
    **  Run through the list of values.
    */

    while (*p != '\0')
    {
        register char *name;
        register int c;
        char savechar;
        int flags;
        auto int stat;

        /*
        **  Find the end of the name.  New style names
        **  end with a comma, old style names end with
        **  a space character.  However, spaces do not
        **  necessarily delimit an old-style name -- at
        **  signs mean keep going.
        */

        /* find end of name */
        while ((isascii((UCHAR)*p) && isspace((UCHAR)*p)) || *p == ',')
            p++;
        name = p;
        for (;;)
        {
            auto char *oldp;
            char pvpbuf[PSBUFSIZE];

            (void) prescan(p, oldstyle ? ' ' : ',', pvpbuf,
                       sizeof pvpbuf, &oldp, NULL);
            p = oldp;

            /* look to see if we have an at sign */
            while (*p != '\0' && isascii((UCHAR)*p) && isspace((UCHAR)*p))
                p++;

            if (*p != '@')
            {
                p = oldp;
                break;
            }
            p += *p == '@' ? 1 : 2;
            while (*p != '\0' && isascii((UCHAR)*p) && isspace((UCHAR)*p))
                p++;
        }
        /* at the end of one complete name */

        /* strip off trailing white space */
        while (p >= name &&
               ((isascii((UCHAR)*p) && isspace((UCHAR)*p)) || *p == ',' || *p == '\0'))
            p--;
        if (++p == name)
            continue;
        savechar = *p;
        *p = '\0';

        /* translate the name to be relative */
        flags = RF_HEADERADDR|RF_ADDDOMAIN;
        if (bitset(H_FROM, h->h_flags))
            flags |= RF_SENDERADDR;
#if USERDB
        else if (e->e_from.q_mailer != NULL &&
             bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
        {
            extern char *udbsender();
            char *q;

            q = udbsender(name);
            if (q != NULL)
                name = q;
        }
#endif
        stat = EX_OK;
        name = remotename(name, mci->mci_mailer, flags, &stat, e);
        if (*name == '\0')
        {
            *p = savechar;
            continue;
        }

        /* output the name with nice formatting */
        opos += strlen(name);
        if (!firstone)
            opos += 2;
        if (opos > omax && !firstone)
        {
            (void) strcpy(obp, ",\n");
            putline(obuf, mci);
            obp = obuf;
            (void) strcpy(obp, "        ");
            opos = strlen(obp);
            obp += opos;
            opos += strlen(name);
        }
        else if (!firstone)
        {
            (void) strcpy(obp, ", ");
            obp += 2;
        }

        while ((c = *name++) != '\0' && obp < &obuf[MAXLINE])
            *obp++ = c;
        firstone = FALSE;
        *p = savechar;
    }
    (void) strcpy(obp, "\n");
    putline(obuf, mci);
}
/*
**  COPYHEADER -- copy header list
**
**    This routine is the equivalent of newstr for header lists
**
**    Parameters:
**        header -- list of header structures to copy.
**
**    Returns:
**        a copy of 'header'.
**
**    Side Effects:
**        none.
*/

HDR *
copyheader(header)
    register HDR *header;
{
    register HDR *newhdr;
    HDR *ret;
    register HDR **tail = &ret;

    while (header != NULL)
    {
        newhdr = (HDR *) xalloc(sizeof(HDR));
        STRUCTCOPY(*header, *newhdr);
        *tail = newhdr;
        tail = &newhdr->h_link;
        header = header->h_link;
    }
    *tail = NULL;

    return ret;
}
#endif*/

//-----------------------------------------------------------------------------
//  Description:
//      Given a header, this function parses it for CRLF<LWSP> sequences
//      unfolds it into a separate buffer, and returns the unfolded line. If
//      the header passed in is not folded, no unfolded line is returned.
//  Arguments:
//      IN CHAR *pszHeader - The folded header. *MUST* be a NULL terminated
//          string.
//      OUT CHAR **ppszUnfolded - If pszValueBuf is not folded, NULL is
//          returned otherwise a new buffer is allocated and pszValueBuf
//          unfolded into the buffer, and the buffer is returned in this
//          parameter. The buffer must be freed with FreeUnfoldedBuffer().
//  Returns:
//      TRUE on success.
//      FALSE on out of memory errors.
//-----------------------------------------------------------------------------
BOOL UnfoldHeader(char *pszHeader, char **ppszUnfolded)
{
    int cbHeader = 0;
    BOOL fUnfold = FALSE;

    *ppszUnfolded = NULL;

    // Check for embedded CRLF<LWSP> AND get length of pszHeader at the same time
    for(cbHeader = 0; pszHeader[cbHeader]; cbHeader++)
    {
        if(!fUnfold &&

           pszHeader[cbHeader] == '\r' &&

           (pszHeader[cbHeader + 1] &&
            pszHeader[cbHeader + 1] == '\n') &&

           (pszHeader[cbHeader + 2] &&
           (pszHeader[cbHeader + 2] == ' ' || pszHeader[cbHeader + 2] == '\t')))

        {
            fUnfold = TRUE;
        }
    }

    if(!fUnfold)
        return TRUE;

    *ppszUnfolded = new char[cbHeader + 1];
    if(!*ppszUnfolded)
        return FALSE;

    //
    // Copy pszHeader to *ppszUnfolded while skipping CRLF<LWSP> sequences
    //

    int i = 0;
    int j = 0;
    while(j < cbHeader)
    {
        if(pszHeader[j] == '\r' && (j+1 < cbHeader && pszHeader[j+1] == '\n'))
        {
            j += 2; // skip the CRLF we found

            while(j < cbHeader && (pszHeader[j] == ' ' || pszHeader[j] == '\t'))
                j++; // skip LWSP

            if(j >= cbHeader)
                break;
        }
        (*ppszUnfolded)[i++] = pszHeader[j++];
    }
    _ASSERT(i < cbHeader);
    (*ppszUnfolded)[i] = '\0';
    return TRUE;
}

void FreeUnfoldedHeader(char *pszHeader)
{
    delete [] pszHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\isrpc.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#include "smtpinc.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <isrpc.hxx>


/************************************************************
 *  Functions
 ************************************************************/


DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls are just noted down in num count.

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;
    Status = RpcServerListen(
                    1,                              // minimum num threads.
                    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
                    TRUE );                         // don't wait

    return( Status );
}


DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    Status = RpcMgmtStopServerListening(0);

    //
    // wait for all RPC threads to go away.
    //

    if( Status == RPC_S_OK) {
        Status = RpcMgmtWaitServerListen();
    }

    return( Status );
}


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{
    //DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);
    SetSecurityDescriptor();

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Created new ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{

    CleanupData();
    Cleanup();    
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Destroyed ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " ISRPC(%08x)::Cleaning up for %s\n",
                   m_pszServiceName));
    }
#endif
    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    //DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()




DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIf(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0    // MgrEpv (Entry Point Vector)
                                      );

        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    //DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }

#if 0
    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::RegisterInterface(%08x)"
                   " returns %ld\n",
                   this, hRpcInterface, dwError));
    }
#endif
    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        //DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
        //_ASSERT( rpcStatus == RPC_S_OK);
        m_fEpRegistered = FALSE;
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);
        //_ASSERT( rpcStatus == RPC_S_OK);
        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
										  );
		//_ASSERT(rpcStatus == RPC_S_OK);
		m_fInterfaceAdded = FALSE;
    }
    return ( rpcStatus);

} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

    fDynamic - Boolean indicating if the call should do dynamic or static
                RPC binding for the protocol specified.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

#ifndef CHICAGO

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK ) {

        if ( Protocol & ISRPC_OVER_TCPIP ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverTcp( TRUE);
        }

        if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

            // Currently we only support static binding
            rpcStatus = BindOverNamedPipe( FALSE);
        }

        if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverSpx( TRUE);
        }
    }

#else // CHICAGO
    rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( Protocol & ISRPC_OVER_NB ) {

        // Currently we only support dynamic binding
        // Ignore status for NB for now
        (VOID)BindOverNetBios(TRUE);
    }
#endif // CHICAGO
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::AddProtocol(%08x) returns %ld.\n",
                   this, Protocol, rpcStatus ));
    }
#endif
    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x)::RemoveProtocol(%s) is not implemented\n",
               this, m_pszServiceName));
    DBG_ASSERT( FALSE);
#endif
    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus = InetinfoStartRpcServerListen();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::StartServer(%s) returns %ld\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = InetinfoStopRpcServerListen();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::StopServer( %s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   //DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }
#if 0
       IF_DEBUG( DLL_RPC) {
           DBGPRINTF(( DBG_CONTEXT, "Binding Handle[%d] = %08x. String = %s\n",
                      i, pBindingVector->BindingH[i], BindingString));
       }
#endif

       //
       // check to we get only our named-pipe endpoint.
       //

       if( strstr( BindingString, "ncacn_np" ) != NULL ) {

           //
           // found a named-pipe binding string.
           //

           if( strstr(BindingString,
                      m_pszServiceName ) == NULL ) {

               //
               // found a non service named-pipe entry.
               // ignore it.
               //

               RpcStringFreeA( (LPBYTE *)&BindingString );

           } else {
#if 0
               IF_DEBUG( DLL_RPC) {
                   DBGPRINTF(( DBG_CONTEXT, "Binding String Chosen = %s\n",
                              BindingString));
               }
#endif
               pBindings->BindingsInfo[dwCount].Length =
                 (strlen(BindingString) + 1) * sizeof(CHAR);
               pBindings->BindingsInfo[dwCount].BindData = BindingString;
               dwCount++;
           }
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;
#if 0
   IF_DEBUG( DLL_RPC) {

       DBGPRINTF(( DBG_CONTEXT, "Binding Vectors chosen"
                  " Service = %s, NumBindings = %d of Total = %d\n",
                  m_pszServiceName, dwCount, pBindingVector->Count));
   }
#endif
 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       //DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;
#if 0
       IF_DEBUG( DLL_RPC) {

           DBGPRINTF(( DBG_CONTEXT,
                      "ISRPC(%08x)::EnumBindingStrings(%s) failed, %ld.",
                      this, m_pszServiceName, dwError ));
       }
#endif
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        //DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (HANDLE)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverTcp(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

#ifdef CHICAGO
DWORD
ISRPC::BindOverNetBios(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NB) == 0);

    if ( !fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    // We will use Dynamic endpoint for the NetBios binding.

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_ipx",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid[ACL_INDEX_ALLOW_ADMIN] );           // security

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_tcp",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid[ACL_INDEX_ALLOW_ADMIN] );           // security

    switch (rpcStatus) {

      case RPC_S_OK:

        //
        // set the protocol bit.
        //

        m_dwProtocols |= ISRPC_OVER_NB;
        break;

      case RPC_S_DUPLICATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is already added for %s\n",
        //           this,
        //           m_pszServiceName));
        rpcStatus = RPC_S_OK;
        break;

      case RPC_S_PROTSEQ_NOT_SUPPORTED:
      case RPC_S_CANT_CREATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is not supported for %s (%ld).\n",
        //           this, m_pszServiceName, rpcStatus ));
        rpcStatus = RPC_S_OK;
        break;

      default:
        break;
    } // switch()

    //
    // if the security support provider is not enabled, do so.
    //

    if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

        rpcStatus = AddSecurity();

    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverNetBios(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverNetBios()
#endif // CHICAGO

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ALL] );          // security
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverSpx(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x). SvcName=%s\n"
               " Protocols = %d.\n"
               " RPC Interface = %08x. Binding Vector = %08x\n"
               " InterfaceAdded = %d.\n"
               " EpRegistered = %d. ServerStarted = %d.\n"
               ,
               this, m_pszServiceName,
               m_dwProtocols,
               m_hRpcInterface, m_pBindingVector,
               m_fInterfaceAdded,
               m_fEpRegistered, m_fServerStarted
               ));
#endif

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid[2];
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the security descriptor
    //

    if (sm_sid[0].Dacl)
        delete [] (BYTE *) (sm_sid[0].Dacl);
    if (sm_sid[1].Dacl)
        delete [] (BYTE *) (sm_sid[1].Dacl);
    
    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is not supported. Error = %ld\n",
            //           rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverTcp() returns %d\n",
                   rpcStatus));
    }
#endif
    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is already added.\n"
            //           ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is not supported. Error (%ld).\n",
            //           rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverSpx() returns %d\n",
                   rpcStatus));
    }
#endif

    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()


//----------------------------------------------------------------
//  Description:
//      Initializes a SECURITY_DESCRIPTOR to allow access to all
//      ("World").
//  Arguments:
//      pSd Pass in a pointer to the SECURITY_DESCRIPTOR
//	  bAdminOnly: TRUE: allow admin, FALSE: allow everyone
//  Returns:
//      ERROR_SUCCESS if initialization proceeded successfully.
//      Win32 error if some failure occurred.
//----------------------------------------------------------------
DWORD InitializeSmtpSecurityDescriptor (PSECURITY_DESCRIPTOR pSd, BOOL bAdminOnly)
{ 
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSidWorld = NULL;
    PSID pSidAdmins = NULL;
    PSID pSid2Allow = NULL;
    SID_IDENTIFIER_AUTHORITY sidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
    ACL *pAcl = NULL;
    DWORD dwAclSize = 0;

    _ASSERT (pSd);

    if (!AllocateAndInitializeSid (
            &sidWorldAuthority,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSidWorld)){

        dwErr = GetLastError ();
        goto Exit;
    }

    if ( !bAdminOnly ) pSid2Allow = pSidWorld;
    else
    {
        if (!AllocateAndInitializeSid( &sidNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,0,0,0,0,0,
                                    &pSidAdmins ) )
        {
            dwErr = GetLastError ();
            goto Exit;
        }
        pSid2Allow = pSidAdmins;
    }
    dwAclSize = sizeof (ACL) +  //  Length of ACL
                (sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)) +    // Length of ACE #1
                GetLengthSid (pSid2Allow) +                          // Length of SID for ACE #1
                (sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD)) +     // Length of ACE #2
                GetLengthSid (pSidWorld);                           // Length of SID for ACE #2

    pAcl = (PACL) new BYTE [dwAclSize]; 
    if (!pAcl) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if (!InitializeAcl (
            pAcl,
            dwAclSize,
            ACL_REVISION)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!AddAccessDeniedAce  (pAcl, ACL_REVISION, WRITE_DAC | WRITE_OWNER, pSidWorld) ||
        !AddAccessAllowedAce (pAcl, ACL_REVISION, GENERIC_ALL, pSid2Allow)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl (pSd, TRUE, pAcl, FALSE)) {
        dwErr = GetLastError ();
        goto Exit;
    }

    pAcl = NULL; // Now pAcl is set on pSd... and will be deleted as pSd->Dacl

Exit:
    if (pSidWorld)
        FreeSid (pSidWorld);
    if (pSidAdmins)
        FreeSid (pSidAdmins);

    if (pAcl)
        delete [] pAcl;

    return dwErr;
}



DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;
    
    if (!InitializeSecurityDescriptor (&sm_sid[0], SECURITY_DESCRIPTOR_REVISION) ||
        !InitializeSecurityDescriptor (&sm_sid[1], SECURITY_DESCRIPTOR_REVISION)) {
        // return directly, don't go to Exit and try to free the Dacl
        return  GetLastError();
    }
    //
    // build a security descriptor that will grant everyone
    // all access to the object --- this is done by setting a
    //  "World" DACL in the SECURITY_DESCRIPTOR.
    //

    dwError = InitializeSmtpSecurityDescriptor(&sm_sid[ACL_INDEX_ALLOW_ALL], false);
    if (dwError!=ERROR_SUCCESS) goto Exit;
    
    dwError = InitializeSmtpSecurityDescriptor(&sm_sid[ACL_INDEX_ALLOW_ADMIN], true);
    if (dwError!=ERROR_SUCCESS) goto Exit;
    

Exit:
	
    if (dwError != ERROR_SUCCESS) {
        //
        // free up security discriptor memory and set it to NULL.
        //
        if (sm_sid[0].Dacl)
            delete [] (BYTE*) sm_sid[0].Dacl;
        if (sm_sid[1].Dacl)
            delete [] (BYTE*) sm_sid[1].Dacl;
        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()




DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "AddSecurity() returns Error %u\n",
                   rpcStatus));
    }
#endif

    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the SMTP Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        JohnL   ????
        MuraliK     11-July-1995 Used Ipc() functions from Inetsvcs.dll

*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "inetsvcs.h"
#include <metacach.hxx>
#include <dbgutil.h>


// ATL Header files
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//
// RPC related includes
//

extern "C" {
#include <inetinfo.h>
#include <smtpsvc.h>
};

#include <smtpinet.h>

extern DWORD g_cMaxConnectionObjs;

BOOL
InitializeSmtpServiceRpc(
                IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL CleanupSmtpServiceRpc(
                 VOID
                 );

//
//  Private constants.
//

BOOL        fAnySecureFilters = FALSE;

//
// for PDC hack
//

#define VIRTUAL_ROOTS_KEY_A     "Virtual Roots"
#define HTTP_EXT_MAPS           "Script Map"
#define SMTP_MODULE_NAME        "smtpsvc"

//
//  Global startup named event
//
DWORD GlobalInitializeStatus = 0;
BOOL g_ServiceBooted = FALSE;

//
//  Private globals.
//

#define INITIALIZE_IPC          0x00000001
#define INITIALIZE_SOCKETS      0x00000002
#define INITIALIZE_ACCESS       0x00000004
#define INITIALIZE_SERVICE      0x00000008
#define INITIALIZE_CONNECTIONS  0x00000010
#define INITIALIZE_DISCOVERY    0x00000020

#define INITIALIZE_RPC          0x00000040
#define INITIALIZE_GLOBALS      0x00000080
#define INITIALIZE_COMMON_DLLS  0x00000100
#define INITIALIZE_ROUTE_SORT   0x00000200
#define INITIALIZE_FIO          0x00000400


DEFINE_TSVC_INFO_INTERFACE();

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

extern VOID SmtpOnConnect( IN SOCKET        sNew,
                  IN SOCKADDR_IN * psockaddr,       //Should be SOCKADDR *
                  IN PVOID         pEndpointContext,
                  IN PVOID         pAtqEndpointObject );

extern VOID
SmtpOnConnectEx(
    VOID *        patqContext,
    DWORD         cbWritten,
    DWORD         err,
    OVERLAPPED *  lpo
    );

VOID
SmtpCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    );

APIERR InitializeService( LPVOID pContext );
APIERR TerminateService( LPVOID pContext );

VOID TerminateInstances( PSMTP_IIS_SERVICE pService);

/************************************************************
 *  Symbolic Constants
 ************************************************************/

static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");

/************************************************************
 *  ATL Module
 ************************************************************/
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

#if 0
/************************************************************
 *  ATL Module
 ************************************************************/
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
#endif


//+---------------------------------------------------------------------------
//
//  Function:
//
//      DllEntryPoint
//
//  Synopsis:
//  Arguments:
//  Returns:
//      See Win32 SDK
//
//  History:
//
//      Richard Kamicar     (rkamicar)              5 January 1996
//
//  Notes:
//
//      If we find we need this per service, we can move it out of here..
//
//----------------------------------------------------------------------------
BOOL WINAPI
DllEntryPoint(HINSTANCE hInst, DWORD dwReason, LPVOID lpvContext)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( SMTP_MODULE_NAME);
        LOAD_DEBUG_FLAGS_FROM_REG_STR("Software\\Microsoft\\Exchange\\SmtpSvc", 0);


        //
        // To help performance, cancel thread attach and detach notifications
        //
        _Module.Init(ObjectMap, hInst);
        DisableThreadLibraryCalls((HMODULE) hInst);
        InitializeCriticalSection( &g_csServiceEntryLock );

        break;

    case DLL_PROCESS_DETACH:

        // Shutdown ATL
        _Module.Term();

#ifdef _NO_TRACING_
        DBG_CLOSE_LOG_FILE();
#endif
        DELETE_DEBUG_PRINT_OBJECT();

         DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

BOOL WINAPI DllMain (HANDLE hInst, ULONG dwReason, LPVOID lpvReserve)
{
  return DllEntryPoint((HINSTANCE) hInst, dwReason, lpvReserve);
}


//
//  Public functions.
//

VOID
ServiceEntry(
    DWORD cArgs,
    LPSTR pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[ServiceEntry] InitCommonDlls failed! Bailing\n" ));

        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    InitAsyncTrace();

    GlobalInitializeStatus |= INITIALIZE_COMMON_DLLS;

    if (!InitializeCache()) goto exit;

    GlobalInitializeStatus |= INITIALIZE_FIO;

    //
    // Initialize Globals
    //

    err = InitializeGlobals();
    if ( err != NO_ERROR )
    {
        goto exit;
    }

    GlobalInitializeStatus |= INITIALIZE_GLOBALS;

    //  Initialize the service status structure.
    //
    g_pInetSvc = new SMTP_IIS_SERVICE(
                                SMTP_SERVICE_NAME_A,
                                SMTP_MODULE_NAME,
                                SMTP_PARAMETERS_KEY,
                                INET_SMTP_SVC_ID,
                                INET_SMTP_SVCLOC_ID,
                                TRUE,
                                0,
                                SmtpOnConnect,
                                SmtpOnConnectEx,
                                SmtpCompletion
                                );



    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed.
    //

   if( ( g_pInetSvc != NULL ) && g_pInetSvc->IsActive() )

    {

       err = ((SMTP_IIS_SERVICE *)g_pInetSvc)->LoadAdvancedQueueingDll();
       if( err != NO_ERROR )
            goto exit;


        fInitSvcObject = TRUE;

        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );




        if ( err )
        {
                //
                //  The event has already been logged
                //

                DBGPRINTF(( DBG_CONTEXT,
                           "SMTP ServiceEntry: StartServiceOperation returned %d\n",
                           err ));
        }
    }
   else if (g_pInetSvc == NULL)
   {
        err = ERROR_NOT_ENOUGH_MEMORY;
   }
   else
   {
        err = g_pInetSvc->QueryCurrentServiceError();
   }

exit:

    if ( g_pInetSvc != NULL )
    {
        g_pInetSvc->CloseService( );
    }

    TerminateGlobals( );

    if( GlobalInitializeStatus & INITIALIZE_FIO)
    {
        TerminateCache();
    }

    if( GlobalInitializeStatus & INITIALIZE_COMMON_DLLS)
    {
        TerminateCommonDlls();
    }


    TermAsyncTrace();

    LeaveCriticalSection( &g_csServiceEntryLock );

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) InitializeGlobals failed, or
    //  3) new operator failed, or
    //  4) SMTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( SMTP_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }

} // ServiceEntry

//
//  Private functions.
//

APIERR
InitializeService(
            LPVOID pContext
            )
/*++

    Routine:
        This function initializes the various SMTP Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err;
    DWORD dwErr = NO_ERROR;
    PSMTP_IIS_SERVICE psi = (PSMTP_IIS_SERVICE)pContext;
    MB      mb( (IMDCOM*) psi->QueryMDObject() );
    STR         TempString;

    char        szTcpipName[MAX_PATH + 1];
    BOOL        bUpdatedDomain;
    BOOL        bUpdatedFQDN;
    HRESULT     hr;

    g_IsShuttingDown = FALSE;

    TraceFunctEnter("InitializeService");

    DBGPRINTF(( DBG_CONTEXT,
                   "initializing Smtp service\n" ));

    SetLastError(NO_ERROR);

    psi->StartHintFunction();

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
           "Cannot CoInitialize, error %lu\n",
            hr ));
        FatalTrace(0,"Cannot CoInitialize, error %d",hr);
//      TraceFunctLeave();
//      return hr;
    }

    g_ProductType = 5;

    psi->StartHintFunction();

    //g_ProductType = 0;

    if ( !mb.Open( "/LM/SMTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeService: Cannot open path %s, error %lu\n",
                    "/LM/SMTPSVC/", GetLastError() ));
        g_pInetSvc->ShutdownService( );
        TraceFunctLeave();
        return ERROR_SERVICE_DISABLED;
    }

    g_ServiceBooted  = TRUE;

    //
    // Initialize the Default Domain, Fully Qualified Domain Name (FQDN) settings.
    // The service will use the default TCP/IP settings in the control panel for these
    // values if the user has never modified the settings.
    //

    DWORD tmp;

    if (!mb.GetDword("", MD_UPDATED_DEFAULT_DOMAIN, IIS_MD_UT_SERVER, &tmp))
    {
        bUpdatedDomain = FALSE;
    }
    else
    {
        bUpdatedDomain = !!tmp;
    }

    if (!mb.GetDword("", MD_UPDATED_FQDN, IIS_MD_UT_SERVER, &tmp))
    {
        bUpdatedFQDN = FALSE;
    }
    else
    {
        bUpdatedFQDN = !!tmp;
    }


    psi->StartHintFunction();

    szTcpipName[0] = '\0';
    lstrcpyn(szTcpipName, g_ComputerName, MAX_PATH);

    //
    // will need to check against TCP/IP settings
    //
    HKEY    hkeyTcpipParam = NULL;
    DWORD   SizeOfBuffer = 0;
    DWORD   cbOffset;
    DWORD   dwType;
    DWORD   err2;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTcpipPath, 0, KEY_QUERY_VALUE, &hkeyTcpipParam) == ERROR_SUCCESS)
    {
        SizeOfBuffer = MAX_PATH;
        err2 = RegQueryValueEx(hkeyTcpipParam, "Hostname", 0, &dwType, (LPBYTE)szTcpipName, &SizeOfBuffer);
        if (err2 != ERROR_SUCCESS || SizeOfBuffer <= 1 || dwType != REG_SZ)
        {
            lstrcpyn(szTcpipName, g_ComputerName, MAX_PATH);
        }
        else
        {
            cbOffset = SizeOfBuffer - 1;
            szTcpipName[cbOffset] = '.';
            SizeOfBuffer = MAX_PATH - (cbOffset);
            err2 = RegQueryValueEx(hkeyTcpipParam, "Domain", 0, &dwType, (LPBYTE)szTcpipName + cbOffset + 1, &SizeOfBuffer);
            if (err2 != ERROR_SUCCESS || SizeOfBuffer <= 1 || dwType != REG_SZ)
            {
                szTcpipName[cbOffset] = '\0';
            }
        }

        _VERIFY(RegCloseKey(hkeyTcpipParam) == ERROR_SUCCESS);
    }


    ((SMTP_IIS_SERVICE *) g_pInetSvc)->SetTcpipName(szTcpipName);


    if (!bUpdatedDomain)
    {
       TempString.Reset();
        if(! mb.GetStr("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty())
        {
            mb.SetString("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
        }

        else
        {
            if (lstrcmpi(szTcpipName,TempString.QueryStr()))
            //
            // no match, update
            //
            {
                mb.SetString("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
            }
        }
    }

    if (!bUpdatedFQDN)
    {
       TempString.Reset();
        if(! mb.GetStr("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty())
        {
            mb.SetString("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
        }

        else
        {
            if (lstrcmpi(szTcpipName,TempString.QueryStr()))
            //
            // no match, update
            //
            {
                mb.SetString("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
            }
        }
    }

    if (!mb.GetDword("", MD_MAX_MAIL_OBJECTS, IIS_MD_UT_SERVER, &g_cMaxConnectionObjs))
    {
        g_cMaxConnectionObjs = 5000;
    }

    mb.Close();

    psi->StartHintFunction();

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

    if( err = psi->InitializeDiscovery( ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "psi->InitializeDiscovery failed, error %lu\n",
                    err ));

        FatalTrace(0,"psi->InitializeDiscovery failed %d\n",err);
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_DISCOVERY;

    if( err = psi->InitializeSockets( ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot initialize service, error %lu\n",
                    err ));

        FatalTrace(0,"psi->InitializeSockets failed %d\n",err);

        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_SOCKETS;

    psi->StartHintFunction();

    if(!InitializeSmtpServiceRpc(SMTP_SERVICE_NAME, smtp_ServerIfHandle))
    {
         err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                   "cannot initialize RPC service, error %lu\n",
                    err ));

        FatalTrace(0,"InitializeSmtpServiceRpc failed %d\n",err);
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_RPC;

    //
    // Reset any Service Principal Names (for Kerberos) that may have been
    // registered
    //

    if (psi->ResetServicePrincipalNames()) {

        DebugTrace(
            0,
            "Unable to reset Kerberos Principal Names %lu, will try later",
            GetLastError());

    }

    //
    // Read and activate all the instances configured
    //

    InitializeInstances( psi );

    //
    //  Success!
    //

    DBGPRINTF(( DBG_CONTEXT, "SMTP Service initialized\n" ));

    TraceFunctLeave();

    return NO_ERROR;

} // InitializeService


APIERR TerminateService(IN LPVOID pContext)
/*++

    Routine:
        This function cleans up the various SMTP Service components.

    Arguments:
        pContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    PSMTP_IIS_SERVICE psi = (PSMTP_IIS_SERVICE)pContext;
    DWORD err;

    TraceFunctEnter("TerminateService");

    if(!g_ServiceBooted)
    {
        ErrorTrace(NULL, "Smtp service not started, returning");
        return NO_ERROR;
    }

    g_ServiceBooted = FALSE ;

    g_IsShuttingDown = TRUE;

    DBG_ASSERT( pContext == g_pInetSvc);

    DBGPRINTF(( DBG_CONTEXT,
                   " SMTP terminating service\n" ));

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //


    //get an exclusive lock on the server.
    //this will wait until all RPCs have
    //exited out of the server and then
    //return

    psi->AcquireServiceExclusiveLock();
    psi->ReleaseServiceExclusiveLock();

    TerminateInstances(psi);

    g_pInetSvc->ShutdownService( );

    if( GlobalInitializeStatus & INITIALIZE_DISCOVERY)
    {
        if ( (err = psi->TerminateDiscovery()) != NO_ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, "TerminateDiscovery() failed. Error = %u\n",
                   err));
        }
    }

    if( GlobalInitializeStatus & INITIALIZE_SOCKETS)
    {
        psi->CleanupSockets( );
    }

    TsFlushMetaCache(METACACHE_SMTP_SERVER_ID,TRUE);

    if( GlobalInitializeStatus & INITIALIZE_RPC)
    {
        CleanupSmtpServiceRpc();
    }

    CoFreeUnusedLibraries();
    CoUninitialize();

    DBGPRINTF(( DBG_CONTEXT,"service terminated\n" ));

    TraceFunctLeave();
    return NO_ERROR;

}  // TerminateService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\wstgado.h $(O)\wstgado_i.c : $(STAXINC)\export\wstgado.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\wstgado_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\wstgado_i.c \
    -header $@ \
    -tlb $(O)\wstagado.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\pe_disp.h $(O)\pe_disp_i.c : $(STAXINC)\export\pe_disp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\pe_disp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\pe_disp_i.c \
    -header $@ \
    -tlb $(O)\pe_disp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpsvc.h $(O)\smtpsvc_s.c : ..\smtpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\smtpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc $(STAXINC)\export\aqerr.mc $(STAXINC)\export\phatqmsg.mc $(STAXINC)\export\caterr.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a smtpmsg.mc + /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\phatqmsg.mc + /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\pe_out.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_out.cxx

   Abstract:

        This module defines the outbound protocol event classes

   Author:

           Keith Lau    (KeithLau)    6/18/98

   Project:

           SMTP Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"

//--------------------------------------------------------------------------------
//  Description:
//      Parses a response from the remote SMTP and appends in in m_cabResponse,
//      setting the numerical status code. Multi-line are also handled by this
//      function.
//
//  Arguments:
//      IN char *InputLine - Start of response to be parsed
//      IN DWORD BufSize - Size of response
//      IN OUT char **NextInputLine - 
//      OUT LPDWORD pRemainingBufSize - 
//      IN DWORD UndecryptedTailSize - If TLS is used, count of undecrypted bytes
//
//  Returns:
//      S_OK if the response was successfully parsed and appended to
//          m_cabResponse and the error code was extracted and set on
//          m_cabResponse. 
//
//      E_INVALIDARG if the response was badly formed and could not be parsed
//          according the to rules specified in the RFC 2821. In this case
//          m_cabResponse is not set, and the connection should be dropped
//          (Note - It should be dropped without issuing QUIT. Trying to be
//          "polite" by gracefully ending the session opens up an unneccessary
//          risk by making us parse further badly formed data).
//
//      Some other error HRESULT if there was some other temporary error.
//--------------------------------------------------------------------------------
HRESULT SMTP_CONNOUT::GetNextResponse(
            char        *InputLine,
            DWORD       BufSize,
            char        **NextInputLine,
            LPDWORD     pRemainingBufSize,
            DWORD       UndecryptedTailSize
            )
{
    HRESULT hr                  = S_OK;
    char    *Buffer             = NULL;
    char    *pszSearch          = NULL;
    BOOL    fFullLine           = FALSE;
    DWORD   IntermediateSize    = 0;
    CHAR    chSave              = 0;

    TraceFunctEnterEx((LPARAM)this,
                "SMTP_CONNOUT::GetNextResponse");

    _ASSERT(InputLine);
    if (!InputLine)
        return(E_POINTER);

    // Start at the beginning
    Buffer = InputLine;

    // We only process full lines (i.e. ends with CRLF)
    while (pszSearch = IsLineComplete(Buffer, BufSize))
    {
        // Calculate the size of the line
        IntermediateSize = (DWORD)((pszSearch - Buffer) + 2); //+2 for CRLF

        //
        // Make sure the response at least contains an error code = 3 digits + CRLF
        // If the response is syntactically invalid we should not fire the response
        // event when this routine returns, which would cause the response handler
        // to try and process potentially bad data. Instead, as soon as it is detected
        // that the response is badly formed, we will drop the connection by returning
        // and error to GlueDispatch.
        //

        if(IntermediateSize < 5 || !isdigit((UCHAR)InputLine[0]) ||
            !isdigit((UCHAR)InputLine[1]) || !isdigit((UCHAR)InputLine[2]))
        {
            // Unparseable response
            chSave = *pszSearch;
            *pszSearch = '\0'; // Null terminate InputLine for ErrorTrace output
            ErrorTrace((LPARAM)this,
                "Cannot parse illegal response from remote SMTP: %s", InputLine);
            *pszSearch = chSave;
            TraceFunctLeaveEx((LPARAM)this);
            return E_INVALIDARG;
        }

        if(IntermediateSize == 5)
        {
            //We have a 250CRLF type response - which according to
            //Drums draft is now legit
            // Get the error code
            Buffer[3] = '\0';
            m_ResponseContext.m_dwSmtpStatus = atoi(Buffer);
            Buffer [3] = CR;
            fFullLine = TRUE;
        }
        else
        {
            // If we encounter a multi-line response, we will keep
            // parsing
            if (Buffer[3] == '-')
            {
                // Try to append the line, this can only fail due
                // to out of memory
                hr = m_ResponseContext.m_cabResponse.Append(
                            Buffer,
                            IntermediateSize,
                            NULL);
                if (FAILED(hr))
                    return(hr);

                // Go to the next line
                Buffer += IntermediateSize;
                BufSize -= IntermediateSize;
                continue;
            }
            if (Buffer[3] == ' ')
            {
                // Get the error code
                Buffer[3] = '\0';
                m_ResponseContext.m_dwSmtpStatus = atoi(Buffer);
                Buffer [3] = ' ';
                fFullLine = TRUE;
            }
            else
            {
                //
                // If the response is syntactically illegal, drop the connection
                // immediately by returning E_INVALIDARG to GlueDispatch. We do
                // not try to further process badly formed data.
                //

                chSave = *pszSearch;
                *pszSearch = '\0'; // Null terminate InputLine for ErrorTrace output
                ErrorTrace((LPARAM)this,
                    "Cannot parse illegal response from remote SMTP: %s", InputLine);
                *pszSearch = chSave;
                TraceFunctLeaveEx((LPARAM)this);
                return E_INVALIDARG;
            }
        }

        // Try to append the line, this can only fail due
        // to out of memory
        hr = m_ResponseContext.m_cabResponse.Append(
                    Buffer,
                    IntermediateSize,
                    NULL);
        if (FAILED(hr))
            return(hr);

        // Adjust the counters
        Buffer += IntermediateSize;
        BufSize -= IntermediateSize;

        // If we have a full response (single or multi-line)
        if (fFullLine)
            break;
    }

    if (fFullLine)
    {
        char    cTerm = '\0';

        // NULL-temrinate it
        hr = m_ResponseContext.m_cabResponse.Append(&cTerm, 1, NULL);
        if (FAILED(hr))
            return(hr);
        else
        {
            // We got a full response. Mark the pointers for
            // the next response
            if (NextInputLine)
                *NextInputLine = Buffer;
            if (pRemainingBufSize)
                *pRemainingBufSize = BufSize;
        }
    }
    else
    {
        // We have either a partial or empty line, either case
        // we need another completion for more data
        hr = S_FALSE;
        MoveMemory((void *)QueryMRcvBuffer(),
                    Buffer,
                    BufSize + UndecryptedTailSize);
        m_cbParsable = BufSize;
        m_cbReceived = BufSize + UndecryptedTailSize;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

HRESULT SMTP_CONNOUT::BuildCommandQEntry(
            LPOUTBOUND_COMMAND_Q_ENTRY  *ppEntry,
            BOOL                        *pfUseNative
            )
{
    // Build a command entry
    DWORD                       dwKeywordLength = 0;
    DWORD                       dwTotalLength = 0;
    LPSTR                       szTemp;
    LPSTR                       pTemp = NULL;
    LPOUTBOUND_COMMAND_Q_ENTRY  pEntry;
    BOOL                        fUseNative = FALSE;

    if (!ppEntry)
        return(E_POINTER);
    *ppEntry = NULL;

    // Determine which response to use
    szTemp = m_OutboundContext.m_cabCommand.Buffer();
    if (!*szTemp)
    {
        szTemp = m_OutboundContext.m_cabNativeCommand.Buffer();
        dwTotalLength = m_OutboundContext.m_cabNativeCommand.Length();
        fUseNative = TRUE;

        // If we have nothing in the buffer, we will return S_FALSE
        if (!*szTemp)
            return(S_FALSE);
    }
    else
        dwTotalLength = m_OutboundContext.m_cabCommand.Length();

    _ASSERT(strlen(szTemp) == dwTotalLength-1);

    // Determine the length of the keyword
    while ((*szTemp != ' ') && (*szTemp != '\0') && (*szTemp != '\r'))
    {
        szTemp++;
        dwKeywordLength++;
    }
    dwKeywordLength++;

    // Determine the total required buffer size
    //NK** add a byte at end to hold the null
    dwTotalLength +=
        (sizeof(OUTBOUND_COMMAND_Q_ENTRY) + dwKeywordLength + 1);

    pTemp = new CHAR [dwTotalLength];
    if (!pTemp)
        return(E_OUTOFMEMORY);

    pEntry = (LPOUTBOUND_COMMAND_Q_ENTRY)pTemp;
    pTemp += sizeof(OUTBOUND_COMMAND_Q_ENTRY);
    pEntry->dwFlags = 0;

    // Set the pipelined flag
    if (m_OutboundContext.m_dwCommandStatus & EXPE_PIPELINED)
        pEntry->dwFlags |= PECQ_PIPELINED;

    // Copy the command keyword
    if (fUseNative)
        szTemp = m_OutboundContext.m_cabNativeCommand.Buffer();
    else
        szTemp = m_OutboundContext.m_cabCommand.Buffer();
    pEntry->pszCommandKeyword = (LPSTR)pTemp;
    if (dwKeywordLength > 1)
    {
        LPSTR   pszTemp = szTemp;
        while (--dwKeywordLength)
            *pTemp++ = (CHAR)tolower(*pszTemp++);
    }
    *pTemp++ = '\0';

    // Copy the full command
    pEntry->pszFullCommand = (LPSTR)pTemp;
    lstrcpy((LPSTR)pTemp, (LPSTR)szTemp);

    *ppEntry = pEntry;
    *pfUseNative = fUseNative;
    return(S_OK);
}


///////////////////////////////////////////////////////////////////
//
//  This function should only be called from GlueDispatch
//
//  It micro-manages sink firing scenarios



HRESULT SMTP_CONNOUT::OnOutboundCommandEvent(
            IUnknown        *pServer,
            IUnknown        *pSession,
            DWORD           dwEventType,
            BOOL            fRepeatLastCommand,
            PMFI            pDefaultOutboundHandler
            )
{
    HRESULT hr = S_OK;
    BOOL    fResult = TRUE;
    BOOL    fFireEvent = TRUE;
    BOOL    fFireDefaultHandler = FALSE;

    ISmtpOutCommandContext  *pContext = (ISmtpOutCommandContext *) &m_OutboundContext;

    // d:\ex\staxpt\src\mail\smtp\server\pe_out.cxx(265) : fatal error C1001: INTERNAL COMPILER ERROR
    //  (compiler file 'E:\utc\src\\P2\main.c', line 379)
    // Please choose the Technical Support command on the Visual C++
    // Help menu, or open the Technical Support help file for more information
    //_ASSERT(pDefaultOutboundHandler);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::OnOutboundCommandEvent");

    // First, we want to make sure that both the command and response
    // dispatchers are not NULL. If they are NULL, then we just call the
    // default handler, if any.
    if (m_pOutboundDispatcher && m_pResponseDispatcher)
    {
        // Now, we take a peek at the bindings and see if we have
        // any sinks installed for this event type
        hr = m_pOutboundDispatcher->SinksInstalled(dwEventType);
        if (hr != S_OK)
        {
            fFireEvent = FALSE;
            DebugTrace((LPARAM)this,
                "There are no sink bindings for this event type");
        }
    }
    else
    {
        fFireEvent = FALSE;
        DebugTrace((LPARAM)this, "Sinks will not be fired because dispatcher NULL");
    }

    // Fire the event accordingly
    // The outbound event is different from the other protocol events
    // For this event, we really don't know when the default handler
    // should be fired. There are two scenarios when we know to fire
    // the default handler:
    //
    // 1) We call the next set of sinks. If the ChainSinks call returns
    //    S_OK and pfFireDefaultHandler returns TRUE, then we will fire
    //    the default handler
    // 2) If we are not able to fire sinks due to a missing dispatcher,
    //    we will fire the default handler (if there is one), and call
    //    it done.

    LPPE_COMMAND_NODE   pCommandNode = NULL;
    LPPE_BINDING_NODE   pBindingNode = NULL;

    if (fFireEvent)
    {
        // Set it up for the dispatcher
        pBindingNode    = NULL;
        pCommandNode    = m_OutboundContext.m_pCurrentCommandContext;

        // Now, if we are asked to repeat the last command, we will have to
        // set up the binding node
        if (fRepeatLastCommand)
        {
            _ASSERT(m_OutboundContext.m_pCurrentCommandContext);
            pBindingNode = m_OutboundContext.m_pCurrentCommandContext->pFirstBinding;
        }

        hr = m_pOutboundDispatcher->ChainSinks(
                    pServer,
                    pSession,
                    m_pIMsg,
                    pContext,
                    dwEventType,
                    &pCommandNode,
                    &pBindingNode
                    );

        // If the event is consumed or if there are no more bindgins
        // left, we will jump to analyze the status codes.
        if ((hr == S_FALSE) || (hr == EXPE_S_CONSUMED))
            goto Analysis;
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            goto Analysis;
        if (FAILED(hr))
            goto Abort;

        // See if we are asked to fire the default handler
        if (pBindingNode)
        {
            // We must have aborted due to default handler, verify this
            // Also verify that we have a default handler ...
            _ASSERT(pBindingNode->dwFlags & PEBN_DEFAULT);
            // The following line results in fatal error C1001: INTERNAL COMPILER ERROR
            //_ASSERT(pDefaultOutboundHandler);

            fFireDefaultHandler = TRUE;
            fResult = (this->*pDefaultOutboundHandler)(NULL, 0, 0);
            if(!fResult)
                m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;

            // Call the dispatcher to process any remaining sinks
            pBindingNode = pBindingNode->pNext;
            if (pBindingNode)
            {
                fFireDefaultHandler = FALSE;
                hr = m_pOutboundDispatcher->ChainSinks(
                            pServer,
                            pSession,
                            m_pIMsg,
                            pContext,
                            dwEventType,
                            &pCommandNode,
                            &pBindingNode
                            );
            }
        }
    }
    else if (pDefaultOutboundHandler)
    {
        // If we already fired the default handler, unless we are
        // asked to repeat, we are plain done
        if (!m_fNativeHandlerFired ||
            fRepeatLastCommand)
        {
            fFireDefaultHandler = TRUE;
            fResult = (this->*pDefaultOutboundHandler)(NULL, 0, 0);
            if(!fResult)
                m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;

            m_fNativeHandlerFired = TRUE;
        }
        else
        {
            // We are done ...
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            m_fNativeHandlerFired = FALSE;
            m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
        }
    }
    else
    {
        // No sinks and no default handler? We're done.
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        m_fNativeHandlerFired = FALSE;
        m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    }

Analysis:

    // Update the context values
    m_OutboundContext.m_pCurrentCommandContext = pCommandNode;
    m_OutboundContext.m_pCurrentBinding = pBindingNode;

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        // Reset the context values
        _ASSERT(!m_OutboundContext.m_pCurrentCommandContext);
        _ASSERT(!m_OutboundContext.m_pCurrentBinding);

        m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    }
    else
    {
        // If we don't have a status code, something is wrong. We will
        // assert in debug and drop the connection in reality.
        //
        // This is possible when misbehaving high-priority sinks consume
        // the event without setting the status code.
        if (m_OutboundContext.m_dwCommandStatus == EXPE_UNHANDLED)
        {
            ErrorTrace((LPARAM)this, "The outbound status code is undefined!");
            m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;
        }
    }

Abort:

    // Set a diagnostic if a sink caused the connection to be dropped
    if(!fFireDefaultHandler && m_OutboundContext.m_dwCommandStatus == EXPE_DROP_SESSION)
    {
        CHAR szCommand[128] = "";
        CHAR *pszCommand = szCommand;
        DWORD cbCommand = sizeof(szCommand);

        if(FAILED(m_OutboundContext.QueryCommandKeyword(szCommand, &cbCommand)))
            pszCommand = NULL;

        SetDiagnosticInfo(
            AQUEUE_E_SINK_DROPPED_CONNECTION,
            pszCommand,
            NULL);
    }


    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


HRESULT SMTP_CONNOUT::OnServerResponseEvent(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            PMFI                        pDefaultResponseHandler
            )
{
    HRESULT hr = S_OK;
    BOOL    fResult = TRUE;
    BOOL    fFireEvent = TRUE;
    BOOL    fFireDefaultHandler = FALSE;

    LPPE_COMMAND_NODE   pCommandNode = NULL;
    LPPE_BINDING_NODE   pBindingNode = NULL;

    ISmtpServerResponseContext  *pContext = (ISmtpServerResponseContext *) &m_ResponseContext;

    _ASSERT(m_ResponseContext.m_pCommand);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::OnServerResponseEvent");

    // First, we want to make sure that both the command and response
    // dispatchers are not NULL. If they are NULL, then we just call the
    // default handler, if any.
    if (m_pOutboundDispatcher && m_pResponseDispatcher)
    {
        // Now, we take a peek at the bindings and see if we have
        // any sinks installed for this command
        hr = m_pResponseDispatcher->SinksInstalled(
                    m_ResponseContext.m_pCommand->pszCommandKeyword,
                    &pCommandNode);
        if (hr != S_OK)
        {
            fFireEvent = FALSE;
            DebugTrace((LPARAM)this,
                "There are no sink bindings for this command");
        }
    }
    else
    {
        fFireEvent = FALSE;
        DebugTrace((LPARAM)this, "Sinks will not be fired because dispatcher NULL");
    }

    if (fFireEvent)
    {
        _ASSERT(pCommandNode);
        pBindingNode = pCommandNode->pFirstBinding;
        _ASSERT(pBindingNode);
    }

    // Fire the event accordingly
    hr = S_OK;
    if (pDefaultResponseHandler)
    {
        DebugTrace((LPARAM)this, "Calling sinks for native command <%s>",
                    m_ResponseContext.m_pCommand->pszCommandKeyword);
        if (fFireEvent)
        {
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_DEFAULT,
                        pCommandNode,
                        &pBindingNode
                        );
            if ((hr == S_FALSE) || (hr == EXPE_S_CONSUMED))
                goto Analysis;
            if (FAILED(hr))
                goto Abort;
        }

        fFireDefaultHandler = TRUE;
        fResult = (this->*pDefaultResponseHandler)(
                    m_ResponseContext.m_cabResponse.Buffer(),
                    m_ResponseContext.m_cabResponse.Length(),
                    0);
        if(!fResult)
            m_ResponseContext.m_dwResponseStatus = EXPE_DROP_SESSION;

        if (fFireEvent && pBindingNode)
            fFireDefaultHandler = FALSE;
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_LOWEST,
                        pCommandNode,
                        &pBindingNode
                        );
    }
    else
    {
        DebugTrace((LPARAM)this, "Calling sinks for non-native command <%s>",
                    m_ResponseContext.m_pCommand->pszCommandKeyword);
        if (fFireEvent)
        {
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_LOWEST,
                        pCommandNode,
                        &pBindingNode
                        );

            // Fall back to "*" sinks
            if ((hr == S_OK) &&
                (m_ResponseContext.m_dwResponseStatus == EXPE_UNHANDLED))
            {
                hr = m_pResponseDispatcher->SinksInstalled(
                            "*",
                            &pCommandNode);
                if (hr == S_OK)
                {
                    _ASSERT(pCommandNode);
                    pBindingNode = pCommandNode->pFirstBinding;
                    _ASSERT(pBindingNode);
                    hr = m_pResponseDispatcher->ChainSinks(
                                pServer,
                                pSession,
                                m_pIMsg,
                                pContext,
                                PRIO_LOWEST,
                                pCommandNode,
                                &pBindingNode
                                );
                }
                else
                    hr = S_OK;
            }
        }
    }

Analysis:

    // If no sinks has handled the response, we will invoke
    // a default handler. This will fail and drop the connection if
    // the SMTP response code is anything other than a complete success.
    if (m_ResponseContext.m_dwResponseStatus == EXPE_UNHANDLED)
    {
        if (!IsSmtpCompleteSuccess(m_ResponseContext.m_dwSmtpStatus))
            m_ResponseContext.m_dwResponseStatus = EXPE_DROP_SESSION;
        else
            m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;
        hr = S_OK;
    }

Abort:

    // Set a diagnostic if a sink caused the connection to be dropped
    if(!fFireDefaultHandler && m_ResponseContext.m_dwResponseStatus == EXPE_DROP_SESSION)
    {
        CHAR szCommand[128] = "";
        CHAR *pszCommand = szCommand;
        DWORD cbCommand = sizeof(szCommand);

        if(FAILED(m_ResponseContext.QueryCommandKeyword(szCommand, &cbCommand)))
            pszCommand = NULL;

        SetDiagnosticInfo(
            AQUEUE_E_SINK_DROPPED_CONNECTION,
            pszCommand,
            NULL);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


#define MAX_OUTSTANDING_COMMANDS    500

BOOL SMTP_CONNOUT::GlueDispatch(
            const char  *InputLine,
            DWORD       ParameterSize,
            DWORD       UndecryptedTailSize,
            DWORD       dwOutboundEventType,
            PMFI        pDefaultOutboundHandler,
            PMFI        pDefaultResponseHandler,
            LPSTR       szDefaultResponseHandlerKeyword,
            BOOL        *pfDoneWithEvent,
            BOOL        *pfAbortEvent
            )
{
    HRESULT hr;
    BOOL    fResult = TRUE;
    BOOL    fRepeatLastCommand = FALSE;
    BOOL    fSendBinaryBlob = FALSE;
    DWORD   dwBuffer = 0;
    BOOL    fStateChange = FALSE;
    BOOL    fResponsesHandled = FALSE;
    PMFI    pfnNextState = NULL;
    char    chErrorPrefix = SMTP_COMPLETE_SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GlueDispatch");

    _ASSERT(m_pInstance);
    _ASSERT(m_pIEventRouter);

    m_ResponseContext.m_pCommand = NULL;

    // Check args.
    if (!InputLine || !pfDoneWithEvent || !pfAbortEvent ||
        !m_pInstance || !m_pIEventRouter)
    {
        ErrorTrace((LPARAM) this, "NULL Pointer");
        TraceFunctLeaveEx((LPARAM)this);
        SetLastError(E_POINTER);
        return(FALSE);
    }
    if (dwOutboundEventType >= PE_OET_INVALID_EVENT_TYPE)
    {
        ErrorTrace((LPARAM) this,
                "Skipping event because of bad outbound event type");
        TraceFunctLeaveEx((LPARAM)this);
        return(TRUE);
    }

    // By default we are still going
    *pfDoneWithEvent = FALSE;
    *pfAbortEvent = FALSE;

    // Get the dispatcher if we don't already have it ...
    if (!m_pOutboundDispatcher)
    {
        hr = m_pIEventRouter->GetDispatcherByClassFactory(
                    CLSID_COutboundDispatcher,
                    &g_cfOutbound,
                    *(COutboundDispatcher::s_rgrguidEventTypes[dwOutboundEventType]),
                    IID_ISmtpOutboundCommandDispatcher,
                    (IUnknown **)&m_pOutboundDispatcher);
        if(!SUCCEEDED(hr))
        {
            // If we fail, we will not fire protocol events
            m_pOutboundDispatcher = NULL;
            ErrorTrace((LPARAM) this,
                "Unable to get outbound dispatcher from router (%08x)", hr);
        }
    }

    //
    // We make sure we will not send out new commands until all our
    // queued commands' responses are received and processed.
    //
    if (InputLine)
    {
        // Handle responses first, followed by generating commands
        char    *pResponses = (char *)InputLine;
        DWORD   dwRemaining = ParameterSize;

        while (!m_FifoQ.IsEmpty())
        {
            // Parse out the next response
            hr = GetNextResponse(
                        pResponses,
                        dwRemaining,
                        &pResponses,
                        &dwRemaining,
                        UndecryptedTailSize);
            if (hr == S_OK)
            {
                //
                // jstamerj 1998/10/30 12:37:28:
                //   Set the correct next state in the response context
                //
                m_ResponseContext.m_dwNextState = CResponseDispatcher::PeStateFromOutboundEventType((OUTBOUND_EVENT_TYPES)dwOutboundEventType);

                // We have a full response, now dequeue the corresponding
                // command entry
                m_ResponseContext.m_pCommand = (LPOUTBOUND_COMMAND_Q_ENTRY)m_FifoQ.Dequeue();

                // This should not be NULL at any time!
                _ASSERT(m_ResponseContext.m_pCommand);

                DebugTrace((LPARAM)this, "Processing Response <%s> for <%s>",
                            m_ResponseContext.m_cabResponse.Buffer(),
                            m_ResponseContext.m_pCommand->pszFullCommand);

                // All except for the last item in the queue must be pipelined
                if (!m_FifoQ.IsEmpty())
                {
                    _ASSERT((m_ResponseContext.m_pCommand->dwFlags & PECQ_PIPELINED) != 0);
                }

                // Call the event handler
                hr = OnServerResponseEvent(
                            m_pInstance->GetInstancePropertyBag(),
                            GetSessionPropertyBag(),
                            (strcmp(m_ResponseContext.m_pCommand->pszCommandKeyword,
                                szDefaultResponseHandlerKeyword) == 0)?
                                pDefaultResponseHandler:
                                NULL
                            );

                // We will ignore all responses to commands that are
                // pipelined. If the command that caused this response is
                // not pipelined, it will fall through this loop and be
                // handled downstream.
                fResponsesHandled = TRUE;

                // Delete the command entry ...
                LPBYTE  pTemp = (LPBYTE)m_ResponseContext.m_pCommand;
                delete [] pTemp;

                pTemp = NULL;
                //Check if we really want to continue
                if( m_ResponseContext.m_dwResponseStatus == EXPE_TRANSIENT_FAILURE ||
                     m_ResponseContext.m_dwResponseStatus == EXPE_COMPLETE_FAILURE )
                {
                    //Free up the command list
                    while(pTemp = (LPBYTE)m_FifoQ.Dequeue())
                    {
                        delete [] pTemp;
                        pTemp = NULL;
                    }
                    //break out of the command loop
                    break;
                }

                // We are done with this response, and the FIFO is not empty,
                // we will reset the context
                if (!m_FifoQ.IsEmpty())
                    m_ResponseContext.ResetResponseContext();
            }
            else if (hr == S_FALSE)
            {
                // This means that the whole buffer received is not long enough
                // to hold the next response. We will wait for the remainder.
                // This might take several completions if needed.
                // Make sure we don't reset the response context at this point
                // or we will lose the previous buffer.
                break;
            }
            else if (hr == E_INVALIDARG)
            {
                //
                // Syntactically invalid response from other side. We will NDR
                // message and end the session. We set the following on the response
                // context so that SMTP_CONNOUT::DoCompletedMessage knows what to
                // do:
                //
                // - m_cabReponse is set to some string indicating what error
                //      occurred. This should really be the actual response from
                //      the server, but since that is garbage we put in something
                //      that conforms to SMTP syntax. This is for our benefit only,
                //      since the m_cabResponse is parsed by many internal functions.
                //      We want those functions to see only syntactically validated
                //      strings, and weed out all errors here.
                //
                // - m_dwSmtpStatus = SMTP_SERVICE_CLOSE_CODE
                //      To indicate that the connection should be closed and that
                //      we shouldn't try to deliver any more messages on this
                //      connection. There is no *correct* error code here, so we
                //      have to pick some reasonable error code.
                //
                // - m_dwReponseStatus = EXPE_COMPLETE_FAILURE to indicate that the
                //      all messages on this connection must be NDR'ed.
                //

                // Delete the command entry
                LPBYTE  pTemp = (LPBYTE)m_ResponseContext.m_pCommand;
                delete [] pTemp;

                // Free up the command list
                while(pTemp = (LPBYTE)m_FifoQ.Dequeue())
                {
                    delete [] pTemp;
                    pTemp = NULL;
                }

                m_ResponseContext.ResetResponseContext();

#define SMTP_INVALID_SYTAX_ERROR "500 Non RFC-compliant response received"

                hr = m_ResponseContext.m_cabResponse.Append(
                                        SMTP_INVALID_SYTAX_ERROR,
                                        sizeof(SMTP_INVALID_SYTAX_ERROR),
                                        NULL);

                if(FAILED(hr))
                {   // Out of memory. Nothing more we can do - drop connection abruptly
                    TraceFunctLeaveEx((LPARAM)this);
                    return FALSE;
                }

                m_ResponseContext.m_dwResponseStatus = EXPE_COMPLETE_FAILURE;
                m_ResponseContext.m_dwSmtpStatus = SMTP_SERVICE_CLOSE_CODE;
                m_OutboundContext.m_pCurrentCommandContext = NULL;
                ErrorTrace((LPARAM)this, "Syntax error in response. Message"
                        " will be NDR'ed");
                fResponsesHandled = TRUE;
                break;
            }
            else
            {
                // Some temporary error, such as out-of-memory.
                ErrorTrace((LPARAM)this, "Failed to GetNextResponse (%08x)", hr);
                return FALSE;
            }
            
        }
    }

    // If we have exhausted all responses and still our command queue
    // is not empty, we need to pend another read for more responses
    if (!m_FifoQ.IsEmpty())
    {
        DebugTrace((LPARAM)this, "Pending a read for more response data");
        TraceFunctLeaveEx((LPARAM)this);
        return(TRUE);
    }

    // Okay, we are now done all queued responses. Before we send out more
    // commands, we want to check if a sink wanted to change the state. If
    // so, we will honor this state change ...
    if (fResponsesHandled)
    {
        switch (m_ResponseContext.m_dwResponseStatus)
        {
        case EXPE_SUCCESS:
            break;

        case EXPE_TRANSIENT_FAILURE:
            chErrorPrefix = SMTP_TRANSIENT_FAILURE;
            pfnNextState = DoCompletedMessage;
            fStateChange = TRUE;
            break;

        case EXPE_COMPLETE_FAILURE:
            chErrorPrefix = SMTP_COMPLETE_FAILURE;
            pfnNextState = DoCompletedMessage;
            fStateChange = TRUE;
            break;

        case EXPE_REPEAT_COMMAND:
            fRepeatLastCommand = TRUE;
            break;

        case EXPE_DROP_SESSION:
            DisconnectClient();
            *pfDoneWithEvent = TRUE;
            *pfAbortEvent = TRUE;
            fResult = FALSE;
            break;

        case EXPE_CHANGE_STATE:
            // Figure out which state pointer to jump to
            switch (m_ResponseContext.m_dwNextState)
            {
            case PE_STATE_SESSION_START:
                pfnNextState = DoSessionStartEvent;
                break;
            case PE_STATE_MESSAGE_START:
                pfnNextState = DoMessageStartEvent;
                break;
            case PE_STATE_PER_RECIPIENT:
                pfnNextState = DoPerRecipientEvent;
                break;
            case PE_STATE_DATA_OR_BDAT:
                pfnNextState = DoBeforeDataEvent;
                break;
            case PE_STATE_SESSION_END:
                pfnNextState = DoSessionEndEvent;
                break;
            default:
                ErrorTrace((LPARAM)this,
                            "Bad next state %u, ignoring ...",
                            m_ResponseContext.m_dwNextState);
            }
            if (pfnNextState)
            {
                *pfDoneWithEvent = TRUE;
                fStateChange = TRUE;
            }
            break;

        case EXPE_UNHANDLED:
            _ASSERT(FALSE);
            break;

        default:
            _ASSERT(FALSE);
        }
    }

    // OK, now we are clear to send the next command ...
    // If the result is already FALSE, we are going to disconnect. Then there
    // is no point generating more commands ...
    //
    // Also, if we are returning from some other state, we just leave
    if (fResult && !fStateChange)
    {
        //NK** : I moved this from outside if to inside. Need to do this to preserve the response in cases where we hit
        //TRANSIENT or permanent errorn
        // Reset the response context
        m_ResponseContext.ResetResponseContext();

        //we need to save the first pipelined address so we can
        //start at this address and check the replies
        m_FirstPipelinedAddress = m_NextAddress;

        do
        {
            BOOL    fUseNative = FALSE;

            // Reset the context
            m_OutboundContext.ResetOutboundContext();

            // Catch here: set what the next address is so that other
            // sinks can at least have a clue who the current recipient is.
            //
            // jstamerj 1998/10/22 17:26:54: Sinks are really
            // interested in the recipient index in the mailmsg, not
            // the index into our private array.  Give them that
            // instead.
            //
            if((dwOutboundEventType == PE_OET_PER_RECIPIENT) &&
               (m_NextAddress < m_NumRcpts))
                m_OutboundContext.m_dwCurrentRecipient = m_RcptIndexList[m_NextAddress];

            // Raise the outbound event ...
            hr = OnOutboundCommandEvent(
                        m_pInstance->GetInstancePropertyBag(),
                        GetSessionPropertyBag(),
                        dwOutboundEventType,
                        fRepeatLastCommand,
                        pDefaultOutboundHandler);
            fRepeatLastCommand = FALSE;

            // See if we are done with this event type
            if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                DebugTrace((LPARAM)this, "Done processing this event, leaving ...");
                *pfDoneWithEvent = TRUE;
                break;
            }

            // See if the last command should be repeated
            if ((m_OutboundContext.m_dwCommandStatus != EXPE_UNHANDLED) &&
                (m_OutboundContext.m_dwCommandStatus & EXPE_REPEAT_COMMAND))
                fRepeatLastCommand = TRUE;

            // See if we're sending blob rather then the command
            if ((m_OutboundContext.m_dwCommandStatus != EXPE_UNHANDLED) &&
                (m_OutboundContext.m_dwCommandStatus & EXPE_BLOB_READY))
                fSendBinaryBlob = TRUE;

            // Handle the status codes, minus the repeat flag ...
            switch (m_OutboundContext.m_dwCommandStatus & (~EXPE_REPEAT_COMMAND) & (~EXPE_BLOB_READY))
            {
            case EXPE_PIPELINED:

                // If the remote server does not support pipelineing,
                // we will honor that.
                if(!IsOptionSet(PIPELINE_OPTION) || !m_pInstance->ShouldPipeLineOut())
                    m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                // Fall Thru ...

            case EXPE_SUCCESS:
                {
                    LPOUTBOUND_COMMAND_Q_ENTRY  pEntry = NULL;
                    LPSTR                       pBuffer;

                    // Build the entry
                    hr = BuildCommandQEntry(&pEntry, &fUseNative);
                    if (FAILED(hr))
                    {
                        chErrorPrefix = SMTP_TRANSIENT_FAILURE;
                        pfnNextState = DoCompletedMessage;
                        fStateChange = TRUE;
                        break;
                    }

                    if (hr == S_OK)
                    {
                        // Push the command into the FIFO queue
                        if (!m_FifoQ.Enqueue((LPVOID)pEntry))
                        {
                            // Since pEntry is never NULL here, we will always succeed
                            _ASSERT(FALSE);
                        }

                        // Write out the command to the real buffer
                        // If the buffer is not big enough, this will write and
                        // flush multiple times until the command is sent
                        pBuffer = (fUseNative)?
                                m_OutboundContext.m_cabNativeCommand.Buffer():
                                m_OutboundContext.m_cabCommand.Buffer();

                        if ( fSendBinaryBlob) {
                            FormatBinaryBlob( m_OutboundContext.m_pbBlob, m_OutboundContext.m_cbBlob);
                        } else {
                            //FormatSmtpMessage will use the first string
                            //as a format string.  Since we obviously have no
                            //arguments, any %'s in pBuffer will cause sprintf
                            //to AV. We must force FormatSmtpMessage to not use
                            //pBuffer as a format string.
                            FormatSmtpMessage(FSM_LOG_ALL, "%s", pBuffer);
                        }
                    }
                }
                break;

            case EXPE_TRANSIENT_FAILURE:
                chErrorPrefix = SMTP_TRANSIENT_FAILURE;
                pfnNextState = DoCompletedMessage;
                fStateChange = TRUE;
                break;

            case EXPE_COMPLETE_FAILURE:
                chErrorPrefix = SMTP_COMPLETE_FAILURE;
                pfnNextState = DoCompletedMessage;
                fStateChange = TRUE;
                break;

            case EXPE_DROP_SESSION:
                DisconnectClient();
                *pfAbortEvent = TRUE;
                *pfDoneWithEvent = TRUE;
                fResult = FALSE;
                break;

            case EXPE_UNHANDLED:
            default:
                DisconnectClient();
                *pfAbortEvent = TRUE;
                *pfDoneWithEvent = TRUE;
                fResult = FALSE;
            }

        } while (m_FifoQ.IsEmpty() ||
                 ((m_OutboundContext.m_dwCommandStatus & EXPE_PIPELINED) &&
                     m_FifoQ.Length() < MAX_OUTSTANDING_COMMANDS));

        // OK, we can flush these commands ...
        fResult = SendSmtpResponse();
    }

    // Make sure we free the outbound dispatcher before
    // exiting or jumping states.
    if (*pfDoneWithEvent || fStateChange)
    {
        if(fStateChange)
            m_fNativeHandlerFired = FALSE;

        // Release the dispatcher
        if (m_pOutboundDispatcher)
        {
            m_pOutboundDispatcher->Release();
            m_pOutboundDispatcher = NULL;
        }

        if (pfnNextState)
        {
            // Call the next state handler
            *pfDoneWithEvent = TRUE;
            *pfAbortEvent = TRUE;
            //
            // jstamerj 1998/11/01 18:51:01: Since we're jumping to
            // another state, reset the variable that keeps track
            // of which command we're firing.
            //
            m_OutboundContext.m_pCurrentCommandContext = NULL;

            DebugTrace((LPARAM)this, "Jumping to another state");
            fResult = (this->*pfnNextState)(&chErrorPrefix, 1, 0);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoSessionStartEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoSessionStartEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoSessionStartEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_SESSION_START,
                &SMTP_CONNOUT::DoEHLOCommand,
                &SMTP_CONNOUT::DoEHLOResponse,
                m_HeloSent?"helo":"ehlo",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        if (m_TlsState == MUST_DO_TLS)
        {
            SetNextState(&SMTP_CONNOUT::DoSTARTTLSCommand);
            fResult = DoSTARTTLSCommand(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else if (m_MsgOptions & KNOWN_AUTH_FLAGS)
        {
            fResult = DoSASLCommand(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else if (m_MsgOptions & EMPTY_CONNECTION_OPTION)
        {
            fResult = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else
        {
            fResult = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoMessageStartEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoMessageStartEvent");

    //send an ETRN request if it defined
    // The ETRN respond will eventually come back to this state
    // again but with the ETRN_SENT option set so it's like a small loop
    if((m_MsgOptions & DOMAIN_INFO_SEND_ETRN) && IsOptionSet(ETRN_OPTION)
        && !IsOptionSet(ETRN_SENT))
    {
        return DoETRNCommand();
    }

    // check to see if this is an empty turn command
    // we need to go back to startsession to issue the TURN
//    if ((m_pIMsg == NULL) && (m_MsgOptions & DOMAIN_INFO_SEND_TURN)) {
    if (m_Flags & TURN_ONLY_OPTION) {
        _ASSERT((m_pIMsg == NULL) && (m_MsgOptions & DOMAIN_INFO_SEND_TURN));
        return StartSession();
    }

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoMessageStartEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_MESSAGE_START,
                &SMTP_CONNOUT::DoMAILCommand,
                &SMTP_CONNOUT::DoMAILResponse,
                "mail",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        //m_NextAddress = 0;
        fResult = DoPerRecipientEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    return(fResult);
}

BOOL SMTP_CONNOUT::DoPerRecipientEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoPerRecipientEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoPerRecipientEvent);

    DebugTrace((LPARAM)this,
                "Processing recipient index %u",
                m_NextAddress);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_PER_RECIPIENT,
                &SMTP_CONNOUT::DoRCPTCommand,
                &SMTP_CONNOUT::DoRCPTResponse,
                "rcpt",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        if(m_NumFailedAddrs >= m_NumRcptSentSaved)
        {
            TraceFunctLeaveEx((LPARAM)this);
            SetNextState (&SMTP_CONNOUT::WaitForRSETResponse);
            if(m_NumRcptSentSaved)
                m_RsetReasonCode = ALL_RCPTS_FAILED;
            else
                m_RsetReasonCode = NO_RCPTS_SENT;
            return DoRSETCommand(NULL, 0, 0);
        }

        // OK, fire the "before data" event
        fResult = DoBeforeDataEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    return(fResult);
}

BOOL SMTP_CONNOUT::DoBeforeDataEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoBeforeDataEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoBeforeDataEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_BEFORE_DATA,
                NULL,
                NULL,
                "",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        if (m_fUseBDAT)
            fResult = DoBDATCommand(InputLine, ParameterSize, UndecryptedTailSize);
        else
            fResult = DoDATACommand(InputLine, ParameterSize, UndecryptedTailSize);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoSessionEndEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoSessionEndEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoSessionEndEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_SESSION_END,
                &SMTP_CONNOUT::DoQUITCommand,
                &SMTP_CONNOUT::WaitForQuitResponse,
                "quit",
                &fDoneEvent,
                &fAbortEvent);

    // Either way we cut it, if we are done, we will delete the connection
    if (fDoneEvent)
        fResult = FALSE;

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\pe_dispi.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_dispi.cxx

   Abstract:

        This module provides the implementation for the protocol
        event dispatchers

   Author:

           Keith Lau    (KeithLau)    6/24/98

   Project:

           SMTP Server DLL

   Revision History:

            KeithLau            Created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "initguid.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include <smtpguid.h>

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"


// =================================================================
// Outbound command generation dispatcher
//

//
// These are the commands that the default handlers hook
//
char *COutboundDispatcher::s_rgszDefaultCommand[PE_STATE_MAX_STATES] =
{
    "ehlo",
    "mail",
    "rcpt",
    NULL,
    "quit"
};

//
// This is what we use to map an event type to an internal index
//
const GUID *COutboundDispatcher::s_rgrguidEventTypes[PE_STATE_MAX_STATES] =
{
    &CATID_SMTP_ON_SESSION_START,
    &CATID_SMTP_ON_MESSAGE_START,
    &CATID_SMTP_ON_PER_RECIPIENT,
    &CATID_SMTP_ON_BEFORE_DATA,
    &CATID_SMTP_ON_SESSION_END
};

//
// Generic dispatcher methods
//
HRESULT CGenericProtoclEventDispatcher::GetLowerAnsiStringFromVariant(
            CComVariant &vString,
            LPSTR       pszString,
            DWORD       *pdwLength
            )
{
    HRESULT hr = S_OK;
    DWORD   dwInLength;

    if (!pszString)
        return(E_POINTER);
    if (!pdwLength)
        return(E_INVALIDARG);

    // Default to NULL
    *pszString = NULL;

    if (vString.vt == VT_BSTR)
    {
        DWORD dwLength = lstrlenW(vString.bstrVal) + 1;

        // Set the size anyway
        dwInLength = *pdwLength;
        *pdwLength = dwLength;

        if (dwLength > dwInLength)
            return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        // copy the rule into an ascii string
        if (WideCharToMultiByte(CP_ACP, 0, vString.bstrVal,
                                -1, pszString, dwLength, NULL, NULL) <= 0)
            return(HRESULT_FROM_WIN32(GetLastError()));

        // Convert to lower case once and for all to avoid strcmpi
        while (*pszString)
        {
            *pszString = (CHAR)tolower(*pszString);
            pszString++;
        }
    }
    else
        hr = E_INVALIDARG;
    return(hr);
}

HRESULT CGenericProtoclEventDispatcher::InsertBinding(
            LPPE_COMMAND_NODE   *ppHeadNode,
            LPPE_BINDING_NODE   pBinding,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize
            )
{
    DWORD                   dwPriority;
    BOOL                    fReorder = FALSE;
    LPPE_COMMAND_NODE       pNode;

    TraceFunctEnter("CGenericProtoclEventDispatcher::InsertBinding");

    if (!ppHeadNode || !pBinding || !pszCommandKeyword)
        return(E_POINTER);

    pNode = *ppHeadNode;
    while (pNode)
    {
        // All strings come in lower case
        if (!strcmp(pszCommandKeyword, pNode->pszCommandKeyword))
        {
            DebugTrace((LPARAM)0, "Found command %s", pszCommandKeyword);

            // Now we determine if we have changed the max priority
            // if we increased the priority (i.e. lower value), then
            // we will have to reposition out node
            dwPriority = pBinding->dwPriority;
            if (pBinding->dwPriority < dwPriority)
            {
                pBinding->dwPriority = dwPriority;
                fReorder = TRUE;
                DebugTrace((LPARAM)0, "Reordering commands");
            }

            // Now insert the binding in the right order
            LPPE_BINDING_NODE   pWalk = pNode->pFirstBinding;
            LPPE_BINDING_NODE   pPrev = (LPPE_BINDING_NODE)&(pNode->pFirstBinding);
            if (!pWalk)
            {
                pBinding->pNext = pNode->pFirstBinding;
                pNode->pFirstBinding = pBinding;
            }
            else while (pWalk)
            {
                if (pWalk->dwPriority > dwPriority)
                    break;
                pPrev = pWalk;
                pWalk = pWalk->pNext;
            }
            pBinding->pNext = pWalk;
            pPrev->pNext = pBinding;

            if (!fReorder)
                return(S_OK);
            else
                break;
        }

        // Next!
        pNode = pNode->pNext;
    }

    if (!fReorder)
    {
        char    *pTemp;
        DWORD   dwSize = sizeof(PE_COMMAND_NODE);

        // Not found, create a new command node, plus a buffer
        // for the command keyword
        dwSize += dwCommandKeywordSize;
        pTemp = new char [dwSize];
        if (!pTemp)
            return(E_OUTOFMEMORY);

        pNode = (LPPE_COMMAND_NODE)pTemp;
        pTemp = (char *)(pNode + 1);

        DebugTrace((LPARAM)0,
                    "Creating node for command %s",
                    pszCommandKeyword);

        strcpy(pTemp, pszCommandKeyword);
        dwPriority = pBinding->dwPriority;
        pBinding->pNext = NULL;
        pNode->pszCommandKeyword = pTemp;
        pNode->dwHighestPriority = dwPriority;
        pNode->pFirstBinding = pBinding;
    }

    // Insert based on top priority
    LPPE_COMMAND_NODE   pWalk = *ppHeadNode;
    LPPE_COMMAND_NODE   pPrev = (LPPE_COMMAND_NODE)ppHeadNode;
    if (!pWalk)
    {
        pNode->pNext = NULL;
        *ppHeadNode = pNode;
        return(S_OK);
    }
    while (pWalk)
    {
        if (pWalk->dwHighestPriority > dwPriority)
            break;
        pPrev = pWalk;
        pWalk = pWalk->pNext;
    }
    pNode->pNext = pWalk;
    pPrev->pNext = pNode;

    TraceFunctLeave();
    return(S_OK);
}

HRESULT CGenericProtoclEventDispatcher::InsertBindingWithHash(
            LPPE_COMMAND_NODE   *rgpHeadNodes,
            DWORD               dwHashSize,
            LPPE_BINDING_NODE   pBinding,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize
            )
{
    TraceFunctEnter("CGenericProtoclEventDispatcher::InsertBindingWithHash");

    if (!rgpHeadNodes || !pBinding || !pszCommandKeyword)
        return(E_POINTER);

    DWORD dwHash = GetHashValue(
                dwHashSize,
                pszCommandKeyword,
                dwCommandKeywordSize);

    HRESULT hr = InsertBinding(
                &(rgpHeadNodes[dwHash]),
                pBinding,
                pszCommandKeyword,
                dwCommandKeywordSize);

    TraceFunctLeave();
    return(hr);
}

HRESULT CGenericProtoclEventDispatcher::FindCommandFromHash(
            LPPE_COMMAND_NODE   *rgpHeadNodes,
            DWORD               dwHashSize,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize,
            LPPE_COMMAND_NODE   *ppCommandNode
            )
{
    TraceFunctEnter("CGenericProtoclEventDispatcher::FindCommandFromHash");

    if (!rgpHeadNodes || !pszCommandKeyword || !ppCommandNode)
        return(E_POINTER);

    DWORD dwHash = GetHashValue(
                dwHashSize,
                pszCommandKeyword,
                dwCommandKeywordSize);

    LPPE_COMMAND_NODE   pNode = rgpHeadNodes[dwHash];

    while (pNode)
    {
        if (!strcmp(pszCommandKeyword, pNode->pszCommandKeyword))
        {
            *ppCommandNode = pNode;
            TraceFunctLeave();
            return(S_OK);
        }
        pNode = pNode->pNext;
    }
    TraceFunctLeave();
    return(S_FALSE);
}

HRESULT CGenericProtoclEventDispatcher::CleanupCommandNodes(
            LPPE_COMMAND_NODE   pHeadNode,
            LPPE_COMMAND_NODE   pSkipNode
            )
{
    LPPE_COMMAND_NODE   pNode;
    while (pHeadNode)
    {
        pNode = pHeadNode->pNext;
        if (pHeadNode != pSkipNode)
        {
            char    *pTemp = (char *)pHeadNode;
            delete [] pTemp;
        }
        pHeadNode = pNode;
    }
    return(S_OK);
}


//
// Inbound dispatcher methods
//

HRESULT CInboundDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new CInboundBinding(this);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CInboundDispatcher::ChainSinks(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            IMailMsgProperties          *pMsg,
            ISmtpInCommandContext       *pContext,
            DWORD                       dwStopAtPriority,
            LPPE_COMMAND_NODE           pCommandNode,
            LPPE_BINDING_NODE           *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_BINDING_NODE   pBinding = NULL;

    TraceFunctEnterEx((LPARAM)this, "CInboundDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !pCommandNode || !ppResumeFrom)
        return(E_POINTER);

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // pCmdNode     ppResumeFrom    Action
    //    NULL          X           Error (E_POINTER)
    //   !NULL          NULL        Error (ERROR_NO_MORE_ITEMS)
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    pBinding = *ppResumeFrom;
    if (!pBinding)
    {
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    CInboundBinding     *pInboundBinding;
    IUnknown            *pUnkSink = NULL;
    ISmtpInCommandSink  *pSink;

    hr = S_OK;
    *ppResumeFrom = pBinding;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwPriority > dwStopAtPriority)
            break;

        // Get the containing binding class
        pInboundBinding = CONTAINING_RECORD(
                    pBinding, CInboundBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pInboundBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpInCommandSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                hr = pSink->OnSmtpInCommand(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
        *ppResumeFrom = pBinding;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// CInboundDispatcher::CInboundBinding methods
//
HRESULT CInboundDispatcher::CInboundBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "CInboundDispatcher::CInboundBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }

    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword || !(*szCommandKeyword))
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBindingWithHash(
                m_pDispatcher->m_rgpCommandList,
                m_pDispatcher->m_dwHashSize,
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


//
// Outbound dispatcher methods
//
void COutboundDispatcher::InitializeDefaultCommandBindings()
{
    for (DWORD i = 0; i < PE_STATE_MAX_STATES; i++)
    {
        if (s_rgszDefaultCommand[i])
        {
            // Set up the list head
            m_rgpCommandList[i] = &(m_rgcnDefaultCommand[i]);

            // Set up the command node
            m_rgpCommandList[i]->pNext = NULL;
            m_rgpCommandList[i]->pszCommandKeyword = s_rgszDefaultCommand[i];
            m_rgpCommandList[i]->dwHighestPriority = PRIO_DEFAULT;
            m_rgpCommandList[i]->pFirstBinding = &(m_rgbnDefaultCommand[i]);

            // Set up the binding node
            m_rgbnDefaultCommand[i].pNext = NULL;
            m_rgbnDefaultCommand[i].dwPriority = PRIO_DEFAULT;
            m_rgbnDefaultCommand[i].dwFlags = PEBN_DEFAULT;
        }
        else
            m_rgpCommandList[i] = NULL;
    }
}

HRESULT COutboundDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new COutboundBinding(this, rguidEventType);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COutboundDispatcher::ChainSinks(
            IUnknown                *pServer,
            IUnknown                *pSession,
            IMailMsgProperties      *pMsg,
            ISmtpOutCommandContext  *pContext,
            DWORD                   dwEventType,
            LPPE_COMMAND_NODE       *ppPreviousCommand,
            LPPE_BINDING_NODE       *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_COMMAND_NODE   pCommand = NULL;
    LPPE_BINDING_NODE   pBinding = NULL;

    _ASSERT(dwEventType < PE_OET_INVALID_EVENT_TYPE);

    TraceFunctEnterEx((LPARAM)this, "COutboundDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !ppPreviousCommand || !ppResumeFrom)
        return(E_POINTER);

    // If we encounter a bad event type, just gracefully return
    // without doing anythig
    if (dwEventType >= PE_OET_INVALID_EVENT_TYPE)
    {
        *ppResumeFrom = NULL;
        ErrorTrace((LPARAM)this,
                "Skipping event due to bad event type %u",
                dwEventType);
        return(S_OK);
    }

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // ppPrevCmd    ppResumeFrom    Action
    //    NULL          NULL        Start from the first command for this event type
    //    NULL         !NULL        Start from the first command for this event type
    //   !NULL          NULL        Start from the first binding for the command
    //                                that follows *ppPreviousCommand
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppPreviousCommand - This will point to the command node of the command
    //                      that was just processed
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    if (!*ppPreviousCommand)
    {
        pCommand = m_rgpCommandList[dwEventType];
        if (!pCommand)
        {
            // Ooooops! We peeked with SinksInstalled() but now we have no sinks
            // This is an error but we will recover gracefully
            _ASSERT(pCommand);
            ErrorTrace((LPARAM)this, "ERROR! Empty command chain!!");
            return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
        }

        // We check this downstream
        pBinding = pCommand->pFirstBinding;
    }
    else if (*ppResumeFrom)
    {
        // We resume from the exact binding as specified
        pCommand = *ppPreviousCommand;
        pBinding = *ppResumeFrom;
    }
    else
    {
        // We start with the next command in the list
        pCommand = (*ppPreviousCommand)->pNext;
        if (!pCommand)
        {
            DebugTrace((LPARAM)this, "No more commands to chain");
            *ppPreviousCommand = NULL;
            *ppResumeFrom = NULL;
            return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
        }

        // We check this downstream
        pBinding = pCommand->pFirstBinding;
    }

    // DEBUG Check: we want the retail perf to be as high as possible
    // and we want it to be fail safe as well. We will do an internal
    // check here to make sure that any command node has at least one
    // binding, and that we have bindings when we expect them.
#ifdef DEBUG
    if (!pBinding)
    {
        // Ooooops! We have a command node without a binding. This is a blatant
        // error but we recover gracefully
        _ASSERT(pBinding);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }
#endif

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    COutboundBinding    *pOutboundBinding;
    IUnknown            *pUnkSink = NULL;
    ISmtpOutCommandSink *pSink;
    COutboundContext    *pCContext;

    // Initialize pContext->m_pCurrentCommandContext
    pCContext = (COutboundContext *)pContext;
    pCContext->m_pCurrentCommandContext = pCommand;

    hr = S_OK;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwFlags & PEBN_DEFAULT)
            break;

        // Get the containing binding class
        pOutboundBinding = CONTAINING_RECORD(
                    pBinding, COutboundBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pOutboundBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpOutCommandSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                // Pre-fill in the next binding to avoid
                // race conditions in the async case
                *ppResumeFrom = pBinding->pNext;
                hr = pSink->OnSmtpOutCommand(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    hr = S_OK;
                //  break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
    }

    // Return where to resume from ...
    *ppPreviousCommand = pCommand;
    *ppResumeFrom = pBinding;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// COutboundDispatcher::COutboundBinding methods
//
COutboundDispatcher::COutboundBinding::COutboundBinding(
            COutboundDispatcher *pDispatcher,
            REFGUID             rguidEventType
            )
{
    _ASSERT(pDispatcher);
    m_pDispatcher = pDispatcher;

    // Based on the event type GUID, we can calculate which
    // event type id this goes to
    for (m_dwEventType = 0;
         m_dwEventType < PE_OET_INVALID_EVENT_TYPE;
         m_dwEventType++)
        if (rguidEventType == *(s_rgrguidEventTypes[m_dwEventType]))
            break;
    // If the GUID is not recognized, then the final value of
    // m_dwEventType will be PE_OET_INVALID_EVENT_TYPE, which
    // we will not process in this dispatcher
}


HRESULT COutboundDispatcher::COutboundBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "COutboundDispatcher::COutboundBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // If the event type GUID is unknown, invalidate this binding
    if (m_dwEventType >= PE_OET_INVALID_EVENT_TYPE)
        return(E_INVALIDARG);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }
    else if(hr == S_FALSE)
    {
        //
        // Treat no rule as an empty string rule
        //
        szCommandKeyword[0] = '\0';
        cchCommandKeyword = 1;
    }


    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword)
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBinding(
                &((m_pDispatcher->m_rgpCommandList)[m_dwEventType]),
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


//
// CResponseDispatcher mathods
//

HRESULT CResponseDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new CResponseBinding(this);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CResponseDispatcher::ChainSinks(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            IMailMsgProperties          *pMsg,
            ISmtpServerResponseContext  *pContext,
            DWORD                       dwStopAtPriority,
            LPPE_COMMAND_NODE           pCommandNode,
            LPPE_BINDING_NODE           *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_BINDING_NODE   pBinding = NULL;

    TraceFunctEnterEx((LPARAM)this, "CResponseDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !pCommandNode || !ppResumeFrom)
        return(E_POINTER);

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // pCmdNode     ppResumeFrom    Action
    //    NULL          X           Error (E_POINTER)
    //   !NULL          NULL        Error (ERROR_NO_MORE_ITEMS)
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    pBinding = *ppResumeFrom;
    if (!pBinding)
    {
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    CResponseBinding        *pResponseBinding;
    IUnknown                *pUnkSink = NULL;
    ISmtpServerResponseSink *pSink;

    hr = S_OK;
    *ppResumeFrom = pBinding;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwPriority > dwStopAtPriority)
            break;

        // Get the containing binding class
        pResponseBinding = CONTAINING_RECORD(
                    pBinding, CResponseBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pResponseBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpServerResponseSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                // Pre-fill in the next binding to avoid
                // race conditions in the async case
                hr = pSink->OnSmtpServerResponse(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    hr = S_OK;
                //  break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
        *ppResumeFrom = pBinding;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// CResponseDispatcher::CResponseBinding methods
//
HRESULT CResponseDispatcher::CResponseBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "CResponseDispatcher::CResponseBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }

    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword || !(*szCommandKeyword))
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBindingWithHash(
                m_pDispatcher->m_rgpCommandList,
                m_pDispatcher->m_dwHashSize,
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//              12/09/07    Milans  Ported it over to Exchange
//
//  Notes:      see notes in registry.h
//
//----------------------------------------------------------------------------

#include    "smtpinc.h"
#include    "registry.h"

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pszPath,
                     samDesiredAccess,
                     pszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pszPath,
                      samDesiredAccess,
                      pszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess,
        LPCSTR  pszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           (LPSTR) pszPath,    //  path to key
                           0,                  //  title index
                           (LPSTR) pszClass,   //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR    szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               szClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        CHAR   szValueID[MAX_PATH];
        ULONG   cbValueID = sizeof(szValueID);
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        szValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CRegKey &)*this, szValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CRegKey &)*this, szValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, szValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, szValueID);
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR   szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     szClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        CHAR   szKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(szKeyName);
        CHAR   szClass[MAX_PATH];
        ULONG   cbClass = sizeof(szClass);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                szKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                szClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, szKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPSTR)_cszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPSTR)_cszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CRegKey cregKey ( hParent,
                      lpszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                    (LPSTR) pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\pe_supp.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_supp.cxx

   Abstract:

        This module provides the implementation for the protocol
		event context

   Author:

           Keith Lau    (KeithLau)    7/07/98

   Project:

           SMTP Server DLL

   Revision History:

			KeithLau			Created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"

//
// Dispatcher implementation 
//
#include "pe_dispi.hxx"


HRESULT STDMETHODCALLTYPE CInboundContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
    TraceFunctEnterEx((LPARAM)this, "CInboundContext::NotifyAsyncCompletion");

	HRESULT hrRes = S_OK;
	SMTP_CONNECTION	*pParent = NULL;

	// We can obtain the SMTP_CONNECTION object from this
	pParent = CONTAINING_RECORD(this, SMTP_CONNECTION, m_CInboundContext);

	// Call the notify method on the parent class
	hrRes = pParent->OnNotifyAsyncCompletion(
				hrResult
				);

    DebugTrace((LPARAM)this, "returning hr %08lx", hrRes);

    TraceFunctLeaveEx((LPARAM)this);

	return(hrRes);
}

HRESULT STDMETHODCALLTYPE COutboundContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
	return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CResponseContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

#if 0
#include <timer.h>
#include <time.h>
#endif

#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>


BOOL
IsSmtpEncryptionPermitted(
                VOID
                )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }

    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    return(TRUE);

} // IsEncryptionPermitted



DWORD
SMTP_SERVER_INSTANCE::QueryEncCaps(
    VOID
    )
/*++

   Description

       Returns encryption capability

   Arguments:

       None

   Return:

       Encryption capability

--*/
{
    //
    //  Get the encryption capability bits.  SecurePort may be zero because
    //  no keys are installed or the locale does not allow encryption
    //

	return 0;
} // SMTP_SERVER_INSTANCE::QueryEncCaps



BOOL
SMTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    return TRUE;

} // SMTP_SERVER_INSTANCE::SetServiceConfig




BOOL
SMTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{
    LPSMTP_CONFIG_INFO  pConfig = (LPSMTP_CONFIG_INFO)pBuffer;
    DWORD               err = NO_ERROR;
    MB                  MetaInfo( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ZeroMemory( pConfig, sizeof( SMTP_CONFIG_INFO ) );

    // We want to open a read handle to the server instance
    // name, and then we'll read the indivdual info out next.
    //

    if ( !MetaInfo.Open( QueryMDVRPath() ))
    {
        return FALSE;
    }

    LockThisForRead();

    //
    //  Get always retrieves all of the parameters
    //

    pConfig->FieldControl = FC_SMTP_INFO_ALL;


    //
    //  Set the encryption capability bits.  SecurePort may be zero
    //  because no keys are installed or the locale does not allow
    //  encryption
    //



    UnlockThis();

    SetLastError(err);
    return(err==NO_ERROR);

} // W3_SERVER_INSTANCE::GetServiceConfig




BOOL
SMTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.

--*/
{
    BOOL fRet = TRUE;

#if 0
    //
    //  Lock the user database.
    //

    LockUserDatabase();

    //
    //  Determine the necessary buffer size.
    //

    pBuffer->EntriesRead = 0;
    pBuffer->Buffer      = NULL;

    cbBuffer  = 0;
    err       = NERR_Success;

    EnumerateUsers( pBuffer, &cbBuffer );

    if( cbBuffer > 0 )
    {
        //
        //  Allocate the buffer.  Note that we *must*
        //  use midl_user_allocate/midl_user_free.
        //

        pBuffer->Buffer = (W3_USER_INFO *) MIDL_user_allocate( (unsigned int)cbBuffer );

        if( pBuffer->Buffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            //  Since we've got the user database locked, there
            //  *should* be enough room in the buffer for the
            //  user data.  If there isn't, we've messed up
            //  somewhere.
            //

            TCP_REQUIRE( ::EnumerateUsers( pBuffer, &cbBuffer ) );
        }
    }

    //
    //  Unlock the user database before returning.

    UnlockUserDatabase();

#endif //0

    return fRet;

} // EnumerateUsers


BOOL
SMTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    BOOL fRet = TRUE;

    //
    //  Do it.
    //

    if( dwIdUser == 0 )
    {
        DisconnectAllConnections();
    }
    else
    {
#if 0
        if( !CLIENT_CONN::DisconnectUser( idUser ) )
        {
            err = NERR_UserNotFound;
        }
#endif
    }

    return fRet;

} // DisconnectUser


BOOL
SMTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel )
    {
    case 0 :
        {
            LPSMTP_STATISTICS_0 pstats1;

            pstats1 = (SMTP_STATISTICS_0 *) MIDL_user_allocate( sizeof(SMTP_STATISTICS_0) );

            if( pstats1 == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                QueryStatsObj()->CopyToStatsBuffer( pstats1 );

                //pstats1->TimeOfLastClear = GetCurrentTimeInSeconds() -
                  //                         pstats1->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //
                //pstats1->CurrentConnections =
                   // g_pSmtpStats->QueryStatsObj()->m_cCurrentConnections;
                //pstats1->MaxConnections =
                   // g_pSmtpStats->QueryStatsObj()->m_cMaxCurrentConnections;
                //pstats1->ConnectionAttempts =
                   // g_pSmtpStats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats1;
            }
        }
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
SMTP_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    QueryStatsObj()->ClearStatistics();

    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ismtpsvr.rc
//
#define IDS_PROJNAME                    100
#define IDR_SMTPSERVER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\queue.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        queue.cxx

   Abstract:
		Implements a queue

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"

/*++

	Name :
		PERSIST_QUEUE::InitializeQueue

    Description:
	   This function initializes all the class
	   member functions.

    Arguments:
	pszQueueName - Name of the on disk queue
	Flags		 - Queue flags
	Retry		 - How long we should retry failed deliveries
	FlushQ		 - How often we should flush the queue to disk

    Returns:

	TRUE if all memory allocations and all I/O operations pass
	FALSE otherwise

--*/
BOOL PERSIST_QUEUE::InitializeQueue (void)
{

	TraceFunctEnterEx((LPARAM)this, "PERSIST_QUEUE::InitializeQueue");

	// Now, initialize the queue structure:
	m_QData.Entries = 0;
	m_QData.RetryInterval = 0;
	m_QData.StoreInterval = 0;
	m_QData.Flags = 0;
	m_QData.LastStore = (LONGLONG) 0;

	//create the thread that processes things out of the
	//the queue
	DWORD ThreadId;
	DWORD  Loop = 0;

	for (Loop = 0; Loop < m_NumThreads; Loop++)
	{
		m_ThreadHandle[Loop] = CreateThread (NULL, 0, PERSIST_QUEUE::QueueThreadRoutine, this, 0, &ThreadId);
		if (m_ThreadHandle[Loop] == NULL)
		{
			TraceFunctLeaveEx((LPARAM)this);
			return FALSE;
		}
	}

	TraceFunctLeaveEx((LPARAM)this);
	return TRUE;
}

/*++

	Name :
		PERSIST_QUEUE::CreateQueue

    Description:
	   This is the static member function that creates the Queue

    Arguments:
	Qtype -	the type of queue to create (i.e Local, Remote, etc.)

    Returns:

	TRUE if all memory allocations and all I/O operaations pass
	FALSE otherwise

--*/
PERSIST_QUEUE * PERSIST_QUEUE::CreateQueue(QUEUE_TYPE Qtype, SMTP_SERVER_INSTANCE * pSmtpInst)
{
    PERSIST_QUEUE * pQueue = NULL;

   _ASSERT (pSmtpInst != NULL);

   if(Qtype == REMOTEQ)
   {
     pQueue = new REMOTE_QUEUE(pSmtpInst);
	 if(pQueue)
	 {
		pQueue->SetNumThreads(pSmtpInst->GetMaxRemoteQThreads());
	 }
	 else
	 {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
	 }
   }
   else
   {
	   _ASSERT(FALSE);
	   return NULL;
   }

	//initialize the queue
	if(!pQueue->InitializeQueue())
	 {
	    delete pQueue;
		pQueue = NULL;
	 }

	return pQueue;
}


/*++

	Name :
		PERSIST_QUEUE::ProcessQueueEvents

    Description:
	   This is the virtual process function
	   that all derived classes must override
	   This function is different depending on
	   what it is suppose to do.  Take a look
	   at localq.cxx and remoteq.cxx for examples.

    Arguments:

    Returns:
	Always TRUE

--*/
BOOL PERSIST_QUEUE::ProcessQueueEvents(ISMTPConnection    *pISMTPConnection)
{
	return TRUE;
}

/*++

	Name :
		PERSIST_QUEUE::FlushQueueEvents

    Description:
	   This function deletes all entries from the queue

    Arguments:

    Returns:

--*/
void PERSIST_QUEUE::FlushQueueEvents(void)
{
	PLIST_ENTRY  pEntry;
	PQUEUE_ENTRY pQEntry;

  	TraceFunctEnterEx((LPARAM)this, "PERSIST_QUEUE::FlushQueueEvents");

	_ASSERT (GetParentInst() != NULL);

	LockQ();

	//delete all entries from the list
	while(!IsListEmpty (&m_QHead))
	{
		GetParentInst()->StopHint();
		pEntry = RemoveHeadList (&m_QHead);
		pQEntry = CONTAINING_RECORD( pEntry, PERSIST_QUEUE_ENTRY, m_QEntry);
		pQEntry->BeforeDelete();
		delete pQEntry;
	}

	//reset the stop hint
	GetParentInst()->SetStopHint(2);
	UnLockQ();
	TraceFunctLeaveEx((LPARAM)this);
}


/*++

	Name :
		PERSIST_QUEUE::QueueThreadRoutine

    Description:
	   This function is the static member
	   function that gets passed to CreateThread
	   to initialize the queue.

    Arguments:
		A pointer to a PERSIST_QUEUE

    Returns:

--*/
DWORD WINAPI PERSIST_QUEUE::QueueThreadRoutine(void * ThisPtr)
{
  PQUEUE QueuePtr = (PQUEUE) ThisPtr;
  HRESULT hr = S_OK;
  ISMTPConnection    *pISMTPConnection = NULL;

  TraceFunctEnterEx((LPARAM)QueuePtr, "PERSIST_QUEUE::QueueThreadRoutine");

  while(TRUE)
  {
	  pISMTPConnection = NULL;
	  hr = QueuePtr->GetParentInst()->GetConnManPtr()->GetNextConnection(&pISMTPConnection);
	  if(!FAILED(hr))
	  {
		//call the virtual process function
		QueuePtr->ProcessQueueEvents(pISMTPConnection);

		 //if we are shutting down, break out of the loop
		 if (QueuePtr->GetParentInst()->IsShuttingDown())
			 goto Out;
	  }
	  else
	  {
		 //if we are shutting down, break out of the loop
		 if (QueuePtr->GetParentInst()->IsShuttingDown())
			 goto Out;
	  }
  }

Out:

  TraceFunctLeaveEx((LPARAM)QueuePtr);
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\rpcmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
*/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//
#include "smtpinc.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"

#include <isrpc.hxx>

PISRPC		g_pIsrpc = NULL;
HINSTANCE	g_hDll = NULL;
PISRPC		sm_isrpc = NULL;

BOOL
InitializeSmtpServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL CleanupSmtpServiceRpc(
                 VOID
                 );

#if 0
extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
		case DLL_PROCESS_ATTACH:  

			g_hDll = hDll;
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		default:
			break ;
    }

    return ( fReturn);

}  // main()

BOOL WINAPI DllMain (HANDLE hInst, ULONG dwReason, LPVOID lpvReserve)
{
  return DLLEntry((HINSTANCE) hInst, dwReason, lpvReserve);
}
#endif

#if 0
BOOL
InitDlls(
    VOID
    )
/*++
    Description:

        DLL Init and uninit functions that don't have to worry about the
        peb lock being taken during PROCESS_ATTACH/DETACH.

--*/
{
    BOOL fReturn = TRUE;

    if ( !InitializeServiceRpc(
                             NNTP_TEST_SERVICE_NAME,
                             nntptest_ServerIfHandle
                             ) )
    {
        fReturn = FALSE;

    }

    return fReturn;
}

BOOL
TerminateDlls(
    VOID
    )
{
    CleanupSmtpServiceRpc( );

    return TRUE;
}
#endif

BOOL
InitializeSmtpServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc;

    //DBG_ASSERT( pszServiceName != NULL);
    //DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //
#if 0
    dwError = pIsrpc->StartServer( );
#endif

exit:

    if ( dwError != NO_ERROR ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "Cannot start RPC Server for %s, error %lu\n",
        //           pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc


BOOL CleanupSmtpServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        //DBGPRINTF((DBG_CONTEXT,
        //    "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

    //(VOID) sm_isrpc->StopServer( );
   // dwError = sm_isrpc->CleanupData();

   sm_isrpc->UnRegisterInterface();
   // if( dwError != RPC_S_OK ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "ISRPC(%08x) Cleanup returns %lu\n", sm_isrpc, dwError ));
        //DBG_ASSERT( !"RpcServerUnregisterIf failure" );
      //  SetLastError( dwError);
    //}

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupSmtpServiceRpc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\shash.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       shash.cxx

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

  		Rohan Phillips   (RohanP)		MARCH-08-1997 - modified for SMTP

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "shash.hxx"

CSMTP_HASH_TABLE::~CSMTP_HASH_TABLE()
{
	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::~CSMTP_HASH_TABLE");

	RemoveAllEntries();

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::RemoveThisEntry(CHASH_ENTRY * pHashEntry, DWORD BucketNum)
{
	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveThisEntry");

	DebugTrace((LPARAM)this, "removing %s from hash table", pHashEntry->GetData());
	m_HashTable[BucketNum].m_Lock.ExclusiveLock();
	RemoveEntryList(&pHashEntry->QueryListEntry());
	m_HashTable[BucketNum].m_Lock.ExclusiveUnlock();

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::RemoveAllEntries(void)
{
	DWORD LoopVar = 0;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	CHASH_ENTRY * pHashEntry = NULL;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveAllEntries");

	//say we don't have any wildcard entries anymore
	m_fWildCard = FALSE;

	for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
	{
		m_HashTable[LoopVar].m_Lock.ExclusiveLock();
		HeadOfList = &m_HashTable[LoopVar].m_ListHead;
		while (!IsListEmpty(HeadOfList))
		{
			//remove the entries from the list
			pEntry = RemoveHeadList (HeadOfList);
			pHashEntry = CONTAINING_RECORD(pEntry, CHASH_ENTRY, m_ListEntry);

			//clear inlist flag
			pHashEntry->ClearInList();

			DebugTrace((LPARAM)this, "removing %s from hash table. RefCnt = %d", pHashEntry->GetData(),  pHashEntry->QueryRefCount());

			//decrement the ref count.  If it hits 0, then the
			//entry will be deleted.  Else, it means some other
			//thread has a refernce to it and that thread will
			//delete the object when the ref count hits 0.
			pHashEntry->DecRefCount();

			//decrement entry counts
			m_HashTable[LoopVar].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[LoopVar].m_RefNum));
			InterlockedDecrement(&m_TotalEntries);
		}
		m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();

	}

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::PrintAllEntries(void)
{
	DWORD LoopVar = 0;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	PLIST_ENTRY  pentryNext = NULL;
	CHASH_ENTRY * pHashEntry = NULL;

	for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
	{
		m_HashTable[LoopVar].m_Lock.ExclusiveLock();

		HeadOfList = &m_HashTable[LoopVar].m_ListHead;
		pEntry = m_HashTable[LoopVar].m_ListHead.Flink;
		for(; pEntry != HeadOfList; pEntry = pentryNext)
		{
			pentryNext = pEntry->Flink;
			pHashEntry = CONTAINING_RECORD(pEntry, CHASH_ENTRY, m_ListEntry);
			printf("%s i n bucket %d\n", pHashEntry->GetData(), LoopVar);
		}

		m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
	}
}


BOOL CSMTP_HASH_TABLE::InsertIntoTable(CHASH_ENTRY * pHashEntry)
{
	unsigned int HashValue = 0;
	char * NewData = NULL;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY ListEntry =NULL;
	CHASH_ENTRY * pExistingEntry = NULL;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::InsertIntoTable");

	_ASSERT(pHashEntry != NULL);

	if(pHashEntry == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

	//get the new data
	NewData = pHashEntry->GetData();

	_ASSERT(NewData != NULL);

	if(NewData == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

	//get the hash value
	HashValue = HashFunction (NewData);

	//lock the list exclusively
	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	//insert the head of the list for this bucket
	//duplicates are not allowed
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(NewData, ExistingData);
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			ErrorTrace((LPARAM)this, "%s is already in hash table - returning FALSE", pHashEntry->GetData());

			if(!m_fDupesAllowed)
			{
				//duplicates are not allowed
				m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
				SetLastError(ERROR_DUP_NAME);
				TraceFunctLeaveEx((LPARAM)this);
				return FALSE;
			}
			else
			{
				//duplicates are allowed
				break;
			}
		}
	}

	// Ok, insert here.

	//inc the ref count
	pHashEntry->IncRefCount();

	// QFE 123862 MarkH: insert before this item
	InsertTailList(ListEntry, &pHashEntry->QueryListEntry());

	//set inlist flag
	pHashEntry->SetInList();

	//update total entries in this bucket
	m_HashTable[HashValue].m_NumEntries++;

	DebugTrace((LPARAM)this, "inserted %s into hash table. RefCnt = %d", pHashEntry->GetData(), pHashEntry->QueryRefCount());

	//update numentries in this bucket
	InterlockedIncrement(&m_TotalEntries);

	//unlock this bucket
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

	TraceFunctLeaveEx((LPARAM)this);
	return TRUE;
}

BOOL CSMTP_HASH_TABLE::InsertIntoTableEx(CHASH_ENTRY * pHashEntry, char * szDefaultDomain)
{
    return(CSMTP_HASH_TABLE::InsertIntoTable(pHashEntry));
}

BOOL CSMTP_HASH_TABLE::RemoveFromTable(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveFromTable");

	_ASSERT(SearchData != NULL);

	if(SearchData == NULL)
	{
		return FALSE;
	}

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(ExistingData, SearchData);
		if(Result == 0)
		{
			DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

			//found it
			RemoveEntryList(ListEntry);
			m_HashTable[HashValue].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[HashValue].m_RefNum));

			//clear inlist flag
			pExistingEntry->ClearInList();

			pExistingEntry->DecRefCount();

			InterlockedDecrement(&m_TotalEntries);

			m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
	TraceFunctLeaveEx((LPARAM)this);
	return FALSE;
}

BOOL CSMTP_HASH_TABLE::RemoveFromTableNoDecRef(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveFromTableNoDecRef");

	_ASSERT(SearchData != NULL);

	if(SearchData == NULL)
	{
		return FALSE;
	}

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(ExistingData, SearchData);
		if(Result == 0)
		{
			DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

			//found it
			RemoveEntryList(ListEntry);
			m_HashTable[HashValue].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[HashValue].m_RefNum));
			m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
			InterlockedDecrement(&m_TotalEntries);
			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
	TraceFunctLeaveEx((LPARAM)this);
	return FALSE;
}


CHASH_ENTRY * CSMTP_HASH_TABLE::FindHashData(const char * SearchData, BOOL fUseShareLock, MULTISZ*  pmsz)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::FindHashData");

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	if(fUseShareLock)
		m_HashTable[HashValue].m_Lock.ShareLock();
	else
		m_HashTable[HashValue].m_Lock.ExclusiveLock();

	//start search at the head of the list for this bucket
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(SearchData, ExistingData);
		// QFE 123862 MarkH: List is ascending
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			//found it
			pExistingEntry->IncRefCount();
			InterlockedIncrement((LPLONG)&m_CacheHits);

			DebugTrace((LPARAM)this, "found %s in hash table", SearchData);

			if(!pmsz)
			{
				if(fUseShareLock)
					m_HashTable[HashValue].m_Lock.ShareUnlock();
				else
					m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

				TraceFunctLeaveEx((LPARAM)this);
				return pExistingEntry;
			}
			else
			{
				MultiszFunction(pExistingEntry, pmsz);
				pExistingEntry->DecRefCount();
				continue;
			}
		}
	}

	DebugTrace((LPARAM)this, "%s was not found in hash table", SearchData);

	if(fUseShareLock)
		m_HashTable[HashValue].m_Lock.ShareUnlock();
	else
		m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

	InterlockedIncrement((LPLONG)&m_CacheMisses);
	SetLastError(ERROR_PATH_NOT_FOUND);
	TraceFunctLeaveEx((LPARAM)this);
	return NULL;
}

CHASH_ENTRY * CSMTP_HASH_TABLE::UnSafeFindHashData(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	//get the hash value
	HashValue = HashFunction (SearchData);

	//insert the head of the list for this bucket
	//duplicates are not allowed
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(SearchData, ExistingData);
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			//found it
			m_HashTable[HashValue].m_Lock.ShareUnlock();
			return pExistingEntry;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	return NULL;
}


CHASH_ENTRY * CSMTP_HASH_TABLE::WildCardFindHashData(const char * DomainName)
{
	CHASH_ENTRY * pHashEntry = NULL;
	char * SearchPtr = NULL;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::WildCardFindHashData");

	//perform the first level hash
	pHashEntry = FindHashData(DomainName, TRUE);

	if(pHashEntry != NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return pHashEntry;
	}
	else if(!m_fWildCard)
	{
		//if no wildcards are in the table,
		//just return NULL.  Else, perform
		//the multilevel hash
		TraceFunctLeaveEx((LPARAM)this);
		return NULL;
	}

	//try to find all sub-domains
	SearchPtr = strchr(DomainName, '.');
	while(SearchPtr)
	{
		//skip past '.'
		SearchPtr += 1;

		//hash this portion of the domain name
		pHashEntry = FindHashData(SearchPtr);
		if((pHashEntry != NULL) && (pHashEntry->IsWildCard()))
		{
			TraceFunctLeaveEx((LPARAM)this);
			return pHashEntry;
		}
		else if(pHashEntry)
		{
			pHashEntry->DecRefCount();
		}

		SearchPtr = strchr(SearchPtr, '.');
	}

	//didn't find it.
	TraceFunctLeaveEx((LPARAM)this);
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpinc.h ===
#ifndef	_SMTPINC_H_
#define	_SMTPINC_H_

#define  INCL_INETSRV_INCS
#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <dns.h>
#include <dnsapi.h>

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>

#include <smtpinet.h>
#include <stdio.h>
#include <stdlib.h>

#include <abtype.h>
#include <abook.h>
#include <string.h>
#include <time.h>
#include <lmcons.h>

#include <dbgtrace.h>
#include <cpool.h>
#include <address.hxx>
#include <ims.h>
#include <envdef.h>

#include <propstr.h>
#include <mailmsgprops.h>
#include <smtpevents.h>

/*
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
*/

#include "filehc.h"
#include "mailmsgi.h"
#include "aqueue.h"

//
// common headers from pop3/inc
//
#include <smtptype.h>
#include <smtps.h>
#include <smtpapi.h>

#include <listmacr.h>
#include <rwnew.h>

//
// local header files
//
#ifdef BUILDING_SMTP_DEBUG_EXTENTIONS
//Debugger extensions need access to private/protected members to 
//calculate their memory offsets
#define private public
#define protected public
#endif //BUILDING_SMTP_DEBUG_EXTENTIONS

#include "stats.hxx"
#include "smtpmsg.h"
#include "queue.hxx"
#include "evntwrap.h"
#include "globals.h"
#include "smtpinst.hxx"
#include "errorlog.hxx"
#include "smtpproc.h"


#ifdef UNICODE
#define	TSTRCPY	wcscpy
#define	TSTRCAT	wcscat
#define	TSTRLEN	wcslen
#else
#define	TSTRCPY	lstrcpy
#define	TSTRCAT	lstrcat
#define	TSTRLEN	lstrlen
#endif
typedef TCHAR	*PTCHAR;

#endif	// _SMTPINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpdns.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include <asynccon.hxx>
#include <dnsreci.h>
#include <cdns.h>
#include "smtpdns.hxx"
#include "asyncmx.hxx"
#include "smtpmsg.h"
#include <tran_evntlog.h>

CDnsLogger *g_pDnsLogger = NULL;
extern DWORD g_DnsErrorsBeforeFailover;
extern DWORD g_DnsConnectsInProbation;

extern BOOL QueueCallBackFunction(PVOID ThisPtr, BOOLEAN fTimedOut);
extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);
extern PSMTPDNS_RECS GetDnsRecordsFromLiteral(const char * HostName);

CPool  CAsyncSmtpDns::Pool(SMTP_ASYNCMX_SIGNATURE);

CAsyncSmtpDns::CAsyncSmtpDns(
    SMTP_SERVER_INSTANCE * pServiceInstance, 
    ISMTPConnection    *pSmtpConnection,
    RETRYPARAMS *pRetryParams,
    char *MyFQDN)
        : CAsyncMxDns(MyFQDN)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::CAsyncSmtpDns");
    DebugTrace((LPARAM) this, "Creating CAsyncSmtpDns object = 0x%08x", this);

    m_Signature = SMTP_ASYNCMX_SIGNATURE;
    m_DomainOptions = 0;
    m_fConnectToSmartHost = FALSE;
    m_pServiceInstance = pServiceInstance;
    m_pISMTPConnection = pSmtpConnection;
    m_pDNS_RESOLVER_RECORD = NULL;
    m_fInitCalled = FALSE;
    m_pszSSLVerificationName = NULL;

    //
    // By default we fail in a retryable fashion. This is the generic failure code. If the
    // query succeeds this should be set to ERROR_SUCCESS. This may also set this to a more
    // specific error code at the point of failure.
    //
    m_dwDiagnostic = AQUEUE_E_HOST_NOT_FOUND;

    //
    // pRetryParams encapsulates parameters for a failed message if this DNS query
    // is on an SMTP 4xx error failover path
    //
    if(!pRetryParams)
        ZeroMemory((PVOID) &m_RetryParams, sizeof(m_RetryParams));
    else
    {
        DebugTrace((LPARAM) this, "Failover mailmsg");
        CopyMemory(&m_RetryParams, pRetryParams, sizeof(m_RetryParams));
    }

    pServiceInstance->InsertAsyncDnsObject(this);
}

BOOL CAsyncSmtpDns::Init (LPSTR pszSSLVerificationName)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CAsyncSmtpDns::Init");

    m_fInitCalled = TRUE;

    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen(pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName)
            goto Exit;

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }

    fRet = TRUE;
Exit:
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

BOOL CAsyncSmtpDns::IsShuttingDown()
{
    return m_pServiceInstance->IsShuttingDown();
}

BOOL CAsyncSmtpDns::IsAddressMine(DWORD dwIp)
{
    return m_pServiceInstance->IsAddressMine(dwIp, 25);
}

CAsyncSmtpDns::~CAsyncSmtpDns()
{
    DWORD dwAck = 0;
    MessageAck MsgAck;

    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::~CAsyncSmtpDns");

    DebugTrace((LPARAM) this, "Destructing CAsyncSmtpDns object = 0x%08x", this);

    _ASSERT (m_fInitCalled && "Init not called on CAsyncSmtpDns");

    if(m_fMxLoopBack)
        m_dwDiagnostic = AQUEUE_E_LOOPBACK_DETECTED;

    DeleteDnsRec(m_AuxList);

    //
    // If we did not succeed, we need to ack the connection here (m_dwDiagnostic holds
    // the error code to use). On the other hand, if we succeeded, then HandleCompletedData
    // must have kicked off an async connection to the server SMTP, and the ISMTPConnection
    // will be acked by the "async connect" code -- we don't need to do anything. The
    // m_pISMTPConnection may also be legally set to NULL (see HandleCompletedData).
    //
    if(m_dwDiagnostic != ERROR_SUCCESS && m_pISMTPConnection)
    {
        if(m_RetryParams.m_pIMsg)
        {
            DebugTrace((LPARAM) this, "Acking connection on MX failover");

            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;
            MsgAck.pvMsgContext = (PDWORD) m_RetryParams.m_pAdvQContext;
            MsgAck.pIMailMsgProperties = (IMailMsgProperties *) m_RetryParams.m_pIMsg;
            m_pISMTPConnection->AckMessage(&MsgAck);
            MsgAck.pIMailMsgProperties->Release();
            ZeroMemory((PVOID) &m_RetryParams, sizeof(m_RetryParams));

            m_pISMTPConnection->AckConnection(CONNECTION_STATUS_DROPPED);
            m_pISMTPConnection->SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, NULL, NULL);
            m_pISMTPConnection->Release();
            m_pISMTPConnection = NULL;
        }
        else
        {
        
            if(AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND == m_dwDiagnostic)
                dwAck = CONNECTION_STATUS_FAILED_NDR_UNDELIVERED;
            else if(AQUEUE_E_LOOPBACK_DETECTED == m_dwDiagnostic)
                dwAck = CONNECTION_STATUS_FAILED_LOOPBACK;
            else
                dwAck = CONNECTION_STATUS_FAILED;

            DebugTrace((LPARAM) this, "Connection status: %d, Failure: %d", dwAck, m_dwDiagnostic);
            m_pISMTPConnection->AckConnection(dwAck);
            m_pISMTPConnection->SetDiagnosticInfo(m_dwDiagnostic, NULL, NULL);
            m_pISMTPConnection->Release();
            m_pISMTPConnection = NULL;
        }
    }

    if(m_pDNS_RESOLVER_RECORD != NULL)
    {
        DebugTrace((LPARAM) this, "Deleting DNS_RESOLVER_RECORD in Async SMTP obj");
        delete m_pDNS_RESOLVER_RECORD;
        m_pDNS_RESOLVER_RECORD = NULL;
    }
    DBG_CODE(else DebugTrace((LPARAM) this, "No DNS_RESOLVER_RECORD set for Async SMTP obj"));

    if(m_pszSSLVerificationName)
        delete [] m_pszSSLVerificationName;

    m_pServiceInstance->RemoveAsyncDnsObject(this);
    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      HandleCompletedData is called when the DNS resolve is finished. It
//      does the final processing after DNS is finished, and sets the
//      m_dwDiagnostic flag appropriately. It does one of three things based
//      on the DnsStatus and m_AuxList:
//
//      (1) If the resolve was successful, it kicks off a connection to the
//          server and set the m_dwDiagnostic to ERROR_SUCCESS.
//      (2) If the resolve failed authoritatively, it set the m_dwDiagnostic
//          to NDR the messages (after checking for a smarthost) ==
//          AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND.
//      (3) If the resolve failed (from dwDnsStatus and m_AuxList) or if
//          something fails during HandleCompletedData, the m_dwDiagnostic is
//          not modified (it remains initialized to AQUEUE_E_DNS_FAILURE, the
//          default error code).
//
//      m_dwDiagnostic is examined in ~CAsyncSmtpDns.
//  Arguments:
//      DNS_STATUS dwDnsStatus - Status code from DnsParseMessage
//  Returns:
//      Nothing.
//-----------------------------------------------------------------------------
void CAsyncSmtpDns::HandleCompletedData(DNS_STATUS dwDnsStatus)
{
    BOOL fRet = FALSE;
    CAsyncMx * pAsyncCon = NULL;
    MXPARAMS Params;
    DWORD dwPostDnsSmartHost = INADDR_NONE;

    // +3 for enclosing [] and NULL termination
    CHAR szPostDnsSmartHost[IP_ADDRESS_STRING_LENGTH + 3];

    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::HandleCompletedData");

    //
    // The DNS lookup failed authoritatively. The messages will be NDR'ed unless there
    // is a smarthost configured. If there is a smarthost, we will kick off a resolve
    // for it.
    //
    if(ERROR_NOT_FOUND == dwDnsStatus)
    {
        if(m_fConnectToSmartHost)
        {
            char szSmartHost[MAX_PATH+1];

            m_pServiceInstance->GetSmartHost(szSmartHost);
            ((REMOTE_QUEUE *)m_pServiceInstance->QueryRemoteQObj())->StartAsyncConnect(szSmartHost, 
                m_pISMTPConnection, m_DomainOptions, FALSE);

            //Do not release this ISMTPConnection object! We passed it on to 
            //StartAsyncConnect so that it can try to associate this object with 
            //a connection with the smart host. We set it to null here so that we
            //will not release it or ack it in the destructor of this object.
            m_pISMTPConnection = NULL;
            m_dwDiagnostic = ERROR_SUCCESS;
            TraceFunctLeaveEx((LPARAM) this);
            return;
        } else {
            //No smart host, messages will be NDR'ed. Return value is meaningless.
            m_dwDiagnostic = AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND;
            TraceFunctLeaveEx((LPARAM) this);
            return;
        }
    }

    //Successful DNS lookup.
    if(dwDnsStatus == ERROR_SUCCESS && m_AuxList)
    {
        //
        // The post-DNS smart host is useful for testing DNS. It allows us
        // to exercise the DNS resolution codepath and yet send to a smarthost.
        // If a smarthost is specified, we will allocate a new TempList struct
        // and fill it in with the IP address.
        //

        if(m_pServiceInstance->GetPostDnsSmartHost(
            szPostDnsSmartHost, sizeof(szPostDnsSmartHost)))

        {
            DeleteDnsRec(m_AuxList);

            // Note: Literal IP must be enclosed in brackets: []
            m_AuxList = GetDnsRecordsFromLiteral(szPostDnsSmartHost);
            if(!m_AuxList)
            {
                ErrorTrace((LPARAM) this, "Can't convert %s to IP", szPostDnsSmartHost);
                TraceFunctLeaveEx((LPARAM) this);
                return;
            }
        }

        if(m_RetryParams.m_pIMsg)
        {
            m_AuxList->pMailMsgObj = m_RetryParams.m_pIMsg;
            m_AuxList->pAdvQContext = m_RetryParams.m_pAdvQContext;
            m_AuxList->pRcptIdxList = m_RetryParams.m_pRcptIdxList;
            m_AuxList->dwNumRcpts = m_RetryParams.m_dwNumRcpts;
        }

        CrashOnInvalidSMTPConn(m_pISMTPConnection);

        Params.HostName = "";
        Params.PortNum = m_pServiceInstance->GetRemoteSmtpPort();
        Params.TimeOut = INFINITE;
        Params.CallBack = QueueCallBackFunction;
        Params.pISMTPConnection = m_pISMTPConnection;
        Params.pInstance = m_pServiceInstance;
        Params.pDnsRec = m_AuxList;
        Params.pDNS_RESOLVER_RECORD = m_pDNS_RESOLVER_RECORD; 

        pAsyncCon = new CAsyncMx (&Params);
        if(pAsyncCon != NULL)
        {
            //  Abdicate responsibility for deleting outbound params
            m_pDNS_RESOLVER_RECORD = NULL;
            m_AuxList = NULL;
            if(m_RetryParams.m_pIMsg)
                ZeroMemory((PVOID) &m_RetryParams, sizeof(m_RetryParams));

            //  Outbound SSL: Set name against which server cert. should matched
            fRet = pAsyncCon->Init(m_pszSSLVerificationName);
            if(!fRet)
            {
                delete pAsyncCon;
                goto Exit;
            }
            
            if(!m_fConnectToSmartHost)
            {
                pAsyncCon->SetTriedOnFailHost();
            }

            pAsyncCon->SetDomainOptions(m_DomainOptions);

            fRet = pAsyncCon->InitializeAsyncConnect();
            if(!fRet)
            {
                delete pAsyncCon;
            }
            else
            {
                // We should not Ack this in the destructor
                m_pISMTPConnection = NULL;
                m_dwDiagnostic = ERROR_SUCCESS;
            }
        }
        else
        {
            DeleteDnsRec(m_AuxList);
        }
    }
Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return;
}

//------------------------------------------------------------------------------
//  Description:
//      Simple wrapper function for DnsQueryAsync. This is a virtual function
//      called from CAsyncDns but implemented in CAsyncSmtpDns. In order to retry
//      a DNS query we need all the parameters of the old query. These are members
//      of CAsyncSmtpDns. Thus the virtual function based implementation.
//
//  Arguments:
//      BOOL fUdp -- Use UDP as transport for retry query?
//
//  Returns:
//      TRUE on success. In this situation the ISMTPConnection ack (and release of
//          pDNS_RESOLVER_RECORD) is handled by the new CAsyncSmtpDns object created
//          by DnsQueryAsync. The diagnostic code of this object is cleared.
//
//      FALSE on error. In this case, the cleanup for ISMTPConnection and
//          pDNS_RESOLVER_RECORD must be done by "this" CAsyncSmtpDns. The
//          diagnostic code is not touched.
//------------------------------------------------------------------------------
BOOL CAsyncSmtpDns::RetryAsyncDnsQuery(BOOL fUdp)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::RetryAsyncDnsQuery");
    BOOL fRet = FALSE;
    RETRYPARAMS *pRetryParams = NULL;

    //
    // If all DNS servers are down, we shouldn't call DnsQueryAsync. This is
    // because DnsQueryAsync guarantees that if nothing is up, it will try to
    // query one of the down DNS servers (so that *something* happens). This
    // is fine when the resolve is happening for the first time (after getting
    // a remote-queue from AQueue), but on the retry code-path, this will cause
    // us to loop. That is why we return immediately if there are no DNS servers.
    //

    if(GetDnsList()->GetUpServerCount() == 0)
    {
        // How to ack the connection
        m_dwDiagnostic = AQUEUE_E_NO_DNS_SERVERS;
        return FALSE;
    }

    //
    //  If we do not have a connection object, then the requery attempt
    //  is doomed to fail. This can happen when we disconnect and 
    //  ATQ calls our completion function with ERROR_OPERATION_ABORTED
    //  If we don't have a connection object, there is no way to 
    //  ack the connection or get messages to send.
    //
    if (!m_pISMTPConnection) {
        DebugTrace((LPARAM) this, 
            "RetryAsyncDnsQuery called without connection object - aborting");
        //should be cleared by same code path
        _ASSERT(!m_pDNS_RESOLVER_RECORD); 
        fRet = FALSE; //there is nothing to Ack.
        goto Exit;
    }

    // Pass in failover message params if any
    if(m_RetryParams.m_pIMsg)
        pRetryParams = &m_RetryParams;

    fRet = DnsQueryAsync(
                m_pServiceInstance,
                m_HostName,
                m_FQDNToDrop,
                m_pISMTPConnection,
                m_dwFlags,
                m_DomainOptions,
                m_fConnectToSmartHost,
                m_pDNS_RESOLVER_RECORD,
                m_pszSSLVerificationName,
                pRetryParams,
                fUdp);

    if(fRet) {
        m_pDNS_RESOLVER_RECORD = NULL;
        m_pISMTPConnection = NULL;
        m_dwDiagnostic = ERROR_SUCCESS;
        ZeroMemory((PVOID) &m_RetryParams, sizeof(m_RetryParams));
    }

  Exit:
    TraceFunctLeave();
    return fRet;
}

DWORD CTcpRegIpList::ConnectsAllowedInProbation()
{
    return g_DnsConnectsInProbation;
}

DWORD CTcpRegIpList::ErrorsBeforeFailover()
{
    return g_DnsErrorsBeforeFailover;
}

void CTcpRegIpList::LogServerDown(
    DWORD dwServerIp,
    BOOL fUdp,
    DWORD dwErr,
    DWORD cUpServers)
{
    const CHAR *pszProtocol = NULL;
    LPSTR pszServerIp = NULL;
    in_addr inAddrIpServer;
    const CHAR *apszSubStrings[2];
    CHAR szEventKey[32];
    int nBytes = 0;

    TraceFunctEnterEx((LPARAM)this, "CTcpRegIpList::LogServerDown");
    // Log event informing that DNS server is out
    CopyMemory(&inAddrIpServer, &dwServerIp, sizeof(DWORD));
    pszServerIp = inet_ntoa(inAddrIpServer);

    if(!pszServerIp)
    {
        ErrorTrace((LPARAM)this, "Unable to allocate pszServerIp");
        return;
    }

    pszProtocol = fUdp ? "UDP" : "TCP";
    apszSubStrings[0] = pszServerIp;
    apszSubStrings[1] = pszProtocol;

    //
    // Generate a unique key for this event. If a given server goes down
    // we will end up logging this warning every 10 minutes (the retry
    // time for a down server). This will spam the log. Therefore, we
    // call TriggerLogEvent with the PERIODIC flag. This causes all events
    // with the same szEventKey to be logged only once per hour. The
    // following key is unique for a server-IP/tranport combination.
    //

    nBytes = _snprintf(szEventKey, sizeof(szEventKey), "DNS %08x %1x",
                    inAddrIpServer, fUdp ? 1 : 0);

    // Guard against future errors. Currently nBytes is guaranteed to be 14 
    if(nBytes < 0) {
        szEventKey[(sizeof(szEventKey)) - 1] = '\0';
        _ASSERT(0 && "szEventKey buffer too small");
    }

    g_EventLog.LogEvent(
        SMTP_DNS_SERVER_DOWN,   // Message ID
        2,                      // # of substrings
        apszSubStrings,         // Substrings
        EVENTLOG_WARNING_TYPE,  // Type of event
        dwErr,                  // Error code
        LOGEVENT_LEVEL_MEDIUM,  // Logging level
        szEventKey,             // Key to this event
        LOGEVENT_FLAG_PERIODIC, // Logging option
        (-1),                   // Substring index for dwErr (unused)
        GetModuleHandle("SMTPSVC")); // Module
        
        
    ErrorTrace((LPARAM) this,
        "Received error %d connecting to DNS server %s over %s",
        dwErr, pszServerIp, pszProtocol);

    if(cUpServers == 0) {

        // Log this only once an hour

        g_EventLog.LogEvent(
            SMTP_NO_DNS_SERVERS,        // Message ID
            0,                          // # of substrings
            NULL,                       // Type of event
            EVENTLOG_ERROR_TYPE,        // Type of event
            DNS_ERROR_NO_DNS_SERVERS,   // Error code
            LOGEVENT_LEVEL_MEDIUM,      // Logging level
            "DNS No Servers",           // Key to this event
            LOGEVENT_FLAG_PERIODIC,     // Logging option
            (-1),                       // Substring index for dwErr (unused)
            GetModuleHandle("SMTPSVC")); // Module

        ErrorTrace((LPARAM) this, "All DNS servers are down");
    }

    TraceFunctLeaveEx((LPARAM)this);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpdef.h ===
/*    Definitions for the SMTP commands

    SMTP commands can be added, and deleted by editing the header file
    smtpdef.h.  This header file should never be touched.  Smtpdef.h
    has a table describing every command the smtp serversupports.
    For instance, a few entries in this file contains :

SmtpDef(NEWSMTPCOMMAND1)
SmtpDef(NEWSMTPCOMMAND2)
SmtpDef(NEWSMTPCOMMAND3)
SmtpDef(NEWSMTPCOMMAND4)
SmtpDef(NEWSMTPCOMMANDETC)


    Other source files include atmdef.h, *AFTER* defining the AtmDef macro to extract only
    the value needed.  For instance, below we need an enumeration of all the counters (ATMCOUNTERS).
    Therefore, before including atmdef.h, we make a macro to extract the first element of
    the array :#define SmtpDef(a) a,.  Notice the comma at the end of the #define.  It is
    not a mistake.  It needs to be there to separate each element.

    To define an array of SDef, we do the following :
    enum smtpstate =
     {
      #undef SmtpDef
      #define SmtpDef(a) {a},
      #include "smtpdef.h"
      LastCounter
     };

    Notice that we first have to undefine the previous instance of SmtpDef, then make
    a new defination of the macro, which extracts all the element.  Again, notice the
    comma.  It needs to be there to separate each element.  Also, notice how the array
    is terminated.

    The beauty of doing it this way is because, to add or delete a command, only one file
    has to change.  Not two or three.

    I hope all of this makes sense.

    -Rohan

*/


SmtpDef(EHLO)
SmtpDef(HELO)
SmtpDef(RCPT)
SmtpDef(MAIL)
SmtpDef(AUTH)
SmtpDef(DATA)
SmtpDef(STARTTLS)
SmtpDef(TLS)
SmtpDef(QUIT)
SmtpDef(RSET)
SmtpDef(NOOP)
SmtpDef(VRFY)
SmtpDef(ETRN)
SmtpDef(TURN)
SmtpDef(BDAT)
SmtpDef(HELP)
SmtpDef(_EOD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpcli.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        smtpcli.cxx

   Abstract:

        This module defines the functions for derived class of connections
        for Internet Services  ( class SMTP_CONNECTION)

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:

          SMTP_CONNECTION::~SMTP_CONNECTION()
          BOOL SMTP_CONNECTION::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)

          BOOL SMTP_CONNECTION::StartupSession( VOID)

   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include <issperr.h>
#include "smtpcli.hxx"
#include "headers.hxx"
#include "timeconv.h"
#include "base64.hxx"

#include "smtpout.hxx"
#include <smtpevents.h>
#include <smtpevent.h>
#include <smtpguid.h>

extern "C"
{
#include <secint.h>
}

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

#define IMSG_PROGID L"Exchange.IMsg"
#define MAILMSG_PROGID          L"Exchange.MailMsg"

extern CHAR g_VersionString[];

// provide memory for static declared in SMTP_CONNECTION
CPool  SMTP_CONNECTION::Pool(CLIENT_CONNECTION_SIGNATURE_VALID);

static char * HelpText= "214-This server supports the following commands:\r\n"
                        "214 HELO EHLO STARTTLS RCPT DATA RSET MAIL QUIT HELP";

static char * Daynames[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

static const char * SMTP_TOO_MANY_RCPTS   = "Too many recipients";
static const char * PasswordParam = "Password:";
static const char * UserParam = "Username:";

static LONG g_NumRoutingThreads = 0;

LONG g_cProcessClientThreads = 0;

// Format strings for "Received:" lines
static const char szFormatReceivedFormatSuccess[] = "Received: from %s ([%s]) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";
static const char szFormatReceivedFormatUnverified[] = "Received: from %s ([%s] unverified) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";
static const char szFormatReceivedFormatFailed[] = "Received: from %s ([%s] RDNS failed) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";

// Search strings to identify our own "Received:" lines (subsections of above lines)
static const char szFormatReceivedServer[] = ") by %s";
static const char szFormatReceivedService[] = " with Microsoft SMTPSVC(";

// Amount of time (FILETIME / 100ns units) we wait if we detect a looping message
#define SMTP_LOOP_DELAY 6000000000 // == 10 minutes

#define SMTP_TIMEOUT 99
#define SMTP_CONTENT_FILE_IO_TIMEOUT 5*60*1000

#define ATQ_LOCATOR (DWORD)'Dd9D'

//ATQ Write file modes
#define BLOCKING 0
#define NONBLOCKING 1

//Trailer byte status
#define CRLF_NEEDED        0
#define CR_SEEN            1
#define CRLF_SEEN          2
#define CR_MISSING         3

#define WHITESPACE " \t\r\n"

/************************************************************
 *    Functions
 ************************************************************/

extern void GenerateMessageId (char * Buffer, DWORD BuffLen);
extern DWORD GetIncreasingMsgId();
extern VOID InternetCompletion(PVOID pvContext, DWORD cbWritten,
                        DWORD dwCompletionStatus, OVERLAPPED * lpo);

/*++

    Name:

    SMTP_CONNECTION::SMTP_CONNECTION

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

--*/
SMTP_CONNECTION::SMTP_CONNECTION(
        IN PSMTP_SERVER_INSTANCE pInstance,
        IN SOCKET sClient,
        IN const SOCKADDR_IN *  psockAddrRemote,
        IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
        IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
        IN PVOID                pvInitialRequest/* = NULL*/ ,
        IN DWORD                cbInitialData  /* = 0    */
        )
 : m_encryptCtx(FALSE),
   m_securityCtx(pInstance,
                TCPAUTH_SERVER| TCPAUTH_UUENCODE,
                 ((PSMTP_SERVER_INSTANCE)pInstance)->QueryAuthentication()),
   CLIENT_CONNECTION ( sClient, psockAddrRemote,
                        psockAddrLocal,  pAtqContext,
                        pvInitialRequest, cbInitialData )
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::SMTP_CONNECTION");
    DebugTrace( (LPARAM)this, "New connection created");

    _ASSERT(pInstance != NULL);

    //
    // By default, we use the smallish receive buffer inherited from
    // the case CLIENT_CONNECTION object.
    //
    m_precvBuffer = m_recvBuffer;
    m_cbMaxRecvBuffer = sizeof(m_recvBuffer);
    m_pOutputBuffer = m_OutputBuffer;
    m_cbMaxOutputBuffer =  sizeof(m_OutputBuffer);

    m_pIMsg = NULL;
    m_pIMsgRecips = NULL;
    m_szHeloAddr[0] = '\0';
//    m_FromAddr = NULL;
    m_szFromAddress[0] = '\0';
    m_pszArgs = NULL;
    m_pInstance = pInstance;
    m_IMsgHandle = NULL;
    m_pBindInterface = NULL;
    m_cbRecvBufferOffset = 0;
    m_pFileWriteBuffer = NULL;
    m_pFileWriteBuffer = new CBuffer();

    m_HopCount = 0;
    m_LocalHopCount = 0;

    if(!m_pFileWriteBuffer)
    {
        ErrorTrace((LPARAM)this, "Failed to get the write buffer Err : %d",
                      GetLastError());
        _ASSERT(0);
    }
    m_AtqLocator = ATQ_LOCATOR;


    // inbound protocol extension related initializations
    m_fAsyncEventCompletion = FALSE;
    m_fAsyncEOD = FALSE;
    m_fIsPeUnderway = FALSE;
    m_pIEventRouter = NULL;
    m_pCInboundDispatcher = NULL;
    // m_CInboundContext is a data member
    m_fPeBlobReady = FALSE;
    m_pPeBlobCallback = NULL;

    ZeroMemory(&m_FileOverLapped, sizeof(m_FileOverLapped));

    m_FileOverLapped.SeoOverlapped.Overlapped.pfnCompletion = SmtpCompletionFIO;
    m_FileOverLapped.SeoOverlapped.ThisPtr = this;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_szUsedAuthKeyword[0] = '\0';
    m_szAuthenticatedUserNameFromSink[0] = '\0';

    //keep track of per instance connection object
    pInstance->IncConnInObjs();

    TraceFunctLeaveEx((LPARAM) this);
}

SMTP_CONNECTION::~SMTP_CONNECTION (void)
{
    PSMTP_SERVER_INSTANCE pInstance = NULL;
    CAddr * pAddress = NULL;
    char *pTempBuffer = NULL;
//    CBuffer * pBuff;

    TraceFunctEnterEx((LPARAM)this, "~SMTP_CONNECTION");

    ReleasImsg(TRUE);

    /*
    pAddress = (CAddr *) InterlockedExchangePointer((PVOID *) &m_FromAddr, (PVOID) NULL);
    if(pAddress != NULL)
    {
        delete pAddress;
    }*/

    pInstance = (PSMTP_SERVER_INSTANCE ) InterlockedExchangePointer((PVOID *) &m_pInstance, (PVOID) NULL);
    if(pInstance != NULL)
    {
        pInstance->DecrementCurrentConnections();
        pInstance->DecConnInObjs();
        pInstance->Dereference();
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_precvBuffer, (PVOID) &m_recvBuffer[0]);
    if (pTempBuffer != m_recvBuffer) {
        delete [] pTempBuffer;
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_pOutputBuffer, (PVOID) &m_OutputBuffer[0]);
    if (pTempBuffer != m_OutputBuffer) {
        delete [] pTempBuffer;
    }

    if(m_pFileWriteBuffer)
    {
        delete m_pFileWriteBuffer;
    }

    if ( NULL != m_pPeBlobCallback) {
        m_pPeBlobCallback->Release();
    }

    if(m_pCInboundDispatcher)
        m_pCInboundDispatcher->Release();

    if(m_pProviderPackagesInfo)
        m_pProviderPackagesInfo->Release();

    DebugTrace( (LPARAM)this, "Connection deleted");
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_CONNECTION::InitializeObject

    Description:
       Initializes all member variables and pre-allocates
       a mail context class

    Arguments:


    Returns:

       TRUE if memory can be allocated.
       FALSE if no memory can be allocated
--*/
BOOL SMTP_CONNECTION::InitializeObject (BOOL IsSecureConnection)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::InitializeObject");

    _ASSERT(m_pInstance != NULL);

    StartProcessingTimer();

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_cbTempBDATLen = 0;
    m_OutputBufferSize = 0;
    m_cbCurrentWriteBuffer = 0;
    m_TotalMsgSize = 0;
    m_SessionSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_ProtocolErrors = 0;
    m_dwUnsuccessfulLogons = 0;
    m_HeaderSize = 0;
    m_cPendingIoCount = 0;
    m_cActiveThreads = 0;
    m_CurrentOffset = 0;
    m_HelloSent = FALSE;
    m_RecvdMailCmd = FALSE;
    m_RecvdAuthCmd = FALSE;
    m_Nooped = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_RecvdRcptCmd = FALSE;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenRFC822SenderAddress = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_HeaderFlags = 0;
    m_MailBodyError = NO_ERROR;
    m_State = HELO;
    m_NeedToQuit = FALSE;
    m_pSmtpStats = NULL;
    m_WritingData = FALSE;
    //m_fReverseDnsFailed = FALSE;
    m_DNSLookupRetCode = SUCCESS;
    m_fUseMbsCta = FALSE;
    m_fAuthenticated = FALSE;
    m_fMayRelay = FALSE;
    m_fClearText = FALSE;
    m_fDidUserCmd = FALSE;
    m_fAuthAnon = FALSE;
    m_SecurePort = IsSecureConnection;
    m_fNegotiatingSSL = m_SecurePort;
    m_szUsedAuthKeyword[0] = '\0';
    m_cbRecvBufferOffset = 0;
    m_fPeBlobReady = FALSE;
    if ( NULL != m_pPeBlobCallback) {
        m_pPeBlobCallback->Release();
    }
    m_pPeBlobCallback = NULL;

    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_fBufferFullInBDAT = FALSE;
    m_fRecvBufferFull = FALSE;

    m_pInstance->LockGenCrit();

    if(m_pInstance->QueryAuthentication() & INET_INFO_AUTH_ANONYMOUS)
    {
        m_fAuthAnon = TRUE;
    }

    // Advertise this property to sinks (EXPS)
    HrSetISessionProperty(ISESSION_PID_ANONYMOUS_AUTH, m_fAuthAnon);

    //
    // Copy IP Address for instance and remote into session
    //
    CopyIPAddressesToSession();

    //
    //   Initialize Security Context
    //

    m_pProviderPackagesInfo = m_pInstance->GetAddRefdProviderPackagesInfo();
    if(!m_pProviderPackagesInfo)
    {
        fRet = FALSE;
        goto Exit;
    }

    if (!m_securityCtx.SetInstanceAuthPackageNames(
              m_pProviderPackagesInfo->GetProviderPackagesCount(),
              m_pProviderPackagesInfo->GetProviderNames(),
              m_pProviderPackagesInfo->GetProviderPackages()))
     {
          ErrorTrace((LPARAM)this, "SetInstanceAuthPackageNames FAILED <Err=%u>",
                  GetLastError());
          fRet = FALSE;
          goto Exit;
     }

    //
    // We want to set up the Cleartext authentication package
    // for this connection based on the instance configuration.
    // To enable MBS CTA,
    // MD_SMTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
    // To disable it, the md value must be set to "".
    //

    m_securityCtx.SetCleartextPackageName(
    m_pInstance->GetCleartextAuthPackage(),
    m_pInstance->GetMembershipBroker());

    if (*m_pInstance->GetCleartextAuthPackage() == '\0' ||
    *m_pInstance->GetMembershipBroker() == '\0')
    {
        m_fUseMbsCta = FALSE;
    }
    else
    {
        m_fUseMbsCta = TRUE;
    }

Exit:
    m_pInstance->UnLockGenCrit();

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::CreateSmtpConnection

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNECTION
       class.  This class cannot be allocated on the stack.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.


    Returns:

       A pointer to an SMTP_CONNECTION class or NULL
--*/
SMTP_CONNECTION * SMTP_CONNECTION::CreateSmtpConnection (IN PCLIENT_CONN_PARAMS ClientParams,
                                                         IN PSMTP_SERVER_INSTANCE pInst)
{
    SMTP_CONNECTION * pSmtpObj = NULL;
    PIIS_ENDPOINT   pTmpEndPoint = NULL;

    pSmtpObj = new SMTP_CONNECTION (pInst, ClientParams->sClient, (const SOCKADDR_IN *) ClientParams->pAddrRemote, (const SOCKADDR_IN *) ClientParams->pAddrLocal,
                                    ClientParams->pAtqContext, ClientParams->pvInitialBuff, ClientParams->cbInitialBuff);

    if(pSmtpObj == NULL)
     {
       SetLastError (ERROR_NOT_ENOUGH_MEMORY);
       return NULL;
     }

    pTmpEndPoint = (PIIS_ENDPOINT)ClientParams->pEndpoint;

    if(!pSmtpObj->InitializeObject(FALSE))
     {
        delete pSmtpObj;
        return NULL;
     }

    return pSmtpObj;
}


#define MAX_LOG_ERROR_LEN (500)

void SMTP_CONNECTION::TransactionLog(
        const char *pszOperation,
        const char *pszParameters,
        const char *pszTarget,
        DWORD dwWin32Error,
        DWORD dwServiceSpecificStatus
        )
{
    INETLOG_INFORMATION translog;
    DWORD  dwLog;
    DWORD cchError = MAX_LOG_ERROR_LEN;
    char VersionString[] = "SMTP";
    char szParametersBuffer[1024] = "";   //Data portion of buffer information

    ZeroMemory(&translog, sizeof(translog));

    translog.pszVersion = VersionString;
    translog.pszClientHostName = (char *) QueryClientHostName();
    translog.cbClientHostName = lstrlen(translog.pszClientHostName);
    translog.pszClientUserName = (char *) QueryClientUserName();
    translog.pszServerAddress = (char *) QueryLocalHostName();

    translog.pszOperation = (char *)pszOperation;
    translog.cbOperation = lstrlen ((char *)pszOperation);
    translog.pszTarget = (char *)pszTarget;
    translog.cbTarget = lstrlen ((char *)pszTarget);
    translog.pszParameters = (char *)pszParameters;

    if (pszParameters) {
        lstrcpyn(szParametersBuffer, pszParameters, sizeof(szParametersBuffer)-sizeof(CHAR));
        translog.pszParameters = szParametersBuffer;
    } else {
        translog.pszParameters = "";
    }

    translog.dwBytesSent = m_dwCmdBytesSent;
    translog.dwBytesRecvd = m_dwCmdBytesRecv;
    translog.dwWin32Status = dwWin32Error;

    translog.dwProtocolStatus = dwServiceSpecificStatus;
    translog.msTimeForProcessing = QueryProcessingTime();

    if(QuerySmtpInstance() != NULL)
      dwLog = QuerySmtpInstance()->m_Logging.LogInformation( &translog);
}

/*++

    Name :
        SMTP_CONNECTION::SendSmtpResponse

    Description:
       This function sends data that was queued in the internal
       m_pOutputBuffer buffer

    Arguments:
         SyncSend - Flag that signifies sync or async send

    Returns:

      TRUE if the string was sent. False otherwise
--*/
BOOL SMTP_CONNECTION::SendSmtpResponse(BOOL SyncSend)
{
  BOOL RetStatus = TRUE;
  DWORD cbMessage = m_OutputBufferSize;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::SendSmtpResponse");

  //IncPendingIoCount();

  //if m_OutputBufferSize > 0that means there is
  //something in the buffer, therefore, we will send it.
  if (m_OutputBufferSize)
  {
      //
      // If we are using SSL, encrypt the output buffer now. Note that
      // FormatSmtpMsg already left header space for the seal header.
      //
      if (m_SecurePort && !m_fNegotiatingSSL)
      {
          char *Buffer = &(m_pOutputBuffer[m_encryptCtx.GetSealHeaderSize()]);

          RetStatus = m_encryptCtx.SealMessage(
                            (UCHAR *) Buffer,
                            m_OutputBufferSize,
                            (UCHAR *) m_pOutputBuffer,
                            &cbMessage);
      }

      if (RetStatus) {
          RetStatus = CLIENT_CONNECTION::WriteFile(m_pOutputBuffer, cbMessage);
      }
      if(RetStatus)
      {
        ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, cbMessage);
        AddCommandBytesSent(cbMessage);
      }
      else
      {
         DebugTrace((LPARAM) this, "WriteFile failed with error %d", GetLastError());
      }

      m_OutputBufferSize = 0;
  }

  //DecPendingIoCount();
  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}


BOOL SMTP_CONNECTION::WriteMailFile(char * Buffer, DWORD BuffSize, BOOL *lpfWritePended)
{
    BOOL fResult = FALSE;
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::WriteMailFileBuffer");

    if(!BuffSize && !Buffer)
    {
        //Simply flush the buffers if we have something to flush
        if(!m_cbCurrentWriteBuffer)
        {//Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = FALSE;
            return TRUE;
        }

        if(!WriteMailFileAtq((char*)m_pFileWriteBuffer->GetData(), m_cbCurrentWriteBuffer, NONBLOCKING))
        {
            m_MailBodyError = GetLastError();
            ErrorTrace((LPARAM) this, "Async Write of to mail file failed : %d",m_MailBodyError);
            fResult = FALSE;
        }
        else
        {
            //Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = TRUE;
            fResult = TRUE;
        }
        TraceFunctLeaveEx((LPARAM) this);
        return fResult;
    }

    //If the data to be written can fit in we take it in and come back
    //else we pend a write
    //Though the var name is a result of its original use, we now use this
    //buffer as a WRITEFILE buffer
    if(m_cbCurrentWriteBuffer + BuffSize > SMTP_WRITE_BUFFER_SIZE)
    {
        //Update the input buffers so that we can
        //go back and start processing the input buffers
        //after the async WRITE completes
        //MoveMemory ((void *)QueryMRcvBuffer(), Buffer, m_cbReceived);

        if(!WriteMailFileAtq((char*)m_pFileWriteBuffer->GetData(), m_cbCurrentWriteBuffer, NONBLOCKING))
        {
            *lpfWritePended = FALSE;
            m_MailBodyError = GetLastError();
            ErrorTrace((LPARAM) this, "Async Write of to mail file failed : %d",m_MailBodyError);
            fResult = FALSE;
        }
        else
        {
            //Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = TRUE;
            fResult = TRUE;
        }
    }
    //Copy the data into the buffer only if we have the space to do so
    else
    {
        CopyMemory((m_pFileWriteBuffer->GetData() + m_cbCurrentWriteBuffer),Buffer,BuffSize);
        m_cbCurrentWriteBuffer += BuffSize;
        fResult = TRUE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fResult;
}

/*++

    Name:
        SMTP_CONNECTION::WriteMailFileAtq

    Description:
        While chunking, once header parsing is done the data is
        dumped to the disk asynchronously using WriteMailFileAtq( )

    Arguments:
        None.

    Returns:
        TRUE if successfully pended a write to the file, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::WriteMailFileAtq(char * InputLine, DWORD dwBytesToWrite, DWORD dwIoMode)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNECTION::WriteMailFileAtq");

    DebugTrace( (LPARAM)this, "WriteFile 0x%08X, len: %d, LPO: 0x%08X",
                     InputLine,
                     dwBytesToWrite,
                     m_FileOverLapped.SeoOverlapped );

    //ZeroMemory( (void*)&m_FileOverLapped, sizeof(OVERLAPPED) );
    //if(dwIoMode == BLOCKING)
    //    m_FileOverLapped.SeoOverlapped.Overlapped.hEvent = (HANDLE)1;

    m_FileOverLapped.SeoOverlapped.Overlapped.Offset = m_CurrentOffset;

    m_FileOverLapped.m_LastIoState = WRITEFILEIO;
    m_FileOverLapped.m_cbIoSize = dwBytesToWrite;
    m_FileOverLapped.m_pIoBuffer = (LPBYTE)InputLine;

    //
    // increment the overall pending io count for this session
    //
    IncPendingIoCount();

    _ASSERT(m_FileOverLapped.SeoOverlapped.Overlapped.pfnCompletion != NULL);
    m_FileOverLapped.SeoOverlapped.ThisPtr = this;

    if (FIOWriteFile(m_IMsgHandle,
                     InputLine,
                     dwBytesToWrite,
                     &(m_FileOverLapped.SeoOverlapped.Overlapped)) == FALSE)
#if 0
    if ( AtqWriteFile(m_pAtqFileContext,
                          InputLine,
                          dwBytesToWrite,
                          (OVERLAPPED *) &(m_FileOverLapped.SeoOverlapped.Overlapped) ) == FALSE)
#endif
    {
        DecPendingIoCount();
        ErrorTrace( (LPARAM)this, "AtqWriteFile failed.");
    }
    else
    {
        TraceFunctLeaveEx((LPARAM) this);
        return  TRUE;
    }

    ErrorTrace( (LPARAM)this, "WriteMailFileAtq failed. err: %d", GetLastError() );

    if(!HandleInternalError(GetLastError()))
        DisconnectClient();

    TraceFunctLeaveEx((LPARAM)this);

    return  FALSE;
}

/*++

    Name:
        SMTP_CONNECTION::HandleInternalError

    Description:
        Contains code to handle common error conditions during inbound message flow.

    Arguments:
        [IN] DWORD Error code

    Returns:
        TRUE if error was handled
        FALSE otherwise

--*/
BOOL SMTP_CONNECTION::HandleInternalError(DWORD dwErr)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleInternalError");
    if(dwErr == ERROR_DISK_FULL)
    {
        FormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " Unable to accept message because the server is out of disk space.\r\n");
        ErrorTrace((LPARAM) this, "Rejecting message: Out of disk space");
        SendSmtpResponse();
        DisconnectClient();
        return TRUE;
    }
    return FALSE;
}

#if 0
/*++

    Name :
        SMTP_CONNECTION::FreeAtqFileContext

    Description :
        Frees AtqContext associated with message file used for doing async writes
        in case of chunking.

    Arguments :
        None. Operates on m_pAtqFileContext

    Returns :
        Nothing

--*/

void SMTP_CONNECTION::FreeAtqFileContext( void )
{
    PFIO_CONTEXT    pFIO;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::FreeAtqFileContext");

    pFIO = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pIMsgHandle, NULL );
    if ( pFIO != NULL )
    {
        DebugTrace((LPARAM) this, "Freeing AtqFileContext!");
        ReleaseContext(pFIO);
    }

    TraceFunctLeaveEx((LPARAM) this);
}
#endif

void SMTP_CONNECTION::ReInitClassVariables(void)
{
    _ASSERT (m_pInstance != NULL);


    //reset all variables to their initial state
    m_HeaderFlags = 0;
    m_TotalMsgSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_CurrentOffset = 0;
    m_State = HELO;
    m_RecvdMailCmd = FALSE;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_fSeenRFC822SenderAddress = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_MailBodyError = NO_ERROR;
    m_RecvdRcptCmd = FALSE;
    m_WritingData = FALSE;
    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;
    m_cbCurrentWriteBuffer = 0;
    m_cbRecvBufferOffset = 0;
    m_fAsyncEOD = FALSE;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_fBufferFullInBDAT = FALSE;

    //Clear the senders address if it's
    //still there.

    m_szFromAddress[0] = '\0';

    ReleasImsg(TRUE);
}


/*++

    Name :
        SMTP_CONNECTION::SmtpGetCommand

    Description:
       This function determines which SMTP input command was sent
       by the client

    Arguments:
         Request - Buffer the client sent
         RequestLen - Length of the buffer

    Returns:

      Index into our array of function pointers
--*/
int SMTP_CONNECTION::SmtpGetCommand(const char * Request, DWORD RequestLen, LPDWORD CmdSize)
{
  DWORD Loop = 0;
  char Cmd[SMTP_MAX_COMMANDLINE_LEN];
  char * ptr = NULL;
  char *psearch = NULL;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::SmtpGetCommand");

   //start out with no errors
  CommandErrorType = SMTP_COMMAND_NOERROR;

  //we will copy the command into Cmd starting from
  //the beginning
  ptr = Cmd;

  //start looking for the space from the beginning
  //of the buffer
  psearch = (char *) Request;

  //search for the command and copy it into Cmd.  We stop
  //looking when we encounter the first space.
  while (*psearch != '\0' && !isspace ((UCHAR) *psearch) && ptr < &Cmd[SMTP_MAX_COMMANDLINE_LEN - 2])
      *ptr++ = *psearch++;

  //null terminate the buffer
  *ptr = '\0';

  //now, look through the list of SMTP commands
  //and compare it to what the client gave us.
  while (SmtpCommands[Loop] != NULL)
    {
        if (!::strcasecmp((char *) Cmd, (char * )SmtpCommands[Loop]))
        {
            goto Exit;
        }

        Loop++;
    }

    //set error to COMMAND_NOT FOUND if we do not recognize the command
    CommandErrorType = SMTP_COMMAND_NOT_FOUND;

Exit:

  //If no error, send back the index in the array
  //If there was an error, send back the index of
  //the last element in the array.  This is our
  //catch all error function.
  if (CommandErrorType == SMTP_COMMAND_NOERROR)
  {
    *CmdSize = DWORD (ptr - Cmd);
    TraceFunctLeaveEx((LPARAM) this);
    return Loop;
  }
  else
   {
    //
    // This is not always an error since a protocol sink may be installed
    //
    DebugTrace((LPARAM) this, "Native command %s was not found in command table", Cmd);
    TraceFunctLeaveEx((LPARAM) this);
    return (DWORD) LAST_SMTP_STATE;
   }

}


/*++

    Name :
        SMTP_CONNECTION::FormatSmtpMessage( IN const char * Format, ...)

    Description:
        This function will build a sting in the output buffer with
        the given input parameters.  If the new data cannot fit in the
        buffer, this function will send whatever data is in the buffer,
        then build the string.

    Arguments:
        String to send

    Returns:

      TRUE if response was queued
--*/
BOOL SMTP_CONNECTION::FormatSmtpMessage(DWORD dwCode, const char * szEnhancedCodes, IN const char * Format, ...)
{
    int BytesWritten;
    va_list arglist;
    char *Buffer;
    DWORD AvailableBytes;
    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);
    char RealFormat[MAX_PATH];
    RealFormat[0] = '\0';

    //If we get passed dwCode we use it
    //If we get passed enhance status code only if we advertise them
    //
    if(dwCode)
    {
        if(m_pInstance->AllowEnhancedCodes() && szEnhancedCodes)
        {
            sprintf(RealFormat,"%d %s",dwCode,szEnhancedCodes);
        }
        else
            sprintf(RealFormat,"%d",dwCode);
    }
    strcat(RealFormat,Format);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    va_start (arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, (const char *)RealFormat, arglist);
    if(BytesWritten < 0)
    {
      //flush any pending response
      SendSmtpResponse();
      _ASSERT (m_OutputBufferSize == 0);
      Buffer = &m_pOutputBuffer[HeaderOffset];
      AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
      BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
      _ASSERT (BytesWritten > 0);
    }
    va_end(arglist);

    m_OutputBufferSize += (DWORD) BytesWritten;

    //m_OutputBufferSize += vsprintf (&m_pOutputBuffer[m_OutputBufferSize], Format, arglist);

    return TRUE;
}

BOOL SMTP_CONNECTION::FormatSmtpMessage(unsigned char *DataBuffer, DWORD dwBytes)
{
    int BytesWritten = 0;
    char *Buffer;
    DWORD AvailableBytes = 0;
    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    if( dwBytes + 2 < AvailableBytes)//+2 for CRLF
    {
        CopyMemory(Buffer, DataBuffer, dwBytes);
        Buffer[dwBytes] = '\r';
        Buffer[dwBytes + 1] = '\n';
        BytesWritten  = dwBytes + 2;

    }
    else
    {
      //flush any pending response

      SendSmtpResponse();
      _ASSERT (m_OutputBufferSize == 0);
      Buffer = &m_pOutputBuffer[HeaderOffset];
      AvailableBytes = max(dwBytes, m_cbMaxOutputBuffer - SealOverhead - 2);
      CopyMemory(Buffer, DataBuffer, AvailableBytes);
      Buffer[dwBytes] = '\r';
      Buffer[dwBytes + 1] = '\n';
      BytesWritten  = dwBytes + 2;
      _ASSERT (BytesWritten > 0);
    }

    m_OutputBufferSize += (DWORD) BytesWritten;
    return TRUE;
}

BOOL SMTP_CONNECTION::PE_FastFormatSmtpMessage(LPSTR pszBuffer, DWORD dwBytes)
{
    LPSTR    Buffer;
    DWORD    BytesWritten = 0;
    DWORD    AvailableBytes = 0;
    DWORD    HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD    SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);
    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    // Write as many buffers as we need to
    while (BytesWritten < dwBytes)
    {
        if ((dwBytes - BytesWritten) <= AvailableBytes)
        {
            CopyMemory(Buffer, pszBuffer, dwBytes - BytesWritten);
            m_OutputBufferSize += (dwBytes - BytesWritten);
            BytesWritten = dwBytes; // BytesWritten += (dwBytes - BytesWritten)
        }
        else
        {
            // We don't have enough buffer space, so write whatever we have left
            CopyMemory(Buffer, pszBuffer, AvailableBytes);
            BytesWritten += AvailableBytes;
            m_OutputBufferSize += AvailableBytes;
            pszBuffer += AvailableBytes;

            //flush any pending response
            SendSmtpResponse();
            _ASSERT (m_OutputBufferSize == 0);

            Buffer = &m_pOutputBuffer[HeaderOffset];
            AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
        }
    }

    return(TRUE);
}

BOOL SMTP_CONNECTION::DoesClientHaveIpAccess()
{
    AC_RESULT       acIpAccess;
    ADDRESS_CHECK   acAccessCheck;
    METADATA_REF_HANDLER    rfAccessCheck;
    BOOL            fNeedDnsCheck = FALSE;
    BOOL            fRet = TRUE;
    struct hostent* pH = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoesClientHaveIpAccess");

    m_pInstance->LockGenCrit();

    acAccessCheck.BindAddr( (PSOCKADDR)&m_saClient );

    if ( !rfAccessCheck.CopyFrom( m_pInstance->QueryRelayMetaDataRefHandler() ) )
    {
        m_pInstance->UnLockGenCrit();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    m_pInstance->UnLockGenCrit();

    acAccessCheck.BindCheckList( (LPBYTE)rfAccessCheck.GetPtr(), rfAccessCheck.GetSize() );

    acIpAccess = acAccessCheck.CheckIpAccess( &fNeedDnsCheck);
    if ( (acIpAccess == AC_IN_DENY_LIST) ||
                ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) )
    {
        fRet = FALSE;
    }
    else if (fNeedDnsCheck)
    {
        pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)(&m_saClient))->sin_addr),
                          4, PF_INET );
        if(pH != NULL)
        {
            acIpAccess = acAccessCheck.CheckName(pH->h_name);
        }
        else
        {
            acIpAccess = AC_IN_DENY_LIST;
        }
    }

    if ( (acIpAccess == AC_IN_DENY_LIST) ||
                (acIpAccess == AC_NOT_IN_GRANT_LIST))
    {
        fRet = FALSE;
    }

    acAccessCheck.UnbindCheckList();
    rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if(!fRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}


/*++

    Name :
        SMTP_CONNECTION::ProcessReadIO

    Description:
        This function gets a buffer from ATQ, parses the buffer to
        find out what command the client sent, then executes that
        cammnd.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/

BOOL SMTP_CONNECTION::ProcessReadIO(IN      DWORD InputBufferLen,
                                    IN      DWORD dwCompletionStatus,
                                    IN OUT  OVERLAPPED * lpo)
{
    BOOL fReturn = TRUE;
    const char * InputLine;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessReadIO");

    _ASSERT (m_pInstance != NULL);

    m_cbReceived += InputBufferLen;

    // Firewall against bugs where we overflow the read buffer
    if(m_cbReceived > QueryMaxReadSize())
    {
        DisconnectClient();
        _ASSERT(0 && "Buffer overflow");
        return FALSE;
    }

    InputLine = QueryMRcvBuffer();

    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdTotal, InputBufferLen);

    if (!m_fNegotiatingSSL)
    {

        if (m_SecurePort)
        {
            fReturn = DecryptInputBuffer();
        }
        else
        {
            m_cbParsable = m_cbReceived;
            m_SessionSize += InputBufferLen;
        }

        if (fReturn)
        {
            fReturn = ProcessInputBuffer();
        }

    }
    else // negotiating SSL
    {
        //
        // If we are still doing the handshake let CEncryptCtx::Converse handle it.
        // Converse returns in the following situations:
        //
        // o The negotiation succeeded. cbExtra returns the number of bytes that
        //      were not consumed by the SSL handshake. These bytes are "application
        //      data" which should be decrypted and processed by the SMTP protocol.
        //
        // o The negotiation failed. The connection will be dropped.
        //
        // o More data is needed from the client to complete the negotiation. A
        //      read should be posted.
        //

        DWORD   dw;
        BOOL    fMore;
        DWORD   dwBytes = MAX_SSL_FRAGMENT_SIZE;
        BOOL    fApplicationDataAvailable = FALSE;
        DWORD   cbExtra = 0;

        dw = m_encryptCtx.Converse( (LPVOID) InputLine,
                                    m_cbReceived,
                                    (PUCHAR) m_pOutputBuffer,
                                    &dwBytes,
                                    &fMore,
                                    (LPSTR) QueryLocalHostName(),
                                    (LPSTR) QueryLocalPortName(),
                                    (LPVOID) QuerySmtpInstance(),
                                    QuerySmtpInstance()->QueryInstanceId(),
                                    &cbExtra
                                    );

        if ( dw == NO_ERROR )
        {
            //
            // reset the read buffer
            //
            if ( cbExtra )
            {
                fApplicationDataAvailable = TRUE;
                MoveMemory( (PVOID)InputLine, InputLine + (m_cbReceived - cbExtra), cbExtra );
            }
            m_cbReceived = cbExtra;

            //
            // send any bytes required for the client
            //
            if ( dwBytes != 0 )
            {
                WriteFile( m_pOutputBuffer, dwBytes );
            }

            if ( fMore )
            {
                //
                // more handshaking required - repost the read
                //
                _ASSERT( dwBytes != 0 );
            }
            else
            {
                //
                // completed negotiation. Turn off the flag indicating thats
                // what we are doing
                //
                m_fNegotiatingSSL = FALSE;
            }
        }
        else if ( dw == SEC_E_INCOMPLETE_MESSAGE )
        {
            //
            // haven't received the full packet from the client
            //
            _ASSERT( dwBytes == 0 );
        }
        else
        {
            ErrorTrace((LPARAM)this, "SSL handshake failed, Error = %d", dw);
            DisconnectClient( dw );
            fReturn = FALSE;
        }

        if ( fApplicationDataAvailable )
        {
            //
            // Application data is already available, no need to post a read
            //
            fReturn = DecryptInputBuffer();

            if ( fReturn )
                fReturn = ProcessInputBuffer();
        }
        else if (fReturn)
        {
            //
            // If we are continuing, we need to post a read
            //
            _ASSERT (m_cbReceived < QueryMaxReadSize() );

            IncPendingIoCount();

            m_LastClientIo = READIO;
            fReturn = ReadFile( QueryMRcvBuffer() + m_cbReceived,
                                QueryMaxReadSize() - m_cbReceived );

            if (!fReturn)
            {
                DisconnectClient();
                DecPendingIoCount();
            }
        }
        else
        {
            m_CInboundContext.SetWin32Status(dw);
            ProtocolLog(STARTTLS, (char *) QueryClientUserName(), dw, SMTP_RESP_BAD_SEQ, 0, 0);
        }

    }

    return( fReturn );
}

/*++

    Name :
        SMTP_CONNECTION::ProcessFileWrite

    Description:
        Handles completion of an async Write issued against a message file by
        WriteMailFileAtq

    Arguments:
        cbRead              count of bytes read
        dwCompletionStatus  Error code for IO operation
        lpo                 Overlapped structure

    Returns:
        TRUE if connection should stay open
        FALSE if this object should be deleted

--*/
BOOL SMTP_CONNECTION::ProcessFileWrite(
    IN      DWORD       BytesWritten,
    IN      DWORD       dwCompletionStatus,
    IN OUT  OVERLAPPED  *lpo
    )
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::ProcessFileWrite");
    SMTPCLI_FILE_OVERLAPPED * lpFileOverlapped;

    _ASSERT(lpo);
    lpFileOverlapped = (SMTPCLI_FILE_OVERLAPPED*)lpo;


    // In case of async Write to disk file, a successsful completion
    // will always mean all the data has been written out
    // Check for partial completions or errors
    // and Disconnect if something failed
    if( BytesWritten != lpFileOverlapped->m_cbIoSize || dwCompletionStatus != NO_ERROR )
    {
        ErrorTrace( (LPARAM)this,
                    "Message WriteFile error: %d, bytes %d, expected %d",
                    dwCompletionStatus,
                    BytesWritten,
                    lpFileOverlapped->m_cbIoSize );

        //Close the file Handle and disconnect the client
        DisconnectClient();
        return( FALSE );
    }
    else
    {
        DebugTrace( (LPARAM)this,
                    "WriteFile complete. bytes %d, lpo: 0x%08X",
                    BytesWritten, lpo );
    }

    m_CurrentOffset += BytesWritten;


    //We write out of the Write buffer
    //We need throw away the data that was written out and
    //move the remaining data to the start of the buffer
//    if(m_cbReceived)
//      MoveMemory ((void *)QueryMRcvBuffer(), (void *)(QueryMRcvBuffer() + BytesWritten), m_cbReceived);
    m_cbCurrentWriteBuffer = 0;

    //Time to go back and process the remaining data in the buffer
    //Adjust the buffer for the next read only in case of Sync write
    return(ProcessInputBuffer());

}


BOOL SMTP_CONNECTION::PendReadIO(DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::PendReadIO");

    BOOL fReturn = TRUE;

    m_LastClientIo = READIO;

    m_cbReceived = m_cbParsable + UndecryptedTailSize;

    _ASSERT (m_cbReceived < QueryMaxReadSize());

    //increment this IO
    IncPendingIoCount();

    fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, QueryMaxReadSize() - m_cbReceived);
    if(!fReturn)
    {
       DecPendingIoCount();
       DisconnectClient();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNECTION::ProcessInputBuffer

    Description:
        This function takes the receive buffer, parses the buffer to
        find out what command the client sent, then executes that
        command.

    Arguments:
        lpfMailQueued -- On return, TRUE if processing the client command
            caused a mail message to be queued.

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.
--*/
BOOL SMTP_CONNECTION::ProcessInputBuffer(void)
{
    BOOL fReturn = TRUE;
    const char * InputLine;
    DWORD UndecryptedTailSize = m_cbReceived - m_cbParsable;
    BOOL fWritePended = FALSE;
    BOOL fShouldImposeLimit = TRUE;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessInputBuffer");

    if(m_pInstance->GetMaxMsgSizeBeforeClose() > 0 &&
        m_SessionSize > m_pInstance->GetMaxMsgSizeBeforeClose())
    {
        hr = m_pInstance->TriggerMaxMsgSizeEvent(
                GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit );

        if(FAILED(hr) || fShouldImposeLimit)
        {
            m_MailBodyError = ERROR_ALLOTTED_SPACE_EXCEEDED;
            ErrorTrace((LPARAM) this,
                "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d",
                m_SessionSize);
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            m_cbParsable = 0;
            m_cbReceived = 0;

            // Client won't be expecting this, but atleast an admin can tell
            // what's wrong from this response.
            FormatSmtpMessage(SMTP_RESP_NOSTORAGE, ENO_RESOURCES," %s\r\n",
                    SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG);
            SendSmtpResponse();
            DisconnectClient();
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    //Start processing at the point after the temporary BDAT chunk
    InputLine = QueryMRcvBuffer() + m_cbTempBDATLen + m_cbRecvBufferOffset;

    if ( TRUE == m_fPeBlobReady) {
        fReturn = ProcessPeBlob( InputLine, m_cbParsable);
        if ( FALSE == fReturn) {
            TraceFunctLeaveEx( ( LPARAM) this);
            return FALSE;
        }
        MoveMemory ( ( void *) QueryMRcvBuffer(), InputLine + m_cbParsable, UndecryptedTailSize);
        m_cbParsable = 0;
        m_cbReceived = UndecryptedTailSize;
        //  always pend a read in this state regardless of previous fReturn
        fReturn = PendReadIO( UndecryptedTailSize);
        TraceFunctLeaveEx( ( LPARAM) this);
        return fReturn;
    }

    if (m_State == DATA)
    {
        BOOL fAsyncOp = FALSE;

        fReturn = ProcessDATAMailBody(InputLine, UndecryptedTailSize, &fAsyncOp);
        if(!fReturn || fAsyncOp)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return fReturn;
        }

        //
        // There is additional data pipelined behind the mailbody. DoDATACommandEx
        // moves this to the beginning of the input buffer after processing the
        // mail body, so the place to begin parsing is m_pRecvBuffer.
        //

        InputLine = QueryMRcvBuffer();
        _ASSERT(m_State == HELO);
    }

PROCESS_BDAT:

    if(m_State == BDAT && !m_fIsChunkComplete)
    {
        BOOL fAsyncOp = FALSE;

        fReturn = ProcessBDATMailBody(InputLine, UndecryptedTailSize, &fAsyncOp);
        if(!fReturn || fAsyncOp)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return fReturn;
        }

        //
        // All the mailbody was processed and the input buffer points to the
        // next SMTP command after readjusting for any *saved* BDAT data (If a
        // header spans 2 chunks, ProcessBDAT will save the partial header from
        // the previous chunk till it can complete it using the next chunk.
        // m_cbTempBdatLen represents the number of saved bytes)
        //

        InputLine = QueryMRcvBuffer() + m_cbTempBDATLen;
    }
    else if(m_State == AUTH)
    {
        fReturn = DoAuthNegotiation(InputLine, m_cbParsable);

        if(!fReturn)
        {
            ++m_ProtocolErrors;
        }

        if(m_State == AUTH)
        {
                fReturn = PendReadIO(UndecryptedTailSize);
                TraceFunctLeaveEx((LPARAM) this);
                return fReturn;
        }
    }

    _ASSERT(m_State != DATA);

     PCHAR pszSearch;
     DWORD IntermediateSize;
     DWORD CmdSize = 0;

     //if we got here, then a read completed.  Process the
     //entire buffer before returning(Pipelining).
     //use to be while ((pszSearch = strstr(QueryRcvBuffer(), CRLF)) != NULL)

     //Reset the the offset ptr into the recv buffer
     //we use this to keeo track of where to continue processing from
     m_cbRecvBufferOffset = 0;
     BOOL fAsyncOp = FALSE;

     while ((pszSearch = IsLineComplete(InputLine,m_cbParsable - m_cbTempBDATLen)) != NULL)
     {
            //Null terminate the end of the command
            *pszSearch = '\0';

            IntermediateSize = (DWORD)(pszSearch - InputLine);
            StartProcessingTimer();
            ResetCommandCounters();
            SetCommandBytesRecv( IntermediateSize );

            if(!SmtpParseCompleteCommand((PCHAR)InputLine, pszSearch, IntermediateSize, &CmdSize))
            {
                ErrorTrace((LPARAM)this, "Discarding illegal SMTP command");
                continue;
            }

            // we might run into a sink that does async operations
            // So update state data that the async thread could see
            m_cbRecvBufferOffset += (DWORD)(pszSearch - (QueryMRcvBuffer() + m_cbTempBDATLen) + 2);
            m_cbParsable -= (IntermediateSize + 2);
            m_cbReceived = m_cbParsable + UndecryptedTailSize;

            // before firing each command load any session properties from ISession
            HrGetISessionProperties();

            //
            // Increment the pending IO count in case this returns async
            //
            IncPendingIoCount();

            fReturn = GlueDispatch((char *)InputLine, IntermediateSize, CmdSize, &fAsyncOp);
            //
            // Assert check that fAsyncOp isn't true when GlueDispatch fails
            //
            _ASSERT( (!fAsyncOp) || fReturn );
            if(!fAsyncOp)
            {
                //
                // Decrement the pending IO count since GlueDispatch
                // returned sync (and we incremented the count above).
                // ProcessClient is above us in the callstack and always has a
                // pending IO reference, so this should never return zero
                //
                _VERIFY(DecPendingIoCount() > 0);
            }

            if (fReturn == TRUE && fAsyncOp)
            {
                //We returned from Dispatcher because some sink did an async operation
                //We need to simply leave. The thread on which the async operation completes
                //will continue with the sink firing. The dispacther will keep the context
                //which will allow it to do so..
                //So as to keep the connection alive - bump up the ref count
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }

            // log this command and the response
            if (m_State != DATA &&
                m_State != BDAT &&
                m_State != AUTH &&
                m_State != QUIT &&
                m_dwCurrentCommand != DATA &&
                m_dwCurrentCommand != BDAT &&
                m_dwCurrentCommand != AUTH &&
                m_dwCurrentCommand != QUIT)
            {
                const char *pszCommand = SmtpCommands[m_dwCurrentCommand];
                DWORD cCmd = (pszCommand) ? strlen(pszCommand) : 0;
                ProtocolLog(m_dwCurrentCommand,
                            InputLine + cCmd,
                            m_CInboundContext.m_dwWin32Status,
                            m_CInboundContext.m_dwSmtpStatus,
                            0,
                            0);
            }

            if (fReturn == TRUE)
            {

                //All Sinks completed synchronously
                m_cbRecvBufferOffset = 0;
                InputLine = pszSearch + 2; //skip CRLF
                if(m_State != DATA && m_State != BDAT)
                {
                    continue;
                }
                else if (m_State == BDAT && m_fIsLastChunk && m_nChunkSize == 0)
                {
                    // The BDAT RFC allows the last chunk to be zero-sized. This
                    // should indicate that the message is done. However no chunk
                    // data is left to be parsed (so m_cbParsable *may* be 0 and if
                    // nonzero, it indicates pipelined SMTP commands after the zero
                    // byte BDAT chunk).

                    goto PROCESS_BDAT;
                }
                else if (m_State == BDAT && m_cbParsable)
                {
                    //We are in BDAT mode and there is some data that can be parsed
                    MoveMemory ((void *)(QueryMRcvBuffer() + m_cbTempBDATLen), InputLine, m_cbReceived - m_cbTempBDATLen );
                    InputLine = QueryMRcvBuffer();
                    goto PROCESS_BDAT;
                }
                else
                {
                    break; // no more data
                }
            }
            else
            {
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }//end if(fReturn == TRUE)
     }//end while

     // if IsLineComplete failed because we passed in a negative length
     // than drop the session.  something is corrupt
     if ((int) m_cbParsable - (int) m_cbTempBDATLen < 0) {
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
     }

    _ASSERT(m_cbReceived <= QueryMaxReadSize());

    //
    // If there is additional data left at the end of the buffer move it to the
    // beginning - clearing out already processed data.
    //

    if(m_cbParsable != 0 && // Additional data in buffer?
      (QueryMRcvBuffer() + m_cbTempBDATLen != InputLine)) // Is MoveMemory needed?
    {
        MoveMemory ((void *)(QueryMRcvBuffer() + m_cbTempBDATLen),
            InputLine, m_cbParsable+UndecryptedTailSize-m_cbTempBDATLen);
    }


    SendSmtpResponse();

    m_cbReceived = m_cbParsable + UndecryptedTailSize;


    //
    // Bad input from the client can cause us to fill up the buffer
    // completely. We can neither process the data available to us already
    // because it is incomplete, nor attempt to complete it by posting more
    // reads on the socket, because we do not have any more space. A well
    // behaved server in such a situation should discard the data as it arrives
    // and after all the data has been received, respond with an error. Note
    // that legal input can never fill up the buffer because the buffer size
    // used is large enough to accomodate all valid SMTP commands.
    //
    // This function checks for such situations, frees up buffer space when
    // it detects such an error and transitions the session to an error state.
    // If the recv-buffer is full, there was an error and we need to free
    // some space to do error processing (see function description).
    //
    // m_cbReceived should never be > QueryMaxReadSize() - at most it is equal
    // to QueryMaxReadSize(). The following if() is just defensive programming.
    //

    if(QueryMaxReadSize() <= m_cbReceived)
        HandleFullRecvBuffer();

    _ASSERT (m_cbReceived < QueryMaxReadSize());

    //pend an I/O
    IncPendingIoCount();
    m_LastClientIo = READIO;
    fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, QueryMaxReadSize() - m_cbReceived);
    if(!fReturn)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      Helper function for SMTP command parser. This is called when we have
//      a complete CRLF terminated line available from the client. It is
//      responsible for parsing the Input from the client and setting
//      m_dwCurrentCommand to the command received.
//
//  Arguments:
//      IN CHAR *InputLine - Pointer to CRLF terminated buffer containing command
//      IN CHAR *pszSearch - Pointer to CRLF that marks the end of the command
//      IN ULONG IntermediateSize - Length of command, excluding CRLF
//      IN ULONG UndecryptedTailSize - If using TLS, these bytes are encrypted
//      OUT DWORD *pdwCmdSize - If command was successfully parsed (this function
//          returned TRUE), this is initialized to the size of the command
//          keyword (excluding arguments).
//
//  Returns:
//      TRUE - If command was successfully parsed. CmdSize will be initialized
//          to the size of the SMTP keyword.
//      FALSE - If the input was not recognized as a command. This function
//          will format the appropriate error message and send it to the
//          client.
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::SmtpParseCompleteCommand(
    const CHAR *InputLine,
    CHAR *pszSearch,
    ULONG IntermediateSize,
    DWORD *pdwCmdSize)
{
    BOOL fReturn = FALSE;
    DWORD UndecryptedTailSize = m_cbReceived - m_cbParsable;
    DWORD dwError = 0;
    LPSTR pszExtended = NULL;
    LPSTR pszText = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::SmtpParseCompleteCommand");

    //
    // Blank lines are accepted for interoperability purposes. Some SMTP
    // implementations append an extra CRLF to some SMTP commands. We will
    // silently accept and ignore blank lines.
    //

    if (*InputLine == 0) {
        MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);
        m_cbParsable -= IntermediateSize + 2;
        m_cbReceived = m_cbParsable + UndecryptedTailSize;
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //
    // Excessively long command was received from client and we could not fit
    // it in our input buffer. So the m_fBufferFull flag was set and the command
    // bytes discarded (so that we could receive the end of line and respond
    // with an error message).
    //

    if(m_fRecvBufferFull) {
        m_fRecvBufferFull = FALSE;
        dwError = SMTP_RESP_BAD_CMD;
        pszExtended = (LPSTR) ESYNTAX_ERROR;
        pszText = (LPSTR) SMTP_BAD_CMD_STR;
        fReturn = FALSE;
        goto Exit;
    }

    //
    // Error case when an overly long SMTP command has to be discarded because
    // there isn't enough space to hold it all in the buffer. Can happen while
    // chunking (see where this member variable is set). In this situation, all
    // bytes received are discarded without parsing, till a CRLF is encountered.
    // Then IsLineComplete succeeds and we execute this if-statement.
    //

    if(m_fBufferFullInBDAT) {
        m_fBufferFullInBDAT = FALSE;
        dwError = SMTP_RESP_BAD_SEQ;
        pszExtended = (LPSTR) ESYNTAX_ERROR;
        pszText = (LPSTR) SMTP_BDAT_EXPECTED;
        fReturn = FALSE;
        goto Exit;
    }


    //
    // SMTP events are fired upon the _EOD event and "_EOD" appears in the
    // SmtpDispatchTable and SmtpCommands[] array. However it isn't an SMTP
    // command. Ideally "_EOD" should never be returned from SmtpGetCommand,
    // but the event firing mechanism is tied to "_EOD" as a string. So we
    // firewall this case in the parser.
    //
    // Other strings unimplemented by SMTP should be handled by GlueDispatch
    // which checks if SMTP sinks are registered to handle that string and
    // fires events for that string. "_EOD" is the only string for which
    // events must not be fired from the SMTP command parser.
    //

    if(!strncasecmp((char *)InputLine, "_EOD", sizeof("_EOD") - 1))
    {
        dwError = SMTP_RESP_BAD_CMD;
        pszExtended = (LPSTR) ENOT_IMPLEMENTED;
        pszText = (LPSTR) SMTP_BAD_CMD_STR;
        fReturn = FALSE;
        goto Exit;
    }

    m_dwCurrentCommand = SmtpGetCommand(InputLine, IntermediateSize, pdwCmdSize);
    if(m_State == BDAT &&
       m_dwCurrentCommand != BDAT &&
       m_dwCurrentCommand != RSET &&
       m_dwCurrentCommand != QUIT &&
       m_dwCurrentCommand != NOOP)
    {
        dwError = SMTP_RESP_BAD_SEQ;
        pszExtended = (LPSTR) ESYNTAX_ERROR;
        pszText = (LPSTR) SMTP_BDAT_EXPECTED;
        fReturn = FALSE;
        goto Exit;
    }

    fReturn = TRUE;

Exit:

    //
    // Error detected during command parsing by one of the if-statements in this
    // function. Discard the line containing the erroneous command (till the CRLF,
    // which is at pszSearch) from the receive buffer, and return an error message,
    // if one was set by the preceding if-statements, to the client.
    //

    if(!fReturn)
    {
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        m_ProtocolErrors++;
        MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);
        m_cbParsable -= IntermediateSize + 2;
        m_cbReceived = m_cbParsable + UndecryptedTailSize;

        if(0 != dwError && pszExtended && pszText)
        {
            PE_CdFormatSmtpMessage(dwError, pszExtended, " %s\r\n", pszText);
            PE_SendSmtpResponse();
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      Certain syntax errors by the client can result in the recv buffer being
//      filled by with client input that does not contain CRLFs. Since SMTP
//      processes line-by-line, it cannot process the data in the recv buffer
//      which lacks CRLFs. It cannot receive additional data (that may contain
//      the CRLFs) either, since the buffer is already full. This function
//      detects such a state, switches over to an "error mode" and discards
//      the received bytes to clear buffer space. Later, when the CRLF is
//      received, and SMTP tries to parse the line (which is really a partial
//      line, since we discarded the beginning of the line here), we will
//      realize that we are in the "error-mode" and instead of parsing the
//      partial line, we will discard it an respond with the appropriate error.
//  Arguments:
//      None.
//  Returns:
//      None.
//  Notes:
//      See SMTP_CONNECTION::SmtpParseCommand() for the rest of the processing
//      done in "error-mode" when the CRLF is received.
//-----------------------------------------------------------------------------
void SMTP_CONNECTION::HandleFullRecvBuffer()
{
    DWORD UndecryptedTailSize = m_cbReceived - m_cbParsable;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::HandleFullRecvBuffer");

    _ASSERT(QueryMaxReadSize() == m_cbReceived);

    //
    // The receive buffer can fill up if we have more than QueryMaxReadSize()
    // bytes in it that cannot be processed till more data is received from
    // the client. This does not happen in the normal processing of SMTP
    // commands, since each SMTP command is limited to 512 bytes, which can
    // comfortably fit in the recv buffer.
    //
    // However, while processing BDAT, CreateMailBodyFromChunk may save the
    // bytes of a partially received header line in the recv buffer by setting
    // m_cbTempBDATLen > 0. For example, suppose the client is sending BDAT
    // chunks, and the first chunk comprises of 500 bytes of data without a
    // CRLF. In this case, SMTP cannot determine whether or not these 500
    // bytes are part of a header. This is because unless the complete line
    // has been received we cannot decide whether or not the line follows
    // the header syntax. Therefore SMTP will save the 500 bytes by setting
    // m_cbTempBDATLen == 500, and any bytes sent by the client will be
    // appended at an offset of 500 in the recv buffer. When the next chunk
    // arrives, SMTP will again try to process the 500 saved bytes + the
    // bytes from the new chunk, as a complete header line.
    //
    // A client cannot fill up the buffer by sending thousands of bytes like
    // this, without CRLFs, forcing SMTP to save the partial header. SMTP has
    // a maximum limit on how long a header line can be (this is 1000 bytes).
    // If this limit is exceeded, SMTP can determine that the line is not a
    // syntactically correct header, and it does not have to wait for the
    // terminating CRLF for the line so that it can parse the complete line
    // according to header syntax.
    //
    // Thus it is impossible to occupy > 999 bytes of space as a saved BDAT
    // partial header. However, even if we occupy the maximum possible 999
    // bytes, the recv buffer (being sized 1024) will have only 26 bytes
    // available for processing SMTP commands. This is clearly inadequate
    // (in theory anyway) because SMTP commands have a max size of 512. In
    // fact, we do not even have enough space to receive and reject illegal
    // commands which can exceed 26 bytes (since a command-line must be
    // completely received, till the terminating CRLF, before we can parse
    // and reject it, in the ordinary course of things).
    //
    // Fortunately, during BDAT, the only commands allowed to be issued are
    // all shorter than 26 bytes: BDAT, RSET and QUIT. We take advantage of
    // this fact if we are caught in the "out of space" scenario, and the
    // follwing if-statement sets m_fBufrFullInBDAT flag. When this flag is
    // set, SMTP will discard every byte it receives from the client
    // (following the saved m_cbTempBDATLen bytes) till a CRLF is received
    // (note that the CRLF marks the end of the illegal SMTP command). Then
    // SMTP responds with "BDAT expected" (see the command loop above) and
    // resets the m_fBufrFullInBDAT flag to the normal state.
    //
    // Note that if the buffer is full, then m_cbTempBDATLen *must* be > 0.
    // We only run out of recv buffer space during chunking. Thus the
    // additional check for m_cbTempBDATLen > 0 in the following if-statement.
    //

    if(m_cbTempBDATLen > 0)
    {
        // Flag error so we know what response to generate when we do get CRLF
        m_fBufferFullInBDAT = TRUE;

        // Discard everything after the saved BDAT chunk except Undecrypted tail
        PBYTE pbDiscardStart = (PBYTE) (QueryMRcvBuffer() + m_cbTempBDATLen);
        PBYTE pbDiscardEnd = (PBYTE) (QueryMRcvBuffer() + m_cbParsable);
        DWORD cbBytesToDiscard = m_cbParsable - m_cbTempBDATLen;
        DWORD cbBytesToMove = UndecryptedTailSize;

        // Keep CR if it's at the end. If the next packet has LF as the
        // first byte we want to process the CRLF with IsLineComplete.
        if(*(pbDiscardEnd - 1) == CR)
        {
            pbDiscardEnd--;
            cbBytesToDiscard--;
            cbBytesToMove++;
        }

        m_cbParsable -= cbBytesToDiscard;
        m_cbReceived -= cbBytesToDiscard;

        _ASSERT(pbDiscardEnd > pbDiscardStart);
        MoveMemory((PVOID)pbDiscardStart, pbDiscardEnd, cbBytesToMove);
        goto Exit;
    }

    //
    // SMTP has a finite capacity to buffer data - QueryMaxReadSize() bytes
    // at a time. So if the client sends a *very* long command that has no
    // CRLFs in the first QueryMaxReadSize() bytes we cannot process that
    // command. It is clearly an illegal command since SMTP commands are
    // restricted to 512 bytes at the most.
    //
    // The error is handled by discarding all the command-bytes received so
    // far, thus clearing space in the buffer. Then  we can pend a read for
    // the next batch of bytes before responding with "unrecognised command"
    //

    if(m_cbParsable > 0)
    {
        ErrorTrace((LPARAM)this, "Command too long, recv buffer full");

        // We already handled (m_cbTempBDATLen > 0) in the previous 'if'
        _ASSERT(m_cbTempBDATLen == 0);

        // Flag error so we know what response to generate when we do get CRLF
        m_fRecvBufferFull = TRUE;

        int cbBytesToClear = m_cbParsable;
        int cbBytesToMove = UndecryptedTailSize;

        m_cbParsable = 0;
        m_cbReceived = UndecryptedTailSize;

        // If the last byte is CR, then an LF might be the first byte of the
        // next packet. Save the last byte of this packet so that IsLineComplete
        // will work in this situation.

        if(*(QueryMRcvBuffer() + cbBytesToClear - 1) == '\r')
        {
            m_cbParsable = 1;
            m_cbReceived = m_cbParsable + UndecryptedTailSize;

            cbBytesToClear--;
            cbBytesToMove++;
        }

        _ASSERT(cbBytesToClear > 0);

        MoveMemory(QueryMRcvBuffer(), QueryMRcvBuffer() + cbBytesToClear,
            cbBytesToMove);

        goto Exit;
    }

Exit:
    _ASSERT(QueryMaxReadSize() > m_cbReceived);
    TraceFunctLeaveEx((LPARAM)this);
    return;
}

/*++

    Name:
        SMTP_CONNECTION::HrGetISessionProperties

    Description:
        A sink may set certain properties on the session
        which should control SMTP behaviour, this function
        pulls those properties from ISession and writes
        them as session parameters (members of SMTP_CONNECTION)

    Arguments:
        None.

    Returns:
        HRESULT - Success or Error
        If there isn't a sink or if a property was not
            set by sink, an error may be returned.

--*/
HRESULT SMTP_CONNECTION::HrGetISessionProperties()
{
    IMailMsgPropertyBag *pISessionProperties = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::HrGetISessionProperties");
    //
    // This is for the EXPS (or any other) AUTH sink, which replaces SMTP
    // authentication --- if the session is authenticated using the sink
    // we should mark it as such. We pull the "AUTH" properties when we are
    // about to process a command that is affected by the AUTH settings. We
    // exclude commands like DATA and BDAT because they MUST have been
    // preceded by MAIL, for which the AUTH setting would have already been
    // checked.
    //
    if(!m_fAuthenticated &&
       (m_dwCurrentCommand == MAIL ||
        m_dwCurrentCommand == TURN ||
        m_dwCurrentCommand == ETRN ||
        m_dwCurrentCommand == VRFY ||
        m_dwCurrentCommand == HELP))
    {
        pISessionProperties = (IMailMsgPropertyBag *)GetSessionPropertyBag();
        //
        // Usage of ISESSION_PID_IS_SESSION_AUTHENTICATED property: The AUTH
        // sink sets this to TRUE when a successful authentication occurs.
        //
        hr = pISessionProperties->GetBool(
                ISESSION_PID_IS_SESSION_AUTHENTICATED,
                (DWORD *) &m_fAuthenticated);

        if(FAILED(hr))
        {
            DebugTrace((LPARAM)this, "Can't get authenticated property for Session. hr - %08x", hr);
            hr = S_OK;
            goto Exit;
        }

        hr = pISessionProperties->GetStringA(
                ISESSION_PID_AUTHENTICATED_USERNAME,
                sizeof(m_szAuthenticatedUserNameFromSink),
                m_szAuthenticatedUserNameFromSink);

        if(FAILED(hr))
        {
            m_szAuthenticatedUserNameFromSink[0] = '\0';
            DebugTrace((LPARAM)this, "Can't get username for Session. hr - %08x", hr);
            hr = S_OK;
        }

        //
        // Protocol sinks may set ISESSION_PID_MAY_RELAY if the authenticated
        // user is permitted to relay even if the ip checks fail and "Allow all
        // authenticated users to relay" isn't checked.
        //
        hr = pISessionProperties->GetBool(
                ISESSION_PID_MAY_RELAY,
                (DWORD *) &m_fMayRelay);

        if(FAILED(hr)) {
            m_fMayRelay = FALSE;
            if (hr != MAILMSG_E_PROPNOTFOUND)
                DebugTrace((LPARAM)this, "Can't get May Relay for Session. hr - %08x", hr);
            hr = S_OK;
        }

    }

Exit:
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

/*++
    Description:
        This function is called set BOOL properties in the ISession property
        bag that must be advertised to protocol sinks.
    Arguments:
        dwPropId - Propid to set
        pvValue - Value of property
    Returns:
        Success HRESULT if the property was set.
        E_FAIL if no ISession pointer exists.
        Error HRESULT on other failures.
--*/
HRESULT SMTP_CONNECTION::HrSetISessionProperty(DWORD dwPropId, BOOL fValue)
{
    IMailMsgPropertyBag *pISessionProperties = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HrSetISessionProperty");

    pISessionProperties = (IMailMsgPropertyBag *) GetSessionPropertyBag();
    if(!pISessionProperties) {
        _ASSERT(0 && "No ISession props!");
        TraceFunctLeaveEx((LPARAM) this);
        return E_FAIL;
    }

    hr = pISessionProperties->PutBool(dwPropId, fValue);

    TraceFunctLeaveEx((LPARAM) this);
    return hr;
}


/*++

    Name :
        SMTP_CONNECTION::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

  Note :

--*/
BOOL SMTP_CONNECTION::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL    fIsAtqThread = TRUE;
    BOOL    RetStatus;
    BOOL    fMailQueued     = FALSE;
    PSMTP_SERVER_INSTANCE pInstance = m_pInstance; //save the instance pointer

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessClient()");

    _ASSERT (m_pInstance != NULL);

    pInstance->IncProcessClientThreads();
    InterlockedIncrement(&g_cProcessClientThreads);
    //
    // increment the number of threads processing this client
    //
    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if( (lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT))
    {
        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //
        IncPendingIoCount();

        FormatSmtpMessage (SMTP_RESP_ERROR, NULL," %s\r\n",SMTP_TIMEOUT_MSG );
        SendSmtpResponse(); //flush the response
        ProtocolLog(SMTP_TIMEOUT, (char *) QueryClientUserName(), inet_addr((char *)QueryClientHostName()), ERROR_SEM_TIMEOUT);

        DebugTrace( (LPARAM)this, "client timed out");

        DisconnectClient();
    }
    else if((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR))
    {
        //
        DebugTrace((LPARAM) this, "SMTP_CONNECTION::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d  - Closing connection", InputBufferLen, dwCompletionStatus);

        //  If this is a mail file write then we handle error: if not a mailfile write or we are unable to
        //  handle the error, then we simply disconnect.
        if( lpo != &m_Overlapped && lpo != QueryAtqOverlapped() && !HandleInternalError(dwCompletionStatus))
            DisconnectClient();
    }
    else if (lpo == &m_Overlapped || lpo == QueryAtqOverlapped())
    {
        //
        // Is this a real IO completion or a completion status
        // posted to notify us an async sink completed?
        //
        if( m_fAsyncEventCompletion )
        {
            //
            // A portocol event sink completed async, called our
            // completion routine, posted a completion status which is
            // being dequeued here.  Our job is now to pend the next read
            // (via ProcessInputBuffer)
            //
            m_fAsyncEventCompletion = FALSE;
            RetStatus = ProcessInputBuffer();
        }
        else
        {
            //A client based async IO completed
            RetStatus = ProcessReadIO(InputBufferLen, dwCompletionStatus, lpo);

            if((m_pInstance->GetMaxErrors() > 0) && (m_ProtocolErrors >= m_pInstance->GetMaxErrors()))
            {
                //If there are too many error, break the connection
                FormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, NULL," %s\r\n",SMTP_TOO_MANY_ERR_MSG);
                FatalTrace((LPARAM) this, "Too many errors. Error count = %d", m_ProtocolErrors);
                SendSmtpResponse();
                DisconnectClient();
            }
        }
    }
    else
    {
        //A Mail File Write completed
        SMTPCLI_FILE_OVERLAPPED* lpFileOverlapped = (SMTPCLI_FILE_OVERLAPPED*)lpo;
        _ASSERT( lpFileOverlapped->m_LastIoState == WRITEFILEIO );

        if (lpFileOverlapped->m_LastIoState == WRITEFILEIO)
        {
            RetStatus = ProcessFileWrite(InputBufferLen, dwCompletionStatus, lpo);
        }
    }

    //
    // decrement the number of threads processing this client if the thread exiting
    // is an Atq pool thread
    //
    //if(fIsAtqThread)
        DecThreadCount();

    DebugTrace((LPARAM)this,"SMTPLCI - Pending IOs: %d", m_cPendingIoCount);
    DebugTrace((LPARAM)this,"SMTPCLI - Num Threads: %d", m_cActiveThreads);

    // Do NOT Touch the member variables past this POINT!
    // This object may be deleted!

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //
    if (DecPendingIoCount() == 0)
    {
        ProtocolLog(QUIT, (char *) QueryClientUserName() , QuerySessionTime(),
        	(m_CInboundContext.m_dwCommandStatus | EXPE_DROP_SESSION) ? ERROR_VC_DISCONNECTED : NO_ERROR);

        DebugTrace((LPARAM)this, "Pending IO count == 0, disconnecting.");
        if(m_DoCleanup)
            DisconnectClient();

        m_pInstance->RemoveConnection(this);
        delete this;
    }

    //if(fIsAtqThread)
    //{
        pInstance->DecProcessClientThreads();
        InterlockedDecrement(&g_cProcessClientThreads);
    //}

    // We are not the last thread, so we will return TRUE
    // to keep the object around
    //TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

 /*++

    Name :
        SMTP_CONNECTION::StartSession

    Description:

        Starts up a session for new client.
        starts off a receive request from client.

    Arguments:

    Returns:

       TRUE if everything is O.K
       FALSE if a write or a pended read failed
--*/
BOOL SMTP_CONNECTION::StartSession( void)
{
    SYSTEMTIME  st;
    BOOL fRet;
    char szDateBuf [cMaxArpaDate];
    char FullName[MAX_PATH + 1];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::StartSession");

    StartSessionTimer();

    if(!m_pFileWriteBuffer || !m_pFileWriteBuffer->GetData())
    {
        ErrorTrace((LPARAM)this, "Failed to get the write buffer Err : %d",
                      GetLastError());
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //
    // If we are negotiating SSL, we need to let the SSL handshake happen
    // first. Else, we are either done with the SSL handshake or we are
    // talking over the unsecured port, so just go ahead and send the server
    // greeting.
    //

    if (!m_fNegotiatingSSL)
    {
        _ASSERT (m_pInstance != NULL);

        //Dump the header line into the buffer to format the greeting
        GetLocalTime(&st);
        GetArpaDate(szDateBuf);

        m_pInstance->LockGenCrit();
        lstrcpy(FullName, m_pInstance->GetFQDomainName());
        m_pInstance->UnLockGenCrit();

        PE_CdFormatSmtpMessage(SMTP_RESP_READY,NULL," %s %s %s, %s \r\n",
                    FullName,
                    m_pInstance->GetConnectResponse(),
                    Daynames[st.wDayOfWeek],
                    szDateBuf);

        //send the greeting
        if(!PE_SendSmtpResponse())
        {
            DebugTrace( (LPARAM) this, "SendSmtpResponse() returned FALSE!");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

    }

    //kick off our first read
    m_LastClientIo = READIO;

    //
    // increment the overall pending io count for this session
    //

    _ASSERT(m_cPendingIoCount == 0);

    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), QueryMaxReadSize());

    if(!fRet)
    {
        int err = GetLastError();

        ErrorTrace((LPARAM)this, "Readfile failed, err = %d", err);
        DecPendingIoCount();    //if one of these operations fail,
        PE_DisconnectClient();  //AND the ReadFile failed the "last error" is lost.

        if(err != ERROR_SUCCESS)
            SetLastError(err);  //restore last error that occurred so higher level routine knows what happened
    }

    DebugTrace((LPARAM)this, "SendSmtpResponse() returned %d", fRet);
    TraceFunctLeaveEx((LPARAM) this);

    return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::CheckArguments

    Description:

        checks the arguments of what the client sends
        for the required space command et al.

    Arguments:

         Arguments from client

    Returns:

    NULL if arguments are not correct
    A pointer into the input buffer where
    the rest of the data is.

--*/
char * SMTP_CONNECTION::CheckArgument(char * Argument, BOOL WriteError)
{

  if(*Argument =='\0')
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Argument missing" );

    return NULL;
  }

  if(!isspace((UCHAR)*Argument))
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n",SMTP_BAD_CMD_STR);

    return NULL;
  }

    //get rid of white space
  while(isspace((UCHAR)*Argument))
      Argument++;

    //is there anything after here ?
  if(*Argument =='\0')
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Argument missing" );

    return NULL;
  }

  return Argument;
}

void SMTP_CONNECTION::FormatEhloResponse(void)
{
    char FullName [MAX_PATH + 1];
    unsigned char AuthPackages [500];
    DWORD BytesRet = 0;
    DWORD ConnectionStatus = 0;

    if(m_SecurePort)
        ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
    if(m_fAuthenticated)
        ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

    m_pInstance->LockGenCrit();
    lstrcpy(FullName, m_pInstance->GetFQDomainName());
    m_pInstance->UnLockGenCrit();

    PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL, "-%s %s [%s]\r\n",  FullName,"Hello", QueryClientHostName());

    if(m_pInstance->AllowAuth())
    {
        if(m_pInstance->QueryAuthentication() != 0)
        {
            if(m_pInstance->QueryAuthentication() & INET_INFO_AUTH_NT_AUTH)
            {
                BytesRet = sizeof(AuthPackages);
                m_securityCtx.GetInstanceAuthPackageNames(AuthPackages, &BytesRet, PkgFmtSpace);
            }

            if(BytesRet > 0)
            {
                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH %s",AuthPackages);

                if(m_pInstance->AllowLogin(ConnectionStatus))
                {
                    PE_FormatSmtpMessage(" LOGIN\r\n");
                }
                else
                {
                    PE_FormatSmtpMessage("\r\n");
                }

                if(m_pInstance->AllowLogin(ConnectionStatus))
                {
                    //For backward compatibility
                    PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH=%s\r\n","LOGIN");
                }
            }
            else if(m_pInstance->AllowLogin(ConnectionStatus))
            {

                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH=LOGIN\r\n");
                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH LOGIN\r\n");
            }

            if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowTURN())
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","TURN");
            }

        }
    }

    if (m_pInstance->GetMaxMsgSize() > 0)
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s %u\r\n","SIZE", m_pInstance->GetMaxMsgSize());
    }
    else
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n","SIZE");
    }

    if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowETRN())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "ETRN");
    }

    if(m_pInstance->ShouldPipeLineIn())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n","PIPELINING");
    }

    if(m_pInstance->AllowDSN())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "DSN");
    }

    if(m_pInstance->AllowEnhancedCodes())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "ENHANCEDSTATUSCODES");
    }

    if(m_pInstance->AllowEightBitMime())
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "8bitmime");
    }

    // Chunking related advertisements
    if(m_pInstance->AllowBinaryMime())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "BINARYMIME");
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "CHUNKING");
    }
    else if(m_pInstance->AllowChunking())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "CHUNKING");
    }

    // verify - we need to advertise it whether we support it or not.
    PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","VRFY");

    // Expand
    if(m_pInstance->AllowExpand(ConnectionStatus))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "EXPN");
    }



    //
    // Check that we have a certificate installed with which we can negotiate
    // a SSL session
    //
    if (!m_SecurePort && // TLS is advertized only if we haven't already negotiated it
        m_encryptCtx.CheckServerCert(
        (LPSTR) QueryLocalHostName(),
            (LPSTR) QueryLocalPortName(),
                (LPVOID) QuerySmtpInstance(),
                    QuerySmtpInstance()->QueryInstanceId()))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","TLS");
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "STARTTLS");
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL," %s\r\n","OK");

}


/*++

    Name :
        SMTP_CONNECTION::DoEHLOCommand

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoEHLOCommand(const char * InputLine, DWORD ParametSize)
{
  BOOL RetStatus = TRUE;
  char * Args = (char *) InputLine;
  CAddr * NewAddress = NULL;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoEHLOCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // pgopi -- don't cound multiple ehlo's as error. This is per bug 82160
  //if (m_HelloSent)
  //    ++m_ProtocolErrors;

  Args = CheckArgument(Args, !m_pInstance->ShouldAcceptNoDomain());
  if(Args != NULL)
  {
      if(m_pInstance->ShouldValidateHeloDomain())
      {
          if(!ValidateDRUMSDomain(Args, lstrlen(Args)))
          {
              //Not a valid domain -
              SetLastError(ERROR_INVALID_DATA);
              HandleAddressError((char *)InputLine);
          }
          else
          {
              //Is reverse DNS lookup enabled
              if(m_pInstance->IsReverseLookupEnabled())
              {
                  m_DNSLookupRetCode = VerifiyClient (Args, QueryClientHostName());
                  if(m_DNSLookupRetCode == NO_MATCH)
                  {
                       //We failed in DNS lookup
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n",SMTP_RDNS_REJECTION);
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS failed for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
                  else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                  {
                      //We had an internal DNS failure
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS DNS failure for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
              } else {
                  m_DNSLookupRetCode = SUCCESS;
              }

              FormatEhloResponse();

              strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
              m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
              m_HelloSent = TRUE;
              m_State = HELO;
          }
      }
      else
      {
          FormatEhloResponse();
          strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
          m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
          m_HelloSent = TRUE;
          m_State = HELO;
      }

  }
  else if(m_pInstance->ShouldAcceptNoDomain())
  {
      FormatEhloResponse();

      if(m_szHeloAddr[0] != '\0')
      {
          m_szHeloAddr[0] = '\0';
      }

      m_HelloSent = TRUE;
      m_State = HELO;

  }

  //we can either accept the HELO or EHLO as the 1st command
  RetStatus =  PE_SendSmtpResponse();
  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoHELOCommand

    Description:

        Responds to the SMTP HELO command

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoHELOCommand(const char * InputLine, DWORD ParameterSize)
{
  char * Args = (char *) InputLine;
  CAddr * NewAddress = NULL;
  char FullName[MAX_PATH + 1];

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoHELOCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // pgopi--don't cound multiple ehlo's as error. This is per bug 82160
  //if (m_HelloSent)
  //   ++m_ProtocolErrors;

  Args = CheckArgument(Args, !m_pInstance->ShouldAcceptNoDomain());
  if(Args != NULL)
  {
      if(m_pInstance->ShouldValidateHeloDomain())
      {
          if(!ValidateDRUMSDomain(Args, lstrlen(Args)))
          {
              //Not a valid domain -
              SetLastError(ERROR_INVALID_DATA);
              HandleAddressError((char *)InputLine);
          }
          else
          {
              if(m_pInstance->IsReverseLookupEnabled())
              {
                  m_DNSLookupRetCode = VerifiyClient (Args, QueryClientHostName());
                  if(m_DNSLookupRetCode == NO_MATCH)
                  {
                       //We failed in DNS lookup
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n",SMTP_RDNS_REJECTION);
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS failed for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
                  else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                  {
                      //We had an internal DNS failure
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS DNS failure for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
              } else {
                  m_DNSLookupRetCode = SUCCESS;
              }

              m_pInstance->LockGenCrit();
              strcpy(FullName, m_pInstance->GetFQDomainName());
              m_pInstance->UnLockGenCrit();

              PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                           "Hello", QueryClientHostName());

              strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
              m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
              m_HelloSent = TRUE;
              m_State = HELO;
          }
      }
      else
      {
          m_pInstance->LockGenCrit();
          strcpy(FullName, m_pInstance->GetFQDomainName());
          m_pInstance->UnLockGenCrit();
          PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                           "Hello", QueryClientHostName());
          strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
          m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
          m_HelloSent = TRUE;
          m_State = HELO;
      }
  }
  else if(m_pInstance->ShouldAcceptNoDomain())
  {
    m_pInstance->LockGenCrit();
    lstrcpy(FullName, m_pInstance->GetFQDomainName());
    m_pInstance->UnLockGenCrit();

    PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                       "Hello", QueryClientHostName());

    if(m_szHeloAddr[0] != '\0')
    {
       m_szHeloAddr[0] = '\0';
    }

    m_HelloSent = TRUE;
    m_State = HELO;

  }

  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoRSETCommand

    Description:

        Responds to the SMTP RSET command.
        Deletes all stored info, and resets
        all flags.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoRSETCommand(const char * InputLine, DWORD parameterSize)
{

    BOOL RetStatus;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRSETCommand");

    _ASSERT (m_pInstance != NULL);

    m_State = HELO;
    m_TotalMsgSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_RecvdMailCmd = FALSE;
    m_HeaderSize = 0;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_MailBodyError = NO_ERROR;
    m_RecvdRcptCmd = FALSE;
    m_CurrentOffset = 0;
    m_HopCount = 0;
    m_LocalHopCount = 0;
    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;
    m_cbRecvBufferOffset = 0;
    m_ProtocolErrors = 0;
    m_fBufferFullInBDAT = FALSE;

    if(m_cbTempBDATLen)
    {
        m_cbParsable -= m_cbTempBDATLen;
        m_cbTempBDATLen = 0;
    }

    m_szFromAddress[0] = '\0';


    //Free the possible ATQ context associated with this File handle
    //This will be if we were processing BDAT before RSET
    //FreeAtqFileContext();

    ReleasImsg(TRUE);

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, EPROT_SUCCESS," %s\r\n",SMTP_RSET_OK_STR);

    RetStatus= PE_SendSmtpResponse();
    TraceFunctLeaveEx((LPARAM) this);
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoNOOPCommand

    Description:

        Responds to the SMTP NOOP command.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoNOOPCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoNOOPCommand");

  _ASSERT (m_pInstance != NULL);

  //send an OK
  PE_CdFormatSmtpMessage (SMTP_RESP_OK, EPROT_SUCCESS," OK\r\n");
  RetStatus = PE_SendSmtpResponse();

  if(!m_Nooped)
  {
      m_Nooped = TRUE;
  }
  else
  {
      m_ProtocolErrors++;
  }

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}


/*++

    Name :
        SMTP_CONNECTION::DoETRNCommand

    Description:

        Responds to the SMTP ETRN command.

    Arguments:
        Parsed to determine the ETRN domain(s) to send mail to.

    Returns:

      TRUE in all cases. We are agreeing to give our best effort to the ETRN command
      re the protocol. Mail is not necessarily in the retry queue so it may not be delivered.


--*/
BOOL SMTP_CONNECTION::DoETRNCommand(const char * InputLine, DWORD parameterSize)
{

  BOOL      RetStatus;
  char *    Ptr = NULL;
  CHAR      szNode[SMTP_MAX_DOMAIN_NAME_LEN];
  DWORD     Ret = 0;
//  DWORD     strLen;
  BOOL      bSubDomain;
  DWORD        dwMessagesQueued;
  HRESULT    hr;
//  BOOL          bWildCard;
//  DOMAIN_ROUTE_ACTION_TYPE action;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoETRNCommand");

  _ASSERT (m_pInstance != NULL);

  bSubDomain = FALSE;
  dwMessagesQueued = 0;
//  bWildCard = FALSE;

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //
  // check that the hello has been sent, and that we are not in the middle of sending
  // a message
  //NimishK : removed the check for HELO EHLO

  if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  if(m_RecvdMailCmd)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_NO_ETRN_IN_MSG);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "In DoETRNCommand():SMTP_RESP_BAD_SEQ, SMTP_NO_ETRN_IN_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //start parsing from the beginning of the line
  Ptr = (char *) InputLine;

  //check if argument have the right format (at least one parameter)
  Ptr = CheckArgument(Ptr);
  if (Ptr == NULL)
  {
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // remove any whitespace
  while((isspace ((UCHAR)*Ptr)))
  {
      Ptr++;
  }


  // check for ETRN subdomain character
  if (*Ptr == '@')
  {
      //We could probably move this check to aqueue or keep it here
    if (!(QuerySmtpInstance()->AllowEtrnSubDomains()))
    {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Invalid domain name");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Invalid domain name");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
    }

    bSubDomain = TRUE;
  }

  // for @ command, check that this is at least a second tier domain (to avoid @com attack)
  if (bSubDomain)
  {
    if (!strchr(Ptr,'.'))
    {
     PE_CdFormatSmtpMessage (SMTP_RESP_NODE_INVALID, EINVALID_ARGS," Node %s not allowed: First tier domain\r\n", Ptr);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_NODE_INVALID - First tier domains are not allowed");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
    }

  }

  lstrcpyn(szNode, Ptr, AB_MAX_DOMAIN);
  char *szTmp;
  if (bSubDomain)
      szTmp = szNode + 1;
  else
      szTmp = szNode;

  if(!ValidateDRUMSDomain(szTmp, lstrlen(szTmp)))
  {
     //Not a valid domain -
     SetLastError(ERROR_INVALID_DATA);

     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Invalid domain name");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Invalid domain name");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //So we have a valid domain
  //Call into connection manager to start the queue
  //If multiple domains were dequed because the domain name was either wild card
  //or specifed with the @ sign
  hr = m_pInstance->GetConnManPtr()->ETRNDomain(lstrlen(szNode),szNode, &dwMessagesQueued);

  if(!FAILED(hr))
  {
      //We know about this ETRN domain
      if(!dwMessagesQueued)
      {
          if (bSubDomain || hr == AQ_S_SMTP_WILD_CARD_NODE)
          {
              PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_ZERO_MSGS, EPROT_SUCCESS," Ok, no messages waiting for node %s and sub nodes\r\n",
                                                         szNode);
          }
          else
          {
              PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_ZERO_MSGS, EPROT_SUCCESS," Ok, no messages waiting for node %s\r\n", szNode);
          }
      }
      else
      {
          if (bSubDomain || hr == AQ_S_SMTP_WILD_CARD_NODE)
          {
                PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_N_MSGS, EPROT_SUCCESS,
                                    " OK, %d pending messages for wildcard node %s started\r\n", dwMessagesQueued, szNode);
          }
          else
          {
                PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_N_MSGS, EPROT_SUCCESS,
                                    " OK, %d pending messages for node %s started\r\n",dwMessagesQueued, szNode);
          }
      }
  }
  else
  {
      if (hr == AQ_E_SMTP_ETRN_NODE_INVALID)
      {
          PE_CdFormatSmtpMessage (SMTP_RESP_NODE_INVALID, EINVALID_ARGS," Node %s not allowed: not configured as ETRN domain\r\n", szNode);
          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ++m_ProtocolErrors;
            ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Domain not allowed");
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
      }
      else
      {
          PE_CdFormatSmtpMessage (SMTP_RESP_ERROR, EINTERNAL_ERROR," Action aborted - internal error\r\n");
          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ErrorTrace((LPARAM) this, "Internal error ETRN processing");
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
      }
  }


  RetStatus = PE_SendSmtpResponse();

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;

}

/*++

    Name :
        SMTP_CONNECTION::DoSTARTTLSCommand

    Description:

        Responds to the SMTP STARTTLS command.

    Arguments:
        Parsed to determine the TLS protocol to use.

    Returns:

      TRUE normally. A FALSE return indicates to the caller that the
      client connection should be dropped.

--*/
BOOL SMTP_CONNECTION::DoSTARTTLSCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus, fStartSSL;
  char * Ptr = NULL;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoSTARTTLSCommand");

  _ASSERT (m_pInstance != NULL);

  fStartSSL = FALSE;

  //
  // check that the hello has been sent, and that we are not in the middle of sending
  // a message
  //
  if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Send hello first" );
     ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // Check that we have a certificate installed with which we can negotiate
  // a SSL session
  //

  if (!m_encryptCtx.CheckServerCert(
        (LPSTR) QueryLocalHostName(),
            (LPSTR) QueryLocalPortName(),
                (LPVOID) QuerySmtpInstance(),
                    QuerySmtpInstance()->QueryInstanceId())) {
     PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n", SMTP_NO_CERT_MSG);
     ProtocolLog(STARTTLS, (char *)InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
     ErrorTrace((LPARAM) this, "In DoSTARTTLSCommand():SMTP_RESP_TRANS_FAILED, SMTP_NO_CERT_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // if we are already secure, reject the request
  //
  if(m_SecurePort)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_ONLY_ONE_TLS_MSG);
     ProtocolLog(STARTTLS, (char *)InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "In DoSTARTTLSCommand():SMTP_RESP_BAD_SEQ, SMTP_ONLY_ONE_TLS_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // Switch over to using a large receive buffer, because a SSL fragment
  // may be up to 32K big.
  fStartSSL = SwitchToBigSSLBuffers();
  if (fStartSSL) {
      PE_CdFormatSmtpMessage(SMTP_RESP_READY, EPROT_SUCCESS," %s\r\n",  SMTP_READY_STR);
      ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_READY, 0, 0);
  } else {
      PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n", SMTP_NO_MEMORY);
      ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_NORESOURCES, 0, 0);
  }
  fStartSSL = TRUE;

  RetStatus = PE_SendSmtpResponse();

  if (fStartSSL)
      m_SecurePort = m_fNegotiatingSSL = TRUE;

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}

BOOL SMTP_CONNECTION::DoTLSCommand(const char * InputLine, DWORD parameterSize)
{
    return DoSTARTTLSCommand(InputLine, parameterSize);
}

//
// the default handler for end of data.  commit the recipients list and
// insert the message into the queue
//
BOOL SMTP_CONNECTION::Do_EODCommand(const char * InputLine, DWORD parameterSize)
{
    TraceFunctEnter("SMTP_CONNECTION::Do_EODCommand");

    HRESULT hr;
    char MessageId[1024];
    BOOL fQRet;

    MessageId[0] = 0;

    if( m_pIMsg )
    {
        m_pIMsg->GetStringA( IMMPID_MP_RFC822_MSG_ID, sizeof( MessageId ), MessageId );
    }

    MessageId[sizeof(MessageId)-1] = 0; // NULL terminate it.

    if(m_HopCount >= m_pInstance->GetMaxHopCount())
    {
        fQRet = m_pInstance->SubmitFailedMessage(m_pIMsg, MESSAGE_FAILURE_HOP_COUNT_EXCEEDED, 0);
        FatalTrace((LPARAM) this, "Hop count exceeded");
    }
    else
    {
        // check to see if we need to hold this message
        if (m_LocalHopCount >= 2) // if we're hitting this server for the 3rd time (or more)
        {
            if( m_pIMsg )
            {
                // Update the deferred delivery time property for this message
                SYSTEMTIME      SystemTime;
                ULARGE_INTEGER  ftDeferred; // == FILETIME
                DWORD           cbProp = 0;
                BOOL            fSuccess;

                // Get the current system time
                GetSystemTime (&SystemTime);

                // Convert it to a file time
                fSuccess = SystemTimeToFileTime(&SystemTime, (FILETIME*)&ftDeferred);
                _ASSERT(fSuccess);

                // Add 10 minutes
                ftDeferred.QuadPart += SMTP_LOOP_DELAY;

                hr = m_pIMsg->PutProperty(IMMPID_MP_DEFERRED_DELIVERY_FILETIME,
                                          sizeof(FILETIME), (BYTE *) &ftDeferred);

                DebugTrace( (LPARAM)this, "Possible Loop : Delaying message 10 minutes");
            }
        }

        fQRet = m_pInstance->InsertIntoQueue(m_pIMsg);
    }

    if(fQRet)
    {
       ReleasImsg(FALSE);
    }
    else
    {
          m_MailBodyError = GetLastError();
          //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    //Get the offset of the filename and send it back to the client
    //we send the status back to the client immediately, just incase
    //the session breaks abnormally, or because the client times out.
    //If the client times out, it would send another message and we
    //would get duplicate mail messages.

    //Note that the response string is limited in length, so we'll truncate
    //the MessageId if it is too long. Otherwise the reponse will be truncated
    //elsewhere, like before the SMTP_QUEUE_MAIL string which will be confusing.
    //MAX_REWRITTEN_MSGID is actually the maximum possible length of the entire
    //"Message-ID: xxx" header in a message.

    _ASSERT(sizeof(MessageId)/sizeof(char) > MAX_REWRITTEN_MSGID);
    MessageId[MAX_REWRITTEN_MSGID] = '\0';
    PE_CdFormatSmtpMessage (SMTP_RESP_OK, EMESSAGE_GOOD, " %s %s\r\n",MessageId, SMTP_QUEUE_MAIL);

    return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoQUITCommand

    Description:

        Responds to the SMTP QUIT command.
        This function always returns false.
        This will stop all processing and
        delete this object.

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNECTION::DoQUITCommand(const char * InputLine, DWORD parameterSize)
{

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoQUITCommand");

  _ASSERT (m_pInstance != NULL);

  //set our state
  m_State = QUIT;

  //send the quit response
  m_pInstance->LockGenCrit();
  PE_CdFormatSmtpMessage (SMTP_RESP_CLOSE, E_GOODBYE, " %s %s\r\n",m_pInstance->GetFQDomainName(), SMTP_QUIT_OK_STR);
  m_pInstance->UnLockGenCrit();

  PE_SendSmtpResponse();

  //disconnect the client
  PE_DisconnectClient();

  TraceFunctLeaveEx((LPARAM) this);
  return FALSE;
}

BOOL SMTP_CONNECTION::DoSizeCommand(char * Value, char * InputLine)
{
    DWORD EstMailSize = 0;
    DWORD EstSessionSize = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoSizeCommand");

    _ASSERT (m_pInstance != NULL);

    EstMailSize = atoi (Value);
    EstSessionSize = m_SessionSize + EstMailSize;

    if (EstMailSize == 0)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
        ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent 0 in SIZE command");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //check to make sure we are going over the servers max file size
    if((m_pInstance->GetMaxMsgSize() > 0) && (EstMailSize > m_pInstance->GetMaxMsgSize()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) )  || fShouldImposeLimit )
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, EMESSAGE_TOO_BIG," %s\r\n", SMTP_MAX_MSG_SIZE_EXCEEDED_MSG );
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", EstMailSize);
            ++m_ProtocolErrors;
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    // Check that the maximum session size has not been exceeded
    if((m_pInstance->GetMaxMsgSizeBeforeClose() > 0) && (EstSessionSize > m_pInstance->GetMaxMsgSizeBeforeClose()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) )  || fShouldImposeLimit )
        {
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d", EstMailSize);
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            DebugTrace((LPARAM) this, "GetMaxMsgSizeBeforeClose()  exceeded - closing connection");

            // Client won't be expecting this, but atleast an admin can tell
            // what's wrong from this response.
            FormatSmtpMessage(SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",
                    SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG);
            SendSmtpResponse();
            DisconnectClient();
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }


    return TRUE;
}

BOOL SMTP_CONNECTION::DoBodyCommand (char * Value, char * InputLine)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBodyCommand");

    _ASSERT (m_pInstance != NULL);

    if(!_strnicmp(Value, (char * )"8bitmime", 8))
    {
        m_pIMsg->PutDWORD(IMMPID_MP_EIGHTBIT_MIME_OPTION, 1);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else if((!_strnicmp(Value, (char * )"BINARYMIME", 10)) && m_pInstance->AllowBinaryMime())
    {
        m_fIsBinaryMime = TRUE;  //Need to get rid of this **
        m_pIMsg->PutDWORD(IMMPID_MP_BINARYMIME_OPTION, 1);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else if(!_strnicmp(Value, (char * )"7bit", 4))
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", SMTP_BAD_BODY_TYPE_STR );
        ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_BODY_TYPE_STR.");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }
}

BOOL SMTP_CONNECTION::DoRetCommand (char * Value, char * InputLine)
{
    char RetDsnValue[10];
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRetCommand");

    _ASSERT (m_pInstance != NULL);

    //strict size checking
    if(strlen(Value) < 5)
    {
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_RET_VALUE, sizeof(RetDsnValue), RetDsnValue);
        if(FAILED(hr))
        {
            if(!_strnicmp(Value, (char * )"FULL", 4) ||
                !_strnicmp(Value, (char * )"HDRS", 4))
            {
                hr = m_pIMsg->PutStringA(IMMPID_MP_DSN_RET_VALUE, Value);
                if(!FAILED(hr))
                {
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
                    ErrorTrace((LPARAM) this, "Failed to set RET value to IMSG");
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
        }
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n","Invalid arguments" );
    ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent bad RET value");
    ++m_ProtocolErrors;
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::IsXtext(char * Xtext)
{
    char * StartPtr = Xtext;
    char NextChar = '\0';

    while((NextChar = *StartPtr++) != '\0')
    {
        if(NextChar == '+')
        {
            NextChar = *StartPtr++;
            if(!isascii((UCHAR)NextChar) || !isxdigit((UCHAR)NextChar))
            {
                return FALSE;
            }
        }
        else if(NextChar < '!' || NextChar > '~' || NextChar == '=')
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SMTP_CONNECTION::DoEnvidCommand (char * Value, char * InputLine)
{
    HRESULT hr = S_OK;
    char EnvidValue[MAX_MAIL_FROM_ENVID_LEN+1];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoEnvidCommand");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (Value != NULL);
    _ASSERT (InputLine != NULL);

    hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_ENVID_VALUE, sizeof(EnvidValue), EnvidValue);
    if(FAILED(hr))
    {
        DWORD ValueLength = lstrlen(Value);

        if((ValueLength != 0) && (ValueLength <= MAX_MAIL_FROM_ENVID_LEN))
        {
            if(IsXtext(Value))
            {
                hr = m_pIMsg->PutStringA(IMMPID_MP_DSN_ENVID_VALUE, Value);
                if(!FAILED(hr))
                {
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
                    ErrorTrace((LPARAM) this, "Failed to set ENVID value to IMSG");
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
        }
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n","Invalid arguments" );
    ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent bad envid value");
    ++m_ProtocolErrors;
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::DoNotifyCommand (char * Value, DWORD * pdwNotifyValue)
{
    *pdwNotifyValue = 0;
    char * SearchPtr = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoNotifyCommand");

    _ASSERT (Value != NULL);

    if(!strcasecmp(Value, "NEVER"))
    {
        *pdwNotifyValue = RP_DSN_NOTIFY_NEVER;
    }
    else
    {
        for(SearchPtr = Value; SearchPtr != NULL; Value = SearchPtr)
        {
            SearchPtr = strchr(SearchPtr, ',');
            if(SearchPtr != NULL)
            {
                *SearchPtr++ = '\0';
            }

            if(!strcasecmp(Value, "SUCCESS"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_SUCCESS;
            }
            else if(!strcasecmp(Value, "FAILURE"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_FAILURE;
            }
            else if(!strcasecmp(Value, "DELAY"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_DELAY;
            }
            else
            {
                *pdwNotifyValue = RP_DSN_NOTIFY_INVALID;
                break;
            }
        }

        if(!*pdwNotifyValue)
        {
            *pdwNotifyValue = RP_DSN_NOTIFY_INVALID;
        }
    }

    if(*pdwNotifyValue == RP_DSN_NOTIFY_INVALID)
    {
        return FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

BOOL SMTP_CONNECTION::DoMailFromAuthArg (char * Value)
{

	HRESULT hr = S_OK;
	char chDummy;
	DWORD ValueLength;

	TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoMailFromAuthArg");

	_ASSERT (m_pInstance != NULL);
	_ASSERT (Value != NULL);

	ValueLength = lstrlen(Value);

	if((ValueLength != 0) && (ValueLength <= MAX_MAIL_FROM_AUTH_LEN)) {
		//
		// Verify that the property doesn't already exist.
		//
		hr = m_pIMsg->GetStringA(IMMPID_MP_INBOUND_MAIL_FROM_AUTH, 0, &chDummy);
		if(hr == STG_E_UNKNOWN) {
			if(IsXtext(Value)) {
				hr = m_pIMsg->PutStringA(IMMPID_MP_INBOUND_MAIL_FROM_AUTH, Value);
				if(!FAILED(hr)) {
					TraceFunctLeaveEx((LPARAM) this);
					return TRUE;
				} else {
					PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
					ErrorTrace((LPARAM) this, "Failed to set AUTH value to IMSG");
					TraceFunctLeaveEx((LPARAM) this);
					return FALSE;
				}
			}
		}
	}

	PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n","Invalid arguments" );
	ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent bad auth value");
	++m_ProtocolErrors;
	TraceFunctLeaveEx((LPARAM) this);
	return FALSE;
}

BOOL SMTP_CONNECTION::DoOrcptCommand (char * Value)
{
    char * XtextPtr = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoOrcptCommand");

    _ASSERT (m_pInstance != NULL);

    DWORD ValueLength = lstrlen(Value);

    if((ValueLength != 0) && (ValueLength <= MAX_RCPT_TO_ORCPT_LEN))
    {
        //NK** : Parse out the address type and validate it against IANA registered
        // mail address type
        if(XtextPtr = strchr(Value,';'))
        {
            if(IsXtext(XtextPtr+1))
            {
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::DoSmtpArgs (char *InputLine)
{
    char * Value = NULL;
    char * EndOfLine = NULL;
    char * Cmd = NULL;
    char * LinePtr = InputLine;
    char * SearchPtr = NULL;

    while(LinePtr && *LinePtr != '\0')
    {
        //find the beginning of the keyword
        LinePtr = (char *) strchr (LinePtr, '=');
        if(LinePtr != NULL)
        {

            SearchPtr = LinePtr;
            //Cmd = LinePtr - 4;
            while( (*SearchPtr != ' ') && (*SearchPtr != '\0'))
            {
                SearchPtr--;
            }

            Cmd = SearchPtr + 1;

            *LinePtr++ = '\0';
            Value = LinePtr;

            //Back track to the beginning of the byte
            //before the size command.  If that character
            //is a space, then we need to Null terminate
            //the string there.  If it's not a space, then
            //this is an error.
            EndOfLine = Cmd - 1;
            if(*EndOfLine == ' ')
                *EndOfLine = '\0';
            else if(*EndOfLine != '\0')
            {
                continue;
            }

            LinePtr = (char *) strchr(LinePtr, ' ');
            if(LinePtr != NULL)
            {
                *LinePtr++ = '\0';
            }

            if(!strcasecmp(Cmd, "SIZE"))
            {
                if(!DoSizeCommand(Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "BODY"))
            {
                if(!DoBodyCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "RET") && m_pInstance->AllowDSN())
            {
                if(!DoRetCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "ENVID") && m_pInstance->AllowDSN())
            {
                if(!DoEnvidCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "AUTH"))
            {
                if(! DoMailFromAuthArg(Value))
                    return FALSE;
            }
            else
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
                ++m_ProtocolErrors;
                return FALSE;
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
            ++m_ProtocolErrors;
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SMTP_CONNECTION::DoRcptArgs (char *InputLine, char * szORCPTval, DWORD * pdwNotifyVal)
{
    char * Value = NULL;
    char * EndOfLine = NULL;
    char * Cmd = NULL;
    char * LinePtr = InputLine;
    char * SearchPtr = NULL;
    *pdwNotifyVal = 0;
    BOOL fDoneOrcptCmd = FALSE;
    BOOL fDoneNotifyCmd = FALSE;


    while(LinePtr && *LinePtr != '\0')
    {
        if(!m_pInstance->AllowDSN())
            return FALSE;

        //find the beginning of the keyword
        LinePtr = (char *) strchr (LinePtr, '=');
        if(LinePtr != NULL)
        {

            SearchPtr = LinePtr;
            //Cmd = LinePtr - 4;
            while( (*SearchPtr != ' ') && (*SearchPtr != '\0'))
            {
                SearchPtr--;
            }

            Cmd = SearchPtr + 1;

            *LinePtr++ = '\0';
            Value = LinePtr;

            //Back track to the beginning of the byte
            //before the size command.  If that character
            //is a space, then we need to Null terminate
            //the string there.  If it's not a space, then
            //this is an error.
            EndOfLine = Cmd - 1;
            if(*EndOfLine == ' ')
                *EndOfLine = '\0';
            else if(*EndOfLine != '\0')
            {
                continue;
            }

            LinePtr = (char *) strchr(LinePtr, ' ');
            if(LinePtr != NULL)
            {
                *LinePtr++ = '\0';
            }

            if(!strcasecmp(Cmd, "NOTIFY") )
            {

                if( fDoneNotifyCmd || ( !DoNotifyCommand( Value, pdwNotifyVal ) ) )
                {
                    return FALSE;
                }

                fDoneNotifyCmd = TRUE;
            }
            else if(!strcasecmp(Cmd, "ORCPT"))
            {
                if( ( !fDoneOrcptCmd ) && DoOrcptCommand(Value))
                {
                    strcpy(szORCPTval,Value);
                    fDoneOrcptCmd = TRUE;
                }
                else
                {
                    *szORCPTval = '\0';
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;

}

//NK** : Receive header always completes sync
BOOL SMTP_CONNECTION::WriteRcvHeader(void)
{
    char * Address = NULL;
    char * VersionNum = NULL;
    CHAR  szText[2024];
    char szDateBuf [cMaxArpaDate];
    DWORD cbText =  0;
    DWORD Error = NO_ERROR;
    DWORD EstMailSize = 0;
    SYSTEMTIME  st;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::WriteRcvHeader");

    if(m_IMsgHandle == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //get the name of the sender to place into the mail header
    Address =  (char *) QueryClientUserName();
    _ASSERT (Address != NULL);

    //Dump the header line into the buffer
    GetLocalTime(&st);
    GetArpaDate(szDateBuf);

    VersionNum = strchr(g_VersionString, ':');
    if(VersionNum)
    {
        VersionNum += 2;
    }
    else
    {
        VersionNum = "";
    }

    m_pInstance->LockGenCrit();
    if(m_DNSLookupRetCode == SUCCESS)
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatSuccess,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }
    else if ( m_DNSLookupRetCode == LOOKUP_FAILED)
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatUnverified,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }
    else
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatFailed,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }

    m_pInstance->UnLockGenCrit();



    //if EstMailSize > 0, then the size command was given.  If the size command was
    //given and the value was 0, we would have caught it above and would skip over
    //this peice of code.
    if (EstMailSize > 0)
    {
        if(SetFilePointer(m_IMsgHandle->m_hFile, EstMailSize + cbText,
                      NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            Error = GetLastError();
            DWORD Offset = EstMailSize + cbText;

            //FormatSmtpMessage ("%d %s %s\r\n",SMTP_RESP_NORESOURCES, ENO_RESOURCES, SMTP_NO_STORAGE );
            //ProtocolLog(MAIL, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            FatalTrace((LPARAM) this, " SetFilePointer failed - %d", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        if(!SetEndOfFile(m_IMsgHandle->m_hFile))
        {
            Error = GetLastError();

            //ProtocolLog(MAIL, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            //PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
            FatalTrace((LPARAM) this, " SetEndOfFile failed - %d", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        DWORD dwPointer;
        dwPointer = SetFilePointer(m_IMsgHandle->m_hFile, 0, NULL, FILE_BEGIN);

        //if we get here, this should always pass
        _ASSERT (dwPointer != 0xFFFFFFFF);
    }

    _ASSERT(m_pFileWriteBuffer);
    _ASSERT(m_pFileWriteBuffer->GetData());
    CopyMemory((m_pFileWriteBuffer->GetData() + m_cbCurrentWriteBuffer),szText,m_HeaderSize);
    m_cbCurrentWriteBuffer += m_HeaderSize;

    wsprintf(szText,"%s, %s",Daynames[st.wDayOfWeek], szDateBuf);

    hr = m_pIMsg->PutStringA(IMMPID_MP_ARRIVAL_TIME, szText);
    if(FAILED(hr))
    {
        Error = GetLastError();
        //FormatSmtpMessage ("%d %s %s\r\n",SMTP_RESP_NORESOURCES, ENO_RESOURCES, SMTP_NO_STORAGE );
        FatalTrace((LPARAM) this, " MailInfo->SetSenderToStream");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    return TRUE;
}


/*++

    Name :
        SMTP_CONNECTION::DoMAILCommand

    Description:

        Responds to the SMTP MAIL command.
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoMAILCommand(const char * InputLine, DWORD ParameterSize)
{
  char * Ptr = NULL;
  char * SizeCmd = NULL;
  //char * Address = NULL;
  char * Value = NULL;
  CAddr * NewAddress = NULL;
  DWORD EstMailSize = 0;
  DWORD cbText =  0;
  DWORD Error = NO_ERROR;
  BOOL FoundSizeCmd = FALSE;
  HRESULT hr = S_OK;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoMAILCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //Check if HELO or EHELO
  if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
     ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_BAD_SEQ, Send hello first");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  if(!m_HelloSent)
  {
     m_HelloSent = TRUE;
  }

  if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  //disallow mail from more than once
  if(m_RecvdMailCmd)
  {
     ++m_ProtocolErrors;
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Sender already specified" );
      ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //We should reset the current hop count when we get a new mail.  If we don't
  //do this, we might NDR the mail that comes later in the session.
  m_HopCount = 0;
  m_LocalHopCount = 0;

  //start parsing from the beginning of the line
  Ptr = (char *) InputLine;

  //check if argument have the right format
  Ptr = CheckArgument(Ptr);
  if (Ptr == NULL)
  {
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }
  //skip over from:
  Ptr = SkipWord (Ptr, "From", 4);
  if (Ptr == NULL)
  {
    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
  }

    DWORD dwAddressLen = 0;
    DWORD dwCanonAddrLen = 0;
    char * ArgPtr = NULL;
    char * AddrPtr = NULL;
    char * CanonAddrPtr = NULL;
    char * DomainPtr = NULL;
    m_szFromAddress[0] = '\0';

    //Parse out the address and possible argumets from the input line
    if(!Extract821AddressFromLine(Ptr,&AddrPtr,&dwAddressLen,&ArgPtr))
    {
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check if we have valid tail and address
    if(!AddrPtr)
    {
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check for the special case <> from address
    if(dwAddressLen == 2 && *AddrPtr == '<' && *(AddrPtr+1) == '>')
    {
        //simply copy this as the validated address
        lstrcpy(m_szFromAddress,"<>");
    }
    else
    {
        //Extract the canonical address in the <local-part> "@" <domain> form
        if(!ExtractCanonical821Address(AddrPtr,dwAddressLen,&CanonAddrPtr,&dwCanonAddrLen))
        {
            SetLastError(ERROR_INVALID_DATA);
            HandleAddressError((char *)InputLine);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //If we have a Canonical addr - validate it
        if(CanonAddrPtr)
        {
            strncpy(m_szFromAddress,CanonAddrPtr,dwCanonAddrLen);
            *(m_szFromAddress + dwCanonAddrLen) = '\0';

            if(!Validate821Address(m_szFromAddress, dwCanonAddrLen))
            {
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }

            //Extract
            if(!Get821AddressDomain(m_szFromAddress,dwCanonAddrLen,&DomainPtr))
            {
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
            else
            {
                //Is the RDNS enabled for MAILFROM command
                if(m_pInstance->IsRDNSEnabledForMAIL())
                {
                    DWORD dwDNSLookupRetCode = SUCCESS;
                    //If we have the RDNS option on MAIL from domain
                    //we cannot get a NULL domain on MAIL from
                    if(DomainPtr)
                    {
                        dwDNSLookupRetCode = VerifiyClient (DomainPtr,DomainPtr);
                        if(dwDNSLookupRetCode == NO_MATCH)
                        {
                            PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, ENO_SECURITY_TMP," %s\r\n",SMTP_RDNS_REJECTION);

                            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                            ++m_ProtocolErrors;
                            ErrorTrace((LPARAM) this, "Rejected Mail From : RDNS failed for %s", DomainPtr);
                            TraceFunctLeaveEx((LPARAM) this);
                            return TRUE;
                        }
                        else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                        {
                            //We had an internal DNS failure
                            PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                            ++m_ProtocolErrors;
                            ErrorTrace((LPARAM) this, "Rejected MAILFROM : RDNS DNS failure for %s", DomainPtr);
                            TraceFunctLeaveEx((LPARAM) this);
                            return TRUE;
                        }
                    }
                    else
                    {
                        PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, ENO_SECURITY_TMP," %s\r\n",SMTP_RDNS_REJECTION);
                        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                        ++m_ProtocolErrors;
                        ErrorTrace((LPARAM) this, "Rejected Mail From : no domain specified");
                        TraceFunctLeaveEx((LPARAM) this);
                        return TRUE;
                    }
                }
            }

        }
        else
        {
            SetLastError(ERROR_INVALID_DATA);
            HandleAddressError((char *)InputLine);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }



        //rewrite the address if it's not the NULL address,
        //and the masquerading option is on
        if(m_pInstance->ShouldMasquerade() && !ISNULLADDRESS(m_szFromAddress)
          && (!DomainPtr || m_pInstance->IsALocalDomain(DomainPtr)))
        {
            if(!m_pInstance->MasqueradeDomain(m_szFromAddress, DomainPtr))
            {
                //it failed.  Inform the user
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
        else if(!DomainPtr && !ISNULLADDRESS(m_szFromAddress))
        {
            //If there is no domain on this address,
            //then append the current domain to this
            //address. However, if we get the <>
            //address, don't append a domain

            if(!m_pInstance->AppendLocalDomain (m_szFromAddress))
            {
                //it failed.  Inform the user
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }


    //parse the arguments, if any
    if(!DoSmtpArgs (ArgPtr))
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    _ASSERT (m_szFromAddress != NULL);
    _ASSERT (m_szFromAddress[0] != '\0');

    hr = m_pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, m_szFromAddress);
    if(FAILED(hr))
    {
        Error = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, " MailInfo->SetSenderToStream");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    m_RecvdMailCmd = TRUE;
    m_State = MAIL;

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, ESENDER_ADDRESS_VALID," %s....Sender OK\r\n", m_szFromAddress);

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoRCPTCommand

    Description:

        Responds to the SMTP RCPT command.
        This funcion gets the addresses and
        places then into a linked list.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoRCPTCommand(const char * InputLine, DWORD ParameterSize)
{
    char * ToName = NULL;
    char * ThisAddress = NULL;
    CAddr * NewAddress = NULL;
    CAddr * TempAddress = NULL;
    BOOL IsDomainValid = TRUE; //assume everyone is O.K
    BOOL RelayThisMail = FALSE;
    BOOL DropQuotaExceeded = FALSE;

    DWORD    dwPropId = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwNewRecipIndex = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRCPTCommand");

    _ASSERT(m_pInstance != NULL);

    //If the current state is BDAT the only command that can be received is BDAT
    if(m_State == BDAT)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "BDAT Expected" );
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_HelloSent)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Send hello first" );
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_fAuthAnon && !m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n","Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoRCPTCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //see if we got a valid return path before going on
    if(!m_RecvdMailCmd || !m_pIMsg || !m_pIMsgRecips || (m_szFromAddress[0] == '\0') )
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_NEED_MAIL_FROM_MSG);
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "In DoRCPTCommand():SMTP_RESP_BAD_SEQ, SMTP_NEED_MAIL_FROM_MSG");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //start at inputline
    ToName = (char *) InputLine;

    //set the state
    m_State = RCPT;

    m_RecvdRcptCmd = TRUE;

    //check if argument have the right format
    ToName = CheckArgument(ToName);
    if (ToName == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    ToName = SkipWord (ToName, "To", 2);
    if (ToName == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    char * DomainPtr = NULL;
    char * ArgPtr = NULL;
    char   szRcptAddress[MAX_INTERNET_NAME + 1];
    szRcptAddress[0] = '\0';

    DWORD  dwNotifyVal;
    char   szOrcptVal[MAX_RCPT_TO_ORCPT_LEN + 1];
    szOrcptVal[0] = '\0';


    if(!ExtractAndValidateRcpt(ToName, &ArgPtr, szRcptAddress, &DomainPtr ))
    {
        // If failed.  Inform the user
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Parse out the DSN values if any
    //parse the arguments, if any
    if(!DoRcptArgs (ArgPtr, szOrcptVal, &dwNotifyVal))
    {
        //it failed.  Inform the user
        DWORD dwError = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
        m_CInboundContext.SetWin32Status(dwError);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //check to see if there is any room in the inn.
    //if the remote queue entry is allocated, check
    //that also.
    DWORD TotalRcpts = 0;
    hr = m_pIMsgRecips->Count(&TotalRcpts);

    if( FAILED(hr) ||  ((m_pInstance->GetMaxRcpts() > 0) && ((TotalRcpts + 1) > m_pInstance->GetMaxRcpts())))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ETOO_MANY_RCPTS, " %s\r\n",SMTP_TOO_MANY_RCPTS);
        ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
        // don't count too many rcpts as protocol errors as this will
        // close the connection.
        //++m_ProtocolErrors;
        delete NewAddress;
        NewAddress = NULL;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //If the relay check feature is enabled make sure that this
    //recipient is to be accepted for relay
    if(m_pInstance->IsRelayEnabled())
    {
        hr = HrShouldAcceptRcpt(DomainPtr);
        if ( S_OK == hr ) RelayThisMail = TRUE;
        else if (S_FALSE == hr ) RelayThisMail = FALSE;
        else
        {
            // Currently, HrShouldAcceptRcpt only return error when AQueue is already shut down or out of memory.
            _ASSERT(FAILED(hr));
            PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, ESVC_SHUTDOWN," %s\r\n",SMTP_SRV_UNAVAIL_STR);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    if (m_pInstance->IsDropDirQuotaCheckingEnabled())
    {
        //We only enforce drop dir quota checking on local and alias domains.  Since
        //this is turned on by default, we assume that anyone who has setup there own
        //non-default drop domain is has some agent the will process mail put in it.
        if (m_pInstance->IsADefaultOrAliasDropDomain(DomainPtr))
            DropQuotaExceeded = m_pInstance->IsDropDirQuotaExceeded();
    }

    ThisAddress = szRcptAddress;
    if(RelayThisMail && !DropQuotaExceeded)
    {
        hr = m_pIMsgRecips->AddPrimary(1, (LPCTSTR *) &ThisAddress, &dwPropId,
            &dwNewRecipIndex, NULL, 0);
        if(!FAILED(hr))
        {
            //If we have any associated DSn values set them
            if(szOrcptVal && szOrcptVal[0] != '\0')
            {
                hr = m_pIMsgRecips->PutStringA(dwNewRecipIndex, IMMPID_RP_DSN_ORCPT_VALUE,(LPCSTR)szOrcptVal);
                if(FAILED(hr))
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
                    ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
                }
            }

            //If we have any associated DSn values set them
            //If we have any associated DSn values set them
            if(!FAILED(hr) && dwNotifyVal & RP_DSN_NOTIFY_MASK)
            {
                //hr = m_pIMsgRecips->PutDWORD(dwNewRecipIndex, IMMPID_RP_DSN_NOTIFY_VALUE, dwNotifyVal);
                hr = m_pIMsgRecips->PutDWORD(dwNewRecipIndex,IMMPID_RP_RECIPIENT_FLAGS, dwNotifyVal);
                if(FAILED(hr))
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n", SMTP_NO_STORAGE);
                    ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
                }
            }

            if(!FAILED(hr))
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_OK, EVALID_DEST_ADDRESS, " %s \r\n",szRcptAddress);
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
            ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
        }
    }
    else if (DropQuotaExceeded)
    {
        PE_CdFormatSmtpMessage (SMTP_INSUFF_STORAGE_CODE, EMAILBOX_FULL, " Mailbox full\r\n");
    }
    else
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_NOT_FOUND, ENO_FORWARDING, " Unable to relay for %s\r\n", szRcptAddress);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}
/*++

    Name :
        SMTP_CONNECTION::HrShouldAcceptRcpt

    Description:
        Check whether we should accept the recipients

    Arguments:
        szDomainName

    Returns:
        HRESULT:
        	S_OK: we should accept it
        	S_FALSE: we should not accept it
        	other error code:
        	    Currently we only return error when HrGetDomainInfoFlags returns AQUEUE_E_SHUTDOWN ( fix for bug 214591 )
        	    or E_OUTOFMEMORY

--*/
HRESULT SMTP_CONNECTION::HrShouldAcceptRcpt(char * szDomainName )
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HrShouldAcceptRcpt");
    HRESULT     hr;
    DWORD       dwDomainInfoFlags;

    hr = m_pInstance->HrGetDomainInfoFlags(szDomainName, &dwDomainInfoFlags);
    if (SUCCEEDED(hr)) {
        if ( (dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX) ||
             (dwDomainInfoFlags & DOMAIN_INFO_ALIAS) ||
             (dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP)) {
            TraceFunctLeaveEx((LPARAM) this);
            return S_OK;
        }
        else if(dwDomainInfoFlags & DOMAIN_INFO_DOMAIN_RELAY) {
            TraceFunctLeaveEx((LPARAM) this);
            return S_OK;
        }
        else if( (m_fAuthenticated && (dwDomainInfoFlags & DOMAIN_INFO_AUTH_RELAY)) ||
            DoesClientHaveIpAccess() ) {
            TraceFunctLeaveEx((LPARAM) this);
            return S_OK;
        }
    }
    else if (AQUEUE_E_SHUTDOWN == hr || E_OUTOFMEMORY == hr)
    {
        // special case: if Aqueue is already shutdown or we're out of memory, return with error
        ErrorTrace((LPARAM) this, "HrGetDomainInfoFlags() failed with 0x%x", hr);
        TraceFunctLeaveEx((LPARAM) this);
        return hr;
    }
    else
    {
        DebugTrace((LPARAM) this, "HrGetDomainInfoFlags() failed with 0x%x", hr);
        if(DoesClientHaveIpAccess() ||
            (m_fAuthenticated && m_pInstance->RelayForAuthUsers())) {
            TraceFunctLeaveEx((LPARAM) this);
            return S_OK;
        }
    }

	//
    // See if this connection is permitted to relay..
    //
    if (m_fMayRelay) {
       TraceFunctLeaveEx((LPARAM) this);
    	return S_OK;
    }
    TraceFunctLeaveEx((LPARAM) this);
    return S_FALSE;
}

BOOL SMTP_CONNECTION::ExtractAndValidateRcpt(char * ToName, char ** ppArgument, char * szRcptAddress, char ** ppDomain )
{
    DWORD dwAddressLen = 0;
    DWORD dwCanonAddrLen = 0;

    char * AddrPtr = NULL;
    char * CanonAddrPtr = NULL;

    //Parse out the address and possible argumets from the input line
    if(!Extract821AddressFromLine(ToName,&AddrPtr,&dwAddressLen,ppArgument))
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //Check if we have valid tail and address
    if(!AddrPtr)
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //Extract the canonical address in the <local-part> "@" <domain> form
    if(!ExtractCanonical821Address(AddrPtr,dwAddressLen,&CanonAddrPtr,&dwCanonAddrLen))
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //If we have a Canonical addr - validate it
    if(CanonAddrPtr)
    {
        strncpy(szRcptAddress,CanonAddrPtr,dwCanonAddrLen);
        *(szRcptAddress + dwCanonAddrLen) = '\0';

        if(!Validate821Address(szRcptAddress, dwCanonAddrLen))
        {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        //Extract
        if(!Get821AddressDomain(szRcptAddress,dwCanonAddrLen,ppDomain))
        {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    if(!(*ppDomain) && !ISNULLADDRESS(szRcptAddress))
    {
        //If there is no domain on this address,
        //then append the current domain to this
        //address.
        if(!m_pInstance->AppendLocalDomain (szRcptAddress))
        {
            return FALSE;
        }
        //Update the DomainPtr to be after the '@' sign
        //we could be safer and do a strchr
        (*ppDomain) = szRcptAddress + dwCanonAddrLen + 1;
    }
    return TRUE;
}

BOOL SMTP_CONNECTION::BindToStoreDrive(void)
{
    SMTP_ALLOC_PARAMS AllocParams;
    DWORD Error = 0;
    BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::BindToStore");

    AllocParams.BindInterfacePtr = (PVOID) m_pBindInterface;
    AllocParams.IMsgPtr = (PVOID) m_pIMsg;
    AllocParams.hContent = NULL;
    AllocParams.hr = S_OK;
    //For client context pass in something that will stay around the lifetime of the
    //atqcontext -
    AllocParams.pAtqClientContext = m_pInstance;

    if(m_pInstance->AllocNewMessage (&AllocParams) && !FAILED(AllocParams.hr))
    {
        m_IMsgHandle = AllocParams.hContent;

        if(WriteRcvHeader())
        {
            fRet = TRUE;
        }
        else
        {
            Error = GetLastError();
            //ProtocolLog(, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            FatalTrace((LPARAM) this, "WriteRcvHeader failed %d", Error);
            SetLastError(Error);
        }
    }
    else
    {
        FatalTrace((LPARAM) this,
            "AllocNewMessage failed hr 0x%08X, GetLastError %d",
            AllocParams.hr, GetLastError());
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::DoDATACommand

    Description:

        Responds to the SMTP DATA command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoDATACommand(const char * InputLine, DWORD parameterSize)
{
    HRESULT hr = S_OK;
    DWORD TotalRcpts = 0;
    DWORD fIsBinaryMime = 0;
    DWORD Error = 0;

  _ASSERT(m_pInstance != NULL);

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoDATACommand");

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(m_pIMsgRecips && m_pIMsg)
  {
    hr = m_pIMsgRecips->Count(&TotalRcpts);

    if(!FAILED(hr))
    {
        m_pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, TotalRcpts );

        hr = m_pIMsg->GetDWORD(IMMPID_MP_BINARYMIME_OPTION, &fIsBinaryMime);
    }
  }



  // Cannot use the DATA command if the body type was BINARYMIME
  if(!FAILED(hr) && fIsBinaryMime)
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Body type BINARYMIME requires BDAT" );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Body type BINARYMIME requires BDAT");
    BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
    ++m_ProtocolErrors;
  }

  //Only save data if HELO was sent and there is at least one recipient.
  //send a message stating "no good recepients",
  //or something like that if both lists are empty.
  else if(!m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
     ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
  }
  else if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_MUST_SECURE, 0, 0);
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  else if (!m_RecvdMailCmd || !m_pIMsg)
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Need mail command." );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need mail command.");
    BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
    ++m_ProtocolErrors;
  }
  else if(TotalRcpts)
  {
    m_cbCurrentWriteBuffer = 0;
    if(BindToStoreDrive())
    {
        m_State = DATA;
        if(!m_pInstance->ShouldParseHdrs())
        {
            m_TimeToRewriteHeader = FALSE;
            m_InHeader = FALSE;
        }
        PE_CdFormatSmtpMessage (SMTP_RESP_START, NULL," %s\r\n",SMTP_START_MAIL_STR);
    }
    else
    {
        DWORD dwErr = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
        ProtocolLog(DATA, (char *)InputLine, ERROR_NOT_ENOUGH_MEMORY, SMTP_RESP_NORESOURCES, 0, 0);
        SmtpLogEventEx(SMTP_EVENT_CANNOT_CREATE_FILE, m_pInstance->GetMailQueueDir(), dwErr);
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
    }
  }
  else if (!m_RecvdRcptCmd)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need Rcpt command." );
     ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need Rcpt command.");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
  }
  else
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ESYNTAX_ERROR," %s\r\n", SMTP_NO_VALID_RECIPS );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_TRANS_FAILED, SMTP_NO_VALID_RECIPS");
    ++m_ProtocolErrors;
  }

  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoBDATCommand

    Description:

        Responds to the SMTP BDAT command. Parses to check if this
        is the last BDAT.

        Error processing for BDAT is more complex than other SMTP commands
        because the RFC forbids a response to BDAT (even error responses that
        the server cannot process BDAT). If we try to send an error  response
        immediately after a BDAT command, we will go out of sync with the
        client because the client is not expecting a response... it is trying
        to send us chunk data, and the client expects us to have posted a TCP
        read to receive the chunk data.

        Errors handled by this function fall into 2 categories:

        (1) Errors by the client, such as sending improperly formatted
            chunksizes, bad syntax for the BDAT command.

        (2) Errors such as failure to allocate memory, restrictions on session
            size and message size, client must authenticate first, client must
            negotiate TLS first, etc.

        In the first case, we can reject the command with an error response,
        if the BDAT command is garbled, there's not much we can do.


        In the second case, we can generate a reasonable error response to be
        sent to the client. We should wait for our turn before doing so, i.e.
        we should accept and discard the BDAT chunks sent by the client, and
        when it it time to ack the chunk, then we send the error response. This
        is implemented by setting the m_MailBodyDiagnostic to the appropriate error, and
        calling AcceptAndDiscardBDAT which handles receiving and discarding
        chunk data and generating error responses when appropriate.

    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoBDATCommand(const char * InputLine, DWORD parameterSize)
{

  HRESULT hr = S_OK;
  DWORD TotalRcpts = 0;
  MailBodyDiagnosticCode mailBodyDiagnostic = ERR_NONE;

  _ASSERT(m_pInstance != NULL);

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATCommand");

  if(m_pIMsgRecips && m_pIMsg)
  {
      hr = m_pIMsgRecips->Count(&TotalRcpts);
      m_pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, TotalRcpts );
  }

  //We parse this command ONLY if we advertise either chunking or binarymime
  if(!m_pInstance->AllowChunking() && !m_pInstance->AllowBinaryMime())
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, EINVALID_COMMAND," %s\r\n", SMTP_NOT_IMPL_STR);
      ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_BAD_CMD, SMTP_NOT_IMPL_STR");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(!m_HelloSent)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_HELO_NEEDED;
  }
  else if(!m_fAuthAnon && !m_fAuthenticated)
  {
        ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_MUST_SECURE, 0, 0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        mailBodyDiagnostic = ERR_AUTH_NEEDED;
  }
  else if (!m_RecvdMailCmd || !m_pIMsg)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need mail command.");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_MAIL_NEEDED;
  }
  else if (!m_RecvdRcptCmd)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need Rcpt command.");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_RCPT_NEEDED;
  }
  else if (FAILED(hr) || 0 == TotalRcpts)
  {
    ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_TRANS_FAILED, SMTP_NO_VALID_RECIPS");
    ++m_ProtocolErrors;
    mailBodyDiagnostic = ERR_NO_VALID_RCPTS;
  }

    char * Argument = (char *) InputLine;
    DWORD dwEstMsgSize = 0;
    DWORD dwEstSessionSize = 0;

    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;

    // Just parse for size and if this is last chunk
    Argument = CheckArgument(Argument);
    if (Argument == NULL)
    {
        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent no CHUNK SIZE");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    // make sure the argument is all digits
    BOOL fBadChunkSize = FALSE;
    for( int i=0; ( ( Argument[i] != 0 ) && ( Argument[i] != ' ' ) ) ; i++ )
    {
        if( !isdigit( (UCHAR) Argument[i] ) )
        {
            fBadChunkSize = TRUE;
            break;
        }
    }



    // Get the chunk size
    m_nChunkSize = atoi (Argument);
    m_nBytesRemainingInChunk = m_nChunkSize + m_cbTempBDATLen;

    if(m_nChunkSize < 0)
    {
        fBadChunkSize = TRUE;
    }
    else if(m_nChunkSize == 0 && m_State != BDAT)
    {
        // Chunk size may be 0, but not on the first chunk
        fBadChunkSize = TRUE;
    }

    if( fBadChunkSize )
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n","Invalid CHUNK size value" );
        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent 0 as CHUNK SIZE");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    // Add this to the mail already received
    // check to make sure we are not going over the servers max message size

    dwEstSessionSize = m_nBytesRemainingInChunk + m_SessionSize;
    dwEstMsgSize = m_nBytesRemainingInChunk +  m_TotalMsgSize;

    if(ERR_NONE == mailBodyDiagnostic)
    {
        if((m_pInstance->GetMaxMsgSize() > 0) && (dwEstMsgSize > m_pInstance->GetMaxMsgSize()))
        {
            BOOL fShouldImposeLimit = TRUE;
            if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
            {
                ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
                ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", dwEstMsgSize);
                ++m_ProtocolErrors;
                BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                mailBodyDiagnostic = ERR_MAX_MSG_SIZE;
            }
        }
    }

    // Check that we are below the max session size allowed on the Server.
    if((m_pInstance->GetMaxMsgSizeBeforeClose() > 0) && (dwEstSessionSize > m_pInstance->GetMaxMsgSizeBeforeClose()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
        {
            ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d", dwEstSessionSize);
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);

            // Client won't be expecting this, but atleast an admin can tell
            // what's wrong from this response.
            FormatSmtpMessage(SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",
                    SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG);
            SendSmtpResponse();
            DisconnectClient();
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    //Check for the presence of the LAST keyword
    Argument = strchr(Argument,' ');
    if(Argument != NULL)
    {
        //get rid of white space
        while(isspace((UCHAR)*Argument))
            Argument++;

        if(*Argument != '\0')
        {
            if(!_strnicmp(Argument,(char *)"LAST",4))
            {
                //This is the last BDAT chunk
                m_fIsLastChunk = TRUE;
            }

            else
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n", "Invalid CHUNK size value" );
                ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
                ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent 0 as CHUNK SIZE");
                ++m_ProtocolErrors;
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }

    // Only the last chunk is allowed to have size = 0
    if(!m_fIsLastChunk && m_nChunkSize == 0)
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n",
                "Invalid CHUNK size value" );
        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
        ErrorTrace((LPARAM) this,
            "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent 0 as CHUNK SIZE");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    m_fIsChunkComplete = FALSE;

    if(m_State != BDAT)
    {
        //we are here for the first time
        m_State = BDAT;
        m_cbCurrentWriteBuffer = 0;

        // If there was an error while processing this BDAT command, flag it (m_MailBodyDiagnostic) & exit.
        m_MailBodyDiagnostic = mailBodyDiagnostic;

        if(mailBodyDiagnostic != ERR_NONE)
            goto Exit;

        if(!BindToStoreDrive())
        {
            //
            // Cannot process BDAT due to error accessing mail-store. Flag the error & exit.
            //

            m_MailBodyError = ERROR_NOT_ENOUGH_MEMORY;
            m_MailBodyDiagnostic = ERR_OUT_OF_MEMORY;
            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
            ProtocolLog(BDAT, (char *)InputLine, ERROR_NOT_ENOUGH_MEMORY, SMTP_RESP_NORESOURCES, 0, 0);
            ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - Allocating stream failed");
            SmtpLogEventEx(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR , "Invalid Mail Queue Directory", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    //
    // If there was an error during this BDAT, flag it... but if there was an error in a
    // previous BDAT command (within the same group of BDATs), preserve it. Once a BDAT fails,
    // all subsequent BDATs will fail. m_MailBodyDiagnostic is reset only when a new BDAT group is
    // started (the first BDAT in a group of BDATs or RSET).
    //

    if(m_MailBodyDiagnostic == ERR_NONE) // Don't overwrite
        m_MailBodyDiagnostic = mailBodyDiagnostic; // Error during this BDAT

    if(m_MailBodyDiagnostic != ERR_NONE) // Should this BDAT succeed?
        goto Exit;


    // There is no response for BDAT command
    if(!m_pInstance->ShouldParseHdrs())
    {
        m_TimeToRewriteHeader = FALSE;
        m_InHeader = FALSE;
    }

Exit:
  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

void SMTP_CONNECTION::ReleasRcptList(void)
{
    IMailMsgRecipients * pRcptList = NULL;
    IMailMsgRecipientsAdd * pRcptListAdd = NULL;

    pRcptListAdd = (IMailMsgRecipientsAdd *) InterlockedExchangePointer((PVOID *) &m_pIMsgRecips, (PVOID) NULL);
    if (pRcptListAdd != NULL)
    {
        pRcptListAdd->Release();
    }

    pRcptList = (IMailMsgRecipients *) InterlockedExchangePointer((PVOID *) &m_pIMsgRecipsTemp, (PVOID) NULL);
    if (pRcptList != NULL)
    {
        pRcptList->Release();
    }
}

void SMTP_CONNECTION::ReleasImsg(BOOL DeleteIMsg)
{
    IMailMsgProperties * pMsg = NULL;
    IMailMsgQueueMgmt * pMgmt = NULL;
    HRESULT hr = S_OK;

    pMsg = (IMailMsgProperties *) InterlockedExchangePointer((PVOID *) &m_pIMsg, (PVOID) NULL);
    if (pMsg != NULL)
    {
        ReleasRcptList();

        if(m_pBindInterface)
        {
            //if(DeleteIMsg)
            //{
            //    m_pBindAtqInterface->ReleaseATQHandle();
            //}

            m_pBindInterface->Release();
        }

        if(DeleteIMsg)
        {
            hr = pMsg->QueryInterface(IID_IMailMsgQueueMgmt, (void **)&pMgmt);
            if(!FAILED(hr))
            {
                pMgmt->Delete(NULL);
                pMgmt->Release();
            }
        }

        pMsg->Release();
    }
}

/*++

    Name :
        SMTP_CONNECTION::HandleCompletedMessage

    Description:

        This function gets called when the client
        sends the CRLF.CRLF sequence saying the
        message is complete.  The function truncates
        the message to the current size, if the client
        lied and gave us a larger size in the FROM command,
        and them queues the message to the Local/Remote
        queues for processing.
    Arguments:

        None.

    Returns:

      TRUE if the message was written to disk and queued.
      FALSE in all other cases.

--*/
BOOL SMTP_CONNECTION::HandleCompletedMessage(DWORD dwCommand, BOOL *pfAsyncOp)
{

    DWORD AbOffset = 0;
    char MessageId[1024];
    HRESULT hr = S_OK;
    DWORD TrailerSize = 0;    //used to strip out the trailing ".CRLF"
    BOOL fPended = FALSE;
    BOOL fQRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleCompletedMessage(void)");

    _ASSERT(m_pInstance != NULL);

    //hack to make transaction logging work
    AddCommandBytesRecv(m_TotalMsgSize);

    MessageId[0] = 0;

    if( m_pIMsg )
    {
        m_pIMsg->GetStringA( IMMPID_MP_RFC822_MSG_ID, sizeof( MessageId ), MessageId );
        m_pIMsg->PutDWORD( IMMPID_MP_MSG_SIZE_HINT, m_TotalMsgSize );
    }

    MessageId[sizeof(MessageId)-1] = 0; // NULL terminate it.


    //Depending on dwCommand the TrailerSize will vary
    //For BDAT = 0
    //For DATA = 3
    if(dwCommand == BDAT )
        TrailerSize = 0;

    DWORD cbTotalMsgSize = 0;

    if( m_fFoundEmbeddedCrlfDotCrlf )
    {
        cbTotalMsgSize = m_cbDotStrippedTotalMsgSize;
    }
    else
    {
        cbTotalMsgSize = m_TotalMsgSize;
    }

    if(SetFilePointer(m_IMsgHandle->m_hFile, (cbTotalMsgSize + m_HeaderSize) - TrailerSize, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
          m_MailBodyError = GetLastError();
          //FatalTrace((LPARAM) this, "SetFilePointer failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          ProtocolLog(dwCommand, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    if(!SetEndOfFile(m_IMsgHandle->m_hFile))
    {
          m_MailBodyError = GetLastError();
         // FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          ProtocolLog(dwCommand, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    hr = m_pIMsgRecipsTemp->WriteList(m_pIMsgRecips);
    if(FAILED(hr))
    {
        m_MailBodyError = GetLastError();
        //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
        m_CInboundContext.SetWin32Status(m_MailBodyError);
        ProtocolLog(dwCommand, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
        SendSmtpResponse();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;

    }

    m_pIMsg->PutDWORD( IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF, m_fScannedForCrlfDotCrlf );
    m_pIMsg->PutDWORD( IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, m_fFoundEmbeddedCrlfDotCrlf );

    hr = m_pIMsg->Commit(NULL);

    if(FAILED(hr))
    {
        m_MailBodyError = GetLastError();
        //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
        m_CInboundContext.SetWin32Status(m_MailBodyError);
        ProtocolLog(dwCommand, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
        SendSmtpResponse();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;

    }

    ReleasRcptList();

    // Fire the end of data event.  The default implementation of this
    // commits the message
    char szVerb[] = "_EOD";
    DWORD CmdSize;

    m_dwCurrentCommand = SmtpGetCommand(szVerb, sizeof(szVerb), &CmdSize);
    BOOL fReturn =
        GlueDispatch((char *)szVerb, sizeof(szVerb), CmdSize, pfAsyncOp);
    if (!fReturn) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (*pfAsyncOp) {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    SendSmtpResponse();

    ProtocolLog(dwCommand, MessageId, NO_ERROR, SMTP_RESP_OK, 0, 0);

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::RewriteHeader

    Description:

          This function adds a message ID, and other
          headers if they are missing

    Arguments:
        OUT BOOL *lfWritePended - Set to TRUE is an async write was
            pended.

    Returns:

      FALSE if WriteFile failed
      TRUE otherwise

--*/
BOOL SMTP_CONNECTION::RewriteHeader(BOOL *lpfWritePended)
{
  char Buffer [MAX_REWRITTEN_HEADERS];
  char szMsgId[MAX_REWRITTEN_MSGID];
  char MessageId [REWRITTEN_GEN_MSGID_BUFFER];
  char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
  char szOriginalArrivalTime[64];
  int NumToWrite;
  int MsgIdSize = 0;
  int CurrentRewriteBufferSize = 0;

  *lpfWritePended = FALSE;

  //***NOTE***
  //If you add *anything* to this function, make sure you update MAX_REWRITTEN_HEADERS
  //to support allow room for this as well.

  //Rewrite header creates its own buffer and writes out

   //add the mail from field if we did not see it.
   if(!(m_HeaderFlags & H_FROM))
   {
       _ASSERT(m_szFromAddress[0] != '\0');

        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "From: %s\r\n",  m_szFromAddress);
        CurrentRewriteBufferSize += NumToWrite;
        m_pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, m_szFromAddress );
        strncat(szSmtpFromAddress, m_szFromAddress, MAX_INTERNET_NAME);
   }

   _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);

  if(!(m_HeaderFlags & H_RCPT))
   {
        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Bcc:\r\n");
        CurrentRewriteBufferSize += NumToWrite;
   }

   _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
   //add the return path field if we did not see it.
  if(!(m_HeaderFlags & H_RETURNPATH))
  {
        _ASSERT(m_szFromAddress[0] != '\0');

        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Return-Path: %s\r\n", m_szFromAddress);
        CurrentRewriteBufferSize += NumToWrite;
  }

   //add the message ID field if we did not see it.
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_MID))
  {
       GenerateMessageId (MessageId, sizeof(MessageId));

       m_pInstance->LockGenCrit();
       MsgIdSize = sprintf( szMsgId, "<%s%8.8x@%s>", MessageId, GetIncreasingMsgId(), m_pInstance->GetFQDomainName());
       m_pInstance->UnLockGenCrit();

       _ASSERT(MsgIdSize < MAX_REWRITTEN_MSGID);

       NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Message-ID: %s\r\n", szMsgId);
       szMsgId[sizeof(szMsgId)-1]=0;

       CurrentRewriteBufferSize += NumToWrite;
  }

  if( !( m_HeaderFlags & H_X_ORIGINAL_ARRIVAL_TIME ) )
  {

      GetSysAndFileTimeAsString( szOriginalArrivalTime );

      NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "X-OriginalArrivalTime: %s\r\n", szOriginalArrivalTime);
      szOriginalArrivalTime[sizeof(szOriginalArrivalTime)-1]=0;

      CurrentRewriteBufferSize += NumToWrite;
  }



  //add the Date field if we did not see it.
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_DATE))
  {
    char szDateBuf [cMaxArpaDate];

    GetArpaDate(szDateBuf);
    NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Date: %s\r\n", szDateBuf);
    CurrentRewriteBufferSize += NumToWrite;
  }

  //Did we see the seperator. If not add one
  //blank line to the message
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_EOH))
  {
    sprintf(Buffer + CurrentRewriteBufferSize,"\r\n", 2);
    CurrentRewriteBufferSize += 2;

  }

  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);


  if(CurrentRewriteBufferSize)
  {
      //Write out the data
      if(!WriteMailFile(Buffer, CurrentRewriteBufferSize, lpfWritePended))
      {
          m_MailBodyError = GetLastError();
          return FALSE;
      }
      else if(!*lpfWritePended)
      {
         //
         // Update the header size and message-properties if the data got copied
         // to the write-buffer. If a write was pended (because the write buffer is
         // currently full), then we will do nothing, and ATQ will call us back when
         // the write completes. This code-path will be called again.
         //
         m_HeaderSize += CurrentRewriteBufferSize;

         if(!(m_HeaderFlags & H_FROM))
            m_pIMsg->PutStringA( IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress );

         if(!(m_HeaderFlags & H_MID))
         {
            if( FAILED( m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, szMsgId ) ) )
                return FALSE;
         }

         if(!(m_HeaderFlags & H_X_ORIGINAL_ARRIVAL_TIME))
         {
            if( FAILED( m_pIMsg->PutStringA(
                    IMMPID_MP_ORIGINAL_ARRIVAL_TIME,
                    szOriginalArrivalTime ) ) )
                return FALSE;
         }
      }
  }

  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::CreateMailBody

    Description:

        Responds to the SMTP data command.
        This funcion spools the mail to a
        directory
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
        UndecryptedTailSize -- amount of undecrypted data at end of buffer
    Returns:

      TRUE if all data(incliding terminating .)
           has been received
      FALSE on all errors (disk full, etc.)

--*/

BOOL SMTP_CONNECTION::CreateMailBody(char * InputLine, DWORD ParameterSize,
                                      DWORD UndecryptedTailSize, BOOL  *lfWritePended)
{
    BOOL MailDone = FALSE;
    DWORD IntermediateSize = 0;
    PCHAR pszSearch = NULL;
    DWORD TotalMsgSize = 0;
    char c1, c2;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::CreateMailBody");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (m_cbParsable <= QueryMaxReadSize());


    // 7/2/99 MILANS
    // The following if statement is completely unnecessary. One should not adjust the line
    // state at the beginning of this function - rather, they should do so as a line is scanned
    // and, for the final (potentially partial) line at the end, when they move the (partial) line
    // as the last step in this function.
    // Nevertheless, in the light of the time, I am leaving the if statement in place.

    //the state of the line completion parsing automaton is to be set to the initial state if
    //for each line except the following case:

    //if the buffer was full in the last iteration --- the data got shifted out and now we are
    //parsing the newly read data. so the state of the line completion automaton must
    if(!m_BufrWasFull)
        m_LineCompletionState = SEEN_NOTHING;   //automaton state for IsLineCompleteRFC822

    m_BufrWasFull = FALSE;
    while ((pszSearch = IsLineCompleteRFC822(InputLine, m_cbParsable, UndecryptedTailSize, &m_BufrWasFull)) != NULL)
    {
        //If the buffer is full and we are not using the entire buffer; then some of the data in the full
        //buffer is data that we have already parsed and processed in preceding iterations. we can discard
        //this data and read in fresh data which may have the CRLFx we are looking for. to do this, break
        //out of this loop, move inputline to the beginning of buffer (done outside loop) and just return.
        //a read is pended and this function is called with freshly read data appended to the "inadequate
        //data". If even then the no CRLFx is found, and the buffer is filled up, we need to start truncation.

        if(m_BufrWasFull && InputLine > QueryMRcvBuffer())
            break;

        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        //stuff in CRLF if it wasn't there
        if(!m_Truncate && m_BufrWasFull)
        {
            c1                  = *pszSearch;
            c2                  = *(pszSearch+1);
            *pszSearch          = CR;
            *(pszSearch+1)      = LF;
        }

        IntermediateSize = (DWORD)(pszSearch - InputLine);
        TotalMsgSize = m_TotalMsgSize + (IntermediateSize + 2);

        //don't write the '.' to the file
        if( (InputLine [0] == '.') && (IntermediateSize == 1) && !m_LongBodyLine )
        {
            //the minimum message size is 3 (.CRLF).  If we are done, and the size
            //of the message is 3 bytes, that means that the body of the message
            //is missing. So, just write the headers and go.
            if(TotalMsgSize == 3 && m_TimeToRewriteHeader)
            {
                if(!RewriteHeader(lfWritePended))
                {
                    m_MailBodyDiagnostic = ERR_RETRY;
                    m_MailBodyError = GetLastError();
                    return TRUE;
                }
                else if(*lfWritePended)
                {
                    //Go away - Atq will call us back when the write file completes
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
                m_TimeToRewriteHeader = FALSE;
            }

            //We are at the end of the message flush our write buffer
            //if there is something in it
            if(!WriteMailFile(NULL, 0, lfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                return TRUE;
            }
            else if(*lfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }

            m_cbParsable -= 3; // 1for the . + 2 for CRLF
            m_cbReceived = m_cbParsable + UndecryptedTailSize;

            if(m_cbReceived)
            {
                //we need to +2 to pszSearch because it points to the CR character
                MoveMemory ((void *)QueryMRcvBuffer(), pszSearch + 2, m_cbReceived);
            }

            //DebugTrace((LPARAM) this, "got ending dot for file %s", MailInfo->GetMailFileName());
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        if(!m_Truncate && m_InHeader && ( m_MailBodyError == NO_ERROR ))
        {

            //the code I stole from SendMail assumes the
            //line has a terminating '\0', so we terminate
            //the line.  We will put back the carriage
            //return later.

            *pszSearch = '\0';
            char *pszValueBuf = NULL;

            //remove header. return false if the line is not a header or the line is NULL
            //chompheader returns everything after ":" into pszValueBuf
            if( m_InHeader = ChompHeader( InputLine, m_HeaderFlags, &pszValueBuf) )
            {
                GetAndPersistRFC822Headers( InputLine, pszValueBuf);
                if(FAILED(m_MailBodyError))
                {
                    ErrorTrace((LPARAM) this, "Error persisting 822 headers 0x%08x", m_MailBodyError);
                    m_MailBodyDiagnostic = ERR_RETRY;
                    *pszSearch = CR;
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
            }
            else
            {
                //in case we have <header><CRLF><CRLF><sp><body><CRLF><x> we have seen
                //an end of header after the 1st <CRLF> but because IsLineComplete822 halts at
                //the third <CRLF> the inputstring to ChompHeader() is
                //<CRLF><sp><body><NULL> rather than just <NULL> had there been no <sp> after
                //the second <CRLF>. Thus ChompHeader will not set the EOH flag correctly.
                //we do this here.
                if( InputLine[0] == CR &&
                    InputLine[1] == LF &&
                    (InputLine[2] == ' ' || InputLine[2] == '\t') )
                    m_HeaderFlags |= H_EOH;
            }

            *pszSearch = CR;
        }


        //If we are not in the header and this is
        //the first time m_TimeToRewriteHeader is
        //TRUE, then add any missing headers we
        //care about.  Set m_TimeToRewriteHeader
        //to false so that we don't enter this
        //part of the code again.  If ReWriteHeader
        //fails, we are probably out of disk space,
        //so set m_NoStorage to TRUE such that we
        //don't waste our time writing to disk.
        //We still have to accept the mail, but we
        //throw it away.  We will send a message
        //back to our client when all is done.
        if(!m_InHeader && m_TimeToRewriteHeader && (m_MailBodyError == NO_ERROR))
        {
            //So there was nothing to write so now write headers
            if(!RewriteHeader(lfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                return TRUE;
            }
            else if(*lfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }
            m_TimeToRewriteHeader = FALSE;
        }

        //restore InputLine for mail file write, if we put in a CRLF
        if(!m_Truncate && m_BufrWasFull)
        {
            *pszSearch          = c1;
            *(pszSearch + 1)    = c2;
        }

        char *pInputLine = InputLine;
        DWORD cbIntermediateSize = IntermediateSize + 2;

        if(m_MailBodyError == NO_ERROR)
        {

            //if we had a full buffer without CRLFx in the previous iteration, we did a
            //MoveMemory() and the beginning of the buffer is not the beginning of the line.
            //dot stripping is only done for the beginning of the line.
            if( !m_LongBodyLine )
            {
                if( *pInputLine == '.' )
                {
                    pInputLine++;
                    cbIntermediateSize --;
                    m_fFoundEmbeddedCrlfDotCrlf = TRUE;
                }
            }

            //write to the file if we have not gone over our alloted limit
            //and if WriteFile did not give us back any errors
            if((m_pInstance->GetMaxMsgSize() > 0) ||
               (m_pInstance->GetMaxMsgSizeBeforeClose() > 0))
            {
                BOOL fShouldImposeLimit = TRUE;

                // if the total msg size is not exceeded continue writing to file.
                // Else, trigger the MaxMsgSize event to see
                // if we can continue to write to the file.

                if ( m_pInstance->GetMaxMsgSize() > 0 && TotalMsgSize > m_pInstance->GetMaxMsgSize() )
                {
                    if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
                    {
                        m_MailBodyError = ERROR_ALLOTTED_SPACE_EXCEEDED;
                        m_MailBodyDiagnostic = ERR_MAX_MSG_SIZE;
                        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
                        ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", TotalMsgSize);
                        ++m_ProtocolErrors;
                        BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                        TraceFunctLeaveEx((LPARAM) this);
                        return TRUE;
                    }
                }

                if(!WriteMailFile(pInputLine, cbIntermediateSize , lfWritePended))
                {
                    m_MailBodyError = GetLastError();
                    m_MailBodyDiagnostic = ERR_RETRY;
                    return TRUE;
                }
                else if(*lfWritePended)
                {
                    //Go away - Atq will call us back when the write file completes
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
            else if (!WriteMailFile(pInputLine, cbIntermediateSize, lfWritePended))
            {
                m_MailBodyError = GetLastError();
                m_MailBodyDiagnostic = ERR_RETRY;
                return TRUE;
            }
            else if(*lfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }
        }

        //We managed to copy data to write buffer without having to write
        //out
        m_cbParsable -= IntermediateSize + 2;
        m_cbReceived -= IntermediateSize + 2;
        m_TotalMsgSize += IntermediateSize + 2;
        m_cbDotStrippedTotalMsgSize += cbIntermediateSize;
        m_cbRecvBufferOffset += IntermediateSize + 2;

        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        InputLine = pszSearch + 2;  //if m_BufrWasFull && UndecryptedTailSize == 0 then InputLine is pointing
                                    //1 byte beyond end of allocated storage; this is not an error.

        //if the buffer is filled up:
        //since we are done parsing it, we can discard it. this is done by setting m_cbParsable to 0
        //then we quit the IsLineComplete loop so that we can exit this function and pend a read for
        //fresh data. If the buffer was filled up, it also means that a CRLFx was not found, so we
        //ought to enter truncation mode (unless we have already done so) because this line was too
        //long.

        if(m_BufrWasFull)
        {
            // raid 196100 - We should not flush all buffers since it may contain some chars we want to save.
            //m_cbParsable = 0;
            m_LongBodyLine = TRUE;  //Next return of pszSearch in while() is not beginning of a new line.
            if(!m_Truncate)
                m_Truncate = TRUE;  //this looks silly... but the point is simply that we are "switching"
            break;                  //states, to truncation mode. The if() reminds you that it is possible
        }                           //to be in truncation mode already.

        //if the buffer still has room:
        //IsLineComplete returned because it found a CRLFx. in normal (non truncation mode) processing
        //this case means nothing, but if we were in truncation mode, then it means that we have hit the
        //end of the header we were truncating, so we need to get back to normal mode.
        else
        {
            m_LongBodyLine = FALSE;
            if(m_Truncate)
                m_Truncate = FALSE;
        }
    }

    if(m_cbParsable != 0)
    {
        //if there is stuff left in the buffer, move it up
        //to the top, then pend a read at the end of where
        //the last data left off

         _ASSERT (m_cbParsable <= QueryMaxReadSize());

         m_cbReceived = m_cbParsable + UndecryptedTailSize;
         MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
         m_cbRecvBufferOffset = 0;
         m_LineCompletionState = SEEN_NOTHING;
    }
    else
    { // m_cbParsable == 0
         m_cbReceived = UndecryptedTailSize;
         if(m_cbReceived > 0) //anything to move?
             MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
         m_cbRecvBufferOffset = 0;
         m_LineCompletionState = SEEN_NOTHING;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}



/*++

    NAME:   SMTP_CONNECTION::IsLineCompleteRFC822

    DESCRIPTION:

        Parses InputLine till it encounters a CRLFx where x is a nontab
        and nonspace character. When CRLFx is found it means that the true
        end of a line has been found, in other words ... there are no more
        continuations of this line.

        Implementation is as a finite state machine (FSM).

        The SMTP_CONNECTION member m_LineCompletion keeps track of the
        state of the FSM between calls so that if the FSM does not hit
        its exit state (CRLFx found) by the time it has scanned the input,
        the caller may obtain more input data and resume the parsing. Thus
        this member variable is "implicitly" passed to the function.

        If the message receive buffer (returned by QueryMRcvBuffer()) is
        filled up, so that the caller has no chance of getting more data
        (since there is no space), this function returns a pointer to the
        last but one item in InputLine and sets the flag FullBuffer. The
        purpose being that the caller can put a CRLF at the position
        returned and proceed as though CRLFx had been found.

        A special condition occurs if the InputLine starts off as .CRLF
        and the initial state is 1. This means that either the message is
        just .CRLF or a CRLF.CRLF has been found. Thus the end of the message
        has been found and the function returns.

    PARAMETERS:

        InputLine               Input data
        nBytes                  Bytes to parse
        UndecryptedTailSize     Data that occupies buffer space but can't
                                be parsed
        p_FullBuffer            If the function fails to find CRLFx, is there
                                enough room left in the buffer so that we can
                                get more input from the user?

        m_LineCompletionState   Implicit parameter... you need to Initialize
                                this.

    RETURNS:
        Pointer to CR if CRLFx found
        Pointer to second last byte of buffer if there is no CRLFx
        NULL if there is no CRLFx and the buffer is not full.

--*/

char * SMTP_CONNECTION::IsLineCompleteRFC822(
                                             IN char *InputLine,
                                             IN DWORD nBytes,
                                             IN DWORD UndecryptedTailSize,
                                             OUT BOOL *p_FullBuffer
                                             )
{
    ASSERT(InputLine);

    char *pCh;
    char *pLastChar = InputLine + nBytes - 1;   //end of input
    DWORD dwSave = 0;

    //One exceptional case : the last line of input
    if(nBytes >= 3)
    {
        if(InputLine[0] == '.' && InputLine[1] == CR && InputLine[2] == LF)
        {
            *p_FullBuffer = FALSE;
            return &InputLine[1];
        }
    }


    for(pCh = InputLine; pCh <= pLastChar; pCh++)
    {
        switch(m_LineCompletionState)
        {
        case SEEN_NOTHING:                        //need CR
            if(*pCh == CR) {
                m_LineCompletionState = SEEN_CR;  //seen CR go on to state_2
                dwSave = 1; // save CR if necessary
            }
            break;

        case SEEN_CR:                                //seen CR need LF
            if(*pCh == LF) {
                m_LineCompletionState = SEEN_CRLF;   //seen LF goto state_3
                dwSave = 2; // save CRLF if necessary
            } else if(*pCh != CR) {
                m_LineCompletionState = SEEN_NOTHING;//if CR stay in this state, else go back to 1
                dwSave = 0;
            }
            break;

        case SEEN_CRLF:                                 //seen CRLF, need x
            if(*pCh != ' ' && *pCh != '\t')             //CRLFx found
            {
                *p_FullBuffer = FALSE;
                m_LineCompletionState = SEEN_NOTHING;     //seen CRLFx, go back to initial state
                return pCh - 2;                           //returning pointer to the CR
            } else {
                m_LineCompletionState = SEEN_NOTHING;   //didn't get either x or CR, nothing matched --- start over again.
                dwSave = 0;
            }
            break;
        }
    }

    //buffer is full && CRLFx not found.
    // raid 196100 - we need to save some bytes (CR, LF, or CRLF) if necessary
    // when buffer is full
    if(*p_FullBuffer = (pLastChar >= QueryMRcvBuffer() + QueryMaxReadSize() - UndecryptedTailSize - 1))
       return pLastChar - 1 - dwSave;   //assumption: nbytes is atleast 2
    return NULL;    //buffer has room left && CRLFx not found
}

/*++

    Name :
        SMTP_CONNECTION::CreateMailBodyFromChunk

    Description:

        Responds to the SMTP BDAT command.
        This function spools the mail to a
        directory keeping track of chunk size
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
        UndecryptedTailSize -- amount of undecrypted data at end of buffer
    Returns:

      TRUE if all data(incliding terminating .)
           has been received
      FALSE on all errors (disk full, etc.)

--*/
BOOL SMTP_CONNECTION::CreateMailBodyFromChunk (char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL *lpfWritePended)
{
    BOOL MailDone = FALSE;
    DWORD IntermediateSize = 0;
    PCHAR pszSearch = NULL;
    char MailFileName[MAX_PATH];
    DWORD TotalMsgSize = 0;
    DWORD SessionSize = 0;

    //  HRESULT hr;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::CreateMailBodyFromChunk");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (m_cbParsable <= QueryMaxReadSize());


    MailFileName[0] = '\0';

    //
    // m_cbTempBDATLen is used to save BDAT chunk bytes for headers spanning multiple
    // BDAT chunks. So we need to parse from the very beginning of the buffer if there
    // are saved BDAT header bytes.
    //

    if(m_cbTempBDATLen)
    {
      InputLine = QueryMRcvBuffer();
    }

    //
    // Process the chunk data line-by-line till a line is encountered which is not a
    // header. At this point m_InHeader is set to FALSE and we never enter this loop
    // again. Instead all chunk data will be directly dumped to disk as the mail body.
    //
    // It can be determined that a line is either header/non-header if:
    //  - It is CRLF terminated (it can be examined for the header syntax)
    //  - If we have 1000+ bytes without a CRLF it is not a header
    //
    // If it does not meet either condition, we must save the data (set m_cbTempBDATLen)
    // and post a read for the next chunk hoping that with the fresh data, either of the
    // two conditions will apply.
    //

    while (m_InHeader &&
           ((pszSearch = IsLineComplete((const char *)InputLine, m_cbParsable)) != NULL ||
                                       m_cbParsable > 1000  ||
                                       m_cbParsable >= (DWORD)m_nBytesRemainingInChunk))
    {
        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        // Found a CRLF in the received data
        if(pszSearch != NULL)
        {
            IntermediateSize = (DWORD)(pszSearch - InputLine);
            TotalMsgSize = m_TotalMsgSize + (IntermediateSize + 2);

            //
            // There are IntermediateSize+2 bytes in this CRLF terminated line.
            // If that is > the number of bytes in the current BDAT chunk:
            // - The chunk was fully received
            // - Some extra bytes (pipelined SMTP command) were received after it.
            // - The CRLF found by IslineComplete is outside this chunk.
            //

            if(( m_nBytesRemainingInChunk - ((int)IntermediateSize + 2) ) < 0)
            {
                if(m_fIsLastChunk || m_nBytesRemainingInChunk > 1000)
                {
                    //
                    // We're done with header parsing because either:
                    // - This is the last BDAT chunk OR
                    // - We have 1000 bytes of mailbody data without a CRLF
                    //

                    m_InHeader = FALSE;
                }
                else
                {
                    //
                    // In this else-block the following is true:
                    // - This is not the last BDAT chunk
                    // - We have < 1000 bytes in the current BDAT chunk
                    // - The CRLF (pszSearch) is outside the current BDAT chunk
                    // - We still haven't hit a non-header line
                    //
                    // We do not know if this is a header. This chunk is saved
                    // as the first m_cbTempBDATLen bytes in the recv buffer. The
                    // next chunk is appended to this and both will be processed
                    // together.
                    //

                    m_cbTempBDATLen = m_nBytesRemainingInChunk;
                    m_nBytesRemainingInChunk = 0;
                    break;
                }
            }

            //look for all the headers we care about.
            //If we are out of storage, forget it.
            if(m_InHeader && (m_MailBodyError == NO_ERROR))
            {
                //For parsing we terminate the line.
                //We will put back the carraige return later
                *pszSearch = '\0';

                //skip over continuation lines
                if((InputLine[0] != ' ') && (InputLine[0] != '\t'))
                {
                    char *pszValueBuf = NULL;
                    //see if we are still in the header portion
                    //of the body
                    if (m_InHeader = ChompHeader(InputLine, m_HeaderFlags, &pszValueBuf))
                    {
                        //Process and Promote RFC822 Headers
                        GetAndPersistRFC822Headers( InputLine, pszValueBuf );
                    }

                }
                //put back the carraige return
                *pszSearch = CR;
            }
        }

        else if((m_cbParsable > 1000) || m_fIsLastChunk)
        {
            //We could not parse the line inspite of having 1000 parsable bytes
            //That tells me it is not a 822 header
            m_InHeader = FALSE;
        }
        else
        {
            //We do not have a parsed line and we have not exceeded the 1000byte
            //limit - looks like what we have is a partial header line
            //Keep the data around
            m_cbTempBDATLen = m_nBytesRemainingInChunk;
            m_nBytesRemainingInChunk = 0;
            break;
        }

        //if we are done with headers break
        if(!m_InHeader)
            break;

        //We are still processing headers
        if(m_MailBodyError == NO_ERROR)
        {
            if(!WriteMailFile(InputLine, IntermediateSize + 2, lpfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                m_InHeader = FALSE;
            }
            else if(*lpfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }
            //Update the remaining bytes expected in this chunk
            else
            {
                //Once we write out chunk data - we should no longer have any saved of portion of chunk
                //
                m_cbTempBDATLen = 0;
                m_nBytesRemainingInChunk -= IntermediateSize + 2;
            }
        }
        else
            m_InHeader = FALSE;

        InputLine = pszSearch + 2;
        m_cbParsable -= (IntermediateSize + 2);
        m_cbReceived -= IntermediateSize + 2;
        m_TotalMsgSize += IntermediateSize + 2;
        m_cbRecvBufferOffset += (IntermediateSize + 2);
        _ASSERT (m_cbParsable < QueryMaxReadSize());
    }//end while

    // If we are done with headers - it is time to write any missing headers
    if(!m_InHeader && m_TimeToRewriteHeader && (m_MailBodyError == NO_ERROR))
    {
        //So there was nothing to write so now write headers
        if(!RewriteHeader(lpfWritePended))
        {
            m_MailBodyDiagnostic = ERR_RETRY;
            m_MailBodyError = GetLastError();
            ErrorTrace( (LPARAM)this, "Rewrite headers failed. err: %d",m_MailBodyError);
        }
        else if(*lpfWritePended)
        {
            //Go away - Atq will call us back when the write file completes
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
        m_TimeToRewriteHeader = FALSE;
    }

    //If we did write something during our header parsing we need to update m_cbReceived
    m_cbReceived = m_cbParsable + UndecryptedTailSize;

    // Now that we are thru with headers and there is more data in the buffer
    // that is part of the chunk - simply dump it to disk asynchronously
    if(!m_InHeader && m_nBytesRemainingInChunk && m_cbParsable)
    {
        DWORD dwBytesToWrite = m_nBytesRemainingInChunk;

        // Simply write the parsable data or the remaining bytes in this chunk
        // to the file - which ever is smaller
        if(m_nBytesRemainingInChunk > (int) m_cbParsable)
            dwBytesToWrite = m_cbParsable;

        if(m_MailBodyError == NO_ERROR)
        {
            //write to the file if we ahve had no errors
            if(!WriteMailFile(InputLine, dwBytesToWrite, lpfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
            }
            else if(*lpfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }

            //Now that we have copied stuff to out buffer
            //update the state data
            m_TotalMsgSize += dwBytesToWrite;

            m_nBytesRemainingInChunk -= dwBytesToWrite;
            //We are down to last bytes - keep a track of trailing CRLF
            if(m_fIsLastChunk && (m_nBytesRemainingInChunk < 2) )
            {
                //We have the second last byte - there is one more byte to be read.
                if(m_nBytesRemainingInChunk)
                {
                    if(*(InputLine + dwBytesToWrite -1) == '\r')
                        m_dwTrailerStatus = CR_SEEN;
                    else
                        m_dwTrailerStatus = CR_MISSING;
                }
                else if(dwBytesToWrite > 1)   //We got the last byte
                {
                    //We have last two bytes together
                    if(!strncmp((InputLine + dwBytesToWrite - 2),"\r\n", 2))
                        m_dwTrailerStatus = CRLF_SEEN;
                    else
                        m_dwTrailerStatus = CRLF_NEEDED;
                }
                else if(m_dwTrailerStatus == CR_SEEN && (*(InputLine + dwBytesToWrite -1) == '\n'))
                    m_dwTrailerStatus = CRLF_SEEN;
                else
                    m_dwTrailerStatus = CRLF_NEEDED;

            }

            //Update IO buffer parameters to reflect the state after WRITE
            m_cbReceived -= dwBytesToWrite;
            m_cbParsable -= dwBytesToWrite;

            //Once we write out chunk data - we should no longer have any saved of portion of chunk
            //
            m_cbTempBDATLen = 0;
            m_cbRecvBufferOffset = 0;

        }

        InputLine += dwBytesToWrite;
        _ASSERT (m_cbParsable < QueryMaxReadSize());
    }

    //Adjust the buffer for the next read only if did comsume any data
    //and there is more data remaining in the input buffer
    //

    if(m_cbReceived && (QueryMRcvBuffer() != InputLine))
    {
        MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
    }
    m_cbRecvBufferOffset = 0;

    //If we are done with current chunk
    if(!m_nBytesRemainingInChunk)
    {
        if(m_MailBodyError == NO_ERROR)
        {
            if(m_fIsLastChunk)
            {
                //we are done with all the chunks
                //We have written the Last chunk and need to see if we need to put the trailing CRLF
                if(m_dwTrailerStatus == CRLF_NEEDED)
                {

                    if(!WriteMailFile("\r\n", 2, lpfWritePended))
                    {
                        m_MailBodyDiagnostic = ERR_RETRY;
                        m_MailBodyError = GetLastError();
                    }
                    else if(*lpfWritePended)
                    {
                        //Go away - Atq will call us back when the write file completes
                        TraceFunctLeaveEx((LPARAM) this);
                        return FALSE;
                    }
                    m_TotalMsgSize += 2;
                    m_dwTrailerStatus = CRLF_SEEN;
                }

                //Flush all the data to disk
                if(!WriteMailFile(NULL, 0, lpfWritePended))
                {
                  m_MailBodyDiagnostic = ERR_RETRY;
                  m_MailBodyError = GetLastError();
                }
                else if(*lpfWritePended)
                {
                    //Go away - Atq will call us back when the write file completes
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }

                //Go back to HELO state
                m_State = HELO;
                m_fIsChunkComplete = FALSE;
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
            else
            {
                //Chunk completion response
                ProtocolLog(BDAT, (char *) MailFileName, NO_ERROR, SMTP_RESP_OK, 0, 0);
                FormatSmtpMessage  (SMTP_RESP_OK, EMESSAGE_GOOD," %s, %d Octets\r\n", SMTP_BDAT_CHUNK_OK_STR, m_nChunkSize );
            }
            m_fIsChunkComplete = TRUE;
        }
        else
        {
            // We had error during handling the Chunk, now that chunk has been consumed
            //we can respond with an error
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

    }
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;



}

/*++

    Name :
        SMTP_CONNECTION::DoDATACommandEx

    Description:

        Responds to the SMTP data command.
        This funcion spools the mail to a
        directory
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

        Currently this function always returns TRUE.

--*/
BOOL SMTP_CONNECTION::DoDATACommandEx(const char * InputLine1, DWORD ParameterSize, DWORD UndecryptedTailSize,BOOL *lpfWritePended, BOOL *pfAsyncOp)
{
  LPSTR InputLine = (LPSTR) InputLine1;
  BOOL fRet = TRUE;
  BOOL fProcess = TRUE;
  PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoDATACommandEx");

  _ASSERT (m_pInstance != NULL);

  //
  // we scan for <CRLF>.<CRLF> when processing the msg body of the DATA
  // command.
  //

  m_fScannedForCrlfDotCrlf = TRUE;

  if(CreateMailBody(InputLine, ParameterSize, UndecryptedTailSize, lpfWritePended))
  {
      if(m_MailBodyDiagnostic != NO_ERROR)
      {
          TraceFunctLeaveEx((LPARAM) this);
          return TRUE;
      }

      //increment our counters
      //make sure the size of the file is proper.
      //subtract 3 bytes accounting for the .CRLF.
      //We don't write that portion to the file.

      ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (m_TotalMsgSize - 3));
      BUMP_COUNTER(QuerySmtpInstance(), NumMsgRecvd);

      //if there was no error while parsing the
      //header, and writimg the file to disk,
      //then save the rest of the file, send
      //a message id back to the client, and
      //queue the message
      if(m_MailBodyError == NO_ERROR)
      {

        //call HandleCompletedMessage() to see
        //if we should process this message
        HandleCompletedMessage(DATA, pfAsyncOp);
        if (*pfAsyncOp) {
            m_fAsyncEOD = TRUE;
            return TRUE;
        }

        //We got all the data and written it to disk.
        //Now, we'll pend a read to pick up the quit
        //response, to get any other mail the client
        //sends.  We need to re-initialize our class
        //variables first.

        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());

      }
      else
      {
        //else, format the appropriate message,
        //and delete all objects pertaining to
        //this file.

        //flush any pending responses
        SendSmtpResponse();

        //re-initialize out class variables
        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
  }


  TraceFunctLeaveEx((LPARAM) this);
  return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function handles receiving the mailbody sent by a client using the
//      DATA command. It wraps the functionality of DoDATACommandEx (the
//      function to parse and process the mailbody) and AcceptAndDiscardDATA
//      (the function that handles errors that occur during DoDATACommandEx).
//
//      The reason for a separate function to do error processing for mailbody
//      errors is that when a mailbody error occurs, SMTP cannot directly abort
//      the transaction and return an error response. Instead it must continue
//      to post reads for the mailbody, and after the mailbody has been completely
//      received, respond with the appropriate error.
//
//      So when an error occurs during DoDATACommandEx, it stops processing and
//      sets m_MailBodyDiagnostic. AcceptAndDiscardData takes over and keeps
//      posting reads till the body has been sent by the client. Then it uses
//      m_MailBodyDiagnostic to generate the error response.
//
//  Arguments:
//      IN char *InputLine - Pointer to data being processed
//      IN DWORD UndecryptedTailSize - If using SSL, this is the encrypted tail
//      OUT BOOL *pfAsyncOp - Set to TRUE if a read of write was pended. In
//          this case.
//  Returns:
//      TRUE - Success. All received data must be passed into this function
//          till the state goes to HELO after which data should be parsed as
//          SMTP commands. Failures while processing DATA are caught internally
//          (flagged by m_MailBodyDiagnostic and m_MailBodyError) and we still
//          return TRUE.
//      FALSE - A failure occurred that cannot be handled (like a TCP/IP
//          failure). In this case we should disconnect.
//
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::ProcessDATAMailBody(const char *InputLine, DWORD UndecryptedTailSize, BOOL *pfAsyncOp)
{
    BOOL fReturn = TRUE;
    BOOL fWritePended = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessDATA");

    _ASSERT(m_State == DATA);

    *pfAsyncOp = FALSE;

    if(m_MailBodyDiagnostic != ERR_NONE)
        goto MAILBODY_ERROR;

    //
    // DoDATACommandEx handles parsing the mailbody, processing the headers and
    // persisting them to the IMailMsg, and writing the mailbody to a file. In
    // addition, when the mailbody has been received, it triggers the _EOD event
    // which may return async (due to installed event handlers). We pre-increment
    // the pending IO count to cover this case.
    //

    IncPendingIoCount();

    fReturn = DoDATACommandEx(InputLine, m_cbParsable, UndecryptedTailSize, &fWritePended, pfAsyncOp);
    _ASSERT(fReturn && "All errors are flagged by m_MailBodyDiagnostic and m_MailBodyError");

    //
    // DoDATACommandEx/CreateMailBody always return immediately after they pend I/Os
    // (expecting the I/O completion threads to resume processing). So if the I/O pend
    // succeeds, DoDATACommandEx must have succeeded.
    //

    if(*pfAsyncOp || fWritePended)
        _ASSERT(m_MailBodyDiagnostic == ERR_NONE);

    if(*pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Decrement the pending IO count since DoDataCommandEx returned sync (and
    // we incremented the count above). ProcessClient is above us in the
    // callstack and always has a pending IO reference, so this should never
    // return zero
    //

    _VERIFY(DecPendingIoCount() > 0);

    //
    // If a Write was pended we simply want to release this thread back to IIS
    // The completion thread will continue with the processing
    //

    if(fWritePended)
    {
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_MailBodyDiagnostic != ERR_NONE)
    {
        _ASSERT(!*pfAsyncOp && !fWritePended);

        //
        // Shift out bytes that already got parsed during DoDATACommandEx.
        //

        MoveMemory(QueryMRcvBuffer(), QueryMRcvBuffer() + m_cbRecvBufferOffset, m_cbParsable);
        m_cbRecvBufferOffset = 0;
        goto MAILBODY_ERROR;
    }

    if(m_State == DATA)
    {
        //
        // If the state is still equal to DATA, then we need to keep
        // pending reads to pickup the rest of the message.  When the
        // state changes to HELO, then we can stop pending reads, and
        // go back into parsing commands.
        //

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    //
    // Done with mail body. Go back to parsing commands.
    //

    _ASSERT(m_State == HELO);
    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;

MAILBODY_ERROR:

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    //
    // DoBDATCommandEx (and other parts of smtpcli) use m_cbRecvBufferOffset to
    // keep track of bytes in the beginning of the recv buffer that have been
    // processed, but have not been shifted out (this is needed for header parsing).
    // All reads/processing therefore start at (recv buffer + offset). During error
    // processing however there's no parsing of headers, so this offset should be
    // set to 0 before calling into discard, and the saved bytes shifted out. The
    // ASSERT below verifies this.
    //

    _ASSERT(m_cbRecvBufferOffset == 0 && "All of recv buffer is not being used");

    fReturn = AcceptAndDiscardDATA(QueryMRcvBuffer(), UndecryptedTailSize, pfAsyncOp);

    //
    // If something failed during error processing, disconnect with an error
    // (this violates the RFC, but there's no option). If we succeeded and a
    // read was pended, all data in the input buffer has been consumed. The
    // read I/O completion thread will pick up processing.
    //

    if(!fReturn || *pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    //
    // All the mailbody was processed and the input buffer contains only SMTP
    // commands. Fall through the the command parsing code.
    //

    _ASSERT(m_State == HELO);

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      Analogous to ProcessDATAMailBody
//  Arguments:
//      Same as ProcessDATAMailBody
//  Returns:
//      Same as ProcessDATAMailBody
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::ProcessBDATMailBody(const char *InputLine, DWORD UndecryptedTailSize, BOOL *pfAsyncOp)
{
    BOOL fWritePended = FALSE;
    BOOL fReturn = FALSE;
    _ASSERT(!m_fIsChunkComplete && m_State == BDAT);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessBDATMailBody");

    *pfAsyncOp = FALSE;

    //
    // We are in the midst of error processing, skip right to it.
    //

    if(m_MailBodyDiagnostic != ERR_NONE)
        goto MAILBODY_ERROR;

    //
    // Increment the pending IO count in case DoBDATCommandEx returns async.
    // When the message is completely received, DoBDATCommandEx will trigger
    // into the _EOD event, which may optionally return async. This increment
    // serves to keep track of that.
    //

    IncPendingIoCount();

    fReturn = DoBDATCommandEx(InputLine, m_cbParsable, UndecryptedTailSize, &fWritePended, pfAsyncOp);

    if(m_MailBodyDiagnostic != ERR_NONE)
    {
        _ASSERT(!fWritePended && !*pfAsyncOp && "Shouldn't be pending read/write on failure");
        _VERIFY(DecPendingIoCount() > 0);
        goto MAILBODY_ERROR;
    }

    // The completion thread will call us when more data arrives
    if (*pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Decrement the pending IO count since DoBDATCommandEx returned sync (and
    // we incremented the count above). ProcessClient is above us in the
    // callstack and always has a pending IO reference, so this should never
    // return zero
    //

    _VERIFY(DecPendingIoCount() > 0);

    //
    // If a Write was pended we simply want to release this thread back to IIS
    // The completion thread will continue with the processing
    //

    if(fWritePended)
    {
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_State == BDAT && !m_fIsChunkComplete)
    {
        //
        // We still are not done with current chunk So Pend read to pickup the
        // rest of the chunk.  When the state changes to HELO or the current
        // chunk completes, then we can stop pending reads, and go back into
        // parsing commands.
        //

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }
    else if(m_cbTempBDATLen)
    {
        //
        // Flush the response to the chunk just processed (why is this needed
        // specifically for m_cbTempBDATLen > 0 only? Shouldn't all responses
        // be treated equally -- gpulla).
        //

        SendSmtpResponse();
    }

    //
    // Done with current chunk. Go back to parsing commands.
    //

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;

MAILBODY_ERROR:

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    //
    // m_cbTempBDATLen is an offset into the recv buffer. It is set to > 0 when
    // DoBDATCommandEx needs to save the start of a header that spans multiple
    // chunks. Since discard does no header parsing, this is unneccessary, and
    // the "offset" number of bytes (if non-zero) should be reset and shifted
    // out before calling into discard.
    //

    if(m_cbTempBDATLen)
    {
        MoveMemory(QueryMRcvBuffer(), QueryMRcvBuffer() + m_cbTempBDATLen, m_cbReceived);
        m_cbTempBDATLen = 0;
    }

    fReturn = AcceptAndDiscardBDAT(QueryMRcvBuffer(), UndecryptedTailSize, pfAsyncOp);

    //
    // If something failed during error processing, disconnect with an error
    // (this violates the RFC, but there's no option). If we succeeded and a
    // read was pended, all data in the input buffer has been consumed. The
    // read I/O completion thread will pick up processing.
    //

    if(!fReturn || *pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    _ASSERT(m_nBytesRemainingInChunk == 0 && "Expected chunk to be done");

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNECTION::DoBDATCommandEx

    Description:

        Handles the data chunks received after a valid BDAT command.
        This funcion spools the mail to a directory.
                In the first chunk it parses for header.
                Once the header is written in current chunk and subsequent chunks it simply
                dumps the data to the disk
    Arguments:
        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoBDATCommandEx(const char * InputLine1, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL *lpfWritePended, BOOL *pfAsyncOp)
{
  LPSTR InputLine = (LPSTR) InputLine1;
  BOOL fRet = TRUE;
  BOOL fProcess = TRUE;
  PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATCommandEx");

  _ASSERT (m_pInstance != NULL);

  *lpfWritePended = FALSE;

  // We make this call only while we are parsing the headers
  // Once we are done parsing the headers
  if(CreateMailBodyFromChunk (InputLine, ParameterSize, UndecryptedTailSize, lpfWritePended))
  {

      m_WritingData = FALSE;
      //increment our counters
      //make sure the size of the file is proper.
      //subtract 3 bytes accounting for the .CRLF.
      //We don't write that portion to the file.

      ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (m_TotalMsgSize - 3));
      BUMP_COUNTER(QuerySmtpInstance(), NumMsgRecvd);

      //if there was no error while parsing the
      //header, and writimg the file to disk,
      //then save the rest of the file, send
      //a message id back to the client, and
      //queue the message
      if(m_MailBodyError == NO_ERROR)
      {

        //call HandleCompletedMessage() to see
        //if we should process this message
        fProcess = HandleCompletedMessage(BDAT, pfAsyncOp);
        if (*pfAsyncOp) {
            m_fAsyncEOD = TRUE;
            return TRUE;
        }

        //We got all the data and written it to disk.
        //Now, we'll pend a read to pick up the quit
        //response, to get any other mail the client
        //sends.  We need to re-initialize our class
        //variables first.

        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
      else
      {
        //else, format the appropriate message,
        //and delete all objects pertaining to
        //this file.

        if(m_MailBodyError == ERROR_BAD_LENGTH)
            FormatSmtpMessage (SMTP_RESP_MBX_SYNTAX,ESYNTAX_ERROR," %s\r\n","Badly formed BDAT Chunk");
        else
            FormatSmtpMessage (SMTP_RESP_NORESOURCES,ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE);

        //flush any pending responses
        SendSmtpResponse();

        //re-initialize out class variables
        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
  }


  TraceFunctLeaveEx((LPARAM) this);
  return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::DoHELPCommand

    Description:

        Responds to the SMTP HELP command.
        send a help text description

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoHELPCommand(const char * InputLine, DWORD parameterSize)
{
    BOOL RetStatus;
    char szHelpCmds[MAX_PATH];
    DWORD ConnectionStatus = 0;

    if(m_SecurePort)
        ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
    if(m_fAuthenticated)
        ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

    _ASSERT (m_pInstance != NULL);

    if(!m_fAuthAnon && !m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n", "Client was not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        return TRUE;
    }

    strcpy(szHelpCmds,HelpText);

    if(m_pInstance->AllowAuth())
    {
        if(m_pInstance->QueryAuthentication() != 0)
        {
            strcat(szHelpCmds, " AUTH");

            if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowTURN())
            {
                strcat(szHelpCmds, " TURN");
            }
        }
    }

    if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowETRN())
    {
        strcat(szHelpCmds, " ETRN");
    }

    // Chunking related advertisements
    if(m_pInstance->AllowBinaryMime() || m_pInstance->AllowChunking())
    {
        strcat(szHelpCmds, " BDAT");
    }
    // verify
    if(m_pInstance->AllowVerify(ConnectionStatus))
    {
        strcat(szHelpCmds, " VRFY");
    }
    // Expand
    if(m_pInstance->AllowExpand(ConnectionStatus))
    {
        strcat(szHelpCmds, " EXPN");
    }

    PE_FormatSmtpMessage ("%s\r\n", szHelpCmds);

    RetStatus = PE_SendSmtpResponse();
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoVRFYCommand

    Description:

        Responds to the SMTP VRFY command.
        send a help text description.  We
        do not really verify an address here.
        This function is just a stub.

    Arguments:
        The name to verify from the client

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoVRFYCommand(const char * InputLine, DWORD ParameterSize)
{

    BOOL RetStatus = TRUE;
    char * VrfyAddr = NULL;
    char * DomainPtr = NULL;
    char * ArgPtr = NULL;
    char    szAddr[MAX_INTERNET_NAME + 1];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoVRFYCommand");

    szAddr[0] = '\0';
    DWORD ConnectionStatus = 0;

    _ASSERT (m_pInstance != NULL);

   if(!m_fAuthAnon && !m_fAuthenticated)
   {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n","Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoVrfyCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
   }

    //start at the beginning;
    VrfyAddr = (char *) InputLine;

    //check the arguments for good form
    VrfyAddr = CheckArgument(VrfyAddr);
    if (VrfyAddr == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(ExtractAndValidateRcpt(VrfyAddr, &ArgPtr, szAddr, &DomainPtr))
    {
        //The address is valid
        //Do we allow verify
        if(m_SecurePort)
            ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
        if(m_fAuthenticated)
            ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

        if(!m_pInstance->AllowVerify(ConnectionStatus))
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_VRFY_CODE, EVALID_DEST_ADDRESS," %s <%s>\r\n", "Cannot VRFY user, but will accept message for", szAddr);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
        //Check the domain to be either belonging to a ALIAS,DEFAULT,DROP,DELIVER
        //We also check the relay restrictions
        HRESULT hr = HrShouldAcceptRcpt(DomainPtr);

        if( S_FALSE == hr )
        {
           PE_CdFormatSmtpMessage (SMTP_RESP_NOT_FOUND, ENO_FORWARDING, " Cannot relay to <%s>\r\n",szAddr);
        }
        else if (S_OK == hr)
        {
           PE_CdFormatSmtpMessage (SMTP_RESP_VRFY_CODE, EVALID_DEST_ADDRESS," %s <%s>\r\n", "Cannot VRFY user, but will take message for", szAddr);
        }
        else
        {
            // Currently, HrShouldAcceptRcpt only return error when AQueue is already shut down or out of memory.
            _ASSERT(FAILED(hr));
            PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, ESVC_SHUTDOWN," %s\r\n",SMTP_SRV_UNAVAIL_STR);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }
    else
    {
        //it failed.  Inform the user
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

//
// Reply strings
//

typedef struct _AUTH_REPLY {
    LPSTR Reply;
    DWORD Len;
} AUTH_REPLY, *PAUTH_REPLY;

char *
SzNextSeparator(IN char * sz, IN CHAR ch1, IN CHAR ch2)
{
        char *   sz1 = NULL;
        char *   sz2 = NULL;
        sz1 = strchr(sz, ch1);
        sz2 = strchr(sz, ch2);

        if (sz1 == sz2)
                return sz1;
        else if (sz1 > sz2)
                return sz2 ? sz2 : sz1;
        else
                return sz1 ? sz1 : sz2;
}

BOOL SMTP_CONNECTION::DoUSERCommand(const CHAR *InputLine, DWORD dwLineSize, unsigned char * OutputBuffer, DWORD * dwBytes, DWORD * ResponseCode, char * szECode)
{
    char    szUserName[MAX_USER_NAME_LEN + MAX_SERVER_NAME_LEN +1];
    char    szLogonDomainAndUserName[MAX_USER_NAME_LEN + (2 * (MAX_SERVER_NAME_LEN + 1))];
    char    lpszDefaultLogonDomain [MAX_SERVER_NAME_LEN + 1];
    char *  pSeparator1 = NULL;
    char *  pSeparator2 = NULL;
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD BuffLen = 0;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoUSERCommand");

    *ResponseCode = SMTP_RESP_AUTH1_PASSED;;

    m_pInstance->LockGenCrit();

    lstrcpyn(lpszDefaultLogonDomain, m_pInstance->GetDefaultLogonDomain(), MAX_SERVER_NAME_LEN);

    m_pInstance->UnLockGenCrit();

    if(!uudecode ((char *) InputLine, &BuffData, &DecodedLen, FALSE) ||
        (DecodedLen == 0))
    {
        *ResponseCode = SMTP_RESP_BAD_ARGS;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Cannot decode arguments");
        m_securityCtx.Reset();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    lstrcpyn(szUserName, (char *) BuffData.QueryPtr(), sizeof(szUserName) - 1);

    if (UseMbsCta())
    {
        // MBS clear text authentication, does not support domain
        lstrcpy(szLogonDomainAndUserName, szUserName);
    }
    else
    {
        // if NT clear text authentication is used, we do some special operations:

        // if no default logon domain is not present in user name, and default
        // logon domain is set, then prepend default logon domain to username
        pSeparator1 = SzNextSeparator(szUserName,'\\','/');

        if(pSeparator1 == NULL && (lpszDefaultLogonDomain[0] != '\0'))
        {
            wsprintf(szLogonDomainAndUserName, "%s/%s", lpszDefaultLogonDomain, szUserName);
        }
        else
        {
            if( pSeparator1 != NULL )
            {
                //
                // HACK-O-RAMA: bug 74776 hack, if a username comes in with "REDMOND\\user"
                // allow it. This is to allow buggy Netscape 4.0 browser client to work.
                //

                if( ( (*pSeparator1) == '\\' ) && ( (*(pSeparator1+1)) == '\\' ) )
                {
                    MoveMemory( pSeparator1, pSeparator1+1, strlen( pSeparator1 ) );
                }


                //check if we have the mailbox name at the end
                pSeparator2 = SzNextSeparator(pSeparator1 + 1,'\\','/');


                if(pSeparator2 != NULL)
                {
                    //If we do simply ignore it by terminating the user string there
                    *pSeparator2 = '\0';
                }
            }
            lstrcpy(szLogonDomainAndUserName, szUserName);
        }
    }

    DebugTrace((LPARAM)this, "LogonDomainAndUser: %s", szLogonDomainAndUserName);

    fRet = ProcessAuthInfo(AuthCommandUser, szLogonDomainAndUserName, OutputBuffer, &BuffLen);
    if(!fRet)
    {
        *ResponseCode = SMTP_RESP_AUTH_REJECT;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Invalid user name");
        *dwBytes = lstrlen("Invalid user name");
    }
    else
    {
        *dwBytes = BuffLen;
    }

    return fRet;
}


//+---------------------------------------------------------------
//
//  Function:   SMTP_CONNECTION::DoPASSCommand
//
//  Synopsis:   Valid in the Authorization State.
//              pswd for clear-text logon
//
//              PASS password\r\n
//
//  Arguments:  const CHAR *:   argument line
//              DWORD:          sizeof argument line
//
//  Returns:    BOOL:   continue processing
//
//----------------------------------------------------------------
BOOL SMTP_CONNECTION::DoPASSCommand(const CHAR *InputLine, DWORD dwLineSize, unsigned char * OutputBuffer, DWORD * dwBytes, DWORD *ResponseCode, char * szECode)
{
    BOOL    fStatus = TRUE;
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD BuffLen = 0;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoPASSCommand");

    *ResponseCode = SMTP_RESP_AUTHENTICATED;

    if(!uudecode ((char *)InputLine, &BuffData, &DecodedLen, FALSE))
    {
        m_RecvdAuthCmd = FALSE;
        m_fClearText = FALSE;
        m_State = HELO;
        *ResponseCode = SMTP_RESP_BAD_ARGS;

        if ( ++m_dwUnsuccessfulLogons >= m_pInstance->GetMaxLogonFailures() )
        {
            ErrorTrace((LPARAM)this, "Logon failed");
            DisconnectClient( ERROR_LOGON_FAILURE );
        }

        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Cannot decode password");
        m_securityCtx.Reset();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    OutputBuffer[0] = '\0';
    fStatus = ProcessAuthInfo( AuthCommandPassword, (char *) BuffData.QueryPtr(), OutputBuffer, &BuffLen );
    if (!fStatus)
    {
        ErrorTrace( (LPARAM)this, "Bad pswd %s", QueryClientUserName() );
        *ResponseCode = SMTP_RESP_AUTH_REJECT;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Authentication unsuccessful");

        if ( ++m_dwUnsuccessfulLogons >= m_pInstance->GetMaxLogonFailures() )
        {
            ErrorTrace((LPARAM)this, "Logon failed");
            DisconnectClient( ERROR_LOGON_FAILURE );
        }
        else
        {
            m_RecvdAuthCmd = FALSE;
            m_fClearText = FALSE;
            m_State = HELO;
        }
    }

    *dwBytes = BuffLen;
    TraceFunctLeaveEx((LPARAM)this);
    return fStatus;
}

BOOL SMTP_CONNECTION::ProcessAuthInfo(AUTH_COMMAND Command, LPSTR Blob, unsigned char * OutBuff, DWORD * dwBytes)
{
    DWORD                   nbytes = 0;
    REPLY_LIST              replyID;
    BOOL                    f = TRUE;

	//
	// Set the IP address so the security log has the info
	//
	SecpSetIPAddress((PUCHAR)&m_saClient, sizeof(m_saClient));

    m_pInstance->LockGenCrit();
    f = m_securityCtx.ProcessAuthInfo(m_pInstance, Command, Blob,
        OutBuff, &nbytes, &replyID);
    m_pInstance->UnLockGenCrit();

    *dwBytes = nbytes;

    //
    // if replyID == NULL we're conversing for challenge/response logon
    //
    if ( replyID == SecNull )
    {
        _ASSERT( nbytes != 0 );
    }

    if (m_securityCtx.IsAuthenticated())
    {
        f = TRUE;
    }

    if ( f == FALSE )
    {
        //
        // if we fail for any reason reset the state to accept user/auth/apop
        //
        m_securityCtx.Reset();
    }

    return  f;
}


//+---------------------------------------------------------------
//
//  Function:   SMTP_CONNECTION::DoAuthNegotiation
//
//  Synopsis:   process base64/uuendcoded blobs in AUTH_NEGOTIATE
//
//              base64 text\r\n
//
//  Arguments:  const CHAR *:   argument line
//              DWORD:          sizeof argument line
//
//  Returns:    BOOL:   continue processing
//
//----------------------------------------------------------------
BOOL SMTP_CONNECTION::DoAuthNegotiation(const CHAR *InputLine, DWORD dwLineSize)
{
    //The size of the output buffer should vary with the package being used.
    //Currently we use a quickfix which should work for LOGIN and NTLM but will
    //fail for other (new) packages if the response string > 25*255+1. Replace
    //this by a CBuffer later. Size of the CBuffer should be the max token size
    //for the package from CACHED_CREDENTIAL::GetCachedCredential.
    //GPulla, 6/15/1999

    unsigned char OutputBuff[MAX_REPLY_SIZE];
    char szECode[25];
    BOOL fAuthed = TRUE;
    BUFFER BuffData;
    DWORD ResponseCode;
    DWORD dwBytes = 0;
    BOOL fDoBase64 = FALSE;
    char * pszSearch = NULL;

    TraceFunctEnterEx((LPARAM)this, "DoAuthNegotiation");

    if (m_cbParsable >= QueryMaxReadSize())
    {
        m_cbParsable = 0;
        m_ProtocolErrors++;
    }

    pszSearch = IsLineComplete(InputLine,m_cbParsable);
    if(pszSearch == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    *pszSearch = '\0';
    m_cbParsable = 0;
    if(!lstrcmp(InputLine, "*"))
    {
        FormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n", "Auth command cancelled");
        m_fDidUserCmd = FALSE;
        m_RecvdAuthCmd = FALSE;
        m_fClearText = FALSE;
        m_State = HELO;
        m_securityCtx.Reset();
        SendSmtpResponse();
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    if(m_fClearText)
    {
        if(m_fDidUserCmd)
        {
            if(DoPASSCommand(InputLine, dwLineSize, OutputBuff, &dwBytes, &ResponseCode, szECode))
            {
                m_State = HELO;
                m_fAuthenticated = TRUE;
                lstrcpy((char *)szECode, "2.7.0");
                lstrcpy((char *)OutputBuff, "Authentication successful");
            }
            else
            {
                fAuthed = FALSE;
//                lstrcpy((char *)OutputBuff, "5.7.3 Authentication unsuccessful");
            }
        }
        else
        {
            if(DoUSERCommand(InputLine, dwLineSize, OutputBuff, &dwBytes, &ResponseCode, szECode))
            {
                lstrcpy((char *)OutputBuff, PasswordParam);
                m_fDidUserCmd = TRUE;
                fDoBase64 = TRUE;
            }
            else
            {
                fAuthed = FALSE;
            }
        }

        if(fDoBase64)
        {
            if(!uuencode ((unsigned char *)OutputBuff, lstrlen((char *) OutputBuff), &BuffData, FALSE))
            {
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;
            }
            else
            {
               FormatSmtpMessage  (ResponseCode,NULL," %s\r\n", BuffData.QueryPtr());
            }
        }
        else
        {
           FormatSmtpMessage  (ResponseCode,szECode," %s\r\n", OutputBuff);
        }

        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, ResponseCode, 0, 0);
    }
    else
    {
        fAuthed = ProcessAuthInfo( AuthCommandTransact, (LPSTR)InputLine, OutputBuff, &dwBytes );
        if(fAuthed)
        {
            if(m_securityCtx.IsAuthenticated())
            {
                m_State = HELO;
                m_fAuthenticated = TRUE;
                fAuthed = TRUE;
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTHENTICATED, ESEC_SUCCESS," %s\r\n", "Authentication successful");
                ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTHENTICATED, 0, 0);
            }
            else
            {
                FormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," ");
                FormatSmtpMessage(OutputBuff, dwBytes);
            }
        }
        else
        {
            FormatSmtpMessage (SMTP_RESP_AUTH_REJECT, ENO_SECURITY, " %s\r\n", "Authentication unsuccessful");
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTH_REJECT, 0, 0);
            if ( ++m_dwUnsuccessfulLogons >= m_pInstance->GetMaxLogonFailures() )
            {
                ErrorTrace((LPARAM)this, "Logon failed");
                SendSmtpResponse();
                DisconnectClient( ERROR_LOGON_FAILURE );
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;
            }
        }
    }

    if(!fAuthed)
    {
        m_State = HELO;
        m_RecvdAuthCmd = FALSE;
        m_fDidUserCmd= FALSE;
    }

    SendSmtpResponse();
    TraceFunctLeaveEx((LPARAM)this);
    return fAuthed;
}

/*++

    Name :
        SMTP_CONNECTION::DoAUTHCommand

    Description:
        This function performs authentication
        for the SMTP service
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoAUTHCommand(const char * InputLine, DWORD ParameterSize)
{
    BOOL fAuthPassed = TRUE;
    char * pMechanism = NULL;
    char * pInitialResponse = NULL;
    DWORD dwConnectionStatus = 0;

    //The size of the output buffer should vary with the package being used.
    //Currently we use a quickfix which should work for LOGIN and NTLM but will
    //fail for other (new) packages if the response string > 25*255+1. Replace
    //this by a CBuffer later. Size of the CBuffer should be the max token size
    //for the package from CACHED_CREDENTIAL::GetCachedCredential.
    //GPulla, 6/15/1999

    unsigned char OutputBuffer[MAX_REPLY_SIZE];
    char szECode[16];
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD dwBytes = 0;
    DWORD ResponseCode;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoAUTHCommand");

    //Do we allow AUTH command
    if(!m_pInstance->AllowAuth())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, ENOT_IMPLEMENTED," %s\r\n", SMTP_BAD_CMD_STR);
        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_BAD_CMD, 0, 0);
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;

    }

    //check if helo was sent
    if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    OutputBuffer[0] = '\0';

    //disallow mail from more than once
    if(m_RecvdAuthCmd)
    {
        ++m_ProtocolErrors;
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Auth already specified" );
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ErrorTrace((LPARAM) this, "DoAuthCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Check syntax: one required parameter, and one optional parameter
    //

    pMechanism = strtok((char *) InputLine, WHITESPACE);
    pInitialResponse = strtok(NULL, WHITESPACE);

    if(pMechanism == NULL)
    {
        ++m_ProtocolErrors;
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","No mechanism" );
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ErrorTrace((LPARAM) this, "DoAuthCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    strncpy(m_szUsedAuthKeyword, pMechanism, sizeof(m_szUsedAuthKeyword)-1);
    if(!lstrcmpi(pMechanism, "login"))
    {
        if(m_SecurePort)
            dwConnectionStatus |= SMTP_IS_SSL_CONNECTION;

        if(m_pInstance->AllowLogin(dwConnectionStatus))
        {
            m_fClearText = TRUE;

            if(pInitialResponse)
            {
                if(DoUSERCommand((const char *) pInitialResponse, lstrlen(pInitialResponse), OutputBuffer, &dwBytes, &ResponseCode, szECode))
                {
                    m_fDidUserCmd = TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (ResponseCode, szECode," %s\r\n",OutputBuffer );
                    ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
                    fAuthPassed = FALSE;
                }
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_PARM_NOT_IMP, ENO_SEC_PACKAGE, " %s \r\n","Unrecognized authentication type" );
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
            fAuthPassed = FALSE;
        }
    }
    else
    {
        /*
        //
        // Switch over to using a large receive buffer, because a AUTH blob
        // may be up to 32K big.
        BOOL fStartSASL = SwitchToBigSSLBuffers();
        if (fStartSASL) {
        //PE_CdFormatSmtpMessage(SMTP_RESP_READY, EPROT_SUCCESS," %s\r\n",  SMTP_READY_STR);
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_READY, 0, 0);
        } else {
          PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n", SMTP_NO_MEMORY);
          ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_NORESOURCES, 0, 0);
        }
        */

        //
        // Register our principal names, if necessary
        //

        QuerySmtpInstance()->RegisterServicePrincipalNames(TRUE);

        if(ProcessAuthInfo( AuthCommandTransact, pMechanism, OutputBuffer, &dwBytes ) == FALSE )
        {
            fAuthPassed = FALSE;
            PE_CdFormatSmtpMessage (SMTP_RESP_PARM_NOT_IMP, ENO_SEC_PACKAGE, " %s \r\n", "Unrecognized authentication type" );
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
        }
        else if(pInitialResponse)
        {
            if(ProcessAuthInfo( AuthCommandTransact, pInitialResponse, OutputBuffer, &dwBytes ) == FALSE )
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH_REJECT, EINVALID_ARGS, " %s\r\n","Cannot authenticate parameter" );
                ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTH_REJECT, 0, 0);
                fAuthPassed = FALSE;
            }
        }
    }

    if(fAuthPassed)
    {
        m_RecvdAuthCmd = TRUE;
        m_State = AUTH;

        if(!pInitialResponse)
        {
            if(!m_fClearText)
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s supported\r\n", pMechanism);
            }
            else
            {
                if(!uuencode ((unsigned char *)UserParam, lstrlen(UserParam), &BuffData, FALSE))
                {
                    TraceFunctLeaveEx((LPARAM)this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s\r\n", BuffData.QueryPtr());
                }

            }
        }
        else
        {
            if(!m_fClearText)
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," ");
                OutputBuffer[dwBytes] = '\0';
                PE_FormatSmtpMessage("%s\r\n",OutputBuffer);
            }
            else
            {
                if(!uuencode ((unsigned char *)PasswordParam, lstrlen(PasswordParam), &BuffData, FALSE))
                {
                    TraceFunctLeaveEx((LPARAM)this);
                    return TRUE;
                }

                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s\r\n", BuffData.QueryPtr());
            }
        }

    }
    else
        m_ProtocolErrors++; //even though we kick out the connection
                            //after MaxLogonFailures, count this as a
                            //protocol error


    TraceFunctLeaveEx((LPARAM) this);
    return(TRUE);
}

BOOL SMTP_CONNECTION::DoTURNCommand(const char * InputLine, DWORD parameterSize)
{
    sockaddr_in AddrRemote;
    SMTP_CONNOUT * SmtpConn = NULL;
    DWORD Error = 0;
    DWORD Options = 0;
    char * pszUserName = "";
    MULTISZ*  pmsz = NULL;
    TURN_DOMAIN_LIST TurnDomainList;

    LPSTR pszAuthenticatedUserName = NULL;
    const char * StartPtr = NULL;
    BOOL Found = FALSE;

    ISMTPConnection    *pISMTPConnection = NULL;
    char Domain[MAX_INTERNET_NAME];
    Domain[0] = '\0';
    DWORD DomainOptions = 0;
    HRESULT hr = S_OK;
    DomainInfo DomainParams;
    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoTurnCommand");

    //check if helo was sent
    if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
    {
        ErrorTrace((LPARAM) this, "In TURN - Hello not sent");
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Send hello first" );
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_securityCtx.QueryUserName())
        ErrorTrace((LPARAM) this, "Looking up user %s in TURN table", m_securityCtx.QueryUserName());

    pmsz = new MULTISZ();
    if(pmsz == NULL)
    {
        Error = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY );
        FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed for TURN");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    pmsz->Reset();

    // Do we have a username from an AUTH sink? If not use anything from SMTP auth
    pszAuthenticatedUserName =
        m_szAuthenticatedUserNameFromSink[0] ?
        m_szAuthenticatedUserNameFromSink : m_securityCtx.QueryUserName();

    QuerySmtpInstance()->IsUserInTurnTable(pszAuthenticatedUserName, pmsz);
    //QuerySmtpInstance()->IsUserInTurnTable("joe", &msz);

    if(pmsz->IsEmpty())
    {
        delete pmsz;
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n","This authenticated user is not allowed to issue TURN");
        ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_RESP_MUST_SECURE, user not in turn table");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Determine the primary domain in the list of domains that are to be turned
    //The primary domain is one that matches the domain name specified in the EHLO command
    //NimishK : What if EHLO is not provided
    //
    for (StartPtr = pmsz->First();
        ( (StartPtr != NULL) && !QuerySmtpInstance()->IsShuttingDown());
            StartPtr = pmsz->Next( StartPtr ))
    {
        ErrorTrace((LPARAM) this, "looking for %s in TURN domains", QueryClientUserName());
        if(!lstrcmpi(QueryClientUserName(), StartPtr))
        {
            Found = TRUE;
            break;
        }
    }

    //If we can determine the primary domain - we get the ISMTPCONNECTION for that domain
    //else we get the first domain in the list and get the ISMTPCONNECTION for it
    BOOL fPrimaryDomain = FALSE;
    if(!Found)
        StartPtr = pmsz->First();
    else
        fPrimaryDomain = TRUE;

    //We need to keep walking the list of domains that are to be turned
    //till we get a valid ISMTPCONN or run out of domains
    while(StartPtr && !QuerySmtpInstance()->IsShuttingDown())
    {
        hr = QuerySmtpInstance()->GetConnManPtr()->GetNamedConnection(lstrlen(StartPtr), (CHAR*)StartPtr, &pISMTPConnection);
        if(FAILED(hr))
        {
            //Something bad happened on this call
            //report to client
            delete pmsz;
            PE_CdFormatSmtpMessage (SMTP_ERROR_PROCESSING_CODE, ENO_RESOURCES," %s\r\n", "Error processing the command");
            ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_ERROR_PROCESSING_CODE, GetNamedConnection failed %d",hr);
            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ++m_ProtocolErrors;
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //If the link corresponding to this domain does not exist in AQ, we get a NULL
        //ISMTPConnection at this point
        //If we do there is nothing to TURN
        if(pISMTPConnection)
            break;
        else
        {
            if(fPrimaryDomain)
            {
                StartPtr = pmsz->First();
                fPrimaryDomain = FALSE;
            }
            else
            {
                StartPtr = pmsz->Next( StartPtr );
            }
            continue;
        }

    }
    if(pISMTPConnection == NULL && StartPtr == NULL)
    {
        //We ran out of the domains and there is not a single link
        PE_CdFormatSmtpMessage (250, EPROT_SUCCESS, " %s\r\n", "Server was turned");
        PE_SendSmtpResponse();

        PE_FormatSmtpMessage ("%s\r\n","QUIT");
        PE_SendSmtpResponse();

        //we will disconnect indirectly by returning false
        //DisconnectClient();

        return FALSE;

    }
    else
    {
        //leave quickly if we are shutting down
        if(QuerySmtpInstance()->IsShuttingDown()
            || (QuerySmtpInstance()->QueryServerState( ) == MD_SERVER_STATE_STOPPED)
            || (QuerySmtpInstance()->QueryServerState( ) == MD_SERVER_STATE_INVALID))
        {
            if(pISMTPConnection)
            {
                //Ack the last connection
                pISMTPConnection->AckConnection((eConnectionStatus)CONNECTION_STATUS_OK);
                pISMTPConnection->Release();
                pISMTPConnection = NULL;
            }
            delete pmsz;
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        DomainParams.szDomainName = Domain;
        DomainParams.cbDomainNameLength = sizeof(Domain);
        hr = pISMTPConnection->GetDomainInfo(&DomainParams);


        TurnDomainList.pmsz = pmsz;
        //If we just got the ISMTPCOnn for the primary domain then we probably
        //jumped over a few domains in the domain list.
        //Set the ptr to start of the domain list
        //That way we will look at all the domains, once we are done with the
        //current primary domain
        if(fPrimaryDomain)
        {
            TurnDomainList.szCurrentDomain = pmsz->First();
            fPrimaryDomain = FALSE;
        }
        else
        {
            //Looks like we failed to get primary domain
            //so got to have started from the top - continue that
            TurnDomainList.szCurrentDomain = StartPtr;
        }

        //If we could not determine a primary domain - use the base
        //connection options
        if(!Found)
            DomainOptions = 0;
        else
            DomainOptions = DomainParams.dwDomainInfoFlags;

        //set the remote IP address we connected to
        AddrRemote.sin_addr.s_addr = 0;

        //
        //  Create an outbound connection
        //  Note: The last parameter, m_pSSLVerificationName is NULL. This is the
        //  name used to match against the SSL certificate that the server gives
        //  us during an outbound session. Setting it to NULL skips certificate
        //  subject validation, which is fine in the case of TURN, since either
        //  the server is already authenticated through other means (if ATRN) or
        //  we don't care about authentication (if TURN is configured).
        //
        SmtpConn = SMTP_CONNOUT::CreateSmtpConnection(
                                        QuerySmtpInstance(),
                                        (SOCKET) m_pAtqContext->hAsyncIO,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        NULL,
                                        (PVOID)&TurnDomainList,
                                        0,
                                        DomainOptions,
                                        NULL,
                                        NULL);
        if(SmtpConn == NULL)
        {
            delete pmsz;
            Error = GetLastError();
            PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY );
            FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed for TURN");
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //from here on, the smtpout class is responsible for
        //cleaning up the AtqContext
        m_DoCleanup = FALSE;

        SmtpConn->SetAtqContext(m_pAtqContext);

        //copy the real domain we are connected to.
        SmtpConn->SetConnectedDomain((char *) Domain);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION, (DWORD_PTR) InternetCompletion);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR) SmtpConn);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_TIMEOUT, m_pInstance->GetRemoteTimeOut());


        //insert the outbound connection object into
        //our list of outbound conection objects
        if(!QuerySmtpInstance()->InsertNewOutboundConnection(SmtpConn, TRUE))
        {
            Error = GetLastError();
            FatalTrace((LPARAM) this, "m_pInstance->InsertNewOutboundConnection failed for TURN");
            SmtpConn->DisconnectClient();
            delete SmtpConn;
            SmtpConn = NULL;
            SetLastError(Error);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        SmtpConn->SetCurrentObject(pISMTPConnection);
        PE_CdFormatSmtpMessage (250, EPROT_SUCCESS, " %s\r\n", "Server was turned");
        PE_SendSmtpResponse();

    }

    //start session will pend a read to pick
    //up the servers signon banner
    if(!SmtpConn->StartSession())
    {
        //get the error
        Error = GetLastError();
        FatalTrace((LPARAM) this, "SmtpConn->StartSession failed for TURN");
        SmtpConn->DisconnectClient();
        QuerySmtpInstance()->RemoveOutboundConnection(SmtpConn);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError (Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    m_State = TURN;

    TraceFunctLeaveEx((LPARAM) this);
    return(FALSE);

}

/*++

    Name :
        SMTP_CONNECTION::DoLASTCommand

    Description:
        This is our catch all error function.
        It will determin what kind of error
        made it execute and send an appropriate
        message back to the client.
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoLASTCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus = TRUE;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoLASTCommand");

  _ASSERT (m_pInstance != NULL);

   PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, ENOT_IMPLEMENTED," %s\r\n", SMTP_BAD_CMD_STR);
   BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
   m_ProtocolErrors++;
   PE_SendSmtpResponse();

   TraceFunctLeaveEx((LPARAM) this);
   return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::VerifiyClient

    Description:
        This function compares the IP address the connection
        was made on to the IP address of the name given with
        the HELO or EHLO commands

    Arguments:
        ClientHostName - from HELO or EHLO command
        KnownIpAddress - from accept
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
DWORD SMTP_CONNECTION::VerifiyClient (const char * ClientHostName, const char * KnownIpAddress)
{
    in_addr UNALIGNED * P_Addr = NULL;
    PHOSTENT Hp = NULL;
    DWORD KnownClientAddress = 0;
    DWORD dwRet = SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::VerifiyClient");

    Hp = gethostbyname (ClientHostName);
    if (Hp == NULL)
    {
        DWORD dwErr = WSAGetLastError();
        if(dwErr == WSANO_DATA)
            dwRet = NO_MATCH;
        else
            dwRet = LOOKUP_FAILED;

        TraceFunctLeaveEx((LPARAM) this);
        return dwRet;
    }

    KnownClientAddress = inet_addr (KnownIpAddress);
    if (KnownClientAddress == INADDR_NONE)
    {
        dwRet = LOOKUP_FAILED;
        TraceFunctLeaveEx((LPARAM) this);
        return dwRet;
    }

    while( (P_Addr = (in_addr UNALIGNED *)*Hp->h_addr_list++) != NULL)
    {
        if (P_Addr->s_addr == KnownClientAddress)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return dwRet;
        }
    }

    dwRet = NO_MATCH;
    TraceFunctLeaveEx((LPARAM) this);
    return dwRet;
}

/*++

    Name :
        void SMTP_CONNECTION::HandleAddressError(char * InputLine)

    Description:
        common code to determine what error occurred
        as a result of address validation/allocation failure failure
    Arguments:

        none
    Returns:

        none
--*/
void SMTP_CONNECTION::HandleAddressError(char * InputLine)
{
    DWORD Error = GetLastError();

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleAddressError");

    if(Error == ERROR_NOT_ENOUGH_MEMORY)
      {
        BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToNoCAddrObjects);
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY );
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY");
      }
    else if (Error == ERROR_INVALID_DATA)
      {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n",SMTP_INVALID_ADDR_MSG);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_BAD_ARGS, SMTP_INVALID_ADDR_MSG");
        m_ProtocolErrors++;
      }
    else
      {
        PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n","Unknown Error");
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_MBX_SYNTAX, Unknown Error");
        m_ProtocolErrors++;
      }

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        void SMTP_CONNECTION::SkipWord

    Description:
        skips over words in a buffer and
        returns pointer to next word
    Arguments:

        none
    Returns:

        none
--*/
char * SMTP_CONNECTION::SkipWord (char * Buffer, char * WordToSkip, DWORD WordLen)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::SkipWord");

    //find string
    if (strncasecmp(Buffer, WordToSkip, WordLen))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS , EINVALID_ARGS," %s %s\r\n",  "Unrecognized parameter", Buffer);
        ProtocolLog(USE_CURRENT, Buffer, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        return NULL;
    }

    //skip past word
    Buffer += WordLen;

    //skip white spaces looking for the ":" character
    while( (*Buffer != '\0') && (isspace ((UCHAR)*Buffer) || (*Buffer == '\t')))
      Buffer++;

    if( (*Buffer == '\0') || (*Buffer != ':'))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS , EINVALID_ARGS," %s %s\r\n", "Unrecognized parameter", Buffer);
        ProtocolLog(USE_CURRENT, Buffer, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        return NULL;
    }

    //add one to skip the ":"
    Buffer++;

    TraceFunctLeaveEx((LPARAM) this);
    return Buffer;
}

VOID SMTP_CONNECTION::ProtocolLog(DWORD dwCommand, LPCSTR pszParameters, DWORD dwWin32Error,
                                  DWORD dwSmtpError, DWORD BytesSent, DWORD BytesRecv, LPSTR pszTarget)
{
    LPCSTR   pszCmd = "";
    char szKeyword[100];

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::ProtocolLog");

    _ASSERT (m_pInstance != NULL);

    //
    // verify if we should use the current command
    //
    if ( dwCommand == USE_CURRENT )
    {
        dwCommand = m_dwCurrentCommand;
    }

    if(dwCommand == SMTP_TIMEOUT)
    {
        strcpy(szKeyword, "TIMEOUT");
        pszCmd = szKeyword;
    }
    else
    {
        pszCmd = (LPSTR)SmtpCommands[ dwCommand ];
        if ( pszCmd == NULL )
        {
            // if this is a PE word then its the first word in the
            // parameters
            char *pszSpace = strchr(pszParameters, ' ');
            if (pszSpace) {
                DWORD_PTR cToCopy = (DWORD_PTR) pszSpace - (DWORD_PTR) pszParameters;
                if (cToCopy >= sizeof(szKeyword)) cToCopy = sizeof(szKeyword) - 1;
                strncpy(szKeyword, pszParameters, cToCopy);
                szKeyword[cToCopy] = 0;
                pszParameters += cToCopy;
                pszCmd = szKeyword;
            } else {
                pszCmd = pszParameters;
                pszParameters = NULL;
            }
        }
    }

    //
    // filter so we only get the desired commands
    //
    DebugTrace( (LPARAM)this,
                "Allow cmds: 0x%08X, cmd: 0x%08X",
                m_pInstance->GetCmdLogFlags(),
                (1<<dwCommand) );

    if ( m_pInstance->GetCmdLogFlags() & (1<<dwCommand) )
    {
        TransactionLog(
                pszCmd,
                pszParameters,
                pszTarget,
                dwWin32Error,
                dwSmtpError);
    }

    TraceFunctLeaveEx((LPARAM) this);
}


BOOL
SMTP_CONNECTION::BindInstanceAccessCheck(
    )
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
     m_pInstance->LockGenCrit();

    if ( m_rfAccessCheck.CopyFrom( m_pInstance->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        m_pInstance->UnLockGenCrit();
        return TRUE;
    }

    m_pInstance->UnLockGenCrit();
    return FALSE;
}


VOID
SMTP_CONNECTION::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}

/*++

    Name :
        void SMTP_CONNECTION::SwitchToBigReceiveBuffer

    Description:
        Helper routine to allocate a 32K buffer and use it for posting reads.
        SSL fragments can be up to 32K large, and we need to accumulate an
        entire fragment to be able to decrypt it.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully allocated, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::SwitchToBigSSLBuffers(void)
{
    char *pTempBuffer;

    pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];

    if (pTempBuffer != NULL) {

        m_precvBuffer = pTempBuffer;
        m_cbMaxRecvBuffer = MAX_SSL_FRAGMENT_SIZE;

                pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
                if (pTempBuffer != NULL) {

                        m_pOutputBuffer = pTempBuffer;
                        m_cbMaxOutputBuffer =  MAX_SSL_FRAGMENT_SIZE;

                        return( TRUE );
                }
    }

    return( FALSE );
}

/*++

    Name :
        void SMTP_CONNECTION::DecryptInputBuffer

    Description:
        Helper routine to decrypt the recieve buffer when session is SSL
        encypted.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully decrypted, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::DecryptInputBuffer(void)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNECTION::DecryptInputBuffer");

    DWORD   cbExpected;
    DWORD   cbReceived;
    DWORD   cbParsable;
    DWORD   dwError;

    dwError = m_encryptCtx.DecryptInputBuffer(
                        (LPBYTE) QueryMRcvBuffer() + m_cbParsable,
                        m_cbReceived - m_cbParsable,
                        &cbReceived,
                        &cbParsable,
                        &cbExpected );

    if ( dwError == NO_ERROR )
    {
        //
        // new total received size is the residual from last processing
        // and whatever is left in the current decrypted read buffer
        //
        m_cbReceived = m_cbParsable + cbReceived;


        //
        // new total parsable size is the residual from last processing
        // and whatever was decrypted from this read io operation
        //
        m_cbParsable += cbParsable;
        m_SessionSize += cbParsable;
    }
    else
    {
        //
        // errors from this routine indicate that the stream has been
        // tampered with or we have an internal error
        //
        ErrorTrace( (LPARAM)this,
                    "DecryptInputBuffer failed: 0x%08X",
                    dwError );

        DisconnectClient( dwError );
    }

    return( dwError == NO_ERROR );
}

/*++

    Name :
        void SMTP_CONNECTION::IsClientSecureEnough

    Description:
        Finds out whether the client has negotiated the appropriate security
        level for the server instance for which this connection was
        created.

    Arguments:
        none

    Returns:
        TRUE if the client has negotiated appropriate level of security

--*/
BOOL SMTP_CONNECTION::IsClientSecureEnough(void)
{
    BOOL fRet = TRUE;

    if (QuerySmtpInstance()->RequiresSSL() && !m_SecurePort) {
        m_CInboundContext.m_dwSmtpStatus = SMTP_RESP_MUST_SECURE;
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, E_TLSNEEDED, " %s\r\n", SMTP_MSG_MUST_SECURE);
        fRet = FALSE;
    }
    else if (m_SecurePort &&
             QuerySmtpInstance()->Requires128Bits() &&
                 m_encryptCtx.QueryKeySize() < 128) {
        m_CInboundContext.m_dwSmtpStatus = SMTP_RESP_TRANS_FAILED;
        PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, E_TLSNEEDED, " %s\r\n", SMTP_MSG_NOT_SECURE_ENOUGH);
        fRet = FALSE;
    }

    if(!fRet)
    {
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
    }

    return fRet;
}



/*++

    Name :
        BOOL SMTP_CONNECTION::OnEvent

    Description:
        Is invoked from GlueDispatch.  Micro-manages sink firing scenarios.

    Arguments:
        char *    InputLine            null terminated chunk of inbound input buffer from beginning of cmd to CRLF
        DWORD    IntermediateSize    length of the above
        DWORD    CmdSize                length of command keyword

    Returns:
        TRUE                        if native handler did or by default
        FALSE                        if native handler did

--*/

HRESULT SMTP_CONNECTION::OnEvent(
        IUnknown * pIserver,
        IUnknown * pISession,
        IMailMsgProperties *pIMessage,
        LPPE_COMMAND_NODE    pCommandNode,
        LPPE_BINDING_NODE    pBindingNode,
        char * szArgs
        )
{
    PMFI PointerToMemberFunction = SmtpDispatchTable[m_dwCurrentCommand];
    HRESULT hr = S_OK;
    BOOL fResult;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::OnEvent");

    _ASSERT(pCommandNode);
    _ASSERT(pBindingNode);
    m_CInboundContext.m_pCurrentBinding = pBindingNode;

    // If this is not a native command
    if (SmtpCommands[m_dwCurrentCommand] == NULL)
    {
        hr = m_pCInboundDispatcher->ChainSinks(
                pIserver,
                pISession,
                pIMessage,
                &m_CInboundContext,
                PRIO_LOWEST,
                pCommandNode,
                &(m_CInboundContext.m_pCurrentBinding)
                );
        if (hr == MAILTRANSPORT_S_PENDING)
            goto AsyncCompletion;
    }
    else
    {
        if (pBindingNode->dwPriority <= PRIO_DEFAULT)
        {
            if (pBindingNode->dwFlags & PEBN_DEFAULT)
            {
                // We are firing the default handler, skip the pre-loop
                m_CInboundContext.m_pCurrentBinding = pBindingNode->pNext;
            }
            else
            {
                hr = m_pCInboundDispatcher->ChainSinks(
                        pIserver,
                        pISession,
                        pIMessage,
                        &m_CInboundContext,
                        PRIO_DEFAULT,
                        pCommandNode,
                        &(m_CInboundContext.m_pCurrentBinding)
                        );
                if (hr == MAILTRANSPORT_S_PENDING)
                    goto AsyncCompletion;
            }

            if (FAILED(hr))
                return hr;

            if((hr != EXPE_S_CONSUMED) && (hr != S_FALSE)) {
                fResult = (this->*PointerToMemberFunction)(szArgs,strlen(szArgs));

                if (!fResult)
                    m_CInboundContext.SetCommandStatus(EXPE_DROP_SESSION);
                else
                    m_CInboundContext.SetCommandStatus(EXPE_SUCCESS);
            }
        }

        if ((m_CInboundContext.m_pCurrentBinding) &&
            (hr != EXPE_S_CONSUMED) && (hr != S_FALSE))
        {
            hr = m_pCInboundDispatcher->ChainSinks(
                    pIserver,
                    pISession,
                    pIMessage,
                    &m_CInboundContext,
                    PRIO_LOWEST,
                    pCommandNode,
                    &(m_CInboundContext.m_pCurrentBinding)
                    );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);

AsyncCompletion:

    DebugTrace((LPARAM)this, "Leaving because of S_PENDING");
    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

HRESULT SMTP_CONNECTION::OnNotifyAsyncCompletion(
    HRESULT    hrResult
    )
{
    HRESULT    hr = S_OK;
    LPSTR    pArgs = NULL;
    CHAR    chTerm = '\0';

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::OnNotifyAsyncCompletion");

    // Make sure the sink did not call back with S_PENDING
    if (hrResult == MAILTRANSPORT_S_PENDING)
        hrResult = S_OK;

    // See if we have to continue chaining
    if (hrResult == S_OK)
    {
        LPPE_BINDING_NODE    pNextBinding;
        PE_BINDING_NODE        bnDefault;

        // If we have more bindings, or if we are before a native command, we have to
        // go in again
        _ASSERT(m_CInboundContext.m_pCurrentBinding);
        pNextBinding = m_CInboundContext.m_pCurrentBinding->pNext;

        // Now see if we have a native handler
        if (SmtpDispatchTable[m_dwCurrentCommand] &&
                (m_CInboundContext.m_pCurrentBinding->dwPriority <= PRIO_DEFAULT))
        {
            if (!pNextBinding || (pNextBinding->dwPriority > PRIO_DEFAULT))
            {
                bnDefault.dwPriority = PRIO_DEFAULT;
                bnDefault.pNext = pNextBinding;
                bnDefault.dwFlags = PEBN_DEFAULT;
                pNextBinding = &bnDefault;
            }
        }

        if (pNextBinding != NULL)
        {
            // Call the OnEvent to resume chaining ...
            pArgs = strchr(m_CInboundContext.m_cabCommand.Buffer(), ' ');
            if (!pArgs)
                pArgs = &chTerm;
            hrResult = OnEvent(
                        m_pInstance->GetInstancePropertyBag(),
                        GetSessionPropertyBag(),
                        m_pIMsg,
                        m_CInboundContext.m_pCurrentCommandContext,
                        pNextBinding,
                        pArgs
                        );
            // We have scenarios:
            // 1) S_OK, S_FALSE: We send the response and do the
            // next command
            // 2) ERROR: Drop the connection
            // 3) S_PENDING: Just let the thread return
        }
        else
            hrResult = S_OK;
    }

    if (hrResult != MAILTRANSPORT_S_PENDING)
    {
		// log this command and the response
		if (m_State != DATA &&
			m_State != BDAT &&
			m_State != AUTH &&
			m_dwCurrentCommand != DATA &&
			m_dwCurrentCommand != BDAT &&
			m_dwCurrentCommand != AUTH)
		{
			const char *pszCommand = SmtpCommands[m_dwCurrentCommand];
			DWORD cCmd = (pszCommand) ? strlen(pszCommand) : 0;
			ProtocolLog(m_dwCurrentCommand,
				m_CInboundContext.m_cabCommand.Buffer() + cCmd,
				m_CInboundContext.m_dwWin32Status,
				m_CInboundContext.m_dwSmtpStatus,
				0,
				0);
		}

        // It's not another async operation
        if (SUCCEEDED(hrResult))
        {
            // Send the response and process the next command
            if (!ProcessAndSendResponse())
                hrResult = E_FAIL;

            // Disconnect client if needed
            if (m_CInboundContext.m_dwCommandStatus & EXPE_DROP_SESSION)
            {
                DisconnectClient();
                hrResult = E_FAIL;
            }

            // do things unique to handling the end of a message
            if (m_fAsyncEOD) {
                ReInitClassVariables();
            }
        }

        if (SUCCEEDED(hrResult)) {
            //
            // ProcessClient usually posts an async ReadFile --
            // This can be a problem since ntos actuall completes the
            // read with the thread that issued it.  If the sink
            // writer has the thread exit before the read completes,
            // we would get an error.  To get around this, we call
            // PostQueuedCompleteionStatus with the sink's thread and
            // then post the next async read with an atq thread.
            //
            //ProcessClient(0, NO_ERROR,
            //(LPOVERLAPPED)&m_CInboundContext);
             m_fAsyncEventCompletion = TRUE;

            if(
                PostCompletionStatus(
                    1 // Post 1 byte (a zero byte completion means the
                      // remote host disconnected
                ) == FALSE) {
                //
                // We were unable to post completion status, fail
                // below
                //
                hrResult = E_FAIL;
                m_fAsyncEventCompletion = FALSE;
            }
        }
        if(FAILED(hrResult))
            ProcessClient(0, ERROR_OPERATION_ABORTED, NULL);
    }

    TraceFunctLeaveEx((LPARAM)this);
    // We always keep the sink happy
    return(S_OK);

}

BOOL SMTP_CONNECTION::ProcessAndSendResponse()
{
    BOOL    fResult = TRUE;
    DWORD    dwResponseSize = 0;
    LPSTR    pszResponse = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessAndSendResponse");


    // See if we have a custom response from sinks
    dwResponseSize = m_CInboundContext.m_cabResponse.Length();
    pszResponse = m_CInboundContext.m_cabResponse.Buffer();
    if (!dwResponseSize || !*pszResponse)
    {
        // Try the native buffer
        dwResponseSize = m_CInboundContext.m_cabNativeResponse.Length();
        pszResponse = m_CInboundContext.m_cabNativeResponse.Buffer();
        // If the response buffer is NULL, we won't send any response.
        // For example BDAT exhibits this behavior
    }

    if (dwResponseSize && *pszResponse)
        PE_FastFormatSmtpMessage(pszResponse, dwResponseSize - 1);

    // SendResponse if needed
    if (!(m_CInboundContext.m_dwCommandStatus & EXPE_PIPELINED))
        fResult = SendSmtpResponse();

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

/*++

    Name :
        BOOL SMTP_CONNECTION::GlueDispatch

    Description:
        Is invoked from ProcessInputBuffer as if it were native handler for SMTP command.
        Finds out if the command is native/non-native, and,if native, extended/non-extended.
        Then, fires the corresponding mix of native handler and inbound sinks.

    Arguments:
        char *    InputLine            null terminated chunk of inbound input buffer from beginning of cmd to CRLF
        DWORD    IntermediateSize    length of the above
        DWORD    CmdSize                length of command keyword

    Returns:
        TRUE                        if native handler did or by default
        FALSE                        if native handler did

--*/
BOOL SMTP_CONNECTION::GlueDispatch(char * InputLine, DWORD IntermediateSize, DWORD CmdSize, BOOL * pfAsyncOp)
{
    HRESULT hr;
    PMFI    PointerToMemberFunction = SmtpDispatchTable[m_dwCurrentCommand];
    BOOL    fSinksInstalled = FALSE;
    BOOL    fResult = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::GlueDispatch");

    _ASSERT(InputLine);
    _ASSERT(m_pInstance);
    _ASSERT(pfAsyncOp);
    if (!InputLine || !m_pInstance || !pfAsyncOp)
        return(FALSE);

    // Default is no async operation
    *pfAsyncOp = FALSE;

    //
    // See if we are secure enough for this command
    //

	switch (m_dwCurrentCommand) {
	case HELO:
	case EHLO:
	case NOOP:
	case STARTTLS:
	case TLS:
	case QUIT:
		// These commands don't need to be done securely
		break;

	default:
		if (!IsClientSecureEnough())
		{
			ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
			TraceFunctLeaveEx((LPARAM) this);
			return TRUE;
		}
	}


    if(m_pCInboundDispatcher == NULL) {
        m_pIEventRouter = m_pInstance->GetRouter();

        _ASSERT(m_pIEventRouter);
        if (!m_pIEventRouter)
            return(FALSE);

        hr = m_pIEventRouter->GetDispatcherByClassFactory(
            CLSID_CInboundDispatcher,
            &g_cfInbound,
            CATID_SMTP_ON_INBOUND_COMMAND,
            IID_ISmtpInboundCommandDispatcher,
            (IUnknown **)&m_pCInboundDispatcher);


        if (!SUCCEEDED(hr)){
            ErrorTrace((LPARAM) this, "Unable to get dispatcher by CLF on router");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    // pre-loading per command buffer into the context object...
    m_CInboundContext.ResetInboundContext();

    // null-terminating the command keyword...
    char * szTemp;
    char * szTemp2;
    char * szArgs;
	char chReplaced = '\0';

    szTemp = strpbrk(InputLine, "\x09\x0a\x0b\x0c\x0d\x20");
    if (szTemp == NULL)
    {
        szTemp = InputLine + strlen(InputLine);
        _ASSERT(szTemp);
        szArgs = szTemp;
    }
    else
    {
    	chReplaced = *szTemp;
        *szTemp='\0';
        szArgs = szTemp;
    }
    szTemp2 = InputLine;
    while (szTemp2 < szTemp)
    {
        *szTemp2 = (CHAR)tolower(*szTemp2);
        szTemp2++;
    }

    // OK, we know we're dealing with native...
    hr = m_pCInboundDispatcher->SinksInstalled(
                    InputLine,
                    &(m_CInboundContext.m_pCurrentCommandContext));
    if (hr == S_OK)
        fSinksInstalled = TRUE;

    if (chReplaced != '\0')
        *szTemp = chReplaced;

    hr = m_CInboundContext.m_cabCommand.Append(
                    (char *)InputLine,
                    strlen(InputLine) + 1,
                    NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "Unable to set command buffer");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }


    // Make sure IMsg is instantiated...if it's not, instantiate it !!!
    if (m_dwCurrentCommand == MAIL)
    {
        BOOL    fCreateIMsg = TRUE;

        if (m_pIMsg != NULL)
        {
            char    b;

            // If we have an allocated IMailMsg but we don't have a valid
            // sender address yet, we will release the object and re-allocate it.
            // Otherwise, we will skip the creation of another message object.
            hr = m_pIMsg->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, 1, &b);
            if(hr == MAILMSG_E_PROPNOTFOUND)
                ReleasImsg(TRUE);
            else
                fCreateIMsg = FALSE;
        }

        if (fCreateIMsg)
        {
            // Create a new MailMsg
            hr = CoCreateInstance(CLSID_MsgImp,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgProperties,
                            (LPVOID *)&m_pIMsg);

            // Next, check if we are over the inbound cutoff limit. If so, we will release the message
            // and not proceed.
            if (SUCCEEDED(hr))
            {
                DWORD    dwCreationFlags;
                hr = m_pIMsg->GetDWORD(
                            IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                            &dwCreationFlags);
                if (FAILED(hr) ||
                    (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                {
                    // If we fail to get this property of if the inbound cutoff
                    // exceeded flag is set, discard the message and return failure
                    if (SUCCEEDED(hr))
                    {
                        DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                        hr = E_OUTOFMEMORY;
                    }
                    m_pIMsg->Release();
                    m_pIMsg = NULL;
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecipsTemp);
                if (SUCCEEDED(hr))
                {
                    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pIMsgRecipsTemp->AllocNewList(&m_pIMsgRecips);
                        if (FAILED(hr))
                        {
                            FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                            ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                            fResult = FALSE;
                            goto ErrorCleanup;
                        }

                        hr = SetAvailableMailMsgProperties();
                        if(FAILED(hr))
                        {
                            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                            FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
                            ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                            fResult = FALSE;
                            goto ErrorCleanup;

                        }


                    }
                    else
                    {
                        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                        m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                        ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                        fResult = FALSE;
                        goto ErrorCleanup;
                    }
                }
                else
                {
                    FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                    m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                    ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                    fResult = FALSE;
                    goto ErrorCleanup;
                }
            }
            else
            {
                BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToNoMailObjects);
                FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                fResult = FALSE;
                goto ErrorCleanup;
            }
        }
    }

    // Mark the start fo protocol event processing
    m_fIsPeUnderway = TRUE;

    if (PointerToMemberFunction != NULL)
    {
        // This is native
        if (fSinksInstalled)
        {
            LPPE_BINDING_NODE    pBinding;
            PE_BINDING_NODE        bnDefault;

            pBinding = m_CInboundContext.m_pCurrentCommandContext->pFirstBinding;
            _ASSERT(pBinding);

            // Now if the first sink is a post sink, we must create a sentinel
            // so we know not to miss the native handler
            if (pBinding->dwPriority > PRIO_DEFAULT)
            {
                bnDefault.dwPriority = PRIO_DEFAULT;
                bnDefault.pNext = pBinding;
                bnDefault.dwFlags = PEBN_DEFAULT;
                pBinding = &bnDefault;
            }

            hr = OnEvent(
                m_pInstance->GetInstancePropertyBag(),
                GetSessionPropertyBag(),
                m_pIMsg,
                m_CInboundContext.m_pCurrentCommandContext,
                pBinding,
                szArgs
                );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
        else
        {
            //OK, it's native, not extended command...
            // So we just run the native handler on it
            fResult = (this->*PointerToMemberFunction)(szArgs, strlen(szArgs));
            // all changes got dumped into context automatically...
            // the interpreter will see the default response nonempty
            // and sink response empty, and it will flush just that...
            // for conformity with onevent
            hr = S_OK;
            // however, we need to modify command status here to signify if
            // we need to keep connection open
            if (!fResult)
                m_CInboundContext.SetCommandStatus(EXPE_DROP_SESSION);
            else
                m_CInboundContext.SetCommandStatus(EXPE_SUCCESS);
        }
    }
    else
    {
        // This is not a native command
        if (fSinksInstalled)
        {
            hr = OnEvent(
                m_pInstance->GetInstancePropertyBag(),
                GetSessionPropertyBag(),
                m_pIMsg,
                m_CInboundContext.m_pCurrentCommandContext,
                m_CInboundContext.m_pCurrentCommandContext->pFirstBinding,
                szArgs
                );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
        // once again, all info now sits in the context
        // the only thing left is just to check if any sinks were chained for this command,
        // and, if not, run a chain of *-sinks on it.  If they did not pick it up, either,
        // we call on DoLASTCommand and that's all!
        //
        // jstamerj 1998/10/29 18:01:53: Check the command status code
        // to see if we need to continue (in addition to smtp status)
        //
        if ((m_CInboundContext.m_dwSmtpStatus == 0) &&
            (m_CInboundContext.m_dwCommandStatus == EXPE_UNHANDLED))
        {
            hr = m_pCInboundDispatcher->SinksInstalled(
                        "*",&(m_CInboundContext.m_pCurrentCommandContext));
            if (hr == S_OK)
            {
                hr = OnEvent(
                    m_pInstance->GetInstancePropertyBag(),
                    GetSessionPropertyBag(),
                    m_pIMsg,
                    m_CInboundContext.m_pCurrentCommandContext,
                    m_CInboundContext.m_pCurrentCommandContext->pFirstBinding,
                    szArgs
                    );
                if (hr == MAILTRANSPORT_S_PENDING)
                    goto AsyncCompletion;
            }

            if ((m_CInboundContext.m_dwSmtpStatus == 0) &&
                (m_CInboundContext.m_dwCommandStatus == EXPE_UNHANDLED))
            {
                fResult=(this->DoLASTCommand)(szArgs, strlen(szArgs));

                // the context at this point does not contain anything meaningful, so just return
                if (!fResult)
                    m_CInboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;
                else
                    m_CInboundContext.m_dwCommandStatus = EXPE_SUCCESS;
                hr = S_OK;
            }
        }
    }

    // first, we interpret the hr-logic
    // if chaining was normal, proceed, otherwise...
    if ((hr != S_OK) &&
        (hr != EXPE_S_CONSUMED))
    {
        ErrorTrace((LPARAM) this, "Error occured during chaining of sinks (%08x)", hr);
    }

    if (SUCCEEDED(hr))
    {
        // Format the message if needed
        fResult = ProcessAndSendResponse();

        // Disconnect client if needed
        if (m_CInboundContext.m_dwCommandStatus & EXPE_DROP_SESSION)
        {
            //Special case for TURN
            //where we do not diconnect the connection but simply destroy smtpcli
            if(m_DoCleanup)
                DisconnectClient();
            fResult = FALSE;
        }

        if ( ( m_CInboundContext.m_dwCommandStatus & EXPE_BLOB_READY) &&
             ( NULL != m_CInboundContext.m_pICallback))
        {
            m_fPeBlobReady = TRUE;
            m_pPeBlobCallback = m_CInboundContext.m_pICallback;
        }

        // do things unique to handling the end of a message
        if (m_fAsyncEOD) {
            ReInitClassVariables();
        }
    }
    else
        fResult = FALSE;

    // Final cleanup
    m_fIsPeUnderway = FALSE;
    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);

AsyncCompletion:

    DebugTrace((LPARAM)this, "Leaving because of S_PENDING");
    *pfAsyncOp = TRUE;
    TraceFunctLeaveEx((LPARAM)this);
    return(TRUE);

ErrorCleanup:

    // Cleanup on error. This includes sending out all final
    // responses
    SendSmtpResponse();

    m_fIsPeUnderway = FALSE;
    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

/*++

    Name :
        BOOL SMTP_CONNECTION::ProcessPeBlob

    Description:
        Calls the protocol extension sink callback with a blob buffer.

    Arguments:
        pbInputLine
        cbSize

    Returns:
        BOOL    :   continue processing

--*/

BOOL SMTP_CONNECTION::ProcessPeBlob(const char * pbInputLine, DWORD cbSize)
{
    BOOL fResult;
    HRESULT hr;
    BOOL fErrorMessageSent = FALSE;

    TraceQuietEnter( "SMTP_CONNECTION::ProcessPeBlob");

    _ASSERT( m_fPeBlobReady);
    if ( NULL == m_pPeBlobCallback) {
        ErrorTrace( ( LPARAM) this, "Sink provided no callback interface");
        fResult = FALSE;
        goto cleanup;
    }

    m_CInboundContext.ResetInboundContext();
    m_CInboundContext.m_pbBlob = ( PBYTE) pbInputLine;
    m_CInboundContext.m_cbBlob = cbSize;

    hr = m_pPeBlobCallback->OnSmtpInCallback(
            m_pInstance->GetInstancePropertyBag(),
            GetSessionPropertyBag(),
            m_pIMsg,
            ( ISmtpInCallbackContext *) &m_CInboundContext);

    if ( FAILED( hr)) {
        ErrorTrace( ( LPARAM) this, "Sink callback failed, hr=%x", hr);
        fResult = FALSE;
        goto cleanup;
    }

    fResult = ProcessAndSendResponse();
    if ( FALSE == fResult) {
        ErrorTrace( ( LPARAM) this, "ProcessAndSendResponse failed");
        goto cleanup;
    }

    if (m_CInboundContext.m_dwCommandStatus & EXPE_DROP_SESSION) {
        fResult = FALSE;
        fErrorMessageSent = TRUE;
        goto cleanup;
    }

    if ( m_CInboundContext.m_dwCommandStatus & EXPE_BLOB_DONE) {
        m_fPeBlobReady = FALSE;
        m_pPeBlobCallback->Release();
        m_pPeBlobCallback = NULL;
    }

cleanup:
    if ( fResult == FALSE) {
        m_fPeBlobReady = FALSE;
        if ( NULL != m_pPeBlobCallback) {
            m_pPeBlobCallback->Release();
            m_pPeBlobCallback = NULL;
        }
        if (!fErrorMessageSent) {
            FormatSmtpMessage( SMTP_RESP_ERROR, NULL, " %s\r\n", "Sink problem processing blob");
            SendSmtpResponse();
        }
    }

    return fResult;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_FormatSmtpMessage

    Description:
        If we are processing non-native or extended native command, caches response in
        context object, otherwise passes it along to native FormatSmtpMessage.

    Arguments:
        As in FormatSmtpMessage.

    Returns:
        TRUE always
--*/
BOOL SMTP_CONNECTION::PE_FormatSmtpMessage(IN const char * Format, ...)
{
    va_list arglist;
    char Buffer[MAX_NATIVE_RESPONSE_SIZE];
    int BytesWritten;
    DWORD AvailableBytes = MAX_NATIVE_RESPONSE_SIZE;

    va_start(arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
    va_end(arglist);

    if (!m_fIsPeUnderway)
    {
        //pass in 0 for the code and NULL for the enhanced staus code
        //
        FormatSmtpMessage(0,NULL,"%s", Buffer);
    }
    else
    {
        m_CInboundContext.AppendNativeResponse(Buffer, strlen(Buffer) + 1);
    }
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_CdFormatSmtpMessage

    Description:
        As PE_FormatSmtpMessage above, except intercepts the SMTP return code.

    Arguments:
        As in PE_FormatSmtpMessage above, except add'l slot for SMTP return code.

    Returns:
        TRUE always

--*/
BOOL SMTP_CONNECTION::PE_CdFormatSmtpMessage(DWORD dwCode, const char * szEnhancedCodes, IN const char * Format,...)
{
    va_list arglist;
    char Buffer[MAX_NATIVE_RESPONSE_SIZE];
    int BytesWritten;
    DWORD AvailableBytes = MAX_NATIVE_RESPONSE_SIZE;
    char RealFormat[MAX_PATH];

    if(m_pInstance->AllowEnhancedCodes() && szEnhancedCodes)
    {
        sprintf(RealFormat,"%d %s",dwCode,szEnhancedCodes);
    }
    else
        sprintf(RealFormat,"%d",dwCode);

    strcat(RealFormat,Format);

    va_start(arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, (const char * )RealFormat, arglist);
    if(BytesWritten == -1) {
        //
        // If response is too long, forcibly truncate it
        // This might mean that the human readable part of the response may be
        // incomplete... but there's nothing we can do about that easily.
        //
        Buffer[MAX_NATIVE_RESPONSE_SIZE-3] = '\r';
        Buffer[MAX_NATIVE_RESPONSE_SIZE-2] = '\n';
        Buffer[MAX_NATIVE_RESPONSE_SIZE-1] = '\0';
    }
    if (m_fIsPeUnderway)
    {
        PE_FormatSmtpMessage("%s",Buffer);
        m_CInboundContext.SetSmtpStatusCode(dwCode);
    }
    else
    {
        //pass in 0 for the code and NULL for the enhanced staus code
        //
        FormatSmtpMessage(0,NULL,"%s",Buffer);
    }
    va_end(arglist);
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_DisconnectClient

    Description:
        If we are processing non-native or extended native command, caches DisconnectClient
        calls' occurences in context object, otherwise passes it along to native
        DisconnectClient.

    Arguments:
        none

    Returns:
        TRUE always

--*/
BOOL SMTP_CONNECTION::PE_DisconnectClient()
{
    if (m_fIsPeUnderway)
    {
        m_CInboundContext.m_dwCommandStatus = m_CInboundContext.m_dwCommandStatus | EXPE_DROP_SESSION;
    }
    else
    {
        DisconnectClient();
    }
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_SendSmtpResponse

    Description:
        If we are processing non-native or extended native command, caches SendSmtpResponse
        calls' occurences in context object, otherwise passes it along to native
        SendSmtpResponse.

    Arguments:
        none

    Returns:
        TRUE always if we're called from GlueDispatch callee's
        SendSmtpResponse return otherwise

--*/
BOOL SMTP_CONNECTION::PE_SendSmtpResponse()
{
    if (m_fIsPeUnderway)
    {
        m_CInboundContext.m_dwCommandStatus = m_CInboundContext.m_dwCommandStatus & (~EXPE_PIPELINED);
        return TRUE;
    }
    else
    {
        return SendSmtpResponse();
    };
}

//////////////////////////////////////////////////////////////////////////////
//---[ SMTP_CONNECTION::GetAndPersistRFC822Headers ]--------------------------
//
//
//  Description:
//      Parses and RFC822 headers, and promotes them to the P2 if neccessary
//  Parameters:
//      IN  InputLine       String with start of link (processed by ChompHeader)
//      IN  psValueBuf      String with value of header
//  Returns:
//      -
//  History:
//      2/8/99 - MikeSwa Updated - moved received header parsing to this function
//
//-----------------------------------------------------------------------------
void SMTP_CONNECTION::GetAndPersistRFC822Headers(
    char* InputLine,
    char* pszValueBuf
    )
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::GetAndPersistRFC822Headers");

    HRESULT hr = S_OK;

    //count the number of received lines for hop count
    //analysis later
    if(!strncasecmp(InputLine, "Received:", strlen("Received:")) ||
       !strncasecmp(InputLine, "Received :", strlen("Received :")))
    {
        m_HopCount++;

        CHAR    szText[2024];
        CHAR *  pszTemp;

        // Check if this string represents the local server - if it does we might be
        // looping around and we need to keep track of how many times this server has
        // seen the message
        sprintf(szText,szFormatReceivedServer, m_pInstance->GetFQDomainName());
        pszTemp = strstr(InputLine, szText);
        if (pszTemp)
        {
            // we found the string, make sure we also find "with Microsoft SMTPSVC"
            sprintf(szText,szFormatReceivedService);
            pszTemp = strstr(InputLine, szText);
            if (pszTemp)
            {
                // we found that string too - we've been here before,
                // increment m_LocalHopCount
                m_LocalHopCount++;
            }
        }
    }

    //
    // Get the message ID and persist it
    //
    if( !m_fSeenRFC822MsgId &&
        ( !strncasecmp( InputLine, "Message-ID:", strlen("Message-ID:") ) ||
          !strncasecmp( InputLine, "Message-ID :", strlen("Message-ID :") ) ) )
    {
        m_fSeenRFC822MsgId = TRUE;

        if( pszValueBuf )
        {
            //
            // Some MTAs fold Message-IDs. Embedded CRLFs in a Message-ID can cause trouble since
            // we use it for message tracking, and in the "Queued" response, so we unfold the
            // Message-ID prior to using it.
            //

            CHAR *pszUnfolded = NULL;

            if(!UnfoldHeader(pszValueBuf, &pszUnfolded))
            {
                m_MailBodyError = E_OUTOFMEMORY;
                TraceFunctLeaveEx((LPARAM) this);
                return;
            }

            if(pszUnfolded)
                pszValueBuf = pszUnfolded;

            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, pszValueBuf ) ) )
                m_MailBodyError = hr;

            if(pszUnfolded)
                FreeUnfoldedHeader(pszUnfolded);

            TraceFunctLeaveEx((LPARAM) this);
            return;
        }

    }

    //
    // get the Subject:  & persist it
    //

    if( !m_fSeenRFC822Subject &&
        ( !strncasecmp( InputLine, "Subject:", strlen("Subject:") ) ||
          !strncasecmp( InputLine, "Subject :", strlen("Subject :") ) ) )
    {
        m_fSeenRFC822Subject = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_SUBJECT, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the To: address & persist it
    //

    if( !m_fSeenRFC822ToAddress &&
        ( !strncasecmp( InputLine, "To:", strlen("To:") ) ||
          !strncasecmp( InputLine, "To :", strlen("To :") ) ) )
    {
        m_fSeenRFC822ToAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_TO_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the Cc: address & persist it
    //

    if( !m_fSeenRFC822CcAddress &&
        ( !strncasecmp( InputLine, "Cc:", strlen("Cc:") ) ||
          !strncasecmp( InputLine, "Cc :", strlen("Cc :") ) ) )
    {
        m_fSeenRFC822CcAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_CC_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the Bcc: address & persist it
    //

    if( !m_fSeenRFC822BccAddress &&
        ( !strncasecmp( InputLine, "Bcc:", strlen("Bcc:") ) ||
          !strncasecmp( InputLine, "Bcc :", strlen("Bcc :") ) ) )
    {
        m_fSeenRFC822BccAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_BCC_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }
    }

    //
    // get the From: address & persist it
    //

    if( !m_fSeenRFC822FromAddress &&
        ( !strncasecmp( InputLine, "From:", strlen("From:") ) ||
          !strncasecmp( InputLine, "From :", strlen("From :") ) ) )
    {
        m_fSeenRFC822FromAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;

            char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpFromAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = m_pIMsg->PutStringA(IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress))) {
                    m_MailBodyError = hr;
                }
            }
        }

    }

    if( !m_fSeenRFC822SenderAddress &&
        ( !strncasecmp( InputLine, "Sender:", strlen("Sender:") ) ||
          !strncasecmp( InputLine, "Sender :", strlen("Sender :") ) ) )
    {
        m_fSeenRFC822SenderAddress = TRUE;

        if( pszValueBuf )
        {
            char szSmtpSenderAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpSenderAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = m_pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS, szSmtpSenderAddress))) {
                    m_MailBodyError = hr;
                }
            }
        }
    }

    //
    // get the X-Priority & persist it
    //

    if( !m_fSeenXPriority &&
        ( !strncasecmp( InputLine, "X-Priority:", strlen("X-Priority:") ) ||
          !strncasecmp( InputLine, "X-Priority :", strlen("X-Priority :") ) ) )
    {
        m_fSeenXPriority = TRUE;

        if( pszValueBuf )
        {
            DWORD dwPri = (DWORD)atoi( pszValueBuf );
            if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_X_PRIORITY, dwPri ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the X-OriginalArrivalTime & persist it
    //

    if( !m_fSeenXOriginalArrivalTime &&
        ( !strncasecmp( InputLine, "X-OriginalArrivalTime:", strlen("X-OriginalArrivalTime:") ) ||
          !strncasecmp( InputLine, "X-OriginalArrivalTime :", strlen("X-OriginalArrivalTime :") ) ) )
    {
        m_fSeenXOriginalArrivalTime = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_ORIGINAL_ARRIVAL_TIME, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }
    }

    //
    // get the content type & persist it
    //

    if( !m_fSeenContentType &&
        ( !strncasecmp( InputLine, "Content-Type:", strlen("Content-Type:") ) ||
          !strncasecmp( InputLine, "Content-Type :", strlen("Content-Type :") ) ) )
    {
        m_fSeenContentType = TRUE;
        m_fSetContentType = TRUE;
        DWORD dwContentType = 0;

        if( pszValueBuf )
        {
            if( !strncasecmp( pszValueBuf, "multipart/signed", strlen("multipart/signed") ) )
            {
                dwContentType = 1;
            }
            else if( !strncasecmp( pszValueBuf, "application/x-pkcs7-mime", strlen("application/x-pkcs7-mime") ) ||
                     !strncasecmp( pszValueBuf, "application/pkcs7-mime", strlen("application/pkcs7-mime") ) )
            {
                dwContentType = 2;
            }

            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_CONTENT_TYPE, pszValueBuf ) ) )
                m_MailBodyError = hr;

        }

        if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, dwContentType ) ) )
            m_MailBodyError = hr;
    }

    if( !m_fSetContentType )
    {
        m_fSetContentType = TRUE;
        if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, 0 ) ) )
            m_MailBodyError = hr;
    }

    TraceFunctLeaveEx((LPARAM) this);
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_CONNECTION::SetAvailableMailMsgProperties()
{

    //set IPaddress that is already available
    HRESULT hr = m_pIMsg->PutStringA(IMMPID_MP_CONNECTION_IP_ADDRESS, QueryClientHostName());
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS, QueryLocalHostName());
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_SERVER_NAME, g_ComputerName);
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_SERVER_VERSION, g_VersionString);
    if(FAILED(hr))
    {
        return( hr );
    }

    if (QueryLocalPortName())
    {
        DWORD dwPortNum = atoi(QueryLocalPortName());
        hr = m_pIMsg->PutDWORD(IMMPID_MP_CONNECTION_SERVER_PORT, dwPortNum);
        if (FAILED(hr))
            return ( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_HELO_DOMAIN, QueryClientUserName());
    if(FAILED(hr))
    {
        return hr;
    }

    if (m_fAuthenticated)
    {

        //Get username
        if (m_securityCtx.QueryUserName())
        {
            hr = m_pIMsg->PutStringA(IMMPID_MP_CLIENT_AUTH_USER,
                                    m_securityCtx.QueryUserName());
            if (FAILED(hr))
                return hr;
        }

        //Get type of authentication
        if (m_szUsedAuthKeyword[0])
        {
            hr = m_pIMsg->PutStringA(IMMPID_MP_CLIENT_AUTH_TYPE, m_szUsedAuthKeyword);
            if (FAILED(hr))
                return hr;
        }

    }
    return( hr );
}

//-----------------------------------------------------------------------------
//  Description:
//      If a failure occurs after a client issues the BDAT command, SMTP cannot
//      respond with a failure code (since the RFC forbids a BDAT response). So
//      SMTP calls this function which will read BDAT chunks from the socket
//      and discard them. When the chunk has been received, and it is time to
//      ACK the chunk, this function calls DoBDATErrorProcessing() to send the
//      correct error response.
//
//  Arguments:
//      IN const char *InputLine - Ptr to data from client
//      IN DWORD UndecryptedTailSize - # of undecrypted bytes in buffer (TLS)
//
//      OUT BOOL *pfAsyncOp - If this function succeeded, this is set to TRUE
//          if all the data in the input buffer was consumed and we pended a
//          read to pick up more. If this is FALSE, and the function succeeded
//          there is extra (pipelined) data in the input buffer, and it must
//          be parsed as an SMTP command.
//
//  Notes:
//      If there is data left in the input buffer after this function is done,
//      that data should be parsed as an SMTP command.
//
//  Returns:
//      TRUE - Keep connection alive.
//      FALSE - Drop connection, there was a fatal error.
//
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::AcceptAndDiscardBDAT(
    const char *InputLine,
    DWORD UndecryptedTailSize,
    BOOL *pfAsyncOp)
{
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::AcceptAndDiscardBDAT");

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    *pfAsyncOp = FALSE;

    // Note: m_nBytesRemainingInChunk may be zero if "BDAT 0 LAST" is submitted.
    // we should be able to handle this.
    if((DWORD)m_nBytesRemainingInChunk <= m_cbParsable)
    {
        //
        // Chunk completely received, discard it, do error processing.
        //

        DebugTrace((LPARAM) this, "Chunk completed");

        MoveMemory((PVOID) InputLine, InputLine + m_nBytesRemainingInChunk,
            m_cbReceived - m_nBytesRemainingInChunk);

        m_cbParsable -= m_nBytesRemainingInChunk;
        m_cbReceived -= m_nBytesRemainingInChunk;
        m_nBytesRemainingInChunk = 0;
        m_fIsChunkComplete = TRUE;

        if(!MailBodyErrorProcessing()) {
            fReturn = FALSE;
            goto Exit;
        }

        //
        // If we're done with all BDAT chunks, reset state. If this is NOT the last
        // BDAT chunk, then either more BDAT commands/chunks are already buffered
        // in the input buffer due to pipelining, or they're on their way. We need
        // to accept and discard all of them. m_fIsLastChunk is set by DoBDATCommand.
        //

        if(m_fIsLastChunk)
        {
            DebugTrace((LPARAM) this, "Last chunk");

            //
            // Note: This doesn't flush the input buffer, so any pipelined data is
            // still kept around. Thus the check for m_cbParsable below is valid.
            //

            ReInitClassVariables();
        }

        //
        // If we got here, there is additional data left in the buffer. This must
        // be pipelined data sent by the client, along with the just discarded
        // chunk.
        //

        *pfAsyncOp = FALSE;
        fReturn = TRUE;
    }
    else
    {
        //
        // The complete chunk has not been received, discard whatever we got, update
        // the counts of bytes received/expected and pend a read to pick up more.
        //

        DebugTrace((LPARAM) this, "Processing partial chunk");
        MoveMemory((PVOID) InputLine, InputLine + m_cbParsable, m_cbReceived - m_cbParsable);

        m_nBytesRemainingInChunk -= m_cbParsable;
        m_cbReceived -= m_cbParsable;
        m_cbParsable = 0;
        _ASSERT(!m_fIsChunkComplete);

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = fReturn;
        goto Exit;
    }

Exit:

    //
    // If we succeeded, one of the following is true:
    // (1) Either there wasn't enough data to complete the chunk and we pended a read.
    // (2) There was enough data to complete the chunk, and the remaining bytes are
    //     to be interpreted as an SMTP command (m_nBytesRemainingInChunk == 0).
    //

    if(fReturn && !*pfAsyncOp)
        _ASSERT(m_nBytesRemainingInChunk == 0);

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

BOOL SMTP_CONNECTION::AcceptAndDiscardDATA(
    const char *InputLine,
    DWORD UndecryptedTailSize,
    BOOL *pfAsyncOp)
{
    DWORD IntermediateSize = 0;
    BOOL fRet = FALSE;
    char *pszSearch = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::AcceptAndDiscardDATA");

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    *pfAsyncOp = FALSE;

    //
    // Discard data line by line until we hit an incomplete line. Then break
    // out of loop and pend a read to pick up more data. If we hit a line that
    // has only a "." in it, that is the end of the mailbody. Kick off error
    // processing, reinit the state and return.
    //

    while(pszSearch = IsLineComplete(InputLine, m_cbParsable))
    {
        IntermediateSize = (DWORD) (pszSearch - InputLine);

        if(IntermediateSize == 1 &&
            InputLine[0] == '.' && InputLine[1] == '\r' && InputLine[2] == '\n')
        {
            m_cbReceived -= IntermediateSize + 2; // +2 for CRLF since pszSearch points->CR
            m_cbParsable -= IntermediateSize + 2;
            MoveMemory((PVOID *)InputLine, pszSearch + 2, m_cbReceived);

            if(MailBodyErrorProcessing())
            {
                ReInitClassVariables();
                fRet = TRUE;
            }

            TraceFunctLeaveEx((LPARAM) this);
            return fRet;
        }

        m_cbReceived -= IntermediateSize + 2; // +2 for CRLF since pszSearch points->CR
        m_cbParsable -= IntermediateSize + 2;
        MoveMemory((PVOID *)InputLine, pszSearch + 2, m_cbReceived);
    }

    //
    // Pend a read to pick up rest of the mail body.
    //

    fRet = PendReadIO(UndecryptedTailSize);
    *pfAsyncOp = fRet;
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Based on m_MailBodyDiagnostic, this function performs error processing for
//      errors that occurred during BDAT. BDAT errors that occur when BDAT
//      is issued are not processed as soon as the error occurs, but after
//      SMTP has accepted the BDAT chunk (see AcceptAndDiscardBDAT()).
//  Arguments:
//      None.
//  Returns:
//      TRUE - Success, error response sent.
//      FALSE - Drop connection. Either there was an error, or error processing
//          requires dropping the connection (This is an RFC violation if there
//          is pipelined data in the input buffer).
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::MailBodyErrorProcessing()
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATErrorProcessing");

    switch(m_MailBodyDiagnostic) {

    case ERR_RETRY:
    case ERR_OUT_OF_MEMORY:
        PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        break;

    case ERR_MAX_MSG_SIZE:
        PE_CdFormatSmtpMessage(SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n", SMTP_MAX_MSG_SIZE_EXCEEDED_MSG );
        break;

    case ERR_AUTH_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        break;

    case ERR_TLS_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", SMTP_MSG_MUST_SECURE);
        break;

    case ERR_HELO_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Send hello first" );
        break;

    case ERR_MAIL_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need mail command." );
        break;

    case ERR_RCPT_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need Rcpt command." );
        break;

    case ERR_NO_VALID_RCPTS:
        PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ESYNTAX_ERROR," %s\r\n", SMTP_NO_VALID_RECIPS );
        break;

    default:
        _ASSERT(0 && "Bad err value");
        PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        ErrorTrace((LPARAM) this, "BUG: bad value");
    }

    TraceFunctLeaveEx((LPARAM) this);
    return SendSmtpResponse(); // Error responses are not pipelined
}

//////////////////////////////////////////////////////////////////////////////
BOOL SMTP_CONNECTION::WriteLine (char * TextToWrite, DWORD TextSize)
{
/*#if 0

    char * SavedLine = TextToWrite;
    char * EndOfLine = &SavedLine[TextSize];
    DWORD LineSize = 0;

    while( (LineSize = (EndOfLine - SavedLine)) > 78)
    {
        char * RealEndOfLine = &TextToWrite[78 - 2];

        if(!WriteMailFile(TextToWrite, RealEndOfLine - SavedLine))
            return FALSE;

        m_TotalMsgSize += (RealEndOfLine - SavedLine);

        if(!WriteMailFile("\r\n", 2))
            return FALSE;

        m_TotalMsgSize += 2;

        if(!WriteMailFile("\t", 1))
            return FALSE;

        m_TotalMsgSize += 1;

        SavedLine = RealEndOfLine;
    }

    if(LineSize > 0)
    {
        if(!WriteMailFile(TextToWrite, LineSize))
            return FALSE;

        m_TotalMsgSize += LineSize;
    }

    if(!WriteMailFile("\r\n", 2))
            return FALSE;

    m_TotalMsgSize += 2;

    return TRUE;
#endif*/
    return FALSE;
}

BOOL SMTP_CONNECTION::AddToField(void)
{
/*#if 0

    char szWriteBuffer [1000];
    char szNameBuf[MAX_INTERNET_NAME + 100];
    int LineSize = 0;
    int PrevLineSize = 0;
    DWORD NumAddress = 0;
    DWORD BuffOffSet = 0;
    DWORD MaxLineSize = 78;
    CAddr * pCAddr = NULL;
    PLIST_ENTRY pentry = NULL;
    char * HeadChar ="";

    //write the "To: " first.  This includes the space
    BuffOffSet = (DWORD) wsprintf(szWriteBuffer, "To: ");

    //get the first address
    pCAddr = MailInfo->GetFirstAddress(&pentry);

    while(pCAddr != NULL)
    {

        if(NumAddress)
        {
            HeadChar = ", ";
        }

        LineSize = wsprintf(szNameBuf, "%s<%s>", HeadChar, pCAddr->GetAddress());
        if( (DWORD)(LineSize + PrevLineSize) < MaxLineSize)
        {
            CopyMemory(&szWriteBuffer[BuffOffSet], szNameBuf, LineSize);
            PrevLineSize += LineSize;
            BuffOffSet += LineSize;
        }
        else
        {
            szWriteBuffer[BuffOffSet++] = CR;
            szWriteBuffer[BuffOffSet++] = LF;
            if(!WriteMailFile(szWriteBuffer, BuffOffSet))
                return FALSE;

            m_TotalMsgSize += BuffOffSet;
            szWriteBuffer[0] = '\t';
            CopyMemory(&szWriteBuffer[1], szNameBuf, LineSize);
            BuffOffSet = LineSize + 1;
            PrevLineSize = BuffOffSet;
        }

        NumAddress++;

        //get the first address
        pCAddr = MailInfo->GetNextAddress(&pentry);
    }

    szWriteBuffer[BuffOffSet++] = CR;
    szWriteBuffer[BuffOffSet++] = LF;

    if(WriteMailFile(szWriteBuffer, BuffOffSet))
    {
        m_TotalMsgSize += BuffOffSet ;
        return TRUE;
    }

    return FALSE;
#endif*/

    return TRUE;
}

//---[ SMTP_CONNECTION::CopyIPAddressesToSession ]---------------------------
//
//
//  Description:
//    Copies the CLIENT_CONNECTION data into the session property bag used by
//	inbound and outbound connections
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/28/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID SMTP_CONNECTION::CopyIPAddressesToSession()
{
    TraceFunctEnterEx((LPARAM) this,
	"SMTP_CONNECTION::CopyIPAddressesToSession");
    HRESULT hr = S_OK;
    IMailMsgPropertyBag *pISessionProperties =
        (IMailMsgPropertyBag *)GetSessionPropertyBag();

    if (!pISessionProperties) {
        ErrorTrace((LPARAM) this, "NULL ISession - bailing");
        goto Exit;
    }

    hr = pISessionProperties->PutStringA(ISESSION_PID_LOCAL_IP_ADDRESS,
					QueryLocalHostName());
    if (FAILED(hr)) {

        //Trace error... otherwise ignore.
        ErrorTrace((LPARAM) this,
	        "Failed to write ISESSION_PID_LOCAL_IP_ADDRESS 0x%08X", hr);
    }

    hr = pISessionProperties->PutStringA(ISESSION_PID_REMOTE_IP_ADDRESS,
					QueryClientHostName());
    if (FAILED(hr)) {

        //Trace error... otherwise ignore.
        ErrorTrace((LPARAM) this,
	        "Failed to write ISESSION_PID_REMOTE_IP_ADDRESS 0x%08X", hr);
    }

  Exit:
    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\remoteq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        remoteq.cxx

   Abstract:
        Implements a derivation of the generic queue
        for internet mail delivery

   Author:

           Rohan Phillips    ( Rohanp )    24-JAN-1995

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "dropdir.hxx"
#include "remoteq.hxx"
#include "smtpout.hxx"
#include <cdns.h>
#include "smtpdns.hxx"
#define INVALID_RCPT_IDX_VALUE 0xFFFFFFFF
extern char * MyStrChr(char *Line, unsigned char Val, DWORD LineSize);
extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);
extern CTcpRegIpList g_TcpRegIpList;

///////////////////////////////////////////////////////////////////////////
#if 0
REMOTE_QUEUE::REMOTE_QUEUE(SMTP_SERVER_INSTANCE * pSmtpInst) 
    : PERSIST_QUEUE(pSmtpInst)
{
}
#endif

///////////////////////////////////////////////////////////////////////////
DWORD   g_dwFileCounter = 0;

#define MIN(a,b) ( (a) > (b) ? (b) : (a) )

///////////////////////////////////////////////////////////////////////////

/*++

    Name :
        REMOTE_QUEUE::ProcessQueueEvents

    Description:

        This function takes a pointer to a QUEUE_ENTRY,
        which contains all the information needed to
        deliver local mail, and delivers the mail to the
        remote site.

    Arguments:

        a pointer to a QUEUE_ENTRY class

    Returns:


--*/
BOOL REMOTE_QUEUE::ProcessQueueEvents(ISMTPConnection    *pISMTPConnection)
{
    DWORD Error = 0;
    char * FileName = NULL;
    DWORD IpAddress = 0;
    DWORD TransmitOptions = 0;
    HRESULT hr = S_OK;
    BOOL AsyncConnectStarted = FALSE;
    DomainInfo DomainParams;
    char * ConnectedDomain = NULL;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::ProcessQueueEvents(PQUEUE_ENTRY pEntry)");

    _ASSERT(pISMTPConnection != NULL);

    ZeroMemory (&DomainParams, sizeof(DomainParams));

    if(pISMTPConnection == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //leave quickly if we are shutting down
    if(GetParentInst()->IsShuttingDown()
        || (GetParentInst()->QueryServerState( ) == MD_SERVER_STATE_STOPPED)
        || (GetParentInst()->QueryServerState( ) == MD_SERVER_STATE_INVALID))
    {
        HandleFailedConnection(pISMTPConnection);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    ZeroMemory(&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = pISMTPConnection->GetDomainInfo(&DomainParams);
    if(!FAILED(hr))
    {
        if(DomainParams.dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP)
        {
            AsyncCopyMailToDropDir(pISMTPConnection, DomainParams.szDropDirectory, GetParentInst());
            pISMTPConnection->Release();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }

        ConnectedDomain = DomainParams.szDomainName;

        if(DomainParams.szSmartHostDomainName != NULL)
        {
            ConnectedDomain = DomainParams.szSmartHostDomainName;
        }

        AsyncConnectStarted = StartAsyncConnect( (const char *)ConnectedDomain,
                                                 pISMTPConnection, 
                                                 DomainParams.dwDomainInfoFlags,
                                                 GetParentInst()->UseSmartHostAfterFail());
        if(AsyncConnectStarted)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    HandleFailedConnection(pISMTPConnection);
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        void HandleFailedConnection (PMAIL_ENTRY MailQEntry)

    Description:

        This function takes a pointer to a PMAIL_ENTRY,
        and either places it in the retry queue or the
        bad mail directory.

    Arguments:

        a pointer to a PMAIL_ENTRY class
        dwConnectionStatus... the status passed back to AQ
        dwConnectedIPAddress IP Adress string (passed back to AQ)

        
        11/11/98 - MikeSwa Added dwConnectionStatus
        11/29/2001 - MikeSwa Added dwConnectedIPAddress

--*/
void REMOTE_QUEUE::HandleFailedConnection (ISMTPConnection *pISMTPConnection,
                                           DWORD dwConnectionStatus,
                                           DWORD dwConnectedIPAddress)
{
    HRESULT hrConnectionFailure = AQUEUE_E_HOST_NOT_RESPONDING;
    if(pISMTPConnection != NULL)
    {
        //We know the connection failed... lets add some additional diagnostic
        //information
        if (CONNECTION_STATUS_FAILED_LOOPBACK == dwConnectionStatus)
            hrConnectionFailure = AQUEUE_E_LOOPBACK_DETECTED;

        pISMTPConnection->SetDiagnosticInfo(hrConnectionFailure, NULL, NULL);
        pISMTPConnection->AckConnection(dwConnectionStatus);

        if (dwConnectedIPAddress) 
            ReportConnectedIPAddress(pISMTPConnection, dwConnectedIPAddress);
        
        pISMTPConnection->Release();
    }
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        void ReportConnectedIPAddress 

    Description:

        Reports IP address that the protocol attempted to connect to back
        to Queuing.

    Arguments:
        ISMTPConnection AQ connection object
        dwConnectedIPAddress IP Adress string (passed back to AQ)

        11/29/2001 - MikeSwa Created

--*/
void REMOTE_QUEUE::ReportConnectedIPAddress(ISMTPConnection  *pISMTPConnection,
                              DWORD dwConnectedIPAddress)
{
    CHAR szConnectedIPAddress[46] = "";
    DWORD IPAddress = dwConnectedIPAddress; 
    CMailMsgPropertyBag SessionPropertyBag;

    if (!IPAddress || !pISMTPConnection) 
        return;

    //
    //  Convert connected IP address to string form
    //
    szConnectedIPAddress[sizeof(szConnectedIPAddress) - 1] = '\0';
    InetNtoa(*(struct in_addr *) &IPAddress, 
                                 (CHAR *) &szConnectedIPAddress);

    _ASSERT(strlen(szConnectedIPAddress) < sizeof(szConnectedIPAddress));
            
    if (szConnectedIPAddress[0])
    {
        SessionPropertyBag.PutStringA(ISESSION_PID_REMOTE_IP_ADDRESS,
                                      szConnectedIPAddress);

        SMTP_CONNOUT::PromoteSessionPropertiesToAQ(
                    (IUnknown *) ((IMailMsgPropertyBag *) &SessionPropertyBag),
                    pISMTPConnection);
    }
}

///////////////////////////////////////////////////////////////////////////
DWORD QueueDeleteFunction(PVOID ThisPtr)
{
    CAsyncMx * ThisQueue = (CAsyncMx *) ThisPtr;

    if(ThisQueue)
    {
        delete ThisQueue;
    }

    return 0;

}

///////////////////////////////////////////////////////////////////////////
//
// QueueCallBackFunction :
//
//Return TRUE - when we want the asyncmx object to be kept around
//Return FALSE - to delete the object when the thread exits
//

BOOL QueueCallBackFunction(PVOID ThisPtr, BOOLEAN fTimedOut)
{
    CAsyncMx * ThisQueue = (CAsyncMx *) ThisPtr;
    REMOTE_QUEUE * pRemoteQ = NULL;
    BOOL fSuccessfullConnect = TRUE;
    BOOL fAtqConnect = TRUE;
    char * NextMxPtr = NULL;
    SMTPDNS_RECS * pDnsRec = NULL;
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD = NULL;
    char szSmartHost[MAX_PATH + 1];
    char Scratch[256];
    DWORD Error = 0;
    DWORD dwFailedConnectionStatus = CONNECTION_STATUS_FAILED;
    int NumRecords = 0;
    DWORD IpAddress = 0;

    TraceFunctEnterEx((LPARAM) ThisQueue, "QueueCallBackFunction");

    Scratch[0] = '\0';

    if(ThisQueue->GetParentInst()->IsShuttingDown())
    {
        //takes care of the case where we are shutting down, but
        //a successful connection came in at the same time
        ThisQueue->SetCloseSocketFlag(TRUE);
        ThisQueue->CloseAsyncSocket();
        ThisQueue->AckMessage();
        pRemoteQ = (REMOTE_QUEUE *) ThisQueue->GetParentInst()->QueryRemoteQObj();
        _ASSERT(pRemoteQ != NULL);
        pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj());
        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return FALSE;
    }

    if (!ThisQueue->GetDnsRec())
    {
        //See bug X5:120720 - This means that another thread has called back
        //on this object.  The call to OnConnect below will AV.  We do not 
        //have a repro scenario for this, and see if only once every few
        //months.  MilanS has recommended this non-intrusive check to
        //add additional protection against a double callback
        _ASSERT(0 && "Multiple threads calling back on CAsyncMx");

        //Return TRUE because first thread will handle deleting object
        return TRUE;
    }

    //get a pointer to the remote queue
    pRemoteQ = (REMOTE_QUEUE *) ThisQueue->GetParentInst()->QueryRemoteQObj();
    _ASSERT(pRemoteQ != NULL);

    IpAddress = ThisQueue->GetConnectedIpAddress();
    InetNtoa(*(struct in_addr *) &IpAddress, Scratch);

    //See if the connect was successful
    fSuccessfullConnect = ThisQueue->AsyncConnectSuccessfull();

    //Call record the state of this connection
    ThisQueue->OnConnect(fSuccessfullConnect);

    //Test the connect value
    if(fSuccessfullConnect)
    {
        DebugTrace((LPARAM)ThisQueue, "QueueCallBack called with successful connect!");

        pDnsRec = ThisQueue->GetDnsRec();
        pDNS_RESOLVER_RECORD = ThisQueue->GetDnsResolverRecord();
        ThisQueue->SetDnsRecToNull();
        ThisQueue->SetDnsResolverRecord(NULL);


        fAtqConnect = pRemoteQ->MakeATQConnection( pDnsRec,
                                                   ThisQueue->GetSockethandle(),
                                                   ThisQueue->GetConnectedIpAddress(),
                                                   ThisQueue->GetSmtpConnectionObj(),
                                                   ThisQueue->GetDomainOptions(),
                                                   ThisQueue->GetSSLVerificationName(),
                                                   pDNS_RESOLVER_RECORD);
        if(!fAtqConnect)
        {
            ErrorTrace((LPARAM)ThisQueue, "FAILED pRemoteQ->MakeATQConnection!!!");

            ThisQueue->AckMessage();
            
            if (ThisQueue->WasLoopback())
                dwFailedConnectionStatus = CONNECTION_STATUS_FAILED_LOOPBACK;
            
            pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj(),
                                             dwFailedConnectionStatus,
                                             ThisQueue->GetConnectedIpAddress());
        }

        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return FALSE;

    } else if (ThisQueue->WasLoopback()) {

        dwFailedConnectionStatus = CONNECTION_STATUS_FAILED_LOOPBACK;
        ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_LOOPBACK_DETECTED, NULL, NULL);

        //
        //  Make sure we have the IP address for diagnostic purposes
        //
        pRemoteQ->ReportConnectedIPAddress(ThisQueue->GetSmtpConnectionObj(), 
                                 ThisQueue->GetConnectedIpAddress());
    }

    ErrorTrace((LPARAM)ThisPtr,"connection to %s failed", Scratch);

    BUMP_COUNTER (ThisQueue->GetParentInst(), NumConnOutRefused);   

    IpAddress = ThisQueue->GetNextIpAddress();

    //
    //  A connect will cause QueueCallBack to be called again through a 
    //  completion event posted on FD_CONNECT. On each call to ConnectToHost 
    //  we try a new IP address till all the IP addresses for this MX host 
    //  are exhausted.
    //
    if((IpAddress != INADDR_NONE) && ThisQueue->ConnectToHost(IpAddress))
    {
        DebugTrace((LPARAM)ThisQueue, "Connecting to MX host: %08x", IpAddress);
        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return TRUE;
    }

    ThisQueue->CloseAsyncSocket();

    DebugTrace((LPARAM) ThisQueue, "Ran out of IP addresses for MX host");
    //
    //  If we failed to connect to any of the IP addresses for the (current)
    //  MX host, try connecting to the next MX host for this destination.
    //
    while(!ThisQueue->GetParentInst()->IsShuttingDown())
    {
        if(ThisQueue->ConnectToNextMxHost())
        {
            DebugTrace((LPARAM)ThisQueue, "Trying ConnectToNextMxHost");
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
        else
        {
            Error = GetLastError();
            ThisQueue->CloseAsyncSocket();
            if(Error == ERROR_NO_MORE_ITEMS)
            {
                DebugTrace((LPARAM)ThisQueue, "Failed ConnectToNextMxHost with ERROR_NO_MORE_ITEMS");
            }
            else
            {
                ErrorTrace((LPARAM)ThisQueue, "Failed ConnectToNextMxHost: Host not responding");
                ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_HOST_NOT_RESPONDING, NULL, NULL);
            }
            break;
        }
    }

    ThisQueue->CloseAsyncSocket();
    DebugTrace((LPARAM)ThisQueue, "Ran out of MX hosts for destination. Trying new destination.");

    //
    //  If we failed to connect to any MX host for the destination server
    //  we need to try an alternate destination. ConnectToNextResolverHost
    //  uses the DNS_RESOLVER_RECORD (member of CAsyncMx *ThisQueue) to get
    //  the name of an alternative host and resolve it (get the MX records
    //  for it).
    //
    while(!ThisQueue->GetParentInst()->IsShuttingDown())
    {
        if(pRemoteQ->ConnectToNextResolverHost( ThisQueue ))
        {
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
        else
        {
            Error = GetLastError();
            ThisQueue->CloseAsyncSocket();
            if(Error == ERROR_NO_MORE_ITEMS)
            {
                DebugTrace((LPARAM)ThisQueue, "Failed ConnectToNextResolverHost : ERROR_NO_MORE_ITEMS");
            }
            else
            {
                ErrorTrace((LPARAM)ThisQueue, "Failed ConnectToNextResolverHost. Error = %08x", Error);
                ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_DNS_FAILURE, NULL, NULL);
            }
            break;
        }
    }

    ThisQueue->CloseAsyncSocket();
        

    

    //So we have tried all we could for the real destination
    //check  if we have a fallback smarthost and that we have not already tried it
    if( pRemoteQ->GetParentInst()->UseSmartHostAfterFail() &&
        pRemoteQ->GetParentInst()->GetSmartHost(szSmartHost) &&
        !ThisQueue->GetTriedOnFailHost())
    {

        if(pRemoteQ->StartAsyncConnect(szSmartHost, ThisQueue->GetSmtpConnectionObj(), ThisQueue->GetDomainOptions(), FALSE))
        {
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
    }

    ThisQueue->AckMessage();

    pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj(), 
                                     dwFailedConnectionStatus,
                                     ThisQueue->GetConnectedIpAddress());
    
    TraceFunctLeaveEx((LPARAM) ThisPtr);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromHostFile(const char * HostName)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 
    struct hostent *hp = NULL;
    BOOL    fRet = TRUE;
    DWORD   Error = 0;

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromHostFile");

    DebugTrace((LPARAM)NULL,"Using gethostbyname for hostname resolution - %s", HostName);

    hp = gethostbyname (HostName);
    if(hp == NULL)
    {
        Error = WSAGetLastError();
        ErrorTrace((LPARAM)NULL,"struct hostent *hp is NULL for %s - %x", HostName, Error);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"pDnsRec = new SMTPDNS_RECS failed for %s", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 0;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));

    for (DWORD Loop = 0; (hp->h_addr_list[Loop] != NULL); Loop++)
    {
        pEntry = new MXIPLIST_ENTRY;
        if(pEntry != NULL)
        {
            pDnsRec->DnsArray[0]->NumEntries++;
            CopyMemory(&pEntry->IpAddress, hp->h_addr_list[Loop], 4);
            InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);
        }
        else
        {
            ErrorTrace((LPARAM)NULL,"new MXIPLIST_ENTRY failed for %s", HostName);
            fRet = FALSE;
            break;
        }
    }

    if(fRet)
    {
        return pDnsRec;
    }
    else
    {
        DeleteDnsRec(pDnsRec);
        pDnsRec = NULL;
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromLiteral(const char * HostName)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 
    BOOL    fRet = TRUE;
    DWORD   Error = 0;
    unsigned long InetAddr = 0;
    char * pEndIp = NULL;
    char * pRealHost = NULL;
    char OldChar = '\0';

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromLiteral");

    pRealHost = (char *) HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
        pEndIp = strchr(pRealHost, ']');
        if(pEndIp == NULL)
        {
            ErrorTrace((LPARAM)NULL,"Didn't find ] in literal for %s", HostName);
            TraceFunctLeaveEx((LPARAM) NULL);
            return NULL;
        }

        //save the old character
        OldChar = *pEndIp;

        //null terminate the string
        *pEndIp = '\0';
        pRealHost++;

        //Is this an ip address
        InetAddr = inet_addr( (char *) pRealHost );
    }

    //put back the old character
    if (pEndIp)
        *pEndIp = OldChar;

    if((InetAddr == INADDR_NONE) || (InetAddr == 0))
    {
        ErrorTrace((LPARAM)NULL,"InetAddr is invalid for %s", HostName);
        return NULL;
    }

    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new SMTPDNS_RECS2 failed for", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES2 failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pEntry = new MXIPLIST_ENTRY;
    if(pEntry == NULL)
    {
        ErrorTrace((LPARAM)NULL,"MXIPLIST_ENTRY2 failed for %s", HostName);
        DeleteDnsRec(pDnsRec);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 1;

    pEntry->IpAddress = InetAddr;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));
    InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromResolverInfo(const char * HostName, DWORD dwAddr)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromResolverInfo");


    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new SMTPDNS_RECS2 failed for", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES2 failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pEntry = new MXIPLIST_ENTRY;
    if(pEntry == NULL)
    {
        ErrorTrace((LPARAM)NULL,"MXIPLIST_ENTRY2 failed for %s", HostName);
        DeleteDnsRec(pDnsRec);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 1;

    pEntry->IpAddress = dwAddr;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));
    InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

//-----------------------------------------------------------------------------
//  Decription:
//      This function is called when we have exhausted all the MX hosts for a
//      particular destination server. The only option is to see if there are 
//      any alternative destinations to which the mail may be forwarded. A list
//      of alternative hosts is maintained in the DNS resolver record (if it is
//      available. So we need to kick off a resolve for the next alternate host
//      if it exists.
//  Arguments:
//  Returns:
//  History:
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::ConnectToNextResolverHost( CAsyncMx    * pThisQ )
{
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD;
    BOOL fRet;

    //  We embedded the resolver record into the MX records object
    pDNS_RESOLVER_RECORD = pThisQ->GetDnsResolverRecord();

    // We will handle deletion of pDNS_RESOLVER_RECORD from now on
    pThisQ->SetDnsResolverRecord(NULL);

    //  No alternate hosts.
    if(pDNS_RESOLVER_RECORD == NULL || pDNS_RESOLVER_RECORD->GetDnsResolverRecord() == NULL)
    {
        if(pDNS_RESOLVER_RECORD)
            delete pDNS_RESOLVER_RECORD;

        return( FALSE );
    }

    char              MyFQDNName[MAX_PATH + 1];

    GetParentInst()->LockGenCrit();
    lstrcpyn(MyFQDNName,GetParentInst()->GetFQDomainName(),MAX_PATH);
    GetParentInst()->UnLockGenCrit();

    CrashOnInvalidSMTPConn(pThisQ->GetSmtpConnectionObj());

    fRet = ConnectToResolverHost( pThisQ->GetSSLVerificationName(), 
                                  MyFQDNName, 
                                  pThisQ->GetSmtpConnectionObj(), 
                                  pThisQ->GetDomainOptions(), 
                                  FALSE,
                                  pDNS_RESOLVER_RECORD,
                                  pThisQ->GetDnsRec() );
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Basically this function tries to resolve one of the hosts in the DNS
//      resolver record (supplied by the sink) so that SMTP can send to that.
//      To do this it is called repeatedly, and each time around it tries a
//      different host till it succeeds in resolving it. If no DNS resolver
//      record is available (NULL) we try to resolve the HostName directly.
//      If DNS resolution is not needed --- ie if the resolution information
//      is available locally or from the resolver record, then this function
//      will kick off an async connect to the first MX host.
//  Arguments:
//      [IN] const char * HostName   - Hostname to resolve
//      [IN] LPSTR MyFQDNName        -
//      [IN] ISMTPConnection *pISMTPConnection -
//      [IN] DWORD DomainOptions     - Bitmask of options
//      [IN] BOOL fUseSmartHostAfterFail -
//      [IN] DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD - This object must always
//              be associated with the current remote queue, till we succeed in
//              connecting to the remote SMTP server. If this function fails,
//              the DNS_RESOLVER_RECORD will be deleted. The caller no longer
//              has responsibility for this after calling this function.
//      [IN] PSMTP_DNSRECS pDnsRec - This is NULL unless the call to Connect...
//          is a "failover call". It encapsulates the parameters for the failed
//          message in such a case. These parameters are copied when an async
//          connection/DNS-query are kicked off and will be acked by the async
//          connect/DNS-query code. If this function succeeds, these parameters
//          should not be acked by the caller and they are set to NULL by this
//          function, within the pDnsRetryRec.
//  Returns:
//      TRUE on success.
//      FALSE on all errors.
//  History:
//      GPulla modified.
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::ConnectToResolverHost( const char * HostName,
                                          LPSTR MyFQDNName,
                                          ISMTPConnection *pISMTPConnection,
                                          DWORD DomainOptions,
                                          BOOL fUseSmartHostAfterFail,
                                          DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
                                          PSMTPDNS_RECS pDnsRetryRec )
{
    DWORD             dwAddr = 0;
    PSMTPDNS_RECS     pDnsRec = NULL;
    BOOL              fRet = FALSE;
    BOOL              fUseDns = TRUE;
    BOOL              fIsLiteral = FALSE;
    DWORD             dwDnsFlags = 0;
    LPSTR             pszRealHostName = NULL;
    BOOL              fFreeHostName = FALSE;
    HRESULT           hr = S_OK;
    LPSTR             pszSSLVerificationName = NULL;
    BOOL              fSSLSubjectDisabled = FALSE;

    TraceFunctEnterEx((LPARAM)this, "ConnectToResolverHost (const char * HostName)");

    DebugTrace((LPARAM) this,"Finding MX records for %s with options %x", HostName, DomainOptions);

    if (HostName)
    {
        fIsLiteral = (HostName[0] == '[');
    }

    if(GetParentInst()->UseGetHostByName() || fIsLiteral)
    {
        fUseDns = FALSE;

        DebugTrace((LPARAM) this,"Not using DNS for resolution - literal, or GHBN");
    }
    else if(g_TcpRegIpList.GetCount() == 0)
    {
        fUseDns = FALSE;

        DebugTrace((LPARAM) this,"Not using DNS for resolution - No DNS servers");
    }

    if (!(DomainOptions | MUST_DO_TLS) || !GetParentInst()->RequiresSSLCertVerifySubject())
        fSSLSubjectDisabled = TRUE;

    dwDnsFlags = GetParentInst()->GetDnsFlags();

    pszRealHostName = (LPSTR)HostName;

    //
    //  If there is a DNS resolver record from the DNS sink, retrieve the (next)
    //  possible destination host from it for resolution.
    //
    if( pDNS_RESOLVER_RECORD && pDNS_RESOLVER_RECORD->GetDnsResolverRecord() )
    {
        DWORD dwAddr = 0;
        LPSTR pszTmpHostName = NULL;

        DebugTrace((LPARAM) this, "Trying to get next host from DNS resolver record");
        if( FAILED( hr = pDNS_RESOLVER_RECORD->HrGetNextDestinationHost(&pszTmpHostName, &dwAddr) ) )
        {
            if( HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) != hr )
            {
                ErrorTrace((LPARAM) this,"m_pIDnsResolverRecord->GetItem() failed hr = 0x%x failed", hr);
            }
            else
            {
                DebugTrace((LPARAM) this, "Tried all possible destination hosts. Failing ConnectToResolverHost.\n");
                SetLastError( ERROR_NO_MORE_ITEMS );
            }

            fRet = FALSE;
            goto Exit;
        }
        else
        {
            fFreeHostName = TRUE;
            pszRealHostName = pszTmpHostName;
            DebugTrace((LPARAM) this, "ConnectToResolverHost trying destination host : %s", pszRealHostName);

            if( dwAddr != 0 )
            {
                //
                // this means we don't have to call  DNS or GetHostByName to get the Ip addres
                //
            
                DebugTrace((LPARAM) this, "DNS records available, not calling DNS");
                pDnsRec = GetDnsRecordsFromResolverInfo( pszRealHostName, dwAddr );
            
                if(pDnsRec)
                {
            
                    //
                    //  This causes SMTP to successively try an connect to each of the MX hosts
                    //  for the destination host in turn till a connection succeeds. pDnsRec has
                    //  the MX hosts info.
                    //
                    DebugTrace((LPARAM) this, "Initializing async connect to MX hosts...");
                    
                    if(pDnsRetryRec)
                    {
                        pDnsRec->pMailMsgObj = pDnsRetryRec->pMailMsgObj;
                        pDnsRec->pAdvQContext = pDnsRetryRec->pAdvQContext;
                        pDnsRec->pRcptIdxList = pDnsRetryRec->pRcptIdxList;
                        pDnsRec->dwNumRcpts = pDnsRetryRec->dwNumRcpts;
                    }

                    if (fSSLSubjectDisabled) {

                        pszSSLVerificationName = NULL;

                    } else if (ERROR_SUCCESS == DnsValidateName (HostName, DnsNameDomain)) {

                        DebugTrace ((LPARAM) this, "%s is a DNS name", HostName);
                        pszSSLVerificationName = (LPSTR) HostName;

                    } else {

                        DebugTrace ((LPARAM) this, "%s is not a DNS name", HostName);
                        pszSSLVerificationName = pszTmpHostName;
                    }

                    //
                    //  if HostName is not a DNS name ---  its a special name (like a
                    //  GUID for an Exchange connector, and we need to use pszTmpHostName,
                    //  the name returned by DNS sink as the SSL verification Name.
                    //
                    //  if HostName is a DNS name --- the the DNS sink resolved it to an
                    //  IP and pszTmpHostName was obtained by DNS indirection (MX record
                    //  or CNAME record). This is insecure and cannot be used for SSL subject
                    //  verification, so we use HostName instead.
                    //
                    fRet = BeginInitializeAsyncConnect(
                                                pDnsRec,
                                                pISMTPConnection,
                                                DomainOptions,
                                                pDNS_RESOLVER_RECORD,
                                                pszSSLVerificationName);

                    pDNS_RESOLVER_RECORD = NULL; //  Passed on delete responsibillity to BeginInitializeAsyncConnect

                    if(!fRet)
                    {
                        ErrorTrace((LPARAM) this, "Failed BeginInitializeAsyncConnect.");
                        DeleteDnsRec(pDnsRec);
                    }
                }
            
                CoTaskMemFree( pszRealHostName );
                pszRealHostName = NULL;
                goto Exit;
            }
            //
            // else go thru DNS or gethostbyname to get the address
            //   
            DebugTrace((LPARAM) this, "Querying DNS");
        }

    }
    else
    {
        _ASSERT( HostName );
    }
    
    if(fUseDns)
    {
        DebugTrace((LPARAM) this, "ConnectToResolverHost querying DNS to resolve host: %s", pszRealHostName);

        if (fSSLSubjectDisabled) {
                
            pszSSLVerificationName = NULL;

        } else {

            pszSSLVerificationName = (LPSTR) pszRealHostName;
        }
        //
        //  Using DNS to resolve destination host.
        //
        fRet = BeginInitializeAsyncDnsQuery( pszRealHostName,
                                             MyFQDNName,
                                             pISMTPConnection,
                                             dwDnsFlags,
                                             DomainOptions,
                                             fUseSmartHostAfterFail,
                                             pDNS_RESOLVER_RECORD,
                                             pszSSLVerificationName,
                                             pDnsRetryRec );

        pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to BeginInitializeAsyncDnsQuery
        DebugTrace((LPARAM) this, "BeginInitializeAsyncDnsQuery returned %s", fRet ? "TRUE" : "FALSE");
    }
    else
    {
        if(!fIsLiteral)
            pDnsRec = GetDnsRecordsFromHostFile(HostName);
        else
            pDnsRec = GetDnsRecordsFromLiteral(HostName);

        if(pDnsRec)
        {
            DebugTrace((LPARAM) this, "ConnectToResolverHost resolved %s locally", pszRealHostName);

            //
            //  The target host (before DNS) to which this server is connecting to... used by SSL
            //  If this is a literal, pass in NULL, as there is no hostname
            //
            pszSSLVerificationName = NULL;


            if (fSSLSubjectDisabled) {
                    
                pszSSLVerificationName = NULL;

            } else if (fIsLiteral) {
            
                pszSSLVerificationName = NULL;
            
            } else {

                pszSSLVerificationName = (LPSTR) HostName;
            }

            if(pDnsRetryRec)
            {
                pDnsRec->pMailMsgObj = pDnsRetryRec->pMailMsgObj;
                pDnsRec->pAdvQContext = pDnsRetryRec->pAdvQContext;
                pDnsRec->pRcptIdxList = pDnsRetryRec->pRcptIdxList;
                pDnsRec->dwNumRcpts = pDnsRetryRec->dwNumRcpts;
            }

            fRet = BeginInitializeAsyncConnect(
                                            pDnsRec,
                                            pISMTPConnection,
                                            DomainOptions,
                                            pDNS_RESOLVER_RECORD,
                                            pszSSLVerificationName);

            pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to BeginInitializeAsyncConnect

            if(!fRet)
            {
                ErrorTrace((LPARAM) this, "Failed BeginInitializeAsyncConnect");
                DeleteDnsRec(pDnsRec);
            }
        }
    }

    if( fFreeHostName )
    {
        CoTaskMemFree( pszRealHostName );
    }

Exit:
    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    if(fRet && pDnsRetryRec && pDnsRetryRec->pMailMsgObj)
    {
        //
        // Defensive: make sure caller doesn't mistakenly ack a failover message
        // if this function has succeeded
        //

        pDnsRetryRec->pMailMsgObj = NULL;
        pDnsRetryRec->pAdvQContext = NULL;
        pDnsRetryRec->pRcptIdxList = NULL;
        pDnsRetryRec->dwNumRcpts = 0;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        StartAsyncConnect

    Description:

        This function either does a straight gethostbyname(),
        or performs an MX record lookup to get the hostname/ip
        address to connect to.

    Arguments:

        char * SmartHost - This is either an IP address,
        or a hostname

    Returns:
        TRUE if an Async connection was started
        FALSE otherwise

--*/
BOOL REMOTE_QUEUE::StartAsyncConnect(
    const char *HostName,
    ISMTPConnection *pISMTPConnection,
    DWORD DomainOptions,
    BOOL fUseSmartHostAfterFail )
{

    DWORD    dwVirtualServerId = 0;
    HRESULT  hr = S_OK;
    char     MyFQDNName[MAX_PATH + 1];
    BOOL     fRet;
    IDnsResolverRecord *pIDnsResolverRecord = NULL;
    IDnsStatus *pIDnsStatus = NULL;
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD = NULL;
    DNS_SERVER_INFO *pDnsServerInfo = NULL;
    CTcpRegIpList *pTcpRegIpList = NULL;

    TraceFunctEnterEx((LPARAM)this, "StartAysncConnect (const char * HostName)");

    CrashOnInvalidSMTPConn(pISMTPConnection);

    DebugTrace((LPARAM) this,"Finding MX records for %s with options %x", HostName, DomainOptions);

    GetParentInst()->LockGenCrit();
    lstrcpyn(MyFQDNName,GetParentInst()->GetFQDomainName(),MAX_PATH);
    dwVirtualServerId = GetParentInst()->QueryInstanceId();
    GetParentInst()->UnLockGenCrit();

    //
    // The DNS resolver event is fired every time we connect to a domain.
    // It enables a sink to return information that modifies how we resolve
    // or connect to the target host "HostName".
    //
    // Two pieces of information may be returned by the DNS sink:
    //
    // (1) pDnsServerInfo - Designed for use on a multihomed server which
    //     acts as a bridge relaying mail between different networks. The
    //     DNS sink determines if HostName is on a different network than
    //     the "default" network for SMTP. Target hosts in the default
    //     network are resolved using the default DNS servers on this box.
    //     The DNS sink may return an alternate set of DNS servers for hosts
    //     on a different network in pDnsServerInfo.
    //
    // (2) pIDnsResolverRecord - This is a list of <hostname, ipaddress>
    //     pairs. The DNS sink may return this to indicate that mail
    //     directed to "HostName" should instead be delivered to the
    //     hosts in pIDnsResolverRecord. If multiple records are returned
    //     in pIDnsResolverRecord we will use them for failover. The
    //     "ipaddress" portion may be missing for a given record in
    //     pIDnsResolverRecord, in which case, the "hostname" must be
    //     resolved by SMTP using the appropriate DNS servers.
    //

    GetParentInst()->TriggerDnsResolverEvent( (LPSTR)HostName, 
                                              MyFQDNName, 
                                              dwVirtualServerId, 
                                              &pDnsServerInfo,
                                              &pIDnsResolverRecord );
    
    if(pDnsServerInfo)
    {
        //
        // Since we use our connection history with a DNS server for the
        // purposes of our DNS server state tracking logic (CTcpRegIpList)
        // we must remember the serverlist returned from pDnsServerInfo
        // and tabulate the successes/failures for them. This means that
        // the list is kept stored in SMTP_SERVER_INSTANCE and we constantly
        // update the connection history as we try resolves against the
        // servers.
        //
        // Since a DNS sink may return different lists of DNS servers for
        // different networks, we need to differentiate between when the
        // serverlist is being returned for a different network and the
        // serverlist for a certain network has itself changed. For this
        // reason, pDnsServerInfo also includes a GUID that uniquely
        // identifies the network associated with the serverlist.
        //

        pTcpRegIpList = GetParentInst()->UpdateDnsServerInfo(pDnsServerInfo);
        if(!pTcpRegIpList)
        {
            ErrorTrace((LPARAM)this, "Unable to update server info");
            fRet = FALSE;
            goto Exit;
        }

        pDNS_RESOLVER_RECORD = new DNS_RESOLVER_RECORD;
        if(!pDNS_RESOLVER_RECORD)
        {
            ErrorTrace((LPARAM)this, "Out of memory creating DNS_RESOLVER_RECORD");
            goto Exit;
        }

        pDNS_RESOLVER_RECORD->SetDnsList(pTcpRegIpList);
    }

    if(pIDnsResolverRecord)
    {
        //
        // IDnsStatus is an optional interface exposed by the DNS resolver record
        // object that contains additional information if something failed in the
        // DNS resolver. If resolution fails, we use it to check if the failure is
        // authoritative, and therefore we should NDR the messages.
        //

        hr = pIDnsResolverRecord->QueryInterface(IID_IDnsStatus, (PVOID *) &pIDnsStatus);
        if(SUCCEEDED(hr))
        {
            DWORD dwAck = 0;
            DWORD dwDiagnostic = 0;

            hr = pIDnsStatus->GetDnsStatus();
            if(HRESULT_FROM_WIN32(DNS_ERROR_RCODE_NAME_ERROR) == hr)
            {
                dwDiagnostic = AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND;
                dwAck = CONNECTION_STATUS_FAILED_NDR_UNDELIVERED;
            }
            else if(FAILED(hr))
            {
                dwDiagnostic = AQUEUE_E_HOST_NOT_FOUND;
                dwAck = CONNECTION_STATUS_FAILED;
            }

            if(FAILED(hr))
            {
                pISMTPConnection->SetDiagnosticInfo(dwDiagnostic, NULL, NULL);
                pISMTPConnection->AckConnection(dwAck);
                pISMTPConnection->Release();

                fRet = TRUE;
                pIDnsStatus->Release();
                pIDnsResolverRecord->Release();
                goto Exit;
            }
            pIDnsStatus->Release();
        }
 
        DebugTrace((LPARAM) this, "DNS resolver sink returned pIDnsResolverRecord");

        if(!pDNS_RESOLVER_RECORD)
            pDNS_RESOLVER_RECORD = new DNS_RESOLVER_RECORD;

        if(!pDNS_RESOLVER_RECORD )
        {
            ErrorTrace((LPARAM) this, "Cannot allocate pDNS_RESOLVER_RECORD. Out of memory."); 
            pIDnsResolverRecord->Release();
            fRet = FALSE;
            goto Exit;
        }
        pDNS_RESOLVER_RECORD->SetDnsResolverRecord(pIDnsResolverRecord);
    }

    fRet = ConnectToResolverHost( HostName, 
                                  MyFQDNName, 
                                  pISMTPConnection, 
                                  DomainOptions, 
                                  fUseSmartHostAfterFail, 
                                  pDNS_RESOLVER_RECORD,
                                  NULL );

    pDNS_RESOLVER_RECORD = NULL;

Exit:
    if(pDNS_RESOLVER_RECORD)
        delete pDNS_RESOLVER_RECORD;

    if(pDnsServerInfo)
        CoTaskMemFree(pDnsServerInfo);

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Wrapper for DnsQueryAsync (exists only to BUMP REMOTE_QUEUE counters).
//  Arguments:
//      These are simply passed in to DnsQueryAsync... see documentation of
//      DnsQueryAsync for details.
//  Returns:
//      TRUE    if query was successfully started.
//      FALSE   on errors.
//  History:
//      GPulla modified.
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::BeginInitializeAsyncDnsQuery( LPSTR pszHostName,
                                                 LPSTR pszFQDN,
                                                 ISMTPConnection *pISMTPConnection,
                                                 DWORD dwDnsFlags,
                                                 DWORD DomainOptions,
                                                 BOOL  fUseSmartHostAfterFail,
                                                 DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
                                                 const char * pszSSLVerificationName,
                                                 PSMTPDNS_RECS pDnsRetryRec ) 
{
    BOOL fRet = FALSE;
    DWORD fUdp = TRUE;
    RETRYPARAMS retryParams;
    RETRYPARAMS *pRetryParams = NULL;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::BeginInitializeAsyncDnsQuery");

    if(dwDnsFlags & DNS_FLAGS_TCP_ONLY)
        fUdp = FALSE;

    if(pDnsRetryRec) {
        retryParams.m_pIMsg = (IMailMsgProperties *) pDnsRetryRec->pMailMsgObj;
        retryParams.m_pAdvQContext = pDnsRetryRec->pAdvQContext;
        retryParams.m_pRcptIdxList = (PDWORD) pDnsRetryRec->pRcptIdxList;
        retryParams.m_dwNumRcpts = pDnsRetryRec->dwNumRcpts;
        pRetryParams = &retryParams;
    }
        
    fRet = DnsQueryAsync(
                GetParentInst(),
                pszHostName,
                pszFQDN,
                pISMTPConnection,
                dwDnsFlags,
                DomainOptions,
                fUseSmartHostAfterFail,
                pDNS_RESOLVER_RECORD,
                pszSSLVerificationName,
                pRetryParams,
                fUdp);

    if(fRet)
        BUMP_COUNTER(GetParentInst(), NumDnsQueries);

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Kicks off an async query to DNS to resolve pszHostName (ie get the MX
//      records for it). When the query is complete, and the MX records have
//      been retrieved, the completion thread will try to connect to the MX
//      hosts by posting a callback to QueueCallBackFunction().
//  Arguments:
//      [IN] pServiceInstance - PTR to ISMTPServerInstance for this queue
//
//      [IN] pszHostName - Host we're trying to lookup (this is copied over)
//
//      [IN] pszFQDN - My FQDN (this is copied over)
//
//      [IN] pISMTPConnection - Connection to ACK, get messages from. After
//          this is passed in, this funtion will handle acking and releasing it
//          if TRUE is returned. If FALSE is returned, the pISMTPConnection
//          is not touched and the caller must ACK and release it.
//
//      [IN] dwDnsFlags - DNS configuration flags.
//
//      [IN] DomainOptions - Use SSL, Verify SSL cert, etc. Various outbound options.
//
//      [IN] fUseSmartHostAfterFail  - DUH
//
//      [IN] DNS_RESOLVER_RECORD *   - Set of possible next hop destinations
//          returned by the DNS sink (may be NULL). If we fail DNS resolution 
//          for pszHostName (which is the first next hop in pDNS_RESOLVER_RECORD),
//          the others are tried in turn. After this is passed in... this function
//          handles deleting it (irrespective of whether TRUE or FALSE is returned).
//
//      [IN] pszSSLVerificationName  - Target host which we are trying to
//          resolve/connect. Could be NULL if there isn't a target host (such as
//          in the case of a literal IP address) (this is copied over).
//
//      [IN] pRetryParams - On a failover path (i.e. if a temporary error occurred
//          while delivering to an SMTP target, we will attempt delivery to an
//          alternate host (like an alternate MX host). The failed message
//          parameters are encapsulated in this.
//
//      [IN] fUdp - Issue query over UDP or TCP?
//-----------------------------------------------------------------------------
BOOL DnsQueryAsync(
    SMTP_SERVER_INSTANCE *pServiceInstance,
    LPSTR pszHostName,
    LPSTR pszFQDN,
    ISMTPConnection *pISMTPConnection,
    DWORD dwDnsFlags,
    DWORD DomainOptions,
    BOOL  fUseSmartHostAfterFail,
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
    const char * pszSSLVerificationName,
    RETRYPARAMS *pRetryParams,
    BOOL fUdp)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL fRet = FALSE;
    CTcpRegIpList *pDnsList = &g_TcpRegIpList;
    BOOL fGlobalDnsList = TRUE;

    TraceFunctEnterEx((LPARAM)NULL, "REMOTE_QUEUE::BeginInitializeAsyncDnsQuery");

    CAsyncSmtpDns *pAsyncDns = new CAsyncSmtpDns(pServiceInstance, pISMTPConnection,
                                    pRetryParams, pszFQDN);

    if(!pAsyncDns)
    {
        DebugTrace((LPARAM) NULL, "Unable to allocate CAsyncSmtpDns object. Out of Memory");
        goto Exit;
    }

    //
    // From now on pAsyncDns will handle the deletion of pDNS_RESOLVER_RECORD and
    // the pISmtpConnection ack... initiation of the async DNS query has succeeded
    // as far as the caller is concerned.
    //
    fRet = TRUE;

    pAsyncDns->SetDnsResolverRecord(pDNS_RESOLVER_RECORD);

    //
    // If the DNS sink specified an alternate set of servers to be used, set them
    // on the async DNS object.
    //
    if(pDNS_RESOLVER_RECORD && pDNS_RESOLVER_RECORD->GetDnsList())
    {
        DebugTrace((LPARAM)NULL, "Using sink returned DNS list for %s", pszHostName);
        pDnsList = pDNS_RESOLVER_RECORD->GetDnsList();
        fGlobalDnsList = FALSE;
    }

    pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to pAsyncDns object
    pISMTPConnection = NULL; // Passed on delete responsibility to pAsyncDns object

    pAsyncDns->SetDomainOptions(DomainOptions);
    pAsyncDns->SetSmartHostOption(fUseSmartHostAfterFail);

    if (!pAsyncDns->Init((LPSTR) pszSSLVerificationName))
    {
        delete pAsyncDns;
        goto Exit;
    }

    DebugTrace((LPARAM) NULL, "Issuing DNS query for pAsyncDns = 0x%08x", pAsyncDns);
    dwStatus = pAsyncDns->Dns_QueryLib(
                                pszHostName,
                                DNS_TYPE_MX,
                                dwDnsFlags,
                                fUdp,
                                pDnsList,
                                fGlobalDnsList);

    if(dwStatus != ERROR_SUCCESS)
    {
        ErrorTrace((LPARAM)NULL, "Failed to issue DNS query for pAsyncDns = 0x%08x", pAsyncDns);
        delete pAsyncDns;
    }
    else
    {
        DebugTrace((LPARAM) NULL, "DNS query outstanding on object pAsyncDns = 0x%08x", pAsyncDns);
    }

Exit:
    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    TraceFunctLeaveEx((LPARAM)NULL);
    return( fRet );
}

//-----------------------------------------------------------------------------
//  Description:
//      This function kicks off a connection to the first of the MX hosts
//      (from pDnsRec). It calls InitializeAsyncConnect() which will call
//      back to QueueCallbackFunction() immediately.
//  Arguments:
//  Returns:
//  History:
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::BeginInitializeAsyncConnect( PSMTPDNS_RECS pDnsRec,
                                                ISMTPConnection *pISMTPConnection,
                                                DWORD DomainOptions,
                                                DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
                                                const char *pszSSLVerificationName )
{
    MXPARAMS Params;
    BOOL fRet = FALSE;
    CHAR szPostDnsSmartHost[IP_ADDRESS_STRING_LENGTH + 3];

    TraceFunctEnterEx((LPARAM)this, "REMOTE_QUEUE::BeginInitializeAsyncConnect");

    //
    // The post-DNS smart host is useful for testing DNS. It allows us
    // to exercise the DNS resolution codepath and yet send to a smarthost.
    // If a smarthost is specified, we will allocate a new TempList struct
    // and fill it in with the IP address.
    //

    if(GetParentInst()->GetPostDnsSmartHost(
           szPostDnsSmartHost, sizeof(szPostDnsSmartHost)))

    {
        DeleteDnsRec(pDnsRec);

        // Note: Literal IP must be enclosed in brackets: []
        pDnsRec = GetDnsRecordsFromLiteral(szPostDnsSmartHost);
        if(!pDnsRec)
        {
            ErrorTrace((LPARAM) this, "Can't convert %s to IP", szPostDnsSmartHost);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    Params.HostName = pDnsRec->DnsArray[0]->DnsName;
    Params.PortNum = GetParentInst()->GetRemoteSmtpPort();
    Params.TimeOut = INFINITE;
    Params.CallBack = QueueCallBackFunction;
    Params.pISMTPConnection = pISMTPConnection;
    Params.pInstance = GetParentInst();
    Params.pDnsRec = pDnsRec;
    Params.pDNS_RESOLVER_RECORD = pDNS_RESOLVER_RECORD;

    CrashOnInvalidSMTPConn(pISMTPConnection);

    CAsyncMx* pAsyncIo = new CAsyncMx (&Params);

    if(pAsyncIo)
    { 
        pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to pAsyncIo
        pAsyncIo->SetDomainOptions(DomainOptions);

        if(!pAsyncIo->Init((LPSTR) pszSSLVerificationName))
        {
            delete pAsyncIo;
        }
        else if(!pAsyncIo->InitializeAsyncConnect())
        {
            delete pAsyncIo;
            fRet = FALSE;
        }
        else
        {
            fRet = TRUE;
        }
    }
    else
    {
        fRet = FALSE;
    }

    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::ReStartAsyncConnections(
    SMTPDNS_RECS    * pDnsRec,
    ISMTPConnection * pISMTPConnection,
    DWORD             DomainOptions,
    LPSTR             pszSSLVerificationName,
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD )
{
    CAsyncMx * pAsyncIo = NULL;
    MXPARAMS Params;
    BOOL fRet = FALSE;
    char szMyFQDNName[MAX_PATH + 1];

    TraceFunctEnterEx((LPARAM)this, "ReStartAsyncConnections");

    //
    // If we're out of MX records to connect to, check to see if there are
    // alternate hosts (returned by the DNS sink in pDNS_RESOLVER_RECORD)
    // Kick off a DNS resolve/connect to the next alternate host.
    //

    if(pDnsRec->StartRecord >= pDnsRec->NumRecords)
    {
        _ASSERT(pDNS_RESOLVER_RECORD && pDNS_RESOLVER_RECORD->GetDnsResolverRecord()
                    && "Need more MX info or alternate hosts from DNS sink");

        GetParentInst()->LockGenCrit();
        lstrcpyn(szMyFQDNName,GetParentInst()->GetFQDomainName(),MAX_PATH);
        GetParentInst()->UnLockGenCrit();

        fRet = ConnectToResolverHost(
                    pszSSLVerificationName,
                    szMyFQDNName,
                    pISMTPConnection,
                    DomainOptions,
                    GetParentInst()->UseSmartHostAfterFail(),
                    pDNS_RESOLVER_RECORD,
                    pDnsRec);

        if(!fRet)
            ErrorTrace((LPARAM) this, "Failed connect to DNS sink returned host");

        pDNS_RESOLVER_RECORD = NULL;

        if(pDnsRec)
            DeleteDnsRec(pDnsRec);

        goto Exit;
    }

    //
    // Connect to the next MX record in pDnsRec
    //
    Params.HostName = pDnsRec->DnsArray[pDnsRec->StartRecord]->DnsName;
    Params.PortNum = GetParentInst()->GetRemoteSmtpPort();
    Params.TimeOut = INFINITE;
    Params.CallBack = QueueCallBackFunction;
    Params.pISMTPConnection = pISMTPConnection;
    Params.pInstance = GetParentInst();
    Params.pDnsRec = pDnsRec;
    Params.pDNS_RESOLVER_RECORD = pDNS_RESOLVER_RECORD;

    pAsyncIo = new CAsyncMx (&Params);
    if(pAsyncIo)
    {
        pDNS_RESOLVER_RECORD = NULL;  // Passed on delete responsibility to pAsyncIo
        if (!pAsyncIo->Init(pszSSLVerificationName))
        {
            ErrorTrace ((LPARAM) this, "pAsyncIo->Init() failed");
            delete pAsyncIo;
            goto Exit;
        }

        pAsyncIo->SetDomainOptions(DomainOptions);

        if(!pAsyncIo->InitializeAsyncConnect())
        {
            ErrorTrace((LPARAM) this,"pAsyncIo->InitializeAsyncConnect()for %s failed", Params.HostName);
            delete pAsyncIo;
        }
        else
        {
            fRet = TRUE;
        }
    }
Exit:
    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::MakeATQConnection(
    SMTPDNS_RECS*    pDnsRec,
    SOCKET           Socket,
    DWORD            IpAddress,
    ISMTPConnection* pISMTPConnection,
    DWORD            Options,
    LPSTR            pszSSLVerificationName,
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD)
{
    sockaddr_in AddrRemote;
    SMTP_CONNOUT * SmtpConn = NULL;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::MakeATQConnection");

    _ASSERT (Socket != INVALID_SOCKET);
    _ASSERT (GetParentInst() != NULL);
    //_ASSERT (IpAddress != 0);

    if(IpAddress == 0)
    {
        if(Socket != INVALID_SOCKET)
            closesocket(Socket);

        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;   
    }

    //set the remote IP address we connected to
    AddrRemote.sin_addr.s_addr = IpAddress;

    //create an outbound connection
    SmtpConn = SMTP_CONNOUT::CreateSmtpConnection(
                                        GetParentInst(),
                                        Socket,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        NULL,
                                        NULL,
                                        0,
                                        Options,
                                        pszSSLVerificationName,
                                        pDNS_RESOLVER_RECORD);
    if(SmtpConn == NULL)
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        closesocket(Socket);
        DeleteDnsRec(pDnsRec);
        delete pDNS_RESOLVER_RECORD;
        FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed, error =%i", Error);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    SmtpConn->SetDnsRec(pDnsRec);

    DebugTrace((LPARAM) this, "alloced SMTPOUT pointer %X", SmtpConn);

    //add this connection object to the ATQ infrastructure
    if(!SmtpConn->AddToAtqHandles((HANDLE)Socket, NULL, GetParentInst()->GetRemoteTimeOut(), InternetCompletion))
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        closesocket(Socket);
        FatalTrace((LPARAM) this, "SmtpConn->AddToAtqHandles failed, error =%d", Error);
        SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError(Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //insert the outbound connection object into
    //our list of outbound conection objects
    if(!GetParentInst()->InsertNewOutboundConnection(SmtpConn))
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        FatalTrace((LPARAM) this, "GetParentInst()->InsertNewOutboundConnection failed, error =%d", Error);
        SmtpConn->DisconnectClient();
        SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError(Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    SmtpConn->SetCurrentObject(pISMTPConnection);

    //start session will pend a read to pick
    //up the servers signon banner
    if(!SmtpConn->StartSession())
    {
        //get the error
        Error = GetLastError();

        //SmtpConn->SetCurrentObjectToNull();
        FatalTrace((LPARAM) this, "SmtpConn->StartSession failed, error =%d", Error);
        SmtpConn->DisconnectClient();
        GetParentInst()->RemoveOutboundConnection(SmtpConn);

        //An empty queue at this point is really not an error
        if (ERROR_EMPTY == Error)
            SmtpConn->SetConnectionStatus(CONNECTION_STATUS_OK);
        else
            SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);

        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError (Error);
        
        //TraceFunctLeaveEx((LPARAM) this);
        //return FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
#define PRIVATE_OPTIMAL_BUFFER_SIZE             64 * 1024
#define PRIVATE_LINE_BUFFER_SIZE                1024
///////////////////////////////////////////////////////////////////////////
static BOOL CopyMessage(PFIO_CONTEXT hSrcFile, HANDLE hDstFile, HANDLE dwEventHandle)
{
    CHAR    acBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    DWORD   dwBytesRead;
    DWORD   dwBytesWritten;
    DWORD   dwTotalBytes = 0;

    CHAR    acCrLfDotCrLf[5] = { '\r', '\n', '.', '\r', '\n' };
    CHAR    acLastBytes[5] = { '\0', '\0', '\0', '\0', '\0' };

    FH_OVERLAPPED   Ov;
    BOOL fResult = TRUE;
    DWORD err = 0;

    ZeroMemory (&Ov, sizeof(Ov));
    Ov.hEvent = (HANDLE) ((ULONG_PTR) dwEventHandle | 1);

    // Copies from the current file pointer to the end of hSrcFile 
    // and appends to the current file pointer of hDstFile.
    _ASSERT(hSrcFile != NULL);
    _ASSERT(hDstFile != INVALID_HANDLE_VALUE);

    do 
    {
        fResult = FIOReadFile(hSrcFile, acBuffer, 
                        PRIVATE_OPTIMAL_BUFFER_SIZE,
                        &Ov);

        // if this returned TRUE then we want to go down the path which calls
        // GetOverlappedResult just so that we can get dwBytesRead.
        if (fResult) err = ERROR_IO_PENDING;
        else err = GetLastError();

        if(err == ERROR_IO_PENDING)
        {
            if(GetOverlappedResult(dwEventHandle, (OVERLAPPED *) &Ov, &dwBytesRead, INFINITE))
            {
                Ov.Offset += dwBytesRead;
                ResetEvent(dwEventHandle);
            }
            else
            {
                return FALSE;
            }
        } else {
            //SmtpLogEventEx(SMTP_EVENT_CANNOT_WRITE_FILE, MailF
            SetLastError (err); //preserve the last error
            if(err == ERROR_HANDLE_EOF)
                return TRUE;
            else
                return FALSE;
        }

        if (dwBytesRead)
        {
            if (!WriteFile(hDstFile, acBuffer, 
                            dwBytesRead,
                            &dwBytesWritten,
                            NULL))
                return(FALSE);

            // See if read equals written
            if (dwBytesRead != dwBytesWritten)
                return(FALSE);
        }
        else
        {
            dwBytesWritten = 0;
        }

        if (dwBytesWritten)
        {
            dwTotalBytes += dwBytesWritten;

            // Save the last two bytes ever written
            if (dwBytesWritten > 4)
            {
                CopyMemory(acLastBytes, &acBuffer[dwBytesWritten-5], 5);
            }
            else
            {
                MoveMemory(acLastBytes, &acLastBytes[dwBytesWritten], 5-dwBytesWritten);
                CopyMemory(&acLastBytes[5-dwBytesWritten], acBuffer, dwBytesWritten);
            }
        }

    } while (dwBytesRead);

    // Now, see if the file ends with a CRLF, if not, add it
    if ((dwTotalBytes > 1) && memcmp(&acLastBytes[3], &acCrLfDotCrLf[3], 2))
    {
        // Add the trailing CRLF        
        if (!WriteFile(hDstFile, acCrLfDotCrLf, 
                        2,
                        &dwBytesWritten,
                        NULL))
        {
            return(FALSE);
        }

        if (dwBytesWritten != 2)
        {
            return(FALSE);
        }

        dwTotalBytes+=2;

    }

    //If file ends with CRLF.CRLF, remove the trailing CRLF.CRLF
    //R.P - On 1/12/98 we decided to remove the CRLF.CRLF because
    //of a bug/feature in IMAP.  POP3 will add the CRLF.CRLF when
    //retrieving the mail.
    if ((dwTotalBytes > 4) && !memcmp(acLastBytes, acCrLfDotCrLf, 5))
    {
        // Remove the trailing CRLF.CRLF
        if ((SetFilePointer(hDstFile, -5, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile))
        {
            return(FALSE);
        }
    }
    else
    {
        // Remove the trailing CRLF
        if ((SetFilePointer(hDstFile, -2, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile))
        {
            return(FALSE);
        }

    }

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////
BOOL CreateXHeaders(
    IMailMsgProperties *pIMsg,
    IMailMsgRecipients *pIMsgRecips ,
    DWORD cRcpts,
    DWORD *rgRcptIndex,
    HANDLE hDrop)
{
    TraceFunctEnter("CreateXHeaders");

    #define X_SENDER_HEADER     "x-sender: "
    #define X_RECEIVER_HEADER   "x-receiver: "
    #define X_HEADER_EOLN       "\r\n"

    #define MAX_HEADER_SIZE     (sizeof(X_RECEIVER_HEADER))

    BOOL fRet = FALSE;
    HRESULT hr;
    DWORD i, cBytes;
    BOOL fContinue = TRUE;
    char szBuffer[
            MAX_HEADER_SIZE +
            MAX_INTERNET_NAME +
            1 + 2 + 1]; // Closing ">", CRLF, and NULL

    strcpy( szBuffer, X_SENDER_HEADER );

    hr = pIMsg->GetStringA(
            IMMPID_MP_SENDER_ADDRESS_SMTP,
            MAX_INTERNET_NAME,
            &szBuffer[ sizeof(X_SENDER_HEADER) - 1] );

    if(SUCCEEDED(hr))
    {
        strcat(szBuffer, X_HEADER_EOLN);

        if (!WriteFile(hDrop, szBuffer, strlen(szBuffer), &cBytes, NULL) ) {

            ErrorTrace(0, "Error %d writing x-sender line %s",
                GetLastError(), szBuffer);

            goto Cleanup;

        } else {

            _ASSERT( cBytes == strlen(szBuffer) );

        }

    } else {

        DebugTrace(0, "Could not get Sender Address %x", hr);

        SetLastError( ERROR_INVALID_DATA );

        goto Cleanup;

    }

    strcpy( szBuffer, X_RECEIVER_HEADER );


    
    
    for (i = 0; i < cRcpts && fContinue; i++)
    {
    
        DWORD dwRecipientFlags = 0;
        hr = pIMsgRecips->GetDWORD(rgRcptIndex[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
        if( SUCCEEDED( hr ) )
        {
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
    
                hr = pIMsgRecips->GetStringA(
                        rgRcptIndex[i],
                        IMMPID_RP_ADDRESS_SMTP,
                        MAX_INTERNET_NAME,
                        &szBuffer[ sizeof(X_RECEIVER_HEADER) - 1 ]);
    
                if (SUCCEEDED(hr)) {
                    
                    strcat(szBuffer, X_HEADER_EOLN);
    
                    if (!WriteFile(hDrop, szBuffer, strlen(szBuffer), &cBytes, NULL)) {
    
                        ErrorTrace(0, "Error %d writing recipient x-header %s",
                            GetLastError(), szBuffer);
    
                        fContinue = FALSE;
    
                    }
    
                }
                else
                {
                    SetLastError( ERROR_INVALID_DATA );
                    fContinue = FALSE;
                }
            }
        }
    
    }

    // If we got all recipients without error, we were successful

    if (i == cRcpts)
        fRet = TRUE;

                

Cleanup:

    TraceFunctLeave();

    return( fRet );

}

///////////////////////////////////////////////////////////////////////////
HANDLE REMOTE_QUEUE::CreateDropFile(const char * DropDir, char * szDropFile)
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    DWORD           dwStrLen;
    FILETIME        ftTime;
    DWORD           Error = 0;

    TraceFunctEnterEx((LPARAM)this, "REMOTE_QUEUE::CreateDropFile");

    dwStrLen = lstrlen(DropDir);
    lstrcpy(szDropFile, DropDir); 

    do
    {
        GetSystemTimeAsFileTime(&ftTime);
        wsprintf(&szDropFile[dwStrLen],
                "%08x%08x%08x%s",
                ftTime.dwLowDateTime,
                ftTime.dwHighDateTime,
                InterlockedIncrement((PLONG)&g_dwFileCounter),
                ".eml");

        FileHandle = CreateFile(szDropFile, GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                 NULL);
        if (FileHandle != INVALID_HANDLE_VALUE)
                break;

        if((Error = GetLastError()) !=  ERROR_FILE_EXISTS)
        {
                TraceFunctLeaveEx((LPARAM)this);
                return(INVALID_HANDLE_VALUE);
        }

    } while( (FileHandle == INVALID_HANDLE_VALUE) && !GetParentInst()->IsShuttingDown());

    return FileHandle;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        CopyMailToDropDir()

    Description:

        This function copies a spooled file to the drop directory
        The drop file will be of the same name as the spooled file.
        This funciton translates the sender and recipient informaiton
        from the mail envelope into x-headers in the drop file.
        Both the message file and the stream file are assumed to be 
        opened upstream.

    Arguments:

        PMAIL_ENTRY lpMailEntry - Queue entry of the spooled file

    Returns:
      
      TRUE if the message was written successfully to the drop dir.
      FALSE in all other cases.  

--*/
BOOL REMOTE_QUEUE::CopyMailToDropDir(ISMTPConnection    *pISMTPConnection, const char * DropDirectory)
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwBytesWritten = 0;
    DWORD           NumRcpts = 0;
    HANDLE          hDrop   = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT    hMail   = NULL;
    HRESULT         hr = S_OK;
    PVOID           AdvContext = NULL;
    DWORD          *RcptIndexList = NULL;
    IMailMsgProperties          * pIMsg = NULL;
    IMailMsgBind * pBindInterface = NULL;
    BOOL            fRet = FALSE;
    MessageAck      MsgAck;
    HANDLE          hFileReadEvent = NULL;
    IMailMsgRecipients *pIMsgRecips = NULL;
    char szDropFile[MAX_PATH +1];

    TraceFunctEnterEx(NULL, "CopyMailToDropDir");

    hFileReadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(hFileReadEvent == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed for FileWriteFileEvent");
        goto ErrorExit;
    }

    while (!GetParentInst()->IsShuttingDown())
    {

        pBindInterface = NULL;
        AdvContext = NULL;
        RcptIndexList = NULL;
        pIMsg = NULL;

        fRet = FALSE;

        hr = pISMTPConnection->GetNextMessage(&pIMsg, (DWORD **)&AdvContext, &NumRcpts, &RcptIndexList);
        if(FAILED(hr))
        {
            fRet = TRUE;
            break;
        }

        if( NumRcpts == 0 )
        {
            fRet = TRUE;
            goto ErrorExit;
        }

        hr = pIMsg->QueryInterface( IID_IMailMsgRecipients, (PVOID *) &pIMsgRecips);
        if( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        if( CheckIfAllRcptsHandled( pIMsgRecips, RcptIndexList, NumRcpts ) )
        {
            fRet = TRUE;
            goto ErrorExit;
        }
            

        hr = pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&pBindInterface);
        if(FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = pBindInterface->GetBinding(&hMail, NULL);
        if(FAILED(hr))
        {
            goto ErrorExit;
        }

        DebugTrace((LPARAM)NULL, "Dropping file to: %s", DropDirectory);

        hDrop = CreateDropFile(DropDirectory, szDropFile);
        if (hDrop == INVALID_HANDLE_VALUE)
        {
            dwError = GetLastError();
            ErrorTrace(NULL, "Unable to create drop directory (%s) : %u", 
                    DropDirectory,
                    dwError);
            SetLastError(dwError);
            goto ErrorExit;
        }

        // Output the x-headers

        if (!CreateXHeaders(pIMsg, pIMsgRecips, NumRcpts, RcptIndexList, hDrop)) {
            dwError = GetLastError();
            ErrorTrace(NULL, "Error %d while creating x-headers", dwError);
            goto ErrorExit;
        }

        ResetEvent(hFileReadEvent);

        // Copy the mail file over
        if (!CopyMessage(hMail, hDrop, hFileReadEvent))
        {
            dwError = GetLastError();
            ErrorTrace(NULL, "Unable to copy mail file into drop directory : %u", 
                    dwError);
            goto ErrorExit;
        }


        if( FAILED( hr = SetAllRcptsHandled( pIMsgRecips, RcptIndexList, NumRcpts ) ) )
        {
            goto ErrorExit;
        }

        fRet = TRUE;

ErrorExit:

        if( pIMsgRecips )
        {
            pIMsgRecips->Release();
            pIMsgRecips = NULL;
        }
        if(pBindInterface)
        {
            pBindInterface->ReleaseContext();
            pBindInterface->Release();
            pBindInterface = NULL;
        }

        MsgAck.pIMailMsgProperties = pIMsg;
        MsgAck.pvMsgContext = (DWORD *) AdvContext;

        if(fRet)
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
        }
        else
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;      
        }

        MsgAck.dwStatusCode = 0;
        pISMTPConnection->AckMessage(&MsgAck);
        pIMsg->Release();
        pIMsg = NULL;

        if(hDrop != INVALID_HANDLE_VALUE)
        {
            _VERIFY(CloseHandle(hDrop));
            hDrop = INVALID_HANDLE_VALUE;
        }

        if(fRet)
            BUMP_COUNTER(GetParentInst(), DirectoryDrops);

    }

    if(fRet)
    {
        pISMTPConnection->AckConnection(CONNECTION_STATUS_OK);
    }
    else
    {
        DeleteFile(szDropFile);
        SetLastError(dwError);
        pISMTPConnection->AckConnection(CONNECTION_STATUS_FAILED);
    }

    if(hFileReadEvent != NULL)
    {
        CloseHandle(hFileReadEvent);
    }

    TraceFunctLeave();
    return(fRet);
}

//////////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::CheckIfAllRcptsHandled(
    IMailMsgRecipients *pIMsgRecips,
    DWORD              *RcptIndexList,
    DWORD              NumRcpts )
{
    BOOL fRet = TRUE;
    
    for( DWORD i = 0; i < NumRcpts; i++ )
    {
        if (RcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            HRESULT hr = pIMsgRecips->GetDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                fRet = FALSE;
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                fRet = FALSE;
                break;
            }
                
        }
    }

    return( fRet );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT REMOTE_QUEUE::SetAllRcptsHandled(
    IMailMsgRecipients *pIMsgRecips,
    DWORD              *RcptIndexList,
    DWORD               NumRcpts )
{
    HRESULT hr = S_OK;
    
    for( DWORD i = 0; i < NumRcpts; i++ )
    {
        if (RcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            hr = pIMsgRecips->GetDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                dwRecipientFlags |= RP_DELIVERED;
            
    
                hr = pIMsgRecips->PutDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr))
                {
                    break;
                }
            }
                
        }
    }
    return( hr );
}


/*++

    ABSTRACT:

    This function Creates a CDropDir object which is associated with a MailMsg object.
    The job of the CDropDir object is to asynchronously write the Mail to the drop dir.

    Called by 
        ProcessQueueEvents()
        CDropDir::~CDropDir().

--*/

BOOL AsyncCopyMailToDropDir(
                            ISMTPConnection    *pISMTPConnection, 
                            const char * DropDirectory, 
                            SMTP_SERVER_INSTANCE *pParentInst
                            )
{
    PVOID               AdvContext = NULL;
    IMailMsgProperties *pIMsg = NULL;
    DWORD               NumRcpts = 0;
    DWORD              *RcptIndexList = NULL;
    CDropDir           *pDropDir = NULL;
    BOOL                fRet = TRUE;
    HRESULT             hr = S_OK;

    TraceFunctEnterEx(NULL, "newCopyMailToDropDir");

    if (!pParentInst->IsShuttingDown())
    {

        AdvContext = NULL;
        fRet = FALSE;

        hr = pISMTPConnection->GetNextMessage(&pIMsg, (DWORD **)&AdvContext, &NumRcpts, &RcptIndexList);
        if(FAILED(hr))
        {
            fRet = TRUE;
            goto Exit;
        }


        pDropDir = new CDropDir();

        if( NULL == pDropDir )
        {
            fRet = FALSE;
            goto Exit;
        }

        if( FAILED( hr = pDropDir->CopyMailToDropDir( pISMTPConnection,
                                                      DropDirectory,
                                                      pIMsg,
                                                      AdvContext,
                                                      NumRcpts,
                                                      RcptIndexList,
                                                      pParentInst) ) )
        {
            fRet = FALSE;
            goto Exit;
        }

        SAFE_RELEASE(pDropDir);
        SAFE_RELEASE(pIMsg );

        fRet = TRUE;
    }

Exit:
    SAFE_RELEASE(pDropDir);
    SAFE_RELEASE(pIMsg );
    TraceFunctLeave();
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpdata.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpdata.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _SMTPDATA_
#define _SMTPDATA_

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );


#define SMTP_UNRECOG_COMMAND_CODE	500
#define SMTP_SYNTAX_ERROR_CODE		501
#define SMTP_NOT_IMPLEMENTED_CODE	502    
#define SMTP_BAD_SEQUENCE_CODE		503
#define SMTP_PARAM_NOT_IMPLEMENTED_CODE	504

#define SMTP_SYS_STATUS_CODE		211
#define SMTP_SERVICE_CLOSE_CODE		221
#define SMTP_SERVICE_READY_CODE		220
#define	SMTP_OK_CODE				250
#define	SMTP_USER_NOT_LOCAL_CODE	251
#define	SMTP_MBOX_BUSY_CODE			450
#define	SMTP_MBOX_NOTFOUND_CODE		550
#define	SMTP_ERROR_PROCESSING_CODE	451
#define	SMTP_USERNOTLOCAL_CODE		551
#define	SMTP_INSUFF_STORAGE_CODE	452
#define	SMTP_ACTION_ABORTED_CODE	552
#define	SMTP_ACTION_NOT_TAKEN_CODE 	553
#define	SMTP_START_MAIL_CODE		354
#define	SMTP_TRANSACT_FAILED_CODE 	554
	
#define	SMTP_SERVICE_UNAVAILABLE_CODE 421	
#define SMTP_COMPLETE_FAILURE_DWORD	5

enum RCPTYPE{LOCAL_NAME, REMOTE_NAME, ALIAS_NAME};

#define NORMAL_RCPT	(char)'R'
#define ERROR_RCPT	(char)'E'
//
// use the current command for transaction logging
//
#define USE_CURRENT         0xFFFFFFFF

static const char * LOCAL_TRANSCRIPT	= "ltr";
static const char * REMOTE_TRANSCRIPT	= "rtr";
static const char * ALIAS_EXT			= "dl";

#define ISNULLADDRESS(Address) ((Address[0] == '<') && (Address[1] == '>'))

typedef char RCPT_TYPE;


//
// Statistics
//

extern SMTP_STATISTICS_0 g_SmtpStat;
extern SMTPCONFIG * g_SmtpConfig;
extern TIME_ZONE_INFORMATION   tzInfo;
extern PERSIST_QUEUE * g_LocalQ;
extern PERSIST_QUEUE * g_RemoteQ;
extern BOOL g_IsShuttingDown;
extern BOOL g_QIsShuttingDown;
extern BOOL g_RetryQIsShuttingDown;

#define INITIALIZE_INBOUNDPOOL  0x00000001
#define INITIALIZE_OUTBOUNDPOOL 0x00000002
#define INITIALIZE_ADDRESSPOOL  0x00000004
#define INITIALIZE_MAILOBJPOOL  0x00000008
#define INITIALIZE_CBUFFERPOOL  0x00000010
#define INITIALIZE_CIOBUFFPOOL  0x00000020

extern  DWORD g_SmtpInitializeStatus;

 
#define	BUMP_COUNTER(counter) \
						InterlockedIncrement((LPLONG) &(g_SmtpStat. counter))

#define	DROP_COUNTER(counter) \
						InterlockedDecrement((LPLONG) &(g_SmtpStat. counter))

#define	ADD_COUNTER(counter, value)	\
		INTERLOCKED_ADD_CHEAP(&(g_SmtpStat. counter), value)

#define	ADD_BIGCOUNTER(counter, value) \
		INTERLOCKED_BIGADD_CHEAP(&(g_SmtpStat. counter), value)

/*++

		Returns a UniqueFilename for an e-mail message.
		The caller should loop through this call and a call to
		CreateFile with the CREATE_NEW flag. If the Create fails due
		to YYY, then the caller should loop again.

	Arguments:

		psz	- a buffer
		pdw	- IN the size of the buffer,
			  OUT: the size of the buffer needed (error == ERROR_MORE_DATA)
			  	   or the size of the filename.

	Returns:
	
		TRUE on SUCCESS
		FALSE if buffer isn't big enough.

--*/
BOOL	GetUniqueFilename(
	IN OUT	LPTSTR	psz,
	IN OUT	LPDWORD	pdw
	);

#endif // _SMTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\spinlock.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.h
//
// Contents: Spinlock package
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980511 17:25:05: Created.
//
//-------------------------------------------------------------
#include <windows.h>

//
// Simple spinlock package used by CLdapConnection
//

typedef LONG SPIN_LOCK;
typedef LPLONG PSPIN_LOCK;

typedef VOID (__stdcall *PFN_ACQUIRESPINLOCK)(PSPIN_LOCK);

extern PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

VOID InitializeSpinLock(
    PSPIN_LOCK psl);

#define AcquireSpinLock (*g_AcquireSpinLock)

VOID AcquireSpinLockSingleProc(
    PSPIN_LOCK psl);
VOID AcquireSpinLockMultipleProc(
    PSPIN_LOCK psl);
VOID ReleaseSpinLock(
    PSPIN_LOCK psl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpproc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpproc.h

Abstract:

    This module contains function prototypes used by the SMTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

--*/

#ifndef	_SMTPPROC_
#define	_SMTPPROC_

//
// smtpdata.cpp
//

APIERR
InitializeGlobals(
            VOID
            );

VOID
TerminateGlobals(
            VOID
            );

//
//  Socket utilities.
//

APIERR InitializeSockets( VOID );

VOID TerminateSockets( VOID );

VOID
SmtpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN * psockaddr
    );

VOID
SmtpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cdWritten,
    DWORD  err,
    OVERLAPPED * lpo
    );

VOID
SmtpCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

VOID
SmtpCompletionFIO(
	PFIO_CONTEXT		pFIOContext,
	FH_OVERLAPPED		*pOverlapped,
	DWORD				cbWritten,
	DWORD				dwCompletionStatus
    );

//
//  IPC functions.
//

APIERR InitializeIPC( VOID );
VOID TerminateIPC( VOID );

//
// svcstat.c
//

VOID
ClearStatistics(
        VOID
        );

#endif // _SMTPPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpout.cxx ===
/*++

   Copyright    (c)    1994-2002    Microsoft Corporation

   Module  Name :

        smtpout.cxx

   Abstract:

        This module defines the functions for derived class of connections
        for Internet Services  ( class SMTP_CONNOUT)

   Author:

           Rohan Phillips    ( Rohanp )    02-Feb-1996

   Project:

          SMTP Server DLL

   Functions Exported:

          SMTP_CONNOUT::~SMTP_CONNOUT()
          BOOL SMTP_CONNOUT::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)

          BOOL SMTP_CONNOUT::StartupSession( VOID)

   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "smtpmsg.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include <smtpevent.h>
#include <smtpguid.h>

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"


    int strcasecmp(char *s1, char *s2);
    int strncasecmp(char *s1, char *s2, int n);

extern CHAR g_VersionString[];

static char * IsLineCompleteBW(IN OUT char *  pchRecvd, IN  DWORD cbRecvd, IN DWORD cbMaxRecvBuffer);

#define SMTP_DUMMY_FAILURE  (0x1000 | SMTP_ACTION_ABORTED_CODE)
#define SMTPOUT_CONTENT_FILE_IO_TIMEOUT 2*60*1000

static const char * TO_MANY_RCPTS_ERROR = "552 Too many recipients";

#define KNOWN_AUTH_FLAGS ((DWORD)(DOMAIN_INFO_USE_NTLM | DOMAIN_INFO_USE_PLAINTEXT | DOMAIN_INFO_USE_DPA \
        | DOMAIN_INFO_USE_KERBEROS))

#define INVALID_RCPT_IDX_VALUE 0xFFFFFFFF

// provide memory for static declared in SMTP_CONNOUT
CPool  SMTP_CONNOUT::Pool(CLIENT_CONNECTION_SIGNATURE_VALID);

//
// Statics for outbound protocol events
//
CInboundDispatcherClassFactory    g_cfInbound;
COutboundDispatcherClassFactory    g_cfOutbound;
CResponseDispatcherClassFactory    g_cfResponse;

/************************************************************
 *    Functions
 ************************************************************/

#define MAX_LOG_ERROR_LEN (500)

extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);

VOID
SmtpCompletion(
              PVOID        pvContext,
              DWORD        cbWritten,
              DWORD        dwCompletionStatus,
              OVERLAPPED * lpo
              );

/*++
    Name :
        InternetCompletion

    Description:

        Handles a completed I/O for outbound connections.

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID InternetCompletion(PVOID pvContext, DWORD cbWritten,
                        DWORD dwCompletionStatus, OVERLAPPED * lpo)
{
    BOOL WasProcessed;
    SMTP_CONNOUT *pCC = (SMTP_CONNOUT *) pvContext;

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) pCC, "InternetCompletion");

    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
    if (!WasProcessed) {
        pCC->DisconnectClient();
        pCC->QuerySmtpInstance()->RemoveOutboundConnection(pCC);
        delete pCC;
        pCC = NULL;
    }

    //TraceFunctLeaveEx((LPARAM)pCC);
}

VOID FIOInternetCompletion(PFIO_CONTEXT pFIOContext,
                           PFH_OVERLAPPED lpo,
                           DWORD cbWritten,
                           DWORD dwCompletionStatus)
{
    BOOL WasProcessed;
    SMTP_CONNOUT *pCC = (SMTP_CONNOUT *) (((SERVEREVENT_OVERLAPPED *) lpo)->ThisPtr);

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) pCC, "InternetCompletion");

    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, (OVERLAPPED *) lpo);

    if (!WasProcessed) {
        pCC->DisconnectClient();
        pCC->QuerySmtpInstance()->RemoveOutboundConnection(pCC);
        delete pCC;
        pCC = NULL;
    }

    //TraceFunctLeaveEx((LPARAM)pCC);
}

void SMTP_CONNOUT::ProtocolLogCommand(LPSTR pszCommand,
                                      DWORD cParameters,
                                      LPCSTR pszIpAddress,
                                      FORMAT_SMTP_MESSAGE_LOGLEVEL eLogLevel)
{
    char *pszCR = NULL, *pszParameters = NULL, *pszSpace = NULL;
    DWORD cBytesSent;

    if (eLogLevel == FSM_LOG_NONE) return;

    if (pszCR = strchr(pszCommand, '\r')) *pszCR = 0;

    if (pszSpace = strchr(pszCommand, ' ')) {
        *pszSpace = 0;
        pszParameters = (eLogLevel == FSM_LOG_ALL) ? pszSpace + 1 : NULL;
    }

    cBytesSent = strlen(pszCommand);

    LogRemoteDeliveryTransaction(
        pszCommand,
        NULL,
        pszParameters,
        pszIpAddress,
        0,
        0,
        cBytesSent,
        0,
        FALSE);

    if (pszCR) *pszCR = '\r';
    if (pszSpace) *pszSpace = ' ';
}

void SMTP_CONNOUT::ProtocolLogResponse(LPSTR pszResponse,
                                       DWORD cParameters,
                                       LPCSTR pszIpAddress)
{
    char *pszCR = NULL;
    DWORD cBytesReceived;

    if (pszCR = strchr(pszResponse, '\r')) *pszCR = 0;
    cBytesReceived = strlen(pszResponse);

    LogRemoteDeliveryTransaction(
        NULL,
        NULL,
        pszResponse,
        pszIpAddress,
        0,
        0,
        cBytesReceived,
        0,
        TRUE);

    if (pszCR) *pszCR = '\r';
}

void SMTP_CONNOUT::LogRemoteDeliveryTransaction(
                                               LPCSTR pszOperation,
                                               LPCSTR pszTarget,
                                               LPCSTR pszParameters,
                                               LPCSTR pszIpAddress,
                                               DWORD dwWin32Error,
                                               DWORD dwServiceSpecificStatus,
                                               DWORD dwBytesSent,
                                               DWORD dwBytesReceived,
                                               BOOL fResponse
                                               )
{
    INETLOG_INFORMATION translog;
    DWORD  dwLog;
    LPSTR lpNull = "";
    DWORD cchError = MAX_LOG_ERROR_LEN;
    char VersionString[] = "SMTP";
    char szClientUserNameCommand[] = "OutboundConnectionCommand";
    char szClientUserNameResponse[] = "OutboundConnectionResponse";

    //Buffers to prevent overwrite by IIS logging
    //which does evil things like change '<sp>' to '+'
    //      6/23/99 - MikeSwa
    char szOperationBuffer[20]    = "";   //This is the protocol verb
    char szTargetBuffer[20]       = "";   //Currently unused by all callers
    char szParametersBuffer[1024] = "";   //Data portion of buffer information

    ZeroMemory(&translog, sizeof(translog));

    if (pszParameters == NULL)
        pszParameters = lpNull;

    if (pszIpAddress == NULL)
        pszIpAddress = lpNull;

    translog.pszVersion = VersionString;
    translog.msTimeForProcessing = QueryProcessingTime();;
    if (fResponse) {
        translog.pszClientUserName = szClientUserNameResponse;
    } else {
        translog.pszClientUserName = szClientUserNameCommand;
    }

    translog.pszClientHostName = (LPSTR)pszIpAddress;
    translog.cbClientHostName = lstrlen(pszIpAddress);

    //Make sure we log the correct port number
    if (IsSecure()) {
        translog.dwPort = QuerySmtpInstance()->GetRemoteSmtpSecurePort();
    } else {
        translog.dwPort = QuerySmtpInstance()->GetRemoteSmtpPort();
    }

    //Copy buffers
    if (pszOperation) {
        lstrcpyn(szOperationBuffer, pszOperation, sizeof(szOperationBuffer)-sizeof(CHAR));
        translog.pszOperation = szOperationBuffer;
        translog.cbOperation = lstrlen(szOperationBuffer);
    } else {
        translog.pszOperation = "";
        translog.cbOperation = 0;
    }

    if (pszTarget) {
        lstrcpyn(szTargetBuffer, pszTarget, sizeof(szTargetBuffer)-sizeof(CHAR));
        translog.pszTarget = szTargetBuffer;
        translog.cbTarget = lstrlen(szTargetBuffer);
    } else {
        translog.pszTarget = "";
        translog.cbTarget = 0;
    }

    if (pszParameters) {
        lstrcpyn(szParametersBuffer, pszParameters, sizeof(szParametersBuffer)-sizeof(CHAR));
        translog.pszParameters = szParametersBuffer;
    } else {
        translog.pszParameters = "";
    }

    //Detect if usage drastically changes... but don't check parameters, because
    //we don't care about logging more than 1K per command
    _ASSERT(sizeof(szOperationBuffer) > lstrlen(pszOperation));
    _ASSERT(sizeof(szTargetBuffer) > lstrlen(pszTarget));

    translog.dwBytesSent = dwBytesSent;
    translog.dwBytesRecvd = dwBytesReceived;
    translog.dwWin32Status = dwWin32Error;
    translog.dwProtocolStatus = dwServiceSpecificStatus;

    dwLog = QuerySmtpInstance()->m_Logging.LogInformation( &translog);
}

/*++

    Name:

    SMTP_CONNOUT::SMTP_CONNOUT

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

--*/
SMTP_CONNOUT::SMTP_CONNOUT(
                          IN PSMTP_SERVER_INSTANCE pInstance,
                          IN SOCKET sClient,
                          IN const SOCKADDR_IN *  psockAddrRemote,
                          IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
                          IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
                          IN PVOID                pvInitialRequest/* = NULL*/ ,
                          IN DWORD                cbInitialData  /* = 0    */
                          )
:  m_encryptCtx( TRUE ),
m_securityCtx(pInstance,
              TCPAUTH_CLIENT| TCPAUTH_UUENCODE,
              ((PSMTP_SERVER_INSTANCE)pInstance)->QueryAuthentication()),
CLIENT_CONNECTION ( sClient, psockAddrRemote,
                    psockAddrRemote,  pAtqContext,
                    pvInitialRequest, cbInitialData )
{

    _ASSERT(pInstance != NULL);

    m_cActiveThreads = 0;
    m_cPendingIoCount = 0;
    m_MsgOptions = 0;
    m_AuthToUse = 0;
    m_pInstance = pInstance;
    m_UsingSSL = FALSE;
    m_fCanTurn = TRUE;
    m_pIMsg = NULL;
    m_pIMsgRecips = NULL;
    m_pISMTPConnection = NULL;
    m_AdvContext = NULL;
    m_pDnsRec = NULL;
    m_EhloSent = FALSE;

    pInstance->IncConnOutObjs();

    //
    // By default, we use the smallish receive buffer inherited from
    // the base CLIENT_CONNECTION object and a smallish output buffer defined in
    // SMTP_CONNOUT
    //
    m_precvBuffer = m_recvBuffer;
    m_cbMaxRecvBuffer =  sizeof(m_recvBuffer);
    m_pOutputBuffer = m_OutputBuffer;
    m_cbMaxOutputBuffer =  sizeof(m_OutputBuffer);

    m_pmszTurnList = NULL;
    m_szCurrentTURNDomain = NULL;
    m_IMsgDotStuffedFileHandle = NULL;

    m_ConnectedDomain [0] = '\0';

    m_pBindInterface = NULL;

    m_SeoOverlapped.ThisPtr = (PVOID) this;
    m_SeoOverlapped.pfnCompletion = InternetCompletion;
    //initialize this error in case the connection gets
    //broken early.
    m_Error =  ERROR_BROKEN_PIPE;

    m_fNeedRelayedDSN = FALSE;
    m_fHadHardError = FALSE;
    m_fHadTempError = FALSE;
    m_fHadSuccessfulDelivery = FALSE;


    //
    // Protocol Events
    //
    m_fNativeHandlerFired    = FALSE;
    m_pOutboundDispatcher    = NULL;
    m_pResponseDispatcher    = NULL;

    //
    // Diagnostic Information
    //
    m_hrDiagnosticError      = S_OK;
    m_szDiagnosticVerb       = NULL;
    m_szDiagnosticResponse[0]= '\0';

    m_szCurrentETRNDomain = NULL;
    m_pszSSLVerificationName = NULL;
    m_pDNS_RESOLVER_RECORD = NULL;
    m_pProviderPackagesInfo = NULL;
}

/*++

    Name :
        SMTP_CONNOUT::~SMTP_CONNOUT (void)

    Description:

        Destructor for outbound connection object.
        This routine checks to see if there was a
        current mail object that was being processed
        before this destructor was called and does
        whatever is necessary to clean up its' memory.
        Then it checks the mailbag and cleans up any
        mail objects it finds in there.


    Arguments:

        none

    Returns:

        none

--*/

SMTP_CONNOUT::~SMTP_CONNOUT (void)
{
    PSMTP_SERVER_INSTANCE pInstance = NULL;
    HRESULT hrDiagnostic = S_OK;
    char * pTempBuffer = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::~SMTP_CONNOUT (void)");

    //We need to call our cleanup function... so that the ATQ context will be
    //freed. We do this first, because a message ack or connection ack may
    //trigger DSN generation, which may take long enough to cause the context
    //to time out and complete on us (causing one thread to AV).
    Cleanup();

    //catch all message ack call
    //NK** : Need to substitute it with an HRESULT based on the actual internal error
    //mikeswa - 9/11/98 - Add check recips to flags

    HandleCompletedMailObj(MESSAGE_STATUS_RETRY_ALL | MESSAGE_STATUS_CHECK_RECIPS, "451 Remote host dropped connection", 0);


    //if we were doing a TLS transmission that got interrupted, we need to
    //destroy the AtqContext we created for reading from the mail file.
    //FreeAtqFileContext();

    if (m_pISMTPConnection) {
        //Ack the connection
        m_pISMTPConnection->AckConnection((eConnectionStatus)m_dwConnectionStatus);
        PromoteSessionPropertiesToAQ();

        if (FAILED(m_hrDiagnosticError))
        {
            m_pISMTPConnection->SetDiagnosticInfo(m_hrDiagnosticError,
                    m_szDiagnosticVerb, m_szDiagnosticResponse);
        }
        else if (CONNECTION_STATUS_OK != m_dwConnectionStatus)
        {
            //Report appropriate diagnostic information if we don't have specific failures
            switch (m_dwConnectionStatus)
            {
                case CONNECTION_STATUS_DROPPED:
                    hrDiagnostic = AQUEUE_E_CONNECTION_DROPPED;
                    break;
                case CONNECTION_STATUS_FAILED:
                    hrDiagnostic = AQUEUE_E_CONNECTION_FAILED;
                    break;
                default:
                    hrDiagnostic = E_FAIL;
            }
            m_pISMTPConnection->SetDiagnosticInfo(hrDiagnostic, NULL, NULL);
        }

        m_pISMTPConnection->Release();
        m_pISMTPConnection = NULL;
    }

    //If we had a TURN list free it up
    if (m_pmszTurnList) {
        delete m_pmszTurnList;
        m_pmszTurnList = NULL;
        m_szCurrentTURNDomain = NULL;
    }

    pInstance = (PSMTP_SERVER_INSTANCE ) InterlockedExchangePointer((PVOID *) &m_pInstance, (PVOID) NULL);
    if (pInstance != NULL) {
        pInstance->DecConnOutObjs();
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_precvBuffer, (PVOID) &m_recvBuffer[0]);
    if (pTempBuffer != m_recvBuffer) {
        delete [] pTempBuffer;
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_pOutputBuffer, (PVOID) &m_OutputBuffer[0]);
    if (pTempBuffer != m_OutputBuffer) {
        delete [] pTempBuffer;
    }

    // Protocol events: Release the dispatchers
    if (m_pOutboundDispatcher)
        m_pOutboundDispatcher->Release();

    if (m_pResponseDispatcher)
        m_pResponseDispatcher->Release();

    if (m_pDnsRec) {
        DeleteDnsRec(m_pDnsRec);
        m_pDnsRec = NULL;
    }

    if (m_pDNS_RESOLVER_RECORD) {
        delete m_pDNS_RESOLVER_RECORD;
        m_pDNS_RESOLVER_RECORD = NULL;
    }

    if (m_pszSSLVerificationName)
        delete [] m_pszSSLVerificationName;

    if (m_pProviderPackagesInfo)
        m_pProviderPackagesInfo->Release();

    if (m_szDiagnosticVerb)
        free(m_szDiagnosticVerb);

    DebugTrace((LPARAM) this,"%X was deleted", this);
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_CONNOUT::DisconnectClient(DWORD dwErrorCode)

    Description:

        Disconnects from the remote server. It first calls
        CLIENT_CONNECTION::DisconnectClient, and then shuts down any mail-file
        read handles we may be pending reads on.

    Arguments:

        dwErrorCode -- Passed through to CLIENT_CONNECTION::Disconnect

    Returns:

        nothing

--*/

VOID SMTP_CONNOUT::DisconnectClient(DWORD dwErrorCode)
{
    TraceFunctEnter("SMTP_CONNOUT::DisconnectClient");

    if (m_DoCleanup)
        CLIENT_CONNECTION::DisconnectClient();
}

/*++

    Name :
        SMTP_CONNOUT::HandleCompletedMailObj


    Description:

        This routinr gets called after the mail file
        has been sent. It will either requeue the object
        in the outbound queue, retry queue, BadMail,etc.

    Arguments:

        none

    Returns:

        none

--*/
void SMTP_CONNOUT::HandleCompletedMailObj(DWORD MsgStatus, char * szExtendedStatus, DWORD cbExtendedStatus)
{
    MessageAck MsgAck;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::HandleCompletedMailObj");

    _ASSERT(IsValid());

    if (m_pISMTPConnection) {
        if (m_pIMsgRecips) {
            //Uncheck all marked recipients if the connection has been dropped
            if (((m_dwConnectionStatus != CONNECTION_STATUS_OK) || (szExtendedStatus[0] != SMTP_COMPLETE_SUCCESS)) &&
                m_NumRcptSentSaved) {
                UnMarkHandledRcpts();
            }
            m_pIMsgRecips->Release();
            m_pIMsgRecips = NULL;

        }

        if (m_pIMsg) {
            MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
            MsgAck.pIMailMsgProperties = m_pIMsg;

            if ( (MsgStatus & MESSAGE_STATUS_RETRY_ALL) ||
                 (MsgStatus & MESSAGE_STATUS_NDR_ALL)) {
                //DebugTrace((LPARAM) this,"CompObj:file %s going to %s was retryed", FileName, m_ConnectedDomain);

            } else {
                //DebugTrace((LPARAM) this,"CompObj:file %s going to %s was delivered", FileName, m_ConnectedDomain);

            }

            MsgAck.dwMsgStatus = MsgStatus;
            MsgAck.dwStatusCode = 0;

            //We will have an extended status string to go along with the Status code
            //in case of some major failure that makes us fail the complete message
            if (MsgStatus & MESSAGE_STATUS_EXTENDED_STATUS_CODES ) {
                MsgAck.cbExtendedStatus = cbExtendedStatus;
                MsgAck.szExtendedStatus = szExtendedStatus;
            }

            if (m_pBindInterface) {
                m_pBindInterface->ReleaseContext();
                m_pBindInterface->Release();
                m_pBindInterface = NULL;

                if( NULL != m_IMsgDotStuffedFileHandle )
                {
                    ReleaseContext( m_IMsgDotStuffedFileHandle );
                    m_IMsgDotStuffedFileHandle = NULL;
                }
            }

            //
            // Do Message Tracking
            //

            MSG_TRACK_INFO msgTrackInfo;
            ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );

            msgTrackInfo.dwEventId = MTE_END_OUTBOUND_TRANSFER;
            msgTrackInfo.pszPartnerName = m_ConnectedDomain;
            if( MsgStatus & MESSAGE_STATUS_RETRY_ALL )
            {
                msgTrackInfo.dwRcptReportStatus = MP_STATUS_RETRY;
            }
            else if( MsgStatus & MESSAGE_STATUS_NDR_ALL )
            {
                msgTrackInfo.dwEventId = MTE_NDR_ALL;
                msgTrackInfo.pszPartnerName = NULL;
                msgTrackInfo.dwRcptReportStatus = MP_STATUS_ABORT_DELIVERY;
            }

            m_pInstance->WriteLog( &msgTrackInfo, m_pIMsg, NULL, NULL );

            m_pISMTPConnection->AckMessage(&MsgAck);
            m_pIMsg->Release();
            m_pIMsg = NULL;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        SMTP_CONNOUT::UnMarkHandledRcpts


    Description:

        When we send out recipients we assumptively mark the recipients as
        delivered or failed based on the responses. Later if it turns out that we
        could never completely send the message. we need to rset the status of
        successful recipients.  However, if we have a hard per-recipient error,
        we should leave the error code intact (otherwise the sender may receive
        a DELAY DSN with a 500-level status code).

    Arguments:

        none

    Returns:

        none

--*/

BOOL SMTP_CONNOUT::UnMarkHandledRcpts(void)
{
    DWORD i;
    HRESULT hr = S_OK;
    DWORD dwRecipientFlags;
    DWORD dwRcptsSaved = m_NumRcptSentSaved;

    //
    //  It is possible for this to be called after HandleCompletedMailObj (after
    //  a 421 response to a DATA command for example).  We should bail if we
    //  do not have a mailmsg ptr.
    //
    if (!m_pIMsgRecips)
        return (TRUE);

    for (i = m_FirstAddressinCurrentMail; (i < m_NumRcpts) && dwRcptsSaved;i++) {
        //Get to the next rcpt that we send out this time
        if (m_RcptIndexList[i] != INVALID_RCPT_IDX_VALUE) {
            //
            //  The ideal way to handle this situation is to use the
            //  RP_VOLATILE_FLAGS_MASK bits in the recipient flags a tmp
            //  storage and then "commit" the handled bit after a successful
            //  connection. Given how mailmsg works, this is not a problem
            //   -  While we are processing the message... it is not possible
            //      for it to be saved to disk until we are done with it.
            //   -  If we can write a property once before committing... we
            //      can always rewrite a property of the same size (since
            //      the required portion of the property stream is already
            //      in memory.
            //  I have added the ASSERT(SUCEEDED(hr)) below
            //      - mikeswa 9/11/98 (updated 10/05/2000)
            dwRecipientFlags = 0;
            hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            //Check to see if we marked it as delivered... and unmark it if we did
            if (RP_DELIVERED == (dwRecipientFlags & RP_DELIVERED)) {
                dwRecipientFlags &= ~RP_DELIVERED;

                hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr)) {
                    //
                    //  We need to understand how this can fail... mailmsg
                    //  is designed so this should not happen.
                    //
                    ASSERT(FALSE && "Potential loss of recipient");
                    SetLastError(ERROR_OUTOFMEMORY);
                    return (FALSE);
                }
            }
            dwRcptsSaved--;
        }
    }

    return (TRUE);
}



/*++

    Name :
        SMTP_CONNOUT::InitializeObject

    Description:
       Initializes all member variables and pre-allocates
       a mail context class

    Arguments:
        Options - SSL etc.
        pszSSLVerificationName - Subject name to look for in server certificate
            if using SSL
    Returns:

       TRUE if memory can be allocated.
       FALSE if no memory can be allocated
--*/
BOOL SMTP_CONNOUT::InitializeObject (
    DWORD Options,
    LPSTR pszSSLVerificationName,
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::InitializeObject");

    m_szCurrentETRNDomain = NULL;
    m_cbReceived = 0;
    m_cbParsable = 0;
    m_OutputBufferSize = 0;
    m_NumRcptSent = 0;
    m_FirstAddressinCurrentMail = 0;
    m_NumRcptSentSaved = 0;
    m_SizeOptionSize = 0;
    m_Flags = 0;
    m_NumFailedAddrs = 0;
    m_cActiveThreads = 0;
    m_cPendingIoCount = 0;
    m_FileSize = 0;

    m_NextAddress = 0;
    m_FirstPipelinedAddress = 0;
    m_First552Address = -1;
    m_NextState = NULL;
    m_HeloSent = FALSE;
    m_EhloFailed = FALSE;
    m_FirstRcpt = FALSE;
    m_SendAgain = FALSE;
    m_Active = TRUE;
    m_HaveDataResponse = FALSE;

    m_SecurePort = FALSE;
    m_fNegotiatingSSL = FALSE;

    m_MsgOptions = Options;
    m_dwConnectionStatus = CONNECTION_STATUS_OK;

    m_fUseBDAT = FALSE;

    m_fNeedRelayedDSN = FALSE;
    m_fHadHardError = FALSE;
    m_fHadTempError = FALSE;
    m_fHadSuccessfulDelivery = FALSE;
    m_pDNS_RESOLVER_RECORD = pDNS_RESOLVER_RECORD;

    if (Options & KNOWN_AUTH_FLAGS) {
        m_pInstance->LockGenCrit();

        //   Initialize Security Context
        //

        m_pProviderPackagesInfo = m_pInstance->GetAddRefdProviderPackagesInfo();
        if(!m_pProviderPackagesInfo)
        {
            fRet = FALSE;
            m_pInstance->UnLockGenCrit();
            goto Exit;
        }

        if (!m_securityCtx.SetInstanceAuthPackageNames(
                  m_pProviderPackagesInfo->GetProviderPackagesCount(),
                  m_pProviderPackagesInfo->GetProviderNames(),
                  m_pProviderPackagesInfo->GetProviderPackages())) {

            m_Error = GetLastError();
            ErrorTrace((LPARAM)this, "SetInstanceAuthPackageNames FAILED <Err=%u>",
                       m_Error);
            fRet = FALSE;
            m_pInstance->UnLockGenCrit();
            goto Exit;
        }

        //
        // We want to set up the Cleartext authentication package
        // for this connection based on the instance configuration.
        // To enable MBS CTA,
        // MD_SMTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
        // To disable it, the md value must be set to "".
        //

        m_securityCtx.SetCleartextPackageName(
                                             m_pInstance->GetCleartextAuthPackage(),
                                             m_pInstance->GetMembershipBroker());

        if (*m_pInstance->GetCleartextAuthPackage() == '\0' ||
            *m_pInstance->GetMembershipBroker() == '\0') {
            m_fUseMbsCta = FALSE;
        } else {
            m_fUseMbsCta = TRUE;
        }

        m_pInstance->UnLockGenCrit();
    }

    m_pmszTurnList = NULL;
    m_szCurrentTURNDomain = NULL;

    m_UsingSSL = (Options & DOMAIN_INFO_USE_SSL);
    m_TlsState = (Options & DOMAIN_INFO_USE_SSL) ? MUST_DO_TLS : DONT_DO_TLS;

    m_TransmitTailBuffer[0] = '.';
    m_TransmitTailBuffer[1] = '\r';
    m_TransmitTailBuffer[2] = '\n';

    m_TransmitBuffers.Head = NULL;
    m_TransmitBuffers.HeadLength = 0;
    m_TransmitBuffers.Tail = m_TransmitTailBuffer;
    m_TransmitBuffers.TailLength = 3;

    //
    // Protocol events: get the response dispatcher for the session
    //
    m_pIEventRouter = m_pInstance->GetRouter();
    if (m_pIEventRouter) {
        HRESULT hr = m_pIEventRouter->GetDispatcherByClassFactory(
                                                                 CLSID_CResponseDispatcher,
                                                                 &g_cfResponse,
                                                                 CATID_SMTP_ON_SERVER_RESPONSE,
                                                                 IID_ISmtpServerResponseDispatcher,
                                                                 (IUnknown **)&m_pResponseDispatcher);
        if (!SUCCEEDED(hr)) {
            // If we fail, we don't process protocol events
            m_pResponseDispatcher = NULL;
            ErrorTrace((LPARAM) this,
                       "Unable to get response dispatcher from router (%08x)",    hr);
        }
    }

    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen (pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName) {
            fRet = FALSE;
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }
    StartProcessingTimer();

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

BOOL SMTP_CONNOUT::GoToWaitForConnectResponseState(void)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GoToWaitForConnectResponseState( void)");

    SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

    m_Error = NO_ERROR;
    m_LastClientIo = SMTP_CONNOUT::READIO;
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::WaitForConnectResponseState - ReadFile failed with error %d", m_Error);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        DecPendingIoCount();
        SetLastError(m_Error);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        fRet = FALSE;
    }

    return fRet;
}

BOOL SMTP_CONNOUT::GetNextTURNConnection(void)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GetNextTURNConnection( void)");
    //We are on a TURNed connection and need to start the queue for next
    //domain in the turn list if it exists
    //Before getting the next connection release the current one.
    //
    if (m_pISMTPConnection) {
        //Ack the last connection
        m_dwConnectionStatus = CONNECTION_STATUS_OK;
        m_pISMTPConnection->AckConnection((eConnectionStatus)m_dwConnectionStatus);
        PromoteSessionPropertiesToAQ();
        m_pISMTPConnection->Release();
        m_pISMTPConnection = NULL;
    }

    m_szCurrentTURNDomain = m_pmszTurnList->Next( m_szCurrentTURNDomain );
    while (m_szCurrentTURNDomain && !QuerySmtpInstance()->IsShuttingDown()) {
        //We have another domain to start
        hr = QuerySmtpInstance()->GetConnManPtr()->GetNamedConnection(lstrlen(m_szCurrentTURNDomain), (CHAR*)m_szCurrentTURNDomain, &m_pISMTPConnection);
        if (FAILED(hr)) {
            //Something bad happened on this call
            ErrorTrace((LPARAM) this, "StartSession - SMTP_ERROR_PROCESSING_CODE, GetNamedConnection failed %d",hr);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        //If the link corresponding to this domain does not exist in AQ, we get a NULL
        //ISMTPConnection at this point
        if (m_pISMTPConnection)
            break;
        else {
            m_szCurrentTURNDomain = m_pmszTurnList->Next( m_szCurrentTURNDomain );
            continue;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

/*++

   Name :
       SMTP_CONNOUT::StartSession

   Description:

       Starts up a session for new client.
       starts off a receive request from client.

   Arguments:

   Returns:

      TRUE if everything is O.K
      FALSE if a write or a pended read failed
--*/

BOOL SMTP_CONNOUT::StartSession( void)
{
    HRESULT hr = S_OK;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::StartSession( void)");

    _ASSERT(IsValid());

    //We do not do s restart if the connection is a tunr connection
    if (!m_pmszTurnList || !m_szCurrentTURNDomain) {
        _ASSERT(m_pDnsRec);
        if(!m_pDnsRec)
        {
            ErrorTrace((LPARAM)this, "Unexpected NULL DnsRec");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        if (m_pDnsRec->pMailMsgObj) {
            fRet = ReStartSession();
            TraceFunctLeaveEx((LPARAM) this);
            return fRet;
        }
    }

    //
    // We are either not doing SSL or are done establishing an SSL session.
    // Lets do the real work of starting a session with a remote SMTP server.
    //

    m_IMsgFileHandle = NULL;
    m_IMsgDotStuffedFileHandle = NULL;

    //get the next object to send
    //This is in loop because - we might have to pickup a new connection in case
    //we are handling a TURN list
    while (1) {
        // we can't call into GetNextMessage if we are on a TURN-only
        // connection.  if we did and a message queued up between the
        // last time we were in StartSession and now then we would
        // get back into the waitforconnect state, which would be really
        // bad.  so if we see the m_Flags set to TURN_ONLY_OPTION then we
        // know that this is an empty TURN and we just pretend that there
        // is no message to pick up.
        if (!(m_Flags & TURN_ONLY_OPTION)) {
            hr = m_pISMTPConnection->GetNextMessage(&m_pIMsg, (DWORD **) &m_AdvContext, &m_NumRcpts, &m_RcptIndexList);
        } else {
            m_pIMsg = NULL;
            hr = HRESULT_FROM_WIN32(ERROR_EMPTY);
        }
        if(FAILED(hr) || (m_pIMsg == NULL))
        {
            m_fCanTurn = FALSE;

            if (m_pmszTurnList && m_szCurrentTURNDomain) {
                //We have valid TURN list - Try and get the connetion for next domain to TURN
                if (GetNextTURNConnection()) {
                    //We loop back if we got a valid connection. Otherwise we drop thru
                    if (m_pISMTPConnection)
                        continue;
                } else {    //some error happened
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }

            if (m_MsgOptions & DOMAIN_INFO_SEND_TURN) {
                if (m_HeloSent || m_EhloSent) {
                    // we will fall into this if we have already sent
                    // the helo
                    FormatSmtpMessage(FSM_LOG_ALL, "TURN\r\n");

                    m_cbReceived = 0;
                    m_cbParsable = 0;
                    m_pmszTurnList = NULL;
                    m_szCurrentTURNDomain = NULL;

                    SendSmtpResponse();
                    SetNextState (&SMTP_CONNOUT::DoTURNCommand);
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                } else {
                    // we fall into this if we are sending TURN on an
                    // otherwise empty connection.  At this point we have
                    // not yet sent EHLO, so it is not safe to send TURN.
                    m_Flags |= TURN_ONLY_OPTION;
                    return GoToWaitForConnectResponseState();
                }
            } else if ((m_MsgOptions & DOMAIN_INFO_SEND_ETRN) &&
                       (m_NextState == NULL) &&
                       !IsOptionSet(ETRN_SENT)) {
                m_Flags |= ETRN_ONLY_OPTION;
                return GoToWaitForConnectResponseState();
            } else if (!(m_EhloSent)) {
                // This is an empty connection
                m_MsgOptions |= EMPTY_CONNECTION_OPTION;
                return GoToWaitForConnectResponseState();
            } else {
                //      1/11/99 - MikeSwa
                //There just happened to be no mail at this time.  Could
                //have been serviced by another connection, or just link
                //state detection
                if (HRESULT_FROM_WIN32(ERROR_EMPTY) == hr)
                    SetLastError(ERROR_EMPTY); //AQueue does not setlast error
                else
                {
                    SetDiagnosticInfo(hr, NULL, NULL);
                }

                DebugTrace((LPARAM) this,"Mailbag empty - returning FALSE");
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;

            }

        }
        else
        {
            //
            // The actual file may have been deleted from the queue. If so, we
            // need to ack the message and get the next one.
            //

            hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
            if (FAILED(hr))
            {
                MessageAck MsgAck;

                ErrorTrace((LPARAM)this, "Unable to Queryinterface message, going on to next one.");

                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                SetDiagnosticInfo(AQUEUE_E_BIND_ERROR, NULL, NULL);

                m_pIMsg->Release();
                m_pIMsg = NULL;
                continue;
            }

            hr = m_pBindInterface->GetBinding(&m_IMsgFileHandle, NULL);
            if (SUCCEEDED(hr))
            {
                MSG_TRACK_INFO msgTrackInfo;
                ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
                msgTrackInfo.pszServerName = g_ComputerName;
                msgTrackInfo.dwEventId = MTE_BEGIN_OUTBOUND_TRANSFER;
                m_pInstance->WriteLog( &msgTrackInfo, m_pIMsg, NULL, NULL );
                break;
            }
            else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {

                MessageAck MsgAck;

                DebugTrace(NULL,
                    "Message from queue has been deleted - ignoring it");

                m_pBindInterface->Release();
                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                m_pIMsg->Release();
                m_pIMsg = NULL;

            }
            else
            {
                ASSERT(FAILED(hr));
                MessageAck MsgAck;

                ErrorTrace((LPARAM)this, "Unable to Bind message, going on to next one.");

                m_pBindInterface->Release();
                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                SetDiagnosticInfo(AQUEUE_E_BIND_ERROR, NULL, NULL);

                m_pIMsg->Release();
                m_pIMsg = NULL;
                continue;
            }
        }
    }

    // Bump both the remote and total recipient counters
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvdRemote, m_NumRcpts);
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvd, m_NumRcpts);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecips);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }


    m_FirstPipelinedAddress = 0;

    //Nk** I moved this here from PerRcptEvent
    m_NextAddress = 0;


    //if m_NextState is NULL, this is the
    //first time this routine has been called
    //as a result of a connection.  If m_NextState
    //is not NULL, this means we just finished
    //sending mail and we are about to send another
    //mail message
    if (m_NextState == NULL) {
        m_Error = NO_ERROR;
        DebugTrace((LPARAM) this,"start session called because of new connection");

        m_FirstPipelinedAddress = 0;

        SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

        m_LastClientIo = SMTP_CONNOUT::READIO;
        IncPendingIoCount();

        fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::StartSession - ReadFile failed with error %d", m_Error);
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DisconnectClient();
            DecPendingIoCount();
            SetLastError(m_Error);

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        }
    } else {
        DebugTrace((LPARAM) this,"start session called because item was found in mailbag");

        m_cbReceived = 0;
        m_cbParsable = 0;
        m_OutputBufferSize = 0;
        m_Error = NO_ERROR;
        m_NumRcptSent = 0;
        m_FirstAddressinCurrentMail = 0;
        m_NumRcptSentSaved = 0;
        m_NumFailedAddrs = 0;
        m_SendAgain = FALSE;
        m_HaveDataResponse = FALSE;
        m_FirstPipelinedAddress = 0;

        m_FirstRcpt = FALSE;

        m_TransmitTailBuffer[0] = '.';
        m_TransmitTailBuffer[1] = '\r';
        m_TransmitTailBuffer[2] = '\n';

        m_TransmitBuffers.Head = NULL;
        m_TransmitBuffers.HeadLength = 0;
        m_TransmitBuffers.Tail = m_TransmitTailBuffer;
        m_TransmitBuffers.TailLength = 3;

        //send a reset
        m_fNativeHandlerFired    = FALSE;
        m_RsetReasonCode = BETWEEN_MSG;
        fRet = DoRSETCommand(NULL, 0, 0);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this,"reset command failed in StartSession");
            TraceFunctLeaveEx((LPARAM) this);

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            return FALSE;
        }

        // WaitForRSETResponse is smart and will raise the message
        // start event
        SetNextState (&SMTP_CONNOUT::WaitForRSETResponse);
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return fRet;
}

BOOL SMTP_CONNOUT::DecPendingIoCountEx(void)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::DecPendingIoCountEx");

    _ASSERT(IsValid());

    if (InterlockedDecrement( &m_cPendingIoCount ) == 0) {
        DebugTrace((LPARAM) this, "DecPendingIoCountEx deleting Smtp_Connout");
        fRet = TRUE;
        DisconnectClient();
        QuerySmtpInstance()->RemoveOutboundConnection(this);
        delete this;
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return fRet;
}


BOOL SMTP_CONNOUT::ConnectToNextIpAddress(void)
{
    BOOL fRet = TRUE;
    REMOTE_QUEUE * pRemoteQ = NULL;
    PSMTPDNS_RECS  pDnsRec = NULL;
    ISMTPConnection * pISMTPConnection = NULL;
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ConnectToNextIpAddress( void)");

    if (m_pmszTurnList && m_szCurrentTURNDomain) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because of TURN");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (!m_fCanTurn) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because of m_fCanTurn");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if(!SetDnsRecToNextMx() &&
        (!m_pDNS_RESOLVER_RECORD || !m_pDNS_RESOLVER_RECORD->GetDnsResolverRecord())) {

        //
        // Set m_pDnsRec to point to the next MX record to connect to. If that fails (because
        // we have no more MX records for the current host), check to see if we have an
        // m_pDNS_RESOLVER_RECORD with any more possible destination hosts. If there is, we
        // will go on to ReStartAsyncConnections, if not, there is nothing to do but retry.
        //

        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (m_NumRcptSentSaved) {
        UnMarkHandledRcpts();
    }

    m_pDnsRec->pMailMsgObj = (PVOID) m_pIMsg;
    m_pDnsRec->pAdvQContext = m_AdvContext;
    m_pDnsRec->pRcptIdxList = (PVOID) m_RcptIndexList;
    m_pDnsRec->dwNumRcpts = m_NumRcpts;

    pDnsRec = m_pDnsRec;
    m_pDnsRec = NULL;

    pDNS_RESOLVER_RECORD = m_pDNS_RESOLVER_RECORD;
    m_pDNS_RESOLVER_RECORD = NULL;


    pISMTPConnection = m_pISMTPConnection;

    if (m_pIMsgRecips) {
        m_pIMsgRecips->Release();
        m_pIMsgRecips = NULL;
    }

    if (m_pBindInterface) {
        m_pBindInterface->ReleaseContext();
        m_pBindInterface->Release();
        m_pBindInterface = NULL;

        if( NULL != m_IMsgDotStuffedFileHandle )
        {
            ReleaseContext( m_IMsgDotStuffedFileHandle );
            m_IMsgDotStuffedFileHandle = NULL;
        }
    }

    pRemoteQ = (REMOTE_QUEUE *) QuerySmtpInstance()->QueryRemoteQObj();
    fRet = pRemoteQ->ReStartAsyncConnections(
                                        pDnsRec,
                                        pISMTPConnection,
                                        m_MsgOptions,
                                        m_pszSSLVerificationName,
                                        pDNS_RESOLVER_RECORD);
    if (fRet) {
        m_pISMTPConnection = NULL;
        m_pIMsg = NULL;
        m_AdvContext = NULL;
        m_RcptIndexList = NULL;
        m_NumRcpts = 0;

        DebugTrace((LPARAM)this, "RestartAsyncConnections succeeded.");

        //close the socket
        DisconnectClient();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      The m_pDnsRec encapsulates all the MX records for a target host for
//      this outbound connection. SMTP iterates through the MX records trying
//      to deliver to each in turn, till an MX host accepts delivery. The
//      m_pDnsRec contains within it, an index keeping track of which MX record
//      we are currently trying to deliver to. This function increments the
//      index to point to the next MX record (if any).
//  Arguments:
//      None.
//  Returns:
//      TRUE - StartRecord (the index) was successfully pointed to the next
//          MX record.
//      FALSE - No more MX records, we've tried and failed all of them.
//-----------------------------------------------------------------------------
BOOL SMTP_CONNOUT::SetDnsRecToNextMx()
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::SetDnsRecToNextIp");

    if (m_pDnsRec == NULL) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress becuase m_pDnsRec is NULL");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (m_pDnsRec->StartRecord > m_pDnsRec->NumRecords) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because StartRecord > NumRecords");
        TraceFunctLeaveEx((LPARAM) NULL);
        return FALSE;
    }

    if (m_pDnsRec->StartRecord == m_pDnsRec->NumRecords) {
        if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->NumRecords - 1]->IpListHead)) {
            ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because list is empty");
            TraceFunctLeaveEx((LPARAM) NULL);
            return FALSE;
        }

        m_pDnsRec->StartRecord = m_pDnsRec->NumRecords - 1;
    } else if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->StartRecord]->IpListHead)) {
        m_pDnsRec->StartRecord++;

        if (m_pDnsRec->StartRecord > m_pDnsRec->NumRecords) {
            TraceFunctLeaveEx((LPARAM) NULL);
            return FALSE;
        }

        if (m_pDnsRec->StartRecord == m_pDnsRec->NumRecords) {
            if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->NumRecords - 1]->IpListHead)) {
                TraceFunctLeaveEx((LPARAM) NULL);
                return FALSE;
            }

            m_pDnsRec->StartRecord = m_pDnsRec->NumRecords - 1;
        }
    }


    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

BOOL SMTP_CONNOUT::ReStartSession(void)
{
    BOOL fRet = TRUE;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ReStartSession( void)");

    DebugTrace((LPARAM) this,"restart session called because of new connection");

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_OutputBufferSize = 0;
    m_Error = NO_ERROR;
    m_NumRcptSent = 0;
    m_NumRcptSentSaved = 0;
    m_NumFailedAddrs = 0;
    m_SendAgain = FALSE;
    m_HaveDataResponse = FALSE;
    m_FirstPipelinedAddress = 0;

    m_FirstRcpt = FALSE;

    m_TransmitTailBuffer[0] = '.';
    m_TransmitTailBuffer[1] = '\r';
    m_TransmitTailBuffer[2] = '\n';

    m_TransmitBuffers.Head = NULL;
    m_TransmitBuffers.HeadLength = 0;
    m_TransmitBuffers.Tail = m_TransmitTailBuffer;
    m_TransmitBuffers.TailLength = 3;

    SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

    m_pIMsg = (IMailMsgProperties *) m_pDnsRec->pMailMsgObj;
    m_AdvContext = m_pDnsRec->pAdvQContext;
    m_RcptIndexList = (DWORD *) m_pDnsRec->pRcptIdxList;
    m_NumRcpts = m_pDnsRec->dwNumRcpts;

    m_pDnsRec->pMailMsgObj = NULL;
    m_pDnsRec->pAdvQContext = NULL;
    m_pDnsRec->pRcptIdxList = NULL;
    m_pDnsRec->dwNumRcpts = 0;

    // Bump both the remote and total recipient counters
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvdRemote, m_NumRcpts);
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvd, m_NumRcpts);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecips);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    hr = m_pBindInterface->GetBinding(&m_IMsgFileHandle, NULL);

    if(FAILED(hr))
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    DWORD fFoundEmbeddedCrlfDot = FALSE;
    DWORD fScanned = FALSE;

    m_LastClientIo = SMTP_CONNOUT::READIO;
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::StartSession - ReadFile failed with error %d", m_Error);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        DecPendingIoCount();
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        SetLastError(m_Error);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::CreateSmtpConnection

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNOUT
       class.  This class cannot be allocated on the stack.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.
      fUseSSL          Indiates whether the connection is to use SSL


    Returns:

       A pointer to an SMTP_CONNOUT class or NULL
--*/
SMTP_CONNOUT * SMTP_CONNOUT::CreateSmtpConnection (
                                                  IN PSMTP_SERVER_INSTANCE pInstance,
                                                  IN SOCKET sClient,
                                                  IN const SOCKADDR_IN *  psockAddrRemote,
                                                  IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
                                                  IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
                                                  IN PVOID                pTurnList/* = NULL*/ ,
                                                  IN DWORD                cbInitialData  /* = 0    */,
                                                  IN DWORD                Options /* = 0 */,
                                                  IN LPSTR                pszSSLVerificationName,
                                                  IN DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD)
{
    SMTP_CONNOUT * pSmtpObj;

    TraceFunctEnter("SMTP_CONNOUT::CreateSmtpConnection");

    pSmtpObj = new SMTP_CONNOUT (pInstance, sClient, psockAddrRemote, psockAddrLocal, pAtqContext,
                                 pTurnList, cbInitialData);
    if (pSmtpObj == NULL) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        FatalTrace(NULL, "new SMTP_CONNOUT failed (err=%d)", GetLastError());
        TraceFunctLeave();
        return NULL;
    }

    if (!pSmtpObj->InitializeObject(Options, pszSSLVerificationName, pDNS_RESOLVER_RECORD)) {
        ErrorTrace(NULL, "InitializeObject failed (err=%d)", GetLastError());
        delete pSmtpObj;
        TraceFunctLeave();
        return NULL;
    }


    if (pTurnList) {
        //Set the TURN domainlist
        pSmtpObj->SetTurnList((PTURN_DOMAIN_LIST)pTurnList);
    }

    TraceFunctLeave();
    return pSmtpObj;
}


/*++

    Name :
        SMTP_CONNOUT::SendSmtpResponse

    Description:
       This function sends data that was queued in the internal
       m_pOutputBuffer buffer

    Arguments:
         SyncSend - Flag that signifies sync or async send

    Returns:

      TRUE is the string was sent. False otherwise
--*/
BOOL SMTP_CONNOUT::SendSmtpResponse(BOOL SyncSend)
{
    BOOL RetStatus = TRUE;
    DWORD cbMessage = m_OutputBufferSize;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::SendSmtpResponse");

    //if m_OutputBufferSize > 0that means there is
    //something in the buffer, therefore, we will send it.

    if (m_OutputBufferSize) {
        //
        // If we are using SSL, encrypt the output buffer now. Note that
        // FormatSmtpMsg already left header space for the seal header.
        //
        if (m_SecurePort) {
            char *Buffer = &m_pOutputBuffer[m_encryptCtx.GetSealHeaderSize()];

            RetStatus = m_encryptCtx.SealMessage(
                                                (UCHAR *) Buffer,
                                                m_OutputBufferSize,
                                                (UCHAR *) m_pOutputBuffer,
                                                &cbMessage);
            if (!RetStatus)
            {
                ErrorTrace ((LPARAM)this, "Sealmessage failed");
                SetLastError(AQUEUE_E_SSL_ERROR);
            }
        }

        if (RetStatus) {
            RetStatus = CLIENT_CONNECTION::WriteFile(m_pOutputBuffer, cbMessage);
        }

        if (RetStatus) {
            ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, m_OutputBufferSize);
        } else {
            DebugTrace((LPARAM) this, "WriteFile failed with error %d", GetLastError());
        }

        m_OutputBufferSize = 0;
    }

    TraceFunctLeaveEx((LPARAM) this);

    return ( RetStatus );
}


/*++

    Name :
        SMTP_CONNOUT::FormatSmtpMessage( IN const char * Format, ...)

    Description:
        This function operates likes sprintf, printf, etc. It
        just places it's data in the output buffer.

    Arguments:
         Format - Data to place in the buffer

    Returns:


--*/
BOOL SMTP_CONNOUT::FormatSmtpMessage( FORMAT_SMTP_MESSAGE_LOGLEVEL eLogLevel, IN const char * Format, ...)
{
    int BytesWritten;
    va_list arglist;
    char *Buffer;
    DWORD AvailableBytes;

    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                          (m_encryptCtx.GetSealHeaderSize() +
                           m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &m_pOutputBuffer[m_OutputBufferSize + HeaderOffset];

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    va_start (arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);

    if (BytesWritten < 0) {
        //flush any pending response
        SendSmtpResponse();
        _ASSERT (m_OutputBufferSize == 0);
        Buffer = &m_pOutputBuffer[HeaderOffset];
        AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
        BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
        _ASSERT (BytesWritten > 0);
    }
    va_end(arglist);

    // log this transaction
    ProtocolLogCommand(Buffer, BytesWritten, QueryClientHostName(), eLogLevel);

    m_OutputBufferSize += (DWORD) BytesWritten;

    //m_OutputBufferSize += vsprintf (&m_OutputBuffer[m_OutputBufferSize], Format, arglist);

    return TRUE;
}


/*++

    Name :
        SMTP_CONNOUT::FormatBinaryBlob(IN PBYTE pbBlob, IN DWORD cbSize)

    Description:
        Places pbBlob of size cbSize into buffer

    Arguments:
        pbBlob - blob to place in the buffer
        cbSize - blob size

    Returns:
        BOOL

--*/
BOOL SMTP_CONNOUT::FormatBinaryBlob( IN PBYTE pbBlob, IN DWORD cbSize)
{
    char *Buffer;
    DWORD AvailableBytes;

    TraceQuietEnter( "SMTP_CONNOUT::FormatBinaryBlob");

    DWORD HeaderOffset = ( m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = ( m_SecurePort ?
                          ( m_encryptCtx.GetSealHeaderSize() +
                           m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &m_pOutputBuffer[ m_OutputBufferSize + HeaderOffset];
    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    while ( AvailableBytes < cbSize) {
        memcpy( Buffer, pbBlob, AvailableBytes);
        pbBlob += AvailableBytes;
        cbSize -= AvailableBytes;
        m_OutputBufferSize += AvailableBytes;
        SendSmtpResponse();
        _ASSERT ( m_OutputBufferSize == 0);
        Buffer = &m_pOutputBuffer[ HeaderOffset];
        AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
    }

    memcpy( Buffer, pbBlob, cbSize);
    m_OutputBufferSize += cbSize;

    return TRUE;
}


/*++

    Name :
        SMTP_CONNOUT::ProcessWriteIO

    Description:
         Handles an async write completion event.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:
      TRUE if the object should continue to survive
      FALSE if the object should be deleted
--*/
BOOL SMTP_CONNOUT::ProcessWriteIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    CBuffer* pBuffer;

    TraceQuietEnter("SMTP_CONNOUT::ProcessWriteIO");

    _ASSERT(IsValid());
    _ASSERT(lpo);
    pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;


    //
    // check for partial completions or errors
    //
    if ( pBuffer->GetSize() != InputBufferLen || dwCompletionStatus != NO_ERROR ) {
        ErrorTrace( (LPARAM)this,
                    "WriteFile error: %d, bytes %d, expected: %d, lpo: 0x%08X",
                    dwCompletionStatus,
                    InputBufferLen,
                    pBuffer->GetSize(),
                    lpo );

        m_Error = dwCompletionStatus;
        SetDiagnosticInfo(HRESULT_FROM_WIN32(dwCompletionStatus), NULL, NULL);

        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        return ( FALSE );
    } else {
        DebugTrace( (LPARAM)this,
                    "WriteFile complete. bytes %d, lpo: 0x%08X",
                    InputBufferLen, lpo );
    }

    //
    // free up IO buffer
    //
    delete  pBuffer;

    //
    // increment only after write completes
    //
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentMsg, InputBufferLen);
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, InputBufferLen);

    DebugTrace( (LPARAM)this, "m_bComplete: %s",
                m_bComplete ? "TRUE" : "FALSE" );

    return ( TRUE );
}

/*++

    Name :
        SMTP_CONNOUT::ProcessTransmitFileIO

    Description:
         processes the return from TransmitFile.
         Right not it just posts a read.

    Arguments:

    Returns:

      TRUE
--*/

BOOL SMTP_CONNOUT::ProcessTransmitFileIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ProcessTransmitFileIO");

    _ASSERT(IsValid());

    //we need to set this outside of the if statement,
    //because we will always have a read pended
    m_LastClientIo = SMTP_CONNOUT::READIO;

    if (dwCompletionStatus != NO_ERROR) {
        m_Error = dwCompletionStatus;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DebugTrace((LPARAM) this, "TranmitFile in ProcessTransmitFileIO failed with error %d !!!!", dwCompletionStatus);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        DisconnectClient();
        TraceFunctLeave();
        return FALSE;
    }

    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentMsg, InputBufferLen);
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, InputBufferLen);

    //pend an IO to pickup the "250 XXXX queued for delivery response"
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "ReadFile in ProcessTransmitFileIO failed with error %d !!!!", m_Error);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        DisconnectClient();
        DecPendingIoCount();
    }

    TraceFunctLeave();
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::WaitForConnectResponse

    Description:
         This function gets called when the SMTP
         server sends it's opening response

    Arguments:
        InputLine - Buffer containing opening response
        ParameterSize - Size of opening response

    Returns:

      TRUE if Object is not to be destroyed
      FALSE if Object is to be destroyed
--*/
BOOL SMTP_CONNOUT::WaitForConnectResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    BOOL IsNextLine;
    DWORD    Error;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::WaitForConnectResponse");

    //get rid of all continuation lines
    while ((pszSearch = IsLineComplete(InputLine, ParameterSize))) {
        *pszSearch = '\0';

        //calculate the length of the line, with the CRLF
        IntermediateSize = (DWORD)((pszSearch - InputLine) + 2);

        //
        // The response is not RFC-compliant. It lacks the 3 digit status - drop
        // connection. We need to do the minimum possible amount of processing of
        // the input from this point on. Many SMTP_CONNOUT functions make assumptions
        // about the well-formedness of the input, and will have problems if an
        // RFC-violating InputLine is passed into them. For example DoCompletedMessage
        // assumes that InputLine[0] is a digit at the very least. The safe thing to
        // do is to disconnect and delete this object.
        //

        if(IntermediateSize < 5 || !isdigit((UCHAR)InputLine[0]) ||
                !isdigit((UCHAR)InputLine[1]) || !isdigit((UCHAR)InputLine[2]))
        {
            ErrorTrace((LPARAM)this, "Received non RFC compliant response %s", InputLine);
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, NULL, NULL);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        //check to see if there is a continuation line
        if(IntermediateSize >= 5)
            IsNextLine = (InputLine[3] == '-');
        else
            IsNextLine = FALSE;


        ShrinkBuffer(
                    pszSearch + 2,
                    ParameterSize - IntermediateSize + UndecryptedTailSize);
        ParameterSize -= IntermediateSize;
    }

    //If ParameterSize is > 0 but pszSearch == NULL, this means
    //there is data in the buffer, but it does not have a CRLF
    //to delimit it, therefore, we need more data to continue.
    //set m_cbReceived equal to where in our input buffer we
    //should pend another read and then return TRUE to pend
    //that read.

    if (ParameterSize != 0) {
        //if we need more data, move the remaining data to the
        //front of the buffer

        MoveMemory(
                  (void *)QueryMRcvBuffer(),
                  InputLine,
                  ParameterSize + UndecryptedTailSize);
        m_cbParsable = ParameterSize;
        m_cbReceived = ParameterSize + UndecryptedTailSize;
        return (TRUE);
    } else if (IsNextLine) {
        m_cbParsable = 0;
        m_cbReceived = UndecryptedTailSize;
        return (TRUE);
    } else {
        BOOL    fResult = TRUE;

        //we got a line that is not a continuation line.
        // Process the connect response
        switch (InputLine [0]) {
        case SMTP_COMPLETE_FAILURE:
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, NULL, NULL);
            DisconnectClient();
            InputLine [3] = '\0';
            Error = atoi (InputLine);
            InputLine [3] = ' ';
            SaveToErrorFile(InputLine, ParameterSize);
            SaveToErrorFile("\r\n", 2);
            fResult = FALSE;
            break;

        case SMTP_COMPLETE_SUCCESS: {
            //If the domain has been specified to use only HELO then we
            //fake it such that EHLO has been already sentand failed
            if (m_MsgOptions & DOMAIN_INFO_USE_HELO )
                m_EhloFailed = TRUE;

            // copy the domain name from the ehlo banner
            strncpy(m_ConnectedDomain, &InputLine[4], sizeof(m_ConnectedDomain)-1);
            // trunc at the first space
            char *pszSpace = strchr(m_ConnectedDomain, ' ');
            if (pszSpace) *pszSpace = 0;

            fResult = DoSessionStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
            break;
        }

        default:
            ErrorTrace( (LPARAM) this,
                        "SMTP_CONNOUT::WaitForConnectResponse executing quit command err = %c%c%c",
                        InputLine [0],
                        InputLine [1],
                        InputLine [2]);
            //
            // Set the error code for DoCompletedMessage to use. We want DoCompletedMessage
            // to issue the QUIT command, so this must be SMTP_SERVICE_UNAVAILABLE_CODE which
            // is a fatal error. Specifically, we do *NOT* want DoCompletedMessage to issue RSET
            // and try to call StartSession again for errors in the connect response.
            //

            m_ResponseContext.m_dwSmtpStatus = SMTP_SERVICE_UNAVAILABLE_CODE;
            hr = m_ResponseContext.m_cabResponse.Append(
                                           (PCHAR)SMTP_SRV_UNAVAIL_STR,
                                           strlen(SMTP_SRV_UNAVAIL_STR),
                                           NULL);
            if (FAILED(hr))
            {
                //
                // This is probably an out of memory error, just kill the session.
                // We cannot call DoCompletedMessage which does extra stuff like
                // failover the connection to an alternate host since DoCompletedMessage
                // relies on the m_cabResponse being set.
                //

                ErrorTrace((LPARAM) this,
                    "Unable to append Input line to Response Context", hr);
                SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, NULL, NULL);
                return FALSE;
            }

            fResult = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
            break;
        }

        TraceFunctLeaveEx((LPARAM)this);
        return fResult;
    }
}


/*++

    Name :
        SMTP_CONNOUT::ProcessReadIO

    Description:
        This function gets a buffer from ATQ, parses the buffer to
        find out what command the client sent, then executes that
        command.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.
--*/
BOOL SMTP_CONNOUT::ProcessReadIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fReturn = TRUE;
    char * InputLine = NULL;
    char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    DWORD UndecryptedTailSize = 0;
    PMFI  PreviousState = NULL;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::ProcessReadIO");

    //make sure the next state is not NULL
    _ASSERT(m_NextState != NULL || m_fNegotiatingSSL);
    _ASSERT(IsValid());

    //get a pointer to our buffer
    InputLine = (char *) QueryMRcvBuffer();

    //add up the number of bytes we received thus far
    m_cbReceived += InputBufferLen;

    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdTotal, InputBufferLen);

    //if we are in the middle of negotiating a SSL session, handle it now.
    if (m_fNegotiatingSSL) {

        fReturn = DoSSLNegotiation(QueryMRcvBuffer(),InputBufferLen, 0);

        if (!fReturn) {
            m_Error = GetLastError();
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DisconnectClient();
        }

        return ( fReturn );
    }

    //if we are using the secure port, decrypt the input buffer now.
    if (m_SecurePort) {

        fReturn = DecryptInputBuffer();

        if (!fReturn) {
            m_Error = GetLastError();
            SetDiagnosticInfo(AQUEUE_E_SSL_ERROR, NULL, NULL);
            return ( fReturn );
        }
    } else {
        m_cbParsable = m_cbReceived;
    }


    //we only process lines that have CRLFs at the end, so if
    //we don't find the CRLF pair, pend another read.  Note
    //that we start at the end of the buffer looking for the
    //CRLF pair.  We just need to know if atleast one line
    //has a CRLF to continue.
    if ((pszSearch = IsLineCompleteBW(InputLine,m_cbParsable, m_cbMaxRecvBuffer)) == NULL) {
        if (m_cbReceived >= m_cbMaxRecvBuffer)
            m_cbReceived = 0;

        IncPendingIoCount();
        fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, m_cbMaxRecvBuffer - m_cbReceived);
        if (!fReturn) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - ReadFile # 1 failed with error %d", m_Error);
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
        }

        TraceFunctLeaveEx((LPARAM)this);
        return fReturn;
    }

    //save the number of bytes that we received,
    //so we can pass it to the function call below.
    //we set m_cbReceived = 0, because other functions
    //will set it the offset in the buffer where we
    //should pend the next read.
    IntermediateSize = m_cbParsable;
    UndecryptedTailSize = m_cbReceived - m_cbParsable;
    m_cbParsable = 0;
    m_cbReceived = 0;

    //save the previous state
    PreviousState = m_NextState;

    ProtocolLogResponse(InputLine, IntermediateSize, QueryClientHostName());

    //execute the next state
    fReturn = (this->*m_NextState)(InputLine, IntermediateSize, UndecryptedTailSize);
    if (fReturn) {
        //if we are in STARTTLS state, don't pend a read since
        //DoSSLNegotiation would have pended a read
        if ((m_NextState == &SMTP_CONNOUT::DoSTARTTLSCommand) &&
            (m_TlsState == SSL_NEG)) {
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we are in middle of SSL negotiation");
            TraceFunctLeaveEx((LPARAM)this);
            return fReturn;
        }

        //do't pend a read if the previous state was
        //DoDataCommandEx.  We want either the transmitfile
        //or the read to fail.  Not both.  Later, we will fix
        //it right for both to complete concurrently.
        if (PreviousState == &SMTP_CONNOUT::DoDATACommandEx) {
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we did a transmitfile");
            TraceFunctLeaveEx((LPARAM)this);
            return fReturn;
        } else if (m_fUseBDAT) {
            //We also don't want to pend a read if we did BDAT processing
            //It is a special case, because of the fact that DoBDATCommand synchronously
            //calls DoDATACommandEx without pending a read. So we never come thru here and get
            //chance to set PreviousState = DoDATACommandEx
            //So I have to hack it

            if ((m_NextState == &SMTP_CONNOUT::DoContentResponse) ||
                (m_SendAgain && (m_NextState == &SMTP_CONNOUT::DoMessageStartEvent))) {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we did a transmitfile");
                TraceFunctLeaveEx((LPARAM)this);
                return fReturn;
            }
        }

        if (m_cbReceived >= m_cbMaxRecvBuffer)
            m_cbReceived = 0;

        IncPendingIoCount();
        fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, m_cbMaxRecvBuffer - m_cbReceived);
        if (!fReturn) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - ReadFile # 2 failed with error %d", m_Error);
        }

    }

    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNOUT::ProcessFileIO

    Description:
        Handles completion of an async read issued against a message file by
        MessageReadFile

    Arguments:
        cbRead              count of bytes read
        dwCompletionStatus  Error code for IO operation
        lpo                 Overlapped structure

    Returns:
        TRUE if connection should stay open
        FALSE if this object should be deleted

--*/
BOOL SMTP_CONNOUT::ProcessFileIO(
                                IN      DWORD       BytesRead,
                                IN      DWORD       dwCompletionStatus,
                                IN OUT  OVERLAPPED  *lpo
                                )
{
    CBuffer* pBuffer;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::ProcessFileIO");

    _ASSERT(lpo);
    pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

    //
    // check for partial completions or errors
    //
    if ( BytesRead != pBuffer->GetSize() || dwCompletionStatus != NO_ERROR ) {
        ErrorTrace( (LPARAM)this,
                    "Message ReadFile error: %d, bytes %d, expected %d",
                    dwCompletionStatus,
                    BytesRead,
                    pBuffer->GetSize() );

        m_Error = dwCompletionStatus;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_dwConnectionStatus), NULL, NULL);
        return ( FALSE );
    } else {
        DebugTrace( (LPARAM)this,
                    "ReadFile complete. bytes %d, lpo: 0x%08X",
                    BytesRead, lpo );
    }

    m_bComplete = (m_dwFileOffset + BytesRead) >= m_FileSize;

    m_dwFileOffset += BytesRead;

    //
    // If anything to write to the client
    //
    if ( BytesRead > 0 ) {
        //
        // set buffer specific IO state
        //
        pBuffer->SetIoState( CLIENT_WRITE );
        pBuffer->SetSize( BytesRead );

        ZeroMemory( (void*)&pBuffer->m_Overlapped.SeoOverlapped, sizeof(OVERLAPPED) );

        DebugTrace( (LPARAM)this, "WriteFile 0x%08X, len: %d, LPO: 0x%08X",
                    pBuffer->GetData(),
                    BytesRead,
                    &pBuffer->m_Overlapped.SeoOverlapped.Overlapped );

        //
        // If we're on the SSL port, encrypt the data.
        //
        if ( m_SecurePort ) {
            //
            // Seal the message in place as we've already reserved room
            // for both the header and trailer
            //
            if ( m_encryptCtx.SealMessage(  pBuffer->GetData() +
                                            m_encryptCtx.GetSealHeaderSize(),
                                            BytesRead,
                                            pBuffer->GetData(),
                                            &BytesRead ) == FALSE ) {
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                m_Error = GetLastError();
                ErrorTrace( (LPARAM)this, "SealMessage failed. err: %d", m_Error);
                SetDiagnosticInfo(AQUEUE_E_SSL_ERROR, NULL, NULL);
                DisconnectClient();
            } else {
                //
                // adjust the byte count to include header and trailer
                //
                _ASSERT(BytesRead == pBuffer->GetSize() +
                        m_encryptCtx.GetSealHeaderSize() +
                        m_encryptCtx.GetSealTrailerSize() );

                pBuffer->SetSize( BytesRead );
            }
        }

        IncPendingIoCount();
        if ( WriteFile( pBuffer->GetData(),
                        BytesRead,
                        (LPOVERLAPPED)&pBuffer->m_Overlapped ) == FALSE ) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            //
            // reset the bytes read so we drop out
            //
            BytesRead = 0;
            ErrorTrace( (LPARAM)this, "WriteFile failed (err=%d)", m_Error );
            delete  pBuffer;

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);

            //
            // treat as fatal error
            //
            DisconnectClient( );
            //
            // cleanup after write failure
            //
            DecPendingIoCount();

        }
    }

    if ( m_bComplete ) {
        BOOL fRet = TRUE;

        //FreeAtqFileContext();

        //We do not have any trailers to write if we are processing BDAT
        //
        if (!m_fUseBDAT) {
            if (m_SecurePort) {
                //Nimishk : Is this right ***
                m_OutputBufferSize = m_cbMaxOutputBuffer;

                fRet = m_encryptCtx.SealMessage(
                                               (LPBYTE) m_TransmitBuffers.Tail,
                                               m_TransmitBuffers.TailLength,
                                               (LPBYTE) m_pOutputBuffer,
                                               &m_OutputBufferSize);

                if (fRet)
                    fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            } else {
                fRet = WriteFile(
                                (LPVOID)m_TransmitBuffers.Tail,
                                m_TransmitBuffers.TailLength );
            }
        }
        m_OutputBufferSize = 0;

        IncPendingIoCount();
        if (fRet) {
            //pend an IO to pickup the "250 XXXX queued for delivery response"
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
        }
        if (!fRet) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "Error %d sending tail or posting read", m_Error);
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
        }
        return ( fRet );
    } else {
        return (MessageReadFile());
    }
}

/*++

    Name :
        SMTP_CONNOUT::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_CONNOUT::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL RetStatus;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::ProcessClient");

    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if ((lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT)) {
        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //

        SetDiagnosticInfo(HRESULT_FROM_WIN32(ERROR_SEM_TIMEOUT), NULL, NULL);
        IncPendingIoCount();

        m_Error = dwCompletionStatus;
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessClient: -  Timing out");
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;

        DisconnectClient();
    } else if ((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR)) {
        //if InputBufferLen == 0, then the connection was closed.
        if (m_Error == NO_ERROR)
            m_Error = ERROR_BROKEN_PIPE;

        SetDiagnosticInfo(AQUEUE_E_CONNECTION_DROPPED, NULL, NULL);

        //
        // If the lpo points to an IO buffer allocated for SSL IO, delete it
        //

        if (lpo != NULL &&
            lpo != &m_Overlapped &&
            lpo != &QueryAtqContext()->Overlapped) {
            CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

            delete pBuffer;
        }

        DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d  - Closing connection", InputBufferLen, dwCompletionStatus);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
    } else if (lpo == &m_Overlapped || lpo == &QueryAtqContext()->Overlapped
               || lpo == (OVERLAPPED *) &m_SeoOverlapped) {

        switch (m_LastClientIo) {
        case SMTP_CONNOUT::READIO:
            RetStatus = ProcessReadIO (InputBufferLen, dwCompletionStatus, lpo);
            break;
        case SMTP_CONNOUT::TRANSFILEIO:
            RetStatus = ProcessTransmitFileIO (InputBufferLen, dwCompletionStatus, lpo);
            break;
        default:
            _ASSERT (FALSE);
            RetStatus = FALSE;
            break;
        }
    } else {
        //
        // This lpo belongs to a CBuffer allocated for message transfers using
        // async reads and writes.
        //

        CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

        if (pBuffer->GetIoState() == MESSAGE_READ) {
            RetStatus = ProcessFileIO(InputBufferLen, dwCompletionStatus, lpo);
        } else {
            _ASSERT( pBuffer->GetIoState() == CLIENT_WRITE );
            RetStatus = ProcessWriteIO(InputBufferLen, dwCompletionStatus, lpo);
        }

    }

    DecThreadCount();

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //
    if ( DecPendingIoCount() == 0 ) {
        if (m_dwConnectionStatus == CONNECTION_STATUS_DROPPED) {
            if (!QuerySmtpInstance()->IsShuttingDown())
                ConnectToNextIpAddress();
        }

        DebugTrace( (LPARAM)this,"Num Threads: %d",m_cActiveThreads);
        _ASSERT( m_cActiveThreads == 0 );
        m_Active = FALSE;
        RetStatus = FALSE;
    } else {
        DebugTrace( (LPARAM)this,"SMTP_CONNOUT::ProcessClient Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_CONNOUT::ProcessClient Num Threads: %d",m_cActiveThreads);
        RetStatus = TRUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNOUT::DoSSLNegotiation

    Description:
        Does the SSL Handshake with a remote SMTP server.

    Arguments:

    Returns:
        TRUE if successful so far
        FALSE if this object should be deleted

--*/

BOOL SMTP_CONNOUT::DoSSLNegotiation(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE, fMore, fPostRead;
    DWORD dwErr;
    HRESULT hr = S_OK;
    ULONG cbExtra = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::DoSSLNegotiations");

    m_OutputBufferSize = m_cbMaxOutputBuffer;

    dwErr = m_encryptCtx.Converse(
                                 QueryMRcvBuffer(),
                                 m_cbReceived,
                                 (LPBYTE) m_pOutputBuffer,
                                 &m_OutputBufferSize,
                                 &fMore,
                                 (LPSTR) QueryLocalHostName(),
                                 (LPSTR) QueryLocalPortName(),
                                 (LPVOID) QuerySmtpInstance(),
                                 QuerySmtpInstance()->QueryInstanceId(),
                                 &cbExtra
                                 );

    if (dwErr == NO_ERROR) {

        //
        // reset the receive buffer
        //
        if (cbExtra)
            MoveMemory (QueryMRcvBuffer(), QueryMRcvBuffer() + (m_cbReceived - cbExtra), cbExtra);
        m_cbReceived = cbExtra;

        if (m_OutputBufferSize != 0) {
            // Send the last negotiation blob to the server and start with Encrypting.
            // Reset the output buffer size
            fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            m_OutputBufferSize = 0;
        }

        if (fMore) {
            fPostRead = TRUE;
        } else {
            m_fNegotiatingSSL = FALSE;

            if (ValidateSSLCertificate ()) {
                m_TlsState = CHANNEL_SECURE;

                //If we negotiated because of STARTTLS, we need to send EHLO and get the
                //options all over again. According to jump_thru_hoops draft
                if (IsOptionSet(STARTTLS_OPTION)) {
                    //Do ehlo again - this to get the response
                    _ASSERT(m_EhloFailed == FALSE);
                    char szInput[25];
                    strcpy(szInput,"220 OK");
                    fRet = DoSessionStartEvent(szInput, strlen(szInput), 0);

                } else if (!(m_MsgOptions & KNOWN_AUTH_FLAGS)) {
                    if (m_MsgOptions & EMPTY_CONNECTION_OPTION) {
                        fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
                    } else {
                        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
                    }
                } else {
                    fRet = DoSASLCommand(InputLine, ParameterSize, UndecryptedTailSize);
                }

                fPostRead = fRet;
            } else {
                fPostRead = fRet = FALSE;
                //Fill in the response context buffer so as to generate the right response
                // Get the error code
                m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
                hr = m_ResponseContext.m_cabResponse.Append(
                                                           (char *)SMTP_REMOTE_HOST_REJECTED_SSL,
                                                           strlen(SMTP_REMOTE_HOST_REJECTED_SSL),
                                                           NULL);
            }
        }

        if (fPostRead) {
            //
            // The negotiation is going well so far, but there is still more
            // negotiation to do. So post a read to receive the next leg of
            // the negotiation.
            //

            DebugTrace((LPARAM) this,"StartSession negotiating SSL");

            IncPendingIoCount();
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer() + cbExtra, m_cbMaxRecvBuffer - cbExtra);
            if (!fRet) {
                dwErr = GetLastError();
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSSLNegotiation failed %d", m_Error);
                DecPendingIoCount();
                SetLastError(dwErr);
                SetDiagnosticInfo(HRESULT_FROM_WIN32(dwErr), NULL, NULL);
                //Fill in the response context buffer so as to generate the right response
                // Get the error code
            }
        }

    } else {
        fRet = FALSE;
        SetLastError(ERROR_NO_SECURITY_ON_OBJECT);
        SetDiagnosticInfo(AQUEUE_E_TLS_NOT_SUPPORTED_ERROR, NULL, NULL);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return ( fRet );
}

//----------------------------------------------------------------------------------
//  Description:
//      Check to see if the SSL cert is valid:
//       (1) Always check if it has expired.
//       (2) If configured, check if the issuer is trusted.
//       (3) If configured, check if the subject matches who we are sending to. This
//           is not simply the server-fqdn we are connected to. Since the server-fqdn
//           may have been obtained via DNS (through MX or CNAME indirection), and
//           since DNS is an insecure protocol, we cannot trust that for the subject.
//           Instead we will use the domain we were passed in prior to DNS... the
//           one passed into the REMOTE_QUEUE. This domain name is passed into
//           SMTP_CONNOUT when it is created as m_pszSSLVerificationDomain. We will
//           do some wildcard matching as well if the certificate subject has the
//           '*' character in it (see simssl.cpp). m_pszSSLVerificationName may be
//           NULL if there is no target hostname --- such as in the case of a literal
//           IP address. In this case, subject verification is skipped.
//  Returns:
//      TRUE - success, certificate verified
//      FALSE - failure, stick queue into retry
//----------------------------------------------------------------------------------
BOOL SMTP_CONNOUT::ValidateSSLCertificate ()
{
    BOOL fRet = FALSE;
    DWORD dwAQDiagnostic = 0;

    TraceFunctEnterEx ((LPARAM) this, "SMTP_CONNECTION::ValidateCertificate");

    fRet = m_encryptCtx.CheckCertificateExpired();
    if (!fRet) {
        ErrorTrace ((LPARAM) this, "SSL Certificate Expired");
        dwAQDiagnostic = AQUEUE_E_SSL_CERT_EXPIRED;
        goto Exit;
    }

    if (m_pInstance->RequiresSSLCertVerifyIssuer()) {

        DebugTrace ((LPARAM) this, "Verifying certificate issuing authority");

        //
        //  Failure in these checks could occur due to temporary conditions (like
        //  out of memory). So the AQueue diagnostic is not 100% accurate, but it's
        //  OK as we don't NDR message. Anyway we DID fail during cert validation.
        //

        fRet = m_encryptCtx.CheckCertificateTrust();
        if (!fRet) {
            ErrorTrace ((LPARAM) this, "SSL Certificate trust verification failure");
            dwAQDiagnostic = AQUEUE_E_SSL_CERT_ISSUER_UNTRUSTED;
            goto Exit;
        }
    }

    if (!m_pszSSLVerificationName) {
        DebugTrace ((LPARAM) this,
            "Skipping certificate subject validation, no name to validate against");
        goto Exit;
    }

    DebugTrace ((LPARAM) this,
        "Validating certificate subject against: %s", m_pszSSLVerificationName);

    fRet = m_encryptCtx.CheckCertificateSubjectName (m_pszSSLVerificationName);
    if (!fRet) {
        ErrorTrace ((LPARAM) this, "SSL certificate subject verification failure");
        dwAQDiagnostic = AQUEUE_E_SSL_CERT_SUBJECT_MISMATCH;
    }
Exit:
    if (!fRet && dwAQDiagnostic)
        SetDiagnosticInfo(dwAQDiagnostic, NULL, NULL);

    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;

}

/*++

    Name :
        void SMTP_CONNECTION::SkipWord

    Description:
        skips over words in a buffer and
        returns pointer to next word

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully decrypted, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::DecryptInputBuffer(void)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNOUT::DecryptInputBuffer");

    DWORD   cbExpected;
    DWORD   cbReceived;
    DWORD   cbParsable;
    DWORD   dwError;

    dwError = m_encryptCtx.DecryptInputBuffer(
                                             (LPBYTE) QueryMRcvBuffer() + m_cbParsable,
                                             m_cbReceived - m_cbParsable,
                                             &cbReceived,
                                             &cbParsable,
                                             &cbExpected );

    if ( dwError == NO_ERROR ) {
        //
        // new total received size is the residual from last processing
        // and whatever is left in the current decrypted read buffer
        //
        m_cbReceived = m_cbParsable + cbReceived;


        //
        // new total parsable size is the residual from last processing
        // and whatever was decrypted from this read io operation
        //
        m_cbParsable += cbParsable;
    } else {
        //
        // errors from this routine indicate that the stream has been
        // tampered with or we have an internal error
        //
        ErrorTrace( (LPARAM)this,
                    "DecryptInputBuffer failed: 0x%08X",
                    dwError );
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;

        DisconnectClient( dwError );
    }

    TraceFunctLeaveEx((LPARAM)this);
    return ( dwError == NO_ERROR );
}

BOOL SMTP_CONNOUT::DoSASLNegotiation(char *InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BUFFER BuffOut;
    DWORD BytesRet = 0;
    BOOL fMoreData = FALSE;
    BOOL fRet = TRUE;
    BOOL fReturn = TRUE;
    DomainInfo DomainParams;
    LPSTR szClearTextPassword = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSASLNegotiation");

    //we need to receive a 354 from the server to go on
    if (InputLine[0] == SMTP_INTERMEDIATE_SUCCESS) {

        if (m_AuthToUse & SMTP_AUTH_NTLM || m_AuthToUse & SMTP_AUTH_KERBEROS) {

            if (m_securityCtx.ClientConverse(
                    InputLine + 4, ParameterSize - 4, &BuffOut, &BytesRet,
                        &fMoreData, &AuthInfoStruct, m_szAuthPackage,
                            NULL, NULL, (PIIS_SERVER_INSTANCE) m_pInstance)) {

                if (BytesRet) {
                    FormatSmtpMessage(FSM_LOG_NONE, "%s\r\n", BuffOut.QueryPtr());
                    SendSmtpResponse();
                }

            } else {

                DebugTrace((LPARAM) this, "m_securityCtx.Converse failed - %d",
                    GetLastError());

                m_Error = ERROR_LOGON_FAILURE;

                //Fill in the response context buffer so as to generate the right response
                // Get the error code

                m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;

                hr = m_ResponseContext.m_cabResponse.Append(
                           (char *)SMTP_REMOTE_HOST_REJECTED_AUTH,
                           strlen(SMTP_REMOTE_HOST_REJECTED_AUTH),
                           NULL);

                fRet = FALSE;

                SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
            }
        } else {

            ZeroMemory (&DomainParams, sizeof(DomainParams));

            DomainParams.cbVersion = sizeof(DomainParams);

            hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);

            if (FAILED(hr)) {

                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                DisconnectClient();
                SetLastError(m_Error = ERROR_LOGON_FAILURE);
                SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;

            }

            szClearTextPassword = DomainParams.szPassword;
            if (!szClearTextPassword) szClearTextPassword = "";

            fReturn = uuencode ((unsigned char *)szClearTextPassword,
                            lstrlen(szClearTextPassword), &BuffOut, FALSE);

            if (fReturn) {

                FormatSmtpMessage(FSM_LOG_NONE, "%s\r\n", BuffOut.QueryPtr());
                SendSmtpResponse();

            } else {

                m_Error = GetLastError();
                SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
                fRet = FALSE;

            }
        }
    } else if (InputLine[0] == SMTP_COMPLETE_SUCCESS) {

        if (m_MsgOptions & EMPTY_CONNECTION_OPTION) {
            fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        } else {
            fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }

    } else {

        fRet = FALSE;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Error = ERROR_LOGON_FAILURE;
        SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
        DisconnectClient();

    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::DoEHLOCommand

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoEHLOCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoEHLOCommand");

    m_OutboundContext.m_cabNativeCommand.Reset();

    if (m_EhloFailed)
    {
        //server did not understand EHLO command, so
        //just send the HELO command
        m_HeloSent = TRUE;
        fRet = PE_AppendSmtpMessage("HELO ");
    } else {
        fRet = PE_AppendSmtpMessage("EHLO ");
    }

    if (fRet) {
        QuerySmtpInstance()->LockGenCrit();
        fRet = PE_AppendSmtpMessage(QuerySmtpInstance()->GetFQDomainName());
        QuerySmtpInstance()->UnLockGenCrit();
    }

    if (fRet)
        fRet = PE_AppendSmtpMessage("\r\n");
    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    m_EhloSent = TRUE;
    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}


/*++

    Name :
        SMTP_CONNOUT::DoEHLOResponse

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoEHLOResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL    fGotAllOptions;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoEHLOResponse");
    char chInputGood = 0;
    BOOL fEndSession = FALSE;

    if ( isdigit( (UCHAR)InputLine[1] ) &&  isdigit( (UCHAR)InputLine[2] ) &&   ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
        chInputGood = InputLine[0];
    } else {
        chInputGood = SMTP_COMPLETE_FAILURE;
        fEndSession = TRUE;
    }


    //get the response
    switch ( chInputGood ) {
    case SMTP_COMPLETE_SUCCESS:

        m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;
        fGotAllOptions = GetEhloOptions(
                                       InputLine,
                                       ParameterSize,
                                       UndecryptedTailSize,
                                       m_HeloSent);
        _ASSERT(fGotAllOptions);
        if (IsOptionSet(ETRN_ONLY_OPTION) && !IsOptionSet(ETRN_OPTION)) {
            //We have no messages to send... only ETRN, but ETRN is not
            //supported by the remote server, we should send quit
            m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
            m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
        }

        break;

    case SMTP_COMPLETE_FAILURE:

        //if the HELO was sent and we got a 55X reply,
        //just quit. This server is hosed.
        if ( m_HeloSent || fEndSession ) {
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoEHLOCommand executing quit command err from client = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
            m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
            m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, m_HeloSent ? "HELO" : "EHLO", InputLine);
        } else {
            //server did not understand EHLO command, so
            //just send the HELO command
            m_EhloFailed = TRUE;
            m_ResponseContext.m_dwResponseStatus = EXPE_REPEAT_COMMAND;
        }
        break;

    default:
        DebugTrace((LPARAM) this,
                   "SMTP_CONNOUT::DoEHLOCommand executing quit command err = %c%c%c",
                   InputLine [0],InputLine [1],InputLine [2]);
        m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
        m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
        m_OutboundContext.m_pCurrentCommandContext = NULL;
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, m_HeloSent ? "HELO" : "EHLO", InputLine);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}

/*++

    Name :

        SMTP_CONNOUT::GetEhloOptions(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)

    Description:

        Parses the response from the EHLO command

    Arguments:
        Line containing the response and line size

    Returns:
        TRUE if it parses all data
        FALSE if it needs more data to continue parsing

--*/
BOOL SMTP_CONNOUT::GetEhloOptions(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL fIsHelo)
{
    register char * pszValue = NULL;
    register char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    BOOL IsNextLine = FALSE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::GetEhloOptions");

    //get each line and parse the commands
    while ((pszSearch = IsLineComplete(InputLine, ParameterSize)) != NULL) {
        //Null terminate the end of the option
        *pszSearch = '\0';

        //check to see if there is a continuation line
        IsNextLine = (InputLine[3] == '-');

        IntermediateSize= (DWORD)((pszSearch - InputLine) + 2); //+2 for CRLF


        // Only process if it is an EHLO command, otherwise, just
        // eat up all the response data.
        if (!fIsHelo) {
            //skip over code and space
            //look for a space in the line.
            //options that have paramters
            //need to have a space after
            //their name
            pszValue = strchr(InputLine + 4, ' ');

            //does the server support the SIZE option ???
            if (strncasecmp(InputLine + 4, (char * )"SIZE", 4) == 0) {
                //yes sireee bob. If the server advertised
                //a maximum file size, get it while we are
                //here.
                m_Flags |= SIZE_OPTION;
                if (pszValue != NULL)
                    m_SizeOptionSize = atoi (pszValue);
            } else if (strcasecmp(InputLine + 4, (char * )"PIPELINING") == 0) {
                m_Flags |= PIPELINE_OPTION;
            } else if (strcasecmp(InputLine + 4, (char * )"8bitmime") == 0) {
                m_Flags |= EBITMIME_OPTION;
            } else if (strcasecmp(InputLine + 4, (char * )"dsn") == 0) {
                m_Flags |= DSN_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"TLS", 3) == 0) {
                m_Flags |= TLS_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"STARTTLS", 8) == 0) {
                m_Flags |= STARTTLS_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"ETRN", 4) == 0) {
                m_Flags |= ETRN_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"CHUNKING") == 0) {
                m_Flags |= CHUNKING_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"BINARYMIME") == 0) {
                m_Flags |= BINMIME_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"ENHANCEDSTATUSCODES") == 0) {
                m_Flags |= ENHANCEDSTATUSCODE_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"AUTH", 4) == 0) {
                pszValue = strchr(InputLine + 4, '=');

                if (pszValue == NULL)
                    pszValue = strchr(InputLine + 4, ' ');

                while (pszValue != NULL) {
                    if (strncasecmp(pszValue + 1, (char *)"NTLM", 4) == 0) {
                        m_Flags |= AUTH_NTLM;

                    } else if (strncasecmp(pszValue + 1, (char *)"LOGIN", 5) == 0) {
                        m_Flags |= AUTH_CLEARTEXT;

                    } else if (strncasecmp(pszValue + 1, (char *)"DPA", 3) == 0) {
                        m_Flags |= AUTH_NTLM;

                    } else if (strncasecmp(pszValue + 1, (char *)"GSSAPI", 6) == 0) {
                        m_Flags |= AUTH_GSSAPI;
                    }

                    pszValue = strchr(pszValue + 1, ' ');
                }

            }

        }

        InputLine += IntermediateSize;
        ParameterSize -= IntermediateSize;
    }

    // We don't want to bail out for weird responses, but we want to
    // note such occurrences.
    if ((ParameterSize > 1) ||
        (!ParameterSize) ||
        (*InputLine)) {
        ErrorTrace((LPARAM)this, "Weird response tail <%*s>",
                   ParameterSize, InputLine);
        _ASSERT(FALSE);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_CONNOUT::DoSASLCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;
    BOOL fMoreData = TRUE;
    BUFFER BuffOut;
    DWORD BytesRet = 0;
    DomainInfo DomainParams;
    LPSTR szUserName = NULL;
    LPSTR szPassword = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSASLCommand");

    ZeroMemory (&DomainParams, sizeof(DomainParams));

    if ((m_MsgOptions & DOMAIN_INFO_USE_NTLM ||
        m_MsgOptions & DOMAIN_INFO_USE_KERBEROS)) {
        if (!IsOptionSet(AUTH_NTLM) && !(IsOptionSet(AUTH_GSSAPI))) {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support any form of login authentication! We have to drop this connection now.
            //
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSASLCommand: ERROR! Remote server does not support AUTH!");
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SUCH_PACKAGE);

            SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, "AUTH", InputLine);

            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    }

    if (m_MsgOptions & DOMAIN_INFO_USE_PLAINTEXT) {
        if (!IsOptionSet(AUTH_CLEARTEXT)) {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support any form of login authentication! We have to drop this connection now.
            //
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSASLCommand: ERROR! Remote server does not support AUTH!");
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SUCH_PACKAGE);

            SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, "AUTH", InputLine);

            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    }

    //set the next state
    SetNextState (&SMTP_CONNOUT::DoSASLNegotiation);

    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);

    if (FAILED(hr)) {
        DisconnectClient();
        SetLastError(m_Error = ERROR_LOGON_FAILURE);
        SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", InputLine);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    szUserName = DomainParams.szUserName;
    szPassword = DomainParams.szPassword;

    //If a username is specified, but NULL password, IIS will attempt
    //anonymous logon.  Force "" password so the correct user is
    //used.
    if (szUserName && !szPassword)
        szPassword = "";

    if (m_MsgOptions & DOMAIN_INFO_USE_NTLM ||
            m_MsgOptions & DOMAIN_INFO_USE_KERBEROS) {

        m_szAuthPackage[0] = '\0';
        BOOL fReturn = FALSE;
        char    szTarget[MAX_INTERNET_NAME + 1];

        if ((m_MsgOptions & DOMAIN_INFO_USE_KERBEROS) && (IsOptionSet(AUTH_GSSAPI))) {
            m_AuthToUse = SMTP_AUTH_KERBEROS;
            strcpy(m_szAuthPackage,"GSSAPI");

            //
            // For Kerberos, we need to set the target server SPN, for which we
            // pickup info from m_pDnsRec
            //
            MX_NAMES *pmx;

            _ASSERT( m_pDnsRec != NULL );
            _ASSERT( m_pDnsRec->StartRecord < m_pDnsRec->NumRecords );

            pmx = m_pDnsRec->DnsArray[m_pDnsRec->StartRecord];
            _ASSERT( pmx != NULL );
            _ASSERT( pmx->DnsName != NULL );

            m_securityCtx.SetTargetPrincipalName(
                SMTP_SERVICE_PRINCIPAL_PREFIX,pmx->DnsName);

            DebugTrace((LPARAM) this, "Setting Target Server SPN to %s",
                       pmx->DnsName);

        } else {
            m_AuthToUse = SMTP_AUTH_NTLM;
            strcpy(m_szAuthPackage,"NTLM");
        }

        DebugTrace((LPARAM) this, "Using NTLM/KERBEROS for user %s",
            DomainParams.szUserName);

        fReturn = m_securityCtx.ClientConverse(
                                    NULL, 0, &BuffOut, &BytesRet,
                                    &fMoreData, &AuthInfoStruct,
                                    m_szAuthPackage,
                                    (char *) szUserName,
                                    (char *) szPassword,
                                    (PIIS_SERVER_INSTANCE) m_pInstance);

        if (fReturn) {
            if (BytesRet) {
                FormatSmtpMessage(FSM_LOG_ALL, "AUTH %s %s\r\n", m_szAuthPackage,
                    BuffOut.QueryPtr());
            }

            if (!fMoreData && (m_MsgOptions & DOMAIN_INFO_USE_NTLM)) {
                fRet = FALSE;
            }
        } else {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "m_securityCtx.Converse for user %s - %d",
                szUserName, m_Error);
            DisconnectClient();
            m_Error = ERROR_LOGON_FAILURE;
            SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", NULL); //Should not pass param Inputline: encrypted
            fRet = FALSE;
        }
    } else {
        BOOL fReturn = FALSE;
        m_AuthToUse = SMTP_AUTH_CLEARTEXT;

        if (!szUserName) szUserName = "";
        if (!szPassword) szPassword = "";

        DebugTrace((LPARAM) this, "Using ClearText for user %s",
            szUserName);
        fReturn = uuencode ((unsigned char *)szUserName,
                    lstrlen(szUserName), &BuffOut, FALSE);

        if (fReturn) {
            FormatSmtpMessage(FSM_LOG_VERB_ONLY, "AUTH LOGIN %s\r\n", (char *)
                BuffOut.QueryPtr());
            BytesRet = lstrlen((char *) BuffOut.QueryPtr());
        } else {
            DisconnectClient();
            m_Error = ERROR_LOGON_FAILURE;
            SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", NULL); //Should not pass param Inputline: uuencoded
            fRet = FALSE;
        }
    }

    if (fRet && BytesRet) {
        SendSmtpResponse();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}


/*++

    Name :
        SMTP_CONNOUT::DoSTARTTLSCommand

    Description:

        Negotiates use of SSL via the STARTTLS command

    Arguments:
        InputLine -- Indicates response of remote server
        ParameterSize -- Size of Inputline
        UndecryptedTailSize -- The part of the received buffer that could not
            be decrypted.

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoSTARTTLSCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSTARTTLSCommand");

    if (m_TlsState == MUST_DO_TLS) {
        if (IsOptionSet(TLS_OPTION) || IsOptionSet(STARTTLS_OPTION)) {
            FormatSmtpMessage(FSM_LOG_ALL, "STARTTLS\r\n");
            SendSmtpResponse();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: STARTTLS command sent");
            m_TlsState = STARTTLS_SENT;
            TraceFunctLeaveEx((LPARAM)this);
            return ( TRUE );
        } else {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support TLS! We have to drop this connection now.
            //
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: ERROR! Remote server does not support TLS!");
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            SetDiagnosticInfo(AQUEUE_E_TLS_NOT_SUPPORTED_ERROR, "STARTTLS", InputLine);
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    } else {
        //
        // We sent the STARTTLS command, and InputLine has the server's response
        // Handle the server's response
        //
        _ASSERT(m_TlsState == STARTTLS_SENT);

        DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server response to STARTTLS is \"%s\"", InputLine);
        switch (InputLine[0]) {
        case SMTP_COMPLETE_FAILURE:
            {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server returned error");
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                SetDiagnosticInfo(AQUEUE_E_TLS_ERROR, "STARTTLS", InputLine);
                DisconnectClient();
                SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                TraceFunctLeaveEx((LPARAM)this);
                return ( FALSE );
            }
            break;

        case SMTP_COMPLETE_SUCCESS:
            {
                m_SecurePort = TRUE;
                m_fNegotiatingSSL = TRUE;
                m_TlsState = SSL_NEG;
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server accepted, beginning SSL handshake");

                //
                // Switch over to using a large receive buffer, because a SSL fragment
                // may be up to 32K big.

                if (!SwitchToBigSSLBuffers()) {
                    DebugTrace((LPARAM) this,
                               "SMTP_CONNOUT::DoSTARTTLSCommand: Failed to allocate Big SSL buffers %d\n",
                               GetLastError());
                    DisconnectClient();
                    TraceFunctLeaveEx((LPARAM)this);
                    return ( FALSE );
                }

                if (!DoSSLNegotiation(NULL, 0, 0)) {
                    DebugTrace(
                              (LPARAM) this,
                              "SMTP_CONNOUT::DoSTARTTLSCommand: SSL Client Hello failed %d!\n",
                              GetLastError());
                    DisconnectClient();
                    SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                    TraceFunctLeaveEx((LPARAM)this);
                    return ( FALSE );
                }

            }
            break;

        default:
            {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server sent malformed response to STARTTLS");
                SetDiagnosticInfo(AQUEUE_E_TLS_ERROR, "STARTTLS", InputLine);
                DisconnectClient();
                SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                TraceFunctLeaveEx((LPARAM)this);
                return ( FALSE );
            }
            break;
        }
    }


    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

/*++

    Name :
        SMTP_CONNOUT::DoRSETCommand

    Description:

        Sends the SMTP RSET command.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRSETCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    FormatSmtpMessage(FSM_LOG_ALL, "RSET\r\n");

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_fUseBDAT = FALSE;

    //If we are issuing rset during the Per rcpt event due to some problem
    //we need to preserve the state till we handle the
    //this message and ack it
    if (m_RsetReasonCode != ALL_RCPTS_FAILED) {
        m_fNeedRelayedDSN = FALSE;
        m_fHadHardError = FALSE;
        m_fHadTempError = FALSE;
    }

    return SendSmtpResponse();
}


/*++

    Name :
        SMTP_CONNOUT::SendRemainingRecipients

    Description:

    SendRemainingRecipients
    gets called when we get a 552 error during the
    RCPT to command.  This means that the server we connected
    to has a fixed max amount of rcpts that it accepts, and we
    went over that limit.  Therefore, we send the mail file to
    the recipients that it accepted and then start over sending
    the mail to the remaining recipients.  However, before doing
    this, check the response to see if the server took the previous
    mail O.K.

    Arguments:

          none

    Returns:
        nothing

--*/
void SMTP_CONNOUT::SendRemainingRecipients (void)
{
#if 0
    CAddr * pwalk = NULL;
    PLIST_ENTRY pListTemp = NULL;

    //increment our counter
    BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

    //yea, baby. Save the start address
    //so we can walk the list deleting
    //any addresses that were successfully
    //sent.
    pwalk = m_StartAddress;
    pListTemp = m_StartAddressLink;

    _ASSERT (pwalk != NULL);

    //set the start address to NULL, so
    //that we can set it to a known good
    //address below.  See the other comment
    //below.
    m_StartAddress = NULL;
    m_StartAddressLink = NULL;

    //step through all the previously sent addresses.
    //If they have an error code of 250, then they
    //were received correctly.  An error code of
    //552 means that we sent too many, so we are
    //going to attempt to send the remaining recipients.
    //We will not attempt to send a rcpt that has any
    //other error code.
    while (pwalk && (pwalk->GetErrorCode() != SMTP_DUMMY_FAILURE)) {
        if ((pwalk->GetErrorCode() == SMTP_OK_CODE) ||
            (pwalk->GetErrorCode() == SMTP_USER_NOT_LOCAL_CODE)) {
            MailInfo->RemoveAddress(pwalk);
            delete pwalk;
        }

        //get the next address
        pwalk = MailInfo->GetNextAddress(&pListTemp);
    }

    _ASSERT (pwalk != NULL);
    _ASSERT (pwalk->GetErrorCode() == SMTP_DUMMY_FAILURE);

    m_StartAddress = pwalk;
    m_StartAddressLink = pListTemp;

    _ASSERT (m_StartAddress != NULL);
    _ASSERT (m_StartAddressLink != NULL);

    //update the queue file to reflect the remaining
    //recipients, if any
    MailInfo->UpdateQueueFile(REMOTE_NAME);

    //save the current RCPT address
    m_NextAddress = pwalk;
    m_NextAddressLink = pListTemp;
#endif

}

BOOL SMTP_CONNOUT::DoETRNCommand(void)
{
    DWORD WaitRes = WAIT_TIMEOUT;
    DWORD TimeToWait = 0;
    HRESULT hr = S_OK;
    DomainInfo DomainParams;
    char  szETRNDomainBuffer[MAX_PATH+1];
    char *szNextETRNDomain = NULL;
    const char *szETRNDomain = szETRNDomainBuffer;
    DWORD cbETRNDomain = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoETRNCommand");

    ZeroMemory(&DomainParams, sizeof(DomainParams));

    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);
    if (FAILED(hr) || (DomainParams.szETRNDomainName == NULL)) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if (!m_szCurrentETRNDomain) {
        m_szCurrentETRNDomain = DomainParams.szETRNDomainName;
    }

    //Find next in comma-delimited list of domains
    szNextETRNDomain = strchr(m_szCurrentETRNDomain, ',');

    if (!szNextETRNDomain) {
        //We are done... this is the last domain
        szETRNDomain = m_szCurrentETRNDomain;
        m_Flags |= ETRN_SENT;
    } else {
        //There are more domains left... we need to copy the domain
        //to our buffer where we can NULL terminate it.
        cbETRNDomain = (DWORD) (sizeof(char)*(szNextETRNDomain-m_szCurrentETRNDomain));
        if ((cbETRNDomain >= sizeof(szETRNDomainBuffer)) ||
            (cbETRNDomain > DomainParams.cbETRNDomainNameLength)) {
            //There is not enough room for this domain
            ErrorTrace((LPARAM) this, "Domain configured for ETRN is greater than MAX_PATH");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
        memcpy(szETRNDomainBuffer, m_szCurrentETRNDomain, cbETRNDomain);
        szETRNDomainBuffer[cbETRNDomain/sizeof(char)] = '\0';

        //Skip to beginning of next domain
        m_szCurrentETRNDomain = szNextETRNDomain;
        while (isspace((UCHAR)*m_szCurrentETRNDomain) || *m_szCurrentETRNDomain == ',') {
            if (!(*m_szCurrentETRNDomain)) {
                //End of string... we're done
                m_Flags |= ETRN_SENT;
                break;
            }
            m_szCurrentETRNDomain++;
        }
    }

#if 0
    TimeToWait = m_pHashEntry->GetEtrnWaitTime() * 60 * 1000; //time in milliseconds

    if (TimeToWait) {
        WaitRes = WaitForSingleObject(QuerySmtpInstance()->GetQStopEvent(), m_pHashEntry->GetEtrnWaitTime());
    }

    if (WaitRes == WAIT_OBJECT_0) {
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }
#endif

    FormatSmtpMessage(FSM_LOG_ALL, "ETRN %s\r\n", szETRNDomain);

    SendSmtpResponse();

    //Keep on sending ETRNs until we are out of domains.
    if (!IsOptionSet(ETRN_ONLY_OPTION) || !(m_Flags & ETRN_SENT)) {
        SetNextState (&SMTP_CONNOUT::DoMessageStartEvent);
    } else {
        SetNextState (&SMTP_CONNOUT::DoCompletedMessage);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::DoMAILCommand

    Description:

        Responds to the SMTP MAIL command.
    Arguments:
        Are ignored

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoMAILCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char Options[1024] = "";
    char BodySize[32];
    char Address[MAX_INTERNET_NAME];
    BOOL fRet = TRUE;
    DWORD MsgOption = 0;
    HRESULT hr = S_OK;
    BOOL fFailedDueToBMIME = FALSE;
    _ASSERT(m_pIMsg);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoMAILCommand");

    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    //clear the options
    Options[0] = '\0';

    //If the message has 8bitmime, make sure the
    //server also supports it.

    hr = m_pIMsg->GetDWORD(IMMPID_MP_EIGHTBIT_MIME_OPTION, &MsgOption);
    if (MsgOption) {
        if (IsOptionSet(EBITMIME_OPTION)) {
            lstrcat(Options, " BODY=8bitmime");
        } else {
            // SetLastError(SMTP_OPTION_NOT_SUPPORTED_8BIT);
            DebugTrace((LPARAM) this, "Message has 8bitmime but server does not support it");
            m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
            //Fill in the response context buffer so as to generate the right response
            // Get the error code
            m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
            hr = m_ResponseContext.m_cabResponse.Append(
                                                       (char *)SMTP_REMOTE_HOST_REJECTED_FOR_TYPE,
                                                       strlen(SMTP_REMOTE_HOST_REJECTED_FOR_TYPE),
                                                       NULL);
            TraceFunctLeaveEx((LPARAM)this);
            return (TRUE);
        }
    } else {
        MsgOption = 0;
        hr = m_pIMsg->GetDWORD(IMMPID_MP_BINARYMIME_OPTION, &MsgOption);
        if (MsgOption) {
            //Check if we allow BINARYMIME outbound at domain level
            if (m_MsgOptions & DOMAIN_INFO_DISABLE_BMIME) {
                fFailedDueToBMIME = TRUE;
            } else {
                //Do we disallow it globally
                if (QuerySmtpInstance()->AllowOutboundBMIME()) {
                    if (IsOptionSet(BINMIME_OPTION) && IsOptionSet(CHUNKING_OPTION)) {
                        lstrcat(Options, " BODY=BINARYMIME");
                        m_fUseBDAT = TRUE;
                    } else {
                        fFailedDueToBMIME = TRUE;
                    }
                } else {
                    fFailedDueToBMIME = TRUE;
                }
            }
        }

    }

    if (fFailedDueToBMIME) {
        // SetLastError(SMTP_OPTION_NOT_SUPPORTED_BMIME);
        DebugTrace((LPARAM) this, "Message has BINARYMIME but server does not support it");
        m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
        //Fill in the response context buffer so as to generate the right response
        // Get the error code
        m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
        hr = m_ResponseContext.m_cabResponse.Append(
                                                   (char *)SMTP_REMOTE_HOST_REJECTED_FOR_TYPE,
                                                   strlen(SMTP_REMOTE_HOST_REJECTED_FOR_TYPE),
                                                   NULL);
        TraceFunctLeaveEx((LPARAM)this);
        return (TRUE);
    }
    //See if CHUNKING is preferred on this connection
    //If it is and the remote site advertised chunking then we set the UseBDAT flag
    else if (!m_fUseBDAT) {
        //Does the remote server advertises chunking
        if (IsOptionSet(CHUNKING_OPTION)) {
            //Do we disallow chunking at domain level
            if (m_MsgOptions & DOMAIN_INFO_DISABLE_CHUNKING) {
                DebugTrace((LPARAM) this, "We disable chunking for this domain");

            } else if ((m_MsgOptions & DOMAIN_INFO_USE_CHUNKING) || QuerySmtpInstance()->ShouldChunkOut()) {
                m_fUseBDAT = TRUE;
            }
        } else if (m_MsgOptions & DOMAIN_INFO_USE_CHUNKING)
            DebugTrace((LPARAM) this, "Remote server does not advertise chunking");
    }

    // produce a dot-stuffed handle if we aren't using bdat
    if (!m_fUseBDAT) {
        DWORD fFoundEmbeddedCrlfDot = FALSE;
        DWORD fScanned = FALSE;

        //
        // get the properties to see if we have scanned for crlf.crlf, and
        // to see if the message contained crlf.crlf when it was scanned.
        // if either of these lookups fail then we will set fScanned to
        // FALSE
        //
        if (FAILED(m_pIMsg->GetDWORD(IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,
                                     &fScanned)) ||
            FAILED(m_pIMsg->GetDWORD(IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF,
                                     &fFoundEmbeddedCrlfDot)))
        {
            fScanned = FALSE;
        }


        //
        // if we didn't scan, or if we found an embedded crlf.crlf then
        // produce a dot stuff context
        //
        if (!fScanned || fFoundEmbeddedCrlfDot) {
            if (!m_IMsgDotStuffedFileHandle) {
                m_IMsgDotStuffedFileHandle = ProduceDotStuffedContext(
                                                                  m_IMsgFileHandle,
                                                                  NULL,
                                                                  TRUE );
                if (NULL == m_IMsgDotStuffedFileHandle)
                {
                    SetDiagnosticInfo(AQUEUE_E_BIND_ERROR , NULL, NULL);
                    ErrorTrace((LPARAM) this, "Failed to get dot stuffed context");
                    TraceFunctLeaveEx((LPARAM)this);
                    return FALSE;
                }
            }
        }
    }

    //get the size of the file
    DWORD dwSizeHigh;
    m_FileSize = GetFileSizeFromContext( (m_IMsgDotStuffedFileHandle && !m_fUseBDAT) ? m_IMsgDotStuffedFileHandle : m_IMsgFileHandle, &dwSizeHigh);
    _ASSERT(dwSizeHigh == 0);

    //if the server supports the size command
    // give him the size of the file
    if (IsOptionSet(SIZE_OPTION) && (m_SizeOptionSize > 0)) {
        if ((m_FileSize != 0XFFFFFFFF) && (m_FileSize <= m_SizeOptionSize))
        {
            wsprintf(BodySize, " SIZE=%d", m_FileSize);
            lstrcat(Options, BodySize);
        }
        else {
            // SetLastError(SMTP_MSG_LARGER_THAN_SIZE);
            DebugTrace((LPARAM) this, "(m_FileSize != 0XFFFFFFFF) && (m_FileSize <= m_SizeOptionSize) failed");
            DebugTrace((LPARAM) this, "m_FileSize = %d, m_SizeOptionSize = %d - quiting", m_FileSize, m_SizeOptionSize );
            m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;

            //Fill in the response context buffer so as to generate the right response
            // Get the error code
            m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
            hr = m_ResponseContext.m_cabResponse.Append(
                                                       (char *)SMTP_REMOTE_HOST_REJECTED_FOR_SIZE,
                                                       strlen(SMTP_REMOTE_HOST_REJECTED_FOR_SIZE),
                                                       NULL);

            TraceFunctLeaveEx((LPARAM)this);
            return (TRUE);
        }
    }

    if (IsOptionSet(DSN_OPTION)) {
        char RetDsnValue[200];
        BOOL fDSNDisallowed = TRUE;

        //Do we disallow DSN at domain level
        if (m_MsgOptions & DOMAIN_INFO_DISABLE_DSN) {
            DebugTrace((LPARAM) this, "We disable DSN for this domain");
        } else if (QuerySmtpInstance()->AllowOutboundDSN()) {
            fDSNDisallowed = FALSE;
        }

        lstrcpy(RetDsnValue, " RET=");
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_RET_VALUE, sizeof(RetDsnValue) - lstrlen(RetDsnValue), RetDsnValue + lstrlen(RetDsnValue));
        if (!FAILED(hr) && !fDSNDisallowed) {
            lstrcat(Options, RetDsnValue);
        }

        lstrcpy(RetDsnValue, " ENVID=");
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_ENVID_VALUE, sizeof(RetDsnValue) - lstrlen(RetDsnValue), RetDsnValue + lstrlen(RetDsnValue));
        if (!FAILED(hr) && !fDSNDisallowed) {
            lstrcat(Options, RetDsnValue);
        }
    }

    hr = m_pIMsg->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, sizeof(Address), Address);
    if (!FAILED(hr)) {
        //format the MAIL FROM command, with SIZE extension if necessary.
        m_OutboundContext.m_cabNativeCommand.Reset();
        if ( (Address[0] == '<') && (Address[1] == '>')) {
            fRet = PE_AppendSmtpMessage("MAIL FROM:<>");
        } else {
            fRet = PE_AppendSmtpMessage("MAIL FROM:<") &&
                PE_AppendSmtpMessage(Address) &&
                PE_AppendSmtpMessage(">");
        }
        if (fRet) {
            fRet = PE_AppendSmtpMessage(Options) &&
                PE_AppendSmtpMessage("\r\n");
        }
    } else {
        DebugTrace((LPARAM) this, "Could not get Sender Address %x", hr);
        m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
        TraceFunctLeaveEx((LPARAM)this);
        return (TRUE);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::DoMAILResponse

    Description:

        Responds to the SMTP MAIL command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoMAILResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoMAILResponse");

    m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;

    char chInputGood = 0;

    if ( isdigit( (UCHAR)InputLine[1] ) &&  isdigit( (UCHAR)InputLine[2] ) &&   ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
        chInputGood = InputLine[0];
    } else {
        chInputGood = SMTP_COMPLETE_FAILURE;
    }

    //the MAIL FROM: was rejected
    if ( chInputGood != SMTP_COMPLETE_SUCCESS) {
        // We expect either a 4xx or 5xx response. If it's 4xx we return
        // a transient, all others will become a complete failure.
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "MAIL", InputLine);
        if ( chInputGood == SMTP_TRANSIENT_FAILURE) {
            m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
        } else {
            m_ResponseContext.m_dwResponseStatus = EXPE_COMPLETE_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoMAILResponse executing quit command err = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}

BOOL SMTP_CONNOUT::AddRcptsDsns(DWORD NotifyOptions, char * OrcptVal, char * AddrBuf, int& AddrSize)
{
    BOOL FirstOption = TRUE;

    if (NotifyOptions & ~(RP_DSN_NOTIFY_NEVER | RP_DSN_NOTIFY_SUCCESS | RP_DSN_NOTIFY_FAILURE | RP_DSN_NOTIFY_DELAY)) {
        NotifyOptions = 0;
    }

    if (NotifyOptions) {
        lstrcat(AddrBuf, " NOTIFY=");
        AddrSize += 8;

        if (NotifyOptions & RP_DSN_NOTIFY_SUCCESS) {
            lstrcat(AddrBuf, "SUCCESS");
            AddrSize += 7;
            FirstOption = FALSE;
        }

        if (NotifyOptions & RP_DSN_NOTIFY_FAILURE) {
            if (!FirstOption) {
                lstrcat(AddrBuf, ",");
                AddrSize += 1;
            }

            lstrcat(AddrBuf, "FAILURE");
            AddrSize += 7;
            FirstOption = FALSE;
        }

        if (NotifyOptions & RP_DSN_NOTIFY_DELAY) {
            if (!FirstOption) {
                lstrcat(AddrBuf, ",");
                AddrSize += 1;
            }

            lstrcat(AddrBuf, "DELAY");
            AddrSize += 5;
            FirstOption = FALSE;
        }

        if (FirstOption) {
            lstrcat(AddrBuf, "NEVER");
            AddrSize += 5;
        }
    }

    if (*OrcptVal != '\0') {
        lstrcat(AddrBuf, " ORCPT=");
        AddrSize += 7;

        lstrcat(AddrBuf, OrcptVal);
        AddrSize += lstrlen(OrcptVal);
    }

    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::SaveToErrorFile

    Description:

        This function saves all errors to
        a file so the NDR thread can send
        a transcript of what tranpired back
        to the original user

    Arguments:

        Buffer with recipient data, size of buffer,

    Returns:

      TRUE if we were able to open and write to the file
      FALSE otherwise

--*/
BOOL SMTP_CONNOUT::SaveToErrorFile(char * Buffer, DWORD BufSize)
{
    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::DoRCPTCommand

    Description:

        This function sends the SMTP RCPT command.
    Arguments:
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRCPTCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char AddrBuf [MAX_INTERNET_NAME + 2024];
    char szRecipName[MAX_INTERNET_NAME];
    char szOrcptVal[MAX_RCPT_TO_ORCPT_LEN+1];
    BOOL fOrcptSpecified;
    BOOL fFoundUnhandledRcpt = FALSE;
    int AddrSize = 0;
    HRESULT hr = S_OK;
    DWORD NextAddress = 0;

    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoRCPTCommand");

    //MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);

    // We report success
    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    //format as much of the recipients that could fit into
    //the output buffer
    NextAddress = m_NextAddress;
    while (NextAddress < m_NumRcpts) {
        DWORD dwRecipientFlags = 0;
        hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
        if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
            //Problemmo
            // Get property shouldn't fail since we've come this far
            //_ASSERT(FALSE);
            goto RcptError;
        }

        //NK** : I am moving this out as it breaks us when the first recipient is a handled recipient
        // Default is pipelined
        m_OutboundContext.m_dwCommandStatus = EXPE_PIPELINED | EXPE_REPEAT_COMMAND;

        //check to see if this recipient needs to be looked at
        if ((dwRecipientFlags & RP_HANDLED) ) {
            //This recipient can be skipped over
            //Mark it inaccesible so that when we sweep the tried recipient
            //in case of connection drop we do not touch the guys we did not send
            //We need to get atleast one guy each time we come in.
            m_RcptIndexList[NextAddress] = INVALID_RCPT_IDX_VALUE;
            m_NextAddress = NextAddress + 1;
            NextAddress ++;
            continue;
        } else {
            hr = m_pIMsgRecips->GetStringA(m_RcptIndexList[NextAddress], IMMPID_RP_ADDRESS_SMTP, sizeof(szRecipName), szRecipName);
            if (!FAILED(hr)) {
                //Format the first recipient
                AddrSize = wsprintf (AddrBuf, "RCPT TO:<%s>", szRecipName);

                fOrcptSpecified = FALSE;
                hr = m_pIMsgRecips->GetStringA(m_RcptIndexList[NextAddress], IMMPID_RP_DSN_ORCPT_VALUE, sizeof(szOrcptVal), szOrcptVal);
                if (!FAILED(hr) && (szOrcptVal[0] != '\0')) {
                    fOrcptSpecified = TRUE;

                } else if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
                    //Problemmo
                    // Get property shouldn't fail since we've come this far
                    //_ASSERT(FALSE);
                    goto RcptError;
                } else {
                    szOrcptVal[0] = '\0';
                }

                //If some DSN property is set then
                if ((dwRecipientFlags & RP_DSN_NOTIFY_MASK) || fOrcptSpecified) {
                    BOOL fAllowDSN = FALSE;

                    //Do we disallow DSN at domain level
                    if (m_MsgOptions & DOMAIN_INFO_DISABLE_DSN) {
                        DebugTrace((LPARAM) this, "We disable DSN for this domain");
                    } else if (QuerySmtpInstance()->AllowOutboundDSN()) {
                        fAllowDSN = TRUE;
                    }

                    if (IsOptionSet(DSN_OPTION) && fAllowDSN) {
                        AddRcptsDsns(dwRecipientFlags, szOrcptVal, AddrBuf, AddrSize);
                        m_fNeedRelayedDSN = FALSE;
                    } else {
                        //let AQ know that the remote server did not advertise DSN
                        m_fNeedRelayedDSN = TRUE;
                        dwRecipientFlags |= RP_REMOTE_MTA_NO_DSN;
                        hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress],
                                                     IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                        if (FAILED(hr)) {
                            //Problemmo
                            goto RcptError;
                        }
                    }
                }

                lstrcat(AddrBuf, "\r\n");
                AddrSize += 2;

                m_OutboundContext.m_cabNativeCommand.Reset();

                if (PE_AppendSmtpMessage(AddrBuf)) {
                    DebugTrace((LPARAM) this,"Sending %s", szRecipName);
                    m_NumRcptSent++;
                    m_NextAddress = NextAddress + 1;

                    if (!IsOptionSet(PIPELINE_OPTION))
                        m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                } else {
                    //no more space in the buffer, send what we have;
                    //_ASSERT(FALSE);
                    m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                    return (TRUE);
                }
            } else {
                //Problemmo
                // Get property shouldn't fail since we've come this far
                //_ASSERT(FALSE);
                goto RcptError;
            }
        }
        NextAddress ++;
        break;
    }

    // If we are done, we will not pipeline further, this will save a loop
    if (m_NumRcpts == NextAddress)
        m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);

RcptError:

    m_OutboundContext.m_dwCommandStatus = EXPE_TRANSIENT_FAILURE;
    TraceFunctLeaveEx((LPARAM)this);
    return (FALSE);
}

/*++

    Name :
        SMTP_CONNOUT::DoRCPTResponse

    Description:

        This function handles the SMTP RCPT response.
    Arguments:
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRCPTResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    HRESULT    hr = S_OK;
    DWORD    NextAddress = 0;
    DWORD dwRecipientFlags;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoRCPTResponse");

    _ASSERT(QuerySmtpInstance() != NULL);

    //MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);

    m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;

    //start at the beginning of the last
    //pipelined address
    NextAddress = m_FirstPipelinedAddress;

    DebugTrace((LPARAM)this, "Response: %*s", ParameterSize, InputLine);

    //step through the returned recipients and check
    //their error code.
    if (m_NumRcptSent) {
        //Get to the next rcpt that we send out this time
        while ((NextAddress < m_NumRcpts) && (m_RcptIndexList[NextAddress] == INVALID_RCPT_IDX_VALUE))
            NextAddress++;

        _ASSERT(NextAddress < m_NumRcpts);
        if (NextAddress >= m_NumRcpts) {
            //Problemo
            SetLastError(ERROR_INVALID_DATA);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        dwRecipientFlags = 0;

        hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);

        if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
            //Problemmo
            SetLastError(ERROR_OUTOFMEMORY);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        m_NumRcptSent--;

        //Once we get 552 Too many recipients error .. we do not bother to look at the real responses
        //Logically they will all be 552 as well
        if (m_SendAgain)
            m_ResponseContext.m_dwSmtpStatus = SMTP_ACTION_ABORTED_CODE;

        // If we have no response status code set, we will abort action
        if (m_ResponseContext.m_dwSmtpStatus == 0) {
            m_NumFailedAddrs++;
            m_NumRcptSentSaved ++;
            hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_ERROR_CODE, SMTP_ACTION_ABORTED_CODE);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                TraceFunctLeaveEx((LPARAM)this);
                return (FALSE);
            }

            //Create the temp error string
            char sztemp[100];
            sprintf(sztemp,"%d %s",SMTP_ACTION_ABORTED_CODE, "Invalid recipient response");
            hr = m_pIMsgRecips->PutStringA(m_RcptIndexList[NextAddress], IMMPID_RP_SMTP_STATUS_STRING,sztemp);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                TraceFunctLeaveEx((LPARAM)this);
                return (FALSE);
            }
            //real bad error.  SCuttle this message
            MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);
            SetLastError(ERROR_CAN_NOT_COMPLETE);
            m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
            return (TRUE);
        } else {
            //save the number of recipients sent so that
            //we can compare this number to the number of
            //failed recipients.
            m_NumRcptSentSaved ++;

            BUMP_COUNTER(QuerySmtpInstance(), NumRcptsSent);

            // Save the error code (if there was an error)
            // We do not want to save "250 OK" or "251 OK" responses because
            // it wastes increases the memory footprint of messages in
            // the queue
            if ((SMTP_OK_CODE != m_ResponseContext.m_dwSmtpStatus) &&
                (SMTP_USER_NOT_LOCAL_CODE != m_ResponseContext.m_dwSmtpStatus)) {

                ErrorTrace((LPARAM)this,
                           "Saving rcpt error code %u - %s",
                           m_ResponseContext.m_dwSmtpStatus, InputLine);

                hr = m_pIMsgRecips->PutDWORD(
                                            m_RcptIndexList[NextAddress],
                                            IMMPID_RP_ERROR_CODE,
                                            m_ResponseContext.m_dwSmtpStatus);
                if (FAILED(hr)) {
                    //Problemmo
                    SetLastError(ERROR_OUTOFMEMORY);
                    TraceFunctLeaveEx((LPARAM)this);
                    return (FALSE);
                }

                //Set the ful response as error string
                hr = m_pIMsgRecips->PutStringA(m_RcptIndexList[NextAddress], IMMPID_RP_SMTP_STATUS_STRING, InputLine);
                if (FAILED(hr)) {
                    //Problemmo
                    SetLastError(ERROR_OUTOFMEMORY);
                    TraceFunctLeaveEx((LPARAM)this);
                    return (FALSE);
                }
            } else {
                //Recipient successful... trace it
                DebugTrace((LPARAM) this,
                    "Recipient %d OK with response %s",
                    NextAddress, InputLine);
            }

            switch (m_ResponseContext.m_dwSmtpStatus) {
            //4XX level code will lead to retry
            case SMTP_ERROR_PROCESSING_CODE:
            case SMTP_MBOX_BUSY_CODE:
            case SMTP_SERVICE_UNAVAILABLE_CODE:
                //Buffer[3] = ' '; put back the space character
                m_fHadTempError = TRUE;
                dwRecipientFlags |= (RP_ERROR_CONTEXT_MTA);
                m_NumFailedAddrs++;
                break;

            case SMTP_ACTION_ABORTED_CODE:
            case SMTP_INSUFF_STORAGE_CODE:		// 452 per rfc2821
                //this means we sent too many recipients.
                //set the m_SendAgain flag which tells us
                //to send whatever we have now, then start
                //sending to the other recipients afterwards.
                //We have to switch the error code because 552
                //means different things depending on what operation
                //we are doing.

                if (!m_SendAgain) {
                    if (m_fHadSuccessfulDelivery) {
                        m_NumFailedAddrs++;
                        m_SendAgain = TRUE;

                        if( m_NumFailedAddrs >= m_NumRcptSentSaved )
                        {
                            m_fHadHardError = TRUE;
                        }

                        if (m_First552Address == -1)
                            m_First552Address = NextAddress;
                        break;
                    }
                }

                // If no rcpts have been accepted so far and this
                // is a 452, then treat it as a temp failure like the
                // other 4xx codes.  If it's 552, we fall through
                if (m_ResponseContext.m_dwSmtpStatus == SMTP_INSUFF_STORAGE_CODE) {
                    m_fHadTempError = TRUE;
                    dwRecipientFlags |= (RP_ERROR_CONTEXT_MTA);
                    m_NumFailedAddrs++;
                    break;
                }
                // Falls through to 5xx case


                //5XX level codes will lead to NDR for the rcpt
            case SMTP_UNRECOG_COMMAND_CODE:
            case SMTP_SYNTAX_ERROR_CODE:
            case SMTP_NOT_IMPLEMENTED_CODE:
            case SMTP_BAD_SEQUENCE_CODE :
            case SMTP_PARAM_NOT_IMPLEMENTED_CODE:
            case SMTP_MBOX_NOTFOUND_CODE:
            case SMTP_USERNOTLOCAL_CODE:
            case SMTP_ACTION_NOT_TAKEN_CODE:
            case SMTP_TRANSACT_FAILED_CODE:

                // Buffer[3] = ' '; //put back the space character
                //SaveToErrorFile(Buffer, IntermediateSize);
                // DebugTrace((LPARAM) this, "User %s failed because of %d", pwalk->GetAddress(), Error);
                SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
                m_fHadHardError = TRUE;
                dwRecipientFlags |= (RP_FAILED | RP_ERROR_CONTEXT_MTA);
                m_NumFailedAddrs++;
                break;
            case SMTP_OK_CODE:
            case SMTP_USER_NOT_LOCAL_CODE:
                m_fHadSuccessfulDelivery = TRUE;
                BUMP_COUNTER(QuerySmtpInstance(), NumRcptsSent);
                dwRecipientFlags |= (RP_DELIVERED | RP_ERROR_CONTEXT_MTA);
                break;
            case SMTP_SERVICE_CLOSE_CODE:
                //fall through.  This is deliberate.
                //we don't want to continue if we get
                //these errors
            default:
                //real bad error.  Copy this error to the
                //front of the input buffer, because this
                //buffer will be passed to DoCompletedMessage
                //to do the right thing.
                {
                    SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
                    char chInputGood = 0;

                    if ( isdigit( (UCHAR)InputLine[1] ) &&
                         isdigit( (UCHAR)InputLine[2] ) &&
                         ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
                        chInputGood = InputLine[0];
                    } else {
                        chInputGood = SMTP_COMPLETE_FAILURE;
                    }


                    MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);
                    SetLastError(ERROR_CAN_NOT_COMPLETE);
                    if ( chInputGood == SMTP_TRANSIENT_FAILURE) {
                        m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
                        m_OutboundContext.m_pCurrentCommandContext = NULL;
                    } else {
                        m_ResponseContext.m_dwResponseStatus = EXPE_COMPLETE_FAILURE;
                        m_OutboundContext.m_pCurrentCommandContext = NULL;
                    }
                    return (TRUE);
                }
            }
        }

        //Set the flags back
        hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
        if (FAILED(hr)) {
            //Problemmo
            SetLastError(ERROR_OUTOFMEMORY);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        NextAddress++;
    }

    // Mark where we should pick up next time ...
    m_FirstPipelinedAddress = NextAddress;

    // No more unprocessed recipients, we are either done or we have to
    // issue more RCPT commands
    if ((NextAddress < m_NumRcpts) && !m_SendAgain)
        m_ResponseContext.m_dwResponseStatus = EXPE_REPEAT_COMMAND;


    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}



/*++

    Name :
        SMTP_CONNOUT::DoDATACommand

    Description:

        Responds to the SMTP DATA command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoDATACommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoDATACommand");

    SetNextState (&SMTP_CONNOUT::DoDATACommandEx);

    FormatSmtpMessage(FSM_LOG_ALL, "DATA\r\n");
    TraceFunctLeaveEx((LPARAM)this);
    return SendSmtpResponse();
}

/*++

    Name :
        SMTP_CONNOUT::DoBDATCommand

    Description:

        Send out the SMTP BDAT command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoBDATCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoBDATCommand");

    SetNextState (&SMTP_CONNOUT::DoDATACommandEx);

    //We send the whole mesage file as a single BDAT chunk
    //Verify if the CHUNK size should be FileSize or +2 for trailing CRLF
    //
    FormatSmtpMessage(FSM_LOG_ALL, "BDAT %d LAST\r\n", m_FileSize);
    if (!SendSmtpResponse()) {
        //BDAT command failed for some reason
        DebugTrace((LPARAM) this, "Failed to send BDAT command");
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return DoDATACommandEx(InputLine, ParameterSize, UndecryptedTailSize);
}


/*++

    Name :
        SMTP_CONNOUT::DoDATACommandEx

    Description:

        This funcion sends the message body to remote server
        after the DATA or BDAT command
    Arguments:

        InputLine - Buffer received from remote Server
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoDATACommandEx(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    LARGE_INTEGER LSize = {0,0};
    BOOL fRet = TRUE;
    HRESULT hr = S_OK;
    char szResponse[] = "123";
    LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoDATACommandEx");

    // we need to receive a 354 from the server to go on in case of DATA command
    // we actually check that we receive atleast a 3xy response (x,y = digits)
    // In case of BDAT, the remote server never responds and so ignore the input line
    //
    if (m_fUseBDAT ||
         (ParameterSize >= 5 &&
         InputLine[0] == SMTP_INTERMEDIATE_SUCCESS &&
         isdigit((UCHAR)InputLine[1]) &&
         isdigit((UCHAR)InputLine[2]))) {

        SetNextState (&SMTP_CONNOUT::DoContentResponse);

        LSize.HighPart = 0;
        LSize.LowPart = m_FileSize;
        m_LastClientIo = SMTP_CONNOUT::TRANSFILEIO;
        //use the trailer buffers only for DATA command
        lpTransmitBuffers = (m_fUseBDAT) ?  NULL : &m_TransmitBuffers;

        fRet = TransmitFileEx ((!m_fUseBDAT && m_IMsgDotStuffedFileHandle) ? m_IMsgDotStuffedFileHandle->m_hFile : m_IMsgFileHandle->m_hFile,
                               LSize,
                               0,
                               lpTransmitBuffers);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "TranmitFile in DoDATACommandEx failed with error %d !!!!", m_Error);
            DisconnectClient();
            return FALSE;
        }

        //need to reset the ATQ timeout thread since we pended two
        //I/Os back to back.
        AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_RESUME_IO, 0);

    } else { //quit if we don't get the 354 response
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "DATA", InputLine);
        ErrorTrace((LPARAM) this, "DoDATACommandEx executing quit command err = %c%c%c", InputLine [0],InputLine [1],InputLine [2]);

        if (InputLine[0] == SMTP_COMPLETE_SUCCESS) {
            CopyMemory(InputLine, "599", 3);
            DebugTrace((LPARAM) this, "DoDATACommandEx executing quit command err = %c%c%c", InputLine [0],InputLine [1],InputLine [2]);
        }

        //DoCompletedMessage uses the m_ResponseContext to get the error
        if ((ParameterSize > 3) &&
            ((InputLine[3] == ' ') || (InputLine[3] == CR))) {
            //Try to get error from 3 digit code on input line
            //In some cases (DoDataCommandEx), the m_ResponseContext is not
            //used
            memcpy(szResponse, InputLine, sizeof(szResponse)-sizeof(char));
            m_ResponseContext.m_dwSmtpStatus = atoi(szResponse);
            hr = m_ResponseContext.m_cabResponse.Append(
                                           InputLine + sizeof(szResponse)/sizeof(char),
                                           ParameterSize-sizeof(szResponse),
                                           NULL);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this,
                    "Unable to append Input line to Response Context", hr);

                //Really nothing we can do about this... DoCompletedMailObj
                //will send RSET and try again
            }
        }

        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);

        //If DoCompletedMessage returns TRUE... then we must post a read for the
        //response. Functions that call into this function expect it to handle
        //the IO state if it returns TRUE.
        if (fRet)
        {
            if (m_cbReceived >= m_cbMaxRecvBuffer)
                m_cbReceived = 0;

            IncPendingIoCount();
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer() + m_cbReceived,
                               m_cbMaxRecvBuffer - m_cbReceived);
            if (!fRet) {
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                m_Error = GetLastError();
                SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
                DisconnectClient();
                DecPendingIoCount();
                DebugTrace((LPARAM) this, "ReadFile in DoDataCommandEx failed with error %d", m_Error);
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::DoContentResponse

    Description:

        This function catches the final response after transmitting
        the message content

    Arguments:

        InputLine - Buffer received from remote Server
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoContentResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoContentResponse");

    //send again gets sent when we get a 552 error during the
    //RCPT to command.  This means that the server we connected
    //to has a fixed max amount of rcpts that it accepts, and we
    //went over that limit.  Therefore, we send the mail file to
    //the recipients that it accepted and then start over sending
    //the mail to the remaining recipients.  However, before doing
    //this, check the response to see if the server took the previous
    //mail O.K.
    if (m_SendAgain) {
        m_cbReceived = 0;
        m_OutputBufferSize = 0;
        m_Error = NO_ERROR;
        m_NumRcptSent = 0;
        m_NumRcptSentSaved = 0;
        m_NumFailedAddrs = 0;

        //NK** : I am moving this down as the check below seems
        //meaningless with this in here
        //m_SendAgain = FALSE;
        m_FirstRcpt = FALSE;

        _ASSERT(m_First552Address != -1);

        //NK** : I am not sure what we are trying to do here by setting pipelined addr to 552addr.
        //I am going to leave this in - but also assign this value to NextAddr which decides
        //from where we should really start
        m_FirstPipelinedAddress  = (DWORD) m_First552Address;
        m_NextAddress  = (DWORD) m_First552Address;
        m_FirstAddressinCurrentMail = (DWORD) m_First552Address;

        m_First552Address = -1;
        m_fHadSuccessfulDelivery = FALSE;

        m_TransmitTailBuffer[0] = '.';
        m_TransmitTailBuffer[1] = '\r';
        m_TransmitTailBuffer[2] = '\n';

        m_TransmitBuffers.Head = NULL;
        m_TransmitBuffers.HeadLength = 0;
        m_TransmitBuffers.Tail = m_TransmitTailBuffer;
        m_TransmitBuffers.TailLength = 3;

        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

        //reset the file pointer to the beginning
        if (SetFilePointer(m_IMsgDotStuffedFileHandle ? m_IMsgDotStuffedFileHandle->m_hFile: m_IMsgFileHandle->m_hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SetFilePointer failed--err = %d", m_Error);
            m_SendAgain = FALSE;
        } else if (InputLine [0] != SMTP_COMPLETE_SUCCESS) {
            //something went wrong before, so let's quit
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoMAILCommand executing quit command err = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
            m_SendAgain = FALSE;
        }
    }

    // Note the if clause above might change this flag so a simple
    // else won't cut it
    if (!m_SendAgain) {
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else {
        m_SendAgain = FALSE;
        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}

BOOL SMTP_CONNOUT::TransmitFileEx (HANDLE hFile, LARGE_INTEGER  &liSize,
                                   DWORD Offset, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers)

{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::TransmitFileEx");

    BOOL fRet;

    _ASSERT(hFile != INVALID_HANDLE_VALUE);
    _ASSERT(liSize.QuadPart > 0);

    QueryAtqContext()->Overlapped.Offset = Offset;

    if (!m_SecurePort) {
        DebugTrace((LPARAM) this, "Calling AtqTransmitFile");

        TraceFunctLeaveEx((LPARAM)this);

        IncPendingIoCount();

        fRet = AtqTransmitFile(
                              QueryAtqContext(),          // Atq context
                              hFile,                      // file data comes fro
                              liSize.LowPart,                     // Bytes To Send
                              lpTransmitBuffers,          // header/tail buffers
                              0
                              );

        if (!fRet) {
            DecPendingIoCount();
        }

        return ( fRet );

    } else {

        //
        // If we are connected over an SSL port, we cannot use TransmitFile,
        // since the data has to be encrypted first.
        //

        DebugTrace((LPARAM)this, "Doing async reads and writes on handle %x", hFile);

        DebugTrace( (DWORD_PTR)this, "hfile  %x", hFile );

        //
        // Send the transmit buffer header synchronously
        //

        fRet = TRUE;

        //We have no headers or Trailers if we are doing BDAT processing
        if (lpTransmitBuffers && m_TransmitBuffers.HeadLength > 0) {
            m_OutputBufferSize = m_cbMaxOutputBuffer;

            //NimishK : We look for Head length and then send Tail
            //Dosn't seem right.
            fRet = m_encryptCtx.SealMessage(
                                           (LPBYTE) m_TransmitBuffers.Tail,
                                           m_TransmitBuffers.TailLength,
                                           (LPBYTE) m_pOutputBuffer,
                                           &m_OutputBufferSize);

            if (fRet)
                fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            else
                SetLastError(AQUEUE_E_SSL_ERROR);
        }

        if (fRet) {
            //
            // issue the first async read against the file
            //
            m_dwFileOffset = 0;
            m_bComplete = FALSE;

            if ( MessageReadFile() ) {
                TraceFunctLeaveEx((LPARAM) this);
                return  TRUE;
            }
        }

        //
        // WriteFile\MessageReadFile will teardown the connection on errors
        //
        TraceFunctLeaveEx((LPARAM) this);
        return  FALSE;

    }

}

/*++

    Name:
        SMTP_CONNOUT::MessageReadFile

    Description:
        When TransmitFile cannot be used to transfer a message (for example,
        when using SSL), the message is transferred in chunks using
        MessageReadFile to retrieve chunks of the file and issueing
        corresponding asynchronous WriteFiles to the remote server.

    Arguments:
        None.

    Returns:
        TRUE if successfully read the next chunk of the file, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::MessageReadFile( void )
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNOUT::MessageReadFile");

    //
    // Main line code path
    //
    CBuffer*    pBuffer = new CBuffer();
    if ( pBuffer != NULL ) {
        LPBYTE  lpData = pBuffer->GetData();
        if ( lpData != NULL ) {
            DWORD cbBufSize = CIoBuffer::Pool.GetInstanceSize();
            // we never want to make SSL data > 16k
            if (cbBufSize > 16*1024) cbBufSize = 16*1024;
            DWORD cb =  cbBufSize -
                        m_encryptCtx.GetSealHeaderSize() -
                        m_encryptCtx.GetSealTrailerSize();

            lpData += m_encryptCtx.GetSealHeaderSize();

            cb = min( cb, m_FileSize - m_dwFileOffset );

            //
            // set buffer specific IO state
            //
            pBuffer->SetIoState( MESSAGE_READ );
            pBuffer->SetSize( cb );

            DebugTrace( (LPARAM)this, "ReadFile 0x%08X, len: %d, LPO: 0x%08X",
                        lpData,
                        cb,
                        &pBuffer->m_Overlapped.SeoOverlapped.Overlapped );

            ZeroMemory( (void*)&pBuffer->m_Overlapped.SeoOverlapped, sizeof(OVERLAPPED) );
            pBuffer->m_Overlapped.SeoOverlapped.Overlapped.Offset = m_dwFileOffset;

            pBuffer->m_Overlapped.SeoOverlapped.Overlapped.pfnCompletion = FIOInternetCompletion;
            pBuffer->m_Overlapped.SeoOverlapped.ThisPtr = this;

//            pBuffer->m_Overlapped.m_pIoBuffer = (LPBYTE)InputLine;

            //
            // increment the overall pending io count for this session
            //
            IncPendingIoCount();

            if ( FIOReadFile(m_IMsgDotStuffedFileHandle ? m_IMsgDotStuffedFileHandle : m_IMsgFileHandle,
                             lpData,
                             cb,
                             &pBuffer->m_Overlapped.SeoOverlapped.Overlapped ) == FALSE ) {
                DecPendingIoCount();
                ErrorTrace( (LPARAM)this, "AtqReadFile failed.");
            } else {
                TraceFunctLeaveEx((LPARAM) this);
                return  TRUE;
            }
        }
        delete  pBuffer;
    }

    m_Error = GetLastError();

    ErrorTrace( (LPARAM)this, "MessageReadFile failed. err: %d", m_Error );
    DisconnectClient();
    TraceFunctLeaveEx((LPARAM)this);

    return  FALSE;
}

/*++

    Name :
        SMTP_CONNOUT::FreeAtqFileContext

    Description :
        Frees AtqContext associated with message files transfered using
        async reads and writes.

    Arguments :
        None. Operates on m_pAtqFileContext

    Returns :
        Nothing

--*/

void SMTP_CONNOUT::FreeAtqFileContext( void )
{
    PATQ_CONTEXT    pAtq;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::FreeAtqFileContext");

#if 0
    pAtq = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqFileContext, (PVOID) NULL );
    if ( pAtq != NULL ) {
        DebugTrace((LPARAM) this, "Freeing AtqFileContext!");
        pAtq->hAsyncIO = NULL;
        AtqFreeContext( pAtq, FALSE );
    }
#endif

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        SMTP_CONNOUT::DoCompletedMessage

    Description:

        Sends the SMTP QUIT command.
        This function always returns false.
        This will stop all processing and
        delete this object.

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNOUT::DoCompletedMessage(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;
    DWORD MsgStatus = 0;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoCompletedMessage");

    //see if the response received has some bad code
    if (InputLine[0] != SMTP_COMPLETE_SUCCESS) {
        //  NimishK :
        //Assumption : If I get 5XX response that leads to DOQUIT it means something real bad happened.
        //We will consider this as a permanent error and NDR all recipients
        //If the code is 4XX we will Retry all recipients
        if (InputLine[0] == SMTP_COMPLETE_FAILURE) {
            MsgStatus = MESSAGE_STATUS_NDR_ALL | MESSAGE_STATUS_EXTENDED_STATUS_CODES;
        } else {
            MsgStatus = MESSAGE_STATUS_RETRY_ALL | MESSAGE_STATUS_EXTENDED_STATUS_CODES;
            if (m_fHadHardError) {
                MsgStatus |= MESSAGE_STATUS_CHECK_RECIPS;
            }
        }
        if (m_ResponseContext.m_cabResponse.Length() > 1) {
            InputLine = m_ResponseContext.m_cabResponse.Buffer();
            ParameterSize = m_ResponseContext.m_cabResponse.Length();
            Error = m_ResponseContext.m_dwSmtpStatus;
        }

    } else if (m_Error == NO_ERROR) {
        //if the message was delivered successfully
        //then bump up our counter
        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

        if (!IsOptionSet(DSN_OPTION)) {
            MsgStatus |= MESSAGE_STATUS_DSN_NOT_SUPPORTED;
        }

        //If we have generate DELAY DSN or NDR DSN we need to tell
        //AQ to look at the recipients
        if (m_fNeedRelayedDSN || m_fHadHardError) {
            MsgStatus |= MESSAGE_STATUS_CHECK_RECIPS;
        }

        //If we had no failures we can set this special status for optimization
        //if only error we had was a hard error - there is no reason to report anything
        if (!m_fHadTempError && !m_fHadHardError )
            MsgStatus |= MESSAGE_STATUS_ALL_DELIVERED;
        else if (m_fHadTempError)
            MsgStatus |= MESSAGE_STATUS_RETRY_ALL;

    } else {
        //The remote server did not have a problem, but we had internal
        //problem
        //NimishK : Add an extended Status
        MsgStatus = MESSAGE_STATUS_RETRY_ALL;
    }

    //figure out what to do with the completed
    //message(e.g. send to retryq, remoteq, badmail,
    //etc.)

    //Includes per recipient 4xx level errors
    if (InputLine[0] == SMTP_TRANSIENT_FAILURE) {
        //If we cannot connect to the next IpAddress, then ack the message as is
        if (ConnectToNextIpAddress()) {
            //$$REVIEW - mikeswa 9/11/98
            //In this case we will attempt to connect to another IP address.
            //Most of the state is reset at this point (except for recipient
            //failures and status strings).  What happens if we fail to connect?
            //Do we:
            //  - Ack the message as RETRY (current implementation)
            //  - Attempt to ack the message with CHECK_RECIPS as well and
            //    let the per-recip flags be enought detail for the DSN code?
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }
    }

    HandleCompletedMailObj(MsgStatus, InputLine, ParameterSize);

    if (InputLine[0] == SMTP_TRANSIENT_FAILURE
        || (Error == SMTP_SERVICE_UNAVAILABLE_CODE)
        || (Error == SMTP_INSUFF_STORAGE_CODE)|| (Error == SMTP_SERVICE_CLOSE_CODE)
        || QuerySmtpInstance()->IsShuttingDown()) {
        //No point in continuing with other messages in this connection
        //Set the connection ack status to DROPPED - AQ will look at my last
        //Msg Ack and determine what to do with remaining messages
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Active = FALSE;

        DebugTrace( (LPARAM)this, "got this error %u on response, calling DoSessionEndEvent", Error );
        fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
    } else {
        fRet = StartSession();
        if (!fRet) {
            //Set the connection Ack status
            m_dwConnectionStatus = CONNECTION_STATUS_OK;
            DebugTrace( (LPARAM)this, "StartSession failed, calling DoSessionEndEvent", Error );
            fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}

/*++

    Name :
        SMTP_CONNOUT::DoQUITCommand

    Description:

    Just generates a QUIT command

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNOUT::DoQUITCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoQUITCommand");

    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    m_OutboundContext.m_cabNativeCommand.Reset();

    fRet = PE_AppendSmtpMessage("QUIT\r\n");

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}


/*++

    Name :
        SMTP_CONNOUT::WaitForRSETResponse

    Description:
        Waits for the response to the RSET command

    Arguments:
        The remote SMTP *MUST* send "250" as the status code in the RSET
        response according to RFC 2821. This function ends the session if
        the first digit of the RSET response is other than '2'.

    Returns:

      FALSE if object should be deleted, and session dropped
      TRUE otherwise

--*/
BOOL SMTP_CONNOUT::WaitForRSETResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL    fRet = TRUE;
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::WaitForRSETResponse");

    _ASSERT (QuerySmtpInstance() != NULL);

    //
    // The response is not RFC-compliant. It lacks the 3 digit status - drop
    // connection. We need to do the minimum possible amount of processing of
    // the input from this point on. Many SMTP_CONNOUT functions make assumptions
    // about the well-formedness of the input, and will have problems if an
    // RFC-violating InputLine is passed into them. For example DoCompletedMessage
    // assumes that InputLine[0] is a digit at the very least. The safe thing to
    // do is to disconnect and delete this object.
    //

    if(ParameterSize < 5 || !isdigit((UCHAR)InputLine[0]) ||
            !isdigit((UCHAR)InputLine[1]) || !isdigit((UCHAR)InputLine[2]))
    {
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RSET", NULL);
        ErrorTrace((LPARAM)this, "Disconnecting: Bad remote SMTP response");
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if (m_RsetReasonCode == BETWEEN_MSG)
        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
    else if (m_RsetReasonCode == ALL_RCPTS_FAILED) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = ALL_RCPTS_FAILED calling DoCompletedMessage" );

        //Check to see if all of the failures were hard (and not transient)
        //If so, set the error code to '5' instead of '4'
        if (!m_fHadTempError) { //no temp errors
            _ASSERT(m_fHadHardError); //therefore all errors must have been 5xx

            //Must have had as many failures as processed RCPT TO's
            _ASSERT(m_NumFailedAddrs >= m_NumRcptSentSaved);
            InputLine[0] = SMTP_COMPLETE_FAILURE;
        } else {
            InputLine[0] = SMTP_TRANSIENT_FAILURE;
        }
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else if (m_RsetReasonCode == NO_RCPTS_SENT) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = NO_RCPTS_SENT calling DoCompletedMessage" );
        InputLine[0] = '2';
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else if (m_RsetReasonCode == FATAL_ERROR) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = FATAL_ERROR calling DoCompletedMessage" );
        //make sure the quit code does not think everything is O.K.
        InputLine[0] = '4';
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    }
    return (fRet);
}

/*++

    Name :
        SMTP_CONNOUT::WaitForQuitResponse

    Description:
        Waits for the response to the quit command

    Arguments:
        Are ignored

    Returns:

      FALSE always

--*/
BOOL SMTP_CONNOUT::WaitForQuitResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT (QuerySmtpInstance() != NULL);
    DisconnectClient();
    return (FALSE);
}

BOOL SMTP_CONNOUT::DoTURNCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    CLIENT_CONN_PARAMS clientParams;
    SMTP_CONNECTION * SmtpConnIn = NULL;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoTURNCommand");

    if (InputLine[0] != SMTP_COMPLETE_SUCCESS) {
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "TURN", InputLine);
        FormatSmtpMessage(FSM_LOG_ALL, "QUIT\r\n");
        SendSmtpResponse();
        DisconnectClient();
        return FALSE;
    }

    SOCKADDR_IN  sockAddr;
    int cbAddr = sizeof( sockAddr);

    if ( getsockname((SOCKET) m_pAtqContext->hAsyncIO,
                     (struct sockaddr *) &sockAddr,
                     &cbAddr )) {

    }

    clientParams.sClient = (SOCKET) m_pAtqContext->hAsyncIO;
    clientParams.pAtqContext = m_pAtqContext;
    clientParams.pAddrLocal = (PSOCKADDR) NULL;
    clientParams.pAddrRemote = (PSOCKADDR)&sockAddr;
    clientParams.pvInitialBuff = NULL;
    clientParams.cbInitialBuff = 0 ;
    clientParams.pEndpoint = (PIIS_ENDPOINT)NULL;

    QuerySmtpInstance()->Reference();
    QuerySmtpInstance()->IncrementCurrentConnections();

    SmtpConnIn = (SMTP_CONNECTION *) QuerySmtpInstance()->CreateNewConnection( &clientParams);
    if (SmtpConnIn == NULL) {
        Error = GetLastError();
        SendSmtpResponse();
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //from here on, the smtpout class is responsible for
    //cleaning up the AtqContext
    m_DoCleanup = FALSE;

    //copy the real domain we are connected to.
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION, (DWORD_PTR) InternetCompletion);
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR) SmtpConnIn);
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_TIMEOUT, QuerySmtpInstance()->GetRemoteTimeOut());

    if (SmtpConnIn->StartSession()) {

    }

    return ( FALSE );
}

/*++

    Name :
        BOOL SMTP_CONNOUT::SwitchToBigReceiveBuffer

    Description:
        Helper routine to allocate a 32K buffer and use it for posting reads.
        SSL fragments can be up to 32K large, and we need to accumulate an
        entire fragment to be able to decrypt it.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully allocated, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::SwitchToBigSSLBuffers(void)
{
    char *pTempBuffer;

    pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
    if (pTempBuffer != NULL) {

        m_precvBuffer = pTempBuffer;
        m_cbMaxRecvBuffer = MAX_SSL_FRAGMENT_SIZE;

        pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
        if (pTempBuffer != NULL) {

            m_pOutputBuffer = pTempBuffer;
            m_cbMaxOutputBuffer =  MAX_SSL_FRAGMENT_SIZE;
            return ( TRUE );
        }
    }
    return ( FALSE );
}

/*++

    Name :
        char * IsLineCompleteBW

    Description:

        Looks for a CRLF starting at the back
        of the buffer. This is from some Gibraltar
        code.

    Arguments:

        pchRecv - The buffer to be scanned
        cbRecvd - size of data in the buffer
    Returns:

      A pointer where the CR is if both CRLF is found,
      or NULL

--*/
char * IsLineCompleteBW(IN OUT char *  pchRecvd, IN  DWORD cbRecvd, IN DWORD cbMaxRecvBuffer)
{
    register int Loop;

    _ASSERT( pchRecvd != NULL);

    if (cbRecvd == 0)
        return NULL;

    if (cbRecvd > cbMaxRecvBuffer)
        return NULL;
    //
    //  Scan the entire buffer ( from back) looking for pattern <cr><lf>
    //
    for ( Loop = (int) (cbRecvd - 2); Loop >= 0; Loop-- ) {
        //
        //  Check if consecutive characters are <cr> <lf>
        //

        if ( ( pchRecvd[Loop]   == '\r')  &&
             ( pchRecvd[Loop + 1]== '\n')) {
            //return where the CR is in the buffer
            return &pchRecvd[Loop];
        }

    } // for

    return (NULL);
}

/*++

    Name :
        SMTP_CONNOUT::PE_AppendSmtpMessage( IN const char * Text)

    Description:
        This function o places it's data in the native command output buffer.

    Arguments:
         Text - Data to place in the buffer

    Returns:


--*/
BOOL SMTP_CONNOUT::PE_AppendSmtpMessage(IN  char *Text)
{

	return SUCCEEDED (m_OutboundContext.m_cabNativeCommand.Append(Text, strlen(Text), NULL));

}

//---[ SMTP_CONNOUT::SetDiagnosticInfo ]---------------------------------------
//
//
//  Description:
//      Sets member diagnostic information that is later Ack'd back to AQueue
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        Verb that caused the failure or NULL
//                                      if it was not a protocol failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response or NULL if the
//                                      failure was not a protocol failure.
//  Returns:
//      -
//  History:
//      2/18/99 - MikeSwa Created
//      7/12/99 - GPulla Modified
//
//-----------------------------------------------------------------------------
void SMTP_CONNOUT::SetDiagnosticInfo(IN  HRESULT hrDiagnosticError,
                                     IN  LPCSTR szDiagnosticVerb,
                                     IN  LPCSTR szDiagnosticResponse)
{
    //
    // Guard against SMTP bugs where we set the diagnostic multiple times.
    // In 99.9% cases the first diagnostic is the one we want to keep (since
    // it is the one that was set closest to the original error).
    //
    if(m_hrDiagnosticError != S_OK)
        return;

    if(m_szDiagnosticVerb)
        free(m_szDiagnosticVerb);

    m_hrDiagnosticError = hrDiagnosticError;

    if(szDiagnosticVerb)
        m_szDiagnosticVerb = _strdup(szDiagnosticVerb);
    else
        m_szDiagnosticVerb = NULL;

    ZeroMemory(&m_szDiagnosticResponse, sizeof(m_szDiagnosticResponse));

    //Force terminating NULL
    m_szDiagnosticResponse[sizeof(m_szDiagnosticResponse)-1] = '\0';

    //Not an SMTP protocol failure
    if(!szDiagnosticResponse) return;

    //copy buffers
    strncpy(m_szDiagnosticResponse, szDiagnosticResponse,
            sizeof(m_szDiagnosticResponse)-1);

}

//---[ SMTP_CONNOUT::GetSessionPropertiesFromAQ ]-----------------------------
//
//
//  Description:
//    Calls into AQ's Connection object to get properties for a session object
//    This is primarily used to allow sinks to know who AQ thinks we are
//    connecting to.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/27/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID SMTP_CONNOUT::GetSessionPropertiesFromAQ()
{
    TraceFunctEnterEx((LPARAM)this,
        "SMTP_CONNOUT::GetSessionPropertiesFromAQ");
    IConnectionPropertyManagement *pIConnectionPropertyManagement = NULL;
    HRESULT hr = S_OK;

    if (!m_pISMTPConnection) {
        DebugTrace((LPARAM) this, "No ISMTPConnection... bailing");
        goto Exit;
    }

    hr = m_pISMTPConnection->QueryInterface(IID_IConnectionPropertyManagement,
                                    (LPVOID *) &pIConnectionPropertyManagement);

    if (FAILED(hr)) {
        pIConnectionPropertyManagement = NULL;

        // if talking to an old AQ... this is expected
        DebugTrace((LPARAM) this,
            "Cannot QI for IConnectionPropertyManagement 0x%08X", hr);
        goto Exit;
    }

    hr = pIConnectionPropertyManagement->CopyQueuePropertiesToSession(
                                                GetSessionPropertyBag());

    if (FAILED(hr))
        ErrorTrace((LPARAM) this,
            "CopyQueuePropertiesToSession failed - 0x%08X", hr);
  Exit:
    if (pIConnectionPropertyManagement)
        pIConnectionPropertyManagement->Release();

    TraceFunctLeave();
}

//---[ SMTP_CONNOUT::PromoteSessionPropertiesToAQ ]-----------------------------
//
//
//  Description:
//    Calls into AQ's Connection object to get properties for a session object
//    This is primarily used to allow sinks to know who AQ thinks we are
//    connecting to.
//
//    This is static to allow remoteq to call in as well (for connections
//	that fail before a SMTP_CONNOUT object is created).
//  Parameters:
//      pISession                Session properties for connection
//	pISMTPConnection         AQ connection object
//  Returns:
//      -
//  History:
//      11/29/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID SMTP_CONNOUT::PromoteSessionPropertiesToAQ(IUnknown *pISession,
                                             ISMTPConnection *pISMTPConnection)
{
    TraceFunctEnterEx((LPARAM)pISession,
        "SMTP_CONNOUT::PromoteSessionPropertiesToAQ");
    IConnectionPropertyManagement *pIConnectionPropertyManagement = NULL;
    HRESULT hr = S_OK;

    if (!pISMTPConnection) {
        DebugTrace((LPARAM) pISession, "No ISMTPConnection... bailing");
        goto Exit;
    }

    hr = pISMTPConnection->QueryInterface(IID_IConnectionPropertyManagement,
                                    (LPVOID *) &pIConnectionPropertyManagement);

    if (FAILED(hr)) {
        pIConnectionPropertyManagement = NULL;

        // if talking to an old AQ... this is expected
        DebugTrace((LPARAM) pISession,
            "Cannot QI for IConnectionPropertyManagement 0x%08X", hr);
        goto Exit;
    }

    hr = pIConnectionPropertyManagement->CopySessionPropertiesToQueue(
                                                pISession);

    if (FAILED(hr))
        ErrorTrace((LPARAM) pISession,
            "CopyQueuePropertiesToSession failed - 0x%08X", hr);
  Exit:
    if (pIConnectionPropertyManagement)
        pIConnectionPropertyManagement->Release();

    TraceFunctLeave();
}

//---[ SMTP_CONNOUT::CopyRemoteIPAddressToSession ]---------------------------
//
//
//  Description:
//    Copies the CLIENT_CONNECTION data into the session property bag used by
//	inbound and outbound connections
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      11/28/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID SMTP_CONNOUT::CopyRemoteIPAddressToSession()
{
    TraceFunctEnterEx((LPARAM) this,
	"SSMTP_CONNOUT::CopyRemoteIPAddressToSession");
    HRESULT hr = S_OK;
    IMailMsgPropertyBag *pISessionProperties =
        (IMailMsgPropertyBag *)GetSessionPropertyBag();

    if (!pISessionProperties) {
        ErrorTrace((LPARAM) this, "NULL ISession - bailing");
        goto Exit;
    }

    hr = pISessionProperties->PutStringA(ISESSION_PID_REMOTE_IP_ADDRESS,
					QueryClientHostName());
    if (FAILED(hr)) {

        //Trace error... otherwise ignore.
        ErrorTrace((LPARAM) this,
	        "Failed to write ISESSION_PID_REMOTE_IP_ADDRESS 0x%08X", hr);
    }

  Exit:
    TraceFunctLeave();
}
/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpsvr.cpp ===
// SMTPServer.cpp : Implementation of CSMTPServer

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "stdafx.h"
#include "dbgtrace.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "smtpsvr.h"

//DECLARE_DEBUG_PRINTS_OBJECT();

#define MAILMSG_PROGID          L"Exchange.MailMsg"

/////////////////////////////////////////////////////////////////////////////
// CSMTPServer

STDMETHODIMP CSMTPServer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_ISMTPServer,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

BOOL InitExchangeSmtpServer(PVOID Ptr, PVOID Ptr2)
{

	CSMTPServer * ThisPtr = (CSMTPServer *) Ptr;
	ThisPtr->Init((SMTP_SERVER_INSTANCE *) Ptr2);
	return TRUE;
}


//
// Add all your initialization needs here ...
//
HRESULT CSMTPServer::Init(SMTP_SERVER_INSTANCE * pInstance)
{
	_ASSERT (pInstance != NULL);

	m_pInstance = pInstance;
	return(S_OK);
}

STDMETHODIMP CSMTPServer::QueryInterface(
                        REFIID          iid,
                        void            **ppvObject
                        )
{

	if (iid == IID_IUnknown)
    {
		// Return our identity
		*ppvObject = (IUnknown *)(ISMTPServerInternal *)this;
		AddRef();
    }
	else if(iid == IID_ISMTPServer)
	{
		// Return our identity
		*ppvObject = (ISMTPServerInternal *)this;
		AddRef();
	}
    else if(iid == IID_ISMTPServerInternal)
    {
        // Return our identity
        *ppvObject = (ISMTPServerInternal *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportRouterReset)
    {
        // Return our identity
        *ppvObject = (IMailTransportRouterReset *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportSetRouterReset)
    {
        // Return our identity
        *ppvObject = (IMailTransportSetRouterReset *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportRouterSetLinkState)
    {
        // Return our identity
        *ppvObject = (IMailTransportRouterSetLinkState *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerEx)
    {
        // Return our identity
        *ppvObject = (ISMTPServerEx *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerGetAuxDomainInfoFlags)
    {
        // Return our identity
        *ppvObject = (ISMTPServerGetAuxDomainInfoFlags *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerAsync)
    {
        // Return our identity
        *ppvObject = (ISMTPServerAsync *)this;
        AddRef();
    }
    else
    {
		return(E_NOINTERFACE);
    }

    return(S_OK);
}

STDMETHODIMP CSMTPServer::AllocMessage(
			IMailMsgProperties **ppMsg
			)
{
	HRESULT hr = S_OK;
	// Create a new MailMsg
	hr = CoCreateInstance(
                    CLSID_MsgImp,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMailMsgProperties,
                    (LPVOID *)ppMsg);

	return(hr);
}

STDMETHODIMP CSMTPServer::SubmitMessage(
			IMailMsgProperties *pMsg
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->InsertIntoAdvQueue(pMsg);
	}

	return(hr);
}


STDMETHODIMP CSMTPServer::TriggerLocalDelivery(
			IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerLocalDelivery(pMsg, dwRecipientCount, pdwRecipIndexes, NULL);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::TriggerLocalDeliveryAsync(
			IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes, IMailMsgNotify *pNotify
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerLocalDelivery(pMsg, dwRecipientCount, pdwRecipIndexes, pNotify);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::TriggerServerEvent(
    DWORD dwEventID,
    PVOID pvContext)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerServerEvent(dwEventID, pvContext);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::ReadMetabaseString(DWORD MetabaseId, LPBYTE Buffer, DWORD * BufferSize, BOOL fSecure)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseString(MetabaseId, (char *) Buffer, BufferSize, (BOOL) fSecure);
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ReadMetabaseDword(DWORD MetabaseId, DWORD * dwValue)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseDword(MetabaseId, dwValue);
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ServerStartHintFunction()
{
	HRESULT hr = S_OK;

	if(m_pInstance)
	{
		m_pInstance->SinkSmtpServerStartHintFunc();
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ServerStopHintFunction()
{
	HRESULT hr = S_OK;

	if(m_pInstance)
	{
		m_pInstance->SinkSmtpServerStopHintFunc();
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ReadMetabaseData(DWORD MetabaseId, BYTE *Buffer, DWORD *BufferSize)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseData(MetabaseId, Buffer, BufferSize);
	}

	return hr;
}

//---[ CSMTPServer::AllocBoundMessage ]----------------------------------------
//
//
//  Description:
//      Creates a message and binds it to an ATQ Context
//  Parameters:
//      ppMsg       Message to allocate
//      phContent   Content handle for message
//  Returns:
//      HRESULT from alloc message event
//      E_POINTER if ppMsg or phContent is NULL
//      E_FAIL if m_pIstance is NULL
//  History:
//      7/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::AllocBoundMessage(
              OUT IMailMsgProperties **ppMsg,
              OUT PFIO_CONTEXT *phContent)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTPServer::AllocBoundMessage");
    HRESULT hr = S_OK;
	SMTP_ALLOC_PARAMS AllocParams;
    IMailMsgBind *pBindInterface = NULL;

    if (!phContent || !ppMsg)
    {
        hr = E_POINTER;
        goto Exit;
    }

    //we cannot bind the message without m_pInstance
    if (!m_pInstance)
    {
        hr = E_FAIL;
        goto Exit;
    }

    //CoCreate unbound message object
    hr = CoCreateInstance(
                    CLSID_MsgImp,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMailMsgProperties,
                    (LPVOID *)ppMsg);

    if (FAILED(hr))
        goto Exit;

    hr = (*ppMsg)->QueryInterface(IID_IMailMsgBind, (void **) &pBindInterface);
    if (FAILED(hr))
        goto Exit;

    AllocParams.BindInterfacePtr = (PVOID) pBindInterface;
    AllocParams.IMsgPtr = (PVOID) (*ppMsg);
    AllocParams.hContent = NULL;
    AllocParams.hr = S_OK;
    AllocParams.m_pNotify = NULL;

    //For client context pass in something that will stay around the lifetime of the
    //atqcontext -
    AllocParams.pAtqClientContext = m_pInstance;

    if(m_pInstance->AllocNewMessage(&AllocParams))
	{
		hr = AllocParams.hr;

		if (SUCCEEDED(hr) && (AllocParams.hContent != NULL))
			*phContent = AllocParams.hContent;
		else
			hr = E_FAIL;
	}
	else
	{
		hr = E_FAIL;
	}

  Exit:

    if (FAILED(hr) && ppMsg && (*ppMsg))
    {
        (*ppMsg)->Release();
        *ppMsg = NULL;

    }

    if (pBindInterface)
        pBindInterface->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CSMTPSvr::ResetRoutes ]-------------------------------------------------
//
//
//  Description:
//      Implements IMailTransportRouterReset::ResetRoutes.  Acts as a buffer
//      between AQ and the routers.  On shutdown... AQ can safely destroy
//      it's heap by telling ISMTPServer to release its pointer to AQ's
//      IMailTransportRouterReset interface
//  Parameters:
//      dwResetType     The type of route reset to perform.
//  Returns:
//      S_OK on success (or if no m_pIRouterReset)
//      Error code from AQUEUE if error occurs.
//  History:
//      11/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::ResetRoutes(IN DWORD dwResetType)
{
    HRESULT hr = S_OK;
    m_slRouterReset.ShareLock();

    if (m_pIRouterReset)
        hr = m_pIRouterReset->ResetRoutes(dwResetType);

    m_slRouterReset.ShareUnlock();
    return hr;
}


//---[ CSMTPSvr::RegisterResetInterface ]---------------------------------------
//
//
//  Description:
//      Implements IMailTransportSetRouterReset::RegisterResetInterface.  Used
//      by AQ to set its IMailTransportRouterReset ptr.  Also used at shutdown
//      to set its pointer to NULL.
//  Parameters:
//      IN dwVirtualServerID        Virtual server ID
//      IN pIRouterReset            AQ's IMailTransportRouterReset
//  Returns:
//      S_OK on success
//  History:
//      11/8/98 - MikeSwa Created
//      1/9/99 - MikeSwa Modified to include IMailTransportRouterSetLinkState
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::RegisterResetInterface(
                            IN DWORD dwVirtualServerID,
                            IN IMailTransportRouterReset *pIRouterReset)
{
    HRESULT hr = S_OK;

    _ASSERT(!m_pInstance || (m_pInstance->QueryInstanceId() == dwVirtualServerID));

    if (m_pInstance && (m_pInstance->QueryInstanceId() != dwVirtualServerID))
        return E_INVALIDARG;

    //Grab exclsuive lock so we don't release out from under anyone
    m_slRouterReset.ExclusiveLock();

    if (m_pIRouterReset)
        m_pIRouterReset->Release();

    if (m_pIRouterSetLinkState)
    {
        m_pIRouterSetLinkState->Release();
        m_pIRouterSetLinkState = NULL;
    }

    m_pIRouterReset = pIRouterReset;
    if (m_pIRouterReset)
    {
        m_pIRouterReset->AddRef();

        //Get new SetLinkState interface
        m_pIRouterReset->QueryInterface(IID_IMailTransportRouterSetLinkState,
                                            (VOID **) &m_pIRouterSetLinkState);
    }

    m_slRouterReset.ExclusiveUnlock();
    return S_OK;
}

STDMETHODIMP CSMTPServer::WriteLog( LPMSG_TRACK_INFO pMsgTrackInfo,
                                    IMailMsgProperties *pMsgProps,
                                    LPEVENT_LOG_INFO pEventLogInfo ,
                                    LPSTR pszProtocolLog )
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->WriteLog( pMsgTrackInfo, pMsgProps, pEventLogInfo, pszProtocolLog );
    }

    return hr;
}

//---[ CSMTPServer::SetLinkState ]----------------------------------------------
//
//
//  Description:
//      Acts as a buffer between AQ and the routers.  On shutdown... AQ can
//      safely destroy it's heap by telling ISMTPServer to release its pointer
//      to AQ's IMailTransportRouterSetLinkState interface
//  Parameters:
//      IN  szLinkDomainName        The Domain Name of the link (next hop)
//      IN  guidRouterGUID          The GUID ID of the router
//      IN  dwScheduleID            The schedule ID link
//      IN  szConnectorName         The connector name given by the router
//      IN  dwSetLinkState          The link state to set
//      IN  dwUnsetLinkState        The link state to unset
//  Returns:
//      S_OK always
//  History:
//      1/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::SetLinkState(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME               *pftNextScheduled,
        IN IMessageRouter         *pMessageRouter)
{
    HRESULT hr = S_OK;
    m_slRouterReset.ShareLock();

    if (m_pIRouterSetLinkState)
        hr = m_pIRouterSetLinkState->SetLinkState(szLinkDomainName,
                                                  guidRouterGUID,
                                                  dwScheduleID,
                                                  szConnectorName,
                                                  dwSetLinkState,
                                                  dwUnsetLinkState,
                                                  pftNextScheduled,
                                                  pMessageRouter);

    m_slRouterReset.ShareUnlock();

    return hr;
}

STDMETHODIMP CSMTPServer::TriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->TriggerLogEvent(
                        idMessage,
                        idCategory,
                        cSubstrings,
                        rgszSubstrings,
                        wType,
                        errCode,
                        iDebugLevel,
                        szKey,
                        dwOptions,
                        iMessageString,
                        hModule);
    }

    return hr;
}


//---[ CSMTPServer::ResetLogEvent ]------------------------------------------
//
//
//  Description:
//      Reset any history about events using this message and key,
//      so that the next TriggerLogEvent with one-time or periodic logging
//      will cause the event to be logged.
//  Parameters:
//      idMessage   :
//      szKey       :
//  Returns:
//      S_OK on success
//  History:
//      7/20/2000 - created, dbraun
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::ResetLogEvent(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey)
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->ResetLogEvent(
                        idMessage,
                        szKey);
    }

    return hr;
}


//---[ CSMTPServer::HrTriggerGetAuxDomainInfoFlagsEvent ]----------------------
//
//
//  Description:
//      Triggers the Get Aux Domain Info Flags event - this is to be used by aqueue to
//      query for additional domain info config stored outside the metabase
//  Parameters:
//      pszDomainName       : Name of domain to query flags for
//      pdwDomainInfoFlags  : DWORD to return domain flags
//  Returns:
//      S_OK on success
//      S_FALSE if no domain found
//  History:
//      10/6/2000 - created, dbraun
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::HrTriggerGetAuxDomainInfoFlagsEvent(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags )
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        hr = m_pInstance->HrTriggerGetAuxDomainInfoFlagsEvent(
                        pszDomainName,
                        pdwDomainInfoFlags);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpinst.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        smtpinst.cxx

   Abstract:

        This module defines the SMTP_SERVER_INSTANCE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996


    Revision History:

        David Howell        (dhowell)       May-1997    Added Etrn Logic
        Nimish Khanolkar    (NimishK)       Jan - 1998 - modified for CAPI store ce


--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <iis64.h>
#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>

#include <nsepname.hxx>
#include "smtpcli.hxx"
#include "dirnot.hxx"
#include <smtpinet.h>

// SEO Header files
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#include "smtpsvr.h"
#include "seo.h"
#include "seolib.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "seo_i.c"
#include "tran_evntlog.h"

extern "C" {
    int strcasecmp(char *s1, char *s2);
    int strncasecmp(char *s1, char *s2, int n);
}

#define STORE_DRIVER_PROGID L"Exchange.NtfsDrv"
#define SMTPSERVER_PROGID L"SMTPServer.SMTPServer.1"

#if 0
extern VOID
ServerEventCompletion(
                     PVOID        pvContext,
                     DWORD        cbWritten,
                     DWORD        dwCompletionStatus,
                     OVERLAPPED * lpo
                     );
#endif

//extern "C++" {
//BOOL g_IsShuttingDown = FALSE;
//}

DWORD BuildInitialQueueProc(void *lpThis);
VOID ProcessInitialQueueObjects(PVOID       pvContext,
                                DWORD       cbWritten,
                                DWORD       dwCompletionStatus,
                                OVERLAPPED  *lpo);

DWORD EnumAllDomains(void *ptr);

//
//  Constants
//

//
// Globals
//

#define MAX_CONNECTION_OBJECTS 5000

PFN_SF_NOTIFY   g_pSslKeysNotify = NULL;
extern STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

SmtpMappingSupportFunction(
                          PVOID pvInstance,
                          PVOID pData,
                          DWORD dwPropId);

SERVICE_MAPPING_CONTEXT g_SmtpSMC = { SmtpMappingSupportFunction};

//
//  Prototypes
//
BOOL
SetSslKeysNotify(
                PFN_SF_NOTIFY pFn
                );


/************************************************************
 *  Symbolic Constants
 ************************************************************/

static TCHAR    szServicePath[] = TEXT("System\\CurrentControlSet\\Services\\");
static TCHAR    szParametersKey[] = TEXT("\\Parameters");
static TCHAR    szParamPath[] = TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters");
static WCHAR    szParamPathW[] = L"System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters";
static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
static TCHAR    szTcpipTransient[] = TEXT("Transient");
static TCHAR    szMaxSmtpErrors[] = TEXT("MaxErrors");
static WCHAR    szMaxSmtpErrorsW[] = L"MaxErrors";
static TCHAR    szMaxRemoteTimeOut[] = TEXT("MaxRemoteTimeOut");
static WCHAR    szMaxRemoteTimeOutW[] = L"MaxRemoteTimeOut";
static TCHAR    szMaxMsgSize[] = TEXT("MaxMsgSize");
static WCHAR    szMaxMsgSizeW[] = L"MaxMsgSize";
static TCHAR    szMaxMsgSizeBeforeClose[] = TEXT("MaxMsgSizeBeforeClose");
static WCHAR    szMaxMsgSizeBeforeCloseW[] = L"MaxMsgSizeBeforeClose";
static TCHAR    szMaxRcpts[] = TEXT("MaxRcpts");
static WCHAR    szMaxRcptsW[] = L"MaxRcpts";
static TCHAR    szEnableReverseLookup[] = TEXT("EnableReverseLookup");
static WCHAR    szEnableReverseLookupW[] = L"EnableReverseLookup";
static TCHAR    szDomains[] = TEXT("Domains");
static WCHAR    szDomainsW[] = L"Domains";
static TCHAR    szNameResolution[] = TEXT("NameResolution");
static WCHAR    szNameResolutionW[] = L"NameResolution";
static TCHAR    szSmartHostType[] = TEXT("SmartHostUseType");
static WCHAR    szSmartHostTypeW[] = L"SmartHostUseType";
static TCHAR    szRetryAttempts[] = TEXT("MaxRetryAttempts");
static WCHAR    szRetryAttemptsW[] = L"MaxRetryAttempts";
static TCHAR    szRetryMinutes[] = TEXT("MaxRetryMinutes");
static WCHAR    szRetryMinutesW[] = L"MaxRetryMinutes";
static TCHAR    szShouldPipelineOut[] = TEXT("PipelineOutput");
static WCHAR    szShouldPipelineOutW[] = L"PipelineOutput";
static TCHAR    szShouldPipelineIn[] = TEXT("PipelineInput");
static WCHAR    szShouldPipelineInW[] = L"PipelineInput";
static TCHAR    szMaxHopCount[] = TEXT("MaxHopCount");
static WCHAR    szMaxHopCountW[] = L"MaxHopCount";
static TCHAR    szMaxOutConnections[] = TEXT("MaxOutConnections");
static WCHAR    szMaxOutConnectionsW[] = L"MaxOutConnections";
static TCHAR    szSendBadToAdmin[] = TEXT("SendBadToAdmin");
static WCHAR    szSendBadToAdminW[] = L"SendBadToAdmin";
static TCHAR    szSendNDRToAdmin[] = TEXT("SentNDRToAdmin");
static WCHAR    szSendNDRToAdminW[] = L"SentNDRToAdmin";
static TCHAR    szRoutingSources[] = TEXT("RoutingSources");
static WCHAR    szRoutingSourcesW[] = L"RoutingSources";
static TCHAR    szRoutingThreads[] = TEXT("RoutingThreads");
static WCHAR    szRoutingThreadsW[] = L"RoutingThreads";
static TCHAR    szDirBuffers[] = TEXT("MaxDirectoryBuffers");
static WCHAR    szDirBuffersW[] = L"MaxDirectoryBuffers";
static TCHAR    szDirBuffersSize[] = TEXT("DirectoryBuffSize");
static WCHAR    szDirBuffersSizeW[] = L"DirectoryBufferSize";
static TCHAR    szDirPendingIos[] = TEXT("NumDirPendingIos");
static WCHAR    szDirPendingIosW[] = L"NumDirPendingIos";
static TCHAR    szBadMailDir[] = TEXT("BadMailDir");
static WCHAR    szBadMailDirW[] = L"BadMailDir";

static TCHAR    szMailQueueDir[] = TEXT("MailQueueDir");
static WCHAR    szMailQueueDirW[] = L"MailQueueDir";
static TCHAR    szShouldDeliver[] = TEXT("ShouldDeliver");
static WCHAR    szShouldDeliverW[] = L"ShouldDeliver";
static TCHAR    szShouldDelete[] = TEXT("ShouldDelete");
static WCHAR    szShouldDeleteW[] = L"ShouldDelete";
static TCHAR    szDeleteDir[] = TEXT("DeleteDir");
static WCHAR    szDeleteDirW[] = L"DeleteDir";
static TCHAR    szMaxAddrObjects[] = TEXT("MaxAddressObjects");
static WCHAR    szMaxAddrObjectsW[] = L"MaxAddressObjects";
static TCHAR    szMaxMailObjects[] = TEXT("MaxMailObjects");
static WCHAR    szMaxMailObjectsW[] = L"MaxMailObjects";
static TCHAR    szRoutingDll[] = TEXT("RoutingDll");
static WCHAR    szRoutingDllW[] = L"RoutingDll";
static TCHAR    szUseFileLinks[] = TEXT("UseFileLinks");
static WCHAR    szUseFileLinksW[] = L"UseFileLinks";
static TCHAR    szMsgBatchLimit[] = TEXT("BatchMsgLimit");
static WCHAR    szMsgBatchLimitW[] = L"BatchMsgLimit";
static TCHAR    szMailPickupDir[] = TEXT("MailPickupDir");
static WCHAR    szMailPickupDirW[] = L"MailPickupDir";
static TCHAR    szMailDropDir[] = TEXT("MailDropDir");
static WCHAR    szMailDropDirW[] = L"MailDropDir";
static TCHAR    szShouldPickupMail[] = TEXT("ShouldPickupMail");
static WCHAR    szShouldPickupMailW[] = L"ShouldPickupMail";
static TCHAR    szCommandLogMask[] = TEXT("CommandLogMask");
static WCHAR    szCommandLogMaskW[] = L"CommandLogMask";
static TCHAR    szShowEightBitMime[] = TEXT("ShowEightBitMime");
static WCHAR    szShowEightBitMimeW[] = L"ShowEightBitMime";
static TCHAR    szShowBinaryMime[] = TEXT("ShowBinaryMime");
static WCHAR    szShowBinaryMimeW[] = L"ShowBinaryMime";
static TCHAR    szShowChunking[] = TEXT("ShowChunking");
static WCHAR    szShowChunkingW[] = L"ShowChunking";
static TCHAR    szFlushMailFiles[] = TEXT("FlushMailFiles");
static WCHAR    szFlushMailFilesW[] = L"FlushMailFiles";
static TCHAR    szVirtualRoot[] = TEXT("Virtual Roots");
static WCHAR    szVirtualRootW[] = L"Virtual Roots";

static TCHAR    szRRetryAttempts[] = TEXT("MaxRemoteRetryAttempts");
static WCHAR    szRRetryAttemptsW[] = L"MaxRemoteRetryAttempts";
static TCHAR    szRRetryMinutes[] = TEXT("MaxRemoteRetryMinutes");
static WCHAR    szRRetryMinutesW[] = L"MaxRemoteRetryMinutes";

static TCHAR    szShareRetryMinutes[] = TEXT("MaxShareRetryMinutes");
static WCHAR    szShareRetryMinutesW[] = L"MaxShareRetryMinutes";


// Always use ANSI for Internet compatibility, even if UNICODE is defined
static WCHAR    szDefaultDomainW[] = L"DefaultDomain";
static TCHAR    szDefaultDomain[] = TEXT("DefaultDomain");
static WCHAR    szConnectResponseW[] = L"ConnectResponse";
static TCHAR    szConnectResponse[] = TEXT("ConnectResponse");
static WCHAR    szSmartHostNameW[] = L"SmartHost";
static TCHAR    szSmartHostName[] = TEXT("SmartHost");


//
// Added by keithlau on 7/12/96
//
#define SMTP_EVENTLOG_MAX_ITEMS     10

#define SMTP_INIT_ABSORT          0x00000001
#define SMTP_INIT_CSLOCK          0x00000002
#define SMTP_INIT_OUTLOCK         0x00000004
#define SMTP_INIT_GENLOCK         0x00000008


const LPSTR     pszPackagesDefault = "NTLM\0GSSAPI\0";
const DWORD     ccbPackagesDefault = sizeof( "NTLM\0GSSAPI\0" );

extern AQ_INITIALIZE_EX_FUNCTION g_pfnInitializeAQ;
extern AQ_DEINITIALIZE_EX_FUNCTION g_pfnDeinitializeAQ;

extern HRESULT CallInstanceInitStoreDriver(DWORD InstanceId, IAdvQueue *pIAq, char * UserName,
                                           char * DomainName, char * Password, char * DnToUse);

extern void CallInstanceDeInitStoreDriver(DWORD InstanceId);

//extern HRESULT HrGetGatewayDN(IN OUT DWORD *pcbBuffer,
//                       IN     LPSTR szBuffer);

inline BOOL
ConvertToMultisz(LPSTR szMulti, DWORD *pdwCount, LPSTR szAuthPack)
{
    CHAR *pcStart = szAuthPack, *pc;
    DWORD dw = 0;

    pc = pcStart;
    if (*pc == '\0' || *pc == ',')
        return FALSE;

    *pdwCount = 0;
    while (TRUE) {
        if (*pc == '\0') {
            strcpy(&szMulti[dw], pcStart);
            (*pdwCount)++;
            dw += lstrlen(pcStart);
            szMulti[dw + 1] = '\0';
            return TRUE;
        } else if (*pc == ',') {
            *pc = '\0';
            lstrcpy(&szMulti[dw], pcStart);
            (*pdwCount)++;
            dw += lstrlen(pcStart);
            dw++;
            *pc = ',';
            pcStart = ++pc;
        } else {
            pc++;
        }
    }
}


//
// Quick and dirty range check using inlines (KeithLau 7/28/96)
//
static inline BOOL pValidateRange(DWORD dwValue, DWORD dwLower, DWORD dwUpper)
{
    // Inclusive
    if ((dwValue >= dwLower) && (dwValue <= dwUpper))
        return (TRUE);

    SetLastError(ERROR_INVALID_PARAMETER);
    return (FALSE);
}

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return (FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return (TRUE);
    return (FALSE);
}


static inline BOOL ConvertFromUnicode(LPWSTR pwsz, char * psz, DWORD cchMax)
/*++
    Converts a given string into unicode string
    Returns FALSE on failure. Use GetLastError() for details.
--*/
{
    DWORD   cch;

    cch = lstrlenW(pwsz) + 1;
    if (cchMax < cch) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    int iRet;

    iRet = WideCharToMultiByte(CP_ACP, 0, pwsz, cch, psz, cchMax, NULL, NULL);

    return (iRet != 0);
} // ConvertToUnicode()

//
// Enumeration stuff
//
DWORD WINAPI EnumBuildQProc(LPVOID  pvContext)
{
    SMTP_SERVER_INSTANCE    *pInst = (SMTP_SERVER_INSTANCE *)pvContext;

    _ASSERT(pInst);

    pInst->TriggerStoreServerEvent(SMTP_STOREDRV_ENUMMESS_EVENT);

    return (NO_ERROR);
}

DWORD
InitializeInstances(
                   PSMTP_IIS_SERVICE pService
                   )
/*++

Routine Description:

    Reads the instances from the metabase

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
    DWORD   i;
    DWORD   cInstances = 0;
    MB      mb( (IMDCOM*) pService->QueryMDObject() );
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   err = NO_ERROR;
    BUFFER  buff;
    BOOL    fMigrateRoots = FALSE;


    //
    //  Open the metabase for write to get an atomic snapshot
    //

    ReOpen:

    if ( !mb.Open( "/LM/SMTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {
        DBGPRINTF(( DBG_CONTEXT,
                    "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/SMTPSVC/", GetLastError() ));

        //
        //  If the web service key isn't here, just create it
        //

        if ( !mb.Open(METADATA_MASTER_ROOT_HANDLE,
                      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/SMTPSVC/" )) {
            err = GetLastError();
            return err;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "/LM/SMTPSvc not found, auto-created\n" ));

        mb.Close();
        goto ReOpen;
    }

    //_VERIFY(mb.SetString("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, "NTLM,LOGIN"));
    DWORD dwVersion;
    if (!mb.GetDword("", MD_SMTP_SERVICE_VERSION, IIS_MD_UT_SERVER, &dwVersion)) {
        _VERIFY(mb.SetDword("", MD_SMTP_SERVICE_VERSION, IIS_MD_UT_SERVER, g_ProductType));
    }
    //_VERIFY(mb.SetDword("", MD_SMTP_AUTHORIZATION, IIS_MD_UT_SERVER, 7));
    //_VERIFY(mb.SetDword("", MD_AUTHORIZATION, IIS_MD_UT_SERVER, 7));



    //
    // Loop through instance keys and build a list.  We don't keep the
    // metabase open because the instance instantiation code will need
    // to write to the metabase
    //

    TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ )) {
        DWORD dwInstance;

        //
        // Get the instance id
        //

        DBGPRINTF((DBG_CONTEXT,"instance key %s\n",szKeyName));

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) ) {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) ) {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" )) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );
    mb.Save();

    for ( i = 0; i < cInstances; i++ ) {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if ( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {
            err = GetLastError();

            DBGPRINTF((DBG_CONTEXT,
                       "InitializeInstances: cannot create instance %lu, error %lu\n",
                       dwInstance, err));

            //break;
        }

    }

    return err;

} // InitializeInstances


//+---------------------------------------------------------------
//
//  Function:   StopInstance
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL
StopSmtpInstances(
                 PVOID                   pvContext,
                 PVOID                   pvContext1,
                 PIIS_SERVER_INSTANCE    pInstance
                 )
{
    PSMTP_SERVER_INSTANCE pSmtpInstance = (PSMTP_SERVER_INSTANCE)pInstance;

    if ( !pSmtpInstance->Stop() ) {

    }

    return TRUE;
}

/*++

Routine Description:

    Shutdown each instance and terminate all global cpools

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
VOID
TerminateInstances( PSMTP_IIS_SERVICE pService)
{
    PFN_INSTANCE_ENUM pfnInstanceEnum = NULL;

    TraceFunctEnter("TerminateInstances");

    //
    //  Iterate over all instances
    //  StopInstance callback calls SMTP_SERVER_INSTANCE::Stop()
    //
    pfnInstanceEnum = (PFN_INSTANCE_ENUM)&StopSmtpInstances;
    if ( !pService->EnumServiceInstances(
                                        NULL,
                                        NULL,
                                        pfnInstanceEnum
                                        ) ) {

        ErrorTrace(0,"Error enumerating instances");
    }

    TraceFunctLeave();
}


SMTP_SERVER_INSTANCE::SMTP_SERVER_INSTANCE(
                                          IN PSMTP_IIS_SERVICE pService,
                                          IN DWORD  dwInstanceId,
                                          IN USHORT Port,
                                          IN LPCSTR lpszRegParamKey,
                                          IN LPWSTR lpwszAnonPasswordSecretName,
                                          IN LPWSTR lpwszVirtualRootsSecretName,
                                          IN BOOL   fMigrateRoots
                                          )
:   IIS_SERVER_INSTANCE(pService,
                        dwInstanceId,
                        Port,
                        lpszRegParamKey,
                        lpwszAnonPasswordSecretName,
                        lpwszVirtualRootsSecretName,
                        fMigrateRoots)
//m_signature (SMTP_SERVER_INSTANCE_SIGNATURE)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE" );

    m_pSmtpStats                = NULL;

    m_IsShuttingDown            = FALSE;
    m_QIsShuttingDown           = FALSE;
    m_RetryQIsShuttingDown      = FALSE;
    m_IsFileSystemNtfs          = TRUE;
    m_fShouldStartAcceptingConnections = TRUE;
    m_SmtpInitializeStatus      = 0;

    m_cCurrentConnections       = 0;
    m_cMaxCurrentConnections    = 0;
    m_cCurrentOutConnections    = 0;
    m_dwNextInboundClientId     = 1;
    m_dwNextOutboundClientId    = 1;
    m_dwStopHint                = 2;
    m_cProcessClientThreads     = 0;
    m_cNumConnInObjsAlloced     = 0;
    m_cNumConnOutObjsAlloced    = 0;
    m_cNumCBufferObjsAlloced    = 0;
    m_cNumAsyncObjsAlloced      = 0;
    m_cNumAsyncDnsObjsAlloced   = 0;
    m_cchConnectResponse        = 0;
    m_cCurrentRoutingThreads    = 0;
    m_cMaxOutConnectionsPerDomain = 0;
    m_cMaxOutConnections        = 0;
    m_cMaxHopCount              = 0;
    m_RemoteSmtpPort            = 0;
    m_cMaxRcpts                 = 0;
    m_fMasquerade               = FALSE;
    m_fIgnoreTime               = FALSE;
    m_fStartRetry               = FALSE;
    m_fRequiresSSL              = FALSE;
    m_fRequires128Bits          = FALSE;
    m_fRequiresCertVerifySubject= FALSE;
    m_fRequiresCertVerifyIssuer = FALSE;
    m_pSSLInfo                  = NULL;
    m_fLimitRemoteConnections   = TRUE;
    m_RDNSOptions               = 0;
    m_fAllowVerify              = FALSE;
    m_InstBooted                = FALSE;
    m_fStoreDrvStartEventCalled  = FALSE;
    m_fStoreDrvPrepShutDownEventCalled = FALSE;
    m_fScheduledConnection      = FALSE;
    m_fIsRoutingTable           = TRUE;
    m_fHaveRegisteredPrincipalNames = FALSE;

    m_fHelloNoValidate          = FALSE;
    m_fMailNoValidate           = FALSE;
    m_fRcptNoValidate           = FALSE;
    m_fEtrnNoValidate           = FALSE;
    m_fPickupNoValidate         = FALSE;
    m_pProviderPackagesInfo     = NULL;
    fInitializedAQ = FALSE;
    fInitializedStoreDriver = FALSE;

    // Raid 174038
    m_fDisablePickupDotStuff = FALSE;

    m_szMasqueradeName [0] = '\0';
    m_szMailQueueDir[0] = '\0';
    m_szMailPickupDir[0] = '\0';
    m_szMailDropDir[0] = '\0';
    m_szBadMailDir[0] = '\0';
    m_szMyDomain[0] = '\0';
    m_szDefaultDomain[0] = '\0';
    m_szFQDomainName[0] = '\0';
    m_szSmartHostName[0] = '\0';
    m_szPostDnsSmarthost[0] = '\0';
    m_AdminName[0] = '\0';
    m_BadMailName[0] = '\0';
    m_DefaultRemoteUserName[0] = '\0';
    m_DefaultRemotePassword[0] = '\0';

    SmtpDir = NULL;
    DirPickupThreadHandle = NULL;
    StopHandle = NULL;
    m_hEnumDomainThreadHandle = NULL;
    m_pChangeObject = NULL;

    m_IAQ = NULL;
    m_ICM = NULL;
    m_pvAQInstanceContext = NULL;
    m_pIAdvQueueConfig = NULL;
    m_RemoteQ = NULL;
    m_ComSmtpServer = NULL;
    m_pSmtpInfo = NULL;

    m_dwEventlogLevel = LOGEVENT_LEVEL_MEDIUM;
    m_dwDnsFlags = 0;
    m_dwDeniedIpAction = 0;

    InitializeCriticalSection( &m_critBoot ) ;
    m_fInitAsyncCS = FALSE;

    m_cServerList = 0;
    ZeroMemory(m_rgpServerList, sizeof(m_rgpServerList));

    m_signature = SMTP_INSTANCE_SIGNATURE;

    TraceFunctLeaveEx((LPARAM)this);
    return;

} // SMTP_SERVER_INSTANCE::SMTP_SERVER_INSTANCE



SMTP_SERVER_INSTANCE::~SMTP_SERVER_INSTANCE(
                                           VOID
                                           )
{
    ULONG i = 0;

    TraceFunctEnterEx((LPARAM)this, "~SMTP_SERVER_INSTANCE" );

    EnterCriticalSection( &m_critBoot );

    if ( m_InstBooted && !m_fShutdownCalled) {
        InitiateShutDown();
    } else
        ErrorTrace((LPARAM) this, "Shutdown for instance %d was already called", QueryInstanceId());

    for(i = 0; i < m_cServerList; i++) {
        if(m_rgpServerList[i])
            delete m_rgpServerList[i];
    }

    LeaveCriticalSection( &m_critBoot );

    DeleteCriticalSection( &m_critBoot ) ;

    TraceFunctLeaveEx((LPARAM) this);
}

//---------------------------------------------------------------------------------------
//  Description:
//      Called by InitiateStartup() to initialize members of SMTP_SERVER_INSTANCE when
//      a VSI is started up. InitiateStartup() is called by IIS to start a VSI.
//  Arguments:
//      None.
//  Returns:
//      None.
//---------------------------------------------------------------------------------------
void SMTP_SERVER_INSTANCE::InitializeClassVariables(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitializeClassVariables" );

    m_pSmtpStats                = NULL;

    m_IsShuttingDown            = FALSE;
    m_QIsShuttingDown           = FALSE;
    m_RetryQIsShuttingDown      = FALSE;
    m_fShouldStartAcceptingConnections = TRUE;
    m_SmtpInitializeStatus      = 0;

    m_cCurrentConnections       = 0;
    m_cMaxCurrentConnections    = 0;
    m_cCurrentOutConnections    = 0;
    m_dwNextInboundClientId     = 1;
    m_dwNextOutboundClientId    = 1;
    m_dwStopHint                = 2;
    m_cProcessClientThreads     = 0;
    m_cNumConnInObjsAlloced     = 0;
    m_cNumConnOutObjsAlloced    = 0;
    m_cNumCBufferObjsAlloced    = 0;
    m_cNumAsyncObjsAlloced      = 0;
    m_cNumAsyncDnsObjsAlloced   = 0;
    m_cchConnectResponse        = 0;
    m_fMasquerade               = FALSE;
    m_fIgnoreTime               = FALSE;
    m_fStartRetry               = FALSE;
    m_fLimitRemoteConnections   = TRUE;
    m_fShutdownCalled           = FALSE;
    m_fSendNDRToAdmin           = FALSE;
    m_fSendBadToAdmin           = FALSE;
    m_fRequiresSASL             = FALSE;
    m_szDefaultLogonDomain[0]   = '\0';
    m_fStoreDrvStartEventCalled  = FALSE;
    m_fStoreDrvPrepShutDownEventCalled = FALSE;

    //directory pickup stuff
    SmtpDir = NULL;
    DirPickupThreadHandle = NULL;
    StopHandle = NULL;
    m_hEnumDomainThreadHandle = NULL;

    // Raid 174038
    m_fDisablePickupDotStuff = FALSE;

    m_QStopEvent = NULL;
    m_hEnumBuildQ = NULL;

    InitializeListHead( &m_ConnectionsList);
    InitializeListHead( &m_OutConnectionsList);
    InitializeListHead( &m_leVRoots);
    InitializeListHead( &m_AsynConnectList);
    InitializeListHead( &m_AsyncDnsList);

    InitializeCriticalSection( &m_csLock);
    m_SmtpInitializeStatus |= SMTP_INIT_CSLOCK;

    _ASSERT(!m_fInitAsyncCS && "Doubly initialized critsec");
    if(!m_fInitAsyncCS) {
        InitializeCriticalSection( &m_csAsyncDns );
        InitializeCriticalSection( &m_csAsyncConnect ) ;
        m_fInitAsyncCS = TRUE;
    }

    m_szConnectResponse[0] = '\0';

    // Set the logging handle
    m_InstancePropertyBag.SetLogging(&m_Logging);

    TraceFunctLeaveEx((LPARAM) this);
}

BOOL SMTP_SERVER_INSTANCE::AllocNewMessage(SMTP_ALLOC_PARAMS * Params)
{
    TraceFunctEnterEx((LPARAM)this, "AllocNewMessage");

    HRESULT  hr = S_OK;
    BOOL fRet = TRUE;

    Params->m_InstanceId = QueryInstanceId();
    Params->m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    Params->m_pNotify = NULL;

    hr = TriggerServerEvent(SMTP_STOREDRV_ALLOC_EVENT, (PVOID) Params);

    if (FAILED(hr)) {
        fRet = FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;

}

HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseDword(DWORD MetabaseId, DWORD * dwValue)
{
    DWORD tmp = 0;
    HRESULT hr = S_FALSE;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    if (mb.Open(QueryMDPath())) {
        if ( dwValue && mb.GetDword("", MetabaseId, IIS_MD_UT_SERVER, &tmp)) {
            *dwValue = tmp;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseString(DWORD MetabaseId, char * Buffer, DWORD * BufferSize, BOOL fSecure)
{
    STR         TempString;
    HRESULT     hr = S_OK;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    DWORD   MetaOptions = METADATA_INHERIT;

    TempString.Reset();

    if (fSecure) {
        MetaOptions |= METADATA_SECURE;
    }

    if (mb.Open(QueryMDPath())) {
        if (!mb.GetStr("", MetabaseId, IIS_MD_UT_SERVER, &TempString, MetaOptions) ||
            TempString.IsEmpty()) {
            hr = S_FALSE;
        } else {
            lstrcpyn(Buffer,TempString.QueryStr(), MAX_PATH);
        }
    }

    return hr;
}

//---[ SMTP_SERVER_INSTANCE::SinkReadMetabaseData -----------------------------
//
//
//  Description:
//      Reads arbitraty binary Metabase data (like an ACL)
//  Parameters:
//      IN      MetabaseId      ID to read data from
//      IN OUT  pBuffer         Buffer to read data into
//      IN OUT  pcbBufferSize   Size of buffer/valid data in buffer
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if buffer size is not
//                              not large enough for requested data.
//  History:
//      6/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseData(DWORD MetabaseId,
                                                   BYTE *pBuffer,
                                                   DWORD *pcbBufferSize)
{
    HRESULT     hr = S_OK;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    if (!pcbBufferSize)
        return E_INVALIDARG;

    if (mb.Open(QueryMDPath())) {
        if (!mb.GetData("",
                        MetabaseId,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        pBuffer,
                        pcbBufferSize,
                        METADATA_INHERIT)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT SMTP_SERVER_INSTANCE::TriggerLocalDelivery(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes, IMailMsgNotify *pNotify)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.IMsgPtr = (PVOID) pMsg;
    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_RecipientCount = dwRecipientCount;
    AllocParams.pdwRecipIndexes = pdwRecipIndexes;
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.hr = S_OK;
    AllocParams.m_pNotify = (PVOID) pNotify;

    _ASSERT(pMsg != NULL);
    _ASSERT(pdwRecipIndexes != NULL);
    _ASSERT(dwRecipientCount != 0);

    ADD_COUNTER (this, NumRcptsRecvdLocal, dwRecipientCount);
    ADD_COUNTER (this, NumRcptsRecvd, dwRecipientCount);

    hr = TriggerServerEvent(SMTP_STOREDRV_DELIVERY_EVENT, (PVOID) &AllocParams);

    //
    // jstamerj 1998/08/04 17:45:15:
    // If a sink returned a special error, return that to the caller of TriggerLocalDelivery
    //
    if (SUCCEEDED(hr) && FAILED(AllocParams.hr))
        hr = AllocParams.hr;

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::TriggerDirectoryDrop(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes,
                                                   LPCSTR DropDirectory)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.IMsgPtr = (PVOID) pMsg;
    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_RecipientCount = dwRecipientCount;
    AllocParams.pdwRecipIndexes = pdwRecipIndexes;
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.m_DropDirectory = DropDirectory;
    AllocParams.m_pNotify = NULL;

    _ASSERT(pMsg != NULL);
    _ASSERT(pdwRecipIndexes != NULL);
    _ASSERT(DropDirectory != NULL);
    _ASSERT(dwRecipientCount != 0);

    if (DropDirectory != NULL) {
        //  hr = TriggerServerEvent(SMTP_MAIL_DROP_EVENT, (PVOID) &AllocParams);

    } else {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::TriggerStoreServerEvent(DWORD EventType)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.m_dwStartupType = SMTP_INIT_VSERVER_STARTUP;
    AllocParams.m_pNotify = NULL;

    hr = TriggerServerEvent(EventType, (PVOID) &AllocParams);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerDnsResolverEvent(
    LPSTR HostName,
    LPSTR pszFQDN,
    DWORD dwVirtualServerId,
    DNS_SERVER_INFO **ppDnsServerInfo,
    IDnsResolverRecord **ppIDnsResolverRecord )
{
    HRESULT hr = S_FALSE;

    EVENTPARAMS_DNSRESOLVERRECORD params;
    params.pszHostName = HostName;
    params.pszFQDN = pszFQDN;
    params.dwVirtualServerId = dwVirtualServerId;
    params.ppIDnsResolverRecord = ppIDnsResolverRecord;
    params.ppDnsServerInfo = ppDnsServerInfo;

    hr = TriggerServerEvent( SMTP_DNSRESOLVERRECORDSINK_EVENT, (PVOID) &params);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerMaxMsgSizeEvent(
    IUnknown      *pIUnknown,
    IMailMsgProperties *pIMailMsg,
    BOOL          *pfShouldImposeLimit )
{
    HRESULT hr = S_FALSE;

    EVENTPARAMS_MAXMSGSIZE params;
    params.pIUnknown = pIUnknown;
    params.pIMailMsg = pIMailMsg;
    params.pfShouldImposeLimit = pfShouldImposeLimit;

    hr = TriggerServerEvent( SMTP_MAXMSGSIZE_EVENT, (PVOID)&params );

    return( hr );
}

/////////////////////////////////////////////////////////////////
void SMTP_SERVER_INSTANCE::WriteLog(
    LPMSG_TRACK_INFO pMsgTrackInfo,
    IMailMsgProperties *pMsgProps,
    LPEVENT_LOG_INFO pEventLogInfo,
    LPSTR pszProtocolLog )
{
    //
    // do the message tracking stuff
    //

    if( pMsgTrackInfo || pMsgProps )
    {
        EVENTPARAMS_MSGTRACKLOG msgTrackLogParams;

        msgTrackLogParams.pIServer = GetInstancePropertyBag();
        msgTrackLogParams.pIMailMsgProperties = pMsgProps;
        msgTrackLogParams.pMsgTrackInfo = pMsgTrackInfo;
        TriggerServerEvent( SMTP_MSGTRACKLOG_EVENT, (PVOID)&msgTrackLogParams );
    }

    //
    // do the event log stuff
    //

    if( pEventLogInfo )
    {
        SmtpLogEventEx( pEventLogInfo->dwEventId, pEventLogInfo->pszEventLogMsg, pEventLogInfo->dwErrorCode );
    }

    //
    // do protocol logging stuff
    //

    if( pszProtocolLog )
    {
        INETLOG_INFORMATION translog;
        ZeroMemory( &translog, sizeof( translog ) );
        translog.pszOperation = "SMTPSVC_LOG";
        translog.cbOperation = strlen ("SMTPSVC_LOG");
        translog.pszHTTPHeader = pszProtocolLog;
        translog.cbHTTPHeaderSize = strlen( pszProtocolLog );

        m_Logging.LogInformation( &translog );
    }
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    HRESULT hr = S_OK;

    EVENTPARAMS_LOG         LogParms;
    SMTP_LOG_EVENT_INFO     LogEventInfo;

    // Construct the log event info
    LogEventInfo.idMessage = idMessage;
    LogEventInfo.idCategory = idCategory;
    LogEventInfo.cSubstrings = cSubstrings;
    LogEventInfo.rgszSubstrings = rgszSubstrings;
    LogEventInfo.wType = wType;
    LogEventInfo.errCode = errCode;
    LogEventInfo.iDebugLevel = iDebugLevel;
    LogEventInfo.szKey = szKey;
    LogEventInfo.dwOptions = dwOptions;
    LogEventInfo.iMessageString = iMessageString;
    LogEventInfo.hModule = hModule;

    // Construct the event context
    LogParms.pSmtpEventLogInfo = &LogEventInfo;
    LogParms.pDefaultEventLogHandler = &g_EventLog;
    LogParms.iSelectedDebugLevel = m_dwEventlogLevel;
    TriggerServerEvent( SMTP_LOG_EVENT, (PVOID)&LogParms );

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::ResetLogEvent(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey)
{
    HRESULT hr = S_OK;

    hr = g_EventLog.ResetEvent(idMessage, szKey);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::HrTriggerGetAuxDomainInfoFlagsEvent(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags )
{
    HRESULT                                 hr          = S_OK;
    EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS   EventParams;
    DWORD   dwStartTicks, dwStopTicks;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:HrTriggerGetAuxDomainInfoFlagsEvent" );

    _ASSERT(pdwDomainInfoFlags);

    // Before we trigger the event, let's pre-set pdwDomainInfoFlags
    // to be "DOMAIN_INFO_INVALID" so we get the right result if there
    // were no sinks
    *pdwDomainInfoFlags = DOMAIN_INFO_INVALID;

    // Construct the event params
    EventParams.pIServer = GetInstancePropertyBag();
    EventParams.pszDomainName = pszDomainName;
    EventParams.pdwDomainInfoFlags = pdwDomainInfoFlags;

    DebugTrace((LPARAM)this, "Triggering event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT ...");

    // Count ticks for calling this event
    dwStartTicks = GetTickCount();

    hr = TriggerServerEvent( SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT, (PVOID)&EventParams );
    if(FAILED(hr)) {
        goto Exit;
    }

    dwStopTicks = GetTickCount();

    DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT took %d ms.",
                    dwStopTicks - dwStartTicks);

    if (*EventParams.pdwDomainInfoFlags & DOMAIN_INFO_INVALID) {
        // domain info not found ... the caller can interpret the flags
        DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT did NOT return data");
        hr = S_OK;
    }
    else {
        DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT returned flags : %d", *EventParams.pdwDomainInfoFlags);
        hr = S_OK;
    }

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerServerEvent(DWORD dwEventID, PVOID pvContext)
{
    return m_CSMTPSeoMgr.HrTriggerServerEvent(dwEventID, pvContext);
}

/////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//  Description:
//      Performs per-startup initialization of SMTP_SERVER_INSTANCE. All initialization
//      in here is de-inited by InitiateShutDown(). IIS calls this function each time
//      a VSI is started up.
//  Arguments:
//      None.
//  Returns:
//      TRUE on success, FALSE otherwise.
//  Notes:
//      InitiateStartup() and InitiateShutdown() could be called multiple times for the
//      same SMTP_SERVER_INSTANCE by IIS. If this fails, IIS will shutdown the VSI by
//      calling InitiateShutdown().
//--------------------------------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::InitiateStartup(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitiateStartup" );

    DWORD error = NO_ERROR, err = NO_ERROR;
    CSMTPServer * Ptr = NULL;
    HRESULT hr = S_OK;

    EnterCriticalSection( &m_critBoot );

    InitializeClassVariables();

    Ptr = new CSMTPServer();
    if (Ptr != NULL) {
        Ptr->Init(this);
        hr = Ptr->QueryInterface(IID_ISMTPServer, (void **) &m_ComSmtpServer);
        if (FAILED(hr) || !m_ComSmtpServer) {
            err = GetLastError();
            ErrorTrace((LPARAM) this, "QueryInterface for m_ComSmtpServer failed - %x", hr);
            goto error_exit;
        }
    } else {
        ErrorTrace((LPARAM) this, "new CSMTPServer() failed");
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    m_QStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_QStopEvent == NULL) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "Creating stop event failed - %d", err);
        goto error_exit;
    }

    //
    // Create statistics object before initializing the queues
    //

    m_pSmtpStats = new SMTP_SERVER_STATISTICS(this);
    if ( m_pSmtpStats == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        ErrorTrace((LPARAM) this, "new SMTP_SERVER_STATISTICS(this) failed - %d", err);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // initialize the info list - used to collect performance info (a bit of a backdoor
    // to get the information back
    //
    if (!(m_pSmtpInfo = new SMTP_INSTANCE_LIST_ENTRY)) {
        ErrorTrace((LPARAM) this, "new SMTP_INSTANCE_LIST_ENTRY failed");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    m_pSmtpInfo->dwInstanceId = QueryInstanceId();
    m_pSmtpInfo->pSmtpServerStatsObj = m_pSmtpStats;

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->AcquireServiceExclusiveLock();
    InsertTailList((((PSMTP_IIS_SERVICE) g_pInetSvc)->GetInfoList()), &(m_pSmtpInfo->ListEntry));
    ((PSMTP_IIS_SERVICE) g_pInetSvc)->ReleaseServiceExclusiveLock();

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    //
    // shinjuku initialization
    //
    hr = m_CSMTPSeoMgr.HrInit(QueryInstanceId());

    if (FAILED(hr)) {
        char szInst[10];

        _itoa((int)QueryInstanceId(), szInst, 10);
        ErrorTrace((LPARAM)this, "Error: Failed to initialize SEO for instance %u",
                   QueryInstanceId());
        SmtpLogEventEx(SEO_INIT_FAILED_INSTANCE,
                       szInst,
                       hr);
        goto error_exit;
    }

    if (!InitFromRegistry()) {
        err= GetLastError();
        ErrorTrace((LPARAM) this, "init from registry failed. err = %d", err);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);
        goto error_exit;
    }

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    TriggerStoreServerEvent(SMTP_STOREDRV_STARTUP_EVENT);
    m_fStoreDrvStartEventCalled = TRUE;

    // Enumerate files ...
    DWORD dwThreadId;
    m_hEnumBuildQ = CreateThread(
                                NULL,
                                0,
                                EnumBuildQProc,
                                (LPVOID)this,
                                0,
                                &dwThreadId);
    if (m_hEnumBuildQ == NULL) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "Creating startup enumeration thread failed - %d", err);
        goto error_exit;
    }

    // Initialize the mail pickup stuff, only if enabled
    if (ShouldPickupMail() && !InitDirectoryNotification()) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "InitDirectoryNotification() failed. err: %u", error);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);
        goto error_exit;
    }

    LeaveCriticalSection( &m_critBoot );
    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;

    error_exit:

    LeaveCriticalSection( &m_critBoot );
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

PSMTP_INSTANCE_LIST_ENTRY SMTP_SERVER_INSTANCE::GetSmtpInstanceInfo(void)
{
    AQPerfCounters AqPerf;
    HRESULT hr = S_FALSE;

    if (m_pIAdvQueueConfig != NULL) {
        AqPerf.cbVersion = sizeof(AQPerfCounters);
        hr = m_pIAdvQueueConfig->GetPerfCounters(
            &AqPerf,
            (m_pSmtpInfo) ?
                &(m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->CatPerfBlock) :
                NULL);
    }

    if(!FAILED(hr))
    {
        if(m_pSmtpInfo)
        {
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RemoteQueueLength = AqPerf.cCurrentQueueMsgInstances;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumMsgsDelivered = AqPerf.cMsgsDeliveredLocal;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->LocalQueueLength = AqPerf.cCurrentMsgsPendingLocalDelivery;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RemoteRetryQueueLength = AqPerf.cCurrentMsgsPendingRemoteRetry;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumSendRetries = AqPerf.cTotalMsgRemoteSendRetries;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumNDRGenerated = AqPerf.cNDRsGenerated;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RetryQueueLength = AqPerf.cCurrentMsgsPendingLocalRetry;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumDeliveryRetries = AqPerf.cTotalMsgLocalRetries;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->ETRNMessages = AqPerf.cTotalMsgsTURNETRN;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->CatQueueLength = AqPerf.cCurrentMsgsPendingCat;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailNoRecipients = AqPerf.cTotalMsgsBadmailNoRecipients;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailHopCountExceeded = AqPerf.cTotalMsgsBadmailHopCountExceeded;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailFailureGeneral = AqPerf.cTotalMsgsBadmailFailureGeneral;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailBadPickupFile = AqPerf.cTotalMsgsBadmailBadPickupFile;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailEvent = AqPerf.cTotalMsgsBadmailEvent;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailNdrOfDsn = AqPerf.cTotalMsgsBadmailNdrOfDsn;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsPendingRouting = AqPerf.cCurrentMsgsPendingRouting;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsPendingUnreachableLink = AqPerf.cCurrentMsgsPendingUnreachableLink;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->SubmittedMessages = AqPerf.cTotalMsgsSubmitted;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->DSNFailures = AqPerf.cTotalDSNFailures;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsInLocalDelivery = AqPerf.cCurrentMsgsInLocalDelivery;

        }
    }
    return m_pSmtpInfo;
}

//---[ SMTP_SERVER_INSTANCE::HrGetDomainInfoFlags ]----------------------------
//
//
//  Description:
//      Gets domain info flags for specified domain if present
//  Parameters:
//      IN  szDomainName          Name of domain to check for
//      OUT pdwDomainInfoFlags    DomainInfo flags for this domain
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szDomainName or pdwDomainInfoFlags is NULL
//      E_FAIL if other failure
//  History:
//      10/6/2000 - dbraun, Created.
//
//-----------------------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::HrGetDomainInfoFlags(
                IN  LPSTR szDomainName,
                OUT DWORD *pdwDomainInfoFlags)
{
    HRESULT                 hr  = S_OK;
    IAdvQueueDomainType   * pIAdvQueueDomainType = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:HrGetDomainInfoFlags" );

    // Make sure we have a valid IAdvQueue interface
    if (!m_IAQ) {
        ErrorTrace((LPARAM) this, "Member m_IAQ is not valid");
        _ASSERT(m_IAQ);
        hr = E_FAIL;
        goto exit;
    }

    // Get the IAdvQueueDomainType interface
    hr = m_IAQ->QueryInterface(IID_IAdvQueueDomainType, (void **) &pIAdvQueueDomainType);
    if (FAILED(hr) || !pIAdvQueueDomainType) {
        ErrorTrace((LPARAM) this, "QueryInterface for IID_IAdvQueueDomainType failed - %x", hr);
        hr = E_FAIL;
        goto exit;
    }

    // Got the interface, now check for the domain
    hr = pIAdvQueueDomainType->GetDomainInfoFlags(szDomainName, pdwDomainInfoFlags);

exit:

    if (pIAdvQueueDomainType)
        pIAdvQueueDomainType->Release();

    TraceFunctLeaveEx((LPARAM) this);

    return hr;
}


BOOL SMTP_SERVER_INSTANCE::Stop(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:Stop" );

    //set the global termination flag
    m_IsShuttingDown = TRUE;

    EnterCriticalSection( &m_critBoot );

    if (m_ICM) {
        m_ICM->ReleaseWaitingThreads();
    }

    if (!m_InstBooted) {
        LeaveCriticalSection( &m_critBoot );
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if (m_fShutdownCalled) {
        LeaveCriticalSection( &m_critBoot );
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if (m_QStopEvent) {
        SetEvent(m_QStopEvent);
    }

    //disconnect all inbound connections
    DisconnectAllConnections();

    DisconnectAllAsyncDnsConnections();

    //disconnect all outbound connections
    DisconnectAllOutboundConnections();

    DisconnectAllAsyncConnections();

    //we need to disconnect all outbound connections again here,
    //incase one slipped past the remote queue shutdown code
    DisconnectAllOutboundConnections();

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );
    LeaveCriticalSection( &m_critBoot );

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

//-----------------------------------------------------------------------------------
//  Description:
//      Function called by IIS to deinitialize SMTP_SERVER_INSTANCE when the VSI is
//      stopping. Note that this function can be called multiple times for the same
//      SMTP_SERVER_INSTANCE. A matching call to InitializeClassVariables() and
//      InitiateStartup() do is made by IIS (to start SMTP_SERVER_INSTANCE).
//  Arguments:
//      None.
//  Returns:
//      None.
//-----------------------------------------------------------------------------------
void SMTP_SERVER_INSTANCE::InitiateShutDown(void)
{
    char IntBuffer [20];

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitiateShutDown" );

    EnterCriticalSection( &m_critBoot );

    Stop();

    // Wait for the enum buildq thread to die ...
    if (m_hEnumBuildQ) {
        DWORD   dwWait;
        do {
            dwWait = WaitForSingleObject(m_hEnumBuildQ, 1000);
            if (dwWait == WAIT_TIMEOUT)
                StopHint();

        } while (dwWait != WAIT_OBJECT_0);

        CloseHandle(m_hEnumBuildQ);
        m_hEnumBuildQ = NULL;
    }

    // Wait for the enum domains thread to die ...
    if (m_hEnumDomainThreadHandle) {
        DWORD   dwWait;
        do {
            dwWait = WaitForSingleObject(m_hEnumDomainThreadHandle, 1000);
            if (dwWait == WAIT_TIMEOUT)
                StopHint();

        } while (dwWait != WAIT_OBJECT_0);

        CloseHandle(m_hEnumDomainThreadHandle);
        m_hEnumDomainThreadHandle = NULL;
    }

    //make sure directory notification threads are shut down
    if (ShouldPickupMail())
        DestroyDirectoryNotification();

    //Prepare for shutdown *must* be called before StopQDrivers... otherwise
    //we may have stray threads calling into submit messages... which could
    //AV.
    if(m_fStoreDrvStartEventCalled && !m_fStoreDrvPrepShutDownEventCalled)
    {
        TriggerStoreServerEvent(SMTP_STOREDRV_PREPSHUTDOWN_EVENT);
        m_fStoreDrvPrepShutDownEventCalled = TRUE;
    }

    // After this NOBODY can submit to the queue, the pointers are GONE
    StopQDrivers();

    if( m_fStoreDrvStartEventCalled )
    {
        TriggerStoreServerEvent(SMTP_STOREDRV_SHUTDOWN_EVENT);
    }

    //now that all the queues have stopped receiving data,
    //flush each queue, by removing all data and then delete
    //the queues.

    if (m_RemoteQ != NULL) {
        delete m_RemoteQ;
        m_RemoteQ = NULL;
    }


    DebugTrace((LPARAM)this, "removing and delete the Info List");

    if (m_pSmtpInfo != NULL) {
        ((PSMTP_IIS_SERVICE)g_pInetSvc)->AcquireServiceExclusiveLock();
        RemoveEntryList(&(m_pSmtpInfo->ListEntry));
        ((PSMTP_IIS_SERVICE)g_pInetSvc)->ReleaseServiceExclusiveLock();

        delete (m_pSmtpInfo);
        m_pSmtpInfo = NULL;
    }

    DebugTrace((LPARAM)this, "deleting statistics obj");

    //
    // delete statistics object
    //

    if ( m_pSmtpStats != NULL ) {
        delete m_pSmtpStats;
        m_pSmtpStats = NULL;
    }


    FreeVRootList(&m_leVRoots);

    DebugTrace((LPARAM)this, "deleting crit sects");

    //Delete the critical section objects

    if (m_SmtpInitializeStatus & SMTP_INIT_CSLOCK) {
        DeleteCriticalSection( &m_csLock);
        m_SmtpInitializeStatus &= ~SMTP_INIT_CSLOCK;
    }

    if (m_pProviderPackagesInfo != NULL ) {
        m_pProviderPackagesInfo->Release();
        m_pProviderPackagesInfo = NULL;
    }

    //free the SSL info object
    if ( m_pSSLInfo != NULL ) {
        //If the refcount is not zero - we have a problem
        DWORD dwCount = IIS_SSL_INFO::Release( m_pSSLInfo );

        m_pSSLInfo = NULL;
    }

    ResetRelayIpSecList();

    //
    // shutdown shinjuku
    // this causes SEO to drop all loaded objects
    //
    m_CSMTPSeoMgr.Deinit();

    if (m_ComSmtpServer != NULL) {
        m_ComSmtpServer->Release();
        m_ComSmtpServer = NULL;
    }

    if (m_QStopEvent != NULL) {
        CloseHandle(m_QStopEvent);
        m_QStopEvent = NULL;
    }

    //
    // here we see if we are getting shutdown because we are being
    // deleted.  if so then we'll remove all of our bindings from
    // the shinjuku event binding database
    //
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    StopHint();

    if (mb.Open(QueryMDPath())) {
        // our metabase path still exists, so we aren't being deleted
        mb.Close();
    } else {
        StopHint();

        // our metabase path is gone, delete the shinjuku binding
        // database
        HRESULT hr = UnregisterPlatSEOInstance(QueryInstanceId());
        if (FAILED(hr)) {
            char szInst[10];

            _itoa((int)QueryInstanceId(), szInst, 10);
            ErrorTrace(0, "UnregisterSEOInstance(%lu) failed with %x",
                       QueryInstanceId(), hr);
            SmtpLogEventEx(SEO_DELETE_INSTANCE_FAILED,
                           szInst,
                           hr);
        }
    }

    _ASSERT(m_fInitAsyncCS && "Deleting un-initialized critsec");
    if(m_fInitAsyncCS) {
        DeleteCriticalSection( &m_csAsyncDns);
        DeleteCriticalSection( &m_csAsyncConnect);
        m_fInitAsyncCS = FALSE;
    }

    m_fShutdownCalled = TRUE;

    LeaveCriticalSection( &m_critBoot );

    TraceFunctLeaveEx((LPARAM) this);
}

DWORD SMTP_SERVER_INSTANCE::PauseInstance()
{
    DWORD err = NO_ERROR ;
    char IntBuffer [20];

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::PauseInstance");

    err = IIS_SERVER_INSTANCE::PauseInstance() ;

    if (err == NO_ERROR) {
        _itoa(QueryInstanceId(), IntBuffer, 10);

        SmtpLogEventEx(SMTP_EVENT_SERVICE_INSTANCE_PAUSED, IntBuffer, 0);
    }

    TraceFunctLeaveEx((LPARAM)this);

    return err ;
}
/*++

Routine Description:

    Sets instance to RUNNING

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/

DWORD SMTP_SERVER_INSTANCE::StartInstance(void)
{
    DWORD RetCode = ERROR_INVALID_SERVICE_CONTROL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::StartInstance(void)" );

    _ASSERT(QueryServerState( ) == MD_SERVER_STATE_STOPPED);

    //initiate our startup first
    if ( InitiateStartup() ) {

        RetCode = IIS_SERVER_INSTANCE::StartInstance();

        if (RetCode != ERROR_SUCCESS) {
            // shutdown the instance
            InitiateShutDown();
            DebugTrace((LPARAM)this, "StartInstance() failed, err= %d", RetCode);
        }
        else
        {
            m_InstBooted = TRUE;
        }


    } else {
        //shutdown everything
        InitiateShutDown();
    }



    TraceFunctLeaveEx((LPARAM)this);
    return RetCode;
}

DWORD SMTP_SERVER_INSTANCE::StopInstance(void)
{
    DWORD RetCode = NO_ERROR;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::StopInstance(void)" );

    //call the IIS stuff first.
    RetCode = IIS_SERVER_INSTANCE::StopInstance();

    if (RetCode == NO_ERROR) {
        //shutdown everything
        InitiateShutDown();
    } else {
        DebugTrace((LPARAM)this, "StopInstance() failed, err= %d", RetCode);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return RetCode;
}

BOOL SMTP_SERVER_INSTANCE::InitQueues(void)
{
    DWORD error = NO_ERROR;
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InitQueues" );

    m_RemoteQ = PERSIST_QUEUE::CreateQueue(REMOTEQ, this);
    if (m_RemoteQ != NULL) {
        fReturn = TRUE;
    } else {
        error = GetLastError();
        ErrorTrace((LPARAM)this, "new failed for PERSIST_QUEUE::CreateQueue(REMOTEQ). err: %u", error);
        if (error == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
    }

    return fReturn;
}

void SMTP_SERVER_INSTANCE::FreeVRootList(PLIST_ENTRY pleHead)
{
    PLIST_ENTRY             pEntry;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::FreeVRootList" );

    while (!IsListEmpty(pleHead)) {
        pEntry = RemoveHeadList(pleHead);
        TCP_FREE(CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list));
    }

    TraceFunctLeaveEx((LPARAM)this);
}



BOOL
GetVroots(
         PVOID          pvContext,
         MB *           pmb,
         VIRTUAL_ROOT * pvr
         )
/*++

Routine Description:

    Virtual directory enumerater callback that allocates and builds the
    virtual directory structure list

Arguments:
    pvContext is a pointer to the midl allocated memory

Return:

    TRUE if success, otherwise FALSE

--*/
{
    //LPINET_INFO_VIRTUAL_ROOT_LIST  pvrl = (LPINET_INFO_VIRTUAL_ROOT_LIST) pv
    //DWORD                          i = pvrl->cEntries;
    //LPINET_INFO_VIRTUAL_ROOT_ENTRY pvre = &pvrl->aVirtRootEntry[i];

    //_ASSERT( pvr->pszMetaPath[0] == '/' &&
    //          pvr->pszMetaPath[1] == '/' );


    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::FindBestVRoot(LPSTR szVRoot)
{
    PLIST_ENTRY             pEntry;
    HANDLE                  hToken;
    DWORD                   cbRoot;
    char                    szRoot[MAX_PATH + 1];
    DWORD                   dwErr;
    DWORD                   dwBytes;
    DWORD                   dwSectors;
    DWORD                   dwFree;
    DWORD                   dwTotal;
    DWORD                   dwRatio;
    DWORD                   dwRatioKeep;
    PLIST_ENTRY             pKeep = NULL;
    LPSTR                   szT;
    DWORD                   cSlash;
    DWORD                   dwAccessMask = 0;
    SMTP_VROOT_ENTRY        *pVrEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTPCONFIG::FindBestVRoot");

    if (IsListEmpty(&m_leVRoots)) {
        ErrorTrace((LPARAM)this, "Vroots list empty");
        return FALSE;
    }

    for (pEntry = m_leVRoots.Flink ; pEntry != &m_leVRoots ; pEntry = pEntry->Flink) {
        cbRoot = sizeof(szRoot);

        pVrEntry = (SMTP_VROOT_ENTRY *) CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list);

        if (!QueryVrootTable()->LookupVirtualRoot(pVrEntry->szVRoot,
                                                  szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                                                  &hToken, NULL)) {
            dwErr = GetLastError();
            ErrorTrace(NULL, "ResolveVirtualRoot failed for %s, %u",
                       CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list)->szVRoot, dwErr);
        } else {
            cSlash = 0;
            if (szRoot[0] == '\\' && szRoot[1] == '\\') {
                // UNC Name
                DebugTrace((LPARAM)this, "Found UNC path %s", szRoot);
                szT = szRoot;

                while (*szT) {
                    if (*szT == '\\') {
                        cSlash++;
                        if (cSlash == 4) {
                            *(szT + 1) = '\0';
                        }
                    }

                    szT++;
                }

                if (cSlash != 4) {
                    lstrcat(szRoot, "\\");
                }
            } else {
                DebugTrace((LPARAM)this, "Found normal directory: %s", szRoot);
                szRoot[3] = '\0';
            }

            DebugTrace((LPARAM)this, "Getting free disk ratio on %s", szRoot);
            if (hToken == 0 || ImpersonateLoggedOnUser(hToken)) {
                if (GetDiskFreeSpace(szRoot, &dwSectors, &dwBytes, &dwFree, &dwTotal)) {
                    dwSectors *= dwBytes;
                    dwRatio = MulDiv(dwSectors, dwTotal, dwFree);
                    if (pKeep == NULL) {
                        dwRatioKeep = dwRatio;
                        pKeep = pEntry;
                    } else {
                        if (dwRatioKeep > dwRatio) {
                            dwRatioKeep = dwRatio;
                            pKeep = pEntry;
                        }
                    }
                }

                if (hToken != 0)
                    _VERIFY(RevertToSelf());
            }
        }
    }

    if (pKeep != NULL)
        lstrcpy(szVRoot, CONTAINING_RECORD(pKeep, SMTP_VROOT_ENTRY, list)->szVRoot);
    else
        lstrcpy(szVRoot, pVrEntry->szVRoot);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::WriteRegParams
//
//  Synopsis:   Writes parameters from a config info structure
//              into the registry
//
//  Arguments:  SMTP_CONFIG_INFO *: pointer to config information
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::WriteRegParams(SMTP_CONFIG_INFO *pconfig)
{

    //TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

DWORD ReadMetabaseDword (MB& mb, DWORD Key, DWORD DefaultValue)
{
    DWORD tmp = 0;

    if ( !mb.GetDword("", Key, IIS_MD_UT_SERVER, &tmp)) {
        //mb.SetDword("", Key, IIS_MD_UT_SERVER, DefaultValue);
        tmp = DefaultValue;
    }

    return tmp;

}

BOOL CProviderPackagesInfo::SetProviderPackages()
{
    TraceFunctEnter( "CProviderPackages::SetProviderPackages" );

    LPSTR   psz;
    DWORD   i;

    PAUTH_BLOCK pBlock = NULL;

    if ( m_ProviderNames == NULL || m_cProviderPackages == 0) {
        ErrorTrace((LPARAM)this, "Invalid Parameters: 0x%08X, %d",
                   m_ProviderNames, m_cProviderPackages );
        return FALSE;
    }

    pBlock = (PAUTH_BLOCK)LocalAlloc(0, m_cProviderPackages * sizeof(AUTH_BLOCK));
    if (pBlock == NULL) {
        ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
        return FALSE;
    }

    //
    // start at 1 since 0 indicates the Invalid protocol
    //
    for ( i=0, psz = (LPSTR)m_ProviderNames; i< m_cProviderPackages; i++ ) {
        //
        // this would be the place to check whether the package was valid
        //
        DebugTrace( 0, "Protocol: %s", psz);

        pBlock[i].Name = psz;

        psz += lstrlen(psz) + 1;
    }

    m_ProviderPackages = pBlock;

    return  TRUE;

} // SetAuthPackageNames


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
                    STR * pstrDomainName
                    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    TraceFunctEnter("GetDefaultDomainName");

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugTrace(0,"cannot open lsa policy, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugTrace(0,"cannot query lsa policy info, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                );

    if ( Result <= 0 ) {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if ( !pstrDomainName->Resize( (UINT)Result + 1 ) ) {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                );

    if ( Result <= 0 ) {
        err = GetLastError();

        DebugTrace(0,"cannot convert domain name to ANSI, error %d\n",err );
        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    _ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    _ASSERT( err == 0 );

    DebugTrace(0,"GetDefaultDomainName: default domain = %s\n",pstrDomainName->QueryStr() );

    Cleanup:

    if ( DomainInfo != NULL ) {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if ( LsaPolicyHandle != NULL ) {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()

//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::ReadRegParams
//
//  Synopsis:   Reads parameters from the registry into the config
//              class member variables and IServer (m_InstancePropertyBag)
//
//  Arguments:  FIELD_CONTROL: Bit-field defining what params to
//                  read.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//  Note:       BOOL fInit argument removed by KeithLau on 7/15/96
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::ReadRegParams(
    FIELD_CONTROL fc, BOOL fRebuild, BOOL fShowEvents)
{
    BOOL        fRet = TRUE;
    DWORD       dwErr = NO_ERROR;
    DWORD       dwAttr;
    DWORD       dwLen;
    DWORD       dwTempVar;
    DWORD       dwAqueueWait = 0;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    char        ScratchBuffer [400];
    STR         TempString;
    const CHAR * apszSubStrings[4];
    CHAR pchAddr1[32] = "";
    AQConfigInfo AQConfig;
    HRESULT      hr;

    char szDomainName[MAX_PATH + 1] = {0};

    TraceFunctEnterEx((LPARAM)this, "SMTPCONFIG::SMTP_SERVER_INSTANCE");

    SetLastError(NO_ERROR);

    m_fDefaultInRt = FALSE;

    ZeroMemory(&AQConfig, sizeof(AQConfig));

    // Make sure we've got a valid field control input
    _ASSERT(fc != 0 && !(fc & ~(FC_SMTP_INFO_ALL)));

    m_GenLock.ExclusiveLock();

    _itoa(QueryInstanceId(), pchAddr1, 10);

    //
    //  Read metabase data.
    //

    if ( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) {
        m_GenLock.ExclusiveUnlock();
        return FALSE;
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_ROUTING)) {
        GetCatInfo(mb, AQConfig);
    }

    ZeroMemory(&AQConfig, sizeof(AQConfig));

    if (IsFieldSet(fc, FC_SMTP_INFO_REVERSE_LOOKUP)) {
        dwTempVar = 0;
        dwTempVar = ReadMetabaseDword(mb, MD_REVERSE_NAME_LOOKUP, 0);

        // If the value is changing, generate an information NT event...
        if (dwTempVar != m_RDNSOptions) {
            apszSubStrings[0] = pchAddr1;

            if (fShowEvents) {
                if (dwTempVar)
                    SmtpLogEvent(SMTP_EVENT_SET_REVERSE_LOOKUP_ENABLED, 1, apszSubStrings, 0);
                else
                    SmtpLogEvent(SMTP_EVENT_SET_REVERSE_LOOKUP_DISABLED, 1, apszSubStrings, 0);
            }

            m_RDNSOptions = dwTempVar;

            StateTrace((LPARAM)this, "m_fEnableReverseLookup = %u", m_RDNSOptions);
        }
    }

    //I am isung this for all commands
    if (IsFieldSet(fc, FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS)) {
        m_InboundCmdOptions = ReadMetabaseDword(mb, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, SMTP_DEFAULT_CMD_SUPPORT);
        m_OutboundCmdOptions = ReadMetabaseDword(mb, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, SMTP_DEFAULT_OUTBOUND_SUPPORT);

        m_fAddNoHdrs = !!ReadMetabaseDword(mb, MD_ADD_NOHEADERS, FALSE);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SSL_PERM)) {

        BOOL fRequiresCertVerifySubject;
        BOOL fRequiresCertVerifyIssuer;

        fRequiresCertVerifyIssuer =
            ReadMetabaseDword (mb, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, FALSE);

        fRequiresCertVerifySubject =
            ReadMetabaseDword (mb, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, FALSE);

        m_fRequiresCertVerifySubject = fRequiresCertVerifySubject;
        m_fRequiresCertVerifyIssuer = fRequiresCertVerifyIssuer;

        BOOL fRequiresSSL, fRequires128Bits;

        dwTempVar = ReadMetabaseDword(mb, MD_SSL_ACCESS_PERM, FALSE);

        fRequiresSSL = IsFieldSet(dwTempVar, MD_ACCESS_SSL);
        fRequires128Bits = IsFieldSet(dwTempVar, MD_ACCESS_SSL128);

        apszSubStrings[0] = pchAddr1;

        // If the value is changing, generate an information NT event...
        if (fShowEvents && (fRequiresSSL != m_fRequiresSSL)) {
            SmtpLogEvent(
                        fRequiresSSL ?
                        SMTP_EVENT_REQUIRE_SSL_INBOUND_ENABLE :
                        SMTP_EVENT_REQUIRE_SSL_INBOUND_DISABLE, 1, apszSubStrings, 0);
        }
        m_fRequiresSSL = fRequiresSSL;

        if (fShowEvents && (fRequires128Bits != m_fRequires128Bits)) {
            SmtpLogEvent(
                        fRequires128Bits ?
                        SMTP_EVENT_REQUIRE_128BIT_SSL_INBOUND_ENABLE :
                        SMTP_EVENT_REQUIRE_128BIT_SSL_INBOUND_DISABLE, 1, apszSubStrings, 0);
        }
        m_fRequires128Bits = fRequires128Bits;

        StateTrace((LPARAM)this,
                   "m_fRequiresSSL = %s, m_fRequires128Bits = %s",
                   m_fRequiresSSL ? "TRUE" : "FALSE",
                   m_fRequires128Bits ? "TRUE" : "FALSE");

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_COMMON_PARAMS)) {
        DWORD   dwDomainValidationFlags = 0;
        DWORD   dwNameResolution = 0;

        m_dwDnsFlags = ReadMetabaseDword(mb, MD_SMTP_USE_TCP_DNS, 0);

        m_dwNameResolution = ReadMetabaseDword(mb, MD_NAME_RESOLUTION_TYPE, 1);

        StateTrace((LPARAM)this, "m_dwNameResolution = %u", m_dwNameResolution);

        m_cMaxBatchLimit = ReadMetabaseDword(mb, MD_BATCH_MSG_LIMIT, 20);

        AQConfig.cMinMessagesPerConnection = m_cMaxBatchLimit;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MIN_MSG;

        AQConfig.dwConnectionWaitMilliseconds = ReadMetabaseDword(mb, MD_SMTP_AQUEUE_WAIT, 60000);
        //AQConfig.dwConnectionWaitMilliseconds = INFINITE;

        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_CON_WAIT;

        StateTrace((LPARAM)this, "m_cMaxBatchLimit = %u", m_cMaxBatchLimit);

        m_fRelayForAuthUsers = !!ReadMetabaseDword(mb, MD_SMTP_RELAY_FOR_AUTH_USERS, TRUE);

        m_fIsRelayEnabled = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_RELAY, TRUE);
        m_fHelloNoDomain = !!ReadMetabaseDword(mb, MD_SMTP_HELO_NODOMAIN, TRUE);
        m_fMailFromNoHello = !!ReadMetabaseDword(mb, MD_SMTP_MAIL_NO_HELO, FALSE);


        //Per spec these two are related
        if (m_fMailFromNoHello)
            m_fHelloNoDomain = TRUE;

        m_fNagleIn = !!ReadMetabaseDword(mb, MD_SMTP_INBOUND_NAGLE, FALSE);
        m_fNagleOut = !!ReadMetabaseDword(mb, MD_SMTP_OUTBOUND_NAGLE, FALSE);

        dwDomainValidationFlags = !!ReadMetabaseDword(mb, MD_DOMAIN_VALIDATION_FLAGS, 0);
        m_fHelloNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_EHLO;
        m_fMailNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_MAIL;
        m_fRcptNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_RCPT;
        m_fEtrnNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_ETRN;
        m_fPickupNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_PKUP;
        m_dwDeniedIpAction = ReadMetabaseDword(mb, MD_SMTP_DENIED_IP_ACTION, SMTPDENIEDIP_DROPCONN);

        TempString.Reset();

        if(mb.GetStr("", MD_SMTP_POST_DNS_SMARTHOST, IIS_MD_UT_SERVER,
                &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(m_szPostDnsSmarthost, TempString.QueryStr(), sizeof(m_szPostDnsSmarthost));
            DebugTrace((LPARAM)this, "Post DNS smarthost = %s", m_szPostDnsSmarthost);
        } else {
            m_szPostDnsSmarthost[0] = '\0';
            DebugTrace((LPARAM)this, "No post DNS smarthost configured");
        }

        ReadRouteDomainIpSecList(mb);
        // Raid 174038
        m_fDisablePickupDotStuff = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_PICKUP_DOT_STUFF, FALSE);
        StateTrace((LPARAM)this, "m_fDisablePickupDotStuff = %u", m_fDisablePickupDotStuff);
        m_dwEventlogLevel = ReadMetabaseDword(mb,
                                              MD_SMTP_EVENTLOG_LEVEL,
                                              LOGEVENT_LEVEL_MEDIUM);

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_OUT_CONN_PER_DOMAIN, 20);

        if (fShowEvents && (dwTempVar != m_cMaxOutConnectionsPerDomain)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_CONN_PER_DOMAIN, 2, apszSubStrings, 0);
        }

        m_cMaxOutConnectionsPerDomain = dwTempVar;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MAX_LINK;
        AQConfig.cMaxLinkConnections = dwTempVar;

        StateTrace((LPARAM)this, "m_cMaxOutConnectionsPerDomain = %u", m_cMaxOutConnectionsPerDomain);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_AUTHORIZATION)) {
        m_dwAuth = ReadMetabaseDword(mb, MD_AUTHORIZATION, DEFAULT_AUTHENTICATION);
        DebugTrace((LPARAM)this, "m_dwAuth=%u", m_dwAuth);
    }

    //
    // update the following data members:
    //  m_ProviderPackages
    //  m_ProviderNames
    //  m_cProviderPackages

    CProviderPackagesInfo *pProviderPackagesInfo = NULL;

    if (IsFieldSet(fc, FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS) &&
            (pProviderPackagesInfo = new CProviderPackagesInfo())) {

        CHAR szAuthPack[MAX_PATH + 1];
        DWORD dwLen;

        TempString.Reset();

        if (mb.GetStr("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(szAuthPack, TempString.QueryStr(), MAX_PATH);
            dwLen = lstrlen(szAuthPack);
            DebugTrace((LPARAM)this, "Authentication packages=%s", szAuthPack);

            ULONG cProviderPackages = 0;

            if(ConvertToMultisz(
                    pProviderPackagesInfo->GetProviderNames(),
                    &cProviderPackages,
                    szAuthPack))
            {
                pProviderPackagesInfo->SetProviderPackagesCount(cProviderPackages);
            }
            else
            {
                CopyMemory(pProviderPackagesInfo->GetProviderNames(), pszPackagesDefault, ccbPackagesDefault);
                pProviderPackagesInfo->SetProviderPackagesCount(2);
            }

        } else {
            DebugTrace((LPARAM)this, "Use default authentication packages=%s", pszPackagesDefault);
            CopyMemory(pProviderPackagesInfo->GetProviderNames(), pszPackagesDefault, ccbPackagesDefault);
            pProviderPackagesInfo->SetProviderPackagesCount(1);
        }

        // set the AUTH_BLOCK info
        if (!pProviderPackagesInfo->SetProviderPackages()) {
            ErrorTrace((LPARAM)this, "Unable to allocate AUTH_BLOCK");
            pProviderPackagesInfo->Release();
        } else {
            if(m_pProviderPackagesInfo)
                m_pProviderPackagesInfo->Release();

            m_pProviderPackagesInfo = pProviderPackagesInfo;
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SASL_LOGON_DOMAIN)) {
        TempString.Reset();

        if (mb.GetStr("", MD_SASL_LOGON_DOMAIN, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(m_szDefaultLogonDomain, TempString.QueryStr(), MAX_SERVER_NAME_LEN);
            DebugTrace((LPARAM)this, "SASL logon domain =%s", m_szDefaultLogonDomain);
        } else {
            m_szDefaultLogonDomain[0] = '\0';
            DebugTrace((LPARAM)this, "no SASL default logon domain was found");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_CLEARTEXT_AUTH_PROVIDER)) {
        TempString.Reset();

        m_cbCleartextAuthPackage = sizeof(m_szCleartextAuthPackage);
        if (mb.GetStr("", MD_SMTP_CLEARTEXT_AUTH_PROVIDER, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpy(m_szCleartextAuthPackage, TempString.QueryStr());
            m_cbCleartextAuthPackage = lstrlen(m_szCleartextAuthPackage) + 1;

            StateTrace((LPARAM)this, "Cleartext authentication provider: <%s>, length %u",
                       m_szCleartextAuthPackage,
                       m_cbCleartextAuthPackage);
        } else {
            m_szCleartextAuthPackage[0] = '\0';
            m_cbCleartextAuthPackage = 0;
            StateTrace((LPARAM)this, "No default cleartext authentication provider specified, using CleartextLogon");
        }

        TempString.Reset();

        if (mb.GetStr("", MD_MD_SERVER_SS_AUTH_MAPPING, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(m_szMembershipBroker, TempString.QueryStr(), MAX_PATH);
            StateTrace((LPARAM)this, "Membership Broker name is set to %s", m_szMembershipBroker);
        } else {
            m_szMembershipBroker[0] = '\0';
            StateTrace((LPARAM)this, "No Membership Broker name configured");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_HOP_COUNT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_HOP_COUNT, 15);
        StateTrace((LPARAM)this, "m_cMaxHopCount = %u", dwTempVar);

        if (fShowEvents && (dwTempVar != m_cMaxHopCount)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_HOPCOUNT, 2, apszSubStrings, 0);
        }

        m_cMaxHopCount = dwTempVar;
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_REMOTE_PORT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_SMTP_PORT, 25);
        if (fShowEvents && (dwTempVar != m_RemoteSmtpPort)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_REMOTE_PORT, 2, apszSubStrings, 0);
        }

        m_RemoteSmtpPort = dwTempVar;

        StateTrace((LPARAM)this, "m_RemoteSmtpPort = %u", m_RemoteSmtpPort);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_ERRORS)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_SMTP_ERRORS, 10);
        if (dwTempVar == 0)
            dwTempVar = 10;

        if (fShowEvents && (dwTempVar != m_cMaxErrors)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_ERRORS, 2, apszSubStrings, 0);
        }

        m_cMaxErrors = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxErrors = %u", m_cMaxErrors);

        dwTempVar = ReadMetabaseDword(mb, MD_MAX_SMTP_AUTHLOGON_ERRORS, 4);
        if (dwTempVar == 0)
            dwTempVar = 4;

        if (fShowEvents && (dwTempVar != m_dwMaxLogonFailures)) {
            //_itoa(dwTempVar, ScratchBuffer, 10);
            // apszSubStrings[0] = pchAddr1;
            // apszSubStrings[1] = ScratchBuffer;
            //SmtpLogEvent(SMTP_EVENT_SET_MAX_ERRORS, 2, apszSubStrings, 0);

        }

        m_dwMaxLogonFailures = dwTempVar;
        StateTrace((LPARAM)this, "m_dwMaxLogonFailures = %u", m_dwMaxLogonFailures);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_SIZE)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_MSG_SIZE, 2 * 1024);

        if (fShowEvents && (dwTempVar != m_cbMaxMsgSize)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_SIZE_ACCEPTED, 2, apszSubStrings, 0);
        }

        m_cbMaxMsgSize = dwTempVar;
        StateTrace((LPARAM)this, "m_cbMaxMsgSize = %u", m_cbMaxMsgSize);

        dwTempVar = ReadMetabaseDword(mb, MD_MAX_MSG_SIZE_B4_CLOSE, 10 * 1024);
        if (fShowEvents && (dwTempVar != m_cbMaxMsgSizeBeforeClose)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_SIZE_BEFORE_CLOSE, 2, apszSubStrings, 0);
        }

        m_cbMaxMsgSizeBeforeClose = dwTempVar;
        StateTrace((LPARAM)this, "m_cbMaxMsgSizeBeforeClose = %u", m_cbMaxMsgSizeBeforeClose);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_REMOTE_TIMEOUT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_TIMEOUT, 600);

        if (fShowEvents && (dwTempVar != m_cMaxRemoteTimeOut)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_REMOTE_TIMEOUT, 2, apszSubStrings, 0);
        }

        m_cMaxRemoteTimeOut = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxRemoteTimeOut = %u", m_cMaxRemoteTimeOut);

        m_ConnectTimeout = ReadMetabaseDword(mb, MD_SMTP_CONNECT_TIMEOUT, 150);

        if (m_ConnectTimeout == 0)
            m_ConnectTimeout = 1;

        // Calculate timeout in milliseconds from timeout in seconds.
        m_ConnectTimeout = m_ConnectTimeout * 60 * 1000;

        m_MailFromTimeout = ReadMetabaseDword(mb, MD_SMTP_MAILFROM_TIMEOUT, 600);
        m_RcptToTimeout = ReadMetabaseDword(mb, MD_SMTP_RCPTTO_TIMEOUT, 600);
        m_DataTimeout = ReadMetabaseDword(mb, MD_SMTP_DATA_TIMEOUT, 600);
        m_AuthTimeout = ReadMetabaseDword(mb, MD_SMTP_AUTH_TIMEOUT, 600);
        m_SaslTimeout = ReadMetabaseDword(mb, MD_SMTP_SASL_TIMEOUT, 600);
        m_HeloTimeout = ReadMetabaseDword(mb, MD_SMTP_HELO_TIMEOUT, 600);
        m_BdatTimeout = ReadMetabaseDword(mb, MD_SMTP_BDAT_TIMEOUT, 600);
        m_TurnTimeout = ReadMetabaseDword(mb, MD_SMTP_TURN_TIMEOUT, 600);
        m_RSetTimeout = ReadMetabaseDword(mb, MD_SMTP_RSET_TIMEOUT, 600);
        m_QuitTimeout = ReadMetabaseDword(mb, MD_SMTP_RSET_TIMEOUT, 600);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_OUTBOUND_CONN)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_OUTBOUND_CONNECTION, 100);
        if (fShowEvents && (dwTempVar != m_cMaxOutConnections)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_OUTBOUND_CONNECTIONS, 2, apszSubStrings, 0);
        }

        m_cMaxOutConnections = dwTempVar;
        AQConfig.cMaxConnections = dwTempVar;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MAX_CON;

        StateTrace((LPARAM)this, "m_cMaxOutConnections = %u", m_cMaxOutConnections);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_RECIPS)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_RECIPIENTS, 100);
        if (fShowEvents && (dwTempVar != m_cMaxRcpts)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_RECIPIENTS, 2, apszSubStrings, 0);
        }

        m_cMaxRcpts = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxRcpts = %u", m_cMaxRcpts);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_ETRN_SUBDOMAINS)) {
        m_fAllowEtrnSubDomains = !!ReadMetabaseDword(mb, MD_ETRN_SUBDOMAINS, TRUE);
        StateTrace((LPARAM)this, "m_fAllowEtrnSubDomains = %u", m_fAllowEtrnSubDomains);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_RETRY)) {
        DWORD dwTempVar2 = 0;
        char ScratchBuffer2[50];

        dwTempVar = ReadMetabaseDword(mb, MD_LOCAL_RETRY_ATTEMPTS, 48);
        dwTempVar2 = ReadMetabaseDword(mb, MD_LOCAL_RETRY_MINUTES, 60);

        if (fShowEvents && ((m_cRetryAttempts != dwTempVar) ||(m_cRetryMinutes != dwTempVar2))) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            _itoa(dwTempVar2, ScratchBuffer2, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = "Local";
            apszSubStrings[2] = ScratchBuffer;
            apszSubStrings[3] = ScratchBuffer2;
            SmtpLogEvent(SMTP_EVENT_SET_RETRY_PARAMETERS, 4, apszSubStrings, 0);
        }


        m_cRetryAttempts = dwTempVar;
        m_cRetryMinutes = dwTempVar2;

        StateTrace((LPARAM)this, "m_cRetryAttempts = %u", m_cRetryAttempts);
        StateTrace((LPARAM)this, "m_cRetryMinutes = %u", m_cRetryMinutes);

        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_RETRY_ATTEMPTS, 48);
        dwTempVar2 = ReadMetabaseDword(mb, MD_REMOTE_RETRY_MINUTES, 60);
        if ( fShowEvents && ((m_cRemoteRetryAttempts != dwTempVar) ||(m_cRemoteRetryMinutes != dwTempVar2))) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            _itoa(dwTempVar2, ScratchBuffer2, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = "Remote";
            apszSubStrings[2] = ScratchBuffer;
            apszSubStrings[3] = ScratchBuffer2;
            SmtpLogEvent(SMTP_EVENT_SET_RETRY_PARAMETERS, 4, apszSubStrings, 0);
        }

        m_cRemoteRetryAttempts = dwTempVar;
        m_cRemoteRetryMinutes = dwTempVar2;

        StateTrace((LPARAM)this, "m_cRetryAttempts = %u", m_cRemoteRetryAttempts);
        StateTrace((LPARAM)this, "m_cRetryMinutes = %u", m_cRemoteRetryMinutes);

        TempString.Reset();

        m_cbProgressiveRetryMinutes = sizeof(m_szProgressiveRetryMinutes);
        if (mb.GetStr("", MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpy(m_szProgressiveRetryMinutes, TempString.QueryStr());
            m_cbProgressiveRetryMinutes = lstrlen(m_szProgressiveRetryMinutes) + 1;

            StateTrace((LPARAM)this, "Progressive retry minutes: <%s>, length %u",
                       m_szProgressiveRetryMinutes,
                       m_cbProgressiveRetryMinutes);
        }

        //Parse out the string to get at most 4 seperate minute values
        //the values will be part of a comma delimited string
        int     cRetryMin[4];
        DWORD   i = 0;
        char    *szTemp;
        char    *Ptr = NULL;
        szTemp = m_szProgressiveRetryMinutes;

        //Parse out the 4 integers
        for (;i<4;) {
            Ptr = strchr(szTemp,',');
            if (Ptr)
                *Ptr = '\0';

            cRetryMin[i] = 0;
            cRetryMin[i] = atoi(szTemp);
            if (cRetryMin[i] < 1)
                break;
            i++;
            if (Ptr) {
                *Ptr = ',';
                szTemp = ++Ptr;
                Ptr = NULL;
            } else
                break;
        }

        //check if could parse nothing
        if (i==0) {
            //dwRetryMin[i] = 60;  //defualt retry is 60 minutes
            //NK** for now look at the old value - this way we can set something
            //using MMC
            cRetryMin[i] = m_cRemoteRetryMinutes;

            i++;
        }

        //If not all four retry intervals were specified
        //Make the use the last specifed interval in place of unspecified intervals
        while (i<4) {
            cRetryMin[i] = cRetryMin[i - 1];
            i++;
        }

        AQConfig.dwFirstRetrySeconds = cRetryMin[0] * 60;
        AQConfig.dwSecondRetrySeconds = cRetryMin[1] * 60;
        AQConfig.dwThirdRetrySeconds = cRetryMin[2] * 60;
        AQConfig.dwFourthRetrySeconds = cRetryMin[3] * 60;

        AQConfig.dwConnectionRetryMilliseconds = (m_cRemoteRetryMinutes*60*1000);
        AQConfig.dwRetryThreshold = ReadMetabaseDword(mb,MD_SMTP_REMOTE_RETRY_THRESHOLD,3);
        if (!AQConfig.dwRetryThreshold)
            AQConfig.dwRetryThreshold = 3;
        StateTrace((LPARAM)this, "RetryThreshold = %u", AQConfig.dwRetryThreshold);

        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_CON_RETRY;

        //
        // If DSN intervals are not set, then derive them from the retry intervals
        //      10/6/98 - MikeSwa
        //

        AQConfig.dwDelayExpireMinutes = ReadMetabaseDword(mb,
                                                          MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, m_cRemoteRetryMinutes);
        AQConfig.dwNDRExpireMinutes = ReadMetabaseDword(mb,
                                                        MD_SMTP_EXPIRE_REMOTE_NDR_MIN,
                                                        m_cRemoteRetryMinutes * m_cRemoteRetryAttempts);
        AQConfig.dwAQConfigInfoFlags |=
        (AQ_CONFIG_INFO_EXPIRE_DELAY |
         AQ_CONFIG_INFO_EXPIRE_NDR);

        AQConfig.dwLocalDelayExpireMinutes = ReadMetabaseDword(mb,
                                                               MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, m_cRetryMinutes);
        AQConfig.dwLocalNDRExpireMinutes = ReadMetabaseDword(mb,
                                                             MD_SMTP_EXPIRE_LOCAL_NDR_MIN,
                                                             m_cRetryMinutes * m_cRetryAttempts);
        AQConfig.dwAQConfigInfoFlags |=
        (AQ_CONFIG_INFO_LOCAL_EXPIRE_DELAY |
         AQ_CONFIG_INFO_LOCAL_EXPIRE_NDR);

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_PIPELINE)) {
        dwTempVar = !!ReadMetabaseDword(mb, MD_SHOULD_PIPELINE_OUT, TRUE);
        if (fShowEvents && ((dwTempVar && !m_fShouldPipelineOut) || (!dwTempVar && m_fShouldPipelineOut))) {
            apszSubStrings[0] = pchAddr1;
            if (dwTempVar)
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_OUT_ENABLED, 1, apszSubStrings, 0);
            else
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_OUT_DISABLED, 1, apszSubStrings, 0);
        }

        m_fShouldPipelineOut = dwTempVar;
        StateTrace((LPARAM)this, "m_fShouldPipelineOut = %u", m_fShouldPipelineOut);

        dwTempVar = !!ReadMetabaseDword(mb, MD_SHOULD_PIPELINE_IN, TRUE);
        if (fShowEvents && ((dwTempVar && !m_fShouldPipelineIn)|| (!dwTempVar && m_fShouldPipelineIn))) {
            apszSubStrings[0] = pchAddr1;
            if (dwTempVar)
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_IN_ENABLED, 1, apszSubStrings, 0);
            else
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_IN_DISABLED, 1, apszSubStrings, 0);

        }

        m_fShouldPipelineIn = dwTempVar;
        StateTrace((LPARAM)this, "m_fShouldPipelineIn = %u", m_fShouldPipelineIn);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SMART_HOST)) {
        dwTempVar = ReadMetabaseDword(mb, MD_SMARTHOST_TYPE, 0);
        StateTrace((LPARAM)this, "m_fSmartHostType = %u", dwTempVar);
        if (dwTempVar != smarthostNone) {
            TempString.Reset();

            if (! mb.GetStr("", MD_SMARTHOST_NAME, IIS_MD_UT_SERVER, &TempString) ||
                TempString.IsEmpty()) {
                // Don't have a smart host, so turn off smart host and start.
                // Log it though, because the settings conflicted and so somebody
                // probably messed up...
                dwTempVar = m_fSmartHostType = smarthostNone;
                m_szSmartHostName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read smart host name, error %u", dwErr);
                apszSubStrings[0] = pchAddr1;
                SmtpLogEvent(SMTP_EVENT_INVALID_SMART_HOST, 1, apszSubStrings, 0);
            } else {
                if (fShowEvents && lstrcmpi(m_szSmartHostName,TempString.QueryStr())) {
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = TempString.QueryStr();
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_NAME, 2, apszSubStrings, 0);
                }

                lstrcpyn (m_szSmartHostName,TempString.QueryStr(), MAX_PATH);
            }

            StateTrace((LPARAM)this, "m_szSmartHost = %s", m_szSmartHostName);
        }

        // If the value is changing, generate an information NT event...
        if (fShowEvents && (dwTempVar != m_fSmartHostType)) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_szSmartHostName;

            switch (dwTempVar) {
            case smarthostNone:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_NONE, 1, apszSubStrings, 0);
                    break;
                }
            case smarthostAfterFail:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_AFTER_FAIL,
                                 2, apszSubStrings, 0);
                    break;
                }
            case smarthostAlways:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_ALWAYS,
                                 2, apszSubStrings, 0);
                    break;
                }
            }//end switch

        }//endf if

        m_fSmartHostType = dwTempVar;
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MASQUERADE)) {
        m_fMasquerade = !!ReadMetabaseDword(mb, MD_DO_MASQUERADE, FALSE);
        StateTrace((LPARAM)this, "m_fSmartHostType = %u", m_fMasquerade);
        if (m_fMasquerade) {
            TempString.Reset();

            if (! mb.GetStr("", MD_MASQUERADE_NAME, IIS_MD_UT_SERVER, &TempString) ||
                TempString.IsEmpty()) {
                // Don't have a masquerade, so turn off masquerading and start.
                // Log it though, because the settings conflicted and so somebody
                // probably messed up...
                m_fMasquerade = 0;
                m_szMasqueradeName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read masquerade name, error %u", dwErr);
                apszSubStrings[0] = pchAddr1;
                SmtpLogEvent(SMTP_EVENT_INVALID_MASQUERADE, 1, apszSubStrings, 0);
            } else {
                if (fShowEvents && lstrcmpi(m_szMasqueradeName,TempString.QueryStr())) {
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = TempString.QueryStr();
                    SmtpLogEvent(SMTP_EVENT_SET_MASQUERADE_NAME, 2, apszSubStrings, 0);
                }

                lstrcpyn (m_szMasqueradeName,TempString.QueryStr(), AB_MAX_DOMAIN);
            }

            StateTrace((LPARAM)this, "m_szMasqueradeName = %s", m_szMasqueradeName);
        }
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_DEFAULT_DOMAIN)) {

        m_fDefaultDomainExists = TRUE;

        TempString.Reset();
        if (! mb.GetStr("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, &TempString)) {
            //
            // we set this value on system start up this is a problem... it should be set.
            //
            lstrcpyn(m_szDefaultDomain, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "Error reading Default Domain from Metabase.  Using TcpipValue Name: %s", m_szDefaultDomain);
        }

        else if (TempString.IsEmpty()) {
            //
            // blow away the value, this will invoke the routine again, and it will be updated
            // with the higher level default.  Just in case, put the Instance value in there as a
            // placeholder... just in case.
            //

            lstrcpyn(m_szDefaultDomain, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "Default Domain was blank string, removing Instance value.");

            if (! mb.DeleteData("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, STRING_METADATA)) {
                ErrorTrace((LPARAM) this, "Error deleting Default Domain from Metabase.  Using TcpipValue Name: %s", m_szDefaultDomain);
            }
        }

        else {
            lstrcpyn(m_szDefaultDomain,TempString.QueryStr(), sizeof(m_szDefaultDomain));

            if (fShowEvents) {
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szDefaultDomain;

                // If the value is changing, generate an information NT event...
                SmtpLogEvent(SMTP_EVENT_SET_DEFAULT_DOMAIN, 2, apszSubStrings, 0);
            }
        }

        //
        // Inform aqueue of the default domain
        //
        AQConfig.szDefaultLocalDomain = m_szDefaultDomain;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_DEFAULT_DOMAIN;
        ErrorTrace((LPARAM)this , "Default domain is %s", m_szDefaultDomain);
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_FQDN)) {

        TempString.Reset();
        if (! mb.GetStr("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, &TempString)) {
            //
            // We set this value on system start up - see main.cxx,
            // InitializeService
            // This is a problem... it should be set.
            //
            lstrcpyn(m_szFQDomainName, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName(), MAX_PATH);
            ErrorTrace((LPARAM) this, "Error reading FQDN value from Metabase.  Using TcpipValue Name: %s", m_szFQDomainName);
        } else if (TempString.IsEmpty()) {
            //
            // blow away the value, this will invoke the routine again, and it will be updated
            // with the higher level default.  Just in case, put the Instance value in there as a
            // placeholder... just in case.
            //

            lstrcpyn(m_szFQDomainName, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "FQDN Value was blank string, removing Instance value.");

            if (! mb.DeleteData("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, STRING_METADATA)) {
                ErrorTrace((LPARAM) this, "Error reading FQDN value from Metabase.  Using TcpipValue Name: %s", m_szFQDomainName);
            }
        }

        else {

            lstrcpyn(m_szFQDomainName,TempString.QueryStr(),
                sizeof(m_szFQDomainName));

            //
            // Register the SPNs for this virtual server. Currently, we ignore
            // errors here.
            //

            if (!RegisterServicePrincipalNames(FALSE)) {

                ErrorTrace((LPARAM) this, "Unable to register Kerberos SPNs %d, will try later",
                           GetLastError());

            }
        }

        //VerifyFQDNWithBindings();

        AQConfig.szServerFQDN = m_szFQDomainName;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_SERVER_FQDN;

        ErrorTrace((LPARAM)this , "Fully qualified domain name is %s", m_szFQDomainName);
    }



    if (IsFieldSet(fc, FC_SMTP_INFO_SEND_TO_ADMIN)) {
        char * DomainOffset = NULL;
        DWORD NameSize = 0;

        TempString.Reset();

        if (! mb.GetStr("", MD_SEND_NDR_TO, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty()) {
            m_fSendNDRToAdmin = FALSE;
            m_AdminName[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read admin name, error %u", dwErr);
        } else {
            lstrcpyn (m_AdminName,TempString.QueryStr(), MAX_INTERNET_NAME);
            DomainOffset = strchr(m_AdminName, '@');
            if (CAddr::ValidateCleanEmailName(m_AdminName, DomainOffset)) {
                m_fSendNDRToAdmin = TRUE;
                if (DomainOffset == NULL) {
                    lstrcat(m_AdminName, "@");
                    lstrcat(m_AdminName, m_szDefaultDomain);
                }
            } else {
                ErrorTrace((LPARAM)this, "Unable to read admin name, error %u", dwErr);
                m_AdminName[0] = '\0';
                m_fSendNDRToAdmin = FALSE;
            }

        }

        StateTrace((LPARAM)this, "m_AdminName = %s", m_AdminName);

        if (fShowEvents && m_fSendNDRToAdmin) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_AdminName;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_NDR_TO_ADMIN_ENABLED, 2, apszSubStrings, 0);
        } else if (fShowEvents && !m_fSendNDRToAdmin) {
            apszSubStrings[0] = pchAddr1;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_NDR_TO_ADMIN_DISABLED, 1, apszSubStrings, 0);
        }

        DomainOffset = NULL;
        NameSize = 0;

        TempString.Reset();

        if (! mb.GetStr("", MD_SEND_BAD_TO, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty()) {
            m_fSendBadToAdmin = FALSE;
            m_BadMailName[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read badmail email name, error %u", dwErr);
        } else {
            lstrcpyn(m_BadMailName,TempString.QueryStr(), MAX_INTERNET_NAME);
            DomainOffset = strchr(m_BadMailName, '@');

            if (CAddr::ValidateCleanEmailName(m_BadMailName, DomainOffset)) {
                m_fSendBadToAdmin = TRUE;
                if (DomainOffset == NULL) {
                    lstrcat(m_BadMailName, "@");
                    lstrcat(m_BadMailName, m_szDefaultDomain);
                }
            } else {
                m_fSendBadToAdmin = FALSE;
                m_BadMailName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read badmail email name, error %u", dwErr);
            }
        }

        StateTrace((LPARAM)this, "m_BadMailName = %s", m_BadMailName);

        if (fShowEvents && m_fSendBadToAdmin) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_BadMailName;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_BAD_TO_ADMIN_ENABLED, 2, apszSubStrings, 0);
        } else if (fShowEvents && !m_fSendBadToAdmin) {
            apszSubStrings[0] = pchAddr1;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_BAD_TO_ADMIN_DISABLED, 1, apszSubStrings, 0);
        }

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_DEFAULT_DROP_DIR)) {
        TempString.Reset();

        if (! mb.GetStr("", MD_MAIL_DROP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the metabase.
            // This is a very bad thing.
            m_szMailDropDir[0] = '\0';
            m_cchMailDropDir = 0;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailDropDir;

            //
            // When Exchange is installed, drop-dir is "" which is a valid configuration
            // so we refrain from logging an event.
            //

            if(!TempString.IsEmpty())
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, 0);

        } else {
            lstrcpyn(m_szMailDropDir, TempString.QueryStr(), MAX_PATH);

            if (fShowEvents) {
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_SET_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
            }

            // We found a path in the reg, so see if we can use it...
            dwAttr = GetFileAttributes(m_szMailDropDir);
            if (dwAttr == 0xFFFFFFFF) {
                // The path doesn't exist yet, so we'll try to create it.
                if (!CreateLayerDirectory(m_szMailDropDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    ErrorTrace((LPARAM)this, "Unable to create mail drop directory (%s)", m_szMailQueueDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailDropDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailDropDir[0] = '\0';
                    m_cchMailDropDir = 0;
                }
            }

            else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    // Because this is the queue directory, we're not going
                    // to be able to start.  Log it so it can be fixed, but
                    // set fRet to FALSE so that we shut back down.
                    ErrorTrace((LPARAM)this, "Mail drop directory (%s) already exists as a file", m_szMailDropDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailDropDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, ERROR_ALREADY_EXISTS);
                    m_szMailDropDir[0] = '\0';
                }
            }

            if (m_szMailDropDir[0] != '\0') {
                // Looks like everything is going to be OK, so we add a backslash (if
                // necessary) because it makes things easier later.
                m_cchMailDropDir = lstrlen(m_szMailDropDir);
                if (m_cchMailDropDir > 0 && m_szMailDropDir[m_cchMailDropDir - 1] != '\\') {
                    lstrcat(m_szMailDropDir, "\\");
                    m_cchMailDropDir++;
                }
            }
        }
    }

    //
    // Added by keithlau on 7/8/96
    //
    if (IsFieldSet(fc, FC_SMTP_INFO_BAD_MAIL_DIR)) {
        TempString.Reset();

        if (! mb.GetStr("", MD_BAD_MAIL_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the registry, so
            // set the flags back to not save bad mail and
            // log it and hop out.
            // This is NOT fatal.  We'll still start up and run,
            // but we're not going to save bad mail, and we wanted
            // to, so at least we'll log the event.
            m_szBadMailDir[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read bad mail dir value, error = %u", dwErr);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szBadMailDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
        } else {
            lstrcpyn (m_szBadMailDir,TempString.QueryStr(), MAX_PATH);
        }

        if (m_szBadMailDir[0] != '\0') {
            // We found a path in the registry, so see if it already exists.
            dwAttr = GetFileAttributes(m_szBadMailDir);
            if (dwAttr == 0xFFFFFFFF) {
                // It doesn't exist at all, so try to create it.
                if (!CreateLayerDirectory(m_szBadMailDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    // We couldn't create it, so we can't save bad mail.
                    // Log it because somebody messed up the registry.
                    // This is NOT fatal.  We'll still start up and run,
                    // but we're not going to save bad mail, and we wanted
                    // to, so at least we'll log the event.
                    ErrorTrace((LPARAM)this, "Unable to create bad mail directory (%s)", m_szBadMailDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szBadMailDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_BAD_MAIL_DIR, 2, apszSubStrings, 0);
                    m_szBadMailDir[0] = '\0';
                }
            } else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    // This is NOT fatal.  We'll still start up and run,
                    // but we're not going to save bad mail, and we wanted
                    // to, so at least we'll log the event.
                    ErrorTrace((LPARAM)this, "Bad mail directory (%s) already exists", m_szBadMailDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szBadMailDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_BAD_MAIL_DIR, 2, apszSubStrings, 0);
                    m_szBadMailDir[0] = '\0';
                }
            }

            StateTrace((LPARAM)this, "Save bad mail is enabled and m_szBadMailDir = %s", m_szBadMailDir);
        } else {
            // We at least leave a trace saying that save bad mail is disabled
            StateTrace((LPARAM)this, "Save bad mail is disabled");
        }

        if (m_szBadMailDir[0] != '\0') {
            // Finally, if everything has gone OK, then add a trailing backslash so
            // that things are easier later.
            dwLen = lstrlen(m_szBadMailDir);
            if (dwLen > 0 && m_szBadMailDir[dwLen-1] != '\\')
                lstrcat(m_szBadMailDir, "\\");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_DOMAIN_ROUTING)) {

        dwTempVar = ReadMetabaseDword(mb, MD_ROUTE_ACTION, 0);

        //
        //  It is not possible to configure the default routeaction
        //  as drop.  This will cause all mail to be NDR'd (the config
        //  is pushed to AQ with no drop directory.
        //
        if (dwTempVar & SMTP_DROP) {
            ErrorTrace((LPARAM) this,
              "Default RouteAction cannot be SMTP_DROP... Action was 0x%X now 0x%X",
              dwTempVar, dwTempVar & ~SMTP_DROP);
            dwTempVar &= ~SMTP_DROP;
        }
        m_DefaultRouteAction = dwTempVar;

        TempString.Reset();

        if (!mb.GetStr("", MD_ROUTE_USER_NAME, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            m_DefaultRemoteUserName[0] = '\0';
            m_DefaultRemotePassword[0] = '\0';
            m_DefaultRouteAction &= ~SMTP_AUTH_NTLM;
            m_DefaultRouteAction &= ~SMTP_AUTH_CLEARTEXT;
            m_DefaultRouteAction &= ~SMTP_AUTH_KERBEROS;
            m_DefaultRouteAction &= ~SMTP_SASL;
        } else {
            lstrcpyn (m_DefaultRemoteUserName,TempString.QueryStr(), MAX_INTERNET_NAME);
        }

        TempString.Reset();

        if (!mb.GetStr("", MD_ROUTE_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE) ||
            TempString.IsEmpty()) {
            m_DefaultRemotePassword[0] = '\0';
        } else {
            lstrcpyn (m_DefaultRemotePassword,TempString.QueryStr(), MAX_PATH);
        }

        // Get change domain name.
        if (m_pChangeObject)
        {
            char *psz = strstr((const char *) m_pChangeObject->pszMDPath, "/Domain/");

            if (!psz)
            {
                // Changing default config or even more, rebuild
                fRebuild = TRUE;
            }
            else
            {
                // Found a normal domain change, copy the name
                strncpy(szDomainName, psz+8, strlen(psz)-8);
                szDomainName[strlen(psz)-8-1]='\0';
            }

            if (!strcmp(szDomainName, "*"))
            {
                // Changing '*' domain, rebuild
                fRebuild = TRUE;
            }
        }

        fRet = GetRouteDomains(mb, szDomainName, fRebuild);
    }

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    //Send badmail information
    AQConfig.szBadMailDir = m_szBadMailDir;
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_BADMAIL_DIR;

    //Get DSN Options
    AQConfig.dwDSNOptions = ReadMetabaseDword(mb, MD_SMTP_DSN_OPTIONS, DSN_OPTIONS_DEFAULT);
    AQConfig.dwDSNLanguageID = ReadMetabaseDword(mb, MD_SMTP_DSN_LANGUAGE_ID, 0);

    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_USE_DSN_OPTIONS |
                                    AQ_CONFIG_INFO_USE_DSN_LANGUAGE;

    if (m_fSendNDRToAdmin)
        AQConfig.szSendCopyOfNDRToAddress = m_AdminName;
    else
        AQConfig.szSendCopyOfNDRToAddress = NULL;
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_SEND_DSN_TO;

    m_pIAdvQueueConfig->SetConfigInfo(&AQConfig);

    //
    // jstamerj 1998/11/17 16:34:48:
    //   Set the well known proeprties of ISession
    //
    hr = HrSetWellKnownIServerProps();
    if(FAILED(hr)) {
        //
        // Just like everything else in this fucntion, don't treat
        // this as fatal; just log it
        //
        ErrorTrace((LPARAM)this, "HrSetWellKnownIServerProps failed hr %08lx", hr);
    }

    m_GenLock.ExclusiveUnlock();

    if (!fRet && (GetLastError() == NO_ERROR))
        SetLastError(ERROR_PATH_NOT_FOUND);

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//+---------------------------------------------------------------
//
//  Function:   DeleteDomainEntry
//
//  Synopsis:   Delete a domain from cached tables.
//
//  Arguments:  DomainName: name of the domain to delete.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------

BOOL SMTP_SERVER_INSTANCE::DeleteDomainEntry(const char *DomainName)
{
    TraceFunctEnterEx((LPARAM)this, "DeleteDomainEntry");

    DebugTrace((LPARAM)this , "Delete Domain [%s] ", DomainName);

    // Remove this domain from our SMTPSVC tables
    m_TurnAccessList.RemoveFromTable((const char *) DomainName);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   RemoveRegParams
//
//  Synopsis:   Remove metabase info from cached tables.
//              We only handle domain removal at this moment.
//
//  Arguments:  DomainName: name of the domain to delete.
//              If DomainName is NULL, we get it from
//              m_pChangeObject.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::RemoveRegParams(const char *DomainName)
{
    TraceFunctEnterEx((LPARAM)this, "RemoveRegParams");

    char szDomainName    [AB_MAX_DOMAIN + 1]    = {0};
    BOOL fRet                                   = TRUE;

    m_GenLock.ExclusiveLock();

    if (!m_pChangeObject)
        goto Exit;

    if (DomainName)
    {
        strcpy(szDomainName, DomainName);
    }
    else
    {
        // At this stage, we only handle Domain removale.
        char *psz = strstr((const char *) m_pChangeObject->pszMDPath, "/Domain/");

        if (psz)
        {
            // We find it.
            strncpy(szDomainName, psz+8, strlen(psz)-8);
            szDomainName[strlen(psz)-8-1]='\0';
        }
    }

    if (szDomainName[0] == '\0')
        goto Exit;

    {
        HRESULT     hr              = S_OK;
        char        szRoutePath     [MAX_PATH + 1];
        char        szActionType    [MAX_PATH + 1];
        char        szUserName      [MAX_INTERNET_NAME + 1];
        char        szEtrnDomain    [AB_MAX_DOMAIN + 1];
        char        szPassword      [MAX_PATH + 1];
        char        szTargetName    [MAX_PATH + 1];
        DomainInfo  DefaultDomainInfo;
        DomainInfo  StarDomainInfo;
        MB          mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

        if( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) )
        {
            fRet = FALSE;
            goto Exit;
        }

        if (!strcmp(szDomainName, "*"))
        {
            // Deleting the '*' domain, must rebuild
            fRet = GetRouteDomains(mb, szDomainName, TRUE);
            goto Exit;
        }

        // Delete the domain from the table in SMTPSVC
        DeleteDomainEntry((const char *) szDomainName);

        // Since we have no way to tell AQ to delete this domain apart from
        // doing a full rebuild, we are going to push the defaults to AQ
        // to overwrite the custom settings this domain had before

        // Load up the "default config" : We get this by loading the server
        // default config and then trying to overwrite it with the '*'
        // domain config (if present)

        // REVIEW : Ideally this code would be in DeleteDomainEntry but putting it
        // there hurts us now because we have to call DeleteDomainEntry from
        // SetRouteDomainParameters to clean the tables in SMTPSVC.  If we can get
        // rid of those tables, the layout of these functions shoule be reconsidered.

        wsprintf(szRoutePath, "");
        SetRouteDomainParameters(mb,
                        szDomainName,
                        szRoutePath,
                        szActionType,
                        szUserName,
                        szEtrnDomain,
                        szPassword,
                        szTargetName,
                        &DefaultDomainInfo);

        if (AlwaysUseSmartHost() && m_szSmartHostName[0]) {
            DefaultDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;
            DefaultDomainInfo.szSmartHostDomainName = m_szSmartHostName;
            DefaultDomainInfo.cbSmartHostDomainNameLength = lstrlen(m_szSmartHostName);
        }

        //check if we should always use SSL
        if (GetDefaultRouteAction() & SMTP_SSL) {
            DefaultDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;
        }

        // Try to overwrite this with the "*" domain if it exists
        wsprintf(szRoutePath, "/Domain/*");
        SetRouteDomainParameters(mb,
                        szDomainName,
                        szRoutePath,
                        szActionType,
                        szUserName,
                        szEtrnDomain,
                        szPassword,
                        szTargetName,
                        &StarDomainInfo);

        // If we found the star domain - dwDomainInfoFlags is zero if
        // the domain does not exist in the metabase
        if (StarDomainInfo.dwDomainInfoFlags) {
            hr = m_pIAdvQueueConfig->SetDomainInfo(&StarDomainInfo);
        }
        // else push the default domain info
        else {
            hr = m_pIAdvQueueConfig->SetDomainInfo(&DefaultDomainInfo);
        }
    }

Exit:
    m_GenLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL SMTP_SERVER_INSTANCE::GetCatInfo(MB& mb, AQConfigInfo& AQConfig)
{
    STR         TempString;
    char        Password[MAX_PATH];
    char        BindType[MAX_PATH];
    char        SchemaType[MAX_PATH];
    char        Domain[MAX_PATH];
    char        UserName[MAX_PATH];
    char        Host[MAX_PATH];
    char        NamingContext[MAX_PATH];
    char        DsType[MAX_PATH];

    Password[0] = '\0';
    BindType[0] = '\0';
    SchemaType[0] = '\0';
    Domain[0] = '\0';
    UserName[0] = '\0';
    Host[0] = '\0';
    NamingContext[0] = '\0';
    DsType [0] = '\0';

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_USE_CAT, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatEnable))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_ENABLE;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATENABLE,
                AQConfig.dwMsgCatEnable)));
    }

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_FLAGS, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatFlags))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_FLAGS;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATFLAGS,
                AQConfig.dwMsgCatFlags)));
    }

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_PORT, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatPort))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_PORT;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATPORT,
                AQConfig.dwMsgCatPort)));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_ACCOUNT, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(UserName, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_USER;
        AQConfig.szMsgCatUser = UserName;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATUSER,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_SCHEMA_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(SchemaType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE;
        AQConfig.szMsgCatSchemaType = SchemaType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATSCHEMA,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_BIND_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(BindType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_BINDTYPE;
        AQConfig.szMsgCatBindType = BindType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATBINDTYPE,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT | METADATA_SECURE )) {
        lstrcpyn(Password, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_PASSWORD;
        AQConfig.szMsgCatPassword = Password;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATPASSWORD,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_DOMAIN, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(Domain, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_DOMAIN;
        AQConfig.szMsgCatDomain = Domain;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDOMAIN,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_NAMING_CONTEXT, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(NamingContext, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT;
        AQConfig.szMsgCatNamingContext = NamingContext;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATNAMINGCONTEXT,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(DsType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_TYPE;
        AQConfig.szMsgCatType = DsType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDSTYPE,
                TempString.QueryStr())));
    }

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    TempString.Reset();

    if(mb.GetStr("RoutingSources", MD_SMTP_DS_HOST, IIS_MD_UT_SERVER, &TempString) &&
       !TempString.IsEmpty())
    {
        lstrcpyn(Host, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_HOST;
        AQConfig.szMsgCatHost = Host;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDSHOST,
                TempString.QueryStr())));
    }

    //
    // Indicate that all the official "msgcat" keys that exist are set
    //
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_DEFAULT;

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    m_pIAdvQueueConfig->SetConfigInfo(&AQConfig);

    return TRUE;
}


BOOL SMTP_SERVER_INSTANCE::ReadRouteDomainIpSecList(MB& mb)
{
    IMDCOM*             pMBCom;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    DWORD               dwErr;
    BOOL                fSuccess = TRUE;
    char                *szValueName = "";

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::ReadRouteDomainIpSecList");

    ResetRelayIpSecList();

    pMBCom = (IMDCOM*)m_Service->QueryMDObject();

    mdRecord.dwMDIdentifier  = MD_SMTP_IP_RELAY_ADDRESSES;
    mdRecord.dwMDAttributes  = METADATA_INHERIT;
    mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
    mdRecord.dwMDDataType    = BINARY_METADATA;
    mdRecord.dwMDDataLen     = 5000;
    mdRecord.pbMDData        = (PBYTE) new char [5000];

    if (mdRecord.pbMDData == NULL) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    hRes = pMBCom->ComMDGetMetaData( mb.QueryHandle(),
                                     (LPBYTE)szValueName,
                                     &mdRecord,
                                     &dwRequiredLen );
    if ( SUCCEEDED( hRes ) ) {

        SetRelayIpSecList(mdRecord.pbMDData,
                          mdRecord.dwMDDataLen,
                          mdRecord.dwMDDataTag );
    } else {
        if (mdRecord.pbMDData)
            delete mdRecord.pbMDData;
        fSuccess = FALSE;
        dwErr = HRESULTTOWIN32( hRes );
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fSuccess;
}

void SMTP_SERVER_INSTANCE::BuildTurnTable(MULTISZ&  msz, char * szDomainName)
{
    const char * StartPtr = NULL;
    CTurnData * pTurnData = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::BuildTurnTable");

    for (StartPtr = msz.First(); StartPtr != NULL; StartPtr = msz.Next( StartPtr )) {
        ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

        DebugTrace((LPARAM)this , "%s is allowed to issue TURN", StartPtr);

        pTurnData = new CTurnData(StartPtr, szDomainName);
        if (pTurnData != NULL) {
            if (!m_TurnAccessList.InsertIntoTable((CHASH_ENTRY *) pTurnData)) {
                delete pTurnData;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
}

//+---------------------------------------------------------------
//
//  Function:   SetRouteDomainParameters
//
//  Synopsis:   Does the actual work of adding a domain from the metabase
//
//----------------------------------------------------------------
void SMTP_SERVER_INSTANCE::SetRouteDomainParameters(MB &mb,
                                                    char *szDomainName,
                                                    char *szRoutePath,
                                                    char  szActionType [MAX_PATH + 1],
                                                    char  szUserName [MAX_INTERNET_NAME + 1],
                                                    char  szEtrnDomain [MAX_INTERNET_NAME + 1],
                                                    char  szPassword [MAX_PATH + 1],
                                                    char  szTargetName [MAX_PATH + 1],
                                                    DomainInfo *pLocalDomainInfo)
{
    TraceFunctEnter("SMTP_SERVER_INSTANCE::SetRouteDomainParameters");

    char *      DomainPtr       = NULL;
    char *      UserNamePtr     = NULL;
    char *      PasswordPtr     = NULL;
    char *      TargetNamePtr   = NULL;
    DWORD       dwAction        = 0;
    STR         TempString;
    DWORD       dwErr           = NO_ERROR;
    DWORD       dwLen           = 0;
    BOOL        RelayForAuth    = TRUE;
    DWORD       dwEtrnWaitTime  = 0;
    BOOL        WildCard        = FALSE;
    CHAR        pchAddr1[32]    = "";
    MULTISZ     msz;

    if (szDomainName[0]) {
        ZeroMemory(pLocalDomainInfo, sizeof(DomainInfo));
        pLocalDomainInfo->cbVersion = sizeof(DomainInfo);
        pLocalDomainInfo->cbDomainNameLength = lstrlen(szDomainName);
        pLocalDomainInfo->szDomainName = szDomainName;

        szActionType [0] = '\0';
        szUserName [0] = '\0';
        szPassword [0] = '\0';
        szEtrnDomain[0] = '\0';
        szTargetName[0] = '\0';

        UserNamePtr = szUserName;
        PasswordPtr = szPassword;
        TargetNamePtr = szTargetName;
        dwAction = 0;

        DomainPtr = szDomainName;

        if (!mb.GetDword(szRoutePath, MD_ROUTE_ACTION, IIS_MD_UT_SERVER, &dwAction)) {
            dwAction = 0;
        }

        // If we don't recognize the actions we bail now - SMTP_DEFAULT
        // shound never be set on any RouteAction in the metabase
        if ((dwAction & ~SMTP_ALL_ROUTE_FLAGS) || (dwAction & SMTP_DEFAULT)) {
            TraceFunctLeave();
            return;
        }

        //
        //  It is not possible to configure the default routeaction
        //  as drop.  This will cause all mail to be NDR'd (the config
        //  is pushed to AQ with no drop directory.
        //
        if ((0 == strcmp(szRoutePath, "")) && dwAction & SMTP_DROP) {
            ErrorTrace((LPARAM) this,
              "Default '*' RouteAction cannot be SMTP_DROP...Action was 0x%X now 0x%X",
              dwAction, dwAction & ~SMTP_DROP);
            dwAction &= ~SMTP_DROP;
        }

        TempString.Reset();
        if (mb.GetStr(szRoutePath, MD_ROUTE_ACTION_TYPE, IIS_MD_UT_SERVER, &TempString, 0) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szActionType, TempString.QueryStr(), MAX_PATH);
        }

        TempString.Reset();

        if (((dwAction & SMTP_SMARTHOST) || (dwAction & SMTP_SASL)) && mb.GetStr(szRoutePath, MD_ROUTE_USER_NAME, IIS_MD_UT_SERVER, &TempString) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szUserName, TempString.QueryStr(), MAX_INTERNET_NAME);
        } else {
            UserNamePtr = NULL;
        }

        TempString.Reset();

        if (UserNamePtr != NULL) {
            if (mb.GetStr(szRoutePath, MD_ROUTE_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE | METADATA_INHERIT) &&
                !TempString.IsEmpty()) {
                lstrcpyn(szPassword, TempString.QueryStr(), MAX_PATH);
            }
        } else {
            PasswordPtr = "";
        }

        TempString.Reset();

        if (TargetNamePtr != NULL) {
            if (mb.GetStr(szRoutePath, MD_ROUTE_AUTHTARGET, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE | METADATA_INHERIT) &&
                !TempString.IsEmpty()) {
                lstrcpyn(szTargetName, TempString.QueryStr(), MAX_PATH);
            }
        } else {
            TargetNamePtr = "";
        }

        TempString.Reset();
        if (mb.GetStr(szRoutePath, MD_SMTP_CSIDE_ETRN_DOMAIN, IIS_MD_UT_SERVER, &TempString, 0) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szEtrnDomain, TempString.QueryStr(), AB_MAX_DOMAIN);
        }

        dwEtrnWaitTime = ReadMetabaseDword(mb, MD_SMTP_CSIDE_ETRN_DELAY, 0);

        //
        //  If the domain is set to explicitly allow relay for authenticated users..
        //  use that value.  Otherwise, use the value set on the VSI (to maintain
        //  backwards compatibility with W2K users).
        //
        if (dwAction & SMTP_AUTH_RELAY)
           RelayForAuth = TRUE;
        else
           RelayForAuth = m_fRelayForAuthUsers;

        if (dwAction & SMTP_SMARTHOST) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;

            if (dwAction & SMTP_SSL)
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;

            if (szActionType[0] != '\0') {
                pLocalDomainInfo->szSmartHostDomainName = szActionType;
                pLocalDomainInfo->cbSmartHostDomainNameLength = lstrlen(szActionType);
            } else if (*szDomainName == '*') {
                //The domain names could be specified as "*" - an explicit smart
                //host must be used.
                pLocalDomainInfo->dwDomainInfoFlags &= ~DOMAIN_INFO_REMOTE_SMARTHOST;
            } else { //use the domain name as our smarthost
                pLocalDomainInfo->szSmartHostDomainName = szDomainName;
                pLocalDomainInfo->cbSmartHostDomainNameLength = lstrlen(pLocalDomainInfo->szSmartHostDomainName);
            }
        }

        //if we are doing SASL, make sure we have a username and password
        //and a correct authentication bits
        if (dwAction & SMTP_SASL) {

            // One of these must be set or else the SMTP_SASL flag doesn't
            // make sense
            if (!(dwAction & SMTP_AUTH_NTLM) &&
                !(dwAction & SMTP_AUTH_CLEARTEXT) &&
                !(dwAction & SMTP_AUTH_KERBEROS)) {

                // dbraun : we can be cleaner about handling this - bailing
                // leaves us with an incompletely configured domain

                TraceFunctLeave();
                return;
            }

            if (UserNamePtr) {
                pLocalDomainInfo->szUserName = UserNamePtr;
                pLocalDomainInfo->cbUserNameLength = lstrlen (UserNamePtr);
            }

            if (PasswordPtr) {
                pLocalDomainInfo->szPassword = PasswordPtr;
                pLocalDomainInfo->cbPasswordLength = lstrlen(PasswordPtr);
            }

            if (dwAction & SMTP_AUTH_NTLM) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_NTLM;
            }

            if (dwAction & SMTP_AUTH_CLEARTEXT) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_PLAINTEXT;
            }
            if (dwAction & SMTP_AUTH_KERBEROS) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_KERBEROS;
                if (TargetNamePtr) {
                    pLocalDomainInfo->szAuthType = TargetNamePtr;
                    pLocalDomainInfo->cbAuthTypeLength = lstrlen(TargetNamePtr);
                }
            }

        }


        char * szTmpDomain;
        //Check for the wildcard entries
        if (*DomainPtr == '*' && *(DomainPtr+1) == '.') {
            WildCard = TRUE;
            szTmpDomain = DomainPtr + 2;
        } else {
            szTmpDomain = DomainPtr;
        }


        if (szTmpDomain[0] != '*' || szTmpDomain[1] != 0) {
            if (!CAddr::ValidateDomainName(szTmpDomain)) {
                ErrorTrace((LPARAM)this , "%s is an invalid domain", DomainPtr);

                //bad domain name
                TraceFunctLeave();
                return;
            }
        }

        if (dwAction & SMTP_DROP) {
            if (!CreateLayerDirectory(szActionType) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // Reflect the changes
                const CHAR *aszStrings[3];
                CHAR szTemp1[MAX_PATH + 1];
                CHAR szTemp2[MAX_PATH + 1];

                aszStrings[0] = pchAddr1;
                aszStrings[1] = szTemp1;
                aszStrings[2] = szTemp2;

                lstrcpyn(szTemp1, szActionType, MAX_PATH);
                lstrcpyn(szTemp2, DomainPtr, MAX_PATH);
                SmtpLogEvent(SMTP_EVENT_NO_DROP_DIRECTORY, 3, aszStrings, dwErr);
            }

            dwLen = lstrlen(szActionType);
            if (dwLen > 0 && szActionType[dwLen-1] != '\\')
                lstrcat(szActionType, "\\");

            pLocalDomainInfo->szDropDirectory = szActionType;
            pLocalDomainInfo->cbDropDirectoryLength = lstrlen (szActionType);
            pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP;
        }

        // Remove original one if it is there
        DeleteDomainEntry((const char *) DomainPtr);

        //
        // Insert local domains into the routing table.
        //
        if ((dwAction & SMTP_DELIVER) && (szActionType[0] == '\0')) {
            DebugTrace((LPARAM)this , "adding %s as a DELIVER domain", szDomainName);

            pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

        } else if (dwAction & SMTP_ALIAS) {
            DebugTrace((LPARAM)this , "adding %s as a ALIAS domain", szDomainName);

            if (IsDefaultInRt()) {
                pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX | DOMAIN_INFO_ALIAS;
            } else {
                pLocalDomainInfo->szDropDirectory = m_szMailDropDir;
                pLocalDomainInfo->cbDropDirectoryLength = lstrlen (m_szMailDropDir);
                pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP | DOMAIN_INFO_ALIAS;
            }
        }

        if (RelayForAuth) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_AUTH_RELAY;
        }

        if (dwAction & SMTP_DOMAIN_RELAY) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DOMAIN_RELAY;
        }

        msz.Reset();

        if ((dwAction & SMTP_ETRN_CMD) && mb.GetMultisz(szRoutePath, MD_SMTP_AUTHORIZED_TURN_LIST, IIS_MD_UT_SERVER, &msz) &&
            !msz.IsEmpty()) {
            BuildTurnTable(msz, szTmpDomain);
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_TURN_ONLY;
        }
        if (dwAction & SMTP_ETRN_CMD && !(dwAction & SMTP_DISABLE_ETRN) ) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_ETRN_ONLY;
        }//if(dwAction & SMTP_ETRN_CMD)

        if (dwAction & SMTP_USE_HELO ) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_HELO;
        }//if(dwAction & SMTP_USE_HELO)

        if (dwAction & SMTP_CSIDE_ETRN) {

            TempString.Reset();
            if (mb.GetStr(szRoutePath, MD_SMTP_CSIDE_ETRN_DOMAIN, IIS_MD_UT_SERVER, &TempString, 0) &&
                !TempString.IsEmpty()) {
                pLocalDomainInfo->szETRNDomainName = szEtrnDomain;
                lstrcpyn(pLocalDomainInfo->szETRNDomainName, TempString.QueryStr(), AB_MAX_DOMAIN);
                pLocalDomainInfo->cbETRNDomainNameLength = strlen(szEtrnDomain);
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_SEND_ETRN;
            }

        }//if(dwAction & SMTP_CSIDE_ETRN)

        if (dwAction & SMTP_CSIDE_TURN) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_SEND_TURN;
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_TURN_ON_EMPTY;

        }//if(dwAction & SMTP_CSIDE_TURN)


        if (dwAction & SMTP_DISABLE_BMIME) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_BMIME;

        }//if(dwAction & SMTP_DISABLE_BMIME)

        if (dwAction & SMTP_CHUNKING) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_CHUNKING;

        }//if(dwAction & SMTP_CHUNKING)
        else if (dwAction & SMTP_DISABLE_CHUNK) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_CHUNKING;
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_BMIME;
        }

        if (dwAction & SMTP_DISABLE_DSN) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_DSN;

        }//if(dwAction & SMTP_DISBALE_DSN)

        if (dwAction & SMTP_DISABLE_PIPELINE) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_PIPELINE;

        }//if(dwAction & SMTP_DISABLE_PIPELINE)

    }//if (szDomainName[0])
    TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   AddDomainEntry
//
//  Synopsis:   Add a domain into cached tables.
//
//  Arguments:  MB:         already opened metabase.
//              DomainName: name of the domain to add.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::AddDomainEntry (MB &mb, char * DomainName)
{
    HRESULT hr              = S_OK;
    BOOL    fReturn         = TRUE;
    char    szDomainName    [AB_MAX_DOMAIN + 1];
    char    szRoutePath     [MAX_PATH + 1];
    char    szActionType    [MAX_PATH + 1];
    char    szUserName      [MAX_INTERNET_NAME + 1];
    char    szEtrnDomain    [AB_MAX_DOMAIN + 1];
    char    szPassword      [MAX_PATH + 1];
    char    szTargetName    [MAX_PATH + 1];
    DomainInfo  LocalDomainInfo;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::AddNewEntry");

    strcpy(szDomainName, DomainName);

    if (szDomainName[0])
    {
        szRoutePath[0] = '\0';
        wsprintf(szRoutePath, "/Domain/%s", szDomainName);

        SetRouteDomainParameters(mb,
                                 szDomainName,
                                 szRoutePath,
                                 szActionType,
                                 szUserName,
                                 szEtrnDomain,
                                 szPassword,
                                 szTargetName,
                                 &LocalDomainInfo);
        hr = m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
        if (FAILED(hr))
        {
            fReturn = FALSE;
        }
    }//if (szDomainName[0])

    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}


//+---------------------------------------------------------------
//
//  Function:   GetRouteDomains
//
//  Synopsis:   Get Routing domains from the metabase
//
//  Arguments:  MB:         already opened metabase.
//              DomainName: name of the domain to add.
//              fRebuild:   bool indicating if we need to rebuild
//                           the whole table
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::GetRouteDomains(MB &mb, char * DomainName, BOOL fRebuild)
{
    HRESULT         hr              = S_OK;
    DWORD           ThreadId;
    DWORD           error;
    BOOL            fReturn         = TRUE;
    DomainInfo      LocalDomainInfo;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::GetRouteDomains");

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    m_TurnAccessList.SetDupesAllowed();

    // Only rebuild when fRebuild is TRUE.
    if (fRebuild)
    {
        // We need to clean m_hEnumDomainThreadHandle here
        // to avoid handle leak.
        if (m_hEnumDomainThreadHandle)
        {
            if (!m_fEnumThreadStarted) {
                // the thread has been created, but it has not been
                // able to grab the gencrit lock yet.  This means
                // that it will be doing a full rebuild already, so
                // we can just bail
                goto cleanup;
            }

            // Set up signal and wait
            WaitForSingleObject(m_hEnumDomainThreadHandle, INFINITE);
            ErrorTrace((LPARAM)this, "EnumDomain Thread is dead");
            CloseHandle(m_hEnumDomainThreadHandle);
            m_hEnumDomainThreadHandle = NULL;
        }

        m_fEnumThreadStarted = FALSE;
        m_hEnumDomainThreadHandle = CreateThread (NULL, 0,
                    EnumAllDomains, this, 0, &ThreadId);
        if(m_hEnumDomainThreadHandle == NULL)
        {
            error = GetLastError();
            ErrorTrace((LPARAM)this, "CreateThread failed for EnumAllDomains. err: %u", error);
            fReturn = FALSE;
        }
        else
        {
            DebugTrace((LPARAM)this , "EnumDomainThread is created, threadId [%ld]", ThreadId);
        }
    }
    else
    {
        if (!AddDomainEntry(mb, DomainName))
            fReturn = FALSE;
    }

cleanup:
    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}


//+---------------------------------------------------------------
//
//  Function:   EnumAllDomains
//
//  Synopsis:   Enumerate all domains in this SMTP instance.
//
//  Arguments:  ptr: pointer to the SMTP server instance.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
DWORD EnumAllDomains(VOID *ptr)
{
    HRESULT     hr              = S_OK;
    char        szDomainName    [AB_MAX_DOMAIN + 1];
    char        szRoutePath     [MAX_PATH + 1];
    char        szActionType    [MAX_PATH + 1];
    char        szUserName      [MAX_INTERNET_NAME + 1];
    char        szEtrnDomain    [AB_MAX_DOMAIN + 1];
    char        szPassword      [MAX_PATH + 1];
    char        szTargetName    [MAX_PATH + 1];
    char        szStarDomain[]  = "*";
    DWORD       dwTotal         = 0;
    DomainInfo  LocalDomainInfo;
    MB          mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    SMTP_SERVER_INSTANCE *pInstance = (SMTP_SERVER_INSTANCE *) ptr;

    TraceFunctEnterEx((LPARAM)pInstance, "EnumAllDomains");

    pInstance->ExclusiveLockGenCrit();

    pInstance->m_fEnumThreadStarted = TRUE;

    pInstance->m_TurnAccessList.SetDupesAllowed();
    pInstance->m_TurnAccessList.RemoveAllEntries();

    //Signal AQ that we are starting over
    pInstance->m_pIAdvQueueConfig->StartConfigUpdate();

    if (pInstance->m_szMailDropDir[0] == '\0')
    {
        ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));
        LocalDomainInfo.cbVersion = sizeof(DomainInfo);
        LocalDomainInfo.cbDomainNameLength = lstrlen(pInstance->m_szDefaultDomain);
        LocalDomainInfo.szDomainName = pInstance->m_szDefaultDomain;
        LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

        HRESULT hr;
        hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

        DebugTrace((LPARAM)pInstance , "default domain %s was added to the routing table", pInstance->m_szDefaultDomain);

        //signals default domain was added to routing table
        pInstance->m_fDefaultInRt = TRUE;
    }
    else
    {
        ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));
        LocalDomainInfo.cbVersion = sizeof(DomainInfo);
        LocalDomainInfo.cbDomainNameLength = lstrlen(pInstance->m_szDefaultDomain);
        LocalDomainInfo.szDomainName = pInstance->m_szDefaultDomain;
        LocalDomainInfo.szDropDirectory = pInstance->m_szMailDropDir;
        LocalDomainInfo.cbDropDirectoryLength = lstrlen (pInstance->m_szMailDropDir);
        LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP;

        hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
    }

    if( !mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_READ ) )
    {
        pInstance->ExclusiveUnLockGenCrit();
        return FALSE;
    }

    while (!pInstance->IsShuttingDown() && mb.EnumObjects("/Domain", szDomainName, dwTotal++)) {

        if (szDomainName[0]) {
            szRoutePath[0] = '\0';
            wsprintf(szRoutePath, "/Domain/%s", szDomainName);

            pInstance->SetRouteDomainParameters(mb,
                                     szDomainName,
                                     szRoutePath,
                                     szActionType,
                                     szUserName,
                                     szEtrnDomain,
                                     szPassword,
                                     szTargetName,
                                     &LocalDomainInfo);
            hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
            if (FAILED(hr)) {
            }
        }//if (szDomainName[0])
    }//while (mb.EnumObjects("/RouteDomains", szDomainName, dw++))


    pInstance->SetRouteDomainParameters(mb,
                                szStarDomain, "",
                                szActionType,
                                szUserName,
                                szEtrnDomain,
                                szPassword,
                                szTargetName,
                                &LocalDomainInfo);

    if (pInstance->AlwaysUseSmartHost() && pInstance->m_szSmartHostName[0]) {
        LocalDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;
        LocalDomainInfo.szSmartHostDomainName = pInstance->m_szSmartHostName;
        LocalDomainInfo.cbSmartHostDomainNameLength = lstrlen(pInstance->m_szSmartHostName);
    }

    //check if we should always use SSL
    if (pInstance->GetDefaultRouteAction() & SMTP_SSL) {
        LocalDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;
    }

    hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

    // jstamerj 1998/07/24 11:18:39:
    //   For M2, AQueue requires a local domain entry " " in its
    //   configuration to handle recipients without SMTP addresses
    //   (such as an remote X400 address).  This will be removed when
    //   code is added to encapsualte non-SMTP addresses into SMTP.
    //   Add this local domain here.
    //
    ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));

    LocalDomainInfo.cbVersion = sizeof(DomainInfo);
    LocalDomainInfo.cbDomainNameLength = 1;
    LocalDomainInfo.szDomainName = " ";
    LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

    hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

    //Signal AQ that we are finished updating domain config
    pInstance->m_pIAdvQueueConfig->FinishConfigUpdate();

    pInstance->ExclusiveUnLockGenCrit();

    TraceFunctLeaveEx((LPARAM)pInstance);
    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::ReadIpSecList(void)
{
    IMDCOM*             pMBCom;
    METADATA_HANDLE     hMB;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    DWORD               dwErr;
    BOOL                fSuccess;

    m_GenLock.ExclusiveLock();

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

    pMBCom = (IMDCOM*)m_Service->QueryMDObject();
    hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                        (BYTE *) QueryMDPath(),
                                        METADATA_PERMISSION_READ,
                                        5000,
                                        &hMB );
    if ( SUCCEEDED( hRes ) ) {
        mdRecord.dwMDIdentifier  = MD_IP_SEC;
        mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
        mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
        mdRecord.dwMDDataType    = BINARY_METADATA;
        mdRecord.dwMDDataLen     = 0;
        mdRecord.pbMDData        = (PBYTE)NULL;

        hRes = pMBCom->ComMDGetMetaData( hMB,
                                         (LPBYTE)"",
                                         &mdRecord,
                                         &dwRequiredLen );
        if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag ) {
            m_rfAccessCheck.Set( mdRecord.pbMDData,
                                 mdRecord.dwMDDataLen,
                                 mdRecord.dwMDDataTag );
        }

        DBG_REQUIRE( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
    } else {
        fSuccess = FALSE;
        dwErr = HRESULTTOWIN32( hRes );
    }

    m_GenLock.ExclusiveUnlock();
    return TRUE;

}

BOOL IsNTFS(IN  LPCSTR  pszRealPath)

/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

--*/
{
#define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)
    CHAR rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int   i;
    DWORD dwReturn = ERROR_PATH_NOT_FOUND;

    if ( pszRealPath   == NULL) {
        return FALSE;
    }

    if ( pszRealPath[0] == ('\\') &&
         pszRealPath[1] == ('\\')) {

        return FALSE;

    } // else

    ZeroMemory( (void *) rgchRoot, sizeof(rgchRoot) );

    //
    // This is non UNC name.
    // Copy just the root directory to rgchRoot for querying
    //

    for ( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

        if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

            break;
        }
    } // for


    if ( rgchRoot[i] != ':') {

        //
        // we could not find the root directory.
        //  return with error value
        //
        return ( FALSE);
    }

    rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
    rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)/sizeof(WCHAR)
                              )) {



        if ( lstrcmp( rgchBuf, "NTFS") == 0) {
            return TRUE;
        }

    }

    return ( FALSE);

}


//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::ReadStartupRegParams
//
//  Synopsis:   Reads fixed (i.e. not modifiable on-the-fly) parameters
//              from the registry into the config class member variables.
//
//  Arguments:  None
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//  Note:       Created by KeithLau on 7/15/96
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::ReadStartupRegParams(VOID)
{
    BOOL        fRet = TRUE;
    DWORD       dwErr = NO_ERROR;
    DWORD       dwAttr;
    char        szValueName[MAX_PATH + 1];
    MB          mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STR         TempString;
    const CHAR * apszSubStrings[2];
    CHAR pchAddr1[32] = "";


    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::ReadStartupRegParams");

    GetServerBindings();

    m_GenLock.ExclusiveLock();

    //
    //  Read metabase data.
    //

    lstrcpy(szValueName, QueryMDPath());

    _itoa(QueryInstanceId(), pchAddr1, 10);

    if ( !mb.Open( szValueName, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) {
        //UnLockConfig();
        m_GenLock.ExclusiveUnlock();
        return FALSE;
    }

    m_CmdLogFlags = ReadMetabaseDword(mb, MD_COMMAND_LOG_MASK, DEFAULT_CMD_LOG_FLAGS);

    m_fFlushMailFiles = !!ReadMetabaseDword(mb, MD_FLUSH_MAIL_FILE, TRUE);

    m_cMaxRoutingThreads = ReadMetabaseDword(mb, MD_ROUTING_THREADS, 8);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u", m_cMaxRoutingThreads);

    m_fDisablePickupDotStuff = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_PICKUP_DOT_STUFF, FALSE);
    StateTrace((LPARAM)this, "m_fDisablePickupDotStuff = %u", m_fDisablePickupDotStuff);

    m_cMaxRemoteQThreads = ReadMetabaseDword(mb, MD_SMTP_MAX_REMOTEQ_THREADS, 1);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u",m_cMaxRemoteQThreads);
    m_cMaxLocalQThreads = ReadMetabaseDword(mb, MD_SMTP_MAX_LOCALQ_THREADS, 1);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u", m_cMaxLocalQThreads);

    TempString.Reset();
    if (!mb.GetStr("", MD_MAIL_QUEUE_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
        TempString.IsEmpty()) {
        // We had a problem reading the registry.
        // This is a very bad thing.  We obviously cannot run without
        // a queue directory, so set fRet to FALSE so that we shut
        // back down (and log it so that an admin can fix it).
        m_szMailQueueDir[0] = '\0';
        fRet = FALSE;
        apszSubStrings[0] = pchAddr1;
        apszSubStrings[1] = szMailQueueDir;

        SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
    } else {
        lstrcpyn(m_szMailQueueDir, TempString.QueryStr(), MAX_PATH);

        if (!IsNTFS(m_szMailQueueDir)) {
            m_IsFileSystemNtfs = FALSE;

            DebugTrace((LPARAM)this, "Queue dir (%s) is not NTFS", m_szMailQueueDir);
        }

        // We found a path in the reg, so see if we can use it...
        dwAttr = GetFileAttributes(m_szMailQueueDir);
        if (dwAttr == 0xFFFFFFFF) {
            // The path doesn't exist yet, so we'll try to create it.
            if (!CreateLayerDirectory(m_szMailQueueDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // It doesn't exist and we couldn't create it, so
                // log it and bail with fRet = FALSE so that we shut
                // back down.
                ErrorTrace((LPARAM)this, "Unable to create mail queue directory (%s)", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailQueueDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR, 2, apszSubStrings, dwErr);
                m_szMailQueueDir[0] = '\0';
                fRet = FALSE;
            }
        } else {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                // The registry points to a file, so we're outta luck.
                // The directory doesn't exist, and we can't create it.
                // Because this is the queue directory, we're not going
                // to be able to start.  Log it so it can be fixed, but
                // set fRet to FALSE so that we shut back down.

                ErrorTrace((LPARAM)this, "Mail queue directory (%s) already exists as a file", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailQueueDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR, 2, apszSubStrings, dwErr);
                m_szMailQueueDir[0] = '\0';
                fRet = FALSE;
            }
        }
    }

    TempString.Reset();

    if (! mb.GetStr("", MD_MAIL_DROP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
        TempString.IsEmpty()) {
        // We had a problem reading the metabase.
        // This is a very bad thing.  We obviously cannot run without
        // a drop directory if we are in drop mode, so set fRet to
        // FALSE so that we shut back down (and log it so that an
        // admin can fix it).
        m_szMailDropDir[0] = '\0';
        m_cchMailDropDir = 0;

        //don't start if we are disabled, since drop directory is  not
        //configurable.
        if (!m_fIsRoutingTable) {
            fRet = FALSE;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailDropDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
        }
    } else {
        lstrcpyn(m_szMailDropDir, TempString.QueryStr(), MAX_PATH);

        apszSubStrings[0] = pchAddr1;
        apszSubStrings[1] = m_szMailDropDir;

        // We found a path in the reg, so see if we can use it...
        dwAttr = GetFileAttributes(m_szMailDropDir);
        if (dwAttr == 0xFFFFFFFF) {
            // The path doesn't exist yet, so we'll try to create it.
            if (!CreateLayerDirectory(m_szMailDropDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // It doesn't exist and we couldn't create it, so
                // log it and bail with fRet = FALSE so that we shut
                // back down.
                ErrorTrace((LPARAM)this, "Unable to create mail drop directory (%s)", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                m_szMailDropDir[0] = '\0';
                m_cchMailDropDir = 0;

                //don't start if we are disabled, since drop directory is  not
                //configurable.
                if (!m_fIsRoutingTable)
                    fRet = FALSE;
            }
        } else {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                // The registry points to a file, so we're outta luck.
                // The directory doesn't exist, and we can't create it.
                // Because this is the queue directory, we're not going
                // to be able to start.  Log it so it can be fixed, but
                // set fRet to FALSE so that we shut back down.
                ErrorTrace((LPARAM)this, "Mail drop directory (%s) already exists as a file", m_szMailDropDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                m_szMailDropDir[0] = '\0';

                //don't start if we are disabled, since drop directory is  not
                //configurable.
                if (!m_fIsRoutingTable)
                    fRet = FALSE;
            }
        }

        // Looks like everything is going to be OK, so we add a backslash (if
        // necessary) because it makes things easier later.
        m_cchMailDropDir = lstrlen(m_szMailDropDir);
        if (m_cchMailDropDir > 0 && m_szMailDropDir[m_cchMailDropDir - 1] != '\\') {
            lstrcat(m_szMailDropDir, "\\");
            m_cchMailDropDir++;
        }
    }

    // Looks like everything is going to be OK, so we add a backslash (if
    // necessary) because it makes things easier later.
    m_cchMailQueueDir = lstrlen(m_szMailQueueDir);
    if (m_cchMailQueueDir > 0 && m_szMailQueueDir[m_cchMailQueueDir - 1] != '\\') {
        lstrcat(m_szMailQueueDir, "\\");
        m_cchMailQueueDir++;
    }

    m_fShouldPickupMail = !!ReadMetabaseDword(mb, MD_SHOULD_PICKUP_MAIL, TRUE);
    if (m_fShouldPickupMail) {
        m_cMaxDirBuffers = ReadMetabaseDword(mb, MD_MAX_DIR_BUFFERS, 2000);
        m_cMaxDirChangeIoSize = ReadMetabaseDword(mb, MD_MAX_DIR_CHANGE_IO_SIZE, 1000);
        m_cMaxDirPendingIos = ReadMetabaseDword(mb, MD_MAX_DIR_PENDING_IOS, 1);

        TempString.Reset();

        if (!mb.GetStr("", MD_MAIL_PICKUP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the registry.
            // This is a very bad thing.
            m_szMailPickupDir[0] = '\0';
            m_fShouldPickupMail = 0;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailPickupDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);

        } else {
            lstrcpyn(m_szMailPickupDir, TempString.QueryStr(), MAX_PATH);

            // We found a path in the reg, so see if we can use it...
            dwAttr = GetFileAttributes(m_szMailPickupDir);
            if (dwAttr == 0xFFFFFFFF) {
                // The path doesn't exist yet, so we'll try to create it.
                if (!CreateLayerDirectory(m_szMailPickupDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    // It doesn't exist and we couldn't create it, so
                    // log it and bail with fRet = FALSE so that we shut
                    // back down.
                    ErrorTrace((LPARAM)this, "Unable to create mail pickup queue directory (%s)", m_szMailPickupDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailPickupDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailPickupDir[0] = '\0';
                    m_fShouldPickupMail = 0;
                }
            } else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    ErrorTrace((LPARAM)this, "Mail pickup queue directory (%s) already exists as a file", m_szMailPickupDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailPickupDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailPickupDir[0] = '\0';
                    m_fShouldPickupMail = 0;
                }
            }
        }

        // Looks like everything is going to be OK, so we add a backslash (if
        // necessary) because it makes things easier later.
        m_cchMailPickupDir = lstrlen(m_szMailPickupDir);
        if (m_cchMailPickupDir > 0 && m_szMailPickupDir[m_cchMailPickupDir - 1] != '\\') {
            lstrcat(m_szMailPickupDir, "\\");
            m_cchMailPickupDir++;
        }
    }

    if (!mb.GetStr("", MD_CONNECT_RESPONSE, IIS_MD_UT_SERVER, &TempString) ||
        TempString.IsEmpty()) {
        // We had a problem reading the metabase
        // This is a very bad thing.
        lstrcpy (m_szConnectResponse, "Microsoft ESMTP MAIL Service, ");
        lstrcat (m_szConnectResponse, g_VersionString);
        lstrcat (m_szConnectResponse, " ready at ");
//      SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
    } else {
        lstrcpyn(m_szConnectResponse, TempString.QueryStr(), MAX_PATH);
    }
    m_cchConnectResponse = lstrlenA(m_szConnectResponse);

    mb.Close();

    m_GenLock.ExclusiveUnlock();

    ReadIpSecList();

    if (!fRet)
        SetLastError(ERROR_PATH_NOT_FOUND);

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

void SMTP_SERVER_INSTANCE::GetServerBindings(void)
{
    DWORD       dwErr = NO_ERROR;

    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::GetServerBindings");

    m_GenLock.ExclusiveLock();

    //
    //  open metabase data.
    //

    if ( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ ) ) {
        m_GenLock.ExclusiveUnlock();
        TraceFunctLeaveEx((LPARAM)this);
        return ;
    }

    m_ServerBindings.Reset();

    if (!mb.GetMultisz("", MD_SERVER_BINDINGS, IIS_MD_UT_SERVER, &m_ServerBindings) ||
        m_ServerBindings.IsEmpty()) {
        dwErr = GetLastError();
        ErrorTrace((LPARAM)this, "Unable to read server bindings, error = %u", dwErr);
    }

    m_GenLock.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM)this);
}


VOID
SMTP_SERVER_INSTANCE::MDChangeNotify(
                                    MD_CHANGE_OBJECT * pco
                                    )
/*++

  This method handles the metabase change notification for this instance

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    pcoChangeList - path and id that has changed

--*/
{
    FIELD_CONTROL   control      = 0;
    BOOL            fSslModified = FALSE;
    DWORD           i;
    DWORD           err;
    DWORD           id;
    DWORD           MdState;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MDChangeNotify");

    //
    //  Tell our parent about the change notification first
    //

    LockThisForWrite();

    IIS_SERVER_INSTANCE::MDChangeNotify( pco );

    // Save change object
    m_pChangeObject = pco;

    for ( i = 0; i < pco->dwMDNumDataIDs; i++ ) {
        id = pco->pdwMDDataIDs[i];

        switch ( id ) {
        case MD_REVERSE_NAME_LOOKUP:
            control |= FC_SMTP_INFO_REVERSE_LOOKUP;
            break;

        case MD_NTAUTHENTICATION_PROVIDERS:
            control |= FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS;
            break;

        case MD_MD_SERVER_SS_AUTH_MAPPING:
        case MD_SMTP_CLEARTEXT_AUTH_PROVIDER:
            control |= FC_SMTP_CLEARTEXT_AUTH_PROVIDER;
            break;

        case MD_AUTHORIZATION:
            control |= FC_SMTP_INFO_AUTHORIZATION;
            break;

        case MD_HOP_COUNT:
            control |= FC_SMTP_INFO_MAX_HOP_COUNT;
            break;

        case MD_MAX_SMTP_ERRORS:
        case MD_MAX_SMTP_AUTHLOGON_ERRORS:
            control |= FC_SMTP_INFO_MAX_ERRORS;
            break;

        case MD_MAX_MSG_SIZE:
        case MD_MAX_MSG_SIZE_B4_CLOSE:
            control |= FC_SMTP_INFO_MAX_SIZE;
            break;

        case MD_REMOTE_TIMEOUT:
            control |= FC_SMTP_INFO_REMOTE_TIMEOUT;
            break;

        case MD_MAX_OUTBOUND_CONNECTION:
            control |= FC_SMTP_INFO_MAX_OUTBOUND_CONN;
            break;

        case MD_MAX_RECIPIENTS:
            control |= FC_SMTP_INFO_MAX_RECIPS;
            break;

        case MD_ETRN_SUBDOMAINS:
            control |= FC_SMTP_INFO_ETRN_SUBDOMAINS;
            break;

        case MD_MAIL_DROP_DIR:
            control |= FC_SMTP_INFO_DEFAULT_DROP_DIR;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_LOCAL_RETRY_ATTEMPTS:
        case MD_LOCAL_RETRY_MINUTES:
        case MD_REMOTE_RETRY_ATTEMPTS:
        case MD_REMOTE_RETRY_MINUTES:
//        case MD_SHARE_RETRY_MINUTES:
        case MD_SMTP_REMOTE_RETRY_THRESHOLD:
        case MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES:
        case MD_SMTP_EXPIRE_REMOTE_NDR_MIN:
        case MD_SMTP_EXPIRE_REMOTE_DELAY_MIN:
        case MD_SMTP_EXPIRE_LOCAL_NDR_MIN:
        case MD_SMTP_EXPIRE_LOCAL_DELAY_MIN:
            control |= FC_SMTP_INFO_RETRY;
            break;

        case MD_SHOULD_PIPELINE_OUT:
        case MD_SHOULD_PIPELINE_IN:
            control |= FC_SMTP_INFO_PIPELINE;
            break;

        case MD_SMTP_DS_TYPE:
        case MD_SMTP_DS_DATA_DIRECTORY:
        case MD_SMTP_DS_DEFAULT_MAIL_ROOT:
        case MD_SMTP_DS_BIND_TYPE:
        case MD_SMTP_DS_SCHEMA_TYPE:
        case MD_SMTP_DS_HOST:
        case MD_SMTP_DS_NAMING_CONTEXT:
        case MD_SMTP_DS_ACCOUNT:
        case MD_SMTP_DS_PASSWORD:
        case MD_SMTP_DS_DOMAIN:
        case MD_SMTP_DS_USE_CAT:
        case MD_SMTP_DS_PORT:
        case MD_SMTP_DS_FLAGS:
            control |= FC_SMTP_INFO_ROUTING;
            break;

        case MD_SEND_BAD_TO:
        case MD_SEND_NDR_TO:
            control |= FC_SMTP_INFO_SEND_TO_ADMIN;
            break;

        case MD_SMARTHOST_TYPE:
        case MD_SMARTHOST_NAME:
            control |= FC_SMTP_INFO_SMART_HOST;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_NAME_RESOLUTION_TYPE:
        case MD_BATCH_MSG_LIMIT:
        case MD_SMTP_IP_RELAY_ADDRESSES:
        case MD_SMTP_DISABLE_RELAY:
        case MD_SMTP_MAIL_NO_HELO:
        case MD_SMTP_HELO_NODOMAIN:
        case MD_SMTP_DISABLE_PICKUP_DOT_STUFF:
        case MD_SMTP_EVENTLOG_LEVEL:
        case MD_SMTP_DENIED_IP_ACTION:
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_DEFAULT_DOMAIN_VALUE:
            control |= FC_SMTP_INFO_DEFAULT_DOMAIN;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_FQDN_VALUE:
            control |= FC_SMTP_INFO_FQDN;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_BAD_MAIL_DIR:
            control |= FC_SMTP_INFO_BAD_MAIL_DIR;
            break;

        case MD_DO_MASQUERADE:
        case MD_MASQUERADE_NAME:
            control |= FC_SMTP_INFO_MASQUERADE;
            break;

        case MD_REMOTE_SMTP_PORT:
            control |= FC_SMTP_INFO_REMOTE_PORT;
            break;

        case MD_LOCAL_DOMAINS:
            control |= FC_SMTP_INFO_LOCAL_DOMAINS;
            break;

        case MD_DOMAIN_ROUTING:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_POSTMASTER_EMAIL:
        case MD_POSTMASTER_NAME:
            control |= FC_SMTP_INFO_ADMIN_EMAIL_NAME;
            break;

        case MD_SMTP_SSL_REQUIRE_TRUSTED_CA:
        case MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION:
        case MD_SSL_ACCESS_PERM:
            control |= FC_SMTP_INFO_SSL_PERM;
            break;

        case MD_SASL_LOGON_DOMAIN:
            control |= FC_SMTP_INFO_SASL_LOGON_DOMAIN;
            break;

        case MD_MAX_OUT_CONN_PER_DOMAIN:
            control |= FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN;
            break;

        case MD_INBOUND_COMMAND_SUPPORT_OPTIONS:
        case MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS:
        case MD_ADD_NOHEADERS :
            control |= FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS;
            break;

        case MD_SERVER_BINDINGS:
            GetServerBindings();
            break;

        case MD_IP_SEC:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            ReadIpSecList();
            break;

        case MD_SMTP_RELAY_FOR_AUTH_USERS:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_DOMAIN_VALIDATION_FLAGS:
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_ROUTE_ACTION:
        case MD_ROUTE_ACTION_TYPE:
        case MD_ROUTE_USER_NAME:
        case MD_ROUTE_PASSWORD:
        case MD_ROUTE_AUTHTARGET:
        case MD_SMTP_CSIDE_ETRN_DELAY:
        case MD_SMTP_CSIDE_ETRN_DOMAIN:
        case MD_SMTP_AUTHORIZED_TURN_LIST:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    //We need to react to domains being deleted
    //      9/29/98 - MikeSwa
    if (MD_CHANGE_TYPE_DELETE_OBJECT == pco->dwMDChangeType) {
        control |= FC_SMTP_INFO_DOMAIN_ROUTING;
    }

    //
    // If anything related to SSL has changed, call the function used to flush
    // the SSL/Schannel credential cache and reset the server certificate
    //
    if ( fSslModified && g_pSslKeysNotify ) {
        (g_pSslKeysNotify) ( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );

        ResetSSLInfo(this);
    }

    MdState = QueryServerState( );

    if ( (MdState == MD_SERVER_STATE_STOPPING) || (MdState == MD_SERVER_STATE_STOPPED)) {
        goto Done;
    }

    if ( control != 0 ) {
        if (!ReadRegParams(control, FALSE)) {
            err = GetLastError();
            DBGPRINTF((
                      DBG_CONTEXT,
                      "SMTP_SERVER_INSTANCE::MDChangeNotify() cannot read config, error %lx\n",
                      err
                      ));

        }
    }

    // Handle deleting domains
    if (control & FC_SMTP_INFO_DOMAIN_ROUTING)
    {
        // We are deleting objects
        if (pco->dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT) {
            if (!RemoveRegParams(NULL)) {
            err = GetLastError();
            DBGPRINTF((
              DBG_CONTEXT,
              "SMTP_SERVER_INSTANCE::MDChangeNotify() cannot remove config, error %lx\n",
              err
              ));
            }
        }
    }

Done:
    m_pChangeObject = NULL;
    UnlockThis();
    TraceFunctLeaveEx((LPARAM)this);
}


IIS_SSL_INFO*
SMTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj( VOID )
/*++

   Description

       Returns SSL info for this instance; calls Reference() before returning
       We actually call GetCertificate( ) here, so the name is really incorrect,
       but changing it will involve asking IIS to change IISTYPES to add the
       new method as a vitual function.

   Arguments:

       None

   Returns:

       Ptr to SSL info object on success, NULL if failure

--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj");
    IIS_SSL_INFO *pPtr = NULL;

    LockThisForRead();

    //
    // If it's null, we may have to create it - unlock, lock for write and make sure it's
    // still NULL before creating it
    //
    if ( !m_pSSLInfo ) {
        UnlockThis();

        LockThisForWrite();

        //
        // Still null, so create it now
        //
        if ( !m_pSSLInfo ) {
            m_pSSLInfo = new IIS_SSL_INFO( (LPTSTR) QueryMDPath(),
                                           (IMDCOM *) g_pInetSvc->QueryMDObject() );

            if ( m_pSSLInfo == NULL ) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                UnlockThis();
                return NULL;
            }

            //
            // Acquire an internal reference
            //
            m_pSSLInfo->Reference();

            //
            // Register for changes
            //
            IIS_SERVER_CERT *pCert = m_pSSLInfo->GetCertificate();
            if ( pCert ) {
                // Do logging if we fail to get the certificate
                LogCertStatus();
            }

            //NIMISHK**** Do I need CTL - maybe I can get rid of this call
            IIS_CTL *pCTL = m_pSSLInfo->GetCTL();
            if ( pCTL ) {
                //Do logging if we fail to get the CTL
                LogCTLStatus();
            }

            if ( g_pCAPIStoreChangeNotifier ) {
                if ( pCert && pCert->IsValid() ) {
                    if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCert->QueryStoreName(),
                                                                             pCert->QueryStoreHandle(),
                                                                             ResetSSLInfo,
                                                                             (PVOID) this ) ) {
                        DebugTrace((LPARAM)this,
                                   "Failed to register for change event on store %s",
                                   pCert->QueryStoreName());
                    }
                }

                if ( pCTL && pCTL->IsValid() ) {
                    if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCTL->QueryStoreName(),
                                                                             pCTL->QueryOriginalStore(),
                                                                             ResetSSLInfo,
                                                                             (PVOID) this ) ) {
                        DebugTrace((LPARAM)this,
                                   "Failed to register for change event on store %s",
                                   pCTL->QueryStoreName());
                    }
                }

                if ( ( pCert && pCert->IsValid()) ||
                     ( pCTL && pCTL->IsValid() ) ) {
                    HCERTSTORE hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                                           0,
                                                           NULL,
                                                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                           "ROOT" );

                    if ( hRootStore ) {
                        //
                        // Watch for changes to the ROOT store
                        //
                        if ( !g_pCAPIStoreChangeNotifier->RegisterStoreForChange( "ROOT",
                                                                                  hRootStore,
                                                                                  ResetSSLInfo,
                                                                                  (PVOID) this ) ) {
                            DebugTrace((LPARAM)this,
                                       "Failed to register for change event on root store");
                        }

                        CertCloseStore( hRootStore,
                                        0 );
                    } else {
                        DebugTrace((LPARAM)this,
                                   "Failed to open ROOT store, error 0x%d",
                                   GetLastError());

                    }
                } // if ( pCert || pCTL )

            } // if (g_pCAPIStoreChangeNotifier)

        } // if ( !m_pSSLInfo )

    } //if ( !m_pSSLInfo )

//
// At this point, m_pSSLInfo should not be NULL anymore, so add the external reference
//
    m_pSSLInfo->Reference();

    pPtr = m_pSSLInfo;

    UnlockThis();

    TraceFunctLeaveEx((LPARAM)this);

    return pPtr;
}

VOID SMTP_SERVER_INSTANCE::ResetSSLInfo( LPVOID pvParam )
/*++
    Description:

        Wrapper function for function to call to notify of SSL changes

    Arguments:

        pvParam - pointer to instance for which SSL keys have changed

    Returns:

        Nothing

--*/
{
    TraceFunctEnterEx((LPARAM)NULL, "SMTP_SERVER_INSTANCE::ResetSSLInfo");
    //
    // Call function to flush credential cache etc
    //
    if ( g_pSslKeysNotify ) {
        g_pSslKeysNotify( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                          pvParam );
    }

    SMTP_SERVER_INSTANCE *pInst = (SMTP_SERVER_INSTANCE *) pvParam;

    pInst->LockThisForRead();

    if ( pInst->m_pSSLInfo ) {
        pInst->UnlockThis();

        pInst->LockThisForWrite();

        if ( pInst->m_pSSLInfo ) {
            //
            // Stop watching for change notifications
            //
            IIS_SERVER_CERT *pCert = pInst->m_pSSLInfo->QueryCertificate();
            IIS_CTL *pCTL = pInst->m_pSSLInfo->QueryCTL();

            if ( g_pCAPIStoreChangeNotifier ) {
                //
                // Stop watching the store the cert came out of
                //
                if ( pCert && pCert->IsValid() ) {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCert->QueryStoreName(),
                                                                 ResetSSLInfo,
                                                                 (PVOID) pvParam );
                }

                //
                // Stop watching the store the CTL came out of
                //
                if ( pCTL && pCTL->IsValid() ) {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCTL->QueryStoreName(),
                                                                 ResetSSLInfo,
                                                                 (PVOID) pvParam );
                }

                //
                // Stop watching the ROOT store
                //
                g_pCAPIStoreChangeNotifier->UnregisterStore( "ROOT",
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
            }

            //
            // Release internal reference
            //
            IIS_SSL_INFO::Release( pInst->m_pSSLInfo );

            //
            // Next call to QueryAndReferenceSSLObj() will create it again
            //
            pInst->m_pSSLInfo = NULL;
        }
    }

    pInst->UnlockThis();
    TraceFunctLeaveEx((LPARAM)NULL);
}

VOID SMTP_SERVER_INSTANCE::LogCertStatus()
/*++
    Description:

       Writes system log event about status of server certificate if the cert is in some
       way not quite kosher eg expired, revoked, not signature-valid

    Arguments:

       None

    Returns:

       Nothing
--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::LogCertStatus");

    _ASSERT( m_pSSLInfo );

    DWORD dwCertValidity = 0;

    //
    // If we didn't construct the cert fully, log an error
    //
    if ( !m_pSSLInfo->QueryCertificate()->IsValid() ) {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCertificate()->Status();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server cert; status : %d",
                   dwStatus);

        switch ( dwStatus ) {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CERT_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CERT_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CERT_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CERT_INTERNAL_ERROR;
            break;
        }

        SmtpLogEvent(dwStringID,
                     2,
                     apszMsgs,
                     0 );

        TraceFunctLeaveEx((LPARAM)this);
        return;
    }


    //
    // If cert is invalid in some other way , write the appropriate log message
    //
    if ( m_pSSLInfo->QueryCertValidity( &dwCertValidity ) ) {
        const CHAR *apszMsgs[1];
        CHAR achInstance[20];
        wsprintfA( achInstance,
                   "%lu",
                   QueryInstanceId() );
        apszMsgs[0] = achInstance;
        DWORD dwMsgID = 0;

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_VALID ) ||
             ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_NESTED ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) ) {
            DebugTrace((LPARAM)this,
                       "Server cert/CTL is not time-valid or time-nested");

            dwMsgID = SSL_MSG_TIME_INVALID_SERVER_CERT;
        }


        if ( dwCertValidity & CERT_TRUST_IS_REVOKED ) {
            DebugTrace((LPARAM)this,
                       "Server Cert is revoked");

            dwMsgID = SSL_MSG_REVOKED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
             ( dwCertValidity & CERT_TRUST_IS_PARTIAL_CHAIN ) ) {
            DebugTrace((LPARAM)this,
                       "Server Cert doesn't chain up to a trusted root");

            dwMsgID = SSL_MSG_UNTRUSTED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) ) {
            DebugTrace((LPARAM)this,
                       "Server Cert/CTL is not signature valid");

            dwMsgID = SSL_MSG_SIGNATURE_INVALID_SERVER_CERT;
        }

        if ( dwMsgID ) {
            SmtpLogEvent( dwMsgID,
                          1,
                          apszMsgs,
                          0 );
        }
    }

    TraceFunctLeaveEx((LPARAM)this);

}


VOID SMTP_SERVER_INSTANCE::LogCTLStatus()
/*++
    Description:

       Writes system log event about status of server CTL if CTL isn't valid

    Arguments:

      None

    Returns:

       Nothing
--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::LogCTLStatus");

    _ASSERT( m_pSSLInfo );

    //
    // If we didn't construct the CTL fully, log an error
    //
    if ( !m_pSSLInfo->QueryCTL()->IsValid() ) {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCTL()->QueryStatus();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server CTL; status : %d\n",
                   dwStatus);

        switch ( dwStatus ) {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CTL_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CTL_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CTL_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CTL_INTERNAL_ERROR;
            break;
        }

        SmtpLogEvent( dwStringID,
                      2,
                      apszMsgs,
                      0 );
        TraceFunctLeaveEx((LPARAM)this);
        return;
    }
    TraceFunctLeaveEx((LPARAM)this);
}


BOOL
SmtpMappingSupportFunction(
                          PVOID pvInstance,
                          PVOID pData,
                          DWORD dwPropId)
{
    if (dwPropId == SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED) {
        return (SetSslKeysNotify( (PFN_SF_NOTIFY) pData));
    } else if (dwPropId == SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ||
               dwPropId == SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED) {
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

BOOL
SetSslKeysNotify(
                PFN_SF_NOTIFY pFn
                )
/*++

   Description

       Set the function called to notify SSL keys have changed
       Can be called only once

   Arguments:

       pFn - function to call to notify SSL keys change

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    if ( g_pSslKeysNotify == NULL || pFn == NULL ) {
        g_pSslKeysNotify = pFn;
        return TRUE;
    }

    return FALSE;
}


CAddr * SMTP_SERVER_INSTANCE::AppendLocalDomain (CAddr * OldAddress)
{
    char ReWriteAddr [MAX_INTERNET_NAME + 1];
    CAddr * NewAddress = NULL;
    DWORD TotalSize  = 0;

    //If there is no domain on this address,
    //then append the current domain to this
    //address

    m_GenLock.ShareLock();

    TotalSize = lstrlen(OldAddress->GetAddress()) + lstrlen(GetDefaultDomain()) + 1; //+1 for the @
    if ( TotalSize  >= MAX_INTERNET_NAME) {
        m_GenLock.ShareUnlock();
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }

    lstrcpy(ReWriteAddr, OldAddress->GetAddress());
    lstrcat(ReWriteAddr, "@");

    lstrcat(ReWriteAddr, GetDefaultDomain());
    m_GenLock.ShareUnlock();

    //create a new CAddr
    NewAddress = CAddr::CreateKnownAddress (ReWriteAddr);

    return NewAddress;
}

BOOL SMTP_SERVER_INSTANCE::AppendLocalDomain(char * Address)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::AppendLocalDomain");

    m_GenLock.ShareLock();

    if ((lstrlen(Address) + lstrlen(GetDefaultDomain()) + 1) > MAX_INTERNET_NAME) {
        //Our concatanated name will be larger than allowed name
        ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
        m_GenLock.ShareUnlock();
        return FALSE;
    }
    lstrcat(Address, "@");
    lstrcat(Address, GetDefaultDomain());

    m_GenLock.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

CAddr * SMTP_SERVER_INSTANCE::MasqueradeDomain (CAddr * OldAddress)
{
    char ReWriteAddr [MAX_INTERNET_NAME + 1];
    CAddr * NewAddress = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MasqueradeDomain");

    m_GenLock.ShareLock();

    if (m_fMasquerade) {
        //if there is a domain in the name, get rid of it
        //we are going to replace it with the masquerade
        if (OldAddress->GetDomainOffset()) {
            *(OldAddress->GetDomainOffset()) = '\0';
        }

        lstrcpy(ReWriteAddr, OldAddress->GetAddress());
        lstrcat(ReWriteAddr, "@");

        lstrcat(ReWriteAddr, m_szMasqueradeName);

        //create a new CAddr
        NewAddress = CAddr::CreateKnownAddress (ReWriteAddr);
    }

    m_GenLock.ShareUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return NewAddress;
}

BOOL SMTP_SERVER_INSTANCE::MasqueradeDomain(char * Address, char * DomainPtr)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MasqueradeDomain");

    m_GenLock.ShareLock();

    if (m_fMasquerade) {
        //if there is a domain in the name, get rid of it
        //we are going to replace it with the masquerade
        if (DomainPtr) {

            if ((DomainPtr - Address + lstrlen(m_szMasqueradeName)) > MAX_INTERNET_NAME) {
                //Our concatanated name will be larger than allowed name
                ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
                m_GenLock.ShareUnlock();
                return FALSE;
            }
            lstrcpy(DomainPtr, m_szMasqueradeName);
        } else {
            if ((lstrlen(Address) + lstrlen(m_szMasqueradeName) + 1) > MAX_INTERNET_NAME) {
                //Our concatanated name will be larger than allowed name
                ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
                m_GenLock.ShareUnlock();
                return FALSE;
            }
            lstrcat(Address, "@");
            lstrcat(Address, m_szMasqueradeName);
        }

    }

    m_GenLock.ShareUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

extern BOOL IsIpInGlobalList(DWORD IpAddress);

BOOL SMTP_SERVER_INSTANCE::CompareIpAddress(DWORD IpAddress)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::CompareIpAddress");

    if (IpAddress != g_LoopBackAddr) {
        fRet = IsIpInGlobalList(IpAddress);
    } else {
        FatalTrace((LPARAM) this, "IpAddress %d is loopback - Failing connection", IpAddress);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//Note : When connected port is passed in 0, it only does IP address comparison
//
BOOL SMTP_SERVER_INSTANCE::IsAddressMine(DWORD IpAddress, DWORD ConnectedPort)
{
    char * Ptr = NULL;
    const char *  StartPtr = NULL;
    const CHAR * ipAddressString = NULL;
    const CHAR * ipPortString = NULL;
    const CHAR * hostNameString = NULL;
    const CHAR * end = NULL;
    DWORD InetAddr = 0;
    DWORD CharIpSize = 0;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;
    BOOL BindingMatchFound = FALSE;
    BOOL IpSame = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::IsAddressMine");

    //grab the sharing lock

    m_GenLock.ShareLock();

    if (m_ServerBindings.IsEmpty()) {
        DebugTrace((LPARAM) this, "Server bindings is emtpy - checking all addresses");

        m_GenLock.ShareUnlock();

        IpSame = CompareIpAddress(IpAddress);
        TraceFunctLeaveEx((LPARAM)this);
        return IpSame;
    } else {
        for (StartPtr = m_ServerBindings.First(); StartPtr != NULL; StartPtr = m_ServerBindings.Next( StartPtr )) {
            ipAddressString = StartPtr;

            ipPortString = strchr(StartPtr, ':');

            if (ipPortString == NULL) {
                goto out;
            }

            ipPortString++;

            hostNameString = strchr( ipPortString, ':' );

            if ( hostNameString == NULL ) {
                goto out;
            }

            hostNameString++;

            //
            // Validate and parse the IP address portion.
            //

            if ( *ipAddressString == ':' ) {
                InetAddr = INADDR_ANY;

            } else {
                length = DIFF(ipPortString - ipAddressString) - 1;

                if ( length >= sizeof(temp) ) {
                    goto out;
                }

                CopyMemory( temp, ipAddressString, length);

                temp[length] = '\0';

                InetAddr = (DWORD)inet_addr( temp );

                if ( InetAddr == INADDR_NONE ) {
                    goto out;
                }

            }//end else of if( *ipAddressString == ':' )

            //
            // Validate and parse the port.
            //

            if ( *ipPortString == ':' ) {
                goto out;
            }

            length = (INT)(hostNameString - ipPortString);

            if ( length > sizeof(temp) ) {
                goto out;
            }

            CopyMemory(temp,ipPortString, length);

            temp[length] = '\0';

            tempPort = strtol( temp, (CHAR **)&end, 0 );

            if ( tempPort <= 0 || tempPort > 0xFFFF ) {
                goto out;
            }

            if ( *end != ':' ) {
                goto out;
            }

            if (InetAddr == INADDR_ANY) {
                IpSame = CompareIpAddress(IpAddress);

                if (IpSame && ((DWORD) tempPort == ConnectedPort) && (ConnectedPort > 0)) {
                    BindingMatchFound = TRUE;
                    goto out;
                } else if (IpSame && (ConnectedPort == 0)) {
                    BindingMatchFound = TRUE;
                    goto out;
                }
            } else if ( (IpAddress == InetAddr) && ((DWORD) tempPort == ConnectedPort) && (ConnectedPort > 0)) {
                FatalTrace((LPARAM) this, "IpAddress %d is one of mine - Failing connection", IpAddress);
                BindingMatchFound = TRUE;
                goto out;
            } else if ( (IpAddress == InetAddr) && (ConnectedPort == 0)) {
                BindingMatchFound = TRUE;
                goto out;
            }

        }//end for
    }//end else

    out:

    m_GenLock.ShareUnlock();

    if (!BindingMatchFound)
        DebugTrace((LPARAM) this, "IpAddress %d is not one of mine", IpAddress);

    TraceFunctLeaveEx((LPARAM)this);
    return BindingMatchFound;
}

BOOL SMTP_SERVER_INSTANCE::MoveToBadMail ( IMailMsgProperties *pIMsg, BOOL fUseIMsg, char * MailFile, char * FilePath)
{
    TCHAR BadMailDir[MAX_PATH + 1];
    TCHAR MailPath [MAX_PATH + 1];
    TCHAR StreamPath[MAX_PATH + 1];
    char * pszSearch = NULL;
    BOOL  f = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MoveToBadMail");

    //concatenate the name of the stream to the file
    lstrcpy(MailPath, FilePath);
    lstrcat(MailPath, MailFile);

    m_GenLock.ShareLock();
    f = SUCCEEDED(m_IAQ->HandleFailedMessage(pIMsg, fUseIMsg, MailPath, MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE, E_FAIL));
    m_GenLock.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return f;
}

#define NTFS_STORE_DIRECTORY_REG_PATH   _T("Software\\Microsoft\\Exchange\\StoreDriver\\Ntfs\\%u")
#define NTFS_STORE_DIRECTORY_REG_NAME   _T("StoreDir")
#define NTFS_STORE_BACKSLASH            _T("\\")
#define NTFS_QUEUE_DIRECTORY_SUFFIX     _T("\\Queue")
#define NTFS_DROP_DIRECTORY_SUFFIX      _T("\\Drop")

/*++
    Description:
      Initializes server configuration data from registry for SMTP Service.
      Some values are also initialized with constants.
      If invalid registry key or load data from registry fails,
        then use default values.

    Arguments:  None

    Returns:

       TRUE  if there are no errors.

    Limitations:

        No validity check is performed on the data present in registry.
--*/
BOOL SMTP_SERVER_INSTANCE::InitFromRegistry(void)
{
    LONG    err = 0;
    DWORD   dwErr = 0;
    DWORD   SizeOfBuffer = 0;
    HKEY    hkeyTcpipParam = NULL;
    BOOL    fRet = FALSE;

    //char    szHostName[MAX_PATH + 1];
    // const   CHAR * apszSubStrings[2];

    CHAR pchAddr1[32] = "";

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InitFromRegistry");

    _itoa(QueryInstanceId(), pchAddr1, 10);

    //
    // This is added by KeithLau on 7/15/96
    // This method loads the registry values that cannot be accessed
    // through the RPC's
    //
    if (!ReadStartupRegParams()) {
        ErrorTrace((LPARAM) this, "Read startup params failed.");
        goto Exit;
    }

    if (!StartAdvancedQueueing()) {
        DebugTrace((LPARAM)this, "Unable to load Advanced Queueing module\n");
        goto Exit;
    }

    fInitializedAQ = TRUE;

    //
    // Metabase Structures... can change at runtime
    // Turn off FC_SMTP_INFO_DEFAULT_DROP_DIR since
    // we already read it in ReadStartupRegParams()

    if (!ReadRegParams(FC_SMTP_INFO_ALL & ~FC_SMTP_INFO_DEFAULT_DROP_DIR, TRUE, FALSE))
    {
        ErrorTrace((LPARAM) this, "Read params failed.");
        goto Exit;
    }

    if (!InitQueues()) {
        err= GetLastError();
        ErrorTrace((LPARAM) this, "can't init queue err  = %d", err);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);

        goto Exit;
    }

    fRet = TRUE;

    Exit:

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

     Adds the new client connection to the list
      of client connections and increments the count of
      clients currently connected to server.
     If the count of max connections is exceeded, then the
      new connection is rejected.

    Arguments:

       pcc       pointer to client connection to be added

    Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
CLIENT_CONNECTION * SMTP_SERVER_INSTANCE::CreateNewConnection( IN OUT PCLIENT_CONN_PARAMS  ClientParam)
{

    SMTP_CONNECTION * NewConnection = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewConnection");

    // We will not accept new connections until the intial queue is built
    if (!m_fShouldStartAcceptingConnections || IsShuttingDown()) {
        return (NULL);
    }

    NewConnection = SMTP_CONNECTION::CreateSmtpConnection (ClientParam, this);
    if (NewConnection != NULL) {

        BUMP_COUNTER(this, NumConnInOpen);

        LockConfig();

        //  Increment the count of connected users
        m_cCurrentConnections++;

        // Update the current maximum connections
        if ( m_cCurrentConnections > m_cMaxCurrentConnections) {
            m_cMaxCurrentConnections = m_cCurrentConnections;
        }

        //set the client unique ID
        NewConnection->SetClientId(m_dwNextInboundClientId);

        m_dwNextInboundClientId++;

        //
        // Insert into the list of connected users.
        //
        InsertTailList( &m_ConnectionsList, &NewConnection->QueryListEntry());

        DebugTrace((LPARAM) this, "SMTP_SERVER_INSTANCE:InsertNewConnection succeeded");

        UnLockConfig();
    }


    TraceFunctLeaveEx((LPARAM)this);
    return ( NewConnection);

}


void SMTP_SERVER_INSTANCE::StopHint()
{
    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() ==  SERVICE_STOP_PENDING) {

        //      10/28/98 - MikeSwa
        //Use stop hint 30 seconds to avoid problems with commiting many
        //messages on shutdown. (the previous limit of 10 seconds seemed
        //to cause problems with the service control manager).
        g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, m_dwStopHint,
                                         30000 ) ;

        m_dwStopHint++ ;
    }
}

/*++

   Disconnects all user connections.

--*/
VOID SMTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)
{
    int iteration = 0;
    int i = 0;
    int Count = 0;
    LONG    cLastThreadCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;
    PLIST_ENTRY  pEntry = NULL;
    SMTP_CONNECTION  * pConn = NULL;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    //set the global termination flag
    m_IsShuttingDown = TRUE;

    LockConfig();

    TriggerStoreServerEvent(SMTP_STOREDRV_PREPSHUTDOWN_EVENT);
    m_fStoreDrvPrepShutDownEventCalled = TRUE;

    //close down all the active sockets.
    for ( pEntry = m_ConnectionsList.Flink; pEntry != &m_ConnectionsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = (SMTP_CONNECTION *) CONTAINING_RECORD( pEntry, CLIENT_CONNECTION, m_listEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient( ERROR_SERVER_DISABLED);
    }

    UnLockConfig();

    DebugTrace((LPARAM)this, "Cancelling all outstanding SQL queries");


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    cLastThreadCount = GetProcessClientThreads();
    for (i = 0; i < 180; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        //  dwAllocCount = SMTP_CONNECTION::Pool.GetAllocCount();
        dwAllocCount = (DWORD) GetConnInAllocCount();
        if (dwAllocCount == 0 && GetProcessClientThreads() == 0) {
            DebugTrace((LPARAM)this, "All SMTP_CONNECTIONs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u; Thread counts: current = %d, last = %d",
                   dwAllocCount, dwLastAllocCount, GetProcessClientThreads(), cLastThreadCount);
        if (dwAllocCount < dwLastAllocCount || GetProcessClientThreads() < cLastThreadCount) {
            DebugTrace((LPARAM)this, "SMTP_CONNECTION Connections are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
        cLastThreadCount = GetProcessClientThreads();
    }

    if (i == 180) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cCurrentConnections);
        //
        // once we're thru do it again to find any stray clients
        //
        LockConfig();

        for (pEntry = m_ConnectionsList.Flink;
            pEntry != &m_ConnectionsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (SMTP_CONNECTION *)CONTAINING_RECORD(pEntry, CLIENT_CONNECTION, m_listEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }
        UnLockConfig();
    }


    DebugTrace( (LPARAM)this, "SMTP_CONNECTION Count at end is: %d", SMTP_CONNECTION::Pool.GetAllocCount() );

    TraceFunctLeaveEx((LPARAM) this);

}


/*++

    Removes the current connection from the list of conenctions
     and decrements count of connected users

    Arguments:

       pcc       pointer to client connection to be removed

--*/
VOID SMTP_SERVER_INSTANCE::RemoveConnection( IN OUT CLIENT_CONNECTION * pConn)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveConnection");

    _ASSERT( pConn != NULL);

    LockConfig();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    // Decrement count of current users
    m_cCurrentConnections--;

    BUMP_COUNTER(this, NumConnInClose);

    UnLockConfig();

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveConnection()




/*++

     Adds the new client connection to the list
      of outbound client connections and increments the count of
      outbound clients currently connected to server.

    Arguments:

       pcc       pointer to client connection to be added

    Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
BOOL SMTP_SERVER_INSTANCE::InsertNewOutboundConnection( IN OUT CLIENT_CONNECTION * pcc, BOOL ByPassLimitCheck)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewOutboundConnection");

    _ASSERT( pcc != NULL);

    m_OutLock.ExclusiveLock();

    // Increment the count of connected users
    m_cCurrentOutConnections++;

    //set the client unique ID
    pcc->SetClientId(m_dwNextOutboundClientId);

    m_dwNextInboundClientId++;

    // Insert into the list of connected outbound users.
    InsertTailList( &m_OutConnectionsList, &pcc->QueryListEntry());

    m_OutLock.ExclusiveUnlock();

    BUMP_COUNTER(this, NumConnOutOpen);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::InsertAsyncDnsObject( IN OUT CAsyncSmtpDns *pcc)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertAsyncDnsObj");

    _ASSERT( pcc != NULL);

    EnterCriticalSection( &m_csAsyncDns ) ;

    IncAsyncDnsObjs();

    BUMP_COUNTER(this, RoutingTableLookups);

    // Insert into the list of connected outbound users.
    InsertTailList( &m_AsyncDnsList, &pcc->QueryListEntry());

    LeaveCriticalSection( &m_csAsyncDns ) ;

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

VOID SMTP_SERVER_INSTANCE::RemoveAsyncDnsObject( IN OUT CAsyncSmtpDns * pConn)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveAsyncDnsObject");

    _ASSERT( pConn != NULL);

    EnterCriticalSection( &m_csAsyncDns ) ;

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    DecAsyncDnsObjs();

    DROP_COUNTER(this, RoutingTableLookups);

    LeaveCriticalSection( &m_csAsyncDns ) ;

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveAsyncObject()


VOID SMTP_SERVER_INSTANCE::DisconnectAllAsyncDnsConnections( VOID)
{

    int iteration = 0;
    int i = 0;
    int Count = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;
    PLIST_ENTRY  pEntry = NULL;
    CAsyncSmtpDns  * pConn = NULL;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllAsyncDnsConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    EnterCriticalSection( &m_csAsyncDns ) ;

    //close down all the active sockets.
    for ( pEntry = m_AsyncDnsList.Flink; pEntry != &m_AsyncDnsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = (CAsyncSmtpDns *) CONTAINING_RECORD( pEntry, CAsyncSmtpDns, m_ListEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //"bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient();
    }

    LeaveCriticalSection( &m_csAsyncDns ) ;


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    for (i = 0; i < 500; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetAsyncDnsAllocCount ();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All SMTP DNS connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u",
                   dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "SMTP DNS Connections are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }

    if (i == 500) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cCurrentConnections);
        //
        // once we're thru do it again to find any stray clients
        //
        EnterCriticalSection( &m_csAsyncDns ) ;

        for (pEntry = m_AsyncDnsList.Flink;
            pEntry != &m_AsyncDnsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (CAsyncSmtpDns *)CONTAINING_RECORD(pEntry, CAsyncSmtpDns, m_ListEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }
        LeaveCriticalSection( &m_csAsyncDns ) ;

    }


    DebugTrace( (LPARAM)this, "SMTP DNS Count at end is: %d", CAsyncSmtpDns::Pool.GetAllocCount() );
    TraceFunctLeaveEx((LPARAM) this);
}

BOOL SMTP_SERVER_INSTANCE::InsertAsyncObject( IN OUT CAsyncMx *pcc)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewAsyncConnection");

    _ASSERT( pcc != NULL);

    m_OutLock.ExclusiveLock();

    IncAsyncMxOutObjs();

    // Insert into the list of connected outbound users.
    InsertTailList( &m_AsynConnectList, &pcc->QueryListEntry());

    m_OutLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

VOID SMTP_SERVER_INSTANCE::RemoveAsyncObject( IN OUT CAsyncMx * pConn)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveAsyncObject");

    _ASSERT( pConn != NULL);

    m_OutLock.ExclusiveLock();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    DecAsyncMxOutObjs();

    m_OutLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveAsyncObject()

VOID SMTP_SERVER_INSTANCE::DisconnectAllAsyncConnections( VOID)
{
    PLIST_ENTRY  pEntry = NULL;
    CAsyncMx  * pConn = NULL;
    int iteration = 0;
    int i = 0;
    int Count = 0;
    LONG    cLastThreadCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllAsynConnections( VOID)");

#if 0

    //close down all the active sockets.
    for ( pEntry = m_AsynConnectList.Flink; pEntry != &m_AsynConnectList; pEntry = pEntry->Flink) {
        //get the next connection object
        pConn = (CAsyncMx *) CONTAINING_RECORD( pEntry, CAsyncMx, m_ListEntry);
        _ASSERT( pConn != NULL);

        pConn->SignalObject( );
    }
#endif

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    for (i = 0; i < 500; i++) {
        DebugTrace((LPARAM)this, "Waiting for async connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetAsyncMxOutAllocCount();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All CASYNCMXs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u; Thread counts: current = %d, last = %d",
                   dwAllocCount, dwLastAllocCount, GetProcessClientThreads(), cLastThreadCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "CASYNCMX Connections are going away, resetting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }

    if (i == 500) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cNumAsyncObjsAlloced);
        //
        // once we're thru do it again to find any stray clients
        //
        m_OutLock.ExclusiveLock();

        for (pEntry = m_ConnectionsList.Flink;
            pEntry != &m_ConnectionsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (CAsyncMx *)CONTAINING_RECORD(pEntry, CAsyncMx, m_ListEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }

        m_OutLock.ExclusiveUnlock();
    }


    DebugTrace( (LPARAM)this, "CASYNCMX Count at end is: %d", m_cNumAsyncObjsAlloced);
    TraceFunctLeaveEx((LPARAM) this);
}




/*++

   Disconnects all user connections.

--*/
VOID SMTP_SERVER_INSTANCE::DisconnectAllOutboundConnections( VOID)
{
    int iteration = 0;
    int i = 0;
    int Count = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    PLIST_ENTRY  pEntry = NULL;
    CLIENT_CONNECTION  * pConn = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::DisconnectAllOutboundConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    m_OutLock.ExclusiveLock();


    //close down all the active sockets.
    for ( pEntry = m_OutConnectionsList.Flink; pEntry != &m_OutConnectionsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = CONTAINING_RECORD( pEntry, CLIENT_CONNECTION, m_listEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //"bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient( ERROR_SERVER_DISABLED);
    }

    m_OutLock.ExclusiveUnlock();

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 180 seconds for a fixed user count.
    //
    dwTickCount = GetTickCount();
    for (i = 0; i < 180; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetConnOutAllocCount();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All SMTP_CONNOUTs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u", dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "SMTP_CONNECTION Connections are going away, resetting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }


    DebugTrace( (LPARAM)this, "SMTP_CONNOUT Count at end is: %d", SMTP_CONNECTION::Pool.GetAllocCount() );
    TraceFunctLeaveEx((LPARAM)this);
}


/*++

    Removes the current connection from the list of conenctions
     and decrements count of connected users

    Arguments:

       pcc       pointer to client connection to be removed

--*/
VOID SMTP_SERVER_INSTANCE::RemoveOutboundConnection( IN OUT CLIENT_CONNECTION * pConn)
{
    _ASSERT( pConn != NULL);

    m_OutLock.ExclusiveLock();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    // Decrement count of current users
    m_cCurrentOutConnections--;

    BUMP_COUNTER(this, NumConnOutClose);

    m_OutLock.ExclusiveUnlock();


} // SMTP_SERVER_INSTANCE::RemoveConnection()

BOOL SMTP_SERVER_INSTANCE::InitDirectoryNotification(void)
{
    char MailPickUp[MAX_PATH + 1];

    TraceFunctEnterEx((LPARAM)this, "InitDirectoryNotification");

    lstrcpy(MailPickUp, GetMailPickupDir());

    //get rid of the \\ at the end of the name
    if (MailPickUp [GetMailPickupDirLength() - 1] == '\\')
        MailPickUp [GetMailPickupDirLength() - 1] = '\0';

    //create an outbound connectiong_SmtpConfig->GetMailPickupDir()
    SmtpDir = SMTP_DIRNOT::CreateSmtpDirNotification(MailPickUp, SMTP_DIRNOT::ReadDirectoryCompletion, this);
    if (SmtpDir == NULL) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //now that both queues are initialized, create the
    //thread that goes off and finds any mail files
    //that were not sent and builds up both queues
    DWORD ThreadId;
    DWORD error;
    DirPickupThreadHandle = CreateThread (NULL, 0, SMTP_DIRNOT::PickupInitialFiles, SmtpDir, 0, &ThreadId);
    if (DirPickupThreadHandle == NULL) {
        error = GetLastError();
        ErrorTrace((LPARAM)this, "CreateThread failed for SMTP_DIRNOT::PickupInitialFiles. err: %u", error);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

void SMTP_SERVER_INSTANCE::DestroyDirectoryNotification(void)
{
    TraceFunctEnterEx((LPARAM)this, "DestroyDirectoryNotification(void)");

    //wait for the initial pickup thread
    //to die
    if (DirPickupThreadHandle != NULL) {
        if (SmtpDir)
            SmtpDir->SetPickupRetryQueueEvent();

        WaitForSingleObject(DirPickupThreadHandle, INFINITE);
        ErrorTrace((LPARAM)this, "Initial pickup thread is dead");
        CloseHandle(DirPickupThreadHandle);
        DirPickupThreadHandle = NULL;
    }

    //Just close the handle to the
    //directory. This will cause
    //the notification to come back
    //with an error, and it will be
    //deleted.
    if (SmtpDir) {
        SmtpDir->CloseDirHandle();
    }

    if (SmtpDir) {
        delete SmtpDir;
        SmtpDir = NULL;
        CloseHandle(StopHandle);
        StopHandle = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
}

extern char g_UserName[];
extern char g_DomainName[];
extern char g_Password[];


void SMTP_SERVER_INSTANCE::SinkSmtpServerStartHintFunc(void)
{
    if (g_pInetSvc) {
        ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
    }
}

void SMTP_SERVER_INSTANCE::SinkSmtpServerStopHintFunc(void)
{
    StopHint();
}

void SmtpServerStartHintFunc(PVOID ThisPtr)
{
    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
}

void SmtpServerStopHintFunc(PVOID ThisPtr)
{
    ((SMTP_SERVER_INSTANCE *) ThisPtr)->StopHint();
}

BOOL SMTP_SERVER_INSTANCE::StartAdvancedQueueing(void)
{
    TraceFunctEnterEx((LPARAM) this, "LoadAdvancedQueueing");

    HRESULT hr = S_OK;

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    hr = (g_pfnInitializeAQ)(m_ComSmtpServer, QueryInstanceId(),
                             g_UserName, g_DomainName, g_Password, SmtpServerStartHintFunc,
                             (PVOID) this, &m_IAQ, &m_ICM,
                             &m_pIAdvQueueConfig, &m_pvAQInstanceContext);

    ErrorTrace((LPARAM)this, "Advanced Queuing returned status code  %x", hr);

    TraceFunctLeaveEx((LPARAM) this);
    return !FAILED(hr);

}

BOOL SMTP_SERVER_INSTANCE::StopQDrivers(void)
{
    TraceFunctEnterEx((LPARAM) this, "StopQDrivers");

    if (m_pIAdvQueueConfig) {
        m_pIAdvQueueConfig->Release();
        m_pIAdvQueueConfig = NULL;
    }

    if (m_IAQ != NULL) {
        m_IAQ->Release();
        m_IAQ = NULL;
    }

    if (m_ICM != NULL) {
        m_ICM->Release();
        m_ICM = NULL;
    }

    if (fInitializedAQ && g_pfnDeinitializeAQ && m_pvAQInstanceContext) {
        (g_pfnDeinitializeAQ)(m_pvAQInstanceContext, SmtpServerStopHintFunc, (PVOID) this);
        m_pvAQInstanceContext = NULL;
        fInitializedAQ = FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

extern void VerifyFQDNWithGlobalIp(DWORD InstanceId,char * szFQDomainName);
void SMTP_SERVER_INSTANCE::VerifyFQDNWithBindings(void)
{

    CONST CHAR *apszMsgs[2];
    CHAR achInstance[20];
    CHAR achIPAddr[20];

    char * FQDNValue = NULL;
    char * IpAddress = NULL;
    in_addr UNALIGNED * P_Addr = NULL;

    PHOSTENT pH = NULL;

    char * Ptr = NULL;
    const char *  StartPtr = NULL;
    const CHAR * ipAddressString = NULL;
    const CHAR * ipPortString = NULL;
    const CHAR * end = NULL;
    DWORD InetAddr = 0;
    DWORD CharIpSize = 0;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;

    BOOL fGlobalListChecked = FALSE;

    //Get the current instnace id
    wsprintf( achInstance,
              "%lu",
              QueryInstanceId() );
    apszMsgs[1] = achInstance;

    //grab the sharing lock

    if (m_ServerBindings.IsEmpty()) {
        if (!fGlobalListChecked) {
            VerifyFQDNWithGlobalIp(QueryInstanceId(), m_szFQDomainName);
            fGlobalListChecked = TRUE;
        }
    } else {
        for (StartPtr = m_ServerBindings.First(); StartPtr != NULL; StartPtr = m_ServerBindings.Next( StartPtr )) {
            ipAddressString = StartPtr;
            ipPortString = strchr(StartPtr, ':');
            if (ipPortString == NULL) {
                wsprintf( achIPAddr,"%s","0.0.0.0");
                apszMsgs[0] = achIPAddr;
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
            }

            // Validate and parse the IP address portion.
            //
            if ( *ipAddressString == ':' ) {
                if (!fGlobalListChecked) {
                    VerifyFQDNWithGlobalIp(QueryInstanceId(),m_szFQDomainName);
                    fGlobalListChecked = TRUE;
                }
            } else {
                length = DIFF(ipPortString - ipAddressString) - 1;
                if ( length >= sizeof(temp) ) {
                    wsprintf( achIPAddr,"%s", temp);
                    apszMsgs[0] = achIPAddr;
                    SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,1,apszMsgs,0 );
                } else {
                    CopyMemory( temp, ipAddressString, length);
                    temp[length] = '\0';
                    InetAddr = inet_addr( temp );
                    if ( InetAddr != INADDR_NONE ) {
                        //For IP address find the host name
                        ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
                        pH = gethostbyaddr((char*)(&InetAddr), 4, PF_INET );
                        if (pH && pH->h_name) {
                            if (_strcmpi(pH->h_name,m_szFQDomainName)) {
                                wsprintf( achIPAddr,"%s",temp);
                                apszMsgs[0] = achIPAddr;
                                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                            }
                        } else {
                            wsprintf( achIPAddr,"%s",temp);
                            apszMsgs[0] = achIPAddr;
                            SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                        }

                    } else {
                        wsprintf( achIPAddr,"%s", temp);
                        apszMsgs[0] = achIPAddr;
                        SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                    }
                }
            }//end else of if( *ipAddressString == ':' )
        }//end for
    }//end else

    return;
}

BOOL SMTP_SERVER_INSTANCE::RegisterServicePrincipalNames(BOOL fLock)
{
    if (fLock)
        m_GenLock.ExclusiveLock();

    if (!m_fHaveRegisteredPrincipalNames) {

        PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

        if (pService->ResetServicePrincipalNames()) {

            m_fHaveRegisteredPrincipalNames =
                CSecurityCtx::RegisterServicePrincipalNames(
                    SMTP_SERVICE_NAME, m_szFQDomainName);
        }
    }

    if (fLock)
        m_GenLock.ExclusiveUnlock();

    return( m_fHaveRegisteredPrincipalNames );
}


//+------------------------------------------------------------
//
// Function: SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps
//
// Synopsis: Take info from member variables and set them in the
//           IServer property bag
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from CMailMsgLoggingPropertyBag
//
// History:
// jstamerj 1998/11/17 16:41:08: Created.
//
//-------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps");

    _ASSERT(m_pSmtpInfo);

    hr = m_InstancePropertyBag.PutDWORD(
        PE_ISERVID_DW_INSTANCE,
        m_pSmtpInfo->dwInstanceId);

    if(FAILED(hr))
        goto CLEANUP;

    hr = m_InstancePropertyBag.PutStringA(
        PE_ISERVID_SZ_DEFAULTDOMAIN,
        m_szDefaultDomain);

    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);

    return hr;
}

//---[ SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded ]--------------------------
//
//
//  Description:
//      Checks to see if we are past our drop dir quota (if enforced).  The
//      quota is defined to be 11 times the max messages size (or 22 MB if
//      there is no max message size).  If we are within 1 max message size
//      of the quota (2MB is no max message size), we will assume that this
//      message will push us over the quota.
//  Parameters:
//      -
//  Returns:
//      TRUE        We are past our quota (or this message will do it)
//      FALSE       We are still under drop dir quota.
//  History:
//      10/28/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded()
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded");
    DWORD   cbMaxMsgSize = GetMaxMsgSize();
    BOOL    fQuotaExceeded = FALSE;
    HANDLE  hDropDirFind = INVALID_HANDLE_VALUE;
    LARGE_INTEGER LIntDropDirSize;
    LARGE_INTEGER LIntDropQuota;
    LARGE_INTEGER LIntCurrentFile;
    WIN32_FIND_DATA   FileInfo;
    CHAR    szDropDirSearch[sizeof(m_szMailDropDir) + sizeof("*")];

    ZeroMemory(&FileInfo, sizeof(FileInfo));
    LIntDropDirSize.QuadPart = 0;
    LIntDropQuota.QuadPart = 0;

    if (!IsDropDirQuotaCheckingEnabled() || !GetMailDropDir(szDropDirSearch))
    {
        fQuotaExceeded = FALSE;
        goto Exit;
    }

    if (!cbMaxMsgSize)
        cbMaxMsgSize = 2*1024*1024;  //Default to 2 MB

    //Set drop dir quota to be 10 times the max message size, if we
    //exceed this, then we are within 1 max message size of the "true" quota
    LIntDropQuota.QuadPart = 10*cbMaxMsgSize;

    //Build up a search so we can loop over the file names
    lstrcat(szDropDirSearch, "*");
    hDropDirFind = FindFirstFileEx(szDropDirSearch,
                                   FindExInfoStandard,
                                   &FileInfo,
                                   FindExSearchNameMatch,
                                   NULL,
                                   0);

    if (INVALID_HANDLE_VALUE == hDropDirFind)
    {
        ErrorTrace((LPARAM) this,
            "Unable to open drop dir for quota checking - 0x%X", GetLastError());

        //If we cannot open the directory assume we are over quota
        fQuotaExceeded  = TRUE;
        goto Exit;
    }

    //Loop over all the files we have found
    do
    {
        LIntCurrentFile.LowPart = FileInfo.nFileSizeLow;
        LIntCurrentFile.HighPart = FileInfo.nFileSizeHigh;

        LIntDropDirSize.QuadPart += LIntCurrentFile.QuadPart;

        if (LIntDropQuota.QuadPart <= LIntDropDirSize.QuadPart)
        {
            fQuotaExceeded = TRUE;
            goto Exit;
        }
    } while (FindNextFile(hDropDirFind, &FileInfo));

    if (LIntDropQuota.QuadPart <= LIntDropDirSize.QuadPart)
        fQuotaExceeded = TRUE;
    else
        fQuotaExceeded = FALSE;

  Exit:
    if (INVALID_HANDLE_VALUE != hDropDirFind)
        FindClose(hDropDirFind);

    TraceFunctLeave();
    return fQuotaExceeded;
}

//-----------------------------------------------------------------------------
//  Description:
//      Given a GUID identifying a DNS-list returned by a DNS sink, this
//      function searches the list of GUID/DNS-lists till a matching GUID is
//      found, and then returns the DNS-list associated with the GUID.
//  Arguments:
//      IN GUID *pGuidNetwork - Identifies a "network" and the set of DNS
//          servers to resolve names on that network.
//  Returns:
//      CTcpRegIpList* corresponding to the DNS-list for the GUID passed in.
//      NULL if there is no matching GUID.
//  Notes:
//      See the documentation for UpdateDnsServerInfo for a general overview
//      of this feature.
//-----------------------------------------------------------------------------
CTcpRegIpList *SMTP_SERVER_INSTANCE::GetDnsServerInfo(GUID *pGuidNetwork)
{
    INT iRet = 0;
    ULONG i = 0;
    CTcpRegIpList *pTcpRegIpList = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::GetDnsServerInfo");

    m_slServerList.ShareLock();

    //
    // Loop through lists of servers, find a GUID match and return a pointer to
    // the CTcpRegIpList struct for the list.
    //
    for(i = 0; i < m_cServerList; i++) {

        iRet = memcmp(
                  &(m_rgpServerList[i]->m_guid),
                  pGuidNetwork,
                  sizeof(GUID));

        if(0 == iRet) {
            DebugTrace((LPARAM)this, "Matched GUID #%d", i);
            pTcpRegIpList = &(m_rgpServerList[i]->m_TcpRegIpList);
            break;
        }
    }

    m_slServerList.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return pTcpRegIpList;
}

//-----------------------------------------------------------------------------
//  Description:
//      Returns the DNS list associated with a GUID. If the GUID is not already
//      in the table of GUID/lists stored in the VSI object, it is entered into
//      the table and the DNS list is returned.
//  Arguments:
//      DNS_SERVER_INFO pDnsServerInfo - New GUID/list to add, unless the GUID
//          is already present in the table in which case the new list is used
//          to update the list in the table.
//  Returns:
//      CTcpRegIpList* to the list associated with the GUID
//      NULL if a failure occurred (typically out of memory)
//  Overview:
//      SMTP fires the DNS resolver event each time it tries to resolve a
//      remote-domain. Through this event, the DNS-sink can control (among
//      other things), the set of DNS servers that SMTP should use to resolve
//      the remote-domain.
//
//      This functionality is used to provide the "DMZ" feature in SMTP. If
//      a mail server is in the DMZ between an internal network and the
//      Internet, and it's function is to relay mail between the internal
//      network and the Internet: then remote-hosts on the Internet must
//      be resolved using a different set of DNS servers than remote-hosts
//      on the intranet. This is because they have different name spaces.
//
//      In such a situation, the DNS sink determines whether the target
//      host should be resolved using an alternate set of DNS servers,
//      and returns the list of DNS servers to be used each time the
//      DNS event if fired.
//
//      Now, we keep track of DNS server state across different outbound
//      connections, so we would like to keep the DNS list around and
//      keep tabulating the connection failure/success statistics, and
//      only update the DNS list when there is a change in the servers
//      being used.
//
//      Since this feature may also be used by a DNS sink to route mail
//      through multiple (> 2) networks, there may be multiple distinct
//      lists of DNS servers in use at any time. It is therefore important
//      to distinguish between when the list of DNS servers has changed,
//      and when a totally different list (for a different) network is
//      being returned.
//
//      For this purpose, each network/list is identified by a GUID. Each
//      time the DNS sink event returns a list of DNS servers and the GUID
//      for the list, this function checks to see if that GUID/list has
//      already been added to our set of GUID/lists. If not, the new
//      GUID/list is added. If it already exists, we check to see if any
//      of the DNS servers have changed, and update them if needed.
//
//  Note:
//      The number of DNS lists are assumed to be quite small. Also, DNS
//      lists can only be added. Once added there is no way to remove a
//      DNS list (other than shutting down the VSI). The idea is that each
//      DNS list corresponds to a "network" and there are only 2-3 different
//      networks. Connections to different networks cause different DNS
//      lists to be used.
//-----------------------------------------------------------------------------
CTcpRegIpList *SMTP_SERVER_INSTANCE::UpdateDnsServerInfo(DNS_SERVER_INFO *pDnsServerInfo)
{
    BOOL fRet = FALSE;
    INT iRet = 0;
    BOOL fGUIDFound = FALSE;
    DNS_SERVER_LIST *pServerList = NULL;
    CTcpRegIpList *pTcpRegIpList = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::UpdateDnsServerInfo");

    pTcpRegIpList = GetDnsServerInfo(&(pDnsServerInfo->guidNetwork));

    // Found a match: update the server-list
    if(pTcpRegIpList) {
        fRet = pTcpRegIpList->UpdateIfChanged((PIP_ARRAY)(pDnsServerInfo->pipServers));
        TraceFunctLeaveEx((LPARAM)this);
        return pTcpRegIpList;
    }

    //
    // This DNS server list does not exist. Add it to the list.
    //

    if(m_cServerList >= MAX_DNS_SERVER_LISTS) {
        ErrorTrace((LPARAM)this, "Exceeded maximum DNS list limit");
        TraceFunctLeaveEx((LPARAM)this);
        return NULL;
    }

    pServerList = new DNS_SERVER_LIST();
    if(!pServerList) {
        pTcpRegIpList = NULL;
        fRet = FALSE;
        goto Cleanup;
    }

    fRet = (pServerList->m_TcpRegIpList).Update((PIP_ARRAY)pDnsServerInfo->pipServers);

    if(!fRet) {
        ErrorTrace((LPARAM)this, "Update failed");
        pTcpRegIpList = NULL;
        fRet = FALSE;
        goto Cleanup;
    }

    CopyMemory(&(pServerList->m_guid), &(pDnsServerInfo->guidNetwork), sizeof(GUID));

    m_slServerList.ExclusiveLock();

    DebugTrace((LPARAM)this, "Added GUID %d to the list", m_cServerList);

    m_rgpServerList[m_cServerList] = pServerList;
    m_cServerList++;

    m_slServerList.ExclusiveUnlock();

    pTcpRegIpList = &(pServerList->m_TcpRegIpList);
    fRet = TRUE;

Cleanup:
    if(!fRet && pServerList)
        delete pServerList;

    TraceFunctLeaveEx((LPARAM)this);
    return pTcpRegIpList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\sockutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    sockutil.c

    This module contains utility routines for managing & manipulating
    sockets.


    FILE HISTORY:
		VladimV		30-May-1995		Created	

*/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

extern HINSTANCE		g_WSockMsgDll;


//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeSockets

    SYNOPSIS:   Initializes socket access.  Among other things, this
                routine is responsible for connecting to WinSock,
                and creating the connection thread.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:

********************************************************************/
APIERR InitializeSockets( VOID )
{
    WSADATA   wsadata;
    SOCKERR   serr;

    TraceFunctEnter( "InitializeSockets" );

    //
    //  Connect to WinSock.
    //

    serr = WSAStartup( MAKEWORD( 1, 1 ), &wsadata );

    if( serr != 0 ) {

       // g_pInetSvc->LogEvent( SMTP_EVENT_CANNOT_INITIALIZE_WINSOCK,
       //                        0, (const CHAR **) NULL, serr);

        FatalTrace( 0, "cannot initialize WinSock, socket error %d", serr); _ASSERT( FALSE);
    } else {
		DebugTrace( 0, "Sockets initialized");
	}
    TraceFunctLeave();
    return serr;
}   // InitializeSockets

/*******************************************************************

    NAME:       TerminateSockets

    SYNOPSIS:   Terminate socket access.  This routine is responsible
                for closing the connection socket(s) and detaching
                from WinSock.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:

********************************************************************/
VOID TerminateSockets( VOID )
{
    SOCKERR serr;

    TraceFunctEnter( "TerminateSockets" );

    //
    //  Disconnect from WinSock.
    //

    serr = WSACleanup();

    if( serr != 0 ) {
		FatalTrace( 0, "cannot terminate WinSock, error=%d", serr); _ASSERT( FALSE);
    } else {
		DebugTrace( 0, "Sockets terminated");
	}
    TraceFunctLeave();
}   // TerminateSockets

/*******************************************************************

    NAME:       GetSockErrorMessage

    SYNOPSIS:   This routine is responsible for getting winsock
                error messages stored in smtpsvc.dll

    HISTORY:

********************************************************************/
DWORD GetSockErrorMessage(DWORD dwErrno, char * ErrorBuf, DWORD ErrorBufSize)
{
    DWORD msglen;
    DWORD usMsgNum;

    switch (dwErrno) 
	{
        case WSAENAMETOOLONG:
            usMsgNum = SMTP_WSAENAMETOOLONG;
            break;
        case WSASYSNOTREADY:
            usMsgNum = SMTP_WSASYSNOTREADY;
            break;
        case WSAVERNOTSUPPORTED:
            usMsgNum = SMTP_WSAVERNOTSUPPORTED;
            break;
        case WSAESHUTDOWN:
            usMsgNum = SMTP_WSAESHUTDOWN;
            break;
        case WSAEINTR:
            usMsgNum = SMTP_WSAEINTR;
            break;
        case WSAHOST_NOT_FOUND:
            usMsgNum = SMTP_WSAHOST_NOT_FOUND;
            break;
        case WSATRY_AGAIN:
            usMsgNum = SMTP_WSATRY_AGAIN;
            break;
        case WSANO_RECOVERY:
            usMsgNum = SMTP_WSANO_RECOVERY;
            break;
        case WSANO_DATA:
            usMsgNum = SMTP_WSANO_DATA;
            break;
        case WSAEBADF:
            usMsgNum = SMTP_WSAEBADF;
            break;
        case WSAEWOULDBLOCK:
            usMsgNum = SMTP_WSAEWOULDBLOCK;
            break;
        case WSAEINPROGRESS:
            usMsgNum = SMTP_WSAEINPROGRESS;
            break;
        case WSAEALREADY:
            usMsgNum = SMTP_WSAEALREADY;
            break;
        case WSAEFAULT:
            usMsgNum = SMTP_WSAEFAULT;
            break;
        case WSAEDESTADDRREQ:
            usMsgNum = SMTP_WSAEDESTADDRREQ;
            break;
        case WSAEMSGSIZE:
            usMsgNum = SMTP_WSAEMSGSIZE;
            break;
        case WSAEPFNOSUPPORT:
            usMsgNum = SMTP_WSAEPFNOSUPPORT;
            break;
        case WSAENOTEMPTY:
            usMsgNum = SMTP_WSAENOTEMPTY;
            break;
        case WSAEPROCLIM:
            usMsgNum = SMTP_WSAEPROCLIM;
            break;
        case WSAEUSERS:
            usMsgNum = SMTP_WSAEUSERS;
            break;
        case WSAEDQUOT:
            usMsgNum = SMTP_WSAEDQUOT;
            break;
        case WSAESTALE:
            usMsgNum = SMTP_WSAESTALE;
            break;
        case WSAEINVAL:
            usMsgNum = SMTP_WSAEINVAL;
            break;
        case WSAEMFILE:
            usMsgNum = SMTP_WSAEMFILE;
            break;
        case WSAELOOP:
            usMsgNum = SMTP_WSAELOOP;
            break;
        case WSAEREMOTE:
            usMsgNum = SMTP_WSAEREMOTE;
            break;
        case WSAENOTSOCK:
            usMsgNum = SMTP_WSAENOTSOCK;
            break;
        case WSAEADDRNOTAVAIL:
            usMsgNum = SMTP_WSAEADDRNOTAVAIL;
            break;
        case WSAEADDRINUSE:
            usMsgNum = SMTP_WSAEADDRINUSE;
            break;
        case WSAEAFNOSUPPORT:
            usMsgNum = SMTP_WSAEAFNOSUPPORT;
            break;
        case WSAESOCKTNOSUPPORT:
            usMsgNum = SMTP_WSAESOCKTNOSUPPORT;
            break;
        case WSAEPROTONOSUPPORT:
            usMsgNum = SMTP_WSAEPROTONOSUPPORT;
            break;
        case WSAENOBUFS:
            usMsgNum = SMTP_WSAENOBUFS;
            break;
        case WSAETIMEDOUT:
            usMsgNum = SMTP_WSAETIMEDOUT;
            break;
        case WSAEISCONN:
            usMsgNum = SMTP_WSAEISCONN;
            break;
        case WSAENOTCONN:
            usMsgNum = SMTP_WSAENOTCONN;
            break;
        case WSAENOPROTOOPT:
            usMsgNum = SMTP_WSAENOPROTOOPT;
            break;
        case WSAECONNRESET:
            usMsgNum = SMTP_WSAECONNRESET;
            break;
        case WSAECONNABORTED:
            usMsgNum = SMTP_WSAECONNABORTED;
            break;
        case WSAENETDOWN:
            usMsgNum = SMTP_WSAENETDOWN;
            break;
        case WSAENETRESET:
            usMsgNum = SMTP_WSAENETRESET;
            break;
        case WSAECONNREFUSED:
            usMsgNum = SMTP_WSAECONNREFUSED;
            break;
        case WSAEHOSTDOWN:
            usMsgNum = SMTP_WSAEHOSTDOWN;
            break;
        case WSAEHOSTUNREACH:
            usMsgNum = SMTP_WSAEHOSTUNREACH;
            break;
        case WSAEPROTOTYPE:
            usMsgNum = SMTP_WSAEPROTOTYPE;
            break;
        case WSAEOPNOTSUPP:
            usMsgNum = SMTP_WSAEOPNOTSUPP;
            break;
        case WSAENETUNREACH:
            usMsgNum = SMTP_WSAENETUNREACH;
            break;
        case WSAETOOMANYREFS:
            usMsgNum = SMTP_WSAETOOMANYREFS;
            break;
        default:
            usMsgNum = dwErrno;
			break;
    }

								// call the OS using US/ASCII
	msglen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, g_WSockMsgDll, usMsgNum,
						   MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
						   ErrorBuf, ErrorBufSize, NULL);
	return(msglen);
}


/*++

	Name :
		MyStrChr

    Description:
	   Works just like strchr(), but takes the size
	   of the buffer

    Arguments:
		Line - Buffer to search
		Val  - Value to look for in the buffer
		LineSize - Size of Line

    Returns:
		If Val is found, a pointer to Val is
		returned, els NULL


--*/
char * MyStrChr(char *Line, unsigned char Val, DWORD LineSize)
{
   register DWORD Loop = 0;
   unsigned char * Match = NULL;
   register unsigned char * SearchPtr;

   ASSERT( Line != NULL);

   if(LineSize == 0)
    return NULL;

   SearchPtr = (unsigned char *) Line;

   // Scan the entire buffer looking for Val
   for(Loop = 0; Loop < LineSize; Loop++)
   {
     if (SearchPtr[Loop] == Val)
     {
		Match  = &SearchPtr[Loop];
        break;
     }

   } // for

  return (char *) Match;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\smtpsvr.h ===
// SMTPServer.h : Declaration of the CSMTPServer

#ifndef __SMTPSERVER_H_
#define __SMTPSERVER_H_

#include "resource.h"       // main symbols
#include <smtpevent.h>

/////////////////////////////////////////////////////////////////////////////
// CSMTPServer
//class ATL_NO_VTABLE CSMTPServer :
class CSMTPServer :
	public ISupportErrorInfo,
    public ISMTPServerInternal,
    public IMailTransportRouterReset,
    public IMailTransportSetRouterReset,
    public IMailTransportRouterSetLinkState,
    public ISMTPServerEx,
    public ISMTPServerGetAuxDomainInfoFlags,
    public ISMTPServerAsync
{
public:
	CSMTPServer()
	{
		m_pInstance = NULL;
        m_pIRouterReset = NULL;
        m_pIRouterSetLinkState = NULL;
		m_ulRefCount = 0;
	}

	HRESULT Init(SMTP_SERVER_INSTANCE * pInstance);


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISMTPServer
public:

	STDMETHOD(QueryInterface)(REFIID iid, void  **ppvObject);

	STDMETHOD_(ULONG, AddRef)(void) {return(InterlockedIncrement(&m_ulRefCount));};

	STDMETHOD_(ULONG, Release) (void)
	{
		LONG    lRefCount = InterlockedDecrement(&m_ulRefCount);
		if (lRefCount == 0)
		{
            delete this;
		}

		return(lRefCount);
	};

	STDMETHOD (AllocMessage)(
				IMailMsgProperties **ppMsg
				);

	STDMETHOD (SubmitMessage)(
				IMailMsgProperties *pMsg
				);

	STDMETHOD (TriggerLocalDelivery)(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes);
    STDMETHOD (TriggerServerEvent)(DWORD dwEventID, PVOID pvContext);

	STDMETHOD (ReadMetabaseString)(DWORD MetabaseId, LPBYTE Buffer, DWORD * BufferSize, BOOL fSecure);

	STDMETHOD (ReadMetabaseDword)(DWORD MetabaseId, DWORD * dwValue);
	STDMETHOD (ServerStartHintFunction)();
	STDMETHOD (ServerStopHintFunction)();

    STDMETHOD (AllocBoundMessage)(OUT IMailMsgProperties **ppMsg, OUT PFIO_CONTEXT *phContent);
    STDMETHOD (WriteLog)(IN LPMSG_TRACK_INFO pMsgTrackInfo,
                         IN IMailMsgProperties *pMsg,
                         IN LPEVENT_LOG_INFO pEventLogInfo,
                         IN LPSTR pszProtocolLog );

    STDMETHOD (ReadMetabaseData)(IN DWORD MetabaseId,
                                 IN OUT BYTE * Buffer,
                                 IN OUT DWORD * BufferSize);


public: //IMailTransportRouterReset
    STDMETHOD (ResetRoutes)(IN DWORD dwResetType);

public: //IMailTransportSetRouterReset
    STDMETHOD (RegisterResetInterface)(IN DWORD dwVirtualServerID,
                                      IN IMailTransportRouterReset *pIRouterReset);
public: //IMailTransportRouterSetLinkState
    STDMETHOD(SetLinkState)(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME                *pftNextScheduled,
        IN IMessageRouter          *pMessageRouter);

public: //ISMTPServerEx
    STDMETHOD(TriggerLogEvent)(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule);

    STDMETHOD(ResetLogEvent)(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey);

public: //ISMTPServerGetAuxDomainInfoFlags
    STDMETHOD(HrTriggerGetAuxDomainInfoFlagsEvent)(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags );

public: //ISMTPServerAsync
	STDMETHOD(TriggerLocalDeliveryAsync)(IMailMsgProperties *pMsg, 
                                         DWORD dwRecipientCount, 
                                         DWORD * pdwRecipIndexes,
                                         IMailMsgNotify *pNotify);

private:
	LONG m_ulRefCount;
	SMTP_SERVER_INSTANCE               *m_pInstance;
    IMailTransportRouterReset          *m_pIRouterReset;
    IMailTransportRouterSetLinkState   *m_pIRouterSetLinkState;
    CShareLockNH                        m_slRouterReset;

};

#endif //__SMTPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\spinlock.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.cpp
//
// Contents: Simple Spinlock package used by CLdapConnection
//
// Classes:
//
// Functions:
//   AcquireSpinLockSingleProc
//   AcquireSpinLockMultiProc
//   InitializeSpinLock
//   ReleaseSpinLock
//
// History:
// jstamerj 980511 17:26:26: Created.
//
//-------------------------------------------------------------
#include "smtpinc.h"
#include "spinlock.h"

PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSpinLock
//
//  Synopsis:   Initializes a SPIN_LOCK
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to initialize
//
//  Returns:    Nothing. *psl is in released state when this functionr returns
//
//-----------------------------------------------------------------------------

VOID InitializeSpinLock(
    PSPIN_LOCK psl)
{
    *psl = 0;

    if(g_AcquireSpinLock == NULL) {
        // Determine multi or single proc
        SYSTEM_INFO si;
        GetSystemInfo(&si);
    
        if(si.dwNumberOfProcessors > 1) {
            g_AcquireSpinLock = AcquireSpinLockMultipleProc;
        } else {
            g_AcquireSpinLock = AcquireSpinLockSingleProc;
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockMultiProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for multi proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockMultipleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            ;
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockSingleProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for single proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockSingleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            Sleep(0);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseSpinLock
//
//  Synopsis:   Releases an acquired spin lock
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to release.
//
//  Returns:    Nothing. *psl is in released state when this function returns
//
//-----------------------------------------------------------------------------

VOID ReleaseSpinLock(
    PSPIN_LOCK psl)
{
    _ASSERT( *psl > 0 );

    InterlockedExchange( psl, 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "smtpinc.h"
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_)
#define AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define INCL_INETSRV_INCS
#include "atq.h"
#include "dbgtrace.h"

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :
    
       stats.cxx

   Abstract:
    
       Defines functions required for server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994
   
   Project:

       Web Server DLL

   Functions Exported:

               SMTP_SERVER_STATISTICS::SERVER_STATISTICS( VOID) 
       VOID    SMTP_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPSMTP_STATISTICS_1 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"


/************************************************************
 *    Functions 
 ************************************************************/

 /*++
     Initializes statistics information for server.
--*/

SMTP_SERVER_STATISTICS::SMTP_SERVER_STATISTICS(SMTP_SERVER_INSTANCE * pInstance) 
{
    InitializeCriticalSection( & m_csStatsLock);

	m_pInstance = pInstance;

    ClearStatistics();

} // SMTP_SERVER_STATISTICS::SMTP_SERVER_STATISTICS();

/*++

    Clears the counters used for statistics information

--*/ 
VOID
SMTP_SERVER_STATISTICS::ClearStatistics( VOID)
{
    LockStatistics();

    ZeroMemory( &m_SmtpStats, sizeof(SMTP_STATISTICS_0) );
    m_SmtpStats.TimeOfLastClear       = GetCurrentTime();
    UnlockStatistics();

} // SMTP_SERVER_STATISTICS::ClearStatistics()



DWORD
SMTP_SERVER_STATISTICS::CopyToStatsBuffer( LPSMTP_STATISTICS_0 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the SMTP_STATISTICS_1 structure for RPC access.

    Arugments:
        lpStat  pointer to SMTP_STATISTICS_1 object which contains the 
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success. 

--*/
{
	AQPerfCounters AqPerf;
	HRESULT hr = S_FALSE;
	IAdvQueueConfig *pIAdvQueueConfig = NULL;

    _ASSERT( lpStat != NULL);

    LockStatistics();

	pIAdvQueueConfig = m_pInstance->QueryAqConfigPtr();
	if(pIAdvQueueConfig != NULL)
	{
        AqPerf.cbVersion = sizeof(AQPerfCounters);
		hr = pIAdvQueueConfig->GetPerfCounters(
            &AqPerf,
            &(m_SmtpStats.CatPerfBlock));

		if(!FAILED(hr))
		{
			m_SmtpStats.RemoteQueueLength = AqPerf.cCurrentQueueMsgInstances;
			m_SmtpStats.NumMsgsDelivered = AqPerf.cMsgsDeliveredLocal;
			m_SmtpStats.LocalQueueLength = AqPerf.cCurrentMsgsPendingLocalDelivery;
			m_SmtpStats.RemoteRetryQueueLength = AqPerf.cCurrentMsgsPendingRemoteRetry;
            m_SmtpStats.NumSendRetries = AqPerf.cTotalMsgRemoteSendRetries;
            m_SmtpStats.NumNDRGenerated = AqPerf.cNDRsGenerated;
            m_SmtpStats.RetryQueueLength = AqPerf.cCurrentMsgsPendingLocalRetry;
            m_SmtpStats.NumDeliveryRetries = AqPerf.cTotalMsgLocalRetries;
            m_SmtpStats.ETRNMessages = AqPerf.cTotalMsgsTURNETRN;
			m_SmtpStats.CatQueueLength = AqPerf.cCurrentMsgsPendingCat;
            m_SmtpStats.MsgsBadmailNoRecipients = AqPerf.cTotalMsgsBadmailNoRecipients;
            m_SmtpStats.MsgsBadmailHopCountExceeded = AqPerf.cTotalMsgsBadmailHopCountExceeded;
            m_SmtpStats.MsgsBadmailFailureGeneral = AqPerf.cTotalMsgsBadmailFailureGeneral;
            m_SmtpStats.MsgsBadmailBadPickupFile = AqPerf.cTotalMsgsBadmailBadPickupFile;
            m_SmtpStats.MsgsBadmailEvent = AqPerf.cTotalMsgsBadmailEvent;
            m_SmtpStats.MsgsBadmailNdrOfDsn = AqPerf.cTotalMsgsBadmailNdrOfDsn;
            m_SmtpStats.MsgsPendingRouting = AqPerf.cCurrentMsgsPendingRouting;
            m_SmtpStats.MsgsPendingUnreachableLink = AqPerf.cCurrentMsgsPendingUnreachableLink;
            m_SmtpStats.SubmittedMessages = AqPerf.cTotalMsgsSubmitted;
            m_SmtpStats.DSNFailures = AqPerf.cTotalDSNFailures;
            m_SmtpStats.MsgsInLocalDelivery = AqPerf.cCurrentMsgsInLocalDelivery;
		}
	}

    CopyMemory( lpStat, &m_SmtpStats, sizeof(SMTP_STATISTICS_0) );

    UnlockStatistics();

    return ( NO_ERROR);

} // CopyToStatsBuffer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\strcscmp.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    strcscmp.cxx

Abstract:

    This module implements case insensitive string comparison routines.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     9-20-91     created

Notes:

    Exports:
        None

--*/

#include "smtpinc.h"

#ident "@(#)strcasecmp.c        5.3     3/8/91"

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  STRCASECMP.C
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/lib/net/0/s.strcasecmp.c
 *      @(#)strcasecmp.c        5.3
 *
 *      Last delta created      14:12:01 3/4/91
 *      This file extracted     11:20:35 3/8/91
 *
 *      Modifications:
 *
 *              GSS     24 Jul 90       New File
 */
/*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)strcasecmp.c        5.7 (Berkeley) 2/7/89";
#endif /* LIBC_SCCS and not lint */
/**************************************************************************/

#include <winsock.h>
//#include "winsockp.h"

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static char charmap[] = {
        '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
        '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
        '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
        '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
        '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
        '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
        '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
        '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
        '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
        '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
        '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
        '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
        '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
        '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
        '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
        '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
        '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
        '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
        '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
        '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317',
        '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327',
        '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
        '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
        '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
        '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
        '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

int
strcasecmp(
    char *s1,
    char *s2
    )
{
        char *cm = charmap;
        unsigned char *us1 = (unsigned char *)s1;
        unsigned char *us2 = (unsigned char *)s2;

        while (cm[*us1] == cm[*us2++])
                if (*us1++ == '\0')
                        return(0);
        return(cm[*us1] - cm[*--us2]);
}

int
strncasecmp(
    char *s1,
    char *s2,
    int   n
    )
{
        char *cm = charmap;
        unsigned char *us1 = (unsigned char *)s1;
        unsigned char *us2 = (unsigned char *)s2;

        while (--n >= 0 && cm[*us1] == cm[*us2++])
                if (*us1++ == '\0')
                        return(0);
        return(n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\timeconv.cxx ===
/* --------------------------------------------------------------------------
	timeconv.cpp
		Functions to perform various time conversion operations.
	
	Copyright (C) 1994, Microsoft Corporation.
	All rights reserved.

	Author:
		Lindsay Harris - lindsayh

   -------------------------------------------------------------------------- */

#include "smtpinc.h"
#include <time.h>
#include <string.h>
#include <dbgtrace.h>
#include "timeconv.h"

/*
 *   A handcrafted time zone string to GMT offsets table.  This is not
 *  a very good way to handle this.
 */

static  struct
{
	int		iTZOffset;		// Arithmetic offset from GMT, in seconds.
	char    rgchTZName[ 4 ];	// String representation of time zone.
} _TZ_NAME[] =
{
	{ 0, 		{ 'G', 'M', 'T', '\0' } },
	{ 0, 		{ 'U', 'T', 'C', '\0' } },
	{ 0, 		{ 'U', 'T', '\0', '\0' } },
	{ -14400,	{ 'E', 'D', 'T', '\0' } },
	{ -18000,	{ 'E', 'S', 'T', '\0' } },
	{ -18000,	{ 'C', 'D', 'T', '\0' } },
	{ -21600,	{ 'C', 'S', 'T', '\0' } },
	{ -21600,	{ 'M', 'D', 'T', '\0' } },
	{ -25200,	{ 'M', 'S', 'T', '\0' } },
	{ -25200,	{ 'P', 'D', 'T', '\0' } },
	{ -28800,	{ 'P', 'S', 'T', '\0' } },
	{  43200,	{ 'N', 'Z', 'S', '\0' } },	// NZ standard time.
	{  46800,	{ 'N', 'Z', 'D', '\0' } },
};

#define	NUM_TZ	(sizeof( _TZ_NAME ) / sizeof( _TZ_NAME[ 0 ] ))

// The date Jan 1, 1970 00:00:00 in type FILETIME
#define	ft1970high 27111902
#define	ft1970low 3577643008

static FILETIME ft1970 = {ft1970low, ft1970high};


// The number of FILETIME units (100's of nanoseconds) in a time_t unit (seconds)
#define dFiletimePerDTime_t 10000000

/*
 *   English language month table.
 */

static  char  *rgchMonth[ 12 ] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

/* -----------------------------------------------------------------------
  GetSysAndFileTimeAsString --s tring should be atleast 64 bytes

   ----------------------------------------------------------------------- */

void GetSysAndFileTimeAsString( char *achReturn )
{

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT

	GetSystemTime( &stUTC );

    FILETIME ft;

	// Convert from SYSTEMTIME to FILETIME
	SystemTimeToFileTime(&stUTC, &ft);

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%02d %s %04d %02d:%02d:%02d.%04d (UTC) FILETIME=[%08X:%08X]",
			  stUTC.wDay,
			  rgchMonth[ stUTC.wMonth - 1 ],
			  stUTC.wYear,
			  stUTC.wHour,
			  stUTC.wMinute,
			  stUTC.wSecond,
			  stUTC.wMilliseconds,
              ft.dwLowDateTime,
              ft.dwHighDateTime);
}

/* -----------------------------------------------------------------------
  GetArpaDate
  	Returns a pointer to static memory containing the current date in
  	Internet/ARPA standard format.

  Author
 	Lindsay Harris	- lindasyh

  History
	13:49 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version.
	Imported to Tigris. Added passed-in buffer, changed year to 4-digit format

   ----------------------------------------------------------------------- */


char  *
GetArpaDate( char achReturn[ cMaxArpaDate ] )
{

	char    chSign;							// Sign to print.

	DWORD   dwResult;

	int		iBias;							// Offset relative to GMT.

	TIME_ZONE_INFORMATION	tzi;			// Local time zone data.

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT



	dwResult = GetTimeZoneInformation( &tzi );
	GetLocalTime( &stUTC );

	//  Calculate the time zone offset.
	iBias = tzi.Bias;
	if( dwResult == TIME_ZONE_ID_DAYLIGHT )
		iBias += tzi.DaylightBias;
	
	/*
	 *   We always want to print the sign for the time zone offset, so
	 *  we decide what it is now and remember that when converting.
	 *  The convention is that west of the 0 degree meridian has a
	 *  negative offset - i.e. add the offset to GMT to get local time.
	 */

	if( iBias > 0 )
	{
		chSign = '-';		// Yes, I do mean negative.
	}
	else
	{
		iBias = -iBias;
		chSign = '+';
	}

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	_snprintf( achReturn, cMaxArpaDate , "%d %s %04d %02d:%02d:%02d %c%02d%02d",
			stUTC.wDay, rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wYear,
			stUTC.wHour, stUTC.wMinute, stUTC.wSecond, chSign,
			(iBias / 60) % 100, iBias % 60 );

	return achReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\timeconv.h ===
/*-------------------------------------------------------------------------
  timeconv.h
  	Function prototypes for time conversion functions.
  

  Copyright (C) 1994  Microsoft Corporation.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:08 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version, now that there are 2 time functions!

  --------------------------------------------------------------------------*/

#if  !defined( _TIMECONV_H )

#define	_TIMECONV_H


const DWORD cMaxArpaDate = 28;
/*
 *  Generate an ARPA/Internet time format string for current time.
 *  You must pass in a buffer of type char [cMaxArpaDate]
 */

char  *
GetArpaDate( char rgBuf[ cMaxArpaDate ] );

//
// 12/21/98 -- pgopi
// Get System time & file time in string format.
//

void GetSysAndFileTimeAsString( char *achReturn );


#endif		// _TIMECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpapi\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"

# if DBG

# include <stdio.h>
# include <stdlib.h>

# define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                              sprintf s ; \
                              OutputDebugStringA( rgchBuff); \
                            }
# define DBG_CONTEXT        ( rgchBuff)


# else // DBG


# define DBGPRINTF(s)     /* nothing */
# define DBG_CONTEXT      /* nothing */

# endif // DBG

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on s